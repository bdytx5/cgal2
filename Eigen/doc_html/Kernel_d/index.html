<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Kernel_d/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - dD Geometry Kernel: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - dD Geometry Kernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_dD_Geometry_Kernel"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Michael Seel</dd></dl>
<h1><a class="anchor" id="Kernel_dIntroduction"></a>
Introduction</h1>
<p>This part of the reference manual covers the higher-dimensional kernel. The kernel contains objects of constant size, such as point, vector, direction, line, ray, segment, circle. With each type comes a set of functions which can be applied to an object of this type. You will typically find access functions (e.g. to the coordinates of a point), tests of the position of a point relative to the object, a function returning the bounding box, the length, or the area of an object, and so on. The <span style="font-variant: small-caps;">CGAL</span> kernel further contains basic operations such as affine transformations, detection and computation of intersections, and distance computations. Note that this section partly recapitulates facts already mentioned for the lower-dimensional kernel.</p>
<h2><a class="anchor" id="Kernel_dRobustness"></a>
Robustness</h2>
<p>The correctness proof of nearly all geometric algorithms presented in theory papers assumes exact computation with real numbers. This leads to a fundamental problem with the implementation of geometric algorithms. Naively, often the exact real arithmetic is replaced by inexact floating-point arithmetic in the implementation. This often leads to acceptable results for many input data. However, even for the implementation of the simplest geometric algorithms this simplification occasionally does not work. Rounding errors introduced by inaccurate arithmetic may lead to inconsistent decisions, causing unexpected failures for some correct input data. There are many approaches to this problem, one of them is to compute exactly (compute so accurate that all decisions made by the algorithm are exact) which is possible in many cases but more expensive than standard floating-point arithmetic. C. M. Hoffmann <a class="el" href="citelist.html#CITEREF_h-gsm-89">[2]</a>, <a class="el" href="citelist.html#CITEREF_h-pargc-89">[1]</a> illustrates some of the problems arising in the implementation of geometric algorithms and discusses some approaches to solve them. A more recent overview is given in <a class="el" href="citelist.html#CITEREF_s-rpigc-00">[3]</a>. The exact computation paradigm is discussed by Yap and Dubé <a class="el" href="citelist.html#CITEREF_yd-ecp-95">[4]</a> and Yap <a class="el" href="citelist.html#CITEREF_y-tegc-97">[5]</a>.</p>
<p>In <span style="font-variant: small-caps;">CGAL</span> you can choose the underlying number types and arithmetic. You can use different types of arithmetic simultaneously and the choice can be easily changed, e.g. for testing. So you can choose between implementations with fast but occasionally inexact arithmetic and implementations guaranteeing exact computation and exact results. Of course you have to pay for the exactness in terms of execution time and storage space. See the dedicated chapter for more details on number types and their capabilities and performance.</p>
<h2><a class="anchor" id="Kernel_dGenericity"></a>
Genericity</h2>
<p>To increase generic usage of objects and predicates the higher-dimensional kernel makes heavy use of iterator ranges as defined in the STL for modeling tuples. Iterators conceptualize C++ pointers.</p>
<p>For an iterator range <code>[first,last)</code> we define <code>T = tuple [first,last)</code> as the ordered tuple \( (T[0],T[1], \ldots T[d-1])\) where \( S[i] = *++^{(i)}\mathit{first}\) (the element obtained by \( i\) times forwarding the iterator by operator <code>++</code> and then dereferencing it to get the value to which it points). We write <code>d = size [first,last)</code> and <code>S = set [first,last)</code> to denote the unordered set of elements of the corresponding tuple.</p>
<p>This extends the syntax of random access iterators to input iterators. If we index the tuple as above then we require that \( ++^{(d)}\mathit{first} = \mathit{last}\).</p>
<h1><a class="anchor" id="Kernel_dKernel"></a>
Kernel Representations</h1>
<p>Our object of study is the \( d\)-dimensional affine Euclidean space, where \( d\) is a parameter of our geometry. Objects in that space are sets of points. A common way to represent the points is the use of Cartesian coordinates, which assumes a reference frame (an origin and \( d\) orthogonal axes). In that framework, a point is represented by a \( d\)-tuple \( (c_0,c_1,\ldots,c_{d-1})\), and so are vectors in the underlying linear space. Each point is represented uniquely by such Cartesian coordinates.</p>
<p>Another way to represent points is by homogeneous coordinates. In that framework, a point is represented by a \( (d+1)\)-tuple \( (h_0,h_1,\ldots,h_d)\). Via the formulae \( c_i = h_i/h_d\), the corresponding point with Cartesian coordinates \( (c_0,c_1,\ldots,c_{d-1})\) can be computed. Note that homogeneous coordinates are not unique. For \( \lambda\ne 0\), the tuples \( (h_0,h_1,\ldots,h_d)\) and \( (\lambda\cdot h_0,\lambda\cdot h_1,\ldots,\lambda\cdot h_d)\) represent the same point. For a point with Cartesian coordinates \( (c_0,c_1,\ldots,c_{d-1})\) a possible homogeneous representation is \( (c_0,c_1,\ldots,c_{d-1},1)\). Homogeneous coordinates in fact allow to represent objects in a more general space, the projective space \( \mathbb{P}^d\). In <span style="font-variant: small-caps;">CGAL</span>, we do not compute in projective geometry. Rather, we use homogeneous coordinates to avoid division operations, since the additional coordinate can serve as a common denominator.</p>
<h2><a class="anchor" id="Kernel_dGenericitythroughParameterization"></a>
Genericity through Parameterization</h2>
<p>Almost all the kernel objects (and the corresponding functions) are templates with a parameter that allows the user to choose the representation of the kernel objects. A type that is used as an argument for this parameter must fulfill certain requirements on syntax and semantics. The list of requirements defines an abstract kernel concept. In <span style="font-variant: small-caps;">CGAL</span> such a kernel concept is often also called a <em>representation class</em> and denoted by <code>R</code>. A representation class provides the actual implementations of the kernel objects. For all kernel objects <code>Kernel_object</code> of a representation class <code>R</code> based on <code><a class="el" href="classCGAL_1_1Cartesian__d.html" title="A model for Kernel_d (and even KernelWithLifting_d) that uses Cartesian coordinates to represent the ...">Cartesian_d</a></code> or <code><a class="el" href="classCGAL_1_1Homogeneous__d.html" title="A model for a Kernel_d (and even KernelWithLifting_d) using homogeneous coordinates to represent the ...">Homogeneous_d</a></code>, the types <code>CGAL::Kernel_object&lt;R&gt;</code> and <code>R::Kernel_object</code> are identical.</p>
<p><span style="font-variant: small-caps;">CGAL</span> offers three families of concrete models for the concept representation class, two based on the Cartesian representation of points and one based on the homogeneous representation of points. The interface of the kernel objects is designed such that it works well with both Cartesian and homogeneous representation, for example, points have a constructor with a range of coordinates plus a common denominator (the \( d+1\) homogeneous coordinates of the point). The common interfaces parameterized with a representation class allow one to develop code independent of the chosen representation. We said "families" of models, because both families are parameterized too. A user can choose the number type used to represent the coordinates and the linear algebra module used to calculate the result of predicates and constructions.</p>
<p>For reasons that will become evident later, a representation class provides two typenames for number types, namely <code>R::FT</code> and <code>R::RT</code>. The type <code>R::FT</code> must fulfill the requirements on what is called a <em>field type</em> in <span style="font-variant: small-caps;">CGAL</span>. This roughly means that <code>R::FT</code> is a type for which operations \( +\), \( -\), \( *\) and \( /\) are defined with semantics (approximately) corresponding to those of a field in a mathematical sense. Note that, strictly speaking, the built-in type <code>int</code> does not fulfill the requirements on a field type, since <code>int</code>s correspond to elements of a ring rather than a field, especially operation \( /\) is not the inverse of \( *\). The requirements on the type <code>R::RT</code> are weaker. This type must fulfill the requirements on what is called a <em>Euclidean ring type</em> in <span style="font-variant: small-caps;">CGAL</span>. This roughly means that <code>R::RT</code> is a type for which operations \( +\), \( -\), \( *\) are defined with semantics (approximately) corresponding to those of a ring in a mathematical sense. A very limited division operation \( /\) must be available as well. It must work for exact (i.e., no remainder) integer divisions only. Furthermore, both number types should fulfill <span style="font-variant: small-caps;">CGAL</span>'s requirements on a number type.</p>
<h2><a class="anchor" id="Kernel_dCartesianKernel"></a>
Cartesian Kernel</h2>
<p>With <code><a class="el" href="classCGAL_1_1Cartesian__d.html" title="A model for Kernel_d (and even KernelWithLifting_d) that uses Cartesian coordinates to represent the ...">Cartesian_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>,LinearAlgebra&gt;</code> you can choose Cartesian representation of coordinates. The type <code>LinearAlgebra</code> must me a linear algebra module working on numbers of type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code>. The second parameter defaults to module delivered with the kernel so for short a user can just write <code><a class="el" href="classCGAL_1_1Cartesian__d.html" title="A model for Kernel_d (and even KernelWithLifting_d) that uses Cartesian coordinates to represent the ...">Cartesian_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>&gt;</code> when not providing her own linear algebra.</p>
<p>When you choose Cartesian representation you have to declare at least the type of the coordinates. A number type used with the <code><a class="el" href="classCGAL_1_1Cartesian__d.html" title="A model for Kernel_d (and even KernelWithLifting_d) that uses Cartesian coordinates to represent the ...">Cartesian_d</a></code> representation class should be a <em>field type</em> as described above. Both <code><a class="el" href="classCGAL_1_1Cartesian__d.html" title="A model for Kernel_d (and even KernelWithLifting_d) that uses Cartesian coordinates to represent the ...">Cartesian_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>&gt;::FT</code> and <code><a class="el" href="classCGAL_1_1Cartesian__d.html" title="A model for Kernel_d (and even KernelWithLifting_d) that uses Cartesian coordinates to represent the ...">Cartesian_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>&gt;::RT</code> are mapped to number type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code>. <code><a class="el" href="classCGAL_1_1Cartesian__d.html" title="A model for Kernel_d (and even KernelWithLifting_d) that uses Cartesian coordinates to represent the ...">Cartesian_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>,LinearAlgebra&gt;::LA</code> is mapped to the type <code>LinearAlgebra</code>. <code><a class="el" href="classCGAL_1_1Cartesian__d.html" title="A model for Kernel_d (and even KernelWithLifting_d) that uses Cartesian coordinates to represent the ...">Cartesian_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>&gt;</code> uses reference counting internally to save copying costs.</p>
<h2><a class="anchor" id="Kernel_dHomogeneousKernel"></a>
Homogeneous Kernel</h2>
<p>As we mentioned before, homogeneous coordinates permit to avoid division operations in numerical computations, since the additional coordinate can serve as a common denominator. Avoiding divisions can be useful for exact geometric computation. With <code><a class="el" href="classCGAL_1_1Homogeneous__d.html" title="A model for a Kernel_d (and even KernelWithLifting_d) using homogeneous coordinates to represent the ...">Homogeneous_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>,LinearAlgebra&gt;</code> you can choose homogeneous representation of coordinates with the kernel objects. As for Cartesian representation you have to declare at the same time the type used to store the homogeneous coordinates. Since the homogeneous representation allows one to avoid the divisions, the number type associated with a homogeneous representation class must be a model for the weaker concept Euclidean ring type only.</p>
<p>The type <code>LinearAlgebra</code> must me a linear algebra module working on numbers of type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a></code>. Again the second parameter defaults to module delivered with the kernel so for short one can just write <code><a class="el" href="classCGAL_1_1Homogeneous__d.html" title="A model for a Kernel_d (and even KernelWithLifting_d) using homogeneous coordinates to represent the ...">Homogeneous_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code> when replacing the default is no issue.</p>
<p>However, some operations provided by this kernel involve division operations, for example computing squared distances or returning a Cartesian coordinate. To keep the requirements on the number type parameter of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Homogeneous.html">Homogeneous</a></code> low, the number type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code> is used instead. This number type turns a ring type into a field type. It maintains numbers as quotients, i.e. a numerator and a denominator. Thereby, divisions are circumvented. With <code><a class="el" href="classCGAL_1_1Homogeneous__d.html" title="A model for a Kernel_d (and even KernelWithLifting_d) using homogeneous coordinates to represent the ...">Homogeneous_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code>, <code><a class="el" href="classCGAL_1_1Homogeneous__d.html" title="A model for a Kernel_d (and even KernelWithLifting_d) using homogeneous coordinates to represent the ...">Homogeneous_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;::FT</code> is equal to <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code> while <code><a class="el" href="classCGAL_1_1Homogeneous__d.html" title="A model for a Kernel_d (and even KernelWithLifting_d) using homogeneous coordinates to represent the ...">Homogeneous_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;::RT</code> is equal to <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a></code>. <code><a class="el" href="classCGAL_1_1Homogeneous__d.html" title="A model for a Kernel_d (and even KernelWithLifting_d) using homogeneous coordinates to represent the ...">Homogeneous_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>,LinearAlgebra&gt;::LA</code> is mapped to the type <code>LinearAlgebra</code>.</p>
<h2><a class="anchor" id="Kernel_dEpickKernel"></a>
Epick_d Kernel</h2>
<p>The kernel <code><a class="el" href="structCGAL_1_1Epick__d.html" title="A model for Kernel_d that uses Cartesian coordinates to represent the geometric objects. ">Epick_d</a>&lt;DimensionTag&gt;</code>, short for <em>Exact Predicates Inexact Constructions <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></em> is a kernel particularly useful when the dimension of the space is known at compile-time; The template parameter <code>DimensionTag</code> is then <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dimension__tag.html">Dimension_tag</a>&lt;d&gt;</code> where <code>d</code> is an integer representing the dimension. It may also be used with parameter <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dynamic__dimension__tag.html">Dynamic_dimension_tag</a></code>, in which case the dimension does not need to be known at compile-time. It uses a Cartesian representation and supports construction of points from <code>double</code> coordinates. It provides exact geometric predicates, but the geometric constructions are not guaranteed to be exact.</p>
<p>Note that it provides few interfaces in addition to those documented in the <code><a class="el" href="classKernel__d.html" title="The concept of a kernel is defined by a set of requirements on the provision of certain types and acc...">Kernel_d</a></code> concept. In particular, the type of a point is only available as <code><a class="el" href="structCGAL_1_1Epick__d.html" title="A model for Kernel_d that uses Cartesian coordinates to represent the geometric objects. ">Epick_d</a>&lt;DimensionTag&gt;::Point_d</code>, <b>not</b> <code><a class="el" href="classCGAL_1_1Point__d.html" title="An instance of data type Point_d&lt;Kernel&gt; is a point of Euclidean space in dimension ...">Point_d</a>&lt;<a class="el" href="structCGAL_1_1Epick__d.html" title="A model for Kernel_d that uses Cartesian coordinates to represent the geometric objects. ">Epick_d</a>&lt;DimensionTag&gt;&gt;</code>.</p>
<h2><a class="anchor" id="Kernel_dNamingconventions"></a>
Naming Conventions</h2>
<p>The use of representation classes does not only avoid problems, it also makes all <span style="font-variant: small-caps;">CGAL</span> classes very uniform. Like <code><a class="el" href="classCGAL_1_1Cartesian__d.html" title="A model for Kernel_d (and even KernelWithLifting_d) that uses Cartesian coordinates to represent the ...">Cartesian_d</a>&lt;double&gt;::Point_d</code>, they <b>always</b> consist of: </p><ol>
<li>
<p class="startli">The <em>capitalized base name</em> of the geometric object, such as <code>Point</code>, <code>Segment</code>, <code>Triangle</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Followed by <code>_d</code>.</p>
<p class="endli"></p>
</li>
<li>
A <em>representation class</em>, which itself may be parameterized with a number type, such as <code><a class="el" href="classCGAL_1_1Cartesian__d.html" title="A model for Kernel_d (and even KernelWithLifting_d) that uses Cartesian coordinates to represent the ...">Cartesian_d</a>&lt;double&gt;</code> or <code><a class="el" href="classCGAL_1_1Homogeneous__d.html" title="A model for a Kernel_d (and even KernelWithLifting_d) using homogeneous coordinates to represent the ...">Homogeneous_d</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__integer.html">leda_integer</a>&gt;</code>, where the type can be found, except for <code><a class="el" href="structCGAL_1_1Epick__d.html" title="A model for Kernel_d that uses Cartesian coordinates to represent the geometric objects. ">Epick_d</a>&lt;DimensionTag&gt;</code> where the number type is implicitly <code>double</code>. </li>
</ol>
<h2><a class="anchor" id="Kernel_dKernelasaTraitsClass"></a>
Kernel as a Traits Class</h2>
<p>Algorithms and data structures in the basic library of <span style="font-variant: small-caps;">CGAL</span> are parameterized by a traits class that subsumes the objects on which the algorithm or data structure operates as well as the operations to do so. For most of the algorithms and data structures in the basic library you can use a kernel as a traits class. For some algorithms you even do not have to specify the kernel; it is detected automatically using the types of the geometric objects passed to the algorithm. In some other cases, the algorithms or data structures need more than is provided by a kernel. In these cases, a kernel can not be used as a traits class.</p>
<h2><a class="anchor" id="Kernel_dChoosingaKernel"></a>
Choosing a Kernel</h2>
<p>If you start with integral Cartesian coordinates, many geometric computations will involve integral numerical values only. Especially, this is true for geometric computations that evaluate only predicates, which are tantamount to determinant computations. Examples are triangulation of point sets and convex hull computation.</p>
<p>The dimension \( d\) of our affine space determines the dimension of the matrix computations in the mathematical evaluation of predicates. As rounding errors accumulate fast the homogeneous representation used with multi-precision integers is the kernel of choice for well-behaved algorithms. Note, that unless you use an arbitrary precision integer type, incorrect results might arise due to overflow.</p>
<p>If new points are to be constructed, for example the intersection point of two lines, computation of Cartesian coordinates usually involves divisions, so you need to use a field type with Cartesian representation or have to switch to homogeneous representation. <code>double</code> is a possible, but imprecise field type. You can also put any ring type into <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a></code> to get a field type and put it into <code><a class="el" href="classCGAL_1_1Cartesian__d.html" title="A model for Kernel_d (and even KernelWithLifting_d) that uses Cartesian coordinates to represent the ...">Cartesian_d</a></code>, but you better put the ring type into <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Homogeneous.html">Homogeneous</a></code>. <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__rational.html">leda_rational</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__real.html">leda_real</a></code> are valid field types, too.</p>
<p>Still other people will prefer the built-in type <code>double</code>, because they need speed and can live with approximate results, or even algorithms that, from time to time, crash or compute incorrect results due to accumulated rounding errors.</p>
<p>The <code><a class="el" href="structCGAL_1_1Epick__d.html" title="A model for Kernel_d that uses Cartesian coordinates to represent the geometric objects. ">Epick_d</a></code> kernel provides a compromise using <code>double</code> coordinates. It evaluates predicates exactly, which is slower than plain <code>double</code> computations, but still faster than using an exact number type thanks to filtering techniques. Constructions are inexact, computed with <code>double</code>.</p>
<h2><a class="anchor" id="Kernel_dInclusionofHeaderFiles"></a>
Inclusion of Header Files</h2>
<p>You need just to include a representation class to obtain the geometric objects of the kernel that you would like to use with the representation class, i.e., <code>CGAL/Cartesian_d.h</code> or <code>CGAL/Homogeneous_d.h</code></p>
<h1><a class="anchor" id="Kernel_dKernel_1"></a>
Kernel Geometry</h1>
<h2><a class="anchor" id="Kernel_dPointsandVectors"></a>
Points and Vectors</h2>
<p>In <span style="font-variant: small-caps;">CGAL</span>, we strictly distinguish between points, vectors and directions. A <em>point</em> is a point in the Euclidean space \( \E^d\), a <em>vector</em> is the difference of two points \( p_2\), \( p_1\) and denotes the direction and the distance from \( p_1\) to \( p_2\) in the vector space \( \mathbb{R}^d\), and a <em>direction</em> is a vector where we forget about its length. They are different mathematical concepts. For example, they behave different under affine transformations and an addition of two points is meaningless in affine geometry. By putting them in different classes we not only get cleaner code, but also type checking by the compiler which avoids ambiguous expressions. Hence, it pays twice to make this distinction.</p>
<p><span style="font-variant: small-caps;">CGAL</span> defines a symbolic constant <code>ORIGIN</code> of type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Origin.html">Origin</a></code> which denotes the point at the origin. This constant is used in the conversion between points and vectors. Subtracting it from a point \( p\) results in the locus vector of \( p\).</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> coord[] = {1.0, 1.0, 1.0, 1.0};</div><div class="line">Cartesian_d&lt;double&gt;::Point_d p(4,coord,coord+4), q(4);</div><div class="line">Cartesian_d&lt;double&gt;::Vector_d v(4);</div><div class="line">v = p - <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a>;</div><div class="line">q = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a> + v; </div><div class="line">assert( p == q );</div></div><!-- fragment --><p>In order to obtain the point corresponding to a vector \( v\) you simply have to add \( v\) to <code>ORIGIN</code>. If you want to determine the point \( q\) in the middle between two points \( p_1\) and \( p_2\), you can write<span class="footnote">you might call <code>midpoint(p_1,p_2)</code> instead</span></p>
<div class="fragment"><div class="line">q = p_1 + (p_2 - p_1) / 2.0;</div></div><!-- fragment --><p>Note that these constructions do not involve any performance overhead for the conversion with the currently available representation classes.</p>
<h2><a class="anchor" id="Kernel_dKernelObjects"></a>
Kernel Objects</h2>
<p>Besides points (<code>R::Point_d</code>), vectors (<code>R::Vector_d</code>), and directions (<code>R::Direction_d</code>), <span style="font-variant: small-caps;">CGAL</span> provides lines, rays, segments, hyperplanes, and spheres.</p>
<p>Lines (<code>R::Line_d</code>) in <span style="font-variant: small-caps;">CGAL</span> are oriented. A ray (<code>R::Ray_d</code>) is a semi-infinite interval on a line, and this line is oriented from the finite endpoint of this interval towards any other point in this interval. A segment (<code>R::Segment_d</code>) is a bounded interval on a directed line, and the endpoints are ordered so that they induce the same direction as that of the line.</p>
<p>Hyperplanes are affine subspaces of dimension \( d-1\) in \( \E^d\), passing through \( d\) points. Hyperplanes are oriented and partition space into a positive side and a negative side. In <span style="font-variant: small-caps;">CGAL</span>, there are no special classes for halfspaces. Halfspaces are supposed to be represented by oriented hyperplanes. All kernel objects are equality comparable via <code>operator==</code> and <code>operator!=</code>. For those oriented objects whose orientation can be reversed (segments, lines, hyperplanes, spheres) there is also a global function <code><a class="el" href="classCGAL_1_1Hyperplane__d.html#a7de58b9954c8dd29537b2ac926f608e5" title="test for weak equality. ">weak_equality()</a></code> that allows to test for point set equality disregarding the orientation.</p>
<h2><a class="anchor" id="Kernel_dOrientationandRelativePosition"></a>
Orientation and Relative Position</h2>
<p>Geometric objects in <span style="font-variant: small-caps;">CGAL</span> have member functions that test the position of a point relative to the object. Full dimensional objects and their boundaries are represented by the same type, e.g. halfspaces and hyperplanes are not distinguished, neither are balls and spheres. Such objects split the ambient space into two full-dimensional parts, a bounded part and an unbounded part (e.g. spheres), or two unbounded parts (e.g. hyperplanes). By default these objects are oriented, i.e., one of the resulting parts is called the positive side, the other one is called the negative side. Both of these may be unbounded.</p>
<p>For these objects there is a function <code>oriented_side()</code> that determines whether a test point is on the positive side, the negative side, or on the oriented boundary. These function returns a value of type <code>Oriented_side</code>.</p>
<p>Those objects that split the space in a bounded and an unbounded part, have a member function <code>bounded_side()</code> with return type <code>Bounded_side</code>.</p>
<p>If an object is lower dimensional, e.g. a segment in \( d\)-dimensional space, there is only a test whether a point belongs to the object or not. This member function, which takes a point as an argument and returns a Boolean value, is called <code>has_on()</code></p>
<h1><a class="anchor" id="Kernel_dPredicates"></a>
Predicates and Constructions</h1>
<h2><a class="anchor" id="Kernel_dPredicates_1"></a>
Predicates</h2>
<p>Predicates are at the heart of a geometry kernel. They are basic units for the composition of geometric algorithms and encapsulate decisions. Hence their correctness is crucial for the control flow and hence for the correctness of an implementation of a geometric algorithm. <span style="font-variant: small-caps;">CGAL</span> uses the term predicate in a generalized sense. Not only components returning a Boolean value are called predicates but also components returning an enumeration type like a <code>Comparison_result</code> or an <code>Orientation</code>. We say components, because predicates are implemented both as functions and function objects (also called functors and provided by a kernel class).</p>
<p><span style="font-variant: small-caps;">CGAL</span> provides predicates for the orientation of point sets (<code>orientation</code>), for comparing points according to some given order, especially for comparing Cartesian coordinates (e.g. <code>lexicographically_xy_smaller</code>), in-sphere tests, and predicates to compare distances.</p>
<h2><a class="anchor" id="Kernel_dConstructions"></a>
Constructions</h2>
<p>Functions and function objects that generate objects that are neither of type <code>bool</code> nor enum types are called constructions. Constructions involve computation of new numerical values and may be imprecise due to rounding errors unless a kernel with an exact number type is used.</p>
<p>Affine transformations (<code>R::Aff_transformation_d</code>) allow to generate new object instances under arbitrary affine transformations. These transformations include translations, rotations (within planes) and scaling. Most of the geometric objects in a kernel have a member function <code>transform(Aff_transformation_d t)</code> which applies the transformation to the object instance.</p>
<p><span style="font-variant: small-caps;">CGAL</span> also provides a set of functions that detect or compute the intersection between objects and functions to calculate their squared distance. Moreover, some member functions of kernel objects are constructions.</p>
<p>So there are routines that compute the square of the Euclidean distance, but no routines that compute the distance itself. Why? First of all, the two values can be derived from each other quite easily (by taking the square root or taking the square). So, supplying only the one and not the other is only a minor inconvenience for the user. Second, often either value can be used. This is for example the case when (squared) distances are compared. Third, the library wants to stimulate the use of the squared distance instead of the distance. The squared distance can be computed in more cases and the computation is cheaper. We do this by not providing the perhaps more natural routine, The problem of a distance routine is that it needs the <code>sqrt</code> operation. This has two drawbacks: </p><ul>
<li>
The <code>sqrt</code> operation can be costly. Even if it is not very costly for a specific number type and platform, avoiding it is always cheaper. </li>
<li>
There are number types on which no <code>sqrt</code> operation is defined, especially integer types and rationals. </li>
</ul>
<h2><a class="anchor" id="Kernel_dIntersections"></a>
Intersections</h2>
<p>Intersections on kernel objects currently cover only those objects that are part of flats (<code>R::Segment_d</code>, <code>R::Ray_d</code>, <code>R::Line_d</code>, and <code>R::Hyperplane_d</code>). For any pair of objects \( o1\), \( o2\) of these types the operation <code>intersection(o1,o2)</code> returns a <code>boost::optional&lt; boost::variant&lt; T... &gt; &gt;</code> where <code>T...</code> is a list of all possible resulting geometric objects.</p>
<p>The exact result type of an intersection can be determined by using <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1cpp11_1_1result__of.html">cpp11::result_of</a>&lt;Kernel::Intersect_d(Type1, Type2)&gt;::type</code> where <code>Type1</code> and <code>Type2</code> are the types of the objects used in the intersection computation.</p>
<h3><a class="anchor" id="Kernel_dExample"></a>
Example</h3>
<p>In the following example, the object type is used as a return value for the intersection computation, as there are possibly different return values.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> Cartesian_d&lt;double&gt; K;</div><div class="line"><span class="keyword">typedef</span> Point_d&lt;K&gt; Point;</div><div class="line"><span class="keyword">typedef</span> Segment_d&lt;K&gt; Segment;</div><div class="line"></div><div class="line">Segment s1, s2;</div><div class="line">std::cin &gt;&gt; s1 &gt;&gt; s2;</div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1cpp11_1_1result__of.html#a0116f3bad73d2c51520c134dffbf1449">cpp11::result_of&lt;K::Intersect_d(Segment, Segment)&gt;::type</a></div><div class="line">  v = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__intersection__linear__grp.html#gab77f3cd98c4c4ff7acff59c98ab88ff0">intersection</a>(s1, s2);</div><div class="line"><span class="keywordflow">if</span>(v) {</div><div class="line">  <span class="comment">// not empty</span></div><div class="line">  <span class="keywordflow">if</span> (<span class="keyword">const</span> Point *p = boost::get&lt;Point&gt;(&amp;*v) ) {</div><div class="line">    <span class="comment">// do something with *p</span></div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <span class="keyword">const</span> Segment *s = boost::get&lt;Segment&gt;(&amp;*v) ) {</div><div class="line">    <span class="comment">// do something with *s</span></div><div class="line">  }</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">  <span class="comment">// empty intersection</span></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Kernel_dConstructivePredicates"></a>
Constructive Predicates</h2>
<p>For testing where a point \( p\) lies with respect to a hyperplane defined by an array \( P\) of points \( p_1\), ... , \( p_d\), one may be tempted to construct the hyperplane <code>R::Hyperplane_d(d,P,P+d)</code> and use the method <code>oriented_side(p)</code>. This may pay off if many tests with respect to the plane are made. Nevertheless, unless the number type is exact, the constructed plane is only approximated, and round-off errors may lead <code>oriented_side(p)</code> to return an orientation which is different from the orientation of \( p_1\), ... , \( p_d\), \( p\).</p>
<p>In <span style="font-variant: small-caps;">CGAL</span>, we provide predicates in which such geometric decisions are made directly with a reference to the input points in \( P\) without an intermediary object like a plane. For the above test, the recommended way to get the result is to use \(\mathrm{orientation}(P',P'+d)\), where \( P'\) is an array containing the points \( p_1\), ... , \( p_d\), \( p\).</p>
<p>For exact number types like <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__real.html">leda_real</a></code>, the situation is different. If several tests are to be made with the same plane, it pays off to construct the plane and to use <code>oriented_side(p)</code>.</p>
<h1><a class="anchor" id="Kernel_dDesign"></a>
Design and Implementation History</h1>
<p>This higher-dimensional kernel is the result of a long evolving development. A first version of the kernel was offered as a LEDA extension package ddgeo by Kurt Mehlhorn and Michael Seel. The original design was driven by the realization of a d-dimensional convex hull data type developed at the Max-Planck Institut für Informatik.</p>
<p>The code base was discussed and reviewed within the <span style="font-variant: small-caps;">CGAL</span> kernel group (of the low-dimensional kernel). This led to the identification of the concept interfaces and in parallel to adaptations according to the evolution of the low-dimensional kernel. The kernel was revised based on suggestions by Hervé Brönnimann, Michael Hoffmann, and Stefan Schirra.</p>
<p><a class="el" href="structCGAL_1_1Epick__d.html" title="A model for Kernel_d that uses Cartesian coordinates to represent the geometric objects. ">Epick_d</a> was added by Marc Glisse in 2014.</p>
<h2><a class="anchor" id="Kernel_dAcknowledgments"></a>
Acknowledgments</h2>
<p>This work was supported by ESPRIT IV Long Term Research Projects No. 21957 (<a class="el" href="namespaceCGAL.html">CGAL</a>) and No. 28155 (GALIA).</p>
<p>The <a class="el" href="structCGAL_1_1Epick__d.html" title="A model for Kernel_d that uses Cartesian coordinates to represent the geometric objects. ">Epick_d</a> kernel was partially supported by the IST Programme of the EU (FET Open) Project under Contract No IST-25582 – (CGL - Computational Geometric Learning). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:40 for CGAL 4.13 - dD Geometry Kernel by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
