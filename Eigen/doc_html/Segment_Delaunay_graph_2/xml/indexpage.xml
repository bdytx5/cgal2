<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Segment_Delaunay_Graphs"/><anchor id="index_1chaptersegdel2"/> <simplesect kind="author"><para>Menelaos Karavelas</para></simplesect>
This chapter describes the two-dimensional segment Delaunay graph package of CGAL. We start with a few definitions in Section <ref refid="index_1secsdg2definitions" kindref="member">Definitions</ref>. The software design of the 2D segment Delaunay graph package is described in Section <ref refid="index_1secsdg2design" kindref="member">Software Design</ref>. In Section <ref refid="index_1secsdg2traits" kindref="member">The Geometric Traits</ref> we discuss the geometric traits of the 2D segment Delaunay graph package and in Section <ref refid="index_1secsdg2hierarchy" kindref="member">The Segment Delaunay Graph Hierarchy</ref> the segment Delaunay graph hierarchy, a data structure suitable for fast nearest neighbor queries, is briefly described.</para><sect1 id="index_1secsdg2definitions">
<title>Definitions</title>
<para><anchor id="index_1fig__figsvd"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="svd-weakly-bw.jpg"></image>
 <image type="latex" name="svd-weakly-bw.jpg" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="svd-strongly-bw.png"></image>
 <image type="latex" name="svd-strongly-bw.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__figsvd" kindref="member">fig__figsvd</ref> The segment Voronoi diagram for a set of weakly (left) and strongly (right) intersecting sites.  <linebreak/>
</para><para>The 2D segment Delaunay graph package of CGAL is designed to compute the Delaunay graph of a set of possibly intersecting segments on the plane. Although we compute the Delaunay graph, we will often refer to its dual, the segment Voronoi diagram, since it is easier to explain and understand. The algorithm that has been implemented is incremental. The corresponding CGAL class is called <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound">Segment_Delaunay_graph_2</ref>&lt;<ref refid="classSegmentDelaunayGraphTraits__2" kindref="compound">SegmentDelaunayGraphTraits_2</ref>,SegmentDelaunayGraphStructure_2&gt;</computeroutput> and will be discussed in more detail in the sequel. The interested reader may want to refer to the paper by Karavelas <ref refid="citelist_1CITEREF_cgal:k-reisv-04" kindref="member">[4]</ref> for the general idea as well as the details of the algorithm implemented.</para><sect2 id="index_1Segment_Delaunay_graph_2Definitions">
<title>Definitions</title>
<para>Before describing the details of the implementation we make a brief introduction to the theory of segment Delaunay graphs and segment Voronoi diagrams. The segment Voronoi diagram is defined over a set of non-intersecting sites, which can either be points or linear segments, which we assume that are given through their endpoints. The segment Voronoi diagram a subdivision of the plane into connected regions, called <emphasis>cells</emphasis>, associated with the sites. The dual graph of the segment Voronoi diagram is called the segment Delaunay graph. The cell of a site <formula id="28">$ t_i$</formula> is the locus of points on the plane that are closer to <formula id="28">$ t_i$</formula> than any other site <formula id="29">$ t_j$</formula>, <formula id="30">$ j\neq i$</formula>. The distance <formula id="31">$ \delta(x, t_i)$</formula> of a point <formula id="18">$ x$</formula> in the plane to a site <formula id="28">$ t_i$</formula> is defined as the minimum of the Euclidean distances of <formula id="18">$ x$</formula> from the points in <formula id="28">$ t_i$</formula>. Hence, if <formula id="28">$ t_i$</formula> is a point <formula id="32">$ p_i$</formula>, then <formula id="33">\[ \delta(x,t_i)=\|x-t_i\|, \]</formula> whereas if <formula id="28">$ t_i$</formula>, is a segment, then <formula id="34">\[ \delta(x,t_i)=\min_{y\in t_i}\|x-y\|, \]</formula> where <formula id="35">$ \|\cdot\|$</formula> denotes the Euclidean norm. It can easily be seen that it is a generalization of the Voronoi diagram for points.</para><para>In many applications the restriction that sites are non-intersecting is too strict. Often we want to allow segments that touch at their endpoints, or even segments that overlap or intersect properly at their interior (for example, see <ref refid="index_1fig__figsvd" kindref="member">fig__figsvd</ref>). Allowing such configurations poses certain problems. More specifically, when we allow segments to touch at their endpoints we may end up with pairs of segments whose bisector is two-dimensional. If we allow pairs of segments that intersect properly at their interior, the interiors of their Voronoi cells are no longer simply connected. In both cases above the resulting Voronoi diagrams are no longer instances of abstract Voronoi diagrams (cf. <ref refid="citelist_1CITEREF_k-cavd-89" kindref="member">[5]</ref>), which has a direct consequence on the efficient computation of the corresponding Voronoi diagram. The remedy to these problems is to consider linear segments not as one object, but rather as three, namely the two endpoints and the interior. This choice guarantees that all bisectors in the Voronoi diagram are one-dimensional and that all Voronoi cells are simply connected. Moreover, we further distinguish between two cases, according to the type of intersecting pair that our input data set contains. A pair of sites is called <emphasis>weakly intersecting</emphasis> if they have a single common point and this common point does not lie in the interior of any of the two sites. A pair of sites is called <emphasis>strongly intersecting</emphasis> if they intersect and they either have more than one common point or their common point lies in the interior of at least one of the two sites. As it will be seen later the two cases have different representation (and thus storage) requirements, as well as they require a somehow different treatment on how the predicates are evaluated. Having made the distinction between weakly and strongly intersecting sites, and having said that segment sites are treated as three objects, we are now ready to precisely define the Delaunay graph we compute. Given a set <formula id="36">$ \mathcal{S}$</formula> of input sites, let <formula id="37">$ \mathcal{S}_{\mathcal{A}}$</formula> be the set of points and (open) segments in the arrangement <formula id="38">$ \mathcal{A}(\mathcal{S})$</formula> of <formula id="36">$ \mathcal{S}$</formula>. The 2D segment Delaunay graph package of CGAL computes the (triangulated) Delaunay graph that is dual to the Euclidean Voronoi diagram of the sites in the set <formula id="37">$ \mathcal{S}_{\mathcal{A}}$</formula>.</para><para>The segment Delaunay graph is uniquely defined once we have the segment Voronoi diagram. If the all sites are in <emphasis>general position</emphasis>, then Delaunay graph is a graph with triangular faces away from the convex hull of the set of sites. To unify our approach and handling of the Delaunay graph we add to the set of (finite) sites a fictitious site at infinity, which we call the <emphasis>site at infinity</emphasis>. We can then connect all vertices of the outer face of the Delaunay graph to the site at infinity which gives us a graph with the property that all of its faces are now triangular. However, the Delaunay graph is not a triangulation for two main reasons: we cannot always embed it on the plane with straight line segments that yield a triangulation and, moreover, we may have two faces of the graph that have two edges in common, which is not allowed in a triangulation.</para><para>We would like to finish our brief introduction to the theory of segment Delaunay graphs and segment Voronoi diagrams by discussing the concept of general position. We say that a set of sites is in general position if no two triplets of sites have the same tritangent Voronoi circle. This statement is rather technical and it is best understood in the context of points. The equivalent statement for points is that we have no two triplets of points that define the same circumcircle, or equivalently that no four points are co-circular. The statement about general position made above is a direct generalization of the (much simpler to understand) statement about points. On the contrary, when we have sites in degenerate position, the Delaunay graph has faces with more than three edges on their boundary. We can get a triangulated version of the Delaunay graph by simply <emphasis>triangulating</emphasis> the corresponding faces in an arbitrary way. In fact the algorithm that has been implemented in CGAL has the property that it always returns a valid <emphasis>triangulated</emphasis> version of the segment Delaunay graph. By valid we mean that it contains the actual (non-triangulated) Delaunay graph, and whenever there are faces with more than three faces then they are triangulated. The way that they are triangulated depends on the order of insertion of the sites in the diagram.</para><para>One final remark has to be made with respect to the difference between the set of <emphasis>input sites</emphasis> and the set of <emphasis>output sites</emphasis>. The set of input sites consists of the closed sites that the user inserts in the diagram. Since segment sites are treated as three objects, internally our algorithm sees only points and open segments. As a result, from the point of view of the algorithm, the input sites have no real meaning. What has real meaning is the set of sites that correspond to cells of the Voronoi diagram and this is the set of output sites.</para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_2DegenerateDimensions">
<title>Degenerate Dimensions</title>
<para>The dimension of the segment Delaunay graph is in general 2. The exceptions to this rule are as follows: <itemizedlist>
<listitem>
<para>The dimension is <formula id="0">$ -1$</formula> if the segment Delaunay graph contains no sites. </para></listitem>
<listitem>
<para>The dimension is <formula id="1">$ 0$</formula> if the segment Delaunay graph contains exactly one (output) site. </para></listitem>
<listitem>
<para>The dimension is <formula id="2">$ 1$</formula> is the segment Delaunay graph contains exactly two (output) sites. </para></listitem>
</itemizedlist>
</para></sect2>
</sect1>
<sect1 id="index_1secsdg2design">
<title>Software Design</title>
<para>The 2D segment Delaunay graph class <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound">Segment_Delaunay_graph_2</ref>&lt;<ref refid="classSegmentDelaunayGraphTraits__2" kindref="compound">SegmentDelaunayGraphTraits_2</ref>,<ref refid="classSegmentDelaunayGraphDataStructure__2" kindref="compound">SegmentDelaunayGraphDataStructure_2</ref>&gt;</computeroutput> follows the design of the triangulation package of CGAL. It is parametrized by two arguments: <itemizedlist>
<listitem>
<para>the <emphasis>geometric traits</emphasis> class. It provides the basic geometric objects involved in the algorithm, such as sites, points etc. It also provides the geometric predicates for the computation of the segment Delaunay graph, as well as some basic constructions that can be used, for example, to visualize the diagram. The geometric traits for the segment Delaunay graph will be discussed in more detail in the next section. </para></listitem>
<listitem>
<para>the <emphasis>segment Delaunay graph data structure</emphasis>. This is essentially the same as the Apollonius graph data structure (discussed in Chapter <ref refid="index_1secapollonius2design" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Apollonius_graph_2.tag">Software Design</ref> of 2D Apollonius Graph), augmented with some additional operations that are specific to segment Voronoi diagrams. The corresponding concept is that of <computeroutput><ref refid="classSegmentDelaunayGraphDataStructure__2" kindref="compound">SegmentDelaunayGraphDataStructure_2</ref></computeroutput>, which in fact is a refinement of the <computeroutput><ref refid="classApolloniusGraphDataStructure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Apollonius_graph_2.tag">ApolloniusGraphDataStructure_2</ref></computeroutput> concept. The class <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">Triangulation_data_structure_2</ref>&lt;Vb,Fb&gt;</computeroutput> is a model of the concept <computeroutput><ref refid="classSegmentDelaunayGraphDataStructure__2" kindref="compound">SegmentDelaunayGraphDataStructure_2</ref></computeroutput>. A default value for the corresponding template parameter is provided, so the user does not need to specify it. </para></listitem>
</itemizedlist>
</para><sect2 id="index_1Segment_Delaunay_graph_2StronglyIntersecting">
<title>Strongly Intersecting Sites and their Representation</title>
<para>As we have mentioned above, the segment Delaunay graph package of CGAL is designed to support the computation of the segment Voronoi diagram even when the input segment sites are intersecting. This choice poses certain issues for the design of the software package. The major concern is the representation of the subsegments that appear in the arrangement of the these sites, because the sites in the arrangement are the ones over which the diagram is actually defined. A direct consequence of the choice of representation is the algebraic degree of the predicates involved in the computation of the segment Delaunay graph, as well as the storage requirements for the subsegments and points on intersection in the arrangement.</para><para>The case of weakly intersecting sites does not require any special treatment. We can simply represent points by their coordinates and segments by their endpoints. In the case of strongly intersecting sites, the obvious choice to use the afore-mentioned representation has severe disadvantages. Consider two strongly intersecting segments <formula id="28">$ t_i$</formula> and <formula id="29">$ t_j$</formula>, whose endpoints have homogeneous coordinates of size <formula id="39">$ b$</formula>. Their intersection point will have homogeneous coordinates of bit size <formula id="40">$ 6b+O(1)$</formula>. This effect can be cascaded, which implies that after inserting <formula id="41">$ k$</formula> (input) segments we can arrive at having points of intersection whose bit sizes are exponential with respect to <formula id="41">$ k$</formula>, i.e., their homogeneous coordinates will have bit size <formula id="42">$ \Omega(2^kb)$</formula>. Not only the points of intersection, but also the adjacent subsegments will be represented by quantities of arbitrarily high bit size, and as a result we would not be able to give a bound on the bit sizes of the coordinates of the points of intersection. As a result, we would not be able to give a bound on the memory needed to store these coordinates. An equally important consequence is that we would also not be able to give a bound on the algebraic degree of the algebraic expressions involved in the evaluation of the predicates.</para><para>Such a behavior is obviously undesirable. For robustness, efficiency, and scalability purposes, it is critical that the bit size of the algebraic expressions in the predicates does not depend on the input size. For this reason, as well as for others to be discussed below, we decided to represent sites in a implicit manner, which somehow encodes the history of their construction. In particular, we exploit the fact that points of intersection always lie on two input segments, and that segments that are not part of the input are always supported by input segments.</para><para>For example, let us consider the configuration in <ref refid="index_1fig__figsdg2siterep" kindref="member">fig__figsdg2siterep</ref>. We assume that the segments <formula id="43">$ t_i=p_iq_i$</formula>, <formula id="44">$ i=1,2,3$</formula>, are inserted in that order. Upon the insertion of <formula id="45">$ t_2$</formula>, our algorithm will split the segment <formula id="46">$ t_1$</formula> into the subsegments <formula id="47">$ p_1s_1$</formula> and <formula id="48">$ s_1q_1$</formula>, then add <formula id="49">$ s_1$</formula>, and finally insert the subsegments <formula id="50">$ p_2s_1$</formula> and <formula id="51">$ s_1q_2$</formula>. How do we represent the five new sites? <formula id="49">$ s_1$</formula> will be represented by its two defining segments <formula id="46">$ t_1$</formula> and <formula id="45">$ t_2$</formula>. The segment <formula id="47">$ p_1s_1$</formula> will be represented by two segments, a point, and a Boolean. The first segment is <formula id="46">$ t_1$</formula>, which is always the segment with the same support as the newly created segment. The second segment is <formula id="45">$ t_2$</formula> and the point is <formula id="52">$ p_1$</formula>. The Boolean indicates whether the first endpoint of <formula id="47">$ p_1s_1$</formula> is an input point; in this case the Boolean is equal to <computeroutput>true</computeroutput>. The segment <formula id="48">$ s_1q_1$</formula> will also be represented by two segments, a point, and a Boolean, namely, <formula id="46">$ t_1$</formula> (the supporting segment of <formula id="48">$ s_1q_1$</formula>), <formula id="45">$ t_2$</formula> and <computeroutput>false</computeroutput> (it is the second endpoint of <formula id="48">$ s_1q_1$</formula> that is an input point). Subsegments <formula id="50">$ p_2s_1$</formula> and <formula id="51">$ s_1q_2$</formula> are represented analogously. Consider now what happens when we insert <formula id="53">$ t_3$</formula>. The point <formula id="54">$ s_2$</formula> will again be represented by two segments, but not <formula id="48">$ s_1q_1$</formula> and <formula id="53">$ t_3$</formula>. In fact, it will be represented by <formula id="46">$ t_1$</formula> (the supporting segment of <formula id="48">$ s_1q_1$</formula>) and <formula id="53">$ t_3$</formula>. <formula id="55">$ s_2q_1$</formula> will be represented by two segments, a point, and a Boolean ( <formula id="46">$ t_1$</formula>, <formula id="53">$ t_3$</formula>, <formula id="56">$ q1$</formula> and <computeroutput>false</computeroutput>), and similarly for <formula id="57">$ p_3s_2$</formula> and <formula id="58">$ s_2q_3$</formula>. On the other hand, both endpoints of <formula id="59">$ s_1s_2$</formula> are non-input points. In such a case we represent the segment by three input segments. More precisely, <formula id="59">$ s_1s_2$</formula> is represented by the segments <formula id="46">$ t_1$</formula> (the supporting segment of <formula id="48">$ s_1q_1$</formula>), <formula id="45">$ t_2$</formula> (it defines <formula id="49">$ s_1$</formula> along with <formula id="46">$ t_1$</formula>) and <formula id="53">$ t_3$</formula> (it defines <formula id="54">$ s_2$</formula> along with <formula id="46">$ t_1$</formula>).</para><para><anchor id="index_1fig__figsdg2siterep"/><image type="html" name="sdg-rep.png"></image>
 <image type="latex" name="sdg-rep.png" width="15cm"></image>
  <ref refid="index_1fig__figsdg2siterep" kindref="member">fig__figsdg2siterep</ref> Site representation. The point <formula id="49">$ s_1$</formula> is represented by the four points <formula id="52">$ p_1$</formula>, <formula id="60">$ q_1$</formula>, <formula id="61">$ p_2$</formula> and <formula id="62">$ q_2$</formula>. The segment <formula id="47">$ p_1s_1$</formula> is represented by the points <formula id="52">$ p_1$</formula>, <formula id="60">$ q_1$</formula>, <formula id="61">$ p_2$</formula>, <formula id="62">$ q_2$</formula> and a Boolean which is set to <computeroutput>true</computeroutput> to indicate that the first endpoint in not a point of intersection. The segment <formula id="59">$ s_1s_2$</formula> is represented by the six points: <formula id="52">$ p_1$</formula>, <formula id="60">$ q_1$</formula>, <formula id="61">$ p_2$</formula>, <formula id="62">$ q_2$</formula>, <formula id="63">$ p_3$</formula> and <formula id="64">$ q_3$</formula>. The remaining (non-input) points and segments in the figure are represented similarly.  <linebreak/>
</para><para>The five different presentations, two for points (coordinates; two input segments) and three for segments (two input points; two input segments, an input point and a Boolean; three input segments), form a closed set of representations and thus represent any point of intersection or subsegment regardless of the number of input segments. Moreover, every point (input or intersection) has homogeneous coordinates of bit size at most <formula id="65">$ 3b+O(1)$</formula>. The supporting lines of the segments (they are needed in some of the predicates) have coefficients which are always of bit size <formula id="66">$ 2b+O(1)$</formula>. As a result, the bit size of the expressions involved in our predicates will always be <formula id="67">$ O(b)$</formula>, independently of the size of the input. The <computeroutput><ref refid="classSegmentDelaunayGraphSite__2" kindref="compound">SegmentDelaunayGraphSite_2</ref></computeroutput> concept encapsulates the ideas presented above. A site is represented in this concept by up to four points and a Boolean, or up to six points, depending on its type. The class <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__site__2" kindref="compound">Segment_Delaunay_graph_site_2</ref>&lt;K&gt;</computeroutput> implements this concept.</para><para>Even this representation, however, has some degree of redundancy. The endpoint of a segment appears in both the representation of the (open) segment site as well as the representation of the point site itself. The situation becomes even worse in the presence of strongly intersecting sites: a point may appear in the representation of multiple subsegments and/or points of intersection. To avoid this redundancy, input points are stored in a container, and the various types of sites (input points and segments, points of intersection, subsegments with one or two points of intersection as endpoints) only store handles to the points in the container. This is achieved by the <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__storage__site__2" kindref="compound">Segment_Delaunay_graph_storage_site_2</ref>&lt;Gt&gt;</computeroutput> class which is a model of the corresponding concept: <computeroutput><ref refid="classSegmentDelaunayGraphStorageSite__2" kindref="compound">SegmentDelaunayGraphStorageSite_2</ref></computeroutput>. This concept enforces a site to be represented by up to 6 handles (which are very lightweight objects) instead of 6 points, which are, compared to handles of course, very heavy objects.</para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_2OptimizingMemory">
<title>Optimizing Memory Allocation</title>
<para>There are applications where we know beforehand that the input consists of only weakly intersecting sites. In these cases the site representation described above poses a significant overhead in the memory requirements of our implementation: instead of representing sites with up to two points (or ultimately with to two handles), we require sites to store six points (respectively, six handles). To avoid this overhead we have introduced two series of traits classes: <itemizedlist>
<listitem>
<para>One that supports the full-fledged sites, and is suitable when the input consists of strongly intersecting sites. This series consists of the <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__traits__2" kindref="compound">Segment_Delaunay_graph_traits_2</ref>&lt;K,MTag&gt;</computeroutput> and <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2" kindref="compound">Segment_Delaunay_graph_filtered_traits_2</ref>&lt;CK,CM,EK,EM,FK,FM&gt;</computeroutput> classes. </para></listitem>
<listitem>
<para>One that is customized for input that contain only weakly intersecting sites. This series consists of the <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__traits__without__intersections__2" kindref="compound">Segment_Delaunay_graph_traits_without_intersections_2</ref>&lt;K,MTag&gt;</computeroutput> and <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2" kindref="compound">Segment_Delaunay_graph_filtered_traits_without_intersections_2</ref>&lt;CK,CM,EK,EM,FK,FM&gt;</computeroutput> classes. </para></listitem>
</itemizedlist>
The advantages of having different traits classes are as follows: <itemizedlist>
<listitem>
<para>When the user chooses to use one of the traits classes in the second series we only store two handles per site. This implies a reduction by a factor of three in the memory allocated per site with respect to the first series of traits classes. </para></listitem>
<listitem>
<para>In the case of the first series of traits classes, we can better exploit the knowledge that have strongly intersecting sites, in order to further apply geometric filters (see below) during the evaluation of the predicates. On the contrary, if the second series of traits classes is used, we can avoid geometric filtering tests that have meaning only in the case of strongly intersecting sites. </para></listitem>
</itemizedlist>
</para></sect2>
</sect1>
<sect1 id="index_1secsdg2traits">
<title>The Geometric Traits</title>
<para>The predicates required for the computation of the segment Voronoi diagram are rather complicated. It is not the purpose of this document to discuss them in detail. The interested reader may refer to Burnikel&apos;s thesis <ref refid="citelist_1CITEREF_b-ecvdl-96" kindref="member">[2]</ref>, where it is shown that in the case of weakly intersecting sites represented in homogeneous coordinates of bit size <formula id="39">$ b$</formula>, the maximum bit size of the algebraic expressions involved in the predicates is <formula id="68">$ 40 b+O(1)$</formula>. Given our site representation given above we can guarantee that even in the case of strongly intersecting sites, the algebraic degree of the predicates remains <formula id="67">$ O(b)$</formula>, independently of the size of the input. What we want to focus in the remainder of this section are the different kinds of filtering techniques that we have employed in our implementation.</para><sect2 id="index_1Segment_Delaunay_graph_2GeometricFiltering">
<title>Geometric Filtering</title>
<para>Our representation of sites is coupled very naturally, with what we call <emphasis>geometric filtering</emphasis>. The technique amounts to performing simple geometric tests exploiting the representation of our data, as well as the geometric structure inherent in our problem, in order to evaluate predicates in seemingly degenerate configurations. Geometric filtering can be seen as a preprocessing step before performing arithmetic filtering. Roughly speaking, by arithmetic filtering we mean that we first try to evaluate the predicates using a fixed-precision floating-point number type (such as <computeroutput>double</computeroutput>), and at the same time keep error bounds on the numerical errors of the computations we perform. If the numerical errors are too big and do not permit us to evaluate the predicate, we switch to an exact number type, and repeat the evaluation of the predicate. Geometric filtering can help by eliminating situations in which the arithmetic filter will fail, thus decreasing the number of times we need to evaluate a predicate using exact arithmetic.</para><para>To illustrate the application and effectiveness of this approach, let us consider a very simple example usage. Suppose we want to determine if two non-input points are identical (we assume here that the input sites are represented by <computeroutput>double</computeroutput>s). In order to do that we need to compute their coordinates and compare them. If the two points are identical, the answer to our question using <computeroutput>double</computeroutput> arithmetic may be wrong (due to numerical errors), in which case we will have to reside to the more expensive exact computation. Instead, before testing the coordinates for equality, we can use the representation of the points to potentially answer the question. More specifically, and this is the geometric filtering part of the computation, we can first test if the defining segments of the two points are the same. If they are not, then we proceed to comparing their coordinates as usual. Testing the defining segments for equality does not involve any arithmetic operations on the input, but rather only comparisons on <computeroutput>double</computeroutput>s. By performing this very simple test we avoid a numerically difficult computation, which could be performed thousands of times during the computation of a Delaunay graph.</para><para>Geometric filtering has been implemented in all our models of the <computeroutput><ref refid="classSegmentDelaunayGraphTraits__2" kindref="compound">SegmentDelaunayGraphTraits_2</ref></computeroutput> concept. These models are the classes: <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__traits__2" kindref="compound">Segment_Delaunay_graph_traits_2</ref>&lt;K,MTag&gt;</computeroutput>, <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__traits__without__intersections__2" kindref="compound">Segment_Delaunay_graph_traits_without_intersections_2</ref>&lt;K,MTag&gt;</computeroutput>, <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2" kindref="compound">Segment_Delaunay_graph_filtered_traits_2</ref>&lt;CK,CM,EK,EM,FK,FM&gt;</computeroutput> and <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2" kindref="compound">Segment_Delaunay_graph_filtered_traits_without_intersections_2</ref>&lt;CK,CM,EK,EM,FK,FM&gt;</computeroutput>.</para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_2ArithmeticFiltering">
<title>Arithmetic Filtering</title>
<para>As mentioned above, performing computations with exact arithmetic can be very costly. For this reason we have devoted considerable effort in implementing different kinds of arithmetic filtering mechanisms. Presently, there two ways of performing arithmetic filtering for the predicates involved in the computation of segment Delaunay graphs: <orderedlist>
<listitem>
<para>The user can define his/her kernel using as number type, a number type of the form <computeroutput>Filtered_exact&lt;CT,ET&gt;</computeroutput>. Then this kernel can be entered as the first template parameter in the <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound">Segment_Delaunay_graph_2</ref>&lt;K,MTag&gt;</computeroutput>. </para></listitem>
<listitem>
<para>The user can define up to three different kernels <computeroutput>CK</computeroutput>, <computeroutput>FK</computeroutput> and <computeroutput>EK</computeroutput> (default values are provided for most parameters). The first kernel <computeroutput>CK</computeroutput> is used only for constructions. The second kernel <computeroutput>FK</computeroutput> is the filtering kernel: the traits class will attempt to compute the predicates using this kernel. If the filtering kernel fails to successfully compute a predicate, the exact kernel <computeroutput>EK</computeroutput> will be used. These three kernels are then used in the <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2" kindref="compound">Segment_Delaunay_graph_filtered_traits_2</ref>&lt;CK,CM,EK,EM,FK,FM&gt;</computeroutput> and <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2" kindref="compound">Segment_Delaunay_graph_filtered_traits_without_intersections_2</ref>&lt;CK,CM,EK,EM,FK,FM&gt;</computeroutput> classes, which have been implemented using the <computeroutput><ref refid="classCGAL_1_1Filtered__predicate" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Filtered_predicate</ref>&lt;EP,FP&gt;</computeroutput> mechanism. </para></listitem>
</orderedlist>
Our experience so far has shown that for all reasonable and valid values of the template parameters, the second method for arithmetic filtering is more efficient among the two.</para><para>Let&apos;s consider once more the class <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound">Segment_Delaunay_graph_2</ref>&lt;K,MTag&gt;</computeroutput>. The template parameter <computeroutput>MTag</computeroutput> provides another degree of freedom to the user, who can indicate the type of arithmetic operations to be used in the evaluation of the predicates. More specifically, <computeroutput>MTag</computeroutput> can be <computeroutput><ref refid="structCGAL_1_1Field__with__sqrt__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Field_with_sqrt_tag</ref></computeroutput>, in which case the predicates will be evaluated using all four basic arithmetic operations plus square roots; this requires, of course, that the number type used in the kernel <computeroutput>K</computeroutput> supports these operations exactly. Alternatively <computeroutput>MTag</computeroutput> can be <computeroutput><ref refid="structCGAL_1_1Field__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Field_tag</ref></computeroutput> This indicates that we want the predicates to be computed using only the four basic arithmetic operations. Again, for the predicates to be evaluated correctly, the number type used in the kernel <computeroutput>K</computeroutput> must support the corresponding operations exactly.</para><para>The semantics for the template parameters <computeroutput>CM</computeroutput>, <computeroutput>FM</computeroutput> and <computeroutput>EM</computeroutput> in the <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2" kindref="compound">Segment_Delaunay_graph_filtered_traits_2</ref>&lt;CK,CM,EK,EM,FK,FM&gt;</computeroutput> and <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2" kindref="compound">Segment_Delaunay_graph_filtered_traits_without_intersections_2</ref>&lt;CK,CM,EK,EM,FK,FM&gt;</computeroutput> classes are analogous. With each of these template parameters we can control the type of arithmetic operations that are going to be used in calculations involving each of the corresponding kernels <computeroutput>CK</computeroutput>, <computeroutput>FK</computeroutput> and <computeroutput>EK</computeroutput>. When the <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2" kindref="compound">Segment_Delaunay_graph_filtered_traits_2</ref>&lt;CK,CM,EK,EM,FK,FM&gt;</computeroutput> is used the possible values for <computeroutput>CM</computeroutput>, <computeroutput>FM</computeroutput> and <computeroutput>EM</computeroutput> are <computeroutput><ref refid="structCGAL_1_1Field__with__sqrt__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Field_with_sqrt_tag</ref></computeroutput> and <computeroutput><ref refid="structCGAL_1_1Field__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Field_tag</ref></computeroutput>, whereas if the <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2" kindref="compound">Segment_Delaunay_graph_filtered_traits_without_intersections_2</ref>&lt;CK,CM,EK,EM,FK,FM&gt;</computeroutput> class is used, the possible values are <computeroutput><ref refid="structCGAL_1_1Field__with__sqrt__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Field_with_sqrt_tag</ref></computeroutput> and <computeroutput><ref refid="structCGAL_1_1Euclidean__ring__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Euclidean_ring_tag</ref></computeroutput>.</para></sect2>
</sect1>
<sect1 id="index_1secsdg2hierarchy">
<title>The Segment Delaunay Graph Hierarchy</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__hierarchy__2" kindref="compound">Segment_Delaunay_graph_hierarchy_2</ref>&lt;<ref refid="classSegmentDelaunayGraphTraits__2" kindref="compound">SegmentDelaunayGraphTraits_2</ref>, SSTag, <ref refid="classSegmentDelaunayGraphDataStructure__2" kindref="compound">SegmentDelaunayGraphDataStructure_2</ref>&gt;</computeroutput> class is the analogue of the <computeroutput><ref refid="classCGAL_1_1Triangulation__hierarchy__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Triangulation_hierarchy_2</ref></computeroutput> or the <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__hierarchy__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Apollonius_graph_2.tag">Apollonius_graph_hierarchy_2</ref></computeroutput> classes, applied to the segment Delaunay graph. It consists of a hierarchy of segment Delaunay graphs constructed in a manner analogous to the Delaunay hierarchy by Devillers <ref refid="citelist_1CITEREF_cgal:d-dh-02" kindref="member">[3]</ref>. Unlike the triangulation hierarchy or the Apollonius graph hierarchy, the situation here is more complicated because of two factors: firstly, segments are treated as three objects instead of one (the two endpoints and the interior of the segments), and secondly, the presence of strongly intersecting sites complicates significantly the way the hierarchy is constructed. The interested reader may refer to the paper by Karavelas <ref refid="citelist_1CITEREF_cgal:k-reisv-04" kindref="member">[4]</ref> for the details of the construction of the hierarchy. Another alternative is to have a hybrid hierarchy that consists of the segment Delaunay graph at the bottom-most level and point Voronoi diagrams at all other levels. This choice seems to work very well in practice , primarily because it avoids the overhead of maintaining a Delaunay graph for segments at the upper levels of the hierarchy. However, it seems much less likely to be possible to give any theoretical guarantees for its performance, in contrast to the hierarchy with segment Delaunay graphs at all levels (cf. <ref refid="citelist_1CITEREF_cgal:k-reisv-04" kindref="member">[4]</ref>). The user can choose between the two types of hierarchies by means of the template parameter <computeroutput>SSTag</computeroutput>. If <computeroutput>SSTag</computeroutput> is set to <computeroutput>false</computeroutput> (which is also the default value), the upper levels of the hierarchy consist of point Delaunay graphs. If <computeroutput>SSTag</computeroutput> is set to <computeroutput>true</computeroutput>, we have segment Delaunay graphs at all levels of the hierarchy.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__hierarchy__2" kindref="compound">Segment_Delaunay_graph_hierarchy_2</ref>&lt;<ref refid="classSegmentDelaunayGraphTraits__2" kindref="compound">SegmentDelaunayGraphTraits_2</ref>, SSTag, <ref refid="classSegmentDelaunayGraphDataStructure__2" kindref="compound">SegmentDelaunayGraphDataStructure_2</ref>&gt;</computeroutput> has exactly the same interface and functionality as the <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound">Segment_Delaunay_graph_2</ref>&lt;<ref refid="classSegmentDelaunayGraphTraits__2" kindref="compound">SegmentDelaunayGraphTraits_2</ref>,<ref refid="classSegmentDelaunayGraphDataStructure__2" kindref="compound">SegmentDelaunayGraphDataStructure_2</ref>&gt;</computeroutput> class. Using the segment Delaunay graph hierarchy involves an additional cost in space and time for maintaining the hierarchy. Our experiments have shown that it usually pays off to use the hierarchy for inputs consisting of more than about 1,000 sites.</para></sect1>
<sect1 id="index_1secsdg2examples">
<title>Examples</title>
<sect2 id="index_1Segment_Delaunay_graph_2FirstExample">
<title>First Example using the Filtered Traits</title>
<para>The following example shows how to use the segment Delaunay graph traits in conjunction with the <computeroutput>Filtered_exact&lt;CT,ET&gt;</computeroutput> mechanism. In addition it shows how to use a few of the iterators provided by the <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound">Segment_Delaunay_graph_2</ref></computeroutput> class in order to count a few site-related quantities.</para><para><linebreak/>
<bold>File</bold> <ref refid="Segment_Delaunay_graph_2_2sdg-count-sites_8cpp-example" kindref="compound">Segment_Delaunay_graph_2/sdg-count-sites.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>define<sp/>the<sp/>input<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/>CK;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_filtered_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2" kindref="compound">CGAL::Segment_Delaunay_graph_filtered_traits_2</ref>&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CK,<ref refid="structCGAL_1_1Field__with__sqrt__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::Field_with_sqrt_tag</ref>&gt;<sp/><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound">CGAL::Segment_Delaunay_graph_2&lt;Gt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SDG2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespacestd" kindref="compound">std</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifstream<sp/>ifs(</highlight><highlight class="stringliteral">&quot;data/sitesx.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Site_2<sp/><sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{<sp/>sdg.insert(<sp/>site<sp/>);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifs.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>sdg.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>the<sp/>number<sp/>of<sp/>input<sp/>and<sp/>output<sp/>sites</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>input<sp/>sites<sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>sdg.number_of_input_sites()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>output<sp/>sites:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>sdg.number_of_output_sites()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n_ipt(0),<sp/>n_iseg(0),<sp/>n_opt(0),<sp/>n_oseg(0),<sp/>n_ptx(0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>count<sp/>the<sp/>number<sp/>of<sp/>input<sp/>points<sp/>and<sp/>input<sp/>segments</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Input_sites_iterator<sp/>iit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(iit<sp/>=<sp/>sdg.input_sites_begin();<sp/>iit<sp/>!=<sp/>sdg.input_sites_end();<sp/>++iit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>iit-&gt;is_point()<sp/>)<sp/>{<sp/>n_ipt++;<sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{<sp/>n_iseg++;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>count<sp/>the<sp/>number<sp/>of<sp/>output<sp/>points<sp/>and<sp/>output<sp/>segments,<sp/>as<sp/>well</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>as<sp/>the<sp/>number<sp/>of<sp/>points<sp/>that<sp/>are<sp/>points<sp/>of<sp/>intersection<sp/>of<sp/>pairs</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>of<sp/>strongly<sp/>intersecting<sp/>sites</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Output_sites_iterator<sp/>oit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(oit<sp/>=<sp/>sdg.output_sites_begin();<sp/>oit<sp/>!=<sp/>sdg.output_sites_end();<sp/>++oit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>oit-&gt;is_segment()<sp/>)<sp/>{<sp/>n_oseg++;<sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n_opt++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!oit-&gt;is_input()<sp/>)<sp/>{<sp/>n_ptx++;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>input<sp/>segments:<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n_iseg<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>input<sp/>points:<sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n_ipt<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>output<sp/>segments:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n_oseg<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>output<sp/>points:<sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n_opt<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>intersection<sp/>points:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n_ptx<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_2FastSP">
<title>Using Spatial Sorting to Speed up Insertion</title>
<para>If you have a rather large input, you better use an insertion function that uses the spatial sorting of your input (end) points. Note that the functions <ref refid="classCGAL_1_1Segment__Delaunay__graph__2_1af190978a7ec3bdc26e96566548c11f63" kindref="member"><computeroutput>insert_points</computeroutput> </ref> or <ref refid="classCGAL_1_1Segment__Delaunay__graph__2_1a896a91e35dabbeb3463ae428e21da5a5" kindref="member"><computeroutput>insert_segments</computeroutput> </ref> can be used if your input is only composed of points or segments.</para><para><linebreak/>
<bold>File</bold> <ref refid="Segment_Delaunay_graph_2_2sdg-fast-sp_8cpp-example" kindref="compound">Segment_Delaunay_graph_2/sdg-fast-sp.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>that<sp/>uses<sp/>the<sp/>filtered<sp/>traits,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph<sp/>and<sp/>the<sp/>spatial<sp/>sorting</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>choose<sp/>the<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_filtered_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2" kindref="compound">CGAL::Segment_Delaunay_graph_filtered_traits_without_intersections_2&lt;K&gt;</ref><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound">CGAL::Segment_Delaunay_graph_2&lt;Gt&gt;</ref><sp/><sp/>SDG2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>ifs(</highlight><highlight class="stringliteral">&quot;data/sites.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Site_2<sp/><sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;SDG2::Site_2&gt;<sp/>sites;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>the<sp/>sites</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sites.push_back(site);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//insert<sp/>the<sp/>sites<sp/>all<sp/>at<sp/>once<sp/>using<sp/>spatial<sp/>sorting<sp/>to<sp/>speed<sp/>the<sp/>insertion</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sdg.insert(<sp/>sites.begin(),<sp/>sites.end(),<ref refid="group__PkgStlExtensionUtilities_1gab3e2296107b5d26c32c8183028a217f1" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Tag_true</ref>()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>sdg.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_2FastSPPolygon">
<title>Delaunay Graph of a Polygon</title>
<para>This example shows how to efficiently compute the Delaunay graph of a simple polygon using the spatial sorting to speed up the insertion.</para><para><linebreak/>
<bold>File</bold> <ref refid="Segment_Delaunay_graph_2_2sdg-fast-sp-polygon_8cpp-example" kindref="compound">Segment_Delaunay_graph_2/sdg-fast-sp-polygon.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>that<sp/>uses<sp/>the<sp/>filtered<sp/>traits,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph<sp/>and<sp/>the<sp/>spatial<sp/>sorting</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>choose<sp/>the<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_filtered_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2" kindref="compound">CGAL::Segment_Delaunay_graph_filtered_traits_without_intersections_2&lt;K&gt;</ref><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound">CGAL::Segment_Delaunay_graph_2&lt;Gt&gt;</ref><sp/><sp/>SDG2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>ifs(</highlight><highlight class="stringliteral">&quot;data/sites.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//polygon<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Gt::Point_2&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//segments<sp/>of<sp/>the<sp/>polygon<sp/>as<sp/>a<sp/>pair<sp/>of<sp/>point<sp/>indices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::pair&lt;std::size_t,std::size_t&gt;<sp/>&gt;<sp/>indices;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Site_2<sp/>site;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//read<sp/>a<sp/>close<sp/>polygon<sp/>given<sp/>by<sp/>its<sp/>segments</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>s<sp/>x0<sp/>y0<sp/>x1<sp/>y1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>s<sp/>x1<sp/>y1<sp/>x2<sp/>y2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>s<sp/>xn<sp/>yn<sp/>x0<sp/>y0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifs<sp/>&gt;&gt;<sp/>site;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>site.is_segment()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>site.source_of_supporting_site()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>k=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>site.is_segment()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points.push_back(<sp/>site.source_of_supporting_site()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indices.push_back(<sp/>std::make_pair(k,<sp/>k+1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(<sp/>std::make_pair(k,<sp/>0)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifs.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//insert<sp/>the<sp/>polygon<sp/>segments<sp/>all<sp/>at<sp/>once<sp/>using<sp/>spatial<sp/>sorting<sp/>to<sp/>speed<sp/>the<sp/>insertion</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sdg.insert_segments(<sp/>points.begin(),<sp/>points.end(),<sp/>indices.begin(),<sp/>indices.end()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>sdg.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_2ExHierachy">
<title>Using the Hierarchy for Faster Location</title>
<para>The following example shows how to use the segment Delaunay graph hierarchy along with the filtered traits class that supports intersecting sites.</para><para><linebreak/>
<bold>File</bold> <ref refid="Segment_Delaunay_graph_2_2sdg-filtered-traits_8cpp-example" kindref="compound">Segment_Delaunay_graph_2/sdg-filtered-traits.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>that<sp/>uses<sp/>the<sp/>filtered<sp/>traits<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph<sp/>hierarchy</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>choose<sp/>the<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_hierarchy_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_filtered_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2" kindref="compound">CGAL::Segment_Delaunay_graph_filtered_traits_2&lt;K&gt;</ref><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Segment__Delaunay__graph__hierarchy__2" kindref="compound">CGAL::Segment_Delaunay_graph_hierarchy_2&lt;Gt&gt;</ref><sp/><sp/>SDG2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>ifs(</highlight><highlight class="stringliteral">&quot;data/sites.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Site_2<sp/><sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>the<sp/>sites<sp/>and<sp/>insert<sp/>them<sp/>in<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sdg.insert(site);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>sdg.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_2ExVorEdges">
<title>Voronoi Edges</title>
<para>The following example demonstrates how to recover the defining sites for the edges of the Voronoi diagram (which are the duals of the edges of the segment Delaunay graph computed).</para><para><linebreak/>
<bold>File</bold> <ref refid="Segment_Delaunay_graph_2_2sdg-voronoi-edges_8cpp-example" kindref="compound">Segment_Delaunay_graph_2/sdg-voronoi-edges.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>define<sp/>the<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Filtered_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/>CK;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Filtered__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Filtered_kernel&lt;CK&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Segment__Delaunay__graph__traits__2" kindref="compound">CGAL::Segment_Delaunay_graph_traits_2&lt;Kernel&gt;</ref><sp/><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound">CGAL::Segment_Delaunay_graph_2&lt;Gt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SDG2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespacestd" kindref="compound">std</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifstream<sp/>ifs(</highlight><highlight class="stringliteral">&quot;data/sites2.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Site_2<sp/><sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>the<sp/>sites<sp/>from<sp/>the<sp/>stream<sp/>and<sp/>insert<sp/>them<sp/>in<sp/>the<sp/>diagram</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{<sp/>sdg.insert(<sp/>site<sp/>);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifs.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>diagram</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>sdg.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>now<sp/>walk<sp/>through<sp/>the<sp/>non-infinite<sp/>edges<sp/>of<sp/>the<sp/>segment<sp/>Delaunay</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>graphs<sp/>(which<sp/>are<sp/>dual<sp/>to<sp/>the<sp/>edges<sp/>in<sp/>the<sp/>Voronoi<sp/>diagram)<sp/>and</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>print<sp/>the<sp/>sites<sp/>defining<sp/>each<sp/>Voronoi<sp/>edge.</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>Each<sp/>oriented<sp/>Voronoi<sp/>edge<sp/>(horizontal<sp/>segment<sp/>in<sp/>the<sp/>figure</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>below)<sp/>is<sp/>defined<sp/>by<sp/>four<sp/>sites<sp/>A,<sp/>B,<sp/>C<sp/>and<sp/>D.</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/>\<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/>\<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/>\<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/>C<sp/><sp/>-----------------<sp/><sp/>D</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/>/<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/>/<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>A<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/>/<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>The<sp/>sites<sp/>A<sp/>and<sp/>B<sp/>define<sp/>the<sp/>(oriented)<sp/>bisector<sp/>on<sp/>which<sp/>the</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>edge<sp/>lies<sp/>whereas<sp/>the<sp/>sites<sp/>C<sp/>and<sp/>D,<sp/>along<sp/>with<sp/>A<sp/>and<sp/>B<sp/>define</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>the<sp/>two<sp/>endpoints<sp/>of<sp/>the<sp/>edge.<sp/>These<sp/>endpoints<sp/>are<sp/>the<sp/>Voronoi</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>vertices<sp/>of<sp/>the<sp/>triples<sp/>A,<sp/>B,<sp/>C<sp/>and<sp/>B,<sp/>A,<sp/>D.</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>If<sp/>one<sp/>of<sp/>these<sp/>vertices<sp/>is<sp/>the<sp/>vertex<sp/>at<sp/>infinity<sp/>the<sp/>string</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>&quot;infinite<sp/>vertex&quot;<sp/>is<sp/>printed;<sp/>the<sp/>corresponding<sp/>Voronoi<sp/>edge<sp/>is</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>actually<sp/>a<sp/>stright-line<sp/>or<sp/>parabolic<sp/>ray.</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>The<sp/>sites<sp/>below<sp/>are<sp/>printed<sp/>in<sp/>the<sp/>order<sp/>A,<sp/>B,<sp/>C,<sp/>D.</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>inf_vertex(</highlight><highlight class="stringliteral">&quot;infinite<sp/>vertex&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>vid[]<sp/>=<sp/>{</highlight><highlight class="charliteral">&apos;A&apos;</highlight><highlight class="normal">,<sp/></highlight><highlight class="charliteral">&apos;B&apos;</highlight><highlight class="normal">,<sp/></highlight><highlight class="charliteral">&apos;C&apos;</highlight><highlight class="normal">,<sp/></highlight><highlight class="charliteral">&apos;D&apos;</highlight><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Finite_edges_iterator<sp/>eit<sp/>=<sp/>sdg.finite_edges_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>1;<sp/>eit<sp/>!=<sp/>sdg.finite_edges_end();<sp/>++eit,<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SDG2::Edge<sp/>e<sp/>=<sp/>*eit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>get<sp/>the<sp/>vertices<sp/>defining<sp/>the<sp/>Voronoi<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SDG2::Vertex_handle<sp/>v[]<sp/>=<sp/>{<sp/>e.first-&gt;vertex(<sp/>sdg.ccw(e.second)<sp/>),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>e.first-&gt;vertex(<sp/>sdg.cw(e.second)<sp/>),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>e.first-&gt;vertex(<sp/>e.second<sp/>),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg.tds().mirror_vertex(e.first,<sp/>e.second)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;---<sp/>Edge<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>---&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>4;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>if<sp/>the<sp/>vertex<sp/>is<sp/>the<sp/>vertex<sp/>at<sp/>infinity;<sp/>if<sp/>yes,<sp/>print</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>corresponding<sp/>string,<sp/>otherwise<sp/>print<sp/>the<sp/>site</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>sdg.is_infinite(v[i])<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>vid[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>inf_vertex<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>vid[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>v[i]-&gt;site()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
