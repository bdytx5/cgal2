<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Segment_Delaunay_graph_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Segment Delaunay Graphs: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Segment Delaunay Graphs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Segment_Delaunay_Graphs"></a><a class="anchor" id="chaptersegdel2"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Menelaos Karavelas</dd></dl>
<p>This chapter describes the two-dimensional segment Delaunay graph package of <span style="font-variant: small-caps;">CGAL</span>. We start with a few definitions in Section <a class="el" href="index.html#secsdg2definitions">Definitions</a>. The software design of the 2D segment Delaunay graph package is described in Section <a class="el" href="index.html#secsdg2design">Software Design</a>. In Section <a class="el" href="index.html#secsdg2traits">The Geometric Traits</a> we discuss the geometric traits of the 2D segment Delaunay graph package and in Section <a class="el" href="index.html#secsdg2hierarchy">The Segment Delaunay Graph Hierarchy</a> the segment Delaunay graph hierarchy, a data structure suitable for fast nearest neighbor queries, is briefly described.</p>
<h1><a class="anchor" id="secsdg2definitions"></a>
Definitions</h1>
<p><a class="anchor" id="fig__figsvd"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="svd-weakly-bw.jpg" alt="svd-weakly-bw.jpg" />
</div>
   </td><td><div class="image">
<img src="svd-strongly-bw.png" alt="svd-strongly-bw.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__figsvd">Figure 48.1</a> The segment Voronoi diagram for a set of weakly (left) and strongly (right) intersecting sites.  </div>  <br />

<p>The 2D segment Delaunay graph package of <span style="font-variant: small-caps;">CGAL</span> is designed to compute the Delaunay graph of a set of possibly intersecting segments on the plane. Although we compute the Delaunay graph, we will often refer to its dual, the segment Voronoi diagram, since it is easier to explain and understand. The algorithm that has been implemented is incremental. The corresponding <span style="font-variant: small-caps;">CGAL</span> class is called <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html" title="The class Segment_Delaunay_graph_2 represents the segment Delaunay graph (which is the dual graph of ...">Segment_Delaunay_graph_2</a>&lt;<a class="el" href="classSegmentDelaunayGraphTraits__2.html">SegmentDelaunayGraphTraits_2</a>,SegmentDelaunayGraphStructure_2&gt;</code> and will be discussed in more detail in the sequel. The interested reader may want to refer to the paper by Karavelas <a class="el" href="citelist.html#CITEREF_cgal:k-reisv-04">[4]</a> for the general idea as well as the details of the algorithm implemented.</p>
<h2><a class="anchor" id="Segment_Delaunay_graph_2Definitions"></a>
Definitions</h2>
<p>Before describing the details of the implementation we make a brief introduction to the theory of segment Delaunay graphs and segment Voronoi diagrams. The segment Voronoi diagram is defined over a set of non-intersecting sites, which can either be points or linear segments, which we assume that are given through their endpoints. The segment Voronoi diagram a subdivision of the plane into connected regions, called <em>cells</em>, associated with the sites. The dual graph of the segment Voronoi diagram is called the segment Delaunay graph. The cell of a site \( t_i\) is the locus of points on the plane that are closer to \( t_i\) than any other site \( t_j\), \( j\neq i\). The distance \( \delta(x, t_i)\) of a point \( x\) in the plane to a site \( t_i\) is defined as the minimum of the Euclidean distances of \( x\) from the points in \( t_i\). Hence, if \( t_i\) is a point \( p_i\), then </p><p class="formulaDsp">
\[ \delta(x,t_i)=\|x-t_i\|, \]
</p>
<p> whereas if \( t_i\), is a segment, then </p><p class="formulaDsp">
\[ \delta(x,t_i)=\min_{y\in t_i}\|x-y\|, \]
</p>
<p> where \( \|\cdot\|\) denotes the Euclidean norm. It can easily be seen that it is a generalization of the Voronoi diagram for points.</p>
<p>In many applications the restriction that sites are non-intersecting is too strict. Often we want to allow segments that touch at their endpoints, or even segments that overlap or intersect properly at their interior (for example, see <a class="el" href="index.html#fig__figsvd">Figure 48.1</a>). Allowing such configurations poses certain problems. More specifically, when we allow segments to touch at their endpoints we may end up with pairs of segments whose bisector is two-dimensional. If we allow pairs of segments that intersect properly at their interior, the interiors of their Voronoi cells are no longer simply connected. In both cases above the resulting Voronoi diagrams are no longer instances of abstract Voronoi diagrams (cf. <a class="el" href="citelist.html#CITEREF_k-cavd-89">[5]</a>), which has a direct consequence on the efficient computation of the corresponding Voronoi diagram. The remedy to these problems is to consider linear segments not as one object, but rather as three, namely the two endpoints and the interior. This choice guarantees that all bisectors in the Voronoi diagram are one-dimensional and that all Voronoi cells are simply connected. Moreover, we further distinguish between two cases, according to the type of intersecting pair that our input data set contains. A pair of sites is called <em>weakly intersecting</em> if they have a single common point and this common point does not lie in the interior of any of the two sites. A pair of sites is called <em>strongly intersecting</em> if they intersect and they either have more than one common point or their common point lies in the interior of at least one of the two sites. As it will be seen later the two cases have different representation (and thus storage) requirements, as well as they require a somehow different treatment on how the predicates are evaluated. Having made the distinction between weakly and strongly intersecting sites, and having said that segment sites are treated as three objects, we are now ready to precisely define the Delaunay graph we compute. Given a set \( \mathcal{S}\) of input sites, let \( \mathcal{S}_{\mathcal{A}}\) be the set of points and (open) segments in the arrangement \( \mathcal{A}(\mathcal{S})\) of \( \mathcal{S}\). The 2D segment Delaunay graph package of <span style="font-variant: small-caps;">CGAL</span> computes the (triangulated) Delaunay graph that is dual to the Euclidean Voronoi diagram of the sites in the set \( \mathcal{S}_{\mathcal{A}}\).</p>
<p>The segment Delaunay graph is uniquely defined once we have the segment Voronoi diagram. If the all sites are in <em>general position</em>, then Delaunay graph is a graph with triangular faces away from the convex hull of the set of sites. To unify our approach and handling of the Delaunay graph we add to the set of (finite) sites a fictitious site at infinity, which we call the <em>site at infinity</em>. We can then connect all vertices of the outer face of the Delaunay graph to the site at infinity which gives us a graph with the property that all of its faces are now triangular. However, the Delaunay graph is not a triangulation for two main reasons: we cannot always embed it on the plane with straight line segments that yield a triangulation and, moreover, we may have two faces of the graph that have two edges in common, which is not allowed in a triangulation.</p>
<p>We would like to finish our brief introduction to the theory of segment Delaunay graphs and segment Voronoi diagrams by discussing the concept of general position. We say that a set of sites is in general position if no two triplets of sites have the same tritangent Voronoi circle. This statement is rather technical and it is best understood in the context of points. The equivalent statement for points is that we have no two triplets of points that define the same circumcircle, or equivalently that no four points are co-circular. The statement about general position made above is a direct generalization of the (much simpler to understand) statement about points. On the contrary, when we have sites in degenerate position, the Delaunay graph has faces with more than three edges on their boundary. We can get a triangulated version of the Delaunay graph by simply <em>triangulating</em> the corresponding faces in an arbitrary way. In fact the algorithm that has been implemented in <span style="font-variant: small-caps;">CGAL</span> has the property that it always returns a valid <em>triangulated</em> version of the segment Delaunay graph. By valid we mean that it contains the actual (non-triangulated) Delaunay graph, and whenever there are faces with more than three faces then they are triangulated. The way that they are triangulated depends on the order of insertion of the sites in the diagram.</p>
<p>One final remark has to be made with respect to the difference between the set of <em>input sites</em> and the set of <em>output sites</em>. The set of input sites consists of the closed sites that the user inserts in the diagram. Since segment sites are treated as three objects, internally our algorithm sees only points and open segments. As a result, from the point of view of the algorithm, the input sites have no real meaning. What has real meaning is the set of sites that correspond to cells of the Voronoi diagram and this is the set of output sites.</p>
<h2><a class="anchor" id="Segment_Delaunay_graph_2DegenerateDimensions"></a>
Degenerate Dimensions</h2>
<p>The dimension of the segment Delaunay graph is in general 2. The exceptions to this rule are as follows: </p><ul>
<li>
The dimension is \( -1\) if the segment Delaunay graph contains no sites. </li>
<li>
The dimension is \( 0\) if the segment Delaunay graph contains exactly one (output) site. </li>
<li>
The dimension is \( 1\) is the segment Delaunay graph contains exactly two (output) sites. </li>
</ul>
<h1><a class="anchor" id="secsdg2design"></a>
Software Design</h1>
<p>The 2D segment Delaunay graph class <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html" title="The class Segment_Delaunay_graph_2 represents the segment Delaunay graph (which is the dual graph of ...">Segment_Delaunay_graph_2</a>&lt;<a class="el" href="classSegmentDelaunayGraphTraits__2.html">SegmentDelaunayGraphTraits_2</a>,<a class="el" href="classSegmentDelaunayGraphDataStructure__2.html" title="The concept SegmentDelaunayGraphDataStructure_2 refines the concept ApolloniusGraphDataStructure_2. In addition it provides two methods for the merging of two vertices joined by an edge of the data structure, and the splitting of a vertex into two. The method that merges two vertices, called join_vertices() identifies the two vertices and deletes their common two faces. The method that splits a vertex, called split_vertex() introduces a new vertex that shares an edge and two faces with the old vertex (see figure below). Notice that the join_vertices() and split_vertex() operations are complementary, in the sense that one reverses the action of the other. ">SegmentDelaunayGraphDataStructure_2</a>&gt;</code> follows the design of the triangulation package of <span style="font-variant: small-caps;">CGAL</span>. It is parametrized by two arguments: </p><ul>
<li>
the <em>geometric traits</em> class. It provides the basic geometric objects involved in the algorithm, such as sites, points etc. It also provides the geometric predicates for the computation of the segment Delaunay graph, as well as some basic constructions that can be used, for example, to visualize the diagram. The geometric traits for the segment Delaunay graph will be discussed in more detail in the next section. </li>
<li>
the <em>segment Delaunay graph data structure</em>. This is essentially the same as the Apollonius graph data structure (discussed in Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Apollonius_graph_2.tag:../Apollonius_graph_2/" href="../Apollonius_graph_2/index.html#secapollonius2design">Software Design</a> of 2D Apollonius Graph), augmented with some additional operations that are specific to segment Voronoi diagrams. The corresponding concept is that of <code><a class="el" href="classSegmentDelaunayGraphDataStructure__2.html" title="The concept SegmentDelaunayGraphDataStructure_2 refines the concept ApolloniusGraphDataStructure_2. In addition it provides two methods for the merging of two vertices joined by an edge of the data structure, and the splitting of a vertex into two. The method that merges two vertices, called join_vertices() identifies the two vertices and deletes their common two faces. The method that splits a vertex, called split_vertex() introduces a new vertex that shares an edge and two faces with the old vertex (see figure below). Notice that the join_vertices() and split_vertex() operations are complementary, in the sense that one reverses the action of the other. ">SegmentDelaunayGraphDataStructure_2</a></code>, which in fact is a refinement of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Apollonius_graph_2.tag:../Apollonius_graph_2/" href="../Apollonius_graph_2/classApolloniusGraphDataStructure__2.html">ApolloniusGraphDataStructure_2</a></code> concept. The class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">Triangulation_data_structure_2</a>&lt;Vb,Fb&gt;</code> is a model of the concept <code><a class="el" href="classSegmentDelaunayGraphDataStructure__2.html" title="The concept SegmentDelaunayGraphDataStructure_2 refines the concept ApolloniusGraphDataStructure_2. In addition it provides two methods for the merging of two vertices joined by an edge of the data structure, and the splitting of a vertex into two. The method that merges two vertices, called join_vertices() identifies the two vertices and deletes their common two faces. The method that splits a vertex, called split_vertex() introduces a new vertex that shares an edge and two faces with the old vertex (see figure below). Notice that the join_vertices() and split_vertex() operations are complementary, in the sense that one reverses the action of the other. ">SegmentDelaunayGraphDataStructure_2</a></code>. A default value for the corresponding template parameter is provided, so the user does not need to specify it. </li>
</ul>
<h2><a class="anchor" id="Segment_Delaunay_graph_2StronglyIntersecting"></a>
Strongly Intersecting Sites and their Representation</h2>
<p>As we have mentioned above, the segment Delaunay graph package of <span style="font-variant: small-caps;">CGAL</span> is designed to support the computation of the segment Voronoi diagram even when the input segment sites are intersecting. This choice poses certain issues for the design of the software package. The major concern is the representation of the subsegments that appear in the arrangement of the these sites, because the sites in the arrangement are the ones over which the diagram is actually defined. A direct consequence of the choice of representation is the algebraic degree of the predicates involved in the computation of the segment Delaunay graph, as well as the storage requirements for the subsegments and points on intersection in the arrangement.</p>
<p>The case of weakly intersecting sites does not require any special treatment. We can simply represent points by their coordinates and segments by their endpoints. In the case of strongly intersecting sites, the obvious choice to use the afore-mentioned representation has severe disadvantages. Consider two strongly intersecting segments \( t_i\) and \( t_j\), whose endpoints have homogeneous coordinates of size \( b\). Their intersection point will have homogeneous coordinates of bit size \( 6b+O(1)\). This effect can be cascaded, which implies that after inserting \( k\) (input) segments we can arrive at having points of intersection whose bit sizes are exponential with respect to \( k\), i.e., their homogeneous coordinates will have bit size \( \Omega(2^kb)\). Not only the points of intersection, but also the adjacent subsegments will be represented by quantities of arbitrarily high bit size, and as a result we would not be able to give a bound on the bit sizes of the coordinates of the points of intersection. As a result, we would not be able to give a bound on the memory needed to store these coordinates. An equally important consequence is that we would also not be able to give a bound on the algebraic degree of the algebraic expressions involved in the evaluation of the predicates.</p>
<p>Such a behavior is obviously undesirable. For robustness, efficiency, and scalability purposes, it is critical that the bit size of the algebraic expressions in the predicates does not depend on the input size. For this reason, as well as for others to be discussed below, we decided to represent sites in a implicit manner, which somehow encodes the history of their construction. In particular, we exploit the fact that points of intersection always lie on two input segments, and that segments that are not part of the input are always supported by input segments.</p>
<p>For example, let us consider the configuration in <a class="el" href="index.html#fig__figsdg2siterep">Figure 48.2</a>. We assume that the segments \( t_i=p_iq_i\), \( i=1,2,3\), are inserted in that order. Upon the insertion of \( t_2\), our algorithm will split the segment \( t_1\) into the subsegments \( p_1s_1\) and \( s_1q_1\), then add \( s_1\), and finally insert the subsegments \( p_2s_1\) and \( s_1q_2\). How do we represent the five new sites? \( s_1\) will be represented by its two defining segments \( t_1\) and \( t_2\). The segment \( p_1s_1\) will be represented by two segments, a point, and a Boolean. The first segment is \( t_1\), which is always the segment with the same support as the newly created segment. The second segment is \( t_2\) and the point is \( p_1\). The Boolean indicates whether the first endpoint of \( p_1s_1\) is an input point; in this case the Boolean is equal to <code>true</code>. The segment \( s_1q_1\) will also be represented by two segments, a point, and a Boolean, namely, \( t_1\) (the supporting segment of \( s_1q_1\)), \( t_2\) and <code>false</code> (it is the second endpoint of \( s_1q_1\) that is an input point). Subsegments \( p_2s_1\) and \( s_1q_2\) are represented analogously. Consider now what happens when we insert \( t_3\). The point \( s_2\) will again be represented by two segments, but not \( s_1q_1\) and \( t_3\). In fact, it will be represented by \( t_1\) (the supporting segment of \( s_1q_1\)) and \( t_3\). \( s_2q_1\) will be represented by two segments, a point, and a Boolean ( \( t_1\), \( t_3\), \( q1\) and <code>false</code>), and similarly for \( p_3s_2\) and \( s_2q_3\). On the other hand, both endpoints of \( s_1s_2\) are non-input points. In such a case we represent the segment by three input segments. More precisely, \( s_1s_2\) is represented by the segments \( t_1\) (the supporting segment of \( s_1q_1\)), \( t_2\) (it defines \( s_1\) along with \( t_1\)) and \( t_3\) (it defines \( s_2\) along with \( t_1\)).</p>
<p><a class="anchor" id="fig__figsdg2siterep"></a></p><div class="image">
<img src="sdg-rep.png" alt="sdg-rep.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figsdg2siterep">Figure 48.2</a> Site representation. The point \( s_1\) is represented by the four points \( p_1\), \( q_1\), \( p_2\) and \( q_2\). The segment \( p_1s_1\) is represented by the points \( p_1\), \( q_1\), \( p_2\), \( q_2\) and a Boolean which is set to <code>true</code> to indicate that the first endpoint in not a point of intersection. The segment \( s_1s_2\) is represented by the six points: \( p_1\), \( q_1\), \( p_2\), \( q_2\), \( p_3\) and \( q_3\). The remaining (non-input) points and segments in the figure are represented similarly.  </div>  <br />

<p>The five different presentations, two for points (coordinates; two input segments) and three for segments (two input points; two input segments, an input point and a Boolean; three input segments), form a closed set of representations and thus represent any point of intersection or subsegment regardless of the number of input segments. Moreover, every point (input or intersection) has homogeneous coordinates of bit size at most \( 3b+O(1)\). The supporting lines of the segments (they are needed in some of the predicates) have coefficients which are always of bit size \( 2b+O(1)\). As a result, the bit size of the expressions involved in our predicates will always be \( O(b)\), independently of the size of the input. The <code><a class="el" href="classSegmentDelaunayGraphSite__2.html" title="The concept SegmentDelaunayGraphSite_2 provides the requirements for the sites of a segment Delaunay ...">SegmentDelaunayGraphSite_2</a></code> concept encapsulates the ideas presented above. A site is represented in this concept by up to four points and a Boolean, or up to six points, depending on its type. The class <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__site__2.html" title="The class Segment_Delaunay_graph_site_2 is a model for the concept SegmentDelaunayGraphSite_2. ">Segment_Delaunay_graph_site_2</a>&lt;K&gt;</code> implements this concept.</p>
<p>Even this representation, however, has some degree of redundancy. The endpoint of a segment appears in both the representation of the (open) segment site as well as the representation of the point site itself. The situation becomes even worse in the presence of strongly intersecting sites: a point may appear in the representation of multiple subsegments and/or points of intersection. To avoid this redundancy, input points are stored in a container, and the various types of sites (input points and segments, points of intersection, subsegments with one or two points of intersection as endpoints) only store handles to the points in the container. This is achieved by the <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__storage__site__2.html" title="The class Segment_Delaunay_graph_storage_site_2 is a model for the concept SegmentDelaunayGraphStorag...">Segment_Delaunay_graph_storage_site_2</a>&lt;Gt&gt;</code> class which is a model of the corresponding concept: <code><a class="el" href="classSegmentDelaunayGraphStorageSite__2.html" title="The concept SegmentDelaunayGraphStorageSite_2 provides the requirements for the storage sites of a se...">SegmentDelaunayGraphStorageSite_2</a></code>. This concept enforces a site to be represented by up to 6 handles (which are very lightweight objects) instead of 6 points, which are, compared to handles of course, very heavy objects.</p>
<h2><a class="anchor" id="Segment_Delaunay_graph_2OptimizingMemory"></a>
Optimizing Memory Allocation</h2>
<p>There are applications where we know beforehand that the input consists of only weakly intersecting sites. In these cases the site representation described above poses a significant overhead in the memory requirements of our implementation: instead of representing sites with up to two points (or ultimately with to two handles), we require sites to store six points (respectively, six handles). To avoid this overhead we have introduced two series of traits classes: </p><ul>
<li>
One that supports the full-fledged sites, and is suitable when the input consists of strongly intersecting sites. This series consists of the <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__traits__2.html" title="The class Segment_Delaunay_graph_traits_2 provides a model for the SegmentDelaunayGraphTraits_2 conce...">Segment_Delaunay_graph_traits_2</a>&lt;K,MTag&gt;</code> and <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2.html" title="The class Segment_Delaunay_graph_filtered_traits_2 provides a model for the SegmentDelaunayGraphTrait...">Segment_Delaunay_graph_filtered_traits_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> classes. </li>
<li>
One that is customized for input that contain only weakly intersecting sites. This series consists of the <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__traits__without__intersections__2.html" title="The class Segment_Delaunay_graph_traits_without_intersections_2 provides a model for the SegmentDelau...">Segment_Delaunay_graph_traits_without_intersections_2</a>&lt;K,MTag&gt;</code> and <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2.html" title="The class Segment_Delaunay_graph_filtered_traits_without_intersections_2 provides a model for the Seg...">Segment_Delaunay_graph_filtered_traits_without_intersections_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> classes. </li>
</ul>
<p>The advantages of having different traits classes are as follows: </p><ul>
<li>
When the user chooses to use one of the traits classes in the second series we only store two handles per site. This implies a reduction by a factor of three in the memory allocated per site with respect to the first series of traits classes. </li>
<li>
In the case of the first series of traits classes, we can better exploit the knowledge that have strongly intersecting sites, in order to further apply geometric filters (see below) during the evaluation of the predicates. On the contrary, if the second series of traits classes is used, we can avoid geometric filtering tests that have meaning only in the case of strongly intersecting sites. </li>
</ul>
<h1><a class="anchor" id="secsdg2traits"></a>
The Geometric Traits</h1>
<p>The predicates required for the computation of the segment Voronoi diagram are rather complicated. It is not the purpose of this document to discuss them in detail. The interested reader may refer to Burnikel's thesis <a class="el" href="citelist.html#CITEREF_b-ecvdl-96">[2]</a>, where it is shown that in the case of weakly intersecting sites represented in homogeneous coordinates of bit size \( b\), the maximum bit size of the algebraic expressions involved in the predicates is \( 40 b+O(1)\). Given our site representation given above we can guarantee that even in the case of strongly intersecting sites, the algebraic degree of the predicates remains \( O(b)\), independently of the size of the input. What we want to focus in the remainder of this section are the different kinds of filtering techniques that we have employed in our implementation.</p>
<h2><a class="anchor" id="Segment_Delaunay_graph_2GeometricFiltering"></a>
Geometric Filtering</h2>
<p>Our representation of sites is coupled very naturally, with what we call <em>geometric filtering</em>. The technique amounts to performing simple geometric tests exploiting the representation of our data, as well as the geometric structure inherent in our problem, in order to evaluate predicates in seemingly degenerate configurations. Geometric filtering can be seen as a preprocessing step before performing arithmetic filtering. Roughly speaking, by arithmetic filtering we mean that we first try to evaluate the predicates using a fixed-precision floating-point number type (such as <code>double</code>), and at the same time keep error bounds on the numerical errors of the computations we perform. If the numerical errors are too big and do not permit us to evaluate the predicate, we switch to an exact number type, and repeat the evaluation of the predicate. Geometric filtering can help by eliminating situations in which the arithmetic filter will fail, thus decreasing the number of times we need to evaluate a predicate using exact arithmetic.</p>
<p>To illustrate the application and effectiveness of this approach, let us consider a very simple example usage. Suppose we want to determine if two non-input points are identical (we assume here that the input sites are represented by <code>double</code>s). In order to do that we need to compute their coordinates and compare them. If the two points are identical, the answer to our question using <code>double</code> arithmetic may be wrong (due to numerical errors), in which case we will have to reside to the more expensive exact computation. Instead, before testing the coordinates for equality, we can use the representation of the points to potentially answer the question. More specifically, and this is the geometric filtering part of the computation, we can first test if the defining segments of the two points are the same. If they are not, then we proceed to comparing their coordinates as usual. Testing the defining segments for equality does not involve any arithmetic operations on the input, but rather only comparisons on <code>double</code>s. By performing this very simple test we avoid a numerically difficult computation, which could be performed thousands of times during the computation of a Delaunay graph.</p>
<p>Geometric filtering has been implemented in all our models of the <code><a class="el" href="classSegmentDelaunayGraphTraits__2.html">SegmentDelaunayGraphTraits_2</a></code> concept. These models are the classes: <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__traits__2.html" title="The class Segment_Delaunay_graph_traits_2 provides a model for the SegmentDelaunayGraphTraits_2 conce...">Segment_Delaunay_graph_traits_2</a>&lt;K,MTag&gt;</code>, <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__traits__without__intersections__2.html" title="The class Segment_Delaunay_graph_traits_without_intersections_2 provides a model for the SegmentDelau...">Segment_Delaunay_graph_traits_without_intersections_2</a>&lt;K,MTag&gt;</code>, <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2.html" title="The class Segment_Delaunay_graph_filtered_traits_2 provides a model for the SegmentDelaunayGraphTrait...">Segment_Delaunay_graph_filtered_traits_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> and <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2.html" title="The class Segment_Delaunay_graph_filtered_traits_without_intersections_2 provides a model for the Seg...">Segment_Delaunay_graph_filtered_traits_without_intersections_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code>.</p>
<h2><a class="anchor" id="Segment_Delaunay_graph_2ArithmeticFiltering"></a>
Arithmetic Filtering</h2>
<p>As mentioned above, performing computations with exact arithmetic can be very costly. For this reason we have devoted considerable effort in implementing different kinds of arithmetic filtering mechanisms. Presently, there two ways of performing arithmetic filtering for the predicates involved in the computation of segment Delaunay graphs: </p><ol>
<li>
The user can define his/her kernel using as number type, a number type of the form <code>Filtered_exact&lt;CT,ET&gt;</code>. Then this kernel can be entered as the first template parameter in the <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html" title="The class Segment_Delaunay_graph_2 represents the segment Delaunay graph (which is the dual graph of ...">Segment_Delaunay_graph_2</a>&lt;K,MTag&gt;</code>. </li>
<li>
The user can define up to three different kernels <code>CK</code>, <code>FK</code> and <code>EK</code> (default values are provided for most parameters). The first kernel <code>CK</code> is used only for constructions. The second kernel <code>FK</code> is the filtering kernel: the traits class will attempt to compute the predicates using this kernel. If the filtering kernel fails to successfully compute a predicate, the exact kernel <code>EK</code> will be used. These three kernels are then used in the <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2.html" title="The class Segment_Delaunay_graph_filtered_traits_2 provides a model for the SegmentDelaunayGraphTrait...">Segment_Delaunay_graph_filtered_traits_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> and <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2.html" title="The class Segment_Delaunay_graph_filtered_traits_without_intersections_2 provides a model for the Seg...">Segment_Delaunay_graph_filtered_traits_without_intersections_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> classes, which have been implemented using the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Filtered__predicate.html">Filtered_predicate</a>&lt;EP,FP&gt;</code> mechanism. </li>
</ol>
<p>Our experience so far has shown that for all reasonable and valid values of the template parameters, the second method for arithmetic filtering is more efficient among the two.</p>
<p>Let's consider once more the class <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html" title="The class Segment_Delaunay_graph_2 represents the segment Delaunay graph (which is the dual graph of ...">Segment_Delaunay_graph_2</a>&lt;K,MTag&gt;</code>. The template parameter <code>MTag</code> provides another degree of freedom to the user, who can indicate the type of arithmetic operations to be used in the evaluation of the predicates. More specifically, <code>MTag</code> can be <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/structCGAL_1_1Field__with__sqrt__tag.html">Field_with_sqrt_tag</a></code>, in which case the predicates will be evaluated using all four basic arithmetic operations plus square roots; this requires, of course, that the number type used in the kernel <code>K</code> supports these operations exactly. Alternatively <code>MTag</code> can be <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/structCGAL_1_1Field__tag.html">Field_tag</a></code> This indicates that we want the predicates to be computed using only the four basic arithmetic operations. Again, for the predicates to be evaluated correctly, the number type used in the kernel <code>K</code> must support the corresponding operations exactly.</p>
<p>The semantics for the template parameters <code>CM</code>, <code>FM</code> and <code>EM</code> in the <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2.html" title="The class Segment_Delaunay_graph_filtered_traits_2 provides a model for the SegmentDelaunayGraphTrait...">Segment_Delaunay_graph_filtered_traits_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> and <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2.html" title="The class Segment_Delaunay_graph_filtered_traits_without_intersections_2 provides a model for the Seg...">Segment_Delaunay_graph_filtered_traits_without_intersections_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> classes are analogous. With each of these template parameters we can control the type of arithmetic operations that are going to be used in calculations involving each of the corresponding kernels <code>CK</code>, <code>FK</code> and <code>EK</code>. When the <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2.html" title="The class Segment_Delaunay_graph_filtered_traits_2 provides a model for the SegmentDelaunayGraphTrait...">Segment_Delaunay_graph_filtered_traits_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> is used the possible values for <code>CM</code>, <code>FM</code> and <code>EM</code> are <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/structCGAL_1_1Field__with__sqrt__tag.html">Field_with_sqrt_tag</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/structCGAL_1_1Field__tag.html">Field_tag</a></code>, whereas if the <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2.html" title="The class Segment_Delaunay_graph_filtered_traits_without_intersections_2 provides a model for the Seg...">Segment_Delaunay_graph_filtered_traits_without_intersections_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> class is used, the possible values are <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/structCGAL_1_1Field__with__sqrt__tag.html">Field_with_sqrt_tag</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/structCGAL_1_1Euclidean__ring__tag.html">Euclidean_ring_tag</a></code>.</p>
<h1><a class="anchor" id="secsdg2hierarchy"></a>
The Segment Delaunay Graph Hierarchy</h1>
<p>The <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__hierarchy__2.html" title="We provide an alternative to the class Segment_Delaunay_graph_2&lt;Gt,DS&gt; for the incremental constructi...">Segment_Delaunay_graph_hierarchy_2</a>&lt;<a class="el" href="classSegmentDelaunayGraphTraits__2.html">SegmentDelaunayGraphTraits_2</a>, SSTag, <a class="el" href="classSegmentDelaunayGraphDataStructure__2.html" title="The concept SegmentDelaunayGraphDataStructure_2 refines the concept ApolloniusGraphDataStructure_2. In addition it provides two methods for the merging of two vertices joined by an edge of the data structure, and the splitting of a vertex into two. The method that merges two vertices, called join_vertices() identifies the two vertices and deletes their common two faces. The method that splits a vertex, called split_vertex() introduces a new vertex that shares an edge and two faces with the old vertex (see figure below). Notice that the join_vertices() and split_vertex() operations are complementary, in the sense that one reverses the action of the other. ">SegmentDelaunayGraphDataStructure_2</a>&gt;</code> class is the analogue of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__hierarchy__2.html">Triangulation_hierarchy_2</a></code> or the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Apollonius_graph_2.tag:../Apollonius_graph_2/" href="../Apollonius_graph_2/classCGAL_1_1Apollonius__graph__hierarchy__2.html">Apollonius_graph_hierarchy_2</a></code> classes, applied to the segment Delaunay graph. It consists of a hierarchy of segment Delaunay graphs constructed in a manner analogous to the Delaunay hierarchy by Devillers <a class="el" href="citelist.html#CITEREF_cgal:d-dh-02">[3]</a>. Unlike the triangulation hierarchy or the Apollonius graph hierarchy, the situation here is more complicated because of two factors: firstly, segments are treated as three objects instead of one (the two endpoints and the interior of the segments), and secondly, the presence of strongly intersecting sites complicates significantly the way the hierarchy is constructed. The interested reader may refer to the paper by Karavelas <a class="el" href="citelist.html#CITEREF_cgal:k-reisv-04">[4]</a> for the details of the construction of the hierarchy. Another alternative is to have a hybrid hierarchy that consists of the segment Delaunay graph at the bottom-most level and point Voronoi diagrams at all other levels. This choice seems to work very well in practice , primarily because it avoids the overhead of maintaining a Delaunay graph for segments at the upper levels of the hierarchy. However, it seems much less likely to be possible to give any theoretical guarantees for its performance, in contrast to the hierarchy with segment Delaunay graphs at all levels (cf. <a class="el" href="citelist.html#CITEREF_cgal:k-reisv-04">[4]</a>). The user can choose between the two types of hierarchies by means of the template parameter <code>SSTag</code>. If <code>SSTag</code> is set to <code>false</code> (which is also the default value), the upper levels of the hierarchy consist of point Delaunay graphs. If <code>SSTag</code> is set to <code>true</code>, we have segment Delaunay graphs at all levels of the hierarchy.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__hierarchy__2.html" title="We provide an alternative to the class Segment_Delaunay_graph_2&lt;Gt,DS&gt; for the incremental constructi...">Segment_Delaunay_graph_hierarchy_2</a>&lt;<a class="el" href="classSegmentDelaunayGraphTraits__2.html">SegmentDelaunayGraphTraits_2</a>, SSTag, <a class="el" href="classSegmentDelaunayGraphDataStructure__2.html" title="The concept SegmentDelaunayGraphDataStructure_2 refines the concept ApolloniusGraphDataStructure_2. In addition it provides two methods for the merging of two vertices joined by an edge of the data structure, and the splitting of a vertex into two. The method that merges two vertices, called join_vertices() identifies the two vertices and deletes their common two faces. The method that splits a vertex, called split_vertex() introduces a new vertex that shares an edge and two faces with the old vertex (see figure below). Notice that the join_vertices() and split_vertex() operations are complementary, in the sense that one reverses the action of the other. ">SegmentDelaunayGraphDataStructure_2</a>&gt;</code> has exactly the same interface and functionality as the <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html" title="The class Segment_Delaunay_graph_2 represents the segment Delaunay graph (which is the dual graph of ...">Segment_Delaunay_graph_2</a>&lt;<a class="el" href="classSegmentDelaunayGraphTraits__2.html">SegmentDelaunayGraphTraits_2</a>,<a class="el" href="classSegmentDelaunayGraphDataStructure__2.html" title="The concept SegmentDelaunayGraphDataStructure_2 refines the concept ApolloniusGraphDataStructure_2. In addition it provides two methods for the merging of two vertices joined by an edge of the data structure, and the splitting of a vertex into two. The method that merges two vertices, called join_vertices() identifies the two vertices and deletes their common two faces. The method that splits a vertex, called split_vertex() introduces a new vertex that shares an edge and two faces with the old vertex (see figure below). Notice that the join_vertices() and split_vertex() operations are complementary, in the sense that one reverses the action of the other. ">SegmentDelaunayGraphDataStructure_2</a>&gt;</code> class. Using the segment Delaunay graph hierarchy involves an additional cost in space and time for maintaining the hierarchy. Our experiments have shown that it usually pays off to use the hierarchy for inputs consisting of more than about 1,000 sites.</p>
<h1><a class="anchor" id="secsdg2examples"></a>
Examples</h1>
<h2><a class="anchor" id="Segment_Delaunay_graph_2FirstExample"></a>
First Example using the Filtered Traits</h2>
<p>The following example shows how to use the segment Delaunay graph traits in conjunction with the <code>Filtered_exact&lt;CT,ET&gt;</code> mechanism. In addition it shows how to use a few of the iterators provided by the <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html" title="The class Segment_Delaunay_graph_2 represents the segment Delaunay graph (which is the dual graph of ...">Segment_Delaunay_graph_2</a></code> class in order to count a few site-related quantities.</p>
<p><br />
<b>File</b> <a class="el" href="Segment_Delaunay_graph_2_2sdg-count-sites_8cpp-example.html">Segment_Delaunay_graph_2/sdg-count-sites.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// define the input kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>     CK;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_filtered_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2.html">CGAL::Segment_Delaunay_graph_filtered_traits_2</a>&lt;</div><div class="line">          CK,<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/structCGAL_1_1Field__with__sqrt__tag.html">CGAL::Field_with_sqrt_tag</a>&gt;  Gt;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2&lt;Gt&gt;</a>             SDG2;</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  ifstream ifs(<span class="stringliteral">"data/sitesx.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  SDG2          sdg;</div><div class="line">  SDG2::Site_2  site;</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) { sdg.insert( site ); }</div><div class="line"></div><div class="line">  ifs.close();</div><div class="line"></div><div class="line">  assert( sdg.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line">  cout &lt;&lt; endl &lt;&lt; endl;</div><div class="line"></div><div class="line">  <span class="comment">// print the number of input and output sites</span></div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of input sites : "</span> &lt;&lt; sdg.number_of_input_sites() &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of output sites: "</span> &lt;&lt; sdg.number_of_output_sites() &lt;&lt; endl;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_ipt(0), n_iseg(0), n_opt(0), n_oseg(0), n_ptx(0);</div><div class="line"></div><div class="line">  <span class="comment">// count the number of input points and input segments</span></div><div class="line">  SDG2::Input_sites_iterator iit;</div><div class="line">  <span class="keywordflow">for</span> (iit = sdg.input_sites_begin(); iit != sdg.input_sites_end(); ++iit)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> ( iit-&gt;is_point() ) { n_ipt++; } <span class="keywordflow">else</span> { n_iseg++; }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// count the number of output points and output segments, as well</span></div><div class="line">  <span class="comment">// as the number of points that are points of intersection of pairs</span></div><div class="line">  <span class="comment">// of strongly intersecting sites</span></div><div class="line">  SDG2::Output_sites_iterator oit;</div><div class="line">  <span class="keywordflow">for</span> (oit = sdg.output_sites_begin(); oit != sdg.output_sites_end(); ++oit)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> ( oit-&gt;is_segment() ) { n_oseg++; } <span class="keywordflow">else</span> {</div><div class="line">        n_opt++;</div><div class="line">        <span class="keywordflow">if</span> ( !oit-&gt;is_input() ) { n_ptx++; }</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"# of input segments:  "</span> &lt;&lt; n_iseg &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of input points:    "</span> &lt;&lt; n_ipt &lt;&lt; endl &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of output segments: "</span> &lt;&lt; n_oseg &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of output points:   "</span> &lt;&lt; n_opt &lt;&lt; endl &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of intersection points: "</span> &lt;&lt; n_ptx &lt;&lt; endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Segment_Delaunay_graph_2FastSP"></a>
Using Spatial Sorting to Speed up Insertion</h2>
<p>If you have a rather large input, you better use an insertion function that uses the spatial sorting of your input (end) points. Note that the functions <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#af190978a7ec3bdc26e96566548c11f63"><code>insert_points</code> </a> or <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a896a91e35dabbeb3463ae428e21da5a5"><code>insert_segments</code> </a> can be used if your input is only composed of points or segments.</p>
<p><br />
<b>File</b> <a class="el" href="Segment_Delaunay_graph_2_2sdg-fast-sp_8cpp-example.html">Segment_Delaunay_graph_2/sdg-fast-sp.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// example that uses the filtered traits,</span></div><div class="line"><span class="comment">// the segment Delaunay graph and the spatial sorting</span></div><div class="line"></div><div class="line"><span class="comment">// choose the kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_filtered_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2.html">CGAL::Segment_Delaunay_graph_filtered_traits_without_intersections_2&lt;K&gt;</a> Gt;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2&lt;Gt&gt;</a>  SDG2;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::ifstream ifs(<span class="stringliteral">"data/sites.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  SDG2          sdg;</div><div class="line">  SDG2::Site_2  site;</div><div class="line"></div><div class="line">  std::vector&lt;SDG2::Site_2&gt; sites;</div><div class="line">  <span class="comment">// read the sites</span></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) {</div><div class="line">    sites.push_back(site);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//insert the sites all at once using spatial sorting to speed the insertion</span></div><div class="line">  sdg.insert( sites.begin(), sites.end(),<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__PkgStlExtensionUtilities.html#gab3e2296107b5d26c32c8183028a217f1">CGAL::Tag_true</a>() );</div><div class="line"></div><div class="line">  <span class="comment">// validate the segment Delaunay graph</span></div><div class="line">  assert( sdg.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Segment_Delaunay_graph_2FastSPPolygon"></a>
Delaunay Graph of a Polygon</h2>
<p>This example shows how to efficiently compute the Delaunay graph of a simple polygon using the spatial sorting to speed up the insertion.</p>
<p><br />
<b>File</b> <a class="el" href="Segment_Delaunay_graph_2_2sdg-fast-sp-polygon_8cpp-example.html">Segment_Delaunay_graph_2/sdg-fast-sp-polygon.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// example that uses the filtered traits,</span></div><div class="line"><span class="comment">// the segment Delaunay graph and the spatial sorting</span></div><div class="line"></div><div class="line"><span class="comment">// choose the kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_filtered_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2.html">CGAL::Segment_Delaunay_graph_filtered_traits_without_intersections_2&lt;K&gt;</a> Gt;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2&lt;Gt&gt;</a>  SDG2;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::ifstream ifs(<span class="stringliteral">"data/sites.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  <span class="comment">//polygon points</span></div><div class="line">  std::vector&lt;Gt::Point_2&gt; points;</div><div class="line">  <span class="comment">//segments of the polygon as a pair of point indices</span></div><div class="line">  std::vector&lt;std::pair&lt;std::size_t,std::size_t&gt; &gt; indices;</div><div class="line"></div><div class="line">  SDG2::Site_2 site;</div><div class="line">  <span class="comment">//read a close polygon given by its segments</span></div><div class="line">  <span class="comment">// s x0 y0 x1 y1</span></div><div class="line">  <span class="comment">// s x1 y1 x2 y2</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="comment">// s xn yn x0 y0</span></div><div class="line">  ifs &gt;&gt; site;</div><div class="line">  assert( site.is_segment() );</div><div class="line">  points.push_back( site.source_of_supporting_site() );</div><div class="line"></div><div class="line">  std::size_t k=0;</div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) {</div><div class="line">    assert( site.is_segment() );</div><div class="line">    points.push_back( site.source_of_supporting_site() );</div><div class="line">    indices.push_back( std::make_pair(k, k+1) );</div><div class="line">    ++k;</div><div class="line">  }</div><div class="line">  indices.push_back( std::make_pair(k, 0) );</div><div class="line">  ifs.close();</div><div class="line"></div><div class="line">  SDG2          sdg;</div><div class="line"></div><div class="line">  <span class="comment">//insert the polygon segments all at once using spatial sorting to speed the insertion</span></div><div class="line">  sdg.insert_segments( points.begin(), points.end(), indices.begin(), indices.end() );</div><div class="line"></div><div class="line">  <span class="comment">// validate the segment Delaunay graph</span></div><div class="line">  assert( sdg.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Segment_Delaunay_graph_2ExHierachy"></a>
Using the Hierarchy for Faster Location</h2>
<p>The following example shows how to use the segment Delaunay graph hierarchy along with the filtered traits class that supports intersecting sites.</p>
<p><br />
<b>File</b> <a class="el" href="Segment_Delaunay_graph_2_2sdg-filtered-traits_8cpp-example.html">Segment_Delaunay_graph_2/sdg-filtered-traits.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// example that uses the filtered traits and</span></div><div class="line"><span class="comment">// the segment Delaunay graph hierarchy</span></div><div class="line"></div><div class="line"><span class="comment">// choose the kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_hierarchy_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_filtered_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2.html">CGAL::Segment_Delaunay_graph_filtered_traits_2&lt;K&gt;</a> Gt;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Segment__Delaunay__graph__hierarchy__2.html">CGAL::Segment_Delaunay_graph_hierarchy_2&lt;Gt&gt;</a>  SDG2;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::ifstream ifs(<span class="stringliteral">"data/sites.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  SDG2          sdg;</div><div class="line">  SDG2::Site_2  site;</div><div class="line"></div><div class="line">  <span class="comment">// read the sites and insert them in the segment Delaunay graph</span></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) {</div><div class="line">    sdg.insert(site);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// validate the segment Delaunay graph</span></div><div class="line">  assert( sdg.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Segment_Delaunay_graph_2ExVorEdges"></a>
Voronoi Edges</h2>
<p>The following example demonstrates how to recover the defining sites for the edges of the Voronoi diagram (which are the duals of the edges of the segment Delaunay graph computed).</p>
<p><br />
<b>File</b> <a class="el" href="Segment_Delaunay_graph_2_2sdg-voronoi-edges_8cpp-example.html">Segment_Delaunay_graph_2/sdg-voronoi-edges.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// define the kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Filtered_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>    CK;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Filtered__kernel.html">CGAL::Filtered_kernel&lt;CK&gt;</a>         <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Segment__Delaunay__graph__traits__2.html">CGAL::Segment_Delaunay_graph_traits_2&lt;Kernel&gt;</a>  Gt;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2&lt;Gt&gt;</a>             SDG2;</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  ifstream ifs(<span class="stringliteral">"data/sites2.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  SDG2          sdg;</div><div class="line">  SDG2::Site_2  site;</div><div class="line"></div><div class="line">  <span class="comment">// read the sites from the stream and insert them in the diagram</span></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) { sdg.insert( site ); }</div><div class="line"></div><div class="line">  ifs.close();</div><div class="line"></div><div class="line">  <span class="comment">// validate the diagram</span></div><div class="line">  assert( sdg.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line">  cout &lt;&lt; endl &lt;&lt; endl;</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">  // now walk through the non-infinite edges of the segment Delaunay</span></div><div class="line"><span class="comment">  // graphs (which are dual to the edges in the Voronoi diagram) and</span></div><div class="line"><span class="comment">  // print the sites defining each Voronoi edge.</span></div><div class="line"><span class="comment">  //</span></div><div class="line"><span class="comment">  // Each oriented Voronoi edge (horizontal segment in the figure</span></div><div class="line"><span class="comment">  // below) is defined by four sites A, B, C and D.</span></div><div class="line"><span class="comment">  //</span></div><div class="line"><span class="comment">  //     \                     /</span></div><div class="line"><span class="comment">  //      \         B         /</span></div><div class="line"><span class="comment">  //       \                 /</span></div><div class="line"><span class="comment">  //     C  -----------------  D</span></div><div class="line"><span class="comment">  //       /                 \</span></div><div class="line"><span class="comment">  //      /         A         \</span></div><div class="line"><span class="comment">  //     /                     \</span></div><div class="line"><span class="comment">  //</span></div><div class="line"><span class="comment">  // The sites A and B define the (oriented) bisector on which the</span></div><div class="line"><span class="comment">  // edge lies whereas the sites C and D, along with A and B define</span></div><div class="line"><span class="comment">  // the two endpoints of the edge. These endpoints are the Voronoi</span></div><div class="line"><span class="comment">  // vertices of the triples A, B, C and B, A, D.</span></div><div class="line"><span class="comment">  // If one of these vertices is the vertex at infinity the string</span></div><div class="line"><span class="comment">  // "infinite vertex" is printed; the corresponding Voronoi edge is</span></div><div class="line"><span class="comment">  // actually a stright-line or parabolic ray.</span></div><div class="line"><span class="comment">  // The sites below are printed in the order A, B, C, D.</span></div><div class="line"><span class="comment">  */</span></div><div class="line"></div><div class="line">  <span class="keywordtype">string</span> inf_vertex(<span class="stringliteral">"infinite vertex"</span>);</div><div class="line">  <span class="keywordtype">char</span> vid[] = {<span class="charliteral">'A'</span>, <span class="charliteral">'B'</span>, <span class="charliteral">'C'</span>, <span class="charliteral">'D'</span>};</div><div class="line"></div><div class="line">  SDG2::Finite_edges_iterator eit = sdg.finite_edges_begin();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 1; eit != sdg.finite_edges_end(); ++eit, ++k) {</div><div class="line">    SDG2::Edge e = *eit;</div><div class="line">    <span class="comment">// get the vertices defining the Voronoi edge</span></div><div class="line">    SDG2::Vertex_handle v[] = { e.first-&gt;vertex( sdg.ccw(e.second) ),</div><div class="line">                                e.first-&gt;vertex( sdg.cw(e.second) ),</div><div class="line">                                e.first-&gt;vertex( e.second ),</div><div class="line">                                sdg.tds().mirror_vertex(e.first, e.second) };</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">"--- Edge "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" ---"</span> &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++) {</div><div class="line">      <span class="comment">// check if the vertex is the vertex at infinity; if yes, print</span></div><div class="line">      <span class="comment">// the corresponding string, otherwise print the site</span></div><div class="line">      <span class="keywordflow">if</span> ( sdg.is_infinite(v[i]) ) {</div><div class="line">        cout &lt;&lt; vid[i] &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; inf_vertex &lt;&lt; endl;</div><div class="line">      } <span class="keywordflow">else</span> {</div><div class="line">        cout &lt;&lt; vid[i] &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; v[i]-&gt;site() &lt;&lt; endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:49 for CGAL 4.13 - 2D Segment Delaunay Graphs by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
