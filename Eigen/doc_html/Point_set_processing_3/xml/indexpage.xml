<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Point_Set_Processing"/><anchor id="index_1chappoint_set_processing_3"/> </para><para><simplesect kind="authors"><para>Pierre Alliez, Simon Giraudot, Clément Jamin, Florent Lafarge, Quentin Mérigot, Jocelyn Meyron, Laurent Saboret, Nader Salman, Shihao Wu</para></simplesect>
</para><sect1 id="index_1Point_set_processing_3Introduction">
<title>Introduction</title>
<para>This CGAL component implements methods to analyze and process 3D point sets. The input is an unorganized 3D point set, possibly with normal attributes (unoriented or oriented). The input point set can be analyzed to measure geometric properties such as average spacing between the points and their <computeroutput>k</computeroutput> nearest neighbors. It can be processed with functions devoted to the simplification, regularization, upsampling, outlier removal, smoothing, normal estimation and normal orientation. The processing of point sets is often needed in applications dealing with measurement data, such as surface reconstruction from laser scanned data (see <ref refid="index_1fig__Point_set_processing_3figintroduction" kindref="member">fig__Point_set_processing_3figintroduction</ref>).</para><para><anchor id="index_1fig__Point_set_processing_3figintroduction"/><image type="html" name="introduction.jpg"></image>
 <image type="latex" name="introduction.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figintroduction" kindref="member">fig__Point_set_processing_3figintroduction</ref> Point set processing. Left: 275K points sampled on the statue of an elephant with a Minolta laser scanner. Right: point set after outlier removal, denoising and simplification to 17K points.  <linebreak/>
</para><para>In the context of surface reconstruction we can position the elements of this component along the common surface reconstruction pipeline (<ref refid="index_1fig__Point_set_processing_3figpipeline" kindref="member">fig__Point_set_processing_3figpipeline</ref>) which involves the following steps:<orderedlist>
<listitem><para>Scanning and scan alignment to produce a set of points or points with normals (alignment is not covered in CGAL);</para></listitem><listitem><para>Outlier removal;</para></listitem><listitem><para>Simplification to reduce the number of input points;</para></listitem><listitem><para>Smoothing to reduce noise in the input data;</para></listitem><listitem><para>Normal estimation and orientation when the normals are not already provided by the acquisition device; and</para></listitem><listitem><para>Surface reconstruction. Chapter <ref refid="index_1Chapter_Poisson_Surface_Reconstruction" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag">Poisson Surface Reconstruction</ref> deals with surface reconstruction from point sets with normal attributes.</para></listitem></orderedlist>
</para><para><anchor id="index_1fig__Point_set_processing_3figpipeline"/><image type="html" name="pipeline.jpg"></image>
 <image type="latex" name="pipeline.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figpipeline" kindref="member">fig__Point_set_processing_3figpipeline</ref> Point set processing pipeline for surface reconstruction. The algorithms listed in gray are available from other <ref refid="namespaceCGAL" kindref="compound">CGAL</ref> components (bounding volumes and principal component analysis).  <linebreak/>
</para></sect1>
<sect1 id="index_1Point_set_processing_3API">
<title>API</title>
<para>The algorithms of this component take as input parameters ranges of 3D points, or of 3D points with normals. They can be adapted to the user&apos;s data structures and make extensive use of <ref refid="index_1Point_set_processing_3NamedParameters" kindref="member">named parameters</ref> and of <ref refid="index_1Point_set_processing_3PropertyMaps" kindref="member">property maps</ref>:</para><para><programlisting><codeline><highlight class="normal">std::vector&lt;PointVectorPair&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal">typedef<sp/>CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;<sp/>Point_map;</highlight></codeline>
<codeline><highlight class="normal">typedef<sp/>CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;<sp/>Vector_map;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">CGAL::jet_estimate_normals</highlight></codeline>
<codeline><highlight class="normal">&lt;CGAL::Parallel_tag&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>concurrency<sp/>tag</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(points,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>input<sp/>range<sp/>of<sp/>points</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>12,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>parameter:<sp/>number<sp/>of<sp/>neighbors</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>CGAL::parameters::<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>named<sp/>parameters:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>point_map<sp/>(Point_map()).<sp/><sp/><sp/><sp/>//<sp/><sp/>*<sp/>point<sp/>map</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>normal_map<sp/>(Vector_map()));<sp/>//<sp/><sp/>*<sp/>normal<sp/>map</highlight></codeline>
</programlisting></para><para>This API was introduced in CGAL 4.12. Please refer to the <ref refid="index_1Point_set_processing_3Deprecated" kindref="member">dedicated section</ref> on how to upgrade from the deprecated API.</para><sect2 id="index_1Point_set_processing_3NamedParameters">
<title>Named Parameters</title>
<para>Named parameters are used to deal with optional parameters. The page <ref refid="index_1BGLNamedParameters" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">Named Parameters</ref> explains the rationale and API in general. The page <ref refid="group__psp__namedparameters" kindref="compound">Named Parameters for Point Set Processing</ref> describes their usage and provides a list of the parameters that are used in this package.</para></sect2>
<sect2 id="index_1Point_set_processing_3PropertyMaps">
<title>Property Maps</title>
<para>The property maps are used to access the point or normal information from the input data, so as to let the user decide upon the implementation of a point with normal. The latter can be represented as, e.g., a class derived from the CGAL 3D point, or as a <computeroutput>std::pair&lt;<ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_3</ref>&lt;K&gt;, <ref refid="classCGAL_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Vector_3</ref>&lt;K&gt;&gt;</computeroutput>, or as a <computeroutput>boost::tuple&lt;..,<ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_3</ref>&lt;K&gt;, ..., <ref refid="classCGAL_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Vector_3</ref>&lt;K&gt; &gt;</computeroutput>.</para><para>The following classes described in Chapter <ref refid="packages_1PkgProperty_mapSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL and Boost Property Maps</ref> provide property maps for the implementations of points with normals listed above:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="structCGAL_1_1Identity__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">Identity_property_map</ref>&lt;T&gt;</computeroutput></para></listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">First_of_pair_property_map</ref>&lt;Pair&gt;</computeroutput> and <computeroutput><ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">Second_of_pair_property_map</ref>&lt;Pair&gt;</computeroutput></para></listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1Nth__of__tuple__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">Nth_of_tuple_property_map</ref>&lt;N, Tuple&gt;</computeroutput></para></listitem></itemizedlist>
</para><para><computeroutput><ref refid="structCGAL_1_1Identity__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">Identity_property_map</ref>&lt;<ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_3</ref>&gt;</computeroutput> is the default value of the position property map expected by all functions in this component.</para><para>See below examples using pair and tuple property maps.</para><para>Users of this package may use other types to represent positions and normals if they implement the corresponding property maps.</para><para>Points and normals can even be stored in separate containers and accessed by their index, as any built-in vector is also a property map.</para><para><linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2grid_simplify_indices_8cpp-example" kindref="compound">Point_set_processing_3/grid_simplify_indices.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/grid_simplify_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.xyz<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points[].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Vector&gt;<sp/>normals;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>fname<sp/>=<sp/>(argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/fin90_with_PCA_normals.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>stream(fname);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vector<sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(stream<sp/>&gt;&gt;<sp/>p<sp/>&gt;&gt;<sp/>v){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points.push_back(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>normals.push_back(v);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>points.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>input<sp/>points&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::size_t&gt;<sp/>indices(points.size());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>points.size();<sp/>++i){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indices[i]<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>simplification<sp/>by<sp/>clustering<sp/>using<sp/>erase-remove<sp/>idiom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>cell_size<sp/>=<sp/>0.05;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::size_t&gt;::iterator<sp/>end;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>end<sp/>=<sp/><ref refid="group__PkgPointSetProcessingAlgorithms_1gac7c81cc8a2986e3972e86612e4f847a1" kindref="member">CGAL::grid_simplify_point_set</ref>(indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cell_size,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map<sp/>(<ref refid="group__PkgProperty__map_1ga44ae71cce5987f3970443868a129752a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::make_property_map</ref>(points)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>k<sp/>=<sp/>end<sp/>-<sp/>indices.begin();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Keep<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>of<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>indices.size()<sp/>&lt;&lt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/>indices&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Point&gt;<sp/>tmp_points(k);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Vector&gt;<sp/>tmp_normals(k);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::size_t<sp/>i=0;<sp/>i&lt;k;<sp/>++i){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>tmp_points[i]<sp/>=<sp/>points[indices[i]];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>tmp_normals[i]<sp/>=<sp/>normals[indices[i]];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points.swap(tmp_points);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>normals.swap(tmp_normals);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>points.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points<sp/>after<sp/>the<sp/>simplification&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Point_set_processing_3Deprecated">
<title>Upgrading from pre-CGAL 4.12 Deprecated API</title>
<para>The current API based on ranges and named parameters was introduced in CGAL 4.12. The old API that used pairs of iterators along with usual C++ parameters (with some default values and overloads to handle optional parameters) is deprecated.</para><para><simplesect kind="warning"><para>The deprecated API will be removed in CGAL 4.14, so we recommend to update your code.</para></simplesect>
Translating your pre-CGAL 4.12 code using Point Set Processing to the new API is easy. For example, consider this code using the old API:</para><para><programlisting><codeline><highlight class="normal">std::vector&lt;PointVectorPair&gt;<sp/>points;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Old<sp/>pre-CGAL<sp/>4.12<sp/>deprecated<sp/>API</highlight></codeline>
<codeline><highlight class="normal">CGAL::jet_estimate_normals&lt;Concurrency_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(points.begin(),<sp/>points.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>12);<sp/>//<sp/>Number<sp/>of<sp/>neighbors</highlight></codeline>
</programlisting></para><para>The pair of iterators is replaced by a range and the optional parameters (than can be deduced automatically in simple cases) are moved to the end of the function in a single named parameter object (see <ref refid="index_1BGLNamedParameters" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">Named Parameters</ref>). The code translated to the new API becomes:</para><para><programlisting><codeline><highlight class="normal">std::vector&lt;PointVectorPair&gt;<sp/>points;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>New<sp/>API</highlight></codeline>
<codeline><highlight class="normal">CGAL::jet_estimate_normals&lt;Concurrency_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(points,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>12,<sp/>//<sp/>Number<sp/>of<sp/>neighbors</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>CGAL::parameters::point_map<sp/>(CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>normal_map<sp/>(CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;()));</highlight></codeline>
</programlisting></para><para>Please refer to the <ref refid="group__PkgPointSetProcessing" kindref="compound">Reference Manual</ref> for the detailed API of the Point Set Processing functions.</para></sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3InputOutput">
<title>Input/Output</title>
<sect2 id="index_1Point_set_processing_3Points_io">
<title>Points And Normals</title>
<para>CGAL provides functions to read and write sets of points or sets of points with normals from the following file formats:</para><para><itemizedlist>
<listitem><para>XYZ (ASCII file three point coordinates <computeroutput>x y z</computeroutput> per line or three point coordinates and three normal vector coordinates <computeroutput>x y z nx ny nz</computeroutput> per line)</para></listitem><listitem><para>OFF (Object File Format) <ref refid="citelist_1CITEREF_cgal:p-gmgv16-96" kindref="member">[9]</ref></para></listitem><listitem><para>PLY (Polygon File Format) <ref refid="citelist_1CITEREF_cgal:b-ply-11" kindref="member">[10]</ref></para></listitem><listitem><para>LAS (Lidar Format). <ref refid="citelist_1CITEREF_cgal:asprs-lasf-13" kindref="member">[1]</ref> This format does not handle normals and requires the <ref refid="installation_1thirdpartyLASlib" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">LASlib</ref> library.</para></listitem></itemizedlist>
</para><para>The following functions are available:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">read_xyz_points()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingIO_1ga1d0f58874ed1ddb2b00721f15ba362a9" kindref="member">read_off_points()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingIOPly_1ga1cff0be3f76b7e5f70dbd4320b06394a" kindref="member">read_ply_points()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingIOLas_1ga638b30c7234beb453a3e3fd31dad267d" kindref="member">read_las_points()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingIO_1ga63d1f8f5933d843d8a179a1be4b0dd8f" kindref="member">write_xyz_points()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingIO_1ga5d99add98e7411c7d5bd27562d48603f" kindref="member">write_off_points()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingIOPly_1ga10908ae5e7b2d585bc973fe14a694a25" kindref="member">write_ply_points()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingIOLas_1gaa96a32cc42a0706e2f7dc74b2fc8be72" kindref="member">write_las_points()</ref></computeroutput></para></listitem></itemizedlist>
</para><para>All of these functions (with the exception of the LAS format) can read and write either points alone or points with normals (depending on whether the <ref refid="group__psp__namedparameters_1PSP_normal_map" kindref="member">normal_map</ref> is provided by the user or not).</para><para>Note that the PLY format handles both ASCII and binary formats. In addition, PLY and LAS are extensible formats that can embed additional properties. These can also be read by CGAL (see Section <ref refid="index_1Point_set_processing_3Properties_io" kindref="member">Points With Properties</ref>).</para><sect3 id="index_1Point_set_processing_3Example_io">
<title>Example</title>
<para>The following example reads a point set from an input file and writes it to a file, both in the XYZ format. Positions and normals are stored in pairs and accessed through property maps. <linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2read_write_xyz_point_set_example_8cpp-example" kindref="compound">Point_set_processing_3/read_write_xyz_point_set_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/write_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>defines<sp/>std::pair</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Point<sp/>with<sp/>normal<sp/>vector<sp/>stored<sp/>as<sp/>a<sp/>std::pair.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Point,<sp/>Vector&gt;<sp/>Pwn;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>fname<sp/>=<sp/>(argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/oni.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.xyz<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points[].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note:<sp/>read_xyz_points()<sp/>requires<sp/>an<sp/>output<sp/>iterator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>over<sp/>points<sp/>and<sp/>as<sp/>well<sp/>as<sp/>property<sp/>maps<sp/>to<sp/>access<sp/>each</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>point<sp/>position<sp/>and<sp/>normal.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Pwn&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>in(fname);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">CGAL::read_xyz_points</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>in,std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map<sp/>(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;Pwn&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal_map<sp/>(<ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</ref>())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fname<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Saves<sp/>point<sp/>set.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note:<sp/>write_xyz_points()<sp/>requires<sp/>property<sp/>maps<sp/>to<sp/>access<sp/>each</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>point<sp/>position<sp/>and<sp/>normal.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ofstream<sp/>out(</highlight><highlight class="stringliteral">&quot;oni_copy.xyz&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!out<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga63d1f8f5933d843d8a179a1be4b0dd8f" kindref="member">CGAL::write_xyz_points</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out,<sp/>points,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;Pwn&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(<ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</ref>())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
</sect2>
<sect2 id="index_1Point_set_processing_3Properties_io">
<title>Points With Properties</title>
<para>PLY files are designed to embed an arbitrary number of additional attributes. More specifically, point sets may contain visibility vectors, RGB colors, intensity, etc. As it is not possible to provide dedicated functions to every possible combination of PLY properties, CGAL provides a simple way to read PLY properties and store them in any structure the user needs. Handling of LAS files works similarly with the difference that the property names and types are fixed and defined by the LAS standard.</para><para>Functions <computeroutput><ref refid="namespaceCGAL_1a483fe42bbefcafce8a5d6194573a2715" kindref="member">read_ply_points_with_properties()</ref></computeroutput> and <computeroutput><ref refid="group__PkgPointSetProcessingIOLas_1gaf02431d387cc9b00ed932a41b164d389" kindref="member">read_las_points_with_properties()</ref></computeroutput> allow the user to read any property needed. The user must provide a set of property handlers that are used to instantiate number types and complex objects from PLY/LAS properties. This handlers are either:</para><para><itemizedlist>
<listitem><para>a pair consisting of a property map and of a single PLY/LAS property descriptor</para></listitem><listitem><para>a tuple consisting of a property map, a functor to construct the objects wanted and multiple PLY/LAS property descriptors</para></listitem></itemizedlist>
</para><para>Output functions <computeroutput><ref refid="group__PkgPointSetProcessingIOPly_1gaa9c84f9edcad73c46d9838618de9878e" kindref="member">write_ply_points_with_properties()</ref></computeroutput> and <computeroutput><ref refid="group__PkgPointSetProcessingIOLas_1gab458d5161d933b236ac42b03366ffeb7" kindref="member">write_las_points_with_properties()</ref></computeroutput> work similarly.</para><sect3 id="index_1Point_set_processing_3Example_ply_write">
<title>PLY Writing Example</title>
<para>The following example shows how to call <computeroutput><ref refid="group__PkgPointSetProcessingIOPly_1gaa9c84f9edcad73c46d9838618de9878e" kindref="member">write_ply_points_with_properties()</ref></computeroutput> to write a point set with points, RGB colors and intensity. Notice that in order to write a complex object, users need to provide an overload of <computeroutput><ref refid="classCGAL_1_1Output__rep" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::Output_rep</ref></computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2write_ply_points_example_8cpp-example" kindref="compound">Point_set_processing_3/write_ply_points_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/write_ply_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1cpp11_1_1array" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::array&lt;unsigned char, 4&gt;</ref><sp/>Color;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Point<sp/>with<sp/>normal,<sp/>color<sp/>and<sp/>intensity</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1cpp11_1_1tuple" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::tuple&lt;Point, Color, int&gt;</ref><sp/>PCI;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Nth__of__tuple__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Nth_of_tuple_property_map&lt;0, PCI&gt;</ref><sp/>Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Nth__of__tuple__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Nth_of_tuple_property_map&lt;1, PCI&gt;</ref><sp/>Color_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Nth__of__tuple__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Nth_of_tuple_property_map&lt;2, PCI&gt;</ref><sp/>Intensity_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Define<sp/>how<sp/>a<sp/>color<sp/>should<sp/>be<sp/>stored</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL" kindref="compound">CGAL</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>F<sp/>&gt;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Output_rep&lt;<sp/>::Color,<sp/>F<sp/>&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>::Color&amp;<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_specialized<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Output_rep<sp/>(const<sp/>::Color&amp;<sp/>c)<sp/>:<sp/>c(c)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ostream&amp;<sp/>operator()<sp/>(std::ostream&amp;<sp/>out)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PkgIOstreams_1ga120bfedfbc3d201a73b4824716e83990" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">is_ascii</ref>(out))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/>int(c[0])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>int(c[1])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>int(c[2])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>int(c[3]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out.write(reinterpret_cast&lt;const<sp/>char*&gt;(&amp;c),<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(c));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>out;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};<sp/></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;PCI&gt;<sp/>points;<sp/></highlight><highlight class="comment">//<sp/>store<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>10;<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points.push_back<sp/>(CGAL::cpp11::make_tuple<sp/>(Point<sp/>(i<sp/>/<sp/>10.,<sp/>i<sp/>/<sp/>20.,<sp/>i<sp/>/<sp/>30.),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::make_array<sp/>((</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">)(255<sp/>/<sp/>(i<sp/>+<sp/>1)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">)(192<sp/>/<sp/>(i<sp/>+<sp/>1)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">)(128<sp/>/<sp/>(i<sp/>+<sp/>1)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">)(64<sp/>/<sp/>(i<sp/>+<sp/>1))),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>f(</highlight><highlight class="stringliteral">&quot;out.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1gaf8eb8599079dfa427e0f34098bcc790b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_binary_mode</ref>(f);<sp/></highlight><highlight class="comment">//<sp/>The<sp/>PLY<sp/>file<sp/>will<sp/>be<sp/>written<sp/>in<sp/>the<sp/>binary<sp/>format</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgPointSetProcessingIOPly_1gaa9c84f9edcad73c46d9838618de9878e" kindref="member">CGAL::write_ply_points_with_properties</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(f,<sp/>points,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="group__PkgPointSetProcessingIOPly_1ga46a5d87f82f7c1f4a210d5e494d72c55" kindref="member">CGAL::make_ply_point_writer</ref><sp/>(Point_map()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>std::make_tuple(Color_map(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1PLY__property" kindref="compound">CGAL::PLY_property&lt;unsigned char&gt;</ref>(</highlight><highlight class="stringliteral">&quot;red&quot;</highlight><highlight class="normal">),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1PLY__property" kindref="compound">CGAL::PLY_property&lt;unsigned char&gt;</ref>(</highlight><highlight class="stringliteral">&quot;green&quot;</highlight><highlight class="normal">),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1PLY__property" kindref="compound">CGAL::PLY_property&lt;unsigned char&gt;</ref>(</highlight><highlight class="stringliteral">&quot;blue&quot;</highlight><highlight class="normal">),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1PLY__property" kindref="compound">CGAL::PLY_property&lt;unsigned char&gt;</ref>(</highlight><highlight class="stringliteral">&quot;alpha&quot;</highlight><highlight class="normal">)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>std::make_pair<sp/>(Intensity_map(),<sp/><ref refid="structCGAL_1_1PLY__property" kindref="compound">CGAL::PLY_property&lt;int&gt;</ref>(</highlight><highlight class="stringliteral">&quot;intensity&quot;</highlight><highlight class="normal">)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1Point_set_processing_3Example_ply_read">
<title>PLY Reading Example</title>
<para>The following example shows how to call <computeroutput><ref refid="namespaceCGAL_1a483fe42bbefcafce8a5d6194573a2715" kindref="member">read_ply_points_with_properties()</ref></computeroutput> to read a point set with points, normals, RGB colors and intensity and stores these attributes in a user-defined container.</para><para><linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2read_ply_points_with_colors_example_8cpp-example" kindref="compound">Point_set_processing_3/read_ply_points_with_colors_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_ply_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1cpp11_1_1array" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::array&lt;unsigned char, 3&gt;</ref><sp/>Color;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Point<sp/>with<sp/>normal,<sp/>color<sp/>and<sp/>intensity</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1cpp11_1_1tuple" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::tuple&lt;Point, Vector, Color, int&gt;</ref><sp/>PNCI;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Nth__of__tuple__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Nth_of_tuple_property_map&lt;0, PNCI&gt;</ref><sp/>Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Nth__of__tuple__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Nth_of_tuple_property_map&lt;1, PNCI&gt;</ref><sp/>Normal_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Nth__of__tuple__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Nth_of_tuple_property_map&lt;2, PNCI&gt;</ref><sp/>Color_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Nth__of__tuple__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Nth_of_tuple_property_map&lt;3, PNCI&gt;</ref><sp/>Intensity_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>fname<sp/>=<sp/>(argc&gt;1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/colors.ply&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.ply<sp/>point<sp/>set<sp/>file<sp/>with<sp/>normal<sp/>vectors<sp/>and<sp/>colors</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;PNCI&gt;<sp/>points;<sp/></highlight><highlight class="comment">//<sp/>store<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(fname);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="namespaceCGAL_1a483fe42bbefcafce8a5d6194573a2715" kindref="member">CGAL::read_ply_points_with_properties</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(in,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter<sp/>(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PkgPointSetProcessingIOPly_1gae8b88aed53f6aad119c4eae3d5ae48bf" kindref="member">CGAL::make_ply_point_reader</ref><sp/>(Point_map()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::make_pair<sp/>(Intensity_map(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1PLY__property" kindref="compound">CGAL::PLY_property&lt;int&gt;</ref>(</highlight><highlight class="stringliteral">&quot;intensity&quot;</highlight><highlight class="normal">)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::make_tuple<sp/>(Color_map(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1Construct__array" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Construct_array</ref>(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1PLY__property" kindref="compound">CGAL::PLY_property&lt;unsigned char&gt;</ref>(</highlight><highlight class="stringliteral">&quot;red&quot;</highlight><highlight class="normal">),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1PLY__property" kindref="compound">CGAL::PLY_property&lt;unsigned char&gt;</ref>(</highlight><highlight class="stringliteral">&quot;green&quot;</highlight><highlight class="normal">),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1PLY__property" kindref="compound">CGAL::PLY_property&lt;unsigned char&gt;</ref>(</highlight><highlight class="stringliteral">&quot;blue&quot;</highlight><highlight class="normal">)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PkgPointSetProcessingIOPly_1gaf72517e2162e7a558dfc20741dc6244a" kindref="member">CGAL::make_ply_normal_reader</ref><sp/>(Normal_map())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fname<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Display<sp/>points<sp/>read</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>points.size<sp/>();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p<sp/>=<sp/>get&lt;0&gt;(points[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Vector&amp;<sp/>n<sp/>=<sp/>get&lt;1&gt;(points[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Color&amp;<sp/>c<sp/>=<sp/>get&lt;2&gt;(points[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>get&lt;3&gt;(points[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Point<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>with<sp/>normal<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;),<sp/>color<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>int(c[0])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>int(c[1])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>int(c[2])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>and<sp/>intensity<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>I<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1Point_set_processing_3Example_las_read">
<title>LAS Reading Example</title>
<para>The following example shows how to call <computeroutput><ref refid="group__PkgPointSetProcessingIOLas_1gaf02431d387cc9b00ed932a41b164d389" kindref="member">read_las_points_with_properties()</ref></computeroutput> to read a point set with points and RGBI colors and stores these attributes in a user-defined container.</para><para><linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2read_las_example_8cpp-example" kindref="compound">Point_set_processing_3/read_las_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_las_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1cpp11_1_1array" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::array&lt;unsigned short, 4&gt;</ref><sp/>Color;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Point,<sp/>Color&gt;<sp/>PointWithColor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>fname<sp/>=<sp/>(argc&gt;1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/pig_points.las&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.las<sp/>point<sp/>set<sp/>file<sp/>with<sp/>normal<sp/>vectors<sp/>and<sp/>colors</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;PointWithColor&gt;<sp/>points;<sp/></highlight><highlight class="comment">//<sp/>store<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(fname,<sp/>std::ios_base::binary);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIOLas_1gaf02431d387cc9b00ed932a41b164d389" kindref="member">CGAL::read_las_points_with_properties</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(in,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter<sp/>(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PkgPointSetProcessingIOLas_1ga215c73a41ddab1c7bf1d35b23786a9ef" kindref="member">CGAL::make_las_point_reader</ref><sp/>(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointWithColor&gt;</ref>()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::make_tuple</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(<ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;PointWithColor&gt;</ref>(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1Construct__array" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Construct_array</ref>(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::LAS_property::R(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::LAS_property::G(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::LAS_property::B(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::LAS_property::I())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fname<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>points.size();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>points[i].first<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
</sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3Spacing">
<title>Average Spacing</title>
<para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1gabb9a90622271869b3f2393314075fa0e" kindref="member">compute_average_spacing()</ref></computeroutput> computes the average spacing of all input points to their <computeroutput>k</computeroutput> nearest neighbor points, <computeroutput>k</computeroutput> being specified by the user. As it provides an order of a point set density, this function is used downstream the surface reconstruction pipeline to automatically determine some parameters such as output mesh sizing for surface reconstruction.</para><sect2 id="index_1Point_set_processing_3Example_average_spacing">
<title>Example</title>
<para>The following example reads a point set in the <computeroutput>xyz</computeroutput> format and computes the average spacing. <ref refid="classIndex" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Index</ref>, position and color are stored in a tuple and accessed through property maps. <linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2average_spacing_example_8cpp-example" kindref="compound">Point_set_processing_3/average_spacing_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/compute_average_spacing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/tuple/tuple.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Data<sp/>type<sp/>:=<sp/>index,<sp/>followed<sp/>by<sp/>the<sp/>point,<sp/>followed<sp/>by<sp/>three<sp/>integers<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>define<sp/>the<sp/>Red<sp/>Green<sp/>Blue<sp/>color<sp/>of<sp/>the<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::tuple&lt;int,<sp/>Point,<sp/>int,<sp/>int,<sp/>int&gt;<sp/>IndexedPointWithColorTuple;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Concurrency</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Sequential__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Sequential_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>fname<sp/>=<sp/>(argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/sphere_20k.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.xyz<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>As<sp/>the<sp/>point<sp/>is<sp/>the<sp/>second<sp/>element<sp/>of<sp/>the<sp/>tuple<sp/>(that<sp/>is<sp/>with<sp/>index<sp/>1)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>use<sp/>a<sp/>property<sp/>map<sp/>that<sp/>accesses<sp/>the<sp/>1st<sp/>element<sp/>of<sp/>the<sp/>tuple.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;IndexedPointWithColorTuple&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>stream(fname);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stream<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">CGAL::read_xyz_points</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream,<sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1Nth__of__tuple__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Nth_of_tuple_property_map&lt;1,IndexedPointWithColorTuple&gt;</ref>())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fname<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>index<sp/>and<sp/>RGB<sp/>color<sp/>fields<sp/>in<sp/>tuple.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>As<sp/>the<sp/>index<sp/>and<sp/>RGB<sp/>color<sp/>are<sp/>respectively<sp/>the<sp/>first<sp/>and<sp/>third-fifth<sp/>elements</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>of<sp/>the<sp/>tuple<sp/>we<sp/>use<sp/>a<sp/>get<sp/>function<sp/>from<sp/>the<sp/>property<sp/>map<sp/>that<sp/>accesses<sp/>the<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>2-4th<sp/>elements<sp/>of<sp/>the<sp/>tuple.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>points.size();<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>points[i].get&lt;0&gt;()<sp/>=<sp/>i;<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>set<sp/>index<sp/>value<sp/>of<sp/>tuple<sp/>to<sp/>i</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>points[i].get&lt;2&gt;()<sp/>=<sp/>0;<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>set<sp/>RGB<sp/>color<sp/>to<sp/>black</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>points[i].get&lt;3&gt;()<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>points[i].get&lt;4&gt;()<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Computes<sp/>average<sp/>spacing.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb_neighbors<sp/>=<sp/>6;<sp/></highlight><highlight class="comment">//<sp/>1<sp/>ring</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>average_spacing<sp/>=<sp/>CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points,<sp/>nb_neighbors,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1Nth__of__tuple__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Nth_of_tuple_property_map&lt;1,IndexedPointWithColorTuple&gt;</ref>()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Average<sp/>spacing:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>average_spacing<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para><para>Note that other functions such as centroid or bounding volumes are found in other CGAL components:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__centroid__grp_1gacc395064255dfefdb1420309db234210" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">centroid()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPrincipalComponentAnalysisDbb_1ga7674a40dcf2ee64bebc89d97bf801c1d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Principal_component_analysis.tag">bounding_box()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Min__sphere__of__spheres__d" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Bounding_volumes.tag">Min_sphere_of_spheres_d</ref>&lt;Traits&gt;</computeroutput></para></listitem></itemizedlist>
</para></sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3Scale">
<title>Automatic Scale Estimation</title>
<para>Point sets are often used to sample objects with a higher dimension, typically a curve in 2D or a surface in 3D. In such cases, finding the scale of the objet is crucial, that is to say finding the minimal number of points (or the minimal local range) such that the subset of points has the appearance of a curve in 2D or a surface in 3D <ref refid="citelist_1CITEREF_cgal:gcsa-nasr-13" kindref="member">[2]</ref>.</para><para>CGAL provides 2 functions that automatically estimate the scale of a 2D point set sampling a curve or a 3D point set sampling a surface:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga7a0e851fd41f7ea2c640eff9f5a3fc2b" kindref="member">estimate_global_k_neighbor_scale()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga8b8e7e8e694d746cfa0bca11f87fb527" kindref="member">estimate_global_range_scale()</ref></computeroutput></para></listitem></itemizedlist>
</para><para>Functions such as <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga0cd0f87de690d4edf82740e856efa491" kindref="member">jet_estimate_normals()</ref></computeroutput> or <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1gafd0b5a21ec5042e4bca09cb43f1847f9" kindref="member">remove_outliers()</ref></computeroutput> require a K neighbor scale while others such as <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1gac7c81cc8a2986e3972e86612e4f847a1" kindref="member">grid_simplify_point_set()</ref></computeroutput> require a range scale. <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga020a2ee77849fc70cbbee93358222dff" kindref="member">vcm_estimate_normals()</ref></computeroutput> is an example of a function that accepts both.</para><para>In some specific cases, the scale of a point set might not be homogeneous (for example if the point set contains variable noise). CGAL also provides 2 functions that automatically estimate the scales of a point set at a set of user-defined query points:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1gab8b8b073db1b79e1cc482114044fd76c" kindref="member">estimate_local_k_neighbor_scales()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1gacc9353050636f6c746585639a282a7b8" kindref="member">estimate_local_range_scales()</ref></computeroutput></para></listitem></itemizedlist>
</para><para>The 4 functions presented here work both with 2D points and 3D points and they shouldn&apos;t be used if the point sets do not sample a curve in 2D or a surface in 3D.</para><sect2 id="index_1Point_set_processing_3Example_scale_estimation_global">
<title>Global Scale Example</title>
<para>The following example reads a 3D point set in the <computeroutput>xyz</computeroutput> format and:</para><para><itemizedlist>
<listitem><para>Estimates the K neighbor global scale</para></listitem><listitem><para>Uses it to smooth the point set</para></listitem><listitem><para>Estimates the range global scale</para></listitem><listitem><para>Uses it to simplify the point set</para></listitem></itemizedlist>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2scale_estimation_example_8cpp-example" kindref="compound">Point_set_processing_3/scale_estimation_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/estimate_scale.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/jet_smooth_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/grid_simplify_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Memory_sizer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/tuple/tuple.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Concurrency</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Sequential__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Sequential_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>fname<sp/>=<sp/>(argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/sphere_20k.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Timer<sp/>task_timer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_3&gt;<sp/>points;<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>stream(fname);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>input</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(stream</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/><ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">CGAL::read_xyz_points</ref>(stream,<sp/>std::back_inserter(points))))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>can&apos;t<sp/>read<sp/>input<sp/>file&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>estimate<sp/>k<sp/>scale</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task_timer.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>k_scale<sp/>=<sp/><ref refid="group__PkgPointSetProcessingAlgorithms_1ga7a0e851fd41f7ea2c640eff9f5a3fc2b" kindref="member">CGAL::estimate_global_k_neighbor_scale</ref><sp/>(points);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task_timer.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Example:<sp/>use<sp/>estimated<sp/>k<sp/>as<sp/>scale<sp/>for<sp/>jet<sp/>smoothing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(points,<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(k_scale));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>estimate<sp/>range<sp/>scale</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task_timer.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>range_scale<sp/>=<sp/><ref refid="group__PkgPointSetProcessingAlgorithms_1ga8b8e7e8e694d746cfa0bca11f87fb527" kindref="member">CGAL::estimate_global_range_scale</ref><sp/>(points);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task_timer.stop();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Example:<sp/>use<sp/>estimated<sp/>range<sp/>for<sp/>grid<sp/>simplification</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.erase<sp/>(<ref refid="group__PkgPointSetProcessingAlgorithms_1gac7c81cc8a2986e3972e86612e4f847a1" kindref="member">CGAL::grid_simplify_point_set</ref><sp/>(points,<sp/>range_scale),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>some<sp/>informations<sp/>on<sp/>runtime</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>memory<sp/>=<sp/>CGAL::Memory_sizer().virtual_size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>time<sp/>=<sp/>task_timer.time();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Scales<sp/>computed<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>time<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)<sp/>using<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>(memory&gt;&gt;20)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>MiB<sp/>of<sp/>memory:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>*<sp/>Global<sp/>K<sp/>scale:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k_scale<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>*<sp/>Global<sp/>range<sp/>scale:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>range_scale<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Point_set_processing_3Example_scale_estimation_local">
<title>Local Scales Example</title>
<para>This second example generates a 2D point set sampling a circle with variable noise. It then estimates the scale at 3 different query points in the domain.</para><para><linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2scale_estimation_2d_example_8cpp-example" kindref="compound">Point_set_processing_3/scale_estimation_2d_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/estimate_scale.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Random.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/tuple/tuple.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;<sp/>samples;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>samples.reserve<sp/>(100000);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Generate<sp/>circle<sp/>with<sp/>gradually<sp/>variable<sp/>noise</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>-<sp/>noise-free<sp/>for<sp/>points<sp/>with<sp/>x<sp/>close<sp/>to<sp/>(-1)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>-<sp/>noisy<sp/>for<sp/>points<sp/>with<sp/>x<sp/>close<sp/>to<sp/>(+1)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>100000;<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FT<sp/>theta<sp/>=<sp/>CGAL::get_default_random().get_double(0,<sp/>2.<sp/>*<sp/>CGAL_PI);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FT<sp/>noise<sp/>=<sp/>0.5<sp/>*<sp/>(std::cos(theta)<sp/>+<sp/>1.)<sp/>*<sp/>CGAL::get_default_random().get_double(0.,<sp/>0.2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>mult<sp/>=<sp/>(CGAL::get_default_random().get_bool()<sp/>?<sp/>1<sp/>:<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>samples.push_back<sp/>(Point_2<sp/>(std::cos(theta)<sp/>*<sp/>(1.<sp/>+<sp/>mult<sp/>*<sp/>noise<sp/>*<sp/>noise),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::sin(theta)<sp/>*<sp/>(1.<sp/>+<sp/>mult<sp/>*<sp/>noise<sp/>*<sp/>noise)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Search<sp/>for<sp/>local<sp/>scales<sp/>on<sp/>3<sp/>different<sp/>locations</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;<sp/>queries;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queries.reserve<sp/>(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queries.push_back<sp/>(Point_2<sp/>(-1.,<sp/>0.));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queries.push_back<sp/>(Point_2<sp/>(0.,<sp/>1.));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queries.push_back<sp/>(Point_2<sp/>(1.,<sp/>0.));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::size_t&gt;<sp/>k_scales;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgPointSetProcessingAlgorithms_1gab8b8b073db1b79e1cc482114044fd76c" kindref="member">CGAL::estimate_local_k_neighbor_scales</ref><sp/>(samples,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>queries,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter<sp/>(k_scales));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Display<sp/>results</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;K-Scales<sp/>found:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>-<sp/>On<sp/>noise-free<sp/>region:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k_scales[0]<sp/>&lt;&lt;<sp/>std::endl<sp/></highlight><highlight class="comment">//<sp/>Should<sp/>be<sp/>small</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>-<sp/>On<sp/>moderately<sp/>noisy<sp/>region:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k_scales[1]<sp/>&lt;&lt;<sp/>std::endl<sp/></highlight><highlight class="comment">//<sp/>Should<sp/>be<sp/>higher</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>-<sp/>On<sp/>very<sp/>noisy<sp/>region:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k_scales[2]<sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight><highlight class="comment">//<sp/>Should<sp/>be<sp/>even<sp/>higher</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3OutlierRemoval">
<title>Outlier Removal</title>
<para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1gafd0b5a21ec5042e4bca09cb43f1847f9" kindref="member">remove_outliers()</ref></computeroutput> deletes a user-specified fraction of outliers from an input point set. More specifically, it sorts the input points in increasing order of average squared distances to their <computeroutput>k</computeroutput> nearest neighbors and deletes the points with largest value.</para><sect2 id="index_1Point_set_processing_3Example_outlier_removal">
<title>Example</title>
<para>The following example reads a point set and removes 5% of the points. It uses the <computeroutput><ref refid="structCGAL_1_1Identity__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">Identity_property_map</ref>&lt;<ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_3</ref>&gt;</computeroutput> property map (optional as it is the default position property map of all functions in this component.) <linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2remove_outliers_example_8cpp-example" kindref="compound">Point_set_processing_3/remove_outliers_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/compute_average_spacing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/remove_outliers.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>fname<sp/>=<sp/>(argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/oni.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.xyz<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points[].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>Identity_property_map<sp/>property<sp/>map<sp/>can<sp/>be<sp/>omitted<sp/>here<sp/>as<sp/>it<sp/>is<sp/>the<sp/>default<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>stream(fname);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stream<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">CGAL::read_xyz_points</ref>(stream,<sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1Identity__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Identity_property_map&lt;Point&gt;</ref>())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fname<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Removes<sp/>outliers<sp/>using<sp/>erase-remove<sp/>idiom.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>Identity_property_map<sp/>property<sp/>map<sp/>can<sp/>be<sp/>omitted<sp/>here<sp/>as<sp/>it<sp/>is<sp/>the<sp/>default<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb_neighbors<sp/>=<sp/>24;<sp/></highlight><highlight class="comment">//<sp/>considers<sp/>24<sp/>nearest<sp/>neighbor<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Estimate<sp/>scale<sp/>of<sp/>the<sp/>point<sp/>set<sp/>with<sp/>average<sp/>spacing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>average_spacing<sp/>=<sp/>CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(points,<sp/>nb_neighbors);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>FIRST<sp/>OPTION<sp/>//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>I<sp/>don&apos;t<sp/>know<sp/>the<sp/>ratio<sp/>of<sp/>outliers<sp/>present<sp/>in<sp/>the<sp/>point<sp/>set</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;::iterator<sp/>first_to_remove</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>=<sp/><ref refid="group__PkgPointSetProcessingAlgorithms_1gafd0b5a21ec5042e4bca09cb43f1847f9" kindref="member">CGAL::remove_outliers</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(points,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>nb_neighbors,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::threshold_percent<sp/>(100.).<sp/></highlight><highlight class="comment">//<sp/>No<sp/>limit<sp/>on<sp/>the<sp/>number<sp/>of<sp/>outliers<sp/>to<sp/>remove</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>threshold_distance<sp/>(2.<sp/>*<sp/>average_spacing));<sp/></highlight><highlight class="comment">//<sp/>Point<sp/>with<sp/>distance<sp/>above<sp/>2*average_spacing<sp/>are<sp/>considered<sp/>outliers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>(100.<sp/>*<sp/>std::distance(first_to_remove,<sp/>points.end())<sp/>/<sp/>(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)(points.size()))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;%<sp/>of<sp/>the<sp/>points<sp/>are<sp/>considered<sp/>outliers<sp/>when<sp/>using<sp/>a<sp/>distance<sp/>threshold<sp/>of<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>2.<sp/>*<sp/>average_spacing<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>SECOND<sp/>OPTION<sp/>//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>I<sp/>know<sp/>the<sp/>ratio<sp/>of<sp/>outliers<sp/>present<sp/>in<sp/>the<sp/>point<sp/>set</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>removed_percentage<sp/>=<sp/>5.0;<sp/></highlight><highlight class="comment">//<sp/>percentage<sp/>of<sp/>points<sp/>to<sp/>remove</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.erase(<ref refid="group__PkgPointSetProcessingAlgorithms_1gafd0b5a21ec5042e4bca09cb43f1847f9" kindref="member">CGAL::remove_outliers</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(points,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nb_neighbors,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::threshold_percent(removed_percentage).<sp/></highlight><highlight class="comment">//<sp/>Minimum<sp/>percentage<sp/>to<sp/>remove</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>threshold_distance(0.)),<sp/></highlight><highlight class="comment">//<sp/>No<sp/>distance<sp/>threshold<sp/>(can<sp/>be<sp/>omitted)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Optional:<sp/>after<sp/>erase(),<sp/>use<sp/>Scott<sp/>Meyer&apos;s<sp/>&quot;swap<sp/>trick&quot;<sp/>to<sp/>trim<sp/>excess<sp/>capacity</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;(points).swap(points);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3Simplification">
<title>Simplification</title>
<para>Four simplification functions are devised to reduce an input point set.</para><para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga4be2d94f1791d24b8ba0107bc33ad6dc" kindref="member">random_simplify_point_set()</ref></computeroutput> randomly deletes a user-specified fraction of points from the input point set. This algorithm is fast.</para><para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1gac7c81cc8a2986e3972e86612e4f847a1" kindref="member">grid_simplify_point_set()</ref></computeroutput> considers a regular grid covering the bounding box of the input point set, and clusters all points sharing the same cell of the grid by picking as representant one arbitrarily chosen point. This algorithm is slower than <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga4be2d94f1791d24b8ba0107bc33ad6dc" kindref="member">random_simplify_point_set()</ref></computeroutput>.</para><para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga149ceecc075a180669bde3e65742fdf5" kindref="member">hierarchy_simplify_point_set()</ref></computeroutput> provides an adaptive simplification of the point set through local clusters <ref refid="citelist_1CITEREF_cgal:pgk-esops-02" kindref="member">[8]</ref>. The size of the clusters is either directly selected by the user or it automatically adapts to the local variation of the point set.</para><para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1gacbddbfa4e9c4c32c42d981a6a050d8cd" kindref="member">wlop_simplify_and_regularize_point_set()</ref></computeroutput> not only simplifies, but also regularizes downsampled points. This is an implementation of the Weighted Locally Optimal Projection (WLOP) algorithm <ref refid="citelist_1CITEREF_wlop-2009" kindref="member">[4]</ref>.</para><sect2 id="index_1Point_set_processing_3Example_grid_simplification">
<title>Grid Simplification Example</title>
<para>The following example reads a point set and simplifies it by clustering. <linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2grid_simplification_example_8cpp-example" kindref="compound">Point_set_processing_3/grid_simplification_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/grid_simplify_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.xyz<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points[].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>fname<sp/>=<sp/>(argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/oni.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>stream(fname);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stream<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">CGAL::read_xyz_points</ref>(stream,<sp/>std::back_inserter(points)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fname<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>simplification<sp/>by<sp/>clustering<sp/>using<sp/>erase-remove<sp/>idiom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>cell_size<sp/>=<sp/>0.001;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.erase(<ref refid="group__PkgPointSetProcessingAlgorithms_1gac7c81cc8a2986e3972e86612e4f847a1" kindref="member">CGAL::grid_simplify_point_set</ref>(points,<sp/>cell_size),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Optional:<sp/>after<sp/>erase(),<sp/>use<sp/>Scott<sp/>Meyer&apos;s<sp/>&quot;swap<sp/>trick&quot;<sp/>to<sp/>trim<sp/>excess<sp/>capacity</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;(points).swap(points);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__Point_set_processing_3figgrid_simplification"/><image type="html" name="grid_simplification.jpg"></image>
 <image type="latex" name="grid_simplification.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figgrid_simplification" kindref="member">fig__Point_set_processing_3figgrid_simplification</ref> Point set simplification through grid-based clustering. Removed points are depicted in red. Notice how low-density areas (in green) are not simplified.  <linebreak/>
</para></sect2>
<sect2 id="index_1Point_set_processing_3Example_hierarchy_simplication">
<title>Hierarchy Simplification Example</title>
<para>The following example reads a point set and produces a set of clusters.</para><para><linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2hierarchy_simplification_example_8cpp-example" kindref="compound">Point_set_processing_3/hierarchy_simplification_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/hierarchy_simplify_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/write_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Memory_sizer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.xyz<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points[].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>fname<sp/>=<sp/>(argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/oni.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>stream(fname);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stream<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">CGAL::read_xyz_points</ref>(stream,<sp/>std::back_inserter(points)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fname<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Read<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points.size<sp/>()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>point(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Timer<sp/>task_timer;<sp/>task_timer.start();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>simplification<sp/>by<sp/>clustering<sp/>using<sp/>erase-remove<sp/>idiom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.erase<sp/>(<ref refid="group__PkgPointSetProcessingAlgorithms_1ga149ceecc075a180669bde3e65742fdf5" kindref="member">CGAL::hierarchy_simplify_point_set</ref><sp/>(points,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::size(100).<sp/></highlight><highlight class="comment">//<sp/>Max<sp/>cluster<sp/>size</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maximum_variation(0.01)),<sp/></highlight><highlight class="comment">//<sp/>Max<sp/>surface<sp/>variation</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points.end<sp/>());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>memory<sp/>=<sp/>CGAL::Memory_sizer().virtual_size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>points.size<sp/>()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>point(s)<sp/>kept,<sp/>computed<sp/>in<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>task_timer.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds,<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>(memory&gt;&gt;20)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>Mib<sp/>allocated.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>f<sp/>(</highlight><highlight class="stringliteral">&quot;out.xyz&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgPointSetProcessingIO_1ga63d1f8f5933d843d8a179a1be4b0dd8f" kindref="member">CGAL::write_xyz_points</ref><sp/>(f,<sp/>points);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para><sect3 id="index_1Point_set_processing_3Hierarchy_simplification_parameter_size">
<title>Parameter: size</title>
<para>The hierarchy simplification algorithm recursively split the point set in two until each cluster&apos;s size is less than the parameter <computeroutput>size</computeroutput>.</para><para><anchor id="index_1fig__Point_set_processing_3figHierarchy_simplification_size"/><image type="html" name="hierarchical_clustering_size.jpg"></image>
 <image type="latex" name="hierarchical_clustering_size.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figHierarchy_simplification_size" kindref="member">fig__Point_set_processing_3figHierarchy_simplification_size</ref> Input point set and hierarchy simplification with different <computeroutput>size</computeroutput> parameter: <formula id="0">$10$</formula>, <formula id="1">$100$</formula> and <formula id="2">$1000$</formula>. In the 3 cases, <computeroutput>var_max</computeroutput> <formula id="3">$=1/3$</formula>. <linebreak/>
</para></sect3>
<sect3 id="index_1Point_set_processing_3Hierarchy_simplification_parameter_var_max">
<title>Parameter: var_max</title>
<para>In addition to the size parameter, a variation parameter allows to increase simplification in monotoneous regions. For each cluster, a surface variation measure is computed using the sorted eigenvalues of the covariance matrix: <formula id="4">\[ \sigma(p) = \frac{\lambda_0}{\lambda_0 + \lambda_1 + \lambda_2}. \]</formula></para><para>This function goes from <formula id="5">$0$</formula> if the cluster is coplanar to <formula id="6">$1/3$</formula> if it is fully isotropic. If a cluster&apos;s variation is above <computeroutput>var_max</computeroutput>, it is split. If <computeroutput>var_max</computeroutput> is equal to <formula id="6">$1/3$</formula>, this parameter has no effect and the clustering is regular on the whole point set.</para><para><anchor id="index_1fig__Point_set_processing_3figHierarchical_clustering_var_max"/><image type="html" name="hierarchical_clustering_var_max.jpg"></image>
 <image type="latex" name="hierarchical_clustering_var_max.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figHierarchical_clustering_var_max" kindref="member">fig__Point_set_processing_3figHierarchical_clustering_var_max</ref> Input point set and hierarchy simplification with different <computeroutput>var_max</computeroutput> parameter: <formula id="7">$0.00001$</formula>, <formula id="8">$0.001$</formula> and <formula id="9">$0.1$</formula>. In the 3 cases, <computeroutput>size</computeroutput> <formula id="10">$=1000$</formula>. <linebreak/>
</para></sect3>
</sect2>
<sect2 id="index_1Point_set_processing_3Example_wlop">
<title>WLOP Simplification Example</title>
<para>The following example reads a point set, simplifies and regularizes it by WLOP.</para><para><linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2wlop_simplify_and_regularize_point_set_example_8cpp-example" kindref="compound">Point_set_processing_3/wlop_simplify_and_regularize_point_set_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/wlop_simplify_and_regularize_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/write_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Concurrency</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Sequential__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Sequential_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>input_filename<sp/>=<sp/>(argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/sphere_20k.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>output_filename<sp/>=<sp/>(argc&gt;2)?argv[2]:</highlight><highlight class="stringliteral">&quot;data/sphere_20k_WLOPED.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.xyz<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points[]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>stream(input_filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stream<sp/>||<sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">CGAL::read_xyz_points</ref>(stream,<sp/>std::back_inserter(points)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>input_filename<sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>output;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//parameters</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>retain_percentage<sp/>=<sp/>2;<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>percentage<sp/>of<sp/>points<sp/>to<sp/>retain.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>neighbor_radius<sp/>=<sp/>0.5;<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>neighbors<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::wlop_simplify_and_regularize_point_set&lt;Concurrency_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(points,<sp/>std::back_inserter(output),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::select_percentage(retain_percentage).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>neighbor_radius<sp/>(neighbor_radius));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out(output_filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!out<sp/>||<sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga63d1f8f5933d843d8a179a1be4b0dd8f" kindref="member">CGAL::write_xyz_points</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out,<sp/>output))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__Point_set_processing_3figsimplification_comparison"/><image type="html" name="simplification_comparison.jpg"></image>
 <image type="latex" name="simplification_comparison.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figsimplification_comparison" kindref="member">fig__Point_set_processing_3figsimplification_comparison</ref> Comparison for three simplification methods: Left: Random simplification result. Middle: Grid simplification result. Right: WLOP simplification result.  <linebreak/>
</para><sect3 id="index_1Point_set_processing_3WLOP_Parameter">
<title>Parameter: require_uniform_sampling</title>
<para>Computing density weights for each point is an optional preprocessing. For example, as shown in the following figure, when require_uniform_sampling is set to false, WLOP preserves the intrinsic non-uniform sampling of the original points; if require_uniform_sampling is set to true, WLOP is resilient to non-uniform sampling and generates sample points with more uniform distribution, at the expense of computational time.</para><para><anchor id="index_1fig__Point_set_processing_3figWLOP_parameter_density"/><image type="html" name="WLOP_parameter_density.jpg"></image>
 <image type="latex" name="WLOP_parameter_density.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figWLOP_parameter_density" kindref="member">fig__Point_set_processing_3figWLOP_parameter_density</ref> Comparison between with and without density: Left: input. Middle: <computeroutput>require_uniform_sampling = false</computeroutput>. Right: <computeroutput>require_uniform_sampling=true</computeroutput>.  <linebreak/>
</para></sect3>
<sect3 id="index_1Point_set_processing_3WLOP_parameter_neighborhood_size">
<title>Parameter: neighbor_radius</title>
<para>Usually, the neighborhood of sample points should include at least two rings of neighboring sample points. Using a small neighborhood size may not be able to generate regularized result, while using big neighborhood size will make the sample points shrink into the interior of the local surface (under-fitting). The function will use a neighborhood size estimation if this parameter value is set to default or smaller that zero.</para><para><anchor id="index_1fig__Point_set_processing_3figWLOP_parameter_neighborhood_size"/><image type="html" name="WLOP_parameter_neighborhood_size.jpg"></image>
 <image type="latex" name="WLOP_parameter_neighborhood_size.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figWLOP_parameter_neighborhood_size" kindref="member">fig__Point_set_processing_3figWLOP_parameter_neighborhood_size</ref> Comparison between different sizes of neighbor radius.  <linebreak/>
</para></sect3>
<sect3 id="index_1Point_set_processing_3WLOP_parallel_performance">
<title>Parallel Performance</title>
<para>A parallel version of WLOP is provided and requires the executable to be linked against the <ulink url="http://www.threadingbuildingblocks.org">Intel TBB library</ulink>. To control the number of threads used, the user may use the tbb::task_scheduler_init class. See the <ulink url="http://www.threadingbuildingblocks.org/documentation">TBB documentation</ulink> for more details. We provide below a speed-up chart generated using the parallel version of the WLOP algorithm. The machine used is a PC running Windows 7 64-bits with a 4-core <ulink url="mailto:i7-4700HQ@2.40GHz">i7-4700HQ@2.40GHz</ulink> CPU with 8GB of RAM.</para><para><anchor id="index_1fig__Point_set_processing_3figWLOP_parallel_performance"/><image type="html" name="parallel_WLOP_performance.jpg"></image>
 <image type="latex" name="parallel_WLOP_performance.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figWLOP_parallel_performance" kindref="member">fig__Point_set_processing_3figWLOP_parallel_performance</ref> Parallel WLOP speed-up, compared to the sequential version of the algorithm.  <linebreak/>
</para></sect3>
</sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3Smoothing">
<title>Smoothing</title>
<para>Two smoothing functions are devised to smooth an input point set.</para><para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga549402c0a8a8b6b71875181e93961521" kindref="member">jet_smooth_point_set()</ref></computeroutput> smooths the input point set by projecting each point onto a smooth parametric surface patch (so-called jet surface) fitted over its <computeroutput>k</computeroutput> nearest neighbors.</para><para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga4f82723e2f0bb33f3677e29e0208a256" kindref="member">bilateral_smooth_point_set()</ref></computeroutput> smooths the input point set by iteratively projecting each point onto the implicit surface patch fitted over its <computeroutput>k</computeroutput> nearest neighbors. Bilateral projection preserves sharp features according to the normal (gradient) information. Normals are thus required as input. For more details, see section 4 of <ref refid="citelist_1CITEREF_ear-2013" kindref="member">[5]</ref>.</para><sect2 id="index_1Point_set_processing_3Example_jet_smoothing">
<title>Jet Smoothing Example</title>
<para>The following example generates a set of 9 points close to the <computeroutput>xy</computeroutput> plane and smooths them using 8 nearest neighbors: <linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2jet_smoothing_example_8cpp-example" kindref="compound">Point_set_processing_3/jet_smoothing_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/jet_smooth_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Concurrency</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Sequential__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Sequential_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>generate<sp/>point<sp/>set</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(<sp/>0.0,<sp/>0.0,<sp/>0.001));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(-0.1,-0.1,<sp/>0.002));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(-0.1,-0.2,<sp/>0.001));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(-0.1,<sp/>0.1,<sp/>0.002));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(<sp/>0.1,-0.1,<sp/>0.000));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(<sp/>0.1,<sp/>0.2,<sp/>0.001));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(<sp/>0.2,<sp/>0.0,<sp/>0.002));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(<sp/>0.2,<sp/>0.1,<sp/>0.000));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(<sp/>0.0,-0.1,<sp/>0.001));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Smoothing.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb_neighbors<sp/>=<sp/>8;<sp/></highlight><highlight class="comment">//<sp/>default<sp/>is<sp/>24<sp/>for<sp/>real-life<sp/>point<sp/>sets</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points,<sp/>nb_neighbors);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Point_set_processing_3Example_bilateral_smoothing">
<title>Bilateral Smoothing Example</title>
<para>The following example reads a set of points with normals and smooths them via bilateral smoothing: <linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2bilateral_smooth_point_set_example_8cpp-example" kindref="compound">Point_set_processing_3/bilateral_smooth_point_set_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/write_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/bilateral_smooth_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/tags.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>defines<sp/>std::pair</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Point<sp/>with<sp/>normal<sp/>vector<sp/>stored<sp/>in<sp/>a<sp/>std::pair.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Point,<sp/>Vector&gt;<sp/>PointVectorPair;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Concurrency</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Sequential__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Sequential_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>input_filename<sp/>=<sp/><sp/>(argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/fin90_with_PCA_normals.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>output_filename<sp/>=<sp/>(argc&gt;2)?argv[2]:</highlight><highlight class="stringliteral">&quot;data/fin90_with_PCA_normals_bilateral_smoothed.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.xyz<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points[]<sp/>*<sp/>with<sp/>normals<sp/>*.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;PointVectorPair&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>stream(input_filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stream<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">CGAL::read_xyz_points</ref>(stream,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(<ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</ref>())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>input_filename<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Algorithm<sp/>parameters</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>120;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>size<sp/>of<sp/>neighborhood.<sp/>The<sp/>bigger<sp/>the<sp/>smoother<sp/>the<sp/>result<sp/>will<sp/>be.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>value<sp/>should<sp/>bigger<sp/>than<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>sharpness_angle<sp/>=<sp/>25;<sp/></highlight><highlight class="comment">//<sp/>control<sp/>sharpness<sp/>of<sp/>the<sp/>result.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>bigger<sp/>the<sp/>smoother<sp/>the<sp/>result<sp/>will<sp/>be</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iter_number<sp/>=<sp/>3;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>number<sp/>of<sp/>times<sp/>the<sp/>projection<sp/>is<sp/>applied</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>iter_number;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>double<sp/>error<sp/>=<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::bilateral_smooth_point_set<sp/>&lt;Concurrency_tag&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>points,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>k,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(<ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>sharpness_angle<sp/>(sharpness_angle));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out(output_filename);<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!out<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga63d1f8f5933d843d8a179a1be4b0dd8f" kindref="member">CGAL::write_xyz_points</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>out,<sp/>points,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(<ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</ref>())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__Point_set_processing_3figsmoothing_comparison"/><image type="html" name="smoothing_comparison.jpg"></image>
 <image type="latex" name="smoothing_comparison.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figsmoothing_comparison" kindref="member">fig__Point_set_processing_3figsmoothing_comparison</ref> Comparison for two smoothing methods: Left: Input, 250K points, normal-color mapping. Middle: Jet smoothing result, 197 seconds. Right: Bilateral smoothing result, 110 seconds.  <linebreak/>
</para><sect3 id="index_1Point_set_processing_3Bilateral_smoothing_parallel_performance">
<title>Parallel</title>
<para>Performance: A parallel version of bilateral smoothing is provided and requires the executable to be linked against the <ulink url="http://www.threadingbuildingblocks.org">Intel TBB library</ulink>. The number of threads used is controlled through the tbb::task_scheduler_init class. See the <ulink url="http://www.threadingbuildingblocks.org/documentation">TBB documentation</ulink> for more details. We provide below a speed-up chart generated using the parallel version of the bilateral smoothing algorithm. The machine used is a PC running Windows 7 64-bits with a 4-core <ulink url="mailto:i7-4700HQ@2.40GHz">i7-4700HQ@2.40GHz</ulink> CPU with 8GB of RAM.</para><para><anchor id="index_1fig__Point_set_processing_3Bilateral_smoothing_parallel_performance"/><image type="html" name="parallel_bilateral_smooth_point_set_performance.jpg"></image>
 <image type="latex" name="parallel_bilateral_smooth_point_set_performance.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3Bilateral_smoothing_parallel_performance" kindref="member">fig__Point_set_processing_3Bilateral_smoothing_parallel_performance</ref> Parallel bilateral smoothing speed-up, compared to the sequential version of the algorithm.  <linebreak/>
</para></sect3>
</sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3NormalEstimation">
<title>Normal Estimation</title>
<para>Assuming a point set sampled over an inferred surface <bold>S</bold>, two functions provide an estimate of the normal to <bold>S</bold> at each point. The result is an unoriented normal vector for each input point.</para><para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga0cd0f87de690d4edf82740e856efa491" kindref="member">jet_estimate_normals()</ref></computeroutput> estimates the normal direction at each point from the input set by fitting a jet surface over its <computeroutput>k</computeroutput> nearest neighbors. The default jet is a quadric surface. This algorithm is well suited to point sets scattered over curved surfaces.</para><para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga8c642da96a025ab32445aeb6cc219b0b" kindref="member">pca_estimate_normals()</ref></computeroutput> estimates the normal direction at each point from the set by linear least squares fitting of a plane over its <computeroutput>k</computeroutput> nearest neighbors. This algorithm is simpler and faster than <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga0cd0f87de690d4edf82740e856efa491" kindref="member">jet_estimate_normals()</ref></computeroutput>.</para><para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga020a2ee77849fc70cbbee93358222dff" kindref="member">vcm_estimate_normals()</ref></computeroutput> estimates the normal direction at each point from the set by using the Voronoi Covariance Measure of the point set. This algorithm is more complex and slower than the previous algorithms. It is based on the article <ref refid="citelist_1CITEREF_cgal:mog-vbcfe-11" kindref="member">[7]</ref>.</para></sect1>
<sect1 id="index_1Point_set_processing_3NormalOrientation">
<title>Normal Orientation</title>
<para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga50c98d5c5ae5535bce6f32eddbd03f33" kindref="member">mst_orient_normals()</ref></computeroutput> orients the normals of a set of points with unoriented normals using the method described by Hoppe et al. in <emphasis>Surface reconstruction from unorganized points</emphasis> <ref refid="citelist_1CITEREF_cgal:hddms-srup-92" kindref="member">[3]</ref>. More specifically, this method constructs a Riemannian graph over the input points (the graph of the <computeroutput>k</computeroutput> nearest neighbor points) and propagates a seed normal orientation within a minimum spanning tree computed over this graph. The result is an oriented normal vector for each input unoriented normal, except for the normals which cannot be successfully oriented.</para><para><anchor id="index_1fig__Point_set_processing_3figmst_orient_normals"/><image type="html" name="mst_orient_normals.jpg"></image>
 <image type="latex" name="mst_orient_normals.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figmst_orient_normals" kindref="member">fig__Point_set_processing_3figmst_orient_normals</ref> Normal orientation of a sampled cube surface. Left: unoriented normals. Right: orientation of right face normals is propagated to bottom face.  <linebreak/>
</para><sect2 id="index_1Point_set_processing_3Example_normals">
<title>Example</title>
<para>The following example reads a point set from a file, estimates the normals through PCA over the 6 nearest neighbors and orients the normals: <linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2normals_example_8cpp-example" kindref="compound">Point_set_processing_3/normals_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/pca_estimate_normals.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/mst_orient_normals.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>defines<sp/>std::pair</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Point<sp/>with<sp/>normal<sp/>vector<sp/>stored<sp/>in<sp/>a<sp/>std::pair.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Point,<sp/>Vector&gt;<sp/>PointVectorPair;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Concurrency</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Sequential__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Sequential_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>fname<sp/>=<sp/>(argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/sphere_1k.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.xyz<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points[].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::list&lt;PointVectorPair&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>stream(fname);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stream<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">CGAL::read_xyz_points</ref>(stream,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</ref>())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fname&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Estimates<sp/>normals<sp/>direction.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note:<sp/>pca_estimate_normals()<sp/>requiresa<sp/>range<sp/>of<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>as<sp/>well<sp/>as<sp/>property<sp/>maps<sp/>to<sp/>access<sp/>each<sp/>point&apos;s<sp/>position<sp/>and<sp/>normal.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb_neighbors<sp/>=<sp/>18;<sp/></highlight><highlight class="comment">//<sp/>K-nearest<sp/>neighbors<sp/>=<sp/>3<sp/>rings</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::pca_estimate_normals&lt;Concurrency_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(points,<sp/>nb_neighbors,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(<ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</ref>()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Orients<sp/>normals.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note:<sp/>mst_orient_normals()<sp/>requires<sp/>a<sp/>range<sp/>of<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>as<sp/>well<sp/>as<sp/>property<sp/>maps<sp/>to<sp/>access<sp/>each<sp/>point&apos;s<sp/>position<sp/>and<sp/>normal.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::list&lt;PointVectorPair&gt;::iterator<sp/>unoriented_points_begin<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PkgPointSetProcessingAlgorithms_1ga50c98d5c5ae5535bce6f32eddbd03f33" kindref="member">CGAL::mst_orient_normals</ref>(points,<sp/>nb_neighbors,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(<ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</ref>()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Optional:<sp/>delete<sp/>points<sp/>with<sp/>an<sp/>unoriented<sp/>normal</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>you<sp/>plan<sp/>to<sp/>call<sp/>a<sp/>reconstruction<sp/>algorithm<sp/>that<sp/>expects<sp/>oriented<sp/>normals.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points.erase(unoriented_points_begin,<sp/>points.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3Upsampling">
<title>Upsampling</title>
<para>The function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga128b4cd2445490a0f1c3f573216ac477" kindref="member">edge_aware_upsample_point_set()</ref></computeroutput> generates a denser point set from an input point set. This has applications in point-based rendering, hole filling, and sparse surface reconstruction. The algorithm can progressively upsample the point set while approaching the edge singularities. See <ref refid="citelist_1CITEREF_ear-2013" kindref="member">[5]</ref> for more details.</para><sect2 id="index_1Point_set_processing_3Example_upsampling">
<title>Example</title>
<para>The following example reads a point set from a file, upsamples it to get a denser result.</para><para><linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2edge_aware_upsample_point_set_example_8cpp-example" kindref="compound">Point_set_processing_3/edge_aware_upsample_point_set_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/edge_aware_upsample_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/write_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Point<sp/>with<sp/>normal<sp/>vector<sp/>stored<sp/>in<sp/>a<sp/>std::pair.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Point,<sp/>Vector&gt;<sp/>PointVectorPair;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Concurrency</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Sequential__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Sequential_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>input_filename<sp/>=<sp/>(argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/before_upsample.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>output_filename<sp/>=<sp/>(argc&gt;2)?argv[2]:</highlight><highlight class="stringliteral">&quot;data/before_upsample_UPSAMPLED.xyz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.xyz<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points[],<sp/>*with<sp/>normals*.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;PointVectorPair&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>stream(input_filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stream<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">CGAL::read_xyz_points</ref>(stream,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(<ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</ref>())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>input_filename<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Algorithm<sp/>parameters</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>sharpness_angle<sp/>=<sp/>25;<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>control<sp/>sharpness<sp/>of<sp/>the<sp/>result.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>edge_sensitivity<sp/>=<sp/>0;<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>higher<sp/>values<sp/>will<sp/>sample<sp/>more<sp/>points<sp/>near<sp/>the<sp/>edges<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>neighbor_radius<sp/>=<sp/>0.25;<sp/><sp/></highlight><highlight class="comment">//<sp/>initial<sp/>size<sp/>of<sp/>neighborhood.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>number_of_output_points<sp/>=<sp/>points.size()<sp/>*<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//Run<sp/>algorithm<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::edge_aware_upsample_point_set&lt;Concurrency_tag&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>normal_map(<ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sharpness_angle(sharpness_angle).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>edge_sensitivity(edge_sensitivity).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>neighbor_radius(neighbor_radius).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>number_of_output_points(number_of_output_points));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Saves<sp/>point<sp/>set.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out(output_filename);<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!out<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga63d1f8f5933d843d8a179a1be4b0dd8f" kindref="member">CGAL::write_xyz_points</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>out,<sp/>points,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(<ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</ref>())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para><sect3 id="index_1Point_set_processing_3Upsample_Parameter1">
<title>Parameter: edge_sensitivity</title>
<para>This parameter controls where the new points are inserted. Larger values of edge-sensitivity give higher priority to inserting points along the sharp features. For example, as shown in the following figure, high value is preferable when one wants to insert more points on sharp features, where the local gradient is high, e.g., darts, cusps, creases and corners. In contrast, points are evenly inserted when edge_sensitivity is set to 0. The range of possible value is [0, 1].</para><para><anchor id="index_1fig__Point_set_processing_3figUpsample_edge_sensitivity"/><image type="html" name="upsample_edge_sensitivity.jpg"></image>
 <image type="latex" name="upsample_edge_sensitivity.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figUpsample_edge_sensitivity" kindref="member">fig__Point_set_processing_3figUpsample_edge_sensitivity</ref> Upsampling for different edge-sensitivity parameter values. The input containing 850 points is upsampled to 1,500 points in all cases depicted.  <linebreak/>
</para></sect3>
<sect3 id="index_1Point_set_processing_3Upsample_Parameter2">
<title>Parameter: sharpness_angle</title>
<para>This parameter controls the preservation of sharp features.</para><para><anchor id="index_1fig__Point_set_processing_3figUpsample_sharpness_angle"/><image type="html" name="upsample_sharpness_angle.jpg"></image>
 <image type="latex" name="upsample_sharpness_angle.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figUpsample_sharpness_angle" kindref="member">fig__Point_set_processing_3figUpsample_sharpness_angle</ref> Upsampling for different sharpness_angle parameter values. The input containing 850 points is upsampled to 425K points in all cases depicted.  <linebreak/>
</para></sect3>
<sect3 id="index_1Point_set_processing_3upsample_neighborhood_size">
<title>Parameter: neighbor_radius</title>
<para>Usually, the neighborhood of sample points should include at least one ring of neighboring sample points. Using small neighborhood size may not be able to insert new points. Using big neighborhood size can fill small holes, but points inserted on the edges could be irregular. The function will use a neigbhorhood size estimation if this parameter value is set to default or smaller than zero.</para><para><anchor id="index_1fig__Point_set_processing_3figupsample_neighborhood_size"/><image type="html" name="upsample_neighborhood_size.jpg"></image>
 <image type="latex" name="upsample_neighborhood_size.jpg" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figupsample_neighborhood_size" kindref="member">fig__Point_set_processing_3figupsample_neighborhood_size</ref> Comparison between different sizes of neighbor radius.  <linebreak/>
</para></sect3>
</sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3FeaturesEstimation">
<title>Feature Edges Estimation</title>
<para>Function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga8e6ef56bbe013f5cfdb955f592918807" kindref="member">vcm_is_on_feature_edge()</ref></computeroutput> indicates if a points belong to a feature edges of the point set using its Voronoi Covariance Measure. It is based on the article <ref refid="citelist_1CITEREF_cgal:mog-vbcfe-11" kindref="member">[7]</ref>.</para><para>It first computes the VCM of the points set using <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1ga6094c666830a87b4bb6ea0ed4c846dd3" kindref="member">compute_vcm()</ref></computeroutput>. Then, it estimates which points belong to a sharp edge by testing if a ratio of eigenvalues is greater than a given threshold.</para><sect2 id="index_1Point_set_processing_3Example_sharp_edges">
<title>Example</title>
<para>The following example reads a point set from a file, estimates the points that are on sharp edges: <linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2edges_example_8cpp-example" kindref="compound">Point_set_processing_3/edges_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/vcm_estimate_edges.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_off_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>defines<sp/>std::pair</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/foreach.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Point<sp/>with<sp/>normal<sp/>vector<sp/>stored<sp/>in<sp/>a<sp/>std::pair.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Point,<sp/>Vector&gt;<sp/>PointVectorPair;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;PointVectorPair&gt;<sp/>PointList;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1cpp11_1_1array" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::array&lt;double,6&gt;</ref><sp/>Covariance;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>.xyz<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points[].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::list&lt;PointVectorPair&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>stream(</highlight><highlight class="stringliteral">&quot;data/fandisk.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stream<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga1d0f58874ed1ddb2b00721f15ba362a9" kindref="member">CGAL::read_off_points</ref>(stream,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(<ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</ref>())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>data/fandisk.off&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Estimates<sp/>covariance<sp/>matrices<sp/>per<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>R<sp/>=<sp/>0.2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>r<sp/>=<sp/>0.1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Covariance&gt;<sp/>cov;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</ref><sp/>point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgPointSetProcessingAlgorithms_1ga6094c666830a87b4bb6ea0ed4c846dd3" kindref="member">CGAL::compute_vcm</ref>(points,<sp/>cov,<sp/>R,<sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map<sp/>(point_map).geom_traits<sp/>(Kernel()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>the<sp/>points<sp/>on<sp/>the<sp/>edges.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>this<sp/>step<sp/>is<sp/>not<sp/>expensive<sp/>and<sp/>can<sp/>be<sp/>done<sp/>several<sp/>time<sp/>to<sp/>get<sp/>better<sp/>results</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>threshold<sp/>=<sp/>0.16;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ofstream<sp/>output(</highlight><highlight class="stringliteral">&quot;points_on_edges.xyz&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>BOOST_FOREACH(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PointVectorPair&amp;<sp/>p,<sp/>points)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PkgPointSetProcessingAlgorithms_1ga8e6ef56bbe013f5cfdb955f592918807" kindref="member">CGAL::vcm_is_on_feature_edge</ref>(cov[i],<sp/>threshold))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output<sp/>&lt;&lt;<sp/>p.first<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3Structuring">
<title>Structuring</title>
<para>The function <computeroutput><ref refid="group__PkgPointSetProcessingAlgorithms_1gaebbc04909dfd575a94f932c8d3bacdce" kindref="member">structure_point_set()</ref></computeroutput> generates a structured version of the input point set assigned to a set of planes. Such an input can be produced by a shape detection algorithm (see <ref refid="packages_1PkgPointSetShapeDetection3Summary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Point Set Shape Detection</ref>). Point set structuring is based on the article <ref refid="citelist_1CITEREF_cgal:la-srpss-13" kindref="member">[6]</ref>.</para><para><itemizedlist>
<listitem><para><bold>Planes</bold>: inliers of each detected plane are replaced by sets of noise-free points sampled at the vertices of a regular grid: this is achieved by filling an occupancy grid aligned on the principal components of the inlier sets with a spacing lower than <formula id="11">$\sqrt{2}$</formula> times the user-defined tolerance.</para></listitem><listitem><para><bold>Creases</bold>: adjacencies between 2 planes are detected and regularly resampled on an occupancy array along the edge with a spacing equal to twice the user-defined tolerance.</para></listitem><listitem><para><bold>Corners</bold>: 3-cycles are detected from the primitive adjacency graph and sampled using the exact intersection point of the 3 planes (provided it exists and remains in the given tolerance). These corners are also locally clustered to former corners of degree higher than 3.</para></listitem></itemizedlist>
</para><para>This algorithm is well suited to point sets sampled on surfaces with planar sections and sharp edges.</para><para><anchor id="index_1fig__Point_set_processing_3figstructuring"/><image type="html" name="structuring.png"></image>
 <image type="latex" name="structuring.png" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figstructuring" kindref="member">fig__Point_set_processing_3figstructuring</ref> Point set structuring. Left: input raw point set. Right: structured point set.  <linebreak/>
</para><para>Structure information of points can be used to perform feature preserving reconstruction (see <ref refid="index_1AFSR_Example_sharp_features" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag">Advancing Front Surface Reconstruction</ref> for example). More specifically, the class storing a point set with structure provides the user with a method <computeroutput><ref refid="classCGAL_1_1Point__set__with__structure_1a751fbbdcdd8b0a07780082ec799a86db" kindref="member">Point_set_with_structure::facet_coherence()</ref></computeroutput> that estimates if a triplet of points form a coherent facet.</para><para><anchor id="index_1fig__Point_set_processing_3figstructuring_coherence"/><image type="html" name="structuring_coherence.png"></image>
 <image type="latex" name="structuring_coherence.png" width="15cm"></image>
  <ref refid="index_1fig__Point_set_processing_3figstructuring_coherence" kindref="member">fig__Point_set_processing_3figstructuring_coherence</ref> (a) Input point set (and structured output); (b) output with many incoherent facets; (c) output with all facets coherent. i, j and k each corresponds to a primitive index.  <linebreak/>
</para><sect2 id="index_1Point_set_processing_3Example_9">
<title>Example</title>
<para>The following example applies shape detection followed by structuring to a point set: <linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2structuring_example_8cpp-example" kindref="compound">Point_set_processing_3/structuring_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/write_xyz_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_with_normal_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Shape__detection__3_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL/Shape_detection_3.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/structure_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Type<sp/>declarations</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Kernel::Point_3,<sp/>Kernel::Vector_3&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_with_normal;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point_with_normal&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Pwn_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/><sp/>Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/>Normal_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Efficient<sp/>RANSAC<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Shape__detection__3_1_1Shape__detection__traits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Shape_detection_traits</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;Kernel,<sp/>Pwn_vector,<sp/>Point_map,<sp/>Normal_map&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection__3_1_1Efficient__RANSAC" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Efficient_RANSAC&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/>Efficient_ransac;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection__3_1_1Plane" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Plane&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Plane;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Points<sp/>with<sp/>normals.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Pwn_vector<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Loading<sp/>point<sp/>set<sp/>from<sp/>a<sp/>file.<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>stream(argc&gt;1<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/cube.pwn&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stream<sp/>||<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga2e8d677def85c5582ba1f01eda030628" kindref="member">CGAL::read_xyz_points</ref>(stream,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(Point_map()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(Normal_map())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>cube.pwn&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>points.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>point(s)<sp/>read.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Shape<sp/>detection</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Efficient_ransac<sp/>ransac;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.set_input(points);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.add_shape_factory&lt;Plane&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.detect();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Efficient_ransac::Plane_range<sp/>planes<sp/>=<sp/>ransac.planes();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Pwn_vector<sp/>structured_pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgPointSetProcessingAlgorithms_1gaebbc04909dfd575a94f932c8d3bacdce" kindref="member">CGAL::structure_point_set</ref><sp/>(points,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>planes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter<sp/>(structured_pts),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0.015,<sp/></highlight><highlight class="comment">//<sp/>epsilon<sp/>for<sp/>structuring<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map<sp/>(Point_map()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal_map<sp/>(Normal_map()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>plane_map<sp/>(<ref refid="classCGAL_1_1Shape__detection__3_1_1Plane__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Plane_map&lt;Traits&gt;</ref>()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>plane_index_map<sp/>(<ref refid="classCGAL_1_1Shape__detection__3_1_1Point__to__shape__index__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Point_to_shape_index_map&lt;Traits&gt;</ref>(points,<sp/>planes)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>structured_pts.size<sp/>()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>structured<sp/>point(s)<sp/>generated.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out<sp/>(</highlight><highlight class="stringliteral">&quot;out.pwn&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgPointSetProcessingIO_1ga63d1f8f5933d843d8a179a1be4b0dd8f" kindref="member">CGAL::write_xyz_points</ref><sp/>(out,<sp/>structured_pts,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(Point_map()).normal_map(Normal_map()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3Callbacks">
<title>Callbacks</title>
<para>Several functions of this package provide a callback mechanism that enables the user to track the progress of the algorithms and to interrupt them if needed. A callback, in this package, is an instance of <computeroutput><ref refid="classCGAL_1_1cpp11_1_1function" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::function</ref>&lt;bool(double)&gt;</computeroutput> that takes the advancement as a parameter (between 0. when the algorithm begins to 1. when the algorithm is completed) and that returns <computeroutput>true</computeroutput> if the algorithm should carry on, <computeroutput>false</computeroutput> otherwise. It is passed as a named parameter with an empty function as default.</para><para>Algorithms that support this mechanism are detailed in the <ref refid="group__PkgPointSetProcessing" kindref="compound">Reference Manual</ref>, along with the effect that an early interruption has on the output.</para><sect2 id="index_1Point_set_processing_3Example_callbacks">
<title>Example</title>
<para>The following example defines a callback that displays the name of the current algorithm along with the progress (as a percentage) updated every <formula id="12">$1/10th$</formula> of a second. While the algorithm is running, the console output will typically look like this:</para><para><programlisting><codeline><highlight class="normal">Computing<sp/>average<sp/>spacing:<sp/>100%</highlight></codeline>
<codeline><highlight class="normal">Grid<sp/>simplification:<sp/>100%</highlight></codeline>
<codeline><highlight class="normal">Jet<sp/>smoothing:<sp/>54%</highlight></codeline>
</programlisting></para><para>Thanks to the carriage return character <computeroutput>\r</computeroutput>, the lines are overwritten and the user sees the percentage increasing on each line.</para><para><linebreak/>
<bold>File</bold> <ref refid="Point_set_processing_3_2callback_example_8cpp-example" kindref="compound">Point_set_processing_3/callback_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Real_timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/compute_average_spacing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/grid_simplify_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/jet_smooth_point_set.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_on_sphere_3&lt;Point&gt;<sp/>Generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Concurrency</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Sequential__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Sequential_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>instance<sp/>of<sp/>CGAL::cpp11::function&lt;bool(double)&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Progress_to_std_cerr_callback</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">mutable</highlight><highlight class="normal"><sp/>std::size_t<sp/>nb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Real_timer<sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>t_start;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">mutable</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>t_latest;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>name;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Progress_to_std_cerr_callback<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>name)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>name<sp/>(name)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>timer.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>t_start<sp/>=<sp/>timer.time();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>t_latest<sp/>=<sp/>t_start;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>advancement)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Avoid<sp/>calling<sp/>time()<sp/>at<sp/>every<sp/>single<sp/>iteration,<sp/>which<sp/>could</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>impact<sp/>performances<sp/>very<sp/>badly</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++<sp/>nb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(advancement<sp/>!=<sp/>1<sp/>&amp;&amp;<sp/>nb<sp/>%<sp/>10000<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>t<sp/>=<sp/>timer.time();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(advancement<sp/>==<sp/>1<sp/>||<sp/>(t<sp/>-<sp/>t_latest)<sp/>&gt;<sp/>0.1)<sp/></highlight><highlight class="comment">//<sp/>Update<sp/>every<sp/>1/10th<sp/>of<sp/>second</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\r&quot;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>Return<sp/>at<sp/>the<sp/>beginning<sp/>of<sp/>same<sp/>line<sp/>and<sp/>overwrite</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>name<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>int(advancement<sp/>*<sp/>100)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;%&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(advancement<sp/>==<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>t_latest<sp/>=<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Generate<sp/>1000000<sp/>points<sp/>on<sp/>a<sp/>sphere<sp/>of<sp/>radius<sp/>100.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.reserve<sp/>(1000000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Generator<sp/>generator(100.);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__STLAlgos_1gadba21cc5c30a79519438dfe0f9264255" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::copy_n</ref><sp/>(generator,<sp/>1000000,<sp/>std::back_inserter(points));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>average<sp/>spacing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>average_spacing<sp/>=<sp/>CGAL::compute_average_spacing&lt;Concurrency_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(points,<sp/>6,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::callback</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>(Progress_to_std_cerr_callback(</highlight><highlight class="stringliteral">&quot;Computing<sp/>average<sp/>spacing&quot;</highlight><highlight class="normal">)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Simplify<sp/>on<sp/>a<sp/>grid<sp/>with<sp/>a<sp/>size<sp/>of<sp/>twice<sp/>the<sp/>average<sp/>spacing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.erase(<ref refid="group__PkgPointSetProcessingAlgorithms_1gac7c81cc8a2986e3972e86612e4f847a1" kindref="member">CGAL::grid_simplify_point_set</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(points,<sp/>2.<sp/>*<sp/>average_spacing,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::callback</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(Progress_to_std_cerr_callback(</highlight><highlight class="stringliteral">&quot;Grid<sp/>simplification&quot;</highlight><highlight class="normal">))),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Smooth<sp/>simplified<sp/>point<sp/>set</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(points,<sp/>6,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::callback</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>(Progress_to_std_cerr_callback(</highlight><highlight class="stringliteral">&quot;Jet<sp/>smoothing&quot;</highlight><highlight class="normal">)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Point_set_processing_3ImplementationHistory">
<title>Implementation History</title>
<para>Pierre Alliez and Laurent Saboret contributed the initial component. Nader Salman contributed the grid simplification. Started from GSoC&apos;2013, three new algorithms were implemented by Shihao Wu and Clément Jamin: WLOP, bilateral smoothing and upsampling. Started from GSoC&apos;2014, Jocelyn Meyron with the help of Quentin Mérigot introduced the computation of the Voronoi covarience measure of a point set, as well as the normal and feature edge estimation functions based on it. Florent Lafarge with the help of Simon Giraudot contributed the point set structuring algorithm. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
