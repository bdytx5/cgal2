<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_SetMovableSeparability2"/>  <simplesect kind="authors"><para>Shahar Shamai and Efi Fogel</para></simplesect>
</para><sect1 id="index_1sms_2_sec_intro">
<title>Introduction</title>
<para><emphasis>Movable Separability of Sets</emphasis> <ref refid="citelist_1CITEREF_t-mss-85" kindref="member">[2]</ref> is a class of problems that deal with moving sets of objects, such as polygons in the plane; the challenge is to avoid collisions between the objects while considering different kinds of motions and various definitions of separation. The <ulink url="https://en.wikipedia.org/wiki/Moving_sofa_problem">Moving sofa problem</ulink> or <emphasis>sofa problem</emphasis> is a classic member of this class. It is a two-dimensional idealisation of real-life furniture-moving problems; it asks for the rigid two-dimensional shape of largest area <formula id="4">$A$</formula> that can be maneuvered through an L-shaped planar region with legs of unit width <ref refid="citelist_1CITEREF_w-sf-76" kindref="member">[3]</ref>. The area <formula id="4">$A$</formula> thus obtained is referred to as the sofa constant. The exact value of the sofa constant is an open problem; see <ref refid="index_1fig__sms_2_fig_sofa_problem" kindref="member">fig__sms_2_fig_sofa_problem</ref>. These problems become progressively more challenging as the allowable set of separation motions becomes more complex (have more degrees of freedom), the number of objects involved grows, or the shape of the objects becomes more complicated.</para><para><anchor id="index_1fig__sms_2_fig_sofa_problem"/><image type="html" name="sofa_problem.png"></image>
 <image type="latex" name="sofa_problem.png" width="15cm"></image>
  <ref refid="index_1fig__sms_2_fig_sofa_problem" kindref="member">fig__sms_2_fig_sofa_problem</ref> The Hammersley sofa has area 2.2074 but is not the largest solution.  <linebreak/>
</para><para>At this point this package provides solutions to one subclass of problems related to 2D castings. In particular, each of these solutions handles a single moving polygon and a single stationary polygon, and considers a single translation of the moving polygon.</para></sect1>
<sect1 id="index_1sms_2_sec_casting">
<title>Casting</title>
<para>Casting is a manufacturing process where liquid material is poured into a cavity inside a mold, which has the shape of a desired product. (The mold can take any shape and form as long as it has a cavity of the desired shape.) After the material solidifies, the product is pulled out of the mold. Typically a mold is used to manufacture numerous copies of a product. The challenge is designing a proper mold, such that the solidified product can be separated from its mold without breaking it.</para><para>This package provides a function called <computeroutput><ref refid="group__top__edges__grp_1ga0ec79c21ecf966930e0b5265cad6bd80" kindref="member">CGAL::Set_movable_separability_2::Single_mold_translational_casting::top_edges()</ref></computeroutput> that, given a simple closed polygon <formula id="5">$P$</formula>, determines whether a cavity (of a mold in the plane) that has the shape of <formula id="5">$P$</formula> can be used so that the polygon <formula id="5">$P$</formula> could be pulled out of the mold without colliding into the mold (but possibly sliding along the mold boundary); see <ref refid="index_1fig__sms_2_fig_polygons" kindref="member">fig__sms_2_fig_polygons</ref> for an illustration. In reality, the mold of a <emphasis>castable</emphasis> polygon must be rotated before the polygon is casted, such that one edge becomes parallel to the <formula id="6">$x$</formula>-axis and is located above all other edges; such an edge is referred to as a <emphasis>top edge</emphasis>. A polygon may have up to four edges that can serve as top edges. If the polygon is <emphasis>castable</emphasis>, the function computes the set of top edges of such cavities and the corresponding closed ranges of pullout directions in the plane.</para><para><anchor id="index_1fig__sms_2_fig_polygons"/><image type="html" name="polygons.png"></image>
 <image type="latex" name="polygons.png" width="15cm"></image>
  <ref refid="index_1fig__sms_2_fig_polygons" kindref="member">fig__sms_2_fig_polygons</ref> Two castable polygons (light grey) in their molds (darker grey) and valid pullout directions on the left. Two non-castable polygons on the right.  <linebreak/>
</para><para>The input polygon must satisfy two conditions as follows. First, it has to be simple. Essentially, a simple polygon is topologically equivalent to a disk; see Chapter <ref refid="index_1Chapter_2D_Regularized_Boolean_Set-Operations" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">2D Regularized Boolean</ref>Set-Operations" for the precise definition of simple polygons. Secondly, any consecutive three vertices cannot be collinear. If you suspect that the input polygon may not satisfy the latter condition, pre-process the polygon to elliminate this ill-condition.</para><para>The implementation is based on an algorithm developed by Shamai and Halperin; see <ref refid="citelist_1CITEREF_cgal:ss-spfis-16" kindref="member">[1]</ref> for the generalization of the algorithm to 3D. The time and space complexities are in <formula id="7">$O(n)$</formula> and <formula id="8">$O(1)$</formula>, respectively. In order to ensure robustness and correctness you must use a kernel that guarantees exact constructions as well as exact predicates, e,g,. <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput>.</para><para>The following example computes the top edges and their pullout directions of an input polygon read from a file and reports the results.</para><para><linebreak/>
<bold>File</bold> <ref refid="Set_movable_separability_2_2top_edges_single_mold_trans_cast_8cpp-example" kindref="compound">Set_movable_separability_2/top_edges_single_mold_trans_cast.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Set_movable_separability_2/Single_mold_translational_casting/top_edges.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Direction__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Direction_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Direction_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>direction<sp/>range<sp/>is<sp/>a<sp/>closed<sp/>range<sp/>of<sp/>directions<sp/>on<sp/>the<sp/>unit<sp/>circle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Direction_2,<sp/>Direction_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Direction_range;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2_1ae575d525fb2ad134952c28a57be92076" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2::Edge_const_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Edge_iter;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>top<sp/>edge<sp/>is<sp/>identified<sp/>by<sp/>the<sp/>index<sp/>to<sp/>an<sp/>edge<sp/>of<sp/>a<sp/>polygon<sp/>and<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>corresponding<sp/>range<sp/>of<sp/>pullout<sp/>directions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Edge_iter,<sp/>Direction_range&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Top_edge;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">SMS<sp/>=<sp/><ref refid="namespaceCGAL_1_1Set__movable__separability__2" kindref="compound">CGAL::Set_movable_separability_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">casting<sp/>=<sp/>SMS::Single_mold_translational_casting;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>main<sp/>program:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>polygon;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;polygon.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>input_file(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>input_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>the<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input_file<sp/>&gt;&gt;<sp/>polygon;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Top_edge&gt;<sp/><ref refid="group__top__edges__grp_1ga0ec79c21ecf966930e0b5265cad6bd80" kindref="member">top_edges</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Example<sp/>for<sp/>top_edges_single_mold_translational_casting_2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__top__edges__grp_1ga0ec79c21ecf966930e0b5265cad6bd80" kindref="member">casting::top_edges</ref>(polygon,<sp/>std::back_inserter(top_edges));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(top_edges.empty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>polygon<sp/>is<sp/>not<sp/>castable!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;There<sp/>are<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>top_edges.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>top<sp/>edges:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>top_edge<sp/>:<sp/>top_edges)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\tEdge:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*top_edge.first&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\tPullout<sp/>directions<sp/>from:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>top_edge.second.first</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>to<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>top_edge.second.second</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This package provides two additional functions, namely, <computeroutput><ref refid="group__pullout__directions__grp_1ga861c10709685f4154563d651146129ec" kindref="member">CGAL::Set_movable_separability_2::Single_mold_translational_casting::pullout_directions()</ref></computeroutput> and <computeroutput><ref refid="group__is__pullout__direction__grp_1ga0e2c774abc7cc2d8d99e10e243c050e6" kindref="member">CGAL::Set_movable_separability_2::Single_mold_translational_casting::is_pullout_direction()</ref></computeroutput>. The former accepts a simple closed polygon <formula id="5">$P$</formula> and an edge <formula id="1">$e$</formula> of the polygon <formula id="5">$P$</formula>; it determines whether <formula id="1">$e$</formula> is a top edge of <formula id="5">$P$</formula>, and if so, it computes the range of pullout directions of <formula id="1">$e$</formula>. The latter is overloaded with two versions: The first version accepts a simple closed polygon <formula id="5">$P$</formula> and a direction <formula id="2">$d$</formula>; it determines whether <formula id="2">$d$</formula> is a pullout direction of some top edge of <formula id="5">$P$</formula>. The other version accepts, in addition, an edge <formula id="1">$e$</formula> of the polygon <formula id="5">$P$</formula>; it determines whether <formula id="2">$d$</formula> is a pullout direction of <formula id="1">$e$</formula>.</para><para>Overloads of each of the functions above that accept (i) an additional argument that indicates the orientation of the input polygon or (ii) an additional traits argument, or (iii) both, are also provided by the package. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
