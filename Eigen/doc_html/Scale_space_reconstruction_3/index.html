<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Scale_space_reconstruction_3/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Scale-Space Surface Reconstruction: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Scale-Space Surface Reconstruction
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Scale_space_reconstruction"></a><a class="anchor" id="chapterScaleSpaceReconstruction3"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Thijs van Lankveld</dd></dl>
<p>This CGAL package implements a surface reconstruction method which takes as input an unordered point set and computes a triangulated surface mesh interpolating the point set. We assume that the input points were sampled from the surface of an object. The method can also process point sets sampled from the interior of the object, although we cannot provide guarantees on the output. This method can handle a decent amount of noise and outliers. The point set may greatly undersample the object in occluded regions, although no surface will be reconstructed to fill these regions.</p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figIntro"></a></p><div class="image">
<img src="knot2_pts_surf.png" alt="knot2_pts_surf.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figIntro">Figure 58.1</a> Left: 5760 points on a synthetic knot data set. Right: reconstructed surface mesh.  </div>  <br />

<p>A triangulated surface mesh is generated by first computing the point set at a coarse scale, then constructing a mesh of the point set at this scale, and finally reverting the points of the mesh back to their original scale.</p>
<h1><a class="anchor" id="ScaleSpaceReconstruction3secMethod"></a>
Scale-Space</h1>
<p>The problem of surface reconstruction from a point sample is ill-defined. Because the points only provide a sample of the surface, we cannot determine with exact certainty how the surface behaves between the points. We may get more information about the surface by sampling the surface further, but even then the problem remains on a smaller scale.</p>
<p>For real-world data sets we also have to contend with noise and outliers, small errors in the point location and points that do not sample the surface respectively. These are generally caused by faults in the measurement procedure. Unless we actually know the surface sampled, we cannot determine whether a distinctive point is an outlier, is caused by noise, or samples a small feature of the surface.</p>
<p>To overcome these obstacles, we model the point set at different scales using a scale-space <a class="el" href="citelist.html#CITEREF_cgal:dmsl-ssmrp-11">[1]</a>. For our purpose, a <em>scale</em> is an abstraction level of the point set. At a lower, finer scale the point set describes smaller features of the object. Conversely at a higher, coarser scale the point set only describes larger features. A <em>scale-space</em> describes the point set at a dynamic scale. It is a four-dimensional space with the scale as fourth dimension. Increasing the scale is similar to smoothing the underlying surface described by the point set. <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figScales">Figure 58.2</a> shows an example point set at different scales. The overall effect of modeling this scale-space, is that the surface reconstruction problem is more well-defined at higher scales.</p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figScales"></a></p><div class="image">
<img src="scale_space_pts.png" alt="scale_space_pts.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figScales">Figure 58.2</a> The black point set contains a smooth region, a region with large features, and a region with either small features or noisy points. The blue points show the point cloud at a higher scale.  </div>  <br />

<p>Small changes in scale result in small changes in the points set that depends on the local shape. As the scale increases, the geometry approaches a number of points based on the connected components. Given a set of points at a fixed scale, the point set at a higher scale can be determined unambiguously, but this is not the case for the point set at a lower scale, as demonstrated by <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figLine">Figure 58.3</a></p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figLine"></a></p><div class="image">
<img src="line.png" alt="line.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figLine">Figure 58.3</a> The black points and crosses show two different point sets. The blue boxes show both point sets at a higher scale. Note that given just the blue boxes, we cannot determine its point set at a lower scale.  </div>  <br />

<p>The scale-space surface reconstruction method works in two phases. Firstly, a scale-space is constructed from the point set and an intersection of this space at a higher scale \( s \) is computed. Then, a triangulated surface mesh of the point set at scale \( s \) is computed. Neighboring triangles in the mesh have consistent orientation, as expressed using the <em>right-hand rule</em> on the ordered vertices of the triangle.</p>
<p>Generally, a reconstruction interpolating the original point set is desired. This can be achieved by reverting the points of the mesh to their original scale, i.e. their original locations. <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figSurfs">Figure 58.4</a> shows example reconstructions from the point set at its original scale and at a higher scale with reverted mesh.</p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figSurfs"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="scale_space_surf_1.png" alt="scale_space_surf_1.png" />
</div>
   </td><td><div class="image">
<img src="scale_space_surf_2.png" alt="scale_space_surf_2.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figSurfs">Figure 58.4</a> The surfaces constructed from the point set at the original scale (left) and at a higher scale (right). The surface points in the right figure are reverted back to the original scale. The dashed paths shows the inward-facing shell where it does not overlap the outward-facing shell. Note how the scale-space reconstruction assumes the points on the right side of the object sample small features.  </div>  <br />

<p>Both the smoothing operator and the mesh reconstruction assume that points near each other belong to the same part of the object. This is usually expressed in the notion of balls with a fixed size, the neighborhood radius. If such a ball contains multiple points, these points are <em>near</em> each other and will influence each other while increasing the scale. If such a ball is empty, it lies outside the object. Note that <em>outside</em> is based on regions empty of points, not on whether a volume is enclosed by the surface.</p>
<p>The neighborhood size can be estimated through statistical analysis. We use a kD-tree to estimate the mean distance to the n-th nearest neighbor and we use this distance as an approximator for the resolution.</p>
<p>The point set at the initial scale is equivalent to the input point set. In theory the scale can be varied continuously, but in practice the scale is increased in discrete iterations for efficiency reasons. The scale is increased one iteration by transforming each point using a smoothing operator. <span style="font-variant: small-caps;">CGAL</span> provides two smoothing operators for scale space reconstruction:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Weighted__PCA__smoother.html" title="Smoother for scale space reconstruction based on a principal component analysis weighted by the local...">CGAL::Scale_space_reconstruction_3::Weighted_PCA_smoother</a></code> (default) uses the <em>density</em>-weighted principal component analysis (PCA) of the local neighborhood. If the point set was sampled from a surface for which any unwanted deformation and sampling noise is smaller than the neighborhood size, the scale is coarse enough for mesh reconstruction after a few iterations of increasing the scale.</li>
<li><code><a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html" title="Smoother for scale space reconstruction based on CGAL::jet_smooth_point_set(). ">CGAL::Scale_space_reconstruction_3::Jet_smoother</a></code> uses the function <code>CGAL::jet_smooth_point_set()</code> that projects the point to a local smooth (jet) surface. This smoothing is less agressive and should be used if the point set is not very noisy and if a higher precision is sough.</li>
</ul>
<p>Users can define their own smoothing operators by following the concept <code><a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Smoother.html" title="Concept describing a smoothing algorithm used to construct the scales of the scale space reconstructi...">CGAL::Scale_space_reconstruction_3::Smoother</a></code>.</p>
<p>Meshing is achieved by interpolating the smoothed point cloud and propagating back the connectivity to the original point cloud. <span style="font-variant: small-caps;">CGAL</span> provides two meshing operators for scale space reconstruction:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Alpha__shape__mesher.html" title="Surface mesher for scale space reconstruction based on CGAL::Alpha_shape_3. ">CGAL::Scale_space_reconstruction_3::Alpha_shape_mesher</a></code> (default) uses a filtered <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Alpha_shapes_3.tag:../Alpha_shapes_3/" href="../Alpha_shapes_3/classCGAL_1_1Alpha__shape__3.html">CGAL::Alpha_shape_3</a></code> algorithm to generate one or several "shells". This method is designed for closed shapes (without boundary). Point sets sampling an opened shape result in an overlapping surface. It requires a fixed neighborhood size parameter, related to the resolution of the data. This parameter indicates a region for which we can assume it contains at least one point if it is centered on the surface.</li>
<li><code><a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html" title="Surface mesher for scale space reconstruction based on CGAL::Advancing_front_surface_reconstruction. ">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher</a></code> uses the algorithm <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/classCGAL_1_1Advancing__front__surface__reconstruction.html">CGAL::Advancing_front_surface_reconstruction</a></code> to generate an oriented 2-manifold surface. This method handles shapes with boundaries and gives the user control over the largest facets used.</li>
</ul>
<p>The method provides access to intermediate results and users can adjust these to better suit their needs. The (intermediate) results are the estimate of the resolution, the scale, and the final collection of surface triangles.</p>
<p>Note that <a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html">Jet_smoother</a> and <a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">Advancing_front_mesher</a> are methods that rely upon other <span style="font-variant: small-caps;">CGAL</span> packages and that do not correspond to the original scale space algorithm. They can be used as alternative operators for the cases of point clouds with low noise that sample surfaces with boundaries. For more information on their parameters and effect, please refer to their respective manual pages (<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/index.html#Point_set_processing_3Smoothing">Smoothing</a> and <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#Chapter_Advancing_Front_Surface_Reconstruction">Chapter_Advancing_Front_Surface_Reconstruction</a>). The rest of this documentation focuses on the default behavior using <a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Weighted__PCA__smoother.html">Weighted_PCA_smoother</a> and <a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Alpha__shape__mesher.html">Alpha_shape_mesher</a>.</p>
<h2><a class="anchor" id="ScaleSpaceReconstruction3secParam"></a>
Parameter Settings</h2>
<p>The scale-space surface reconstruction method has two main global parameters: the radius of the neighborhood ball and the number iterations of increasing the scale. If no appropriate neighborhood radius is known, this can be estimated using another two parameters: the mean number of neighbors and the number of samples. We have empirically determined values for each of these parameters that work well on a broad spectrum of data sets. However, we advise to carefully fine-tune these parameters for each type of data set.</p>
<p>The scale-space reconstruction operates locally. Points within a local neighborhood influence each other when increasing the scale. Similarly, points near each other in space are more likely to be near each other on the reconstructed surface. Therefore, it is important to have a good indication of which points are near each other. This proximity is expressed in the neighborhood ball radius parameter.</p>
<p>The neighborhood ball radius is related to the point density and the object thickness. In the ideal case, the radius is chosen such that any ball \( B \) with this radius centered on any point of surface of the object will contain several points that should be connected by a local patch in the surface to reconstruct. At the same time, \( B \) should not contain any points that should not be part of this local patch, such as points on the other side of the object.</p>
<p>The neighborhood radius can be estimated automatically from the point set. In this case, the radius is estimated such that on average it contains a given number of points. The number of points should be chosen such that the conditions on the neighborhood radius described above are preserved. Generally, an average of 30 neighbors gives good results. This number may be increased if parts of the object have a very low point density, it may be decreased if thin features of the object should be reconstructed better.</p>
<p>The radius estimation is based on a number of sample points. This number of samples is related to how regularly the point set covers the object. A large sample size may be required if the object is covered very irregularly. However, a larger number of samples may require more computation time. We generally use 200 samples to estimate the neighborhood radius.</p>
<p>The scale-space method tries to make the surface reconstruction problem less ill-posed by increasing the scale to an appropriately coarse scale. At this coarse scale the point set samples a smoothed surface, which is easier to reconstruct. The number of scale increase iterations determines how much this surface is smoothed.</p>
<p>The number of iterations is related to the noise in the point set, the acuteness of surface features, and the thickness of the object. Point sets with a lot of noise and objects with sharp or small features will require more iterations. At the same time, processing too many iterations can degenerate a volume into a plane. These degeneracies may cause the reconstructed surface to connect points on opposite sides of the object. Generally, 4 iterations of increasing the scale are appropriate.</p>
<h2><a class="anchor" id="ScaleSpaceReconstruction3secOutput"></a>
Output Surface</h2>
<p>The surface mesh constructed at scale \( s \) is non-self-intersecting. The interiors of any two triangles cannot pairwise intersect in a line segment. However, the surface does not need to be 2-manifold. An edge may be incident to more than two triangles and triangles may overlap exactly if large regions on both sides of the triangle are empty of points. Note that we count overlapping triangles with opposite orientations as separate triangles. In many cases where the points sample the surface of an object, the computed surface will contain both an <em>outward-facing</em> and a similar <em>inward-facing</em> surface, with a thin volume between them.</p>
<p>The surface mesh will not have edges incident to only one triangle or holes, loops of such edges, and the triangles are all oriented away from the point set. If the point set has <em>holes</em>, it is likely that the surface mesh will contain overlapping triangles with opposite orientation touching this hole.</p>
<p>An additional treatment can be applied to force the output surface to be 2-manifold: small flat volumes are found before reconstructing and the surface is forced to only use one side of the volume while keeping consistency with the adjacent singular facets. Only one side of each singular facet is used. In addition, non-manifold edges and vertices are removed as a post-processing. The facets that have been discarded to make the surface 2-manifold are stored and accessible.</p>
<p>If the object is not densely sampled or has disconnected components, the reconstructed surface may have several disconnected components. The surface is either an unordered collection of triangles, or the same collection sorted per <em>shell</em>. A shell is a collection of connected triangles that are locally oriented towards the same side of the surface.</p>
<p>When reverted to the original scale, we cannot guarantee the surface is a valid embedding, because the triangles of this surface may pairwise intersect in their interior. It may also have boundary edges, although these will always be incident to two surface triangles oriented in opposite directions. However, when using appropriate parameter settings for the number of iterations and neighborhood size the surface will generally not self-intersect. The appropriate parameter settings depend on the geometry of the point set and generally need to be fine-tuned per data set, as described later.</p>
<h1><a class="anchor" id="ScaleSpaceReconstruction3secDesign"></a>
Software Design</h1>
<p>The main classes <code><a class="el" href="classCGAL_1_1Scale__space__surface__reconstruction__3.html" title="computes a triangulated surface mesh interpolating a point set. ">Scale_space_surface_reconstruction_3</a></code>, <a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Weighted__PCA__smoother.html">Weighted_PCA_smoother</a> and <a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Alpha__shape__mesher.html">Alpha_shape_mesher</a> contain all the functionality to estimate the neighborhood size, compute the scale-space and increase the scale, and reconstruct the surface from the point set at the current scale.</p>
<p>The neighborhood size is estimated using <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Spatial_searching.tag:../Spatial_searching/" href="../Spatial_searching/classCGAL_1_1Orthogonal__k__neighbor__search.html">Orthogonal_k_neighbor_search</a></code>. The point set is generally stored in a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Spatial_searching.tag:../Spatial_searching/" href="../Spatial_searching/classCGAL_1_1Orthogonal__k__neighbor__search.html#a25bde1160d0c7784f04ccd2a9e9019f9">Orthogonal_k_neighbor_search::Tree</a></code>. When the neighborhood size is estimated, this tree is searched for nearest neighbors.</p>
<p>The scale-space is constructed at the original scale of the points. An iteration of increasing the scale is computed using a weighted PCA procedure. As described by Digne <em>et al.</em> <a class="el" href="citelist.html#CITEREF_cgal:dmsl-ssmrp-11">[1]</a>, unlike similar methods this procedure does not lead to an <em>undesirable clustering effect</em>. By default the efficient <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/installation.html#thirdpartyEigen">Eigen</a> library is used for this procedure if available. Otherwise, the internal fallback <code>Diagonalize_traits</code> is used. It is also possible to provide your own model for the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classDiagonalizeTraits.html">DiagonalizeTraits</a></code> concept. The weighted PCA procedure is performed locally per point, so it can be performed with parallel computing (linking with Intel TBB and passing the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a></code> to the reconstruction class is required).</p>
<p>The mesh reconstruction is performed by filtering a <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Alpha_shapes_3.tag:../Alpha_shapes_3/" href="../Alpha_shapes_3/index.html#Chapter_3D_Alpha_Shapes">3D alpha shape</a> of the point set at a fixed scale. This filtering constructs a triangle for each regular facet; each singular facet results in two triangles facing opposite directions.</p>
<p>The resulting surface is stored as a collection of triples. Each triple contains three indices to the point set. The scale iterations do not change the order of the points. This means these indices can be applied on the point set at its original scale to get an interpolating surface, called <em>reverting</em> the scale of the surface. The indices may also be applied to the point set at the current scale to get a smoothed surface. This smoothed surface will generally have shrunk somewhat compared to the reverted surface.</p>
<p>To reduce memory requirements, the point set is not stored at its original scale. Instead, the stored point set at the current scale is a clone of the input. This means that the original input can be used to revert the surface.</p>
<h1><a class="anchor" id="Triangulation3secComplexity"></a>
Case Sets and Performance</h1>
<p>There is a wide variety of possible point sets, whether synthetic or measured. The scale-space surface reconstruction method attempts to make the reconstruction problem less ill-posed. However, we cannot guarantee good results for arbitrary point set. Some point sets require careful parameter setting, while for others this method is ill-suited altogether. Here, we show different cases including the ideal sampling and different problem cases.</p>
<h2><a class="anchor" id="Triangulation3ssecIdeal"></a>
Ideal Conditions</h2>
<p>The scale-space surface reconstruction has lenient ideal conditions. The surface should be reasonably regularly sampled and it should not contain overly concave corners. These notions affect the neighborhood parameter in opposing ways: more regular sampling may admit a smaller neighborhood parameter, which will admit smaller concavities. The point set may contain noise that is significantly smaller than the neighborhood size. Even so, when using the method to construct a mesh interpolating the original point set, any noise will deform the mesh. <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figIdeal">Figure 58.5</a> shows a reconstruction under ideal conditions.</p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figIdeal"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="retinal_pts.png" alt="retinal_pts.png" />
</div>
   </td><td><div class="image">
<img src="retinal_surf.png" alt="retinal_surf.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figIdeal">Figure 58.5</a> <b>Left:</b> In the ideal case, points are regularly distributed and concavities are limited. <b>Right:</b> reconstructed surface mesh.  </div>  <br />

<h2><a class="anchor" id="Triangulation3ssecBound"></a>
Boundaries</h2>
<p>Surfaces with boundaries are handled naturally. However, it is important to note that in these cases, the surface does not explicitly identify the boundary and <em>loops</em> around it. In many cases, this will lead to boundary edges being shared by neighboring triangles of the surface that are identical except for their orientation. The boundaries may be made explicit by identifying orientation discrepancies between neighboring triangles, but this functionality is not provided by this package. <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figBound">Figure 58.6</a> shows a reconstructed surface with a boundary.</p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figBound"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="mushroom_pts.png" alt="mushroom_pts.png" />
</div>
   </td><td><div class="image">
<img src="mushroom_surf.png" alt="mushroom_surf.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figBound">Figure 58.6</a> <b>Left:</b> A point sample of a surface with boundary. <b>Right:</b> reconstructed surface mesh.  </div>  <br />

<p>Note that the mesher <a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">Advancing_front_mesher</a> is a good alternative for producing well oriented surfaces with boundaries.</p>
<h2><a class="anchor" id="Triangulation3ssecRegularity"></a>
Sampling Regularity</h2>
<p>As described above, ideally the point set regularly samples the surface. For example, for each point its six nearest points lie at roughly equal distance forming a rough hexagon around the point. This will generally not occur when working with realistic data. The scale-space method can reconstruct very unevenly sampled surfaces, as <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figUneven">Figure 58.7</a> shows. However, as noted earlier the sampling regularity and allowed concavity form a trade-off. <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figUnevenFail">Figure 58.8</a> shows a case where we cannot simultaneously model the concave regions and sparse regions correctly.</p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figUneven"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="femur_pts.png" alt="femur_pts.png" />
</div>
   </td><td><div class="image">
<img src="femur_surf.png" alt="femur_surf.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figUneven">Figure 58.7</a> <b>Left:</b> A very irregularly sampled point set. <b>Right:</b> reconstructed surface mesh.  </div>  <br />

<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figUnevenFail"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="lion-head_pts.png" alt="lion-head_pts.png" />
</div>
   </td><td><div class="image">
<img src="lion-head_surf.png" alt="lion-head_surf.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figUnevenFail">Figure 58.8</a> <b>Left:</b> A very irregularly sampled point set with tight concavities. <b>Right:</b> reconstructed surface mesh. Note we cannot correctly model the mouth and eyes as well as the neck.  </div>  <br />

<h2><a class="anchor" id="Triangulation3ssecSharp"></a>
Sharp Features</h2>
<p>The scale-space surface reconstruction method was not designed to deal specifically with surfaces with sharp features. However, it reconstructs these features adequately when using appropriate parameter settings, as demonstrated in <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figSharp">Figure 58.9</a>. The main prerequisite for correctly reconstructing the sharp features is that they contain sufficient sample points on the features and the features are not too thin compared to the neighborhood parameter.</p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figSharp"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="fandisk_pts.png" alt="fandisk_pts.png" />
</div>
   </td><td><div class="image">
<img src="fandisk_surf.png" alt="fandisk_surf.png" />
</div>
   </td><td><div class="image">
<img src="fandisk_2_surf.png" alt="fandisk_2_surf.png" />
</div>
   </td><td><div class="image">
<img src="fandisk_2_surf_detail.png" alt="fandisk_2_surf_detail.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figSharp">Figure 58.9</a> A point set on a surface with sharp creases and the reconstructed surface mesh seen from different sides. Note that the sharp features are mostly reconstructed correctly. However, in the thin regions circled in red the feature is not reconstructed correctly. The trade-off between regularity and concavity also means a hole appears in the third figure, bottom right.  </div>  <br />

<h2><a class="anchor" id="Triangulation3ssecTopo"></a>
Topology</h2>
<p>The scale-space surface reconstruction method does not take into account the topology of the surface. This means the reconstructed surface may have a different topology than the surface sampled to obtain the point set. <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figTopo">Figure 58.10</a> shows an example point set that was sampled from a surface with the topology of a sphere; the reconstructed surface has the topology of a torus.</p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figTopo"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="man_pts.png" alt="man_pts.png" />
</div>
   </td><td><div class="image">
<img src="man_surf.png" alt="man_surf.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figTopo">Figure 58.10</a> <b>Left:</b> An irregularly sampling of a surface with the topology of a sphere. <b>Right:</b> reconstructed surface mesh with the topology of a torus. Note that the irregular sampling makes it impossible to reconstruct a surface with the topology of a sphere, because the method uses a global scale parameter.  </div>  <br />

<h2><a class="anchor" id="Triangulation3ssecAttrib"></a>
Point Attributes</h2>
<p>Many point sets contain point attributes such as normals or colors. Because the scale-space surface reconstruction constructs the connectivity between the original points, any point attributes that make sense for a surface can be propagated to the reconstruction. <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figColor">Figure 58.11</a> shows the surface reconstructed for a set of points with colors.</p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figColor"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="trophime.png" alt="trophime.png" />
</div>
   </td><td><div class="image">
<img src="trophime_detail.png" alt="trophime_detail.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figColor">Figure 58.11</a> <b>Left:</b> A reconstructed surface with vertex coloring using the colors of the point set. <b>Right:</b> detail of the surface shown as wire-frame. Images or image-based modeling: MAP (Mod√®les et simulations pour l'Architecture et le Patrimoine) - UMR CNRS/MCC 3495.  </div>  <br />

<h2><a class="anchor" id="Triangulation3ssecPerform"></a>
Performance</h2>
<p>We have evaluated the scale-space surface reconstruction method on several data sets of various sizes. <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figBenchmarks">Figure 58.13</a> shows the parameter settings used when processing the scale-space reconstruction method.</p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figSettings"></a></p><center> <table class="doxtable">
<tr>
<th align="right">Data set </th><th align="right">Neighbors </th><th align="right">Samples </th><th align="right">Iterations  </th></tr>
<tr>
<td align="right">Mushroom (s) </td><td align="right">10 </td><td align="right">200 </td><td align="right">2 </td></tr>
<tr>
<td align="right">Elephant (s) </td><td align="right">15 </td><td align="right">200 </td><td align="right">1 </td></tr>
<tr>
<td align="right">Knot 1 (s) </td><td align="right">8 </td><td align="right">100 </td><td align="right">8 </td></tr>
<tr>
<td align="right">Retinal (s) </td><td align="right">30 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Femur </td><td align="right">25 </td><td align="right">300 </td><td align="right">6 </td></tr>
<tr>
<td align="right">Kitten (s) </td><td align="right">10 </td><td align="right">100 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Knot 2 (s) </td><td align="right">8 </td><td align="right">300 </td><td align="right">8 </td></tr>
<tr>
<td align="right">Bull (s) </td><td align="right">100 </td><td align="right">600 </td><td align="right">1 </td></tr>
<tr>
<td align="right">Fandisk (s) </td><td align="right">6 </td><td align="right">300 </td><td align="right">8 </td></tr>
<tr>
<td align="right">Lion-head (s) </td><td align="right">12 </td><td align="right">400 </td><td align="right">1 </td></tr>
<tr>
<td align="right">Turbine (s) </td><td align="right">60 </td><td align="right">400 </td><td align="right">1 </td></tr>
<tr>
<td align="right">Graill 1 </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Graill 11 </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Man (s) </td><td align="right">100 </td><td align="right">600 </td><td align="right">1 </td></tr>
<tr>
<td align="right">Face </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Carc 20 LR </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Carc 21 LR </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Bowl 1 </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Bowl 5 </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Fount 1 </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Fount 11 </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Trophime </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Carc 20 </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
<tr>
<td align="right">Carc 21 </td><td align="right">10 </td><td align="right">200 </td><td align="right">4 </td></tr>
</table>
</center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figSettings">Figure 58.12</a> Settings used when running the scale-space method on several data sets. Data sets indicated by "(s)" are synthetic. <em>Neighbors</em> indicates the number of neighbors the estimated neighborhood ball should contain on average, <em>Samples</em> indicates the number of sample points used to estimate the neighborhood radius, <em>Iterations</em> indicates the number of scale increase iterations.  </div>  <br />

<p><a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figBenchmarks">Figure 58.13</a> shows the number of triangles of the surfaces constructed and the running time for doing so. Half of the data sets are synthetic, the others are constructed by image-based dense reconstruction. The data sets are ordered by size, the synthetic sets mainly making up the smaller ones.</p>
<p>The times were measured on a 64-bit Windows 7 system with 8 2.5GHz Intel processors and 16GB RAM. The scale-space constructions employ parallel computing using Intel TBB. The smaller data sets use roughly 0.1GB of memory, but the largest data sets have a peak usage of 10.5GB during the meshing step. For this benchmark we used the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">Exact_predicates_inexact_constructions_kernel</a></code> kernel, <code>FS</code> enabled, and <code>Sh</code> disabled.</p>
<p><a class="anchor" id="fig__chapterScaleSpaceReconstruction3figBenchmarks"></a></p><center> <table class="doxtable">
<tr>
<th align="right">Data set </th><th align="right">Number of points </th><th align="right">Surface triangles </th><th align="right">Neighborhood (ms) </th><th align="right">Scale-space (ms) </th><th align="right">Meshing (ms) </th><th align="right">Total (ms)  </th></tr>
<tr>
<td align="right">Mushroom (s) </td><td align="right">2,337 </td><td align="right">7,966 </td><td align="right">7 </td><td align="right">64 </td><td align="right">88 </td><td align="right">159 </td></tr>
<tr>
<td align="right">Elephant (s) </td><td align="right">2,775 </td><td align="right">6,746 </td><td align="right">4 </td><td align="right">33 </td><td align="right">91 </td><td align="right">128 </td></tr>
<tr>
<td align="right">Knot 1 (s) </td><td align="right">3,200 </td><td align="right">12,800 </td><td align="right">7 </td><td align="right">148 </td><td align="right">134 </td><td align="right">289 </td></tr>
<tr>
<td align="right">Retinal (s) </td><td align="right">3,643 </td><td align="right">14,154 </td><td align="right">8 </td><td align="right">224 </td><td align="right">122 </td><td align="right">354 </td></tr>
<tr>
<td align="right">Femur </td><td align="right">3,897 </td><td align="right">12,612 </td><td align="right">6 </td><td align="right">592 </td><td align="right">120 </td><td align="right">718 </td></tr>
<tr>
<td align="right">Kitten (s) </td><td align="right">5,210 </td><td align="right">20,428 </td><td align="right">7 </td><td align="right">198 </td><td align="right">172 </td><td align="right">377 </td></tr>
<tr>
<td align="right">Knot 2 (s) </td><td align="right">5,760 </td><td align="right">22,904 </td><td align="right">5 </td><td align="right">278 </td><td align="right">206 </td><td align="right">489 </td></tr>
<tr>
<td align="right">Bull (s) </td><td align="right">6,200 </td><td align="right">11,892 </td><td align="right">20 </td><td align="right">238 </td><td align="right">149 </td><td align="right">407 </td></tr>
<tr>
<td align="right">Fandisk (s) </td><td align="right">6,475 </td><td align="right">25,282 </td><td align="right">5 </td><td align="right">330 </td><td align="right">212 </td><td align="right">547 </td></tr>
<tr>
<td align="right">Lion-head (s) </td><td align="right">8,356 </td><td align="right">27,128 </td><td align="right">7 </td><td align="right">125 </td><td align="right">249 </td><td align="right">382 </td></tr>
<tr>
<td align="right">Turbine (s) </td><td align="right">9,210 </td><td align="right">14,084 </td><td align="right">12 </td><td align="right">293 </td><td align="right">201 </td><td align="right">507 </td></tr>
<tr>
<td align="right">Graill 1 </td><td align="right">12,681 </td><td align="right">45,326 </td><td align="right">14 </td><td align="right">1,166 </td><td align="right">381 </td><td align="right">1,561 </td></tr>
<tr>
<td align="right">Graill 11 </td><td align="right">14,617 </td><td align="right">54,550 </td><td align="right">18 </td><td align="right">1,072 </td><td align="right">454 </td><td align="right">1,544 </td></tr>
<tr>
<td align="right">Man (s) </td><td align="right">17,495 </td><td align="right">38,496 </td><td align="right">25 </td><td align="right">845 </td><td align="right">421 </td><td align="right">1,291 </td></tr>
<tr>
<td align="right">Face </td><td align="right">296,275 </td><td align="right">906,648 </td><td align="right">128 </td><td align="right">17,983 </td><td align="right">7,843 </td><td align="right">25,957 </td></tr>
<tr>
<td align="right">Carc 20 LR </td><td align="right">1,311,850 </td><td align="right">1,311,850 </td><td align="right">154 </td><td align="right">20,652 </td><td align="right">10,822 </td><td align="right">31,632 </td></tr>
<tr>
<td align="right">Carc 21 LR </td><td align="right">1,443,510 </td><td align="right">1,443,510 </td><td align="right">157 </td><td align="right">19,778 </td><td align="right">12,290 </td><td align="right">32,228 </td></tr>
<tr>
<td align="right">Bowl 1 </td><td align="right">2,741,328 </td><td align="right">2,841,328 </td><td align="right">351 </td><td align="right">34,688 </td><td align="right">22,559 </td><td align="right">57,608 </td></tr>
<tr>
<td align="right">Bowl 5 </td><td align="right">3,682,188 </td><td align="right">3,682,188 </td><td align="right">471 </td><td align="right">50,762 </td><td align="right">29,899 </td><td align="right">81,144 </td></tr>
<tr>
<td align="right">Fount 1 </td><td align="right">1,504,761 </td><td align="right">5,946,502 </td><td align="right">764 </td><td align="right">112,028 </td><td align="right">51,451 </td><td align="right">164,262 </td></tr>
<tr>
<td align="right">Fount 11 </td><td align="right">2,589,083 </td><td align="right">10,203,108 </td><td align="right">1,350 </td><td align="right">216,623 </td><td align="right">85,231 </td><td align="right">303,248 </td></tr>
<tr>
<td align="right">Trophime </td><td align="right">4,572,657 </td><td align="right">16,982,194 </td><td align="right">2,413 </td><td align="right">630,502 </td><td align="right">134,427 </td><td align="right">767,389 </td></tr>
<tr>
<td align="right">Carc 20 </td><td align="right">5,370,681 </td><td align="right">21,190,868 </td><td align="right">2,531 </td><td align="right">304,015 </td><td align="right">179,223 </td><td align="right">485,813 </td></tr>
<tr>
<td align="right">Carc 21 </td><td align="right">5,800,135 </td><td align="right">23,042,576 </td><td align="right">2,916 </td><td align="right">365,731 </td><td align="right">212,840 </td><td align="right">581,535 </td></tr>
</table>
</center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figBenchmarks">Figure 58.13</a> Number of triangles of the surfaces constructed and running times in milliseconds for the scale-space method. Data sets indicated by "(s)" are synthetic.  </div>  <br />

<h1><a class="anchor" id="ScaleSpaceReconstruction3secExamples"></a>
Examples</h1>
<p>This first example shows how to read a point set from a file, reconstruct the surface, and for each shell of the reconstruction, access the triangle vertex indices.</p>
<p><br />
<b>File</b> <a class="el" href="Scale_space_reconstruction_3_2scale_space_8cpp-example.html">Scale_space_reconstruction_3/scale_space.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_off_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>     <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</a>    Reconstruction;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Reconstruction::Facet_const_iterator                   Facet_iterator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (argc!=2){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error, no input file provided\n"</span>;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  <span class="comment">// Read the data.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  std::ifstream in(argv[1]);</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading "</span> &lt;&lt; std::flush;</div><div class="line">  <span class="keywordflow">if</span>( !in || !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessingIO.html#ga1d0f58874ed1ddb2b00721f15ba362a9">CGAL::read_off_points</a>( in, std::back_inserter( points ) ) ) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done: "</span> &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reconstruction "</span>;</div><div class="line">  CGAL::Timer t;</div><div class="line">  t.start();</div><div class="line">  <span class="comment">// Construct the mesh in a scale space.</span></div><div class="line">  Reconstruction reconstruct (points.begin(), points.end());</div><div class="line">  reconstruct.increase_scale(4);</div><div class="line">  reconstruct.reconstruct_surface();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" sec."</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  std::ofstream out (<span class="stringliteral">"out.off"</span>);</div><div class="line">  out &lt;&lt; reconstruct;</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Writing result in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" sec."</span> &lt;&lt; std::endl;</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>The different phases of the reconstruction can also be performed individually. This may be helpful in cases where the correct parameter settings are not known in advance. In <a class="el" href="index.html#fig__chapterScaleSpaceReconstruction3figSurfs">Figure 58.4</a>, the right figure shows the surface after incrementing the scale. After examining the reconstructed surface, we may decide that performing more iterations may better model the top-left part.</p>
<p>The next example performs two reconstructions with different smoothing of the point set by further advancing the scale space. It illustrates how the code can be used in an interactive way.</p>
<p><br />
<b>File</b> <a class="el" href="Scale_space_reconstruction_3_2scale_space_incremental_8cpp-example.html">Scale_space_reconstruction_3/scale_space_incremental.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_off_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>     <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt; Kernel &gt;</a>                Reconstruction;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Weighted__PCA__smoother.html">CGAL::Scale_space_reconstruction_3::Weighted_PCA_smoother&lt; Kernel &gt;</a> Smoother;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Alpha__shape__mesher.html">CGAL::Scale_space_reconstruction_3::Alpha_shape_mesher&lt; Kernel &gt;</a>    Mesher;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Reconstruction::Point                                   Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Reconstruction::Facet_const_iterator                   Facet_iterator;</div><div class="line"></div><div class="line"><span class="comment">// function for writing the reconstruction output in the off format</span></div><div class="line"><span class="keywordtype">void</span> dump_reconstruction(<span class="keyword">const</span> Reconstruction&amp; reconstruct, std::string name)</div><div class="line">{</div><div class="line">  std::ofstream output(name.c_str());</div><div class="line">  output &lt;&lt; <span class="stringliteral">"OFF "</span> &lt;&lt; reconstruct.number_of_points() &lt;&lt; <span class="stringliteral">" "</span></div><div class="line">         &lt;&lt; reconstruct.number_of_facets() &lt;&lt; <span class="stringliteral">" 0\n"</span>;</div><div class="line"></div><div class="line">  std::copy(reconstruct.points_begin(),</div><div class="line">            reconstruct.points_end(),</div><div class="line">            std::ostream_iterator&lt;Point&gt;(output,<span class="stringliteral">"\n"</span>));</div><div class="line">  <span class="keywordflow">for</span>( Facet_iterator it = reconstruct.facets_begin(); it != reconstruct.facets_end(); ++it )</div><div class="line">      output &lt;&lt; <span class="stringliteral">"3 "</span> &lt;&lt; *it &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line">    <span class="comment">// Read the data.</span></div><div class="line">    std::vector&lt;Point&gt; points;</div><div class="line">    <span class="keywordflow">if</span> (argc!=2){</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Error, no input file provided\n"</span>;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    std::ifstream in(argv[1]);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Reading "</span> &lt;&lt; std::flush;</div><div class="line">    <span class="keywordflow">if</span>( !in || !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessingIO.html#ga1d0f58874ed1ddb2b00721f15ba362a9">CGAL::read_off_points</a>( in, std::back_inserter( points ) ) ) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file"</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"done: "</span> &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Construct the reconstruction</span></div><div class="line">    Reconstruction reconstruct;</div><div class="line">    </div><div class="line">    <span class="comment">// Add the points.</span></div><div class="line">    reconstruct.insert( points.begin(), points.end() );</div><div class="line"></div><div class="line">    <span class="comment">// Two passes</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 2; ++ i)</div><div class="line">    {</div><div class="line">      <span class="comment">// Construct the smoother with parameters for</span></div><div class="line">      <span class="comment">// the neighborhood squared radius estimation.</span></div><div class="line">      Smoother smoother( 10, 100 );</div><div class="line"></div><div class="line">      <span class="comment">// Advance the scale-space several steps.</span></div><div class="line">      <span class="comment">// This automatically estimates the scale-space.</span></div><div class="line">      reconstruct.increase_scale( 2, smoother );</div><div class="line"></div><div class="line">      <span class="comment">// Reconstruct the surface from the current scale-space.</span></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"Neighborhood squared radius is "</span></div><div class="line">                &lt;&lt; smoother.squared_radius() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      Mesher mesher (smoother.squared_radius());</div><div class="line">      reconstruct.reconstruct_surface(mesher);</div><div class="line">      <span class="keywordflow">if</span> (i == 0)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"First reconstruction done."</span> &lt;&lt; std::endl;</div><div class="line">        <span class="comment">// Write the reconstruction.</span></div><div class="line">        dump_reconstruction(reconstruct, <span class="stringliteral">"reconstruction1.off"</span>);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Second reconstruction done."</span> &lt;&lt; std::endl;</div><div class="line">        <span class="comment">// Write the reconstruction.</span></div><div class="line">        dump_reconstruction(reconstruct, <span class="stringliteral">"reconstruction2.off"</span>);</div><div class="line">      }      </div><div class="line">    }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Reconstructions are ready to be examinated in your favorite viewer"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>This example shows how to force the output surface to be 2-manifold. In this case, some facets may be discarded in order to remove non-manifold simplices. They are stored in a <em>garbage</em> container in an unordered fashion. They are accessed by iterating on this container.</p>
<p><br />
<b>File</b> <a class="el" href="Scale_space_reconstruction_3_2scale_space_manifold_8cpp-example.html">Scale_space_reconstruction_3/scale_space_manifold.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_off_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>     Kernel;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt; Kernel &gt;</a>                Reconstruction;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Weighted__PCA__smoother.html">CGAL::Scale_space_reconstruction_3::Weighted_PCA_smoother&lt; Kernel &gt;</a> Smoother;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Alpha__shape__mesher.html">CGAL::Scale_space_reconstruction_3::Alpha_shape_mesher&lt; Kernel &gt;</a>    Mesher;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Reconstruction::Point                                   Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Reconstruction::Facet_const_iterator                    Facet_iterator;</div><div class="line"><span class="keyword">typedef</span> Mesher::Facet_const_iterator                            Mesher_iterator;</div><div class="line"><span class="keyword">typedef</span> CGAL::Timer Timer;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line">  <span class="keywordflow">if</span> (argc!=2){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error, no input file provided\n"</span>;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  <span class="comment">// Read the data.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  std::ifstream in(argv[1]);</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading "</span> &lt;&lt; std::flush;</div><div class="line">  <span class="keywordflow">if</span>( !in || !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessingIO.html#ga1d0f58874ed1ddb2b00721f15ba362a9">CGAL::read_off_points</a>( in, std::back_inserter( points ) ) ) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done: "</span> &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Timer t;</div><div class="line">  t.start();</div><div class="line">  <span class="comment">// Construct the mesh in a scale space.</span></div><div class="line">  Reconstruction reconstruct( points.begin(), points.end() );</div><div class="line">  Smoother smoother( 10, 200 );</div><div class="line">  reconstruct.increase_scale (4, smoother);</div><div class="line"></div><div class="line">  Mesher mesher( smoother.squared_radius(),</div><div class="line">                 <span class="keyword">false</span>, <span class="comment">// Do not separate shells</span></div><div class="line">                 <span class="keyword">true</span> <span class="comment">// Force manifold output</span></div><div class="line">               );                 </div><div class="line">  reconstruct.reconstruct_surface( mesher );</div><div class="line">  </div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reconstruction done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" sec."</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  std::ofstream out (<span class="stringliteral">"out.off"</span>);</div><div class="line">  <span class="comment">// Write the reconstruction.</span></div><div class="line">  <span class="keywordflow">for</span>( Facet_iterator it = reconstruct.facets_begin( ); it != reconstruct.facets_end(  ); ++it )</div><div class="line">    out &lt;&lt; <span class="stringliteral">"3 "</span>&lt;&lt; *it &lt;&lt; <span class="charliteral">'\n'</span>; <span class="comment">// We write a '3' in front so that it can be assembled into an OFF file</span></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Writing result in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" sec."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  out.close();</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  std::ofstream garbage (<span class="stringliteral">"garbage.off"</span>);</div><div class="line">  <span class="comment">// Write facets that were removed to force manifold output</span></div><div class="line">  <span class="keywordflow">for</span>( Mesher_iterator it = mesher.garbage_begin( ); it != mesher.garbage_end(  ); ++it )</div><div class="line">    garbage &lt;&lt; <span class="stringliteral">"3 "</span>&lt;&lt; *it &lt;&lt; <span class="charliteral">'\n'</span>; <span class="comment">// We write a '3' in front so that it can be assembled into an OFF file</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Writing garbage facets in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" sec."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  garbage.close ();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>This last example shows how to use the alternative operators <a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html">Jet_smoother</a> and <a class="el" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">Advancing_front_mesher</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Scale_space_reconstruction_3_2scale_space_advancing_front_8cpp-example.html">Scale_space_reconstruction_3/scale_space_advancing_front.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_reconstruction_3/Advancing_front_mesher.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_reconstruction_3/Jet_smoother.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_off_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>     Kernel;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</a>                    Reconstruction;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher&lt;Kernel&gt;</a>    Mesher;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html">CGAL::Scale_space_reconstruction_3::Jet_smoother&lt;Kernel&gt;</a>              Smoother;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Reconstruction::Facet_const_iterator                   Facet_iterator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (argc!=2){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error, no input file provided\n"</span>;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  <span class="comment">// Read the data.</span></div><div class="line">  Point_set points;</div><div class="line">  std::ifstream in(argv[1]);</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading "</span> &lt;&lt; std::flush;</div><div class="line">  in &gt;&gt; points;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (points.empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done: "</span> &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reconstruction "</span>;</div><div class="line"></div><div class="line">  CGAL::Timer t;</div><div class="line">  t.start();</div><div class="line">  </div><div class="line">  <span class="comment">// Construct the mesh in a scale space.</span></div><div class="line">  Reconstruction reconstruct (points.points().begin(), points.points().end());</div><div class="line">  reconstruct.increase_scale&lt;Smoother&gt; (4);</div><div class="line">  reconstruct.reconstruct_surface (Mesher (0.5));</div><div class="line">  </div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" sec."</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  t.reset();</div><div class="line">  </div><div class="line">  std::ofstream out (<span class="stringliteral">"out.off"</span>);</div><div class="line">  out &lt;&lt; <span class="stringliteral">"OFF"</span> &lt;&lt; std::endl &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; reconstruct.number_of_facets() &lt;&lt; <span class="stringliteral">" 0"</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (Point_set::iterator it = points.begin(); it != points.end(); ++ it)</div><div class="line">    out &lt;&lt; points.point(*it) &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (Reconstruction::Facet_iterator it = reconstruct.facets_begin();</div><div class="line">       it != reconstruct.facets_end(); ++ it)</div><div class="line">    out &lt;&lt; <span class="stringliteral">"3 "</span> &lt;&lt; (*it)[0] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; (*it)[1] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; (*it)[2] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Writing result in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" sec."</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done."</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ScaleSpaceReconstruction3secDesImpl"></a>
Design and Implementation History</h1>
<p>This method was developed by Julie Digne <em>et al.</em> in 2011 <a class="el" href="citelist.html#CITEREF_cgal:dmsl-ssmrp-11">[1]</a> and implemented by Thijs van Lankveld at Inria - Sophia Antipolis in 2014. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:04 for CGAL 4.13 - Scale-Space Surface Reconstruction by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
