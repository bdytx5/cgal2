<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Scale_space_reconstruction"/><anchor id="index_1chapterScaleSpaceReconstruction3"/></para><para><simplesect kind="authors"><para>Thijs van Lankveld</para></simplesect>
This CGAL package implements a surface reconstruction method which takes as input an unordered point set and computes a triangulated surface mesh interpolating the point set. We assume that the input points were sampled from the surface of an object. The method can also process point sets sampled from the interior of the object, although we cannot provide guarantees on the output. This method can handle a decent amount of noise and outliers. The point set may greatly undersample the object in occluded regions, although no surface will be reconstructed to fill these regions.</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figIntro"/><image type="html" name="knot2_pts_surf.png"></image>
 <image type="latex" name="knot2_pts_surf.png" width="15cm"></image>
  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figIntro" kindref="member">fig__chapterScaleSpaceReconstruction3figIntro</ref> Left: 5760 points on a synthetic knot data set. Right: reconstructed surface mesh.  <linebreak/>
</para><para>A triangulated surface mesh is generated by first computing the point set at a coarse scale, then constructing a mesh of the point set at this scale, and finally reverting the points of the mesh back to their original scale.</para><sect1 id="index_1ScaleSpaceReconstruction3secMethod">
<title>Scale-Space</title>
<para>The problem of surface reconstruction from a point sample is ill-defined. Because the points only provide a sample of the surface, we cannot determine with exact certainty how the surface behaves between the points. We may get more information about the surface by sampling the surface further, but even then the problem remains on a smaller scale.</para><para>For real-world data sets we also have to contend with noise and outliers, small errors in the point location and points that do not sample the surface respectively. These are generally caused by faults in the measurement procedure. Unless we actually know the surface sampled, we cannot determine whether a distinctive point is an outlier, is caused by noise, or samples a small feature of the surface.</para><para>To overcome these obstacles, we model the point set at different scales using a scale-space <ref refid="citelist_1CITEREF_cgal:dmsl-ssmrp-11" kindref="member">[1]</ref>. For our purpose, a <emphasis>scale</emphasis> is an abstraction level of the point set. At a lower, finer scale the point set describes smaller features of the object. Conversely at a higher, coarser scale the point set only describes larger features. A <emphasis>scale-space</emphasis> describes the point set at a dynamic scale. It is a four-dimensional space with the scale as fourth dimension. Increasing the scale is similar to smoothing the underlying surface described by the point set. <ref refid="index_1fig__chapterScaleSpaceReconstruction3figScales" kindref="member">fig__chapterScaleSpaceReconstruction3figScales</ref> shows an example point set at different scales. The overall effect of modeling this scale-space, is that the surface reconstruction problem is more well-defined at higher scales.</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figScales"/><image type="html" name="scale_space_pts.png"></image>
 <image type="latex" name="scale_space_pts.png" width="15cm"></image>
  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figScales" kindref="member">fig__chapterScaleSpaceReconstruction3figScales</ref> The black point set contains a smooth region, a region with large features, and a region with either small features or noisy points. The blue points show the point cloud at a higher scale.  <linebreak/>
</para><para>Small changes in scale result in small changes in the points set that depends on the local shape. As the scale increases, the geometry approaches a number of points based on the connected components. Given a set of points at a fixed scale, the point set at a higher scale can be determined unambiguously, but this is not the case for the point set at a lower scale, as demonstrated by <ref refid="index_1fig__chapterScaleSpaceReconstruction3figLine" kindref="member">fig__chapterScaleSpaceReconstruction3figLine</ref></para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figLine"/><image type="html" name="line.png"></image>
 <image type="latex" name="line.png" width="15cm"></image>
  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figLine" kindref="member">fig__chapterScaleSpaceReconstruction3figLine</ref> The black points and crosses show two different point sets. The blue boxes show both point sets at a higher scale. Note that given just the blue boxes, we cannot determine its point set at a lower scale.  <linebreak/>
</para><para>The scale-space surface reconstruction method works in two phases. Firstly, a scale-space is constructed from the point set and an intersection of this space at a higher scale <formula id="0">$ s $</formula> is computed. Then, a triangulated surface mesh of the point set at scale <formula id="0">$ s $</formula> is computed. Neighboring triangles in the mesh have consistent orientation, as expressed using the <emphasis>right-hand rule</emphasis> on the ordered vertices of the triangle.</para><para>Generally, a reconstruction interpolating the original point set is desired. This can be achieved by reverting the points of the mesh to their original scale, i.e. their original locations. <ref refid="index_1fig__chapterScaleSpaceReconstruction3figSurfs" kindref="member">fig__chapterScaleSpaceReconstruction3figSurfs</ref> shows example reconstructions from the point set at its original scale and at a higher scale with reverted mesh.</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figSurfs"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="scale_space_surf_1.png"></image>
 <image type="latex" name="scale_space_surf_1.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="scale_space_surf_2.png"></image>
 <image type="latex" name="scale_space_surf_2.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figSurfs" kindref="member">fig__chapterScaleSpaceReconstruction3figSurfs</ref> The surfaces constructed from the point set at the original scale (left) and at a higher scale (right). The surface points in the right figure are reverted back to the original scale. The dashed paths shows the inward-facing shell where it does not overlap the outward-facing shell. Note how the scale-space reconstruction assumes the points on the right side of the object sample small features.  <linebreak/>
</para><para>Both the smoothing operator and the mesh reconstruction assume that points near each other belong to the same part of the object. This is usually expressed in the notion of balls with a fixed size, the neighborhood radius. If such a ball contains multiple points, these points are <emphasis>near</emphasis> each other and will influence each other while increasing the scale. If such a ball is empty, it lies outside the object. Note that <emphasis>outside</emphasis> is based on regions empty of points, not on whether a volume is enclosed by the surface.</para><para>The neighborhood size can be estimated through statistical analysis. We use a kD-tree to estimate the mean distance to the n-th nearest neighbor and we use this distance as an approximator for the resolution.</para><para>The point set at the initial scale is equivalent to the input point set. In theory the scale can be varied continuously, but in practice the scale is increased in discrete iterations for efficiency reasons. The scale is increased one iteration by transforming each point using a smoothing operator. CGAL provides two smoothing operators for scale space reconstruction:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Weighted__PCA__smoother" kindref="compound">CGAL::Scale_space_reconstruction_3::Weighted_PCA_smoother</ref></computeroutput> (default) uses the <emphasis>density</emphasis>-weighted principal component analysis (PCA) of the local neighborhood. If the point set was sampled from a surface for which any unwanted deformation and sampling noise is smaller than the neighborhood size, the scale is coarse enough for mesh reconstruction after a few iterations of increasing the scale.</para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother" kindref="compound">CGAL::Scale_space_reconstruction_3::Jet_smoother</ref></computeroutput> uses the function <computeroutput>CGAL::jet_smooth_point_set()</computeroutput> that projects the point to a local smooth (jet) surface. This smoothing is less agressive and should be used if the point set is not very noisy and if a higher precision is sough.</para></listitem></itemizedlist>
</para><para>Users can define their own smoothing operators by following the concept <computeroutput><ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Smoother" kindref="compound">CGAL::Scale_space_reconstruction_3::Smoother</ref></computeroutput>.</para><para>Meshing is achieved by interpolating the smoothed point cloud and propagating back the connectivity to the original point cloud. CGAL provides two meshing operators for scale space reconstruction:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Alpha__shape__mesher" kindref="compound">CGAL::Scale_space_reconstruction_3::Alpha_shape_mesher</ref></computeroutput> (default) uses a filtered <computeroutput><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Alpha_shapes_3.tag">CGAL::Alpha_shape_3</ref></computeroutput> algorithm to generate one or several &quot;shells&quot;. This method is designed for closed shapes (without boundary). Point sets sampling an opened shape result in an overlapping surface. It requires a fixed neighborhood size parameter, related to the resolution of the data. This parameter indicates a region for which we can assume it contains at least one point if it is centered on the surface.</para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher" kindref="compound">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher</ref></computeroutput> uses the algorithm <computeroutput><ref refid="classCGAL_1_1Advancing__front__surface__reconstruction" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag">CGAL::Advancing_front_surface_reconstruction</ref></computeroutput> to generate an oriented 2-manifold surface. This method handles shapes with boundaries and gives the user control over the largest facets used.</para></listitem></itemizedlist>
</para><para>The method provides access to intermediate results and users can adjust these to better suit their needs. The (intermediate) results are the estimate of the resolution, the scale, and the final collection of surface triangles.</para><para>Note that <ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother" kindref="compound">Jet_smoother</ref> and <ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher" kindref="compound">Advancing_front_mesher</ref> are methods that rely upon other CGAL packages and that do not correspond to the original scale space algorithm. They can be used as alternative operators for the cases of point clouds with low noise that sample surfaces with boundaries. For more information on their parameters and effect, please refer to their respective manual pages (<ref refid="index_1Point_set_processing_3Smoothing" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_processing_3.tag">Smoothing</ref> and <ref refid="index_1Chapter_Advancing_Front_Surface_Reconstruction" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag">Chapter_Advancing_Front_Surface_Reconstruction</ref>). The rest of this documentation focuses on the default behavior using <ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Weighted__PCA__smoother" kindref="compound">Weighted_PCA_smoother</ref> and <ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Alpha__shape__mesher" kindref="compound">Alpha_shape_mesher</ref>.</para><sect2 id="index_1ScaleSpaceReconstruction3secParam">
<title>Parameter Settings</title>
<para>The scale-space surface reconstruction method has two main global parameters: the radius of the neighborhood ball and the number iterations of increasing the scale. If no appropriate neighborhood radius is known, this can be estimated using another two parameters: the mean number of neighbors and the number of samples. We have empirically determined values for each of these parameters that work well on a broad spectrum of data sets. However, we advise to carefully fine-tune these parameters for each type of data set.</para><para>The scale-space reconstruction operates locally. Points within a local neighborhood influence each other when increasing the scale. Similarly, points near each other in space are more likely to be near each other on the reconstructed surface. Therefore, it is important to have a good indication of which points are near each other. This proximity is expressed in the neighborhood ball radius parameter.</para><para>The neighborhood ball radius is related to the point density and the object thickness. In the ideal case, the radius is chosen such that any ball <formula id="1">$ B $</formula> with this radius centered on any point of surface of the object will contain several points that should be connected by a local patch in the surface to reconstruct. At the same time, <formula id="1">$ B $</formula> should not contain any points that should not be part of this local patch, such as points on the other side of the object.</para><para>The neighborhood radius can be estimated automatically from the point set. In this case, the radius is estimated such that on average it contains a given number of points. The number of points should be chosen such that the conditions on the neighborhood radius described above are preserved. Generally, an average of 30 neighbors gives good results. This number may be increased if parts of the object have a very low point density, it may be decreased if thin features of the object should be reconstructed better.</para><para>The radius estimation is based on a number of sample points. This number of samples is related to how regularly the point set covers the object. A large sample size may be required if the object is covered very irregularly. However, a larger number of samples may require more computation time. We generally use 200 samples to estimate the neighborhood radius.</para><para>The scale-space method tries to make the surface reconstruction problem less ill-posed by increasing the scale to an appropriately coarse scale. At this coarse scale the point set samples a smoothed surface, which is easier to reconstruct. The number of scale increase iterations determines how much this surface is smoothed.</para><para>The number of iterations is related to the noise in the point set, the acuteness of surface features, and the thickness of the object. Point sets with a lot of noise and objects with sharp or small features will require more iterations. At the same time, processing too many iterations can degenerate a volume into a plane. These degeneracies may cause the reconstructed surface to connect points on opposite sides of the object. Generally, 4 iterations of increasing the scale are appropriate.</para></sect2>
<sect2 id="index_1ScaleSpaceReconstruction3secOutput">
<title>Output Surface</title>
<para>The surface mesh constructed at scale <formula id="0">$ s $</formula> is non-self-intersecting. The interiors of any two triangles cannot pairwise intersect in a line segment. However, the surface does not need to be 2-manifold. An edge may be incident to more than two triangles and triangles may overlap exactly if large regions on both sides of the triangle are empty of points. Note that we count overlapping triangles with opposite orientations as separate triangles. In many cases where the points sample the surface of an object, the computed surface will contain both an <emphasis>outward-facing</emphasis> and a similar <emphasis>inward-facing</emphasis> surface, with a thin volume between them.</para><para>The surface mesh will not have edges incident to only one triangle or holes, loops of such edges, and the triangles are all oriented away from the point set. If the point set has <emphasis>holes</emphasis>, it is likely that the surface mesh will contain overlapping triangles with opposite orientation touching this hole.</para><para>An additional treatment can be applied to force the output surface to be 2-manifold: small flat volumes are found before reconstructing and the surface is forced to only use one side of the volume while keeping consistency with the adjacent singular facets. Only one side of each singular facet is used. In addition, non-manifold edges and vertices are removed as a post-processing. The facets that have been discarded to make the surface 2-manifold are stored and accessible.</para><para>If the object is not densely sampled or has disconnected components, the reconstructed surface may have several disconnected components. The surface is either an unordered collection of triangles, or the same collection sorted per <emphasis>shell</emphasis>. A shell is a collection of connected triangles that are locally oriented towards the same side of the surface.</para><para>When reverted to the original scale, we cannot guarantee the surface is a valid embedding, because the triangles of this surface may pairwise intersect in their interior. It may also have boundary edges, although these will always be incident to two surface triangles oriented in opposite directions. However, when using appropriate parameter settings for the number of iterations and neighborhood size the surface will generally not self-intersect. The appropriate parameter settings depend on the geometry of the point set and generally need to be fine-tuned per data set, as described later.</para></sect2>
</sect1>
<sect1 id="index_1ScaleSpaceReconstruction3secDesign">
<title>Software Design</title>
<para>The main classes <computeroutput><ref refid="classCGAL_1_1Scale__space__surface__reconstruction__3" kindref="compound">Scale_space_surface_reconstruction_3</ref></computeroutput>, <ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Weighted__PCA__smoother" kindref="compound">Weighted_PCA_smoother</ref> and <ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Alpha__shape__mesher" kindref="compound">Alpha_shape_mesher</ref> contain all the functionality to estimate the neighborhood size, compute the scale-space and increase the scale, and reconstruct the surface from the point set at the current scale.</para><para>The neighborhood size is estimated using <computeroutput><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Spatial_searching.tag">Orthogonal_k_neighbor_search</ref></computeroutput>. The point set is generally stored in a <computeroutput><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search_1a25bde1160d0c7784f04ccd2a9e9019f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Spatial_searching.tag">Orthogonal_k_neighbor_search::Tree</ref></computeroutput>. When the neighborhood size is estimated, this tree is searched for nearest neighbors.</para><para>The scale-space is constructed at the original scale of the points. An iteration of increasing the scale is computed using a weighted PCA procedure. As described by Digne <emphasis>et al.</emphasis> <ref refid="citelist_1CITEREF_cgal:dmsl-ssmrp-11" kindref="member">[1]</ref>, unlike similar methods this procedure does not lead to an <emphasis>undesirable clustering effect</emphasis>. By default the efficient <ref refid="installation_1thirdpartyEigen" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Eigen</ref> library is used for this procedure if available. Otherwise, the internal fallback <computeroutput>Diagonalize_traits</computeroutput> is used. It is also possible to provide your own model for the <computeroutput><ref refid="classDiagonalizeTraits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Solver_interface.tag">DiagonalizeTraits</ref></computeroutput> concept. The weighted PCA procedure is performed locally per point, so it can be performed with parallel computing (linking with Intel TBB and passing the <computeroutput><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Parallel_tag</ref></computeroutput> to the reconstruction class is required).</para><para>The mesh reconstruction is performed by filtering a <ref refid="index_1Chapter_3D_Alpha_Shapes" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Alpha_shapes_3.tag">3D alpha shape</ref> of the point set at a fixed scale. This filtering constructs a triangle for each regular facet; each singular facet results in two triangles facing opposite directions.</para><para>The resulting surface is stored as a collection of triples. Each triple contains three indices to the point set. The scale iterations do not change the order of the points. This means these indices can be applied on the point set at its original scale to get an interpolating surface, called <emphasis>reverting</emphasis> the scale of the surface. The indices may also be applied to the point set at the current scale to get a smoothed surface. This smoothed surface will generally have shrunk somewhat compared to the reverted surface.</para><para>To reduce memory requirements, the point set is not stored at its original scale. Instead, the stored point set at the current scale is a clone of the input. This means that the original input can be used to revert the surface.</para></sect1>
<sect1 id="index_1Triangulation3secComplexity">
<title>Case Sets and Performance</title>
<para>There is a wide variety of possible point sets, whether synthetic or measured. The scale-space surface reconstruction method attempts to make the reconstruction problem less ill-posed. However, we cannot guarantee good results for arbitrary point set. Some point sets require careful parameter setting, while for others this method is ill-suited altogether. Here, we show different cases including the ideal sampling and different problem cases.</para><sect2 id="index_1Triangulation3ssecIdeal">
<title>Ideal Conditions</title>
<para>The scale-space surface reconstruction has lenient ideal conditions. The surface should be reasonably regularly sampled and it should not contain overly concave corners. These notions affect the neighborhood parameter in opposing ways: more regular sampling may admit a smaller neighborhood parameter, which will admit smaller concavities. The point set may contain noise that is significantly smaller than the neighborhood size. Even so, when using the method to construct a mesh interpolating the original point set, any noise will deform the mesh. <ref refid="index_1fig__chapterScaleSpaceReconstruction3figIdeal" kindref="member">fig__chapterScaleSpaceReconstruction3figIdeal</ref> shows a reconstruction under ideal conditions.</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figIdeal"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="retinal_pts.png"></image>
 <image type="latex" name="retinal_pts.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="retinal_surf.png"></image>
 <image type="latex" name="retinal_surf.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figIdeal" kindref="member">fig__chapterScaleSpaceReconstruction3figIdeal</ref> <bold>Left:</bold> In the ideal case, points are regularly distributed and concavities are limited. <bold>Right:</bold> reconstructed surface mesh.  <linebreak/>
</para></sect2>
<sect2 id="index_1Triangulation3ssecBound">
<title>Boundaries</title>
<para>Surfaces with boundaries are handled naturally. However, it is important to note that in these cases, the surface does not explicitly identify the boundary and <emphasis>loops</emphasis> around it. In many cases, this will lead to boundary edges being shared by neighboring triangles of the surface that are identical except for their orientation. The boundaries may be made explicit by identifying orientation discrepancies between neighboring triangles, but this functionality is not provided by this package. <ref refid="index_1fig__chapterScaleSpaceReconstruction3figBound" kindref="member">fig__chapterScaleSpaceReconstruction3figBound</ref> shows a reconstructed surface with a boundary.</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figBound"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="mushroom_pts.png"></image>
 <image type="latex" name="mushroom_pts.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="mushroom_surf.png"></image>
 <image type="latex" name="mushroom_surf.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figBound" kindref="member">fig__chapterScaleSpaceReconstruction3figBound</ref> <bold>Left:</bold> A point sample of a surface with boundary. <bold>Right:</bold> reconstructed surface mesh.  <linebreak/>
</para><para>Note that the mesher <ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher" kindref="compound">Advancing_front_mesher</ref> is a good alternative for producing well oriented surfaces with boundaries.</para></sect2>
<sect2 id="index_1Triangulation3ssecRegularity">
<title>Sampling Regularity</title>
<para>As described above, ideally the point set regularly samples the surface. For example, for each point its six nearest points lie at roughly equal distance forming a rough hexagon around the point. This will generally not occur when working with realistic data. The scale-space method can reconstruct very unevenly sampled surfaces, as <ref refid="index_1fig__chapterScaleSpaceReconstruction3figUneven" kindref="member">fig__chapterScaleSpaceReconstruction3figUneven</ref> shows. However, as noted earlier the sampling regularity and allowed concavity form a trade-off. <ref refid="index_1fig__chapterScaleSpaceReconstruction3figUnevenFail" kindref="member">fig__chapterScaleSpaceReconstruction3figUnevenFail</ref> shows a case where we cannot simultaneously model the concave regions and sparse regions correctly.</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figUneven"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="femur_pts.png"></image>
 <image type="latex" name="femur_pts.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="femur_surf.png"></image>
 <image type="latex" name="femur_surf.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figUneven" kindref="member">fig__chapterScaleSpaceReconstruction3figUneven</ref> <bold>Left:</bold> A very irregularly sampled point set. <bold>Right:</bold> reconstructed surface mesh.  <linebreak/>
</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figUnevenFail"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="lion-head_pts.png"></image>
 <image type="latex" name="lion-head_pts.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="lion-head_surf.png"></image>
 <image type="latex" name="lion-head_surf.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figUnevenFail" kindref="member">fig__chapterScaleSpaceReconstruction3figUnevenFail</ref> <bold>Left:</bold> A very irregularly sampled point set with tight concavities. <bold>Right:</bold> reconstructed surface mesh. Note we cannot correctly model the mouth and eyes as well as the neck.  <linebreak/>
</para></sect2>
<sect2 id="index_1Triangulation3ssecSharp">
<title>Sharp Features</title>
<para>The scale-space surface reconstruction method was not designed to deal specifically with surfaces with sharp features. However, it reconstructs these features adequately when using appropriate parameter settings, as demonstrated in <ref refid="index_1fig__chapterScaleSpaceReconstruction3figSharp" kindref="member">fig__chapterScaleSpaceReconstruction3figSharp</ref>. The main prerequisite for correctly reconstructing the sharp features is that they contain sufficient sample points on the features and the features are not too thin compared to the neighborhood parameter.</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figSharp"/><center> <table rows="1" cols="4"><row>
<entry thead="no"><para><image type="html" name="fandisk_pts.png"></image>
 <image type="latex" name="fandisk_pts.png" width="3.75cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="fandisk_surf.png"></image>
 <image type="latex" name="fandisk_surf.png" width="3.75cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="fandisk_2_surf.png"></image>
 <image type="latex" name="fandisk_2_surf.png" width="3.75cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="fandisk_2_surf_detail.png"></image>
 <image type="latex" name="fandisk_2_surf_detail.png" width="3.75cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figSharp" kindref="member">fig__chapterScaleSpaceReconstruction3figSharp</ref> A point set on a surface with sharp creases and the reconstructed surface mesh seen from different sides. Note that the sharp features are mostly reconstructed correctly. However, in the thin regions circled in red the feature is not reconstructed correctly. The trade-off between regularity and concavity also means a hole appears in the third figure, bottom right.  <linebreak/>
</para></sect2>
<sect2 id="index_1Triangulation3ssecTopo">
<title>Topology</title>
<para>The scale-space surface reconstruction method does not take into account the topology of the surface. This means the reconstructed surface may have a different topology than the surface sampled to obtain the point set. <ref refid="index_1fig__chapterScaleSpaceReconstruction3figTopo" kindref="member">fig__chapterScaleSpaceReconstruction3figTopo</ref> shows an example point set that was sampled from a surface with the topology of a sphere; the reconstructed surface has the topology of a torus.</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figTopo"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="man_pts.png"></image>
 <image type="latex" name="man_pts.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="man_surf.png"></image>
 <image type="latex" name="man_surf.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figTopo" kindref="member">fig__chapterScaleSpaceReconstruction3figTopo</ref> <bold>Left:</bold> An irregularly sampling of a surface with the topology of a sphere. <bold>Right:</bold> reconstructed surface mesh with the topology of a torus. Note that the irregular sampling makes it impossible to reconstruct a surface with the topology of a sphere, because the method uses a global scale parameter.  <linebreak/>
</para></sect2>
<sect2 id="index_1Triangulation3ssecAttrib">
<title>Point Attributes</title>
<para>Many point sets contain point attributes such as normals or colors. Because the scale-space surface reconstruction constructs the connectivity between the original points, any point attributes that make sense for a surface can be propagated to the reconstruction. <ref refid="index_1fig__chapterScaleSpaceReconstruction3figColor" kindref="member">fig__chapterScaleSpaceReconstruction3figColor</ref> shows the surface reconstructed for a set of points with colors.</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figColor"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="trophime.png"></image>
 <image type="latex" name="trophime.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="trophime_detail.png"></image>
 <image type="latex" name="trophime_detail.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figColor" kindref="member">fig__chapterScaleSpaceReconstruction3figColor</ref> <bold>Left:</bold> A reconstructed surface with vertex coloring using the colors of the point set. <bold>Right:</bold> detail of the surface shown as wire-frame. Images or image-based modeling: MAP (Modèles et simulations pour l&apos;Architecture et le Patrimoine) - UMR CNRS/MCC 3495.  <linebreak/>
</para></sect2>
<sect2 id="index_1Triangulation3ssecPerform">
<title>Performance</title>
<para>We have evaluated the scale-space surface reconstruction method on several data sets of various sizes. <ref refid="index_1fig__chapterScaleSpaceReconstruction3figBenchmarks" kindref="member">fig__chapterScaleSpaceReconstruction3figBenchmarks</ref> shows the parameter settings used when processing the scale-space reconstruction method.</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figSettings"/><center> <table rows="25" cols="4"><row>
<entry thead="yes"><para>Data set </para></entry><entry thead="yes"><para>Neighbors </para></entry><entry thead="yes"><para>Samples </para></entry><entry thead="yes"><para>Iterations  </para></entry></row>
<row>
<entry thead="no"><para>Mushroom (s) </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>2 </para></entry></row>
<row>
<entry thead="no"><para>Elephant (s) </para></entry><entry thead="no"><para>15 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>1 </para></entry></row>
<row>
<entry thead="no"><para>Knot 1 (s) </para></entry><entry thead="no"><para>8 </para></entry><entry thead="no"><para>100 </para></entry><entry thead="no"><para>8 </para></entry></row>
<row>
<entry thead="no"><para>Retinal (s) </para></entry><entry thead="no"><para>30 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Femur </para></entry><entry thead="no"><para>25 </para></entry><entry thead="no"><para>300 </para></entry><entry thead="no"><para>6 </para></entry></row>
<row>
<entry thead="no"><para>Kitten (s) </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>100 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Knot 2 (s) </para></entry><entry thead="no"><para>8 </para></entry><entry thead="no"><para>300 </para></entry><entry thead="no"><para>8 </para></entry></row>
<row>
<entry thead="no"><para>Bull (s) </para></entry><entry thead="no"><para>100 </para></entry><entry thead="no"><para>600 </para></entry><entry thead="no"><para>1 </para></entry></row>
<row>
<entry thead="no"><para>Fandisk (s) </para></entry><entry thead="no"><para>6 </para></entry><entry thead="no"><para>300 </para></entry><entry thead="no"><para>8 </para></entry></row>
<row>
<entry thead="no"><para>Lion-head (s) </para></entry><entry thead="no"><para>12 </para></entry><entry thead="no"><para>400 </para></entry><entry thead="no"><para>1 </para></entry></row>
<row>
<entry thead="no"><para>Turbine (s) </para></entry><entry thead="no"><para>60 </para></entry><entry thead="no"><para>400 </para></entry><entry thead="no"><para>1 </para></entry></row>
<row>
<entry thead="no"><para>Graill 1 </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Graill 11 </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Man (s) </para></entry><entry thead="no"><para>100 </para></entry><entry thead="no"><para>600 </para></entry><entry thead="no"><para>1 </para></entry></row>
<row>
<entry thead="no"><para>Face </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Carc 20 LR </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Carc 21 LR </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Bowl 1 </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Bowl 5 </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Fount 1 </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Fount 11 </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Trophime </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Carc 20 </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
<row>
<entry thead="no"><para>Carc 21 </para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>200 </para></entry><entry thead="no"><para>4 </para></entry></row>
</table>
</center>  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figSettings" kindref="member">fig__chapterScaleSpaceReconstruction3figSettings</ref> Settings used when running the scale-space method on several data sets. Data sets indicated by &quot;(s)&quot; are synthetic. <emphasis>Neighbors</emphasis> indicates the number of neighbors the estimated neighborhood ball should contain on average, <emphasis>Samples</emphasis> indicates the number of sample points used to estimate the neighborhood radius, <emphasis>Iterations</emphasis> indicates the number of scale increase iterations.  <linebreak/>
</para><para><ref refid="index_1fig__chapterScaleSpaceReconstruction3figBenchmarks" kindref="member">fig__chapterScaleSpaceReconstruction3figBenchmarks</ref> shows the number of triangles of the surfaces constructed and the running time for doing so. Half of the data sets are synthetic, the others are constructed by image-based dense reconstruction. The data sets are ordered by size, the synthetic sets mainly making up the smaller ones.</para><para>The times were measured on a 64-bit Windows 7 system with 8 2.5GHz Intel processors and 16GB RAM. The scale-space constructions employ parallel computing using Intel TBB. The smaller data sets use roughly 0.1GB of memory, but the largest data sets have a peak usage of 10.5GB during the meshing step. For this benchmark we used the <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput> kernel, <computeroutput>FS</computeroutput> enabled, and <computeroutput>Sh</computeroutput> disabled.</para><para><anchor id="index_1fig__chapterScaleSpaceReconstruction3figBenchmarks"/><center> <table rows="25" cols="7"><row>
<entry thead="yes"><para>Data set </para></entry><entry thead="yes"><para>Number of points </para></entry><entry thead="yes"><para>Surface triangles </para></entry><entry thead="yes"><para>Neighborhood (ms) </para></entry><entry thead="yes"><para>Scale-space (ms) </para></entry><entry thead="yes"><para>Meshing (ms) </para></entry><entry thead="yes"><para>Total (ms)  </para></entry></row>
<row>
<entry thead="no"><para>Mushroom (s) </para></entry><entry thead="no"><para>2,337 </para></entry><entry thead="no"><para>7,966 </para></entry><entry thead="no"><para>7 </para></entry><entry thead="no"><para>64 </para></entry><entry thead="no"><para>88 </para></entry><entry thead="no"><para>159 </para></entry></row>
<row>
<entry thead="no"><para>Elephant (s) </para></entry><entry thead="no"><para>2,775 </para></entry><entry thead="no"><para>6,746 </para></entry><entry thead="no"><para>4 </para></entry><entry thead="no"><para>33 </para></entry><entry thead="no"><para>91 </para></entry><entry thead="no"><para>128 </para></entry></row>
<row>
<entry thead="no"><para>Knot 1 (s) </para></entry><entry thead="no"><para>3,200 </para></entry><entry thead="no"><para>12,800 </para></entry><entry thead="no"><para>7 </para></entry><entry thead="no"><para>148 </para></entry><entry thead="no"><para>134 </para></entry><entry thead="no"><para>289 </para></entry></row>
<row>
<entry thead="no"><para>Retinal (s) </para></entry><entry thead="no"><para>3,643 </para></entry><entry thead="no"><para>14,154 </para></entry><entry thead="no"><para>8 </para></entry><entry thead="no"><para>224 </para></entry><entry thead="no"><para>122 </para></entry><entry thead="no"><para>354 </para></entry></row>
<row>
<entry thead="no"><para>Femur </para></entry><entry thead="no"><para>3,897 </para></entry><entry thead="no"><para>12,612 </para></entry><entry thead="no"><para>6 </para></entry><entry thead="no"><para>592 </para></entry><entry thead="no"><para>120 </para></entry><entry thead="no"><para>718 </para></entry></row>
<row>
<entry thead="no"><para>Kitten (s) </para></entry><entry thead="no"><para>5,210 </para></entry><entry thead="no"><para>20,428 </para></entry><entry thead="no"><para>7 </para></entry><entry thead="no"><para>198 </para></entry><entry thead="no"><para>172 </para></entry><entry thead="no"><para>377 </para></entry></row>
<row>
<entry thead="no"><para>Knot 2 (s) </para></entry><entry thead="no"><para>5,760 </para></entry><entry thead="no"><para>22,904 </para></entry><entry thead="no"><para>5 </para></entry><entry thead="no"><para>278 </para></entry><entry thead="no"><para>206 </para></entry><entry thead="no"><para>489 </para></entry></row>
<row>
<entry thead="no"><para>Bull (s) </para></entry><entry thead="no"><para>6,200 </para></entry><entry thead="no"><para>11,892 </para></entry><entry thead="no"><para>20 </para></entry><entry thead="no"><para>238 </para></entry><entry thead="no"><para>149 </para></entry><entry thead="no"><para>407 </para></entry></row>
<row>
<entry thead="no"><para>Fandisk (s) </para></entry><entry thead="no"><para>6,475 </para></entry><entry thead="no"><para>25,282 </para></entry><entry thead="no"><para>5 </para></entry><entry thead="no"><para>330 </para></entry><entry thead="no"><para>212 </para></entry><entry thead="no"><para>547 </para></entry></row>
<row>
<entry thead="no"><para>Lion-head (s) </para></entry><entry thead="no"><para>8,356 </para></entry><entry thead="no"><para>27,128 </para></entry><entry thead="no"><para>7 </para></entry><entry thead="no"><para>125 </para></entry><entry thead="no"><para>249 </para></entry><entry thead="no"><para>382 </para></entry></row>
<row>
<entry thead="no"><para>Turbine (s) </para></entry><entry thead="no"><para>9,210 </para></entry><entry thead="no"><para>14,084 </para></entry><entry thead="no"><para>12 </para></entry><entry thead="no"><para>293 </para></entry><entry thead="no"><para>201 </para></entry><entry thead="no"><para>507 </para></entry></row>
<row>
<entry thead="no"><para>Graill 1 </para></entry><entry thead="no"><para>12,681 </para></entry><entry thead="no"><para>45,326 </para></entry><entry thead="no"><para>14 </para></entry><entry thead="no"><para>1,166 </para></entry><entry thead="no"><para>381 </para></entry><entry thead="no"><para>1,561 </para></entry></row>
<row>
<entry thead="no"><para>Graill 11 </para></entry><entry thead="no"><para>14,617 </para></entry><entry thead="no"><para>54,550 </para></entry><entry thead="no"><para>18 </para></entry><entry thead="no"><para>1,072 </para></entry><entry thead="no"><para>454 </para></entry><entry thead="no"><para>1,544 </para></entry></row>
<row>
<entry thead="no"><para>Man (s) </para></entry><entry thead="no"><para>17,495 </para></entry><entry thead="no"><para>38,496 </para></entry><entry thead="no"><para>25 </para></entry><entry thead="no"><para>845 </para></entry><entry thead="no"><para>421 </para></entry><entry thead="no"><para>1,291 </para></entry></row>
<row>
<entry thead="no"><para>Face </para></entry><entry thead="no"><para>296,275 </para></entry><entry thead="no"><para>906,648 </para></entry><entry thead="no"><para>128 </para></entry><entry thead="no"><para>17,983 </para></entry><entry thead="no"><para>7,843 </para></entry><entry thead="no"><para>25,957 </para></entry></row>
<row>
<entry thead="no"><para>Carc 20 LR </para></entry><entry thead="no"><para>1,311,850 </para></entry><entry thead="no"><para>1,311,850 </para></entry><entry thead="no"><para>154 </para></entry><entry thead="no"><para>20,652 </para></entry><entry thead="no"><para>10,822 </para></entry><entry thead="no"><para>31,632 </para></entry></row>
<row>
<entry thead="no"><para>Carc 21 LR </para></entry><entry thead="no"><para>1,443,510 </para></entry><entry thead="no"><para>1,443,510 </para></entry><entry thead="no"><para>157 </para></entry><entry thead="no"><para>19,778 </para></entry><entry thead="no"><para>12,290 </para></entry><entry thead="no"><para>32,228 </para></entry></row>
<row>
<entry thead="no"><para>Bowl 1 </para></entry><entry thead="no"><para>2,741,328 </para></entry><entry thead="no"><para>2,841,328 </para></entry><entry thead="no"><para>351 </para></entry><entry thead="no"><para>34,688 </para></entry><entry thead="no"><para>22,559 </para></entry><entry thead="no"><para>57,608 </para></entry></row>
<row>
<entry thead="no"><para>Bowl 5 </para></entry><entry thead="no"><para>3,682,188 </para></entry><entry thead="no"><para>3,682,188 </para></entry><entry thead="no"><para>471 </para></entry><entry thead="no"><para>50,762 </para></entry><entry thead="no"><para>29,899 </para></entry><entry thead="no"><para>81,144 </para></entry></row>
<row>
<entry thead="no"><para>Fount 1 </para></entry><entry thead="no"><para>1,504,761 </para></entry><entry thead="no"><para>5,946,502 </para></entry><entry thead="no"><para>764 </para></entry><entry thead="no"><para>112,028 </para></entry><entry thead="no"><para>51,451 </para></entry><entry thead="no"><para>164,262 </para></entry></row>
<row>
<entry thead="no"><para>Fount 11 </para></entry><entry thead="no"><para>2,589,083 </para></entry><entry thead="no"><para>10,203,108 </para></entry><entry thead="no"><para>1,350 </para></entry><entry thead="no"><para>216,623 </para></entry><entry thead="no"><para>85,231 </para></entry><entry thead="no"><para>303,248 </para></entry></row>
<row>
<entry thead="no"><para>Trophime </para></entry><entry thead="no"><para>4,572,657 </para></entry><entry thead="no"><para>16,982,194 </para></entry><entry thead="no"><para>2,413 </para></entry><entry thead="no"><para>630,502 </para></entry><entry thead="no"><para>134,427 </para></entry><entry thead="no"><para>767,389 </para></entry></row>
<row>
<entry thead="no"><para>Carc 20 </para></entry><entry thead="no"><para>5,370,681 </para></entry><entry thead="no"><para>21,190,868 </para></entry><entry thead="no"><para>2,531 </para></entry><entry thead="no"><para>304,015 </para></entry><entry thead="no"><para>179,223 </para></entry><entry thead="no"><para>485,813 </para></entry></row>
<row>
<entry thead="no"><para>Carc 21 </para></entry><entry thead="no"><para>5,800,135 </para></entry><entry thead="no"><para>23,042,576 </para></entry><entry thead="no"><para>2,916 </para></entry><entry thead="no"><para>365,731 </para></entry><entry thead="no"><para>212,840 </para></entry><entry thead="no"><para>581,535 </para></entry></row>
</table>
</center>  <ref refid="index_1fig__chapterScaleSpaceReconstruction3figBenchmarks" kindref="member">fig__chapterScaleSpaceReconstruction3figBenchmarks</ref> Number of triangles of the surfaces constructed and running times in milliseconds for the scale-space method. Data sets indicated by &quot;(s)&quot; are synthetic.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1ScaleSpaceReconstruction3secExamples">
<title>Examples</title>
<para>This first example shows how to read a point set from a file, reconstruct the surface, and for each shell of the reconstruction, access the triangle vertex indices.</para><para><linebreak/>
<bold>File</bold> <ref refid="Scale_space_reconstruction_3_2scale_space_8cpp-example" kindref="compound">Scale_space_reconstruction_3/scale_space.cpp</ref> <programlisting><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_off_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Scale__space__surface__reconstruction__3" kindref="compound">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/>Reconstruction;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Reconstruction::Facet_const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Facet_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc!=2){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error,<sp/>no<sp/>input<sp/>file<sp/>provided\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::flush;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>!in<sp/>||<sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga1d0f58874ed1ddb2b00721f15ba362a9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::read_off_points</ref>(<sp/>in,<sp/>std::back_inserter(<sp/>points<sp/>)<sp/>)<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reconstruction<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>mesh<sp/>in<sp/>a<sp/>scale<sp/>space.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Reconstruction<sp/>reconstruct<sp/>(points.begin(),<sp/>points.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>reconstruct.increase_scale(4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>reconstruct.reconstruct_surface();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>sec.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out<sp/>(</highlight><highlight class="stringliteral">&quot;out.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out<sp/>&lt;&lt;<sp/>reconstruct;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Writing<sp/>result<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>sec.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The different phases of the reconstruction can also be performed individually. This may be helpful in cases where the correct parameter settings are not known in advance. In <ref refid="index_1fig__chapterScaleSpaceReconstruction3figSurfs" kindref="member">fig__chapterScaleSpaceReconstruction3figSurfs</ref>, the right figure shows the surface after incrementing the scale. After examining the reconstructed surface, we may decide that performing more iterations may better model the top-left part.</para><para>The next example performs two reconstructions with different smoothing of the point set by further advancing the scale space. It illustrates how the code can be used in an interactive way.</para><para><linebreak/>
<bold>File</bold> <ref refid="Scale_space_reconstruction_3_2scale_space_incremental_8cpp-example" kindref="compound">Scale_space_reconstruction_3/scale_space_incremental.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_off_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Scale__space__surface__reconstruction__3" kindref="compound">CGAL::Scale_space_surface_reconstruction_3&lt; Kernel &gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Reconstruction;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Weighted__PCA__smoother" kindref="compound">CGAL::Scale_space_reconstruction_3::Weighted_PCA_smoother&lt; Kernel &gt;</ref><sp/>Smoother;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Alpha__shape__mesher" kindref="compound">CGAL::Scale_space_reconstruction_3::Alpha_shape_mesher&lt; Kernel &gt;</ref><sp/><sp/><sp/><sp/>Mesher;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Reconstruction::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Reconstruction::Facet_const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Facet_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>function<sp/>for<sp/>writing<sp/>the<sp/>reconstruction<sp/>output<sp/>in<sp/>the<sp/>off<sp/>format</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>dump_reconstruction(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Reconstruction&amp;<sp/>reconstruct,<sp/>std::string<sp/>name)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>output(name.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>output<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;OFF<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>reconstruct.number_of_points()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>reconstruct.number_of_facets()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>0\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::copy(reconstruct.points_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reconstruct.points_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ostream_iterator&lt;Point&gt;(output,</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/>Facet_iterator<sp/>it<sp/>=<sp/>reconstruct.facets_begin();<sp/>it<sp/>!=<sp/>reconstruct.facets_end();<sp/>++it<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>output<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;3<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*it<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc!=2){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error,<sp/>no<sp/>input<sp/>file<sp/>provided\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>in(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::flush;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>!in<sp/>||<sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga1d0f58874ed1ddb2b00721f15ba362a9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::read_off_points</ref>(<sp/>in,<sp/>std::back_inserter(<sp/>points<sp/>)<sp/>)<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>reconstruction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Reconstruction<sp/>reconstruct;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>the<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reconstruct.insert(<sp/>points.begin(),<sp/>points.end()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Two<sp/>passes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>2;<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>smoother<sp/>with<sp/>parameters<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>neighborhood<sp/>squared<sp/>radius<sp/>estimation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Smoother<sp/>smoother(<sp/>10,<sp/>100<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Advance<sp/>the<sp/>scale-space<sp/>several<sp/>steps.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>automatically<sp/>estimates<sp/>the<sp/>scale-space.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>reconstruct.increase_scale(<sp/>2,<sp/>smoother<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Reconstruct<sp/>the<sp/>surface<sp/>from<sp/>the<sp/>current<sp/>scale-space.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Neighborhood<sp/>squared<sp/>radius<sp/>is<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>smoother.squared_radius()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Mesher<sp/>mesher<sp/>(smoother.squared_radius());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>reconstruct.reconstruct_surface(mesher);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(i<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;First<sp/>reconstruction<sp/>done.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>the<sp/>reconstruction.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dump_reconstruction(reconstruct,<sp/></highlight><highlight class="stringliteral">&quot;reconstruction1.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Second<sp/>reconstruction<sp/>done.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>the<sp/>reconstruction.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dump_reconstruction(reconstruct,<sp/></highlight><highlight class="stringliteral">&quot;reconstruction2.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reconstructions<sp/>are<sp/>ready<sp/>to<sp/>be<sp/>examinated<sp/>in<sp/>your<sp/>favorite<sp/>viewer&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This example shows how to force the output surface to be 2-manifold. In this case, some facets may be discarded in order to remove non-manifold simplices. They are stored in a <emphasis>garbage</emphasis> container in an unordered fashion. They are accessed by iterating on this container.</para><para><linebreak/>
<bold>File</bold> <ref refid="Scale_space_reconstruction_3_2scale_space_manifold_8cpp-example" kindref="compound">Scale_space_reconstruction_3/scale_space_manifold.cpp</ref> <programlisting><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_off_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Scale__space__surface__reconstruction__3" kindref="compound">CGAL::Scale_space_surface_reconstruction_3&lt; Kernel &gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Reconstruction;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Weighted__PCA__smoother" kindref="compound">CGAL::Scale_space_reconstruction_3::Weighted_PCA_smoother&lt; Kernel &gt;</ref><sp/>Smoother;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Alpha__shape__mesher" kindref="compound">CGAL::Scale_space_reconstruction_3::Alpha_shape_mesher&lt; Kernel &gt;</ref><sp/><sp/><sp/><sp/>Mesher;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Reconstruction::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Reconstruction::Facet_const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Facet_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Mesher::Facet_const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Mesher_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Timer<sp/>Timer;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc!=2){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error,<sp/>no<sp/>input<sp/>file<sp/>provided\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::flush;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>!in<sp/>||<sp/>!<ref refid="group__PkgPointSetProcessingIO_1ga1d0f58874ed1ddb2b00721f15ba362a9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::read_off_points</ref>(<sp/>in,<sp/>std::back_inserter(<sp/>points<sp/>)<sp/>)<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>mesh<sp/>in<sp/>a<sp/>scale<sp/>space.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Reconstruction<sp/>reconstruct(<sp/>points.begin(),<sp/>points.end()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Smoother<sp/>smoother(<sp/>10,<sp/>200<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>reconstruct.increase_scale<sp/>(4,<sp/>smoother);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mesher<sp/>mesher(<sp/>smoother.squared_radius(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/></highlight><highlight class="comment">//<sp/>Do<sp/>not<sp/>separate<sp/>shells</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>Force<sp/>manifold<sp/>output</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>reconstruct.reconstruct_surface(<sp/>mesher<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reconstruction<sp/>done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>sec.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out<sp/>(</highlight><highlight class="stringliteral">&quot;out.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>the<sp/>reconstruction.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/>Facet_iterator<sp/>it<sp/>=<sp/>reconstruct.facets_begin(<sp/>);<sp/>it<sp/>!=<sp/>reconstruct.facets_end(<sp/><sp/>);<sp/>++it<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;3<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>*it<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;<sp/></highlight><highlight class="comment">//<sp/>We<sp/>write<sp/>a<sp/>&apos;3&apos;<sp/>in<sp/>front<sp/>so<sp/>that<sp/>it<sp/>can<sp/>be<sp/>assembled<sp/>into<sp/>an<sp/>OFF<sp/>file</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Writing<sp/>result<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>sec.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>garbage<sp/>(</highlight><highlight class="stringliteral">&quot;garbage.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>facets<sp/>that<sp/>were<sp/>removed<sp/>to<sp/>force<sp/>manifold<sp/>output</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/>Mesher_iterator<sp/>it<sp/>=<sp/>mesher.garbage_begin(<sp/>);<sp/>it<sp/>!=<sp/>mesher.garbage_end(<sp/><sp/>);<sp/>++it<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>garbage<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;3<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>*it<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;<sp/></highlight><highlight class="comment">//<sp/>We<sp/>write<sp/>a<sp/>&apos;3&apos;<sp/>in<sp/>front<sp/>so<sp/>that<sp/>it<sp/>can<sp/>be<sp/>assembled<sp/>into<sp/>an<sp/>OFF<sp/>file</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Writing<sp/>garbage<sp/>facets<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>sec.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>garbage.close<sp/>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This last example shows how to use the alternative operators <ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother" kindref="compound">Jet_smoother</ref> and <ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher" kindref="compound">Advancing_front_mesher</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Scale_space_reconstruction_3_2scale_space_advancing_front_8cpp-example" kindref="compound">Scale_space_reconstruction_3/scale_space_advancing_front.cpp</ref> <programlisting><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3/IO.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Scale_space_reconstruction_3/Advancing_front_mesher.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Scale_space_reconstruction_3/Jet_smoother.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_off_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Scale__space__surface__reconstruction__3" kindref="compound">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Reconstruction;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher" kindref="compound">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/>Mesher;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother" kindref="compound">CGAL::Scale_space_reconstruction_3::Jet_smoother&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Smoother;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Point_set_3&lt;Point&gt;<sp/>Point_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Reconstruction::Facet_const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Facet_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc!=2){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error,<sp/>no<sp/>input<sp/>file<sp/>provided\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::flush;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(points.empty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reconstruction<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>mesh<sp/>in<sp/>a<sp/>scale<sp/>space.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Reconstruction<sp/>reconstruct<sp/>(points.points().begin(),<sp/>points.points().end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>reconstruct.increase_scale&lt;Smoother&gt;<sp/>(4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>reconstruct.reconstruct_surface<sp/>(Mesher<sp/>(0.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>sec.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out<sp/>(</highlight><highlight class="stringliteral">&quot;out.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;OFF&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>points.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>reconstruct.number_of_facets()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>0&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Point_set::iterator<sp/>it<sp/>=<sp/>points.begin();<sp/>it<sp/>!=<sp/>points.end();<sp/>++<sp/>it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/>points.point(*it)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Reconstruction::Facet_iterator<sp/>it<sp/>=<sp/>reconstruct.facets_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>!=<sp/>reconstruct.facets_end();<sp/>++<sp/>it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;3<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(*it)[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(*it)[1]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(*it)[2]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Writing<sp/>result<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>sec.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1ScaleSpaceReconstruction3secDesImpl">
<title>Design and Implementation History</title>
<para>This method was developed by Julie Digne <emphasis>et al.</emphasis> in 2011 <ref refid="citelist_1CITEREF_cgal:dmsl-ssmrp-11" kindref="member">[1]</ref> and implemented by Thijs van Lankveld at Inria - Sophia Antipolis in 2014. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
