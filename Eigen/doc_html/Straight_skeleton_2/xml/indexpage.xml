<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Straight_Skeleton_and_Polygon_Offsetting"/><anchor id="index_1chapterstraightskeleton2"/> <simplesect kind="author"><para>Fernando Cacciola</para></simplesect>
</para><sect1 id="index_1Straight_skeleton_2Definitions">
<title>Definitions</title>
<sect2 id="index_1Straight_skeleton_22DContour">
<title>2D Contour</title>
<para>A <emphasis>2D contour</emphasis> is a closed sequence (a cycle) of 3 or more <emphasis>connected 2D oriented straight line segments</emphasis> called <emphasis>contour edges</emphasis>. The endpoints of the contour edges are called <emphasis>vertices</emphasis>. Each contour edge shares its endpoints with at least two other contour edges.</para><para>If the edges intersect only at the vertices and at most are coincident along a line but do not <emphasis>cross</emphasis> one another, the contour is classified as <emphasis>simple</emphasis>.</para><para>A contour is topologically equivalent to a <emphasis>disk</emphasis> and if it is simple, is said to be a <emphasis>Jordan Curve</emphasis>.</para><para>Contours partition the plane in two open regions: one bounded and one unbounded. If the bounded region of a contour is only one <emphasis>singly-connected set</emphasis>, the contour is said to be <emphasis>strictly-simple</emphasis>.</para><para>The <computeroutput>Orientation</computeroutput> of a contour is given by the order of the vertices around the region they bound. It can be <computeroutput>CLOCKWISE</computeroutput> (CW) or <computeroutput>COUNTERCLOCKWISE</computeroutput> (CCW).</para><para>The <emphasis>bounded side</emphasis> of a contour edge is the side facing the bounded region of the contour. If the contour is oriented CCW, the bounded side of an edge is its left side.</para><para>A contour with a null edge (a segment of length zero given by two consecutive coincident vertices), or with edges not connected to the bounded region (an antenna: 2 consecutive edges going forth and back along the same line), is said to be <emphasis>degenerate</emphasis> (collinear edges are <emphasis>not</emphasis> considered a degeneracy).</para></sect2>
<sect2 id="index_1Straight_skeleton_22DPolygonwithHoles">
<title>2D Polygon with Holes</title>
<para>A <emphasis>2D polygon</emphasis> is a contour.</para><para>A <emphasis>2D polygon with holes</emphasis> is a contour, called the <emphasis>outer contour</emphasis>, having zero or more contours, called <emphasis>inner contours</emphasis>, or <emphasis>holes</emphasis>, in its bounded region. The intersection of the bounded region of the outer contour and the unbounded regions of each inner contour is the <emphasis>interior</emphasis> of the polygon with holes. The orientation of the holes must be opposite to the orientation of the outer contour and there cannot be any intersection among any contour. A hole cannot be in the bounded region of any other hole.</para><para>A polygon with holes is strictly-simple if its interior is a singly-connected set.</para><para>The orientation of a polygon with holes is the orientation of its outer contour. The bounded side of <emphasis>any</emphasis> edge, whether of the outer contour or a hole, is the <emphasis>same</emphasis> for all edges. That is, if the outer contour is oriented CCW and the holes CW, both contour and hole edges face the polygon interior to their left.</para><para>Throughout the rest of this chapter the term <emphasis>polygon</emphasis> will be used as a shortcut for <emphasis>polygon with holes</emphasis>.</para><para><anchor id="index_1fig__Validpolygons"/><image type="html" name="valid_polygons.png"></image>
 <image type="latex" name="valid_polygons.png" width="15cm"></image>
  <ref refid="index_1fig__Validpolygons" kindref="member">fig__Validpolygons</ref> Examples of strictly simple polygons: One with no holes and two edges coincident (left) and one with 2 holes (right).  <linebreak/>
</para><para><anchor id="index_1fig__Invalidpolygons"/><image type="html" name="invalid_polygons.png"></image>
 <image type="latex" name="invalid_polygons.png" width="15cm"></image>
  <ref refid="index_1fig__Invalidpolygons" kindref="member">fig__Invalidpolygons</ref> Examples of non-simple polygons: One folding into itself, that is, non-planar (left), one with a vertex touching an edge (middle), and one with a hole crossing into the outside (right)  <linebreak/>
</para></sect2>
<sect2 id="index_1Straight_skeleton_2InwardOffsetofaNondegenerate">
<title>Inward Offset of a Non-degenerate Strictly-Simple Polygon with Holes</title>
<para>For any 2D non-degenerate strictly-simple polygon with holes called the <emphasis>source</emphasis>, there can exist a <emphasis>set</emphasis> of 0, 1 or more <emphasis>inward offset polygons with holes</emphasis>, or just offset polygons for short, at some euclidean distance <emphasis>t</emphasis> <formula id="5">$ &gt;0$</formula> (each being strictly simple and non-degenerate). Any contour edge of such offset polygon, called an <emphasis>offset edge</emphasis> corresponds to <emphasis>some</emphasis> contour edge of the source polygon, called its <emphasis>source edge</emphasis>. An offset edge is parallel to its source edge and has the same orientation. The Euclidean distance between the <emphasis>lines</emphasis> supporting an offset edge and its source edge is exactly <computeroutput>t</computeroutput>.</para><para>An offset edge is always located to the bounded side of its source edge (which is an oriented straight line segment).</para><para>An offset polygon can have less, equal or more sides as its source polygon.</para><para>If the source polygon has no holes, no offset polygon has holes. If the source polygon has holes, any of the offset polygons can have holes itself, but it might as well have no holes at all (if the distance is sufficiently large).</para><para>Each offset polygon has the same orientation as the source polygon.</para><para><anchor id="index_1Offsets"/> </para></sect2>
<sect2 id="index_1Straight_skeleton_2StraightSkeletonofa2D">
<title>Straight Skeleton of a 2D Non-degenerate Strictly-Simple Polygon with Holes</title>
<para>The <emphasis>2D straight skeleton</emphasis> of a non-degenerate strictly-simple polygon with holes <ref refid="citelist_1CITEREF_aaag-ntsp-95" kindref="member">[2]</ref> is a special partitioning of the polygon interior into <emphasis>straight skeleton regions</emphasis> corresponding to the monotone areas traced by a continuous <emphasis>inward offsetting</emphasis> of the contour edges. Each region corresponds to exactly 1 contour edge.</para><para>These regions are bounded by angular bisectors of the supporting lines of the contour edges and each such region is itself a non-convex non-degenerate strictly-simple polygon.</para><para><anchor id="index_1fig__ComplexSLS"/><image type="html" name="complex_skeleton.png"></image>
 <image type="latex" name="complex_skeleton.png" width="15cm"></image>
  <ref refid="index_1fig__ComplexSLS" kindref="member">fig__ComplexSLS</ref> Straight skeleton of a complex shaggy contour  <linebreak/>
</para><para><anchor id="index_1fig__MoreSLS"/><image type="html" name="simple_skeleton_0.png"></image>
 <image type="latex" name="simple_skeleton_0.png" width="15cm"></image>
  <ref refid="index_1fig__MoreSLS" kindref="member">fig__MoreSLS</ref> Other examples: A vertex-event (left), the case of several collinear edges (middle), and the case of a validly simple polygon with tangent edges (right).  <linebreak/>
</para></sect2>
<sect2 id="index_1Straight_skeleton_2AngularBisectingLines">
<title>Angular Bisecting Lines and Offset Bisectors</title>
<para>Given two points and a line passing through them, the perpendicular line passing through the midpoint is the bisecting line (or bisector) of those points.</para><para>Two non-parallel lines, intersecting at a point, are bisected by two other lines passing through that intersection point.</para><para>Two parallel lines are bisected by another parallel line placed halfway in between.</para><para>Given just one line, any perpendicular line can be considered the bisecting line (any bisector of any two points along the single line).</para><para>The bisecting lines of two edges are the lines bisecting the supporting lines of the edges (if the edges are parallel or collinear, there is just one bisecting line).</para><para>The halfplane to the bounded side of the line supporting a contour edge is called the <emphasis>offset zone</emphasis> of the contour edge.</para><para>Given any number of contour edges (not necessarily consecutive), the intersection of their offset zones is called their <emphasis>combined offset zone</emphasis>.</para><para>Any two contour edges define an <emphasis>offset bisector</emphasis>, as follows: If the edges are non-parallel, their bisecting lines can be decomposed as 4 rays originating at the intersection of the supporting lines. Only one of these rays is contained in the combined offset zone of the edges (which one depends on the possible combinations of orientations). This ray is the offset bisector of the non-parallel contour edges.</para><para>If the edges are parallel (but not collinear) and have opposite orientation, the entire and unique bisecting line is their offset bisector. If the edges are parallel but have the same orientation, there is no offset bisector between them.</para><para>If the edges are collinear and have the same orientation, their offset bisector is given by a perpendicular ray to the left of the edges which originates at the midpoint of the combined complement of the edges. (The <emphasis>complement</emphasis> of an edge/segment are the two rays along its supporting line which are not the segment and the <emphasis>combined complement</emphasis> of <computeroutput>N</computeroutput> collinear segments is the intersection of the complements of each segment). If the edges are collinear but have opposite orientation, there is no offset bisector between them.</para></sect2>
<sect2 id="index_1Straight_skeleton_2FacesEdgesandVertices">
<title>Faces, Edges and Vertices</title>
<para>Each region of the partitioning defined by a straight skeleton is called a <emphasis>face</emphasis>. Each face is bounded by straight line segments, called <emphasis>edges</emphasis>. Exactly one edge per face is a <emphasis>contour edge</emphasis> (corresponds to a side of the polygon) and the rest of the edges, located in the interior of the polygon, are called <emphasis>skeleton edges</emphasis>, or <emphasis>bisectors</emphasis>.</para><para>The bisectors of the straight skeleton are segments of the offset bisectors as defined previously. Since an offset bisector is a ray of a bisecting line of 2 contour edges, each skeleton edge (or bisector) is uniquely given by two contour edges. These edges are called the <emphasis>defining contour edges</emphasis> of the bisector.</para><para>The intersection of the edges are called <emphasis>vertices</emphasis>. Although in a simple polygon, only 2 edges intersect at a vertex, in a straight skeleton, 3 or more edges intersect a any given vertex. That is, vertices in a straight skeleton have degree <formula id="6">$ &gt;=3$</formula>.</para><para>A <emphasis>contour vertex</emphasis> is a vertex for which 2 of its incident edges are contour edges.</para><para>A <emphasis>skeleton vertex</emphasis> is a vertex who&apos;s incident edges are all skeleton edges.</para><para>A <emphasis>contour bisector</emphasis> is a bisector who&apos;s defining contour edges are consecutive. Such a bisector is incident upon 1 contour vertex and 1 skeleton vertex and touches the input polygon at exactly 1 endpoint.</para><para>An <emphasis>inner bisector</emphasis> is a bisector who&apos;s defining contour edges are not consecutive. Such a bisector is incident upon 2 skeleton vertices and is strictly contained in the interior of the polygon.</para></sect2>
</sect1>
<sect1 id="index_1Straight_skeleton_2Representation">
<title>Representation</title>
<para>This CGAL package represents a straight skeleton as a specialized <computeroutput>Halfedge Data Structure</computeroutput> (HDS) whose vertices embeds 2D Points (see the <computeroutput><ref refid="classStraightSkeleton__2" kindref="compound">StraightSkeleton_2</ref></computeroutput> concept in the reference manual for details).</para><para>Its halfedges, by considering the source and target points, implicitly embeds 2D oriented straight line segments (each halfedge per see does not embed a segment explicitly).</para><para>A face of the straight skeleton is represented as a face in the HDS. Both contour and skeleton edges are represented by pairs of opposite HDS halfedges, and both contour and skeleton vertices are represented by HDS vertices.</para><para>In a HDS, a border halfedge is a halfedge which is incident upon an unbounded face. In the case of the straight skeleton HDS, such border halfedges are oriented such that their left side faces outwards the polygon. Therefore, the opposite halfedge of any border halfedge is oriented such that its left side faces inward the polygon.</para><para>This CGAL package requires the input polygon (with holes) to be non-degenerate, strictly-simple, and oriented counter-clockwise.</para><para>The skeleton halfedges are oriented such that their <emphasis>left</emphasis> side faces inward the region they bound. That is, the vertices (both contour and skeleton) of a face are circulated in counter-clockwise order. There is one and only one contour halfedge incident upon any face.</para><para>The contours of the input polygon are traced by the border halfedges of the HDS (those facing outward), but in the opposite direction. That is, the vertices of the contours can only by traced from the straight skeleton data structure by circulating the border halfedges, and the resulting vertex sequence will be reversed w.r.t the input vertex sequence.</para><para>A skeleton edge, according to the definition given in the previous section, is defined by 2 contour edges. In the representation, each one of the opposite halfedges that represent a skeleton edge is associated with one of the opposite halfedges that correspond to one of its defining contour edges. Thus, the 2 opposite halfedges of a skeleton edge link the edge to its 2 defining contour edges.</para><para>Starting from any border contour halfedge, circulating the structure walks through border counter halfedges and traces the vertices of the polygon&apos;s contours (in opposite order).</para><para>Starting from any non-border but contour halfedge, circulating the structure walks counter-clockwise around the face corresponding to that contour halfedge. The vertices around a face always describe a non-convex non-degenerate strictly-simple polygon.</para><para>A vertex is the intersection of contour and/or skeleton edges. Since a skeleton edge is defined by 2 contour edges, any vertex is itself defined by a unique set of contour edges. These are called the <emphasis>defining contour edges</emphasis> of the vertex.</para><para>A vertex is identified by it&apos;s set of defining contour edges. Two vertices are distinct if they have differing sets of defining contour edges. Note that vertices can be distinct even if they are geometrically embedded at the same point.</para><para>The <emphasis>degree</emphasis> of a vertex is the number of halfedges around the vertex incident upon (pointing to) the vertex. As with any halfedge data structure, there is one outgoing halfedge for each incoming (incident) halfedge around a vertex. The degree of the vertex counts only incoming (incident) halfedges.</para><para>In a straight skeleton, the degree of a vertex is not only the number of incident halfedges around the vertex but also the number of defining contour halfedges. The vertex itself is the point where all the defining contour edges simultaneously collide.</para><para>Contour vertices have exactly two defining contour halfedges, which are the contour edges incident upon the vertex; and 3 incident halfedges. One and only one of the incident halfedges is a skeleton halfedge. The degree of a contour vertex is exactly 3.</para><para>Skeleton vertices have at least 3 defining contour halfedges and 3 incident skeleton halfedges. If more than 3 edges collide simultaneously at the same point and time (like in any regular polygon with more than 3 sides), the corresponding skeleton vertex will have more than 3 defining contour halfedges and incident skeleton halfedges. That is, the degree of a skeleton vertex is <formula id="6">$ &gt;=3$</formula> (the algorithm initially produces nodes of degree 3 but in the end all coincident nodes are merged to form higher degree nodes). All halfedges incident upon a skeleton vertex are skeleton halfedges.</para><para>The defining contour halfedges and incident halfedges around a vertex can be traced using the circulators provided by the vertex class. The degree of a vertex is not cached and cannot be directly obtained from the vertex, but you can calculate this number by manually counting the number of incident halfedges around the vertex.</para><para>Each vertex stores a 2D point and a <computeroutput>time</computeroutput>, which is the euclidean distance from the vertex&apos;s point to the <emphasis>lines</emphasis> supporting each of the defining contour edges of the vertex (the distance is the same to each line). Unless the polygon is convex, this distance is not equidistant to the edges, as in the case of a Medial Axis, therefore, the time of a skeleton vertex does not correspond to the distance from the polygon to the vertex (so it cannot be used to obtain the deep of a region in a shape, for instance).</para><para>If the polygon <emphasis>is</emphasis> convex, the straight skeleton is exactly equivalent to the polygon&apos;s Voronoi diagram and each vertex time is the equidistance to the defining edges.</para><para>Contour vertices have time zero.</para><para><anchor id="index_1fig__Simplepolyoffsets"/><image type="html" name="fig6.png"></image>
 <image type="latex" name="fig6.png" width="15cm"></image>
  <ref refid="index_1fig__Simplepolyoffsets" kindref="member">fig__Simplepolyoffsets</ref> Straight Skeleton Data Structure  <linebreak/>
</para></sect1>
<sect1 id="index_1Straight_skeleton_2API">
<title>API</title>
<sect2 id="index_1Straight_skeleton_2CreateaStraightSkeleton">
<title>Create a Straight Skeleton</title>
<para>The straight skeleton data structure is defined by the <computeroutput><ref refid="classStraightSkeleton__2" kindref="compound">StraightSkeleton_2</ref></computeroutput> concept and modeled in the <computeroutput><ref refid="classCGAL_1_1Straight__skeleton__2" kindref="compound">Straight_skeleton_2</ref>&lt;Traits,Items,Alloc&gt;</computeroutput> class.</para><para>The simplest way to construct a straight skeleton is via the free functions <computeroutput><ref refid="group__PkgStraightSkeleton2Functions_1gae7a94b0153c186417fc2df0cbc2cbbdc" kindref="member">create_interior_straight_skeleton_2()</ref></computeroutput> and <computeroutput><ref refid="group__PkgStraightSkeleton2Functions_1gaccab04dfe659847c0c427a06a872f7b3" kindref="member">create_exterior_straight_skeleton_2()</ref></computeroutput>, as shown in the following example:</para><para><linebreak/>
<bold>File</bold> <ref refid="Straight_skeleton_2_2Create_straight_skeleton_2_8cpp-example" kindref="compound">Straight_skeleton_2/Create_straight_skeleton_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include&lt;boost/shared_ptr.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/create_straight_skeleton_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Straight__skeleton__2" kindref="compound">CGAL::Straight_skeleton_2&lt;K&gt;</ref><sp/>Ss<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::shared_ptr&lt;Ss&gt;<sp/>SsPtr<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>poly<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(-1,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(0,-12)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(1,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(12,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(1,1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(0,12)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(-1,1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(-12,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>You<sp/>can<sp/>pass<sp/>the<sp/>polygon<sp/>via<sp/>an<sp/>iterator<sp/>pair</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SsPtr<sp/>iss<sp/>=<sp/><ref refid="group__PkgStraightSkeleton2Functions_1gae7a94b0153c186417fc2df0cbc2cbbdc" kindref="member">CGAL::create_interior_straight_skeleton_2</ref>(poly.vertices_begin(),<sp/>poly.vertices_end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Or<sp/>you<sp/>can<sp/>pass<sp/>the<sp/>polygon<sp/>directly,<sp/>as<sp/>below.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>To<sp/>create<sp/>an<sp/>exterior<sp/>straight<sp/>skeleton<sp/>you<sp/>need<sp/>to<sp/>specify<sp/>a<sp/>maximum<sp/>offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>lMaxOffset<sp/>=<sp/>5<sp/>;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SsPtr<sp/>oss<sp/>=<sp/><ref refid="group__PkgStraightSkeleton2Functions_1gaccab04dfe659847c0c427a06a872f7b3" kindref="member">CGAL::create_exterior_straight_skeleton_2</ref>(lMaxOffset,<sp/>poly);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_straight_skeleton(*iss);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_straight_skeleton(*oss);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The input to these functions is the polygon, which can be given as an iterator pair or directly as a <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref></computeroutput> object. In the case of the exterior skeleton, a maximum offset must be specified as well (see the ref manual for details on this max offset parameter).</para></sect2>
<sect2 id="index_1Straight_skeleton_2CreateaStraightSkeleton_1">
<title>Create a Straight Skeleton from a Polygon With Holes</title>
<para>If <computeroutput><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_with_holes_2</ref></computeroutput> is used, you can pass an instance of it directly to the function creating the interior skeleton, as shown below. Notice that a different header must be included in this case.</para><para><linebreak/>
<bold>File</bold> <ref refid="Straight_skeleton_2_2Create_straight_skeleton_from_polygon_with_holes_2_8cpp-example" kindref="compound">Straight_skeleton_2/Create_straight_skeleton_from_polygon_with_holes_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include&lt;boost/shared_ptr.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Polygon_with_holes_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/create_straight_skeleton_from_polygon_with_holes_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_with_holes_2&lt;K&gt;</ref><sp/>Polygon_with_holes<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Straight__skeleton__2" kindref="compound">CGAL::Straight_skeleton_2&lt;K&gt;</ref><sp/><sp/>Ss<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::shared_ptr&lt;Ss&gt;<sp/>SsPtr<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>outer<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(-1,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(0,-12)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(1,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(12,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(1,1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(0,12)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(-1,1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(-12,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>hole<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(-1,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(0,1<sp/>)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(1,0<sp/>)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(0,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_with_holes<sp/>poly(<sp/>outer<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.add_hole(<sp/>hole<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SsPtr<sp/>iss<sp/>=<sp/><ref refid="group__PkgStraightSkeleton2Functions_1gae7a94b0153c186417fc2df0cbc2cbbdc" kindref="member">CGAL::create_interior_straight_skeleton_2</ref>(poly);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_straight_skeleton(*iss);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Straight_skeleton_2CreateOffsetPolygonsfrom">
<title>Create Offset Polygons from a Straight Skeleton</title>
<para>If you already have a straight skeleton instance, the simpler way to generate offset polygons is to call <computeroutput><ref refid="group__PkgStraightSkeleton2Functions_1gaf85a09dc47cb9bb9e2ef28e00fc905ff" kindref="member">create_offset_polygons_2()</ref></computeroutput> as shown in the next example, passing the desired offset and the straight skeleton. You can reuse the same skeleton to generate offsets at a different distance, which is recommended because producing the straight skeleton is much slower then generating offset polygons.</para><para><linebreak/>
<bold>File</bold> <ref refid="Straight_skeleton_2_2Create_offset_polygons_2_8cpp-example" kindref="compound">Straight_skeleton_2/Create_offset_polygons_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;boost/shared_ptr.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/create_offset_polygons_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Straight__skeleton__2" kindref="compound">CGAL::Straight_skeleton_2&lt;K&gt;</ref><sp/>Ss<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::shared_ptr&lt;Polygon_2&gt;<sp/>PolygonPtr<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::shared_ptr&lt;Ss&gt;<sp/>SsPtr<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;PolygonPtr&gt;<sp/>PolygonPtrVector<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>poly<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(-1,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(0,-12)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(1,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(12,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(1,1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(0,12)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(-1,1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(-12,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SsPtr<sp/>ss<sp/>=<sp/><ref refid="group__PkgStraightSkeleton2Functions_1gae7a94b0153c186417fc2df0cbc2cbbdc" kindref="member">CGAL::create_interior_straight_skeleton_2</ref>(poly);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>lOffset<sp/>=<sp/>1<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PolygonPtrVector<sp/>offset_polygons<sp/>=<sp/>CGAL::create_offset_polygons_2&lt;Polygon_2&gt;(lOffset,*ss);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_polygons(offset_polygons);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Straight_skeleton_2CreateOffsetPolygonsfrom_1">
<title>Create Offset Polygons from a Polygon (With or Without Holes)</title>
<para>If you need offset polygons at just one single distance, you can hide away the construction of the straight skeleton by calling directly the functions <computeroutput><ref refid="group__PkgStraightSkeleton2Functions_1ga8b32cf165e4fb19a2cf1a47d9005928d" kindref="member">create_interior_skeleton_and_offset_polygons_2()</ref></computeroutput> and <computeroutput><ref refid="group__PkgStraightSkeleton2Functions_1gaa05856f5b799ab5aed6e488212aa4f31" kindref="member">create_exterior_skeleton_and_offset_polygons_2()</ref></computeroutput> as shown in the following examples:</para><para><linebreak/>
<bold>File</bold> <ref refid="Straight_skeleton_2_2Create_skeleton_and_offset_polygons_2_8cpp-example" kindref="compound">Straight_skeleton_2/Create_skeleton_and_offset_polygons_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;boost/shared_ptr.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/create_offset_polygons_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Straight__skeleton__2" kindref="compound">CGAL::Straight_skeleton_2&lt;K&gt;</ref><sp/>Ss<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::shared_ptr&lt;Polygon_2&gt;<sp/>PolygonPtr<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::shared_ptr&lt;Ss&gt;<sp/>SsPtr<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;PolygonPtr&gt;<sp/>PolygonPtrVector<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>poly<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(-1,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(0,-12)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(1,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(12,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(1,1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(0,12)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(-1,1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(<sp/>Point(-12,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>lOffset<sp/>=<sp/>1<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PolygonPtrVector<sp/>inner_offset_polygons<sp/>=<sp/><ref refid="group__PkgStraightSkeleton2Functions_1ga8b32cf165e4fb19a2cf1a47d9005928d" kindref="member">CGAL::create_interior_skeleton_and_offset_polygons_2</ref>(lOffset,poly);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PolygonPtrVector<sp/>outer_offset_polygons<sp/>=<sp/><ref refid="group__PkgStraightSkeleton2Functions_1gaa05856f5b799ab5aed6e488212aa4f31" kindref="member">CGAL::create_exterior_skeleton_and_offset_polygons_2</ref>(lOffset,poly);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_polygons(inner_offset_polygons);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_polygons(outer_offset_polygons);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>... and using a <computeroutput><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_with_holes_2</ref></computeroutput> directly when available:</para><para><linebreak/>
<bold>File</bold> <ref refid="Straight_skeleton_2_2Create_saop_from_polygon_with_holes_2_8cpp-example" kindref="compound">Straight_skeleton_2/Create_saop_from_polygon_with_holes_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;iterator&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;iomanip&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;boost/shared_ptr.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Polygon_with_holes_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/create_offset_polygons_from_polygon_with_holes_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_with_holes_2&lt;K&gt;</ref><sp/>Polygon_with_holes<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Straight__skeleton__2" kindref="compound">CGAL::Straight_skeleton_2&lt;K&gt;</ref><sp/><sp/>Ss<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::shared_ptr&lt;Polygon_2&gt;<sp/>PolygonPtr<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::shared_ptr&lt;Ss&gt;<sp/>SsPtr<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;PolygonPtr&gt;<sp/>PolygonPtrVector<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>outer<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(-1,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(0,-12)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(1,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(12,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(1,1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(0,12)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(-1,1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(-12,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>hole<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(-1,0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(0,1<sp/>)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(1,0<sp/>)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(0,-1)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_with_holes<sp/>poly(<sp/>outer<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.add_hole(<sp/>hole<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>lOffset<sp/>=<sp/>0.2<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PolygonPtrVector<sp/>offset_polygons<sp/>=<sp/><ref refid="group__PkgStraightSkeleton2Functions_1ga8b32cf165e4fb19a2cf1a47d9005928d" kindref="member">CGAL::create_interior_skeleton_and_offset_polygons_2</ref>(lOffset,poly);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_polygons(offset_polygons);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>If the input polygon has holes, there can be holes in the offset polygons. However, the polygons generated by all the offsetting functions shown before do not have any parent-hole relationship computed; that is, they just instances of <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref></computeroutput> instead of <computeroutput><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_with_holes_2</ref></computeroutput>. If <computeroutput><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_with_holes_2</ref></computeroutput> are available and you need the offsetting to produce them, you can call the function <computeroutput><ref refid="group__PkgStraightSkeleton2Functions_1gafc364113b39f15f5369fbaa495c8f7f6" kindref="member">arrange_offset_polygons_2()</ref></computeroutput> passing the result of any of the offsetting functions described so far. That function arranges the offset polygons detecting and distributing holes within parents. As a shortcut, you can use the function <computeroutput><ref refid="group__PkgStraightSkeleton2Functions_1gac7686e47d2573e95dcca775d2525d51c" kindref="member">create_interior_skeleton_and_offset_polygons_with_holes_2()</ref></computeroutput> as shown below:</para><para><linebreak/>
<bold>File</bold> <ref refid="Straight_skeleton_2_2Create_skeleton_and_offset_polygons_with_holes_2_8cpp-example" kindref="compound">Straight_skeleton_2/Create_skeleton_and_offset_polygons_with_holes_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;boost/shared_ptr.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Polygon_with_holes_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/create_offset_polygons_from_polygon_with_holes_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_with_holes_2&lt;K&gt;</ref><sp/>PolygonWithHoles<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::shared_ptr&lt;PolygonWithHoles&gt;<sp/>PolygonWithHolesPtr<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;PolygonWithHolesPtr&gt;<sp/>PolygonWithHolesPtrVector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>outer<sp/>;<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(<sp/>0.0,<sp/>0.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(10.0,<sp/>0.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(10.0,<sp/>4.5)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(12.0,<sp/>4.5)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(12.0,<sp/>2.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(16.0,<sp/>2.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(16.0,<sp/>8.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(12.0,<sp/>8.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(12.0,<sp/>5.5)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(10.0,<sp/>5.5)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(10.0,10.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outer.push_back(<sp/>Point(<sp/>0.0,10.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>hole<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(3.0,3.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(3.0,7.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(7.0,7.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>hole.push_back(<sp/>Point(7.0,3.0)<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PolygonWithHoles<sp/>poly(<sp/>outer<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.add_hole(<sp/>hole<sp/>)<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>lOffset<sp/>=<sp/>1<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PolygonWithHolesPtrVector<sp/>offset_poly_with_holes<sp/>=<sp/><ref refid="group__PkgStraightSkeleton2Functions_1gac7686e47d2573e95dcca775d2525d51c" kindref="member">CGAL::create_interior_skeleton_and_offset_polygons_with_holes_2</ref>(lOffset,poly);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_polygons_with_holes(offset_poly_with_holes);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para></para><para>Consider an input polygon with parallel edges separated a distance <formula id="7">$ 2*t$</formula>. If you produce an offset polygon at distance <formula id="8">$ t$</formula>, these parallel edges will just collapse each other and vanish from the result, keeping the output as a <emphasis>simple polygon</emphasis>, just like the input. However, if you request an offset polygon at a distance <formula id="9">$ t-epsilon$</formula>, the result will still be a simple polygon but with edges that are so close to each other that will almost intersect. If a kernel with exact constructions is used, the offsetting algorithm can guarantee that the output contains only simple polygons. However, if inexact constructions are used the roundoff in the coordinates of the output points will cause parallel edges that <emphasis>almost</emphasis> collapse-but not so-to become really collinear or even cross each other.</para><para>Thus, it is neccessary to use a kernel with exact constructions if offset polygons must be simple, yet computing a straight skeleton using that kernel is very slow, much more than computing the offset polygons. To help with this, it is possible to construct the straight skeleton using the recommended kernel <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>, then convert the skeleton to a different kernel via the function <computeroutput><ref refid="group__PkgStraightSkeleton2Functions_1ga5db640321394c163c89e050e9c69cfae" kindref="member">convert_straight_skeleton_2()</ref></computeroutput> and input the converted skeleton to the offsetting functions.</para><para>All the offsetting functions that take polygons as input (and create the straight skeleton under the hood) apply that optimization automatically: that is, the output polygons are defined over the same kernel of the input polygons, whatever that is, yet the straight skeleton is constructed with the faster recommended kernel and converted if necessary.</para><para>Notice how some of the examples above use <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput>. In all cases, the straight skeleton is constructed using <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>. </para></sect2>
<sect2 id="index_1Straight_skeleton_2LowlevelAPI">
<title>Low level API</title>
<para>All the high level functions described above are just wrappers around the low level API described here. This low level API is richer and provides options and configurations not covered by any of those functions.</para><para>The straight skeleton construction algorithm is encapsulated in the class <computeroutput><ref refid="classCGAL_1_1Straight__skeleton__builder__2" kindref="compound">Straight_skeleton_builder_2</ref>&lt;Gt,Ss,Visitor&gt;</computeroutput> which is parameterized on a geometric traits (class <computeroutput><ref refid="classCGAL_1_1Straight__skeleton__builder__traits__2" kindref="compound">Straight_skeleton_builder_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput>) and the Straight Skeleton class (Ss).</para><para>The offset contours construction algorithm is encapsulated in the class <computeroutput><ref refid="classCGAL_1_1Polygon__offset__builder__2" kindref="compound">Polygon_offset_builder_2</ref>&lt;Ss,Gt,Container&gt;</computeroutput> which is parameterized on the Straight Skeleton class (Ss), a geometric traits (class <computeroutput><ref refid="classCGAL_1_1Polygon__offset__builder__traits__2" kindref="compound">Polygon_offset_builder_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput>) and a container type where the resulting offset polygons are generated.</para><para>To construct the straight skeleton of a polygon with holes the user must:</para><para>(1) Instantiate the straight skeleton builder.</para><para>(2) Enter one contour at a time, starting from the outer contour, via the method <computeroutput><ref refid="classCGAL_1_1Straight__skeleton__builder__2_1ac433450b3ae08169d3ea650770ca042e" kindref="member">Straight_skeleton_builder_2::enter_contour()</ref></computeroutput>. The input polygon with holes must be non-degenerate, strictly-simple and counter-clockwise oriented (see the definitions at the beginning of this chapter). Collinear edges are allowed. The insertion order of each hole is unimportant but the outer contour must be entered first.</para><para>(3) Call <computeroutput><ref refid="classCGAL_1_1Straight__skeleton__builder__2_1aeb3382ca9ec8e8b5856ccb3c74743c1b" kindref="member">Straight_skeleton_builder_2::construct_skeleton()</ref></computeroutput> once <emphasis>all</emphasis> the contours have been entered. You cannot enter another contour once the skeleton has been constructed.</para><para>To construct a set of inward offset contours the user must:</para><para>(1) Construct the straight skeleton of the source polygon with holes.</para><para>(2) Instantiate the polygon offset builder passing in the straight skeleton as a parameter.</para><para>(3) Call <computeroutput><ref refid="classCGAL_1_1Polygon__offset__builder__2_1aac7a872eb1a5c45947c04b750baf9398" kindref="member">Polygon_offset_builder_2::construct_offset_contours()</ref></computeroutput> passing the desired offset distance and an output iterator that can store a <computeroutput>boost::shared_ptr</computeroutput> of <computeroutput>Container</computeroutput> instances into a resulting sequence (typically, a back insertion iterator)</para><para>Each element in the resulting sequence is an <emphasis>offset contour</emphasis>, given by a <computeroutput>boost::shared_ptr</computeroutput> holding a dynamically allocated instance of the Container type. Such a container can be any model of the <computeroutput><ref refid="classVertexContainer__2" kindref="compound">VertexContainer_2</ref></computeroutput> concept, for example, a <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref></computeroutput>, or just a <computeroutput>std::vector</computeroutput> of 2D points.</para><para>The resulting sequence of offset contours can contain both outer and inner contours. Each offset hole (inner offset contour) would logically belong in the interior of some of the outer offset contours. However, this algorithm returns a sequence of contours in arbitrary order and there is no indication whatsoever of the parental relationship between inner and outer contours.</para><para>On the other hand, each outer contour is counter-clockwise oriented while each hole is clockwise-oriented. And since offset contours do form simple polygons with holes, it is guaranteed that no hole will be inside another hole, no outer contour will be inside any other contour, and each hole will be inside exactly 1 outer contour.</para><para>Parental relationships are <emphasis>not</emphasis> automatically reconstructed by this algorithm because this relation is not directly given by the input polygon with holes and must be done as a post processing step. The function <computeroutput><ref refid="group__PkgStraightSkeleton2Functions_1gafc364113b39f15f5369fbaa495c8f7f6" kindref="member">arrange_offset_polygons_2()</ref></computeroutput> can be used to do that efficiently.</para><para>A user can reconstruct the parental relationships as a post processing operation by testing each inner contour (which is identified by being clockwise) against each outer contour (identified as being counter-clockwise) for insideness.</para><para>This algorithm requires exact predicates but not exact constructions Therefore, the <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput> should be used.</para><para><linebreak/>
<bold>File</bold> <ref refid="Straight_skeleton_2_2Low_level_API_8cpp-example" kindref="compound">Straight_skeleton_2/Low_level_API.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;iterator&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;iomanip&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;boost/shared_ptr.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Straight_skeleton_builder_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/Polygon_offset_builder_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include&lt;CGAL/compute_outer_frame_margin.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>example<sp/>illustrates<sp/>how<sp/>to<sp/>use<sp/>the<sp/>CGAL<sp/>Straight<sp/>Skeleton<sp/>package</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>to<sp/>construct<sp/>an<sp/>offset<sp/>contour<sp/>on<sp/>the<sp/>outside<sp/>of<sp/>a<sp/>polygon</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>is<sp/>the<sp/>recommended<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/>Contour;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::shared_ptr&lt;Contour&gt;<sp/>ContourPtr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;ContourPtr&gt;<sp/><sp/><sp/><sp/>ContourSequence<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Straight__skeleton__2" kindref="compound">CGAL::Straight_skeleton_2&lt;Kernel&gt;</ref><sp/>Ss;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Ss::Halfedge_iterator<sp/>Halfedge_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Ss::Halfedge_handle<sp/><sp/><sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Ss::Vertex_handle<sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Straight__skeleton__builder__traits__2" kindref="compound">CGAL::Straight_skeleton_builder_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>SsBuilderTraits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Straight__skeleton__builder__2" kindref="compound">CGAL::Straight_skeleton_builder_2&lt;SsBuilderTraits,Ss&gt;</ref><sp/>SsBuilder;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__offset__builder__traits__2" kindref="compound">CGAL::Polygon_offset_builder_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>OffsetBuilderTraits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__offset__builder__2" kindref="compound">CGAL::Polygon_offset_builder_2&lt;Ss,OffsetBuilderTraits,Contour&gt;</ref><sp/>OffsetBuilder;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>A<sp/>start-shaped<sp/>polygon,<sp/>oriented<sp/>counter-clockwise<sp/>as<sp/>required<sp/>for<sp/>outer<sp/>contours.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>pts[]<sp/>=<sp/>{<sp/>Point_2(-1,-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>Point_2(0,-12)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>Point_2(1,-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>Point_2(12,0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>Point_2(1,1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>Point_2(0,12)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>Point_2(-1,1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>Point_2(-12,0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;<sp/>star(pts,pts+8);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>want<sp/>an<sp/>offset<sp/>contour<sp/>in<sp/>the<sp/>outside.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Since<sp/>the<sp/>package<sp/>doesn&apos;t<sp/>support<sp/>that<sp/>operation<sp/>directly,<sp/>we<sp/>use<sp/>the<sp/>following<sp/>trick:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(1)<sp/>Place<sp/>the<sp/>polygon<sp/>as<sp/>a<sp/>hole<sp/>of<sp/>a<sp/>big<sp/>outer<sp/>frame.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(2)<sp/>Construct<sp/>the<sp/>skeleton<sp/>on<sp/>the<sp/>interior<sp/>of<sp/>that<sp/>frame<sp/>(with<sp/>the<sp/>polygon<sp/>as<sp/>a<sp/>hole)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(3)<sp/>Construc<sp/>the<sp/>offset<sp/>contours</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(4)<sp/>Identify<sp/>the<sp/>offset<sp/>contour<sp/>that<sp/>corresponds<sp/>to<sp/>the<sp/>frame<sp/>and<sp/>remove<sp/>it<sp/>from<sp/>the<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>offset<sp/>=<sp/>3<sp/>;<sp/></highlight><highlight class="comment">//<sp/>The<sp/>offset<sp/>distance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>First<sp/>we<sp/>need<sp/>to<sp/>determine<sp/>the<sp/>proper<sp/>separation<sp/>between<sp/>the<sp/>polygon<sp/>and<sp/>the<sp/>frame.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>this<sp/>helper<sp/>function<sp/>provided<sp/>in<sp/>the<sp/>package.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::optional&lt;double&gt;<sp/>margin<sp/>=<sp/><ref refid="group__PkgStraightSkeleton2Functions_1ga082ba1726ab0bc292bd56ef903326fa8" kindref="member">CGAL::compute_outer_frame_margin</ref>(star.begin(),star.end(),offset);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Proceed<sp/>only<sp/>if<sp/>the<sp/>margin<sp/>was<sp/>computed<sp/>(an<sp/>extremely<sp/>sharp<sp/>corner<sp/>might<sp/>cause<sp/>overflow)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>margin<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>bbox<sp/>of<sp/>the<sp/>polygon</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Bbox__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Bbox_2</ref><sp/>bbox<sp/>=<sp/>CGAL::bbox_2(star.begin(),star.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>boundaries<sp/>of<sp/>the<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>fxmin<sp/>=<sp/>bbox.<ref refid="classCGAL_1_1Bbox__2_1a63af1afb0d6da705540fa204039053e6" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">xmin</ref>()<sp/>-<sp/>*margin<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>fxmax<sp/>=<sp/>bbox.<ref refid="classCGAL_1_1Bbox__2_1a9e48dd530dea0cc1a28b5e9bc14a64ff" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">xmax</ref>()<sp/>+<sp/>*margin<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>fymin<sp/>=<sp/>bbox.<ref refid="classCGAL_1_1Bbox__2_1a849e45ce29fc5bdd02a6a2fc898a9880" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">ymin</ref>()<sp/>-<sp/>*margin<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>fymax<sp/>=<sp/>bbox.<ref refid="classCGAL_1_1Bbox__2_1a0baeec271d6b81c384254b13e102e584" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">ymax</ref>()<sp/>+<sp/>*margin<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>the<sp/>rectangular<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>frame[4]=<sp/>{<sp/>Point_2(fxmin,fymin)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>Point_2(fxmax,fymin)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>Point_2(fxmax,fymax)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>Point_2(fxmin,fymax)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>the<sp/>skeleton<sp/>builder</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SsBuilder<sp/>ssb<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Enter<sp/>the<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssb.enter_contour(frame,frame+4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Enter<sp/>the<sp/>polygon<sp/>as<sp/>a<sp/>hole<sp/>of<sp/>the<sp/>frame<sp/>(NOTE:<sp/>as<sp/>it<sp/>is<sp/>a<sp/>hole<sp/>we<sp/>insert<sp/>it<sp/>in<sp/>the<sp/>opposite<sp/>orientation)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssb.enter_contour(star.rbegin(),star.rend());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>skeleton</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::shared_ptr&lt;Ss&gt;<sp/>ss<sp/>=<sp/>ssb.construct_skeleton();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Proceed<sp/>only<sp/>if<sp/>the<sp/>skeleton<sp/>was<sp/>correctly<sp/>constructed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>ss<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>print_straight_skeleton(*ss);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>the<sp/>container<sp/>of<sp/>offset<sp/>contours</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ContourSequence<sp/>offset_contours<sp/>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>the<sp/>offset<sp/>builder<sp/>with<sp/>the<sp/>skeleton</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>OffsetBuilder<sp/>ob(*ss);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Obtain<sp/>the<sp/>offset<sp/>contours</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ob.construct_offset_contours(offset,<sp/>std::back_inserter(offset_contours));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Locate<sp/>the<sp/>offset<sp/>contour<sp/>that<sp/>corresponds<sp/>to<sp/>the<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>That<sp/>must<sp/>be<sp/>the<sp/>outmost<sp/>offset<sp/>contour,<sp/>which<sp/>in<sp/>turn<sp/>must<sp/>be<sp/>the<sp/>one</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>with<sp/>the<sp/>largetst<sp/>unsigned<sp/>area.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ContourSequence::iterator<sp/>f<sp/>=<sp/>offset_contours.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>lLargestArea<sp/>=<sp/>0.0<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(ContourSequence::iterator<sp/>i<sp/>=<sp/>offset_contours.begin();<sp/>i<sp/>!=<sp/>offset_contours.end();<sp/>++<sp/>i<sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>lArea<sp/>=<sp/>CGAL_NTS<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1d5106cf8be16adb4c4dc8b1ec3a5a92" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">abs</ref>(<sp/>(*i)-&gt;area()<sp/>)<sp/>;<sp/></highlight><highlight class="comment">//Take<sp/>abs()<sp/>as<sp/><sp/>Polygon_2::area()<sp/>is<sp/>signed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>lArea<sp/>&gt;<sp/>lLargestArea<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f<sp/>=<sp/>i<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lLargestArea<sp/>=<sp/>lArea<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>the<sp/>offset<sp/>contour<sp/>that<sp/>corresponds<sp/>to<sp/>the<sp/>frame.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>offset_contours.erase(f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>print_polygons(offset_contours);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Straight_skeleton_2ExteriorSkeletonsandExterior">
<title>Exterior Skeletons and Exterior Offset Contours</title>
<para>This CGAL package can only construct the straight skeleton and offset contours in the <emphasis>interior</emphasis> of a polygon with holes. However, constructing exterior skeletons and exterior offsets is possible:</para><para>Say you have some polygon made of 1 outer contour C0 and 1 hole C1, and you need to obtain some exterior offset contours.</para><para>The interior region of a polygon with holes is connected while the exterior region is not: there is an unbounded region outside the outer contour, and one bounded region inside each hole. To construct an offset contour you need to construct an straight skeleton. Thus, to construct exterior offset contours for a polygon with holes, you need to construct, <emphasis>separately</emphasis>, the exterior skeleton of the outer contour and the interior skeleton of each hole.</para><para>Constructing the interior skeleton of a hole is directly supported by this CGAL package; you just need to input the hole&apos;s vertices in reversed order as if it were an outer contour.</para><para>Constructing the exterior skeleton of the outer contour is possible by means of the following trick: place the contour as a hole of a big rectangle (call it <emphasis>frame</emphasis>). If the frame is sufficiently separated from the contour, the resulting skeleton will be practically equivalent to a <emphasis>real</emphasis> exterior skeleton.</para><para>To construct exterior offset contours in the inside of each hole you just use the skeleton constructed in the interior, and, if required, revert the orientation of each resulting offset contour.</para><para>Constructing exterior offset contours in the outside of the outer contour is just a little bit more involved: Since the contour is placed as a hole of a frame, you will always obtain 2 offset contours for any given distance; one is the offseted frame and the other is the offseted contour. Thus, from the resulting offset contour sequence, you always need to discard the offsetted frame, easily identified as the offset contour with the largest area.</para><para>It is necessary to place the frame sufficiently away from the contour. If it is not, it could occur that the outward offset contour collides and merges with the inward offset frame, resulting in 1 instead of 2 offset contours.</para><para>However, the proper separation between the contour and the frame is not directly given by the offset distance at which you want the offset contour. That distance must be at least the desired offset plus the largest euclidean distance between an offset vertex and its original.</para><para>This CGAL packages provides a helper function to compute the required separation: <computeroutput><ref refid="group__PkgStraightSkeleton2Functions_1ga082ba1726ab0bc292bd56ef903326fa8" kindref="member">compute_outer_frame_margin()</ref></computeroutput></para><para>If you use this function to place the outer frame you are guaranteed to obtain an offset contour corresponding exclusively to the frame, which you can always identify as the one with the largest area and which you can simple remove from the result (to keep just the relevant outer contours).</para><para><anchor id="index_1fig__Exterior"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="exterior_skeleton.png"></image>
 <image type="latex" name="exterior_skeleton.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="exterior_offset.png"></image>
 <image type="latex" name="exterior_offset.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__Exterior" kindref="member">fig__Exterior</ref> Exterior skeleton obtained using a frame (left) and 2 sample exterior offset contours (right)  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1Straight_skeleton_2Straight">
<title>Straight Skeletons, Medial Axis and Voronoi Diagrams</title>
<para>The straight skeleton of a polygon is similar to the medial axis and the Voronoi diagram of a polygon in the way it partitions it; however, unlike the medial axis and Voronoi diagram, the bisectors are not equidistant to its defining edges but to the supporting lines of such edges. As a result, Straight Skeleton bisectors might not be located in the center of the polygon and so cannot be regarded as a proper Medial Axis in its geometrical meaning.</para><para>On the other hand, only reflex vertices (whose internal angle <formula id="3">$ &gt; \pi$</formula>) are the source of deviations of the bisectors from its center location. Therefore, for convex polygons, the straight skeleton, the medial axis and the Voronoi diagram are exactly equivalent, and, if a non-convex polygon contains only vertices of low reflexivity, the straight skeleton bisectors will be placed nearly equidistant to their defining edges, producing a straight skeleton pretty much alike a proper medial axis.</para></sect1>
<sect1 id="index_1Straight_skeleton_2Usages">
<title>Usages of the Straight Skeletons</title>
<para>The most natural usage of straight skeletons is offsetting: growing and shrinking polygons (provided by this CGAL package).</para><para>Another usage, perhaps its very first, is roof design: The straight skeleton of a polygonal roof directly gives the layout of each tent. If each skeleton edge is lifted from the plane a height equal to its offset distance, the resulting roof is &quot;correct&quot; in that water will always fall down to the contour edges (roof border) regardless of were in the roof it falls. <ref refid="citelist_1CITEREF_cgal:ld-agrm-03" kindref="member">[5]</ref> gives an algorithm for roof design based on the straight skeleton.</para><para>Just like medial axes, 2D straight skeletons can also be used for 2D shape description and matching. Essentially, all the applications of image-based skeletonization (for which there is a vast literature) are also direct applications of the straight skeleton, specially since skeleton edges are simply straight line segments.</para><para>Consider the subgraph formed only by <emphasis>inner bisectors</emphasis> (that is, only the skeleton halfedges which are not incident upon a contour vertex). Call this subgraph a <emphasis>skeleton axis</emphasis>. Each node in the skeleton axis whose degree is <formula id="6">$ &gt;=3$</formula> roots more than one skeleton tree. Each skeleton tree roughly corresponds to a region in the input topologically equivalent to a rectangle; that is, without branches. For example, a simple letter &quot;H&quot; would contain 2 higher degree nodes separating the skeleton axis in 5 trees; while the letter &quot;@&quot; would contain just 1 higher degree node separating the skeleton axis in 2 curly trees.</para><para>Since a skeleton edge is a 2D straight line, each branch in a skeleton tree is a polyline. Thus, the path-length of the tree can be directly computed. Furthermore, the polyline for a particular tree can be interpolated to obtain curve-related information.</para><para>Pruning each skeleton tree cutting off branches whose length is below some threshold; or smoothing a given branch, can be used to reconstruct the polygon without undesired details, or fit into a particular canonical shape.</para><para>Each skeleton edge in a skeleton branch is associated with 2 contour edges which are facing each other. If the polygon has a bottleneck (it almost touches itself), a search in the skeleton graph measuring the distance between each pair of contour edges will reveal the location of the bottleneck, allowing you to cut the shape in two. Likewise, if two shapes are too close to each other along some part of their boundaries (a near contact zone), a similar search in an exterior skeleton of the two shapes at once would reveal the parts of near contact, allowing you to stitch the shapes. These <emphasis>cut and stitch</emphasis> operations can be directly executed in the straight skeleton itself instead of the input polygon (because the straight skeleton contains a graph of the connected contour edges).</para></sect1>
<sect1 id="index_1Straight_skeleton_2Straight_1">
<title>Straight Skeleton of a General Figure in the Plane</title>
<para>A straight skeleton can also be defined for a general multiply-connected planar directed straight-line graph <ref refid="citelist_1CITEREF_aa-skfgpf-95" kindref="member">[1]</ref> by considering all the edges as embedded in an unbounded region. The only difference is that in this case some faces will be only partially bounded.</para><para>The current version of this CGAL package can only construct the straight skeleton in the interior of a simple polygon with holes, that is it doesn&apos;t handle general polygonal figures in the plane. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
