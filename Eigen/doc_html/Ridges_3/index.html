<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Ridges_3/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Approximation of Ridges and Umbilics on Triangulated Surface Meshes: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Approximation of Ridges and Umbilics on Triangulated Surface Meshes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Approximation_of_Ridges_and_Umbilics_on_Triangulated_Surface_Meshes"></a><a class="anchor" id="chapRidges3"></a> </p><dl class="section author"><dt>Authors</dt><dd>Marc Pouget and Frédéric Cazals  <div id="autotoc" class="toc"></div> </dd></dl>
<p><a class="anchor" id="fig__davidcrest"></a></p><div class="image">
<img src="david_crest.jpg" alt="david_crest.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__davidcrest">Figure 69.1</a> Crest ridges on the David, model provided by the Digital Michelangelo Project.  </div>  <br />

<p>This chapter describes the <span style="font-variant: small-caps;">CGAL</span> package for the approximating the ridges and umbilics of a smooth surface discretized by a triangle mesh. Given a smooth surface, a ridge is a curve along which one of the principal curvatures has an extremum along its curvature line. An umbilic is a point at which both principal curvatures are equal. Ridges define a singular curve, i.e., a self-intersecting curve, and umbilics are special points on this curve. Ridges are curves of <em>extremal</em> curvature and therefore encode important informations used in segmentation, registration, matching and surface analysis. Based on the results of the article <a class="el" href="citelist.html#CITEREF_cgal:cp-tdare-05">[2]</a>, we propose algorithms to identify and extract different parts of this singular ridge curve as well as umbilics on a surface given as a triangulated surface mesh. Differential quantities associated to the mesh vertices are assumed to be given for these algorithms; such quantities may be computed by the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgJet_fitting_3Summary">Estimation of Local Differential Properties of Point-Sampled Surfaces</a>.</p>
<p>Note that this package needs the third party library <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/installation.html#thirdpartyEigen">Eigen</a> for linear algebra operations.</p>
<h1><a class="anchor" id="Ridges_3Overview"></a>
Overview</h1>
<p>Section <a class="el" href="index.html#smooth">Ridges and Umbilics of a Smooth Surface</a> presents the basics of the theory of ridges and umbilics on smooth surfaces. Sections <a class="el" href="index.html#Ridges_3Approximating">Approximating Ridges on Triangulated Surface Meshes</a> and <a class="el" href="index.html#Ridges_3Approximating_1">Approximating Umbilics on Triangulated Surface Meshes</a> present algorithms for approximating the ridges and umbilics (of a smooth surface) from a triangle mesh. Section <a class="el" href="index.html#Ridges_3Software">Software Design</a> gives the package specifications, while example calls to functions of the package are provided in Section <a class="el" href="index.html#Ridges_3Examples">Examples</a>.</p>
<h1><a class="anchor" id="smooth"></a>
Ridges and Umbilics of a Smooth Surface</h1>
<p>For a detailed introduction to ridges and related topics, the reader may consult <a class="el" href="citelist.html#CITEREF_cgal:hgygm-ttdpf-99">[3]</a>,cgal:p-gd-01, as well as the following survey article <a class="el" href="citelist.html#CITEREF_cgal:cp-ssulc-05">[1]</a>. In the sequel, we just introduce the basic notions so as to explain our algorithms. Consider a smooth embedded surface, and denote \( k_1\) and \( k_2\) the principal curvatures, with \( k_1\geq k_2\). Umbilics are the points where \( k_1=k_2\). For any non umbilical point, the corresponding principal directions of curvature are well defined, and we denote them \( d_1\) and \( d_2\). In local coordinates, we denote \( \langle , \rangle\) the inner product induced by the ambient Euclidean space, and \( dk_1\), \( dk_2\) the gradients of the principal curvatures. Ridges, illustrated in <a class="el" href="index.html#fig__ellipsoidridges">Figure 69.2</a> for the standard ellipsoid, are defined by:</p>
<p><b>Definition.</b> <em><a class="anchor" id="defridgeextrema"></a>A non umbilical point is called </em></p><ul>
<li>
<p class="startli">a max ridge point, if the <em>extremality coefficient</em> \( b_0=\langle dk_1,d_1 \rangle\) vanishes, i.e. \( b_0=0\).</p>
<p class="endli"></p>
</li>
<li>
a min ridge point, if the <em>extremality coefficient</em> \( b_3=\langle dk_2,d_2 \rangle\) vanishes, i.e. \( b_3=0\) <span class="footnote">Notations \( b_0, b_3\) comes from Equation <a class="el" href="index.html#eqmonge">eqmonge</a> </span>. </li>
</ul>
<p></p>
<p>The previous characterization of ridges involves third-order differential properties. Using fourth-order differential quantities, a ridge point can further be qualified as <em>elliptic</em> if it corresponds to a maximum of \( k_1\) or a minimum of \( k_2\), or <em>hyperbolic</em> otherwise. Hence we end up with four types of ridges, namely: <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aad6458197d2d914616a1229703641fc26">MAX_ELLIPTIC_RIDGE</a>, <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aafff4a2edf212ef44875cd3fd82f1fc6a">MAX_HYPERBOLIC_RIDGE</a>, <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aaf28972caa9c208fa7096a992139b582c">MIN_ELLIPTIC_RIDGE</a>, <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aac4a20a4d417d135de77f1d7c6cb4cdaf">MIN_HYPERBOLIC_RIDGE</a>, which are illustrated in <a class="el" href="index.html#fig__ellipsoidridges">Figure 69.2</a>. Also of interest are the <em>crest lines</em>, a crest line being an elliptic ridge which is a maximum of \( \max(|k_1|,|k_2|)\). Crest lines form a subset of elliptic ridges, and can be seen as the visually most salient curves on a surface. Hence we provide the two additional ridge types <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aa8476643dc6a52935b0413cf080bb8ed4">MAX_CREST_RIDGE</a> and <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aa224c1b10b418e4511734720d6db26049">MIN_CREST_RIDGE</a>, which are illustrated in <a class="el" href="index.html#fig__davidcrest">Figure 69.1</a>.</p>
<p><a class="anchor" id="fig__ellipsoidridges"></a></p><div class="image">
<img src="ellipsoid_ridges.png" alt="ellipsoid_ridges.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__ellipsoidridges">Figure 69.2</a> Ridges on the ellipsoid, normals pointing outward. <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Color.html">Color</a> coding: <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aad6458197d2d914616a1229703641fc26">MAX_ELLIPTIC_RIDGE</a> are blue, <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aafff4a2edf212ef44875cd3fd82f1fc6a">MAX_HYPERBOLIC_RIDGE</a> are green, <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aaf28972caa9c208fa7096a992139b582c">MIN_ELLIPTIC_RIDGE</a> are red and <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aac4a20a4d417d135de77f1d7c6cb4cdaf">MIN_HYPERBOLIC_RIDGE</a> are yellow. The red line is also the <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aa224c1b10b418e4511734720d6db26049">MIN_CREST_RIDGE</a> and this is the only crest ridge of the ellipsoid.  </div>  <br />

<p>At any point of the surface which is not an umbilic, principal directions \( d_1, d_2\) are well defined, and these (non oriented) directions together with the normal vector \( n\) define two direct orthonormal frames. If \( v_1\) is a unit vector of direction \( d_1\) then there exists a unique unit vector \( v_2\) so that \( (v_1,v_2,n)\) is direct, that is has the same orientation as the canonical basis of the ambient \( 3d\) space (and the other possible frame is \( (-v_1,-v_2,n)\)). In the coordinate systems \( (v_1,v_2,n)\), the surface has the following canonical form, known as the Monge form :</p>
<p><a class="anchor" id="eqmonge"></a> </p><p class="formulaDsp">
\begin{eqnarray} z(x,y) = &amp; \frac{1}{2}(k_1x^2 + k_2y^2)+ \frac{1}{6}(b_0x^3+3b_1x^2y+3b_2xy^2+b_3y^3) \\ &amp; +\frac{1}{24}(c_0x^4+4c_1x^3y+6c_2x^2y^2+4c_3xy^3+c_4y^4) + h.o.t \end{eqnarray}
</p>
<p>The Taylor expansion of \( k_1\) (resp. \( k_2\)) along the max (resp. min) curvature line going through the origin and parameterized by \( x\) (resp. \( y\)) are:</p>
<p><a class="anchor" id="eqtaylor_along_line"></a> </p><p class="formulaDsp">
\[ \begin{equation} k_1(x) = k_1 + b_0x + \frac{P_1}{2(k_1-k_2)}x^2 + ... , \quad \quad \quad P_1= 3b_1^2+(k_1-k_2)(c_0-3k_1^3). \end{equation} \]
</p>
<p><a class="anchor" id="eqtaylor_along_red_line"></a> </p><p class="formulaDsp">
\[ \begin{equation} k_2(y) = k_2 + b_3y + \frac{P_2}{2(k_2-k_1)}y^2 + ... , \quad \quad \quad P_2= 3b_2^2+(k_2-k_1)(c_4-3k_2^3). \end{equation} \]
</p>
<p>Notice also that switching from one to the other of the two afore-mentioned coordinate systems reverts the sign of all the odd coefficients on the Monge form of the surface.<br />
</p>
<p><br />
</p>
<p>Hence ridge types are characterized by </p><ul>
<li>
max ridge if \( b_0=0\) </li>
<li>
<a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aad6458197d2d914616a1229703641fc26">MAX_ELLIPTIC_RIDGE</a> if \( b_0=0\) and \( P_1&lt;0\) </li>
<li>
<a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aafff4a2edf212ef44875cd3fd82f1fc6a">MAX_HYPERBOLIC_RIDGE</a> if \( b_0=0\) and \( P_1&gt;0\) </li>
<li>
min ridge if \( b_3=0\) </li>
<li>
<a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aaf28972caa9c208fa7096a992139b582c">MIN_ELLIPTIC_RIDGE</a> if \( b_3=0\) and \( P_2&lt;0\) </li>
<li>
<a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aac4a20a4d417d135de77f1d7c6cb4cdaf">MIN_HYPERBOLIC_RIDGE</a> if \( b_3=0\) and \( P_2&gt;0\) </li>
<li>
<a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aa8476643dc6a52935b0413cf080bb8ed4">MAX_CREST_RIDGE</a> if \( b_0=0\) and \( P_1&lt;0\) and \( |k_1|&gt;|k_2|\) </li>
<li>
<a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aa224c1b10b418e4511734720d6db26049">MIN_CREST_RIDGE</a> if \( b_3=0\) and \( P_2&lt;0\) and \( |k_2|&gt;|k_1|\) </li>
</ul>
<p>As illustrated in <a class="el" href="index.html#fig__index_umbilic">Figure 69.3</a> and <a class="el" href="index.html#fig__umbilics">Figure 69.4</a>, the patterns made by curvature lines around an umbilic can be characterized using the notion of an <em>index</em> associated to the principal directions - see also <a class="el" href="citelist.html#CITEREF_cgal:cp-ssulc-05">[1]</a>. As depicted in <a class="el" href="index.html#fig__index_umbilic">Figure 69.3</a>, consider a small circuit \( C\) around the umbilic, and a point \( p \in C\). Starting from an initial orientation \( u\) of a tangent vector to the curvature line through point \( p\), propagate <em>by continuity</em> this orientation around the circuit. The index is defined by the angle swept by \( u\) around this revolution, normalized by \( 2\pi\). In our example, the index is thus 1/2.</p>
<p>If the index of the principal direction field is \( 1/2\) then it is called a <a class="el" href="group__PkgRidges__3Enums.html#gga4a6962972d77b9dcc9dfd82fdb5cf822afb00126ebe97b59d3426f9bf4cc93e98">ELLIPTIC_UMBILIC</a>, if it is \( -1/2\) it is called a <a class="el" href="group__PkgRidges__3Enums.html#gga4a6962972d77b9dcc9dfd82fdb5cf822a08e952e539375e05e9b2575bb413dcd9">HYPERBOLIC_UMBILIC</a>. Otherwise the umbilic is qualified <a class="el" href="group__PkgRidges__3Enums.html#gga4a6962972d77b9dcc9dfd82fdb5cf822a34921ace95210d956a9ba2c8615933a7">NON_GENERIC_UMBILIC</a>.</p>
<p><a class="anchor" id="fig__index_umbilic"></a></p><div class="image">
<img src="index_umbilic.png" alt="index_umbilic.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__index_umbilic">Figure 69.3</a> <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classIndex.html">Index</a> \(1/2\) umbilic or elliptic umbilic.  </div>  <br />

<p><a class="anchor" id="fig__umbilics"></a></p><div class="image">
<img src="lemon.png" alt="lemon.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__umbilics">Figure 69.4</a> Elliptic and hyperbolic umbilics.  </div>  <br />

<h1><a class="anchor" id="Ridges_3Approximating"></a>
Approximating Ridges on Triangulated Surface Meshes</h1>
<p>Our method aims at reporting ridges as polygonal lines living on the mesh. It assumes differential quantities are available for each vertex of the mesh (principal curvatures and directions together with third order quantities \( b_0, b_3\) and optionally fourth order quantities \( P_1, P_2\)). These differential quantities may be computed for the smooth surface the mesh is inscribed in (analytically or using approximation methods), or may be estimated for a mesh given without reference to an underlying smooth surface. Although the ridge approximation algorithm is the same in both cases, one cannot ambition to ask for the same certificates. This distinction calls for the notion of <em>compliant</em> mesh.</p>
<p><b>Compliant meshes.</b></p>
<p>Ridges of a smooth surface are points with prescribed differential properties, and reporting them from a mesh inscribed in the surface requires delicate hypothesis on the geometry of that mesh so as to get a certified result. In this paragraph, we assume the mesh provided complies with a number of hypothesis, which guarantee the topology of the ridges reported matches that of the ridges on the smooth surface. To summarize things, a compliant mesh is a mesh dense enough so that (i) umbilics are properly isolated (ii) ridges running next to one another are also properly separated. See <a class="el" href="citelist.html#CITEREF_cgal:cp-tdare-05">[2]</a> for a detailed discussion of <em>compliant</em> meshes.<br />
</p>
<p>As 0-level set of the extremality coefficients \( b_0\) and \( b_3\), ridges are extracted by a marching triangles algorithm.<span class="footnote">A marching triangles algorithm is similar to a 2d marching cubes algorithm (or marching rectangles algorithm), except that a one-manifold is reported on a two-manifold tessellated by triangles.</span></p>
<p>As the signs of these extremality coefficients depend on the orientation of the principal directions, we expect both extremalities and vectors orienting the principal direction to be given at each point vertex of the mesh. Except in the neighborhood of umbilics, if the mesh is dense enough, a coherent orientation of principal directions at both endpoints of an edge is chosen such that the angle between the two vectors is acute. This rule, the <em>acute rule</em>, is precisely analyzed in <a class="el" href="citelist.html#CITEREF_cgal:cp-tdare-05">[2]</a>. Moreover, we only seek ridges in triangles for which one can find an orientation of its three vertices such that the three edges are coherently oriented by the acute rule. Such triangles are called <em>regular</em>. This said, two remarks are in order.</p>
<p><em> - Regular triangles and ridge segments.</em> A regular triangle has 0 or 2 edges crossed by a max (resp. min) ridge, which is tantamount to a sign change of \( b_0\) (resp. \( b_3\)) along the corresponding edges. In the latter case, we say that the triangle contains a ridge segment. Two methods are provided to compute its type, be it elliptic or hyperbolic. First, if fourth order differential quantities are provided, one can use the \( P_1\) ( \( P_2\)) values of Equations <a class="el" href="index.html#eqtaylor_along_line">eqtaylor_along_line</a> ( <a class="el" href="index.html#eqtaylor_along_red_line">eqtaylor_along_red_line</a>) for a max (min) ridge. The value of \( P_i\) for a ridge segment is defined as the mean value of the \( P_i\) values of the two crossing points on edges (while the value at a crossing point on an edge is the \( b_i\)-weighted mean value of the values at endpoints). Alternatively, if third order differential quantities only are available, one may use the geometric method developed in <a class="el" href="citelist.html#CITEREF_cgal:cp-tdare-05">[2]</a>.</p>
<p>Using the notion of ridge segment, a <code><a class="el" href="classCGAL_1_1Ridge__line.html" title="The class Ridge_line stores the description of a ridge line. ">Ridge_line</a></code> is defined as a maximal connected sequence of ridge segments of the same type and connected together. Notice that the topology of a <code><a class="el" href="classCGAL_1_1Ridge__line.html" title="The class Ridge_line stores the description of a ridge line. ">Ridge_line</a></code> is either that of an interval or a circle.</p>
<p><em> - Non-regular triangles.</em> In the neighborhood of umbilics, triangle are less likely to be regular and the detection of ridges cannot be relevant by this method. This is why we propose another method to detect umbilics independently.</p>
<p><b>Non compliant meshes: filtering ridges on <em>strength</em> and <em>sharpness</em>.</b></p>
<p>For real world applications dealing with coarse meshes, or meshes featuring degenerate regions or sharp features, or meshes conveying some amount of noise, the <em>compliance</em> hypothesis <a class="el" href="citelist.html#CITEREF_cgal:cp-tdare-05">[2]</a> cannot be met. In that case, it still makes sense to seek loci of points featuring extremality of estimated principal curvatures, but the ridges reported may require filtering. For example, if the principal curvatures are constant</p><ul>
<li>which is the case on a plane or a cylinder, then all points are ridge points. In this context, an appealing notion is that of <em>sharp</em> ridge or <em>prominent</em> ridge. Since ridges are witnessed by zero crossings of \( b_0\) and \( b_3\), one can expect erroneous detections as long as these coefficients remain small. In order to select the most prominent ridge points, we focus on points where the variation of the curvature is fast along the curvature line. One can observe that, at a ridge point, according to Equation <a class="el" href="index.html#eqtaylor_along_line">eqtaylor_along_line</a>, the second derivative of \( k_1\) along its curvature line satisfies \( k_1^{''}(0) = P_1/(k_1-k_2)\). Using this observation, one can define the <em>sharpness of a ridge</em> as the integral of the absolute value of \( P_1/(k_1-k_2)\) along the ridge. As the second derivative of the curvature is homogeneous to the inverse of the cube of a length, the sharpness is homogeneous to the inverse of the square of a length. Multiplying the sharpness by the square of the model size gives a threshold and an associated sharpness-filter which are scale independent. Another filtering is also available with the <em>strength </em> which is the integral of the curvature along the ridge line <a class="el" href="citelist.html#CITEREF_cgal:ybs-rvlmi-04">[4]</a>.</li>
</ul>
<h1><a class="anchor" id="Ridges_3Approximating_1"></a>
Approximating Umbilics on Triangulated Surface Meshes</h1>
<p><a class="anchor" id="umbilicmesh"></a> The method aims at identifying some vertices of a mesh as umbilics. It assumes principal curvatures and directions are given at each vertex on the mesh.</p>
<p><b>Algorithm.</b></p>
<p>Assume each vertex \( v\) of the mesh comes with a patch (a topological disk) around it. Checking whether vertex \( v\) is an umbilic is a two stages process, which are respectively concerned with the variation of the function \( k_1-k_2\) over the patch, and the index of the vertex computed from the boundary of the patch. More precisely, vertex \( v\) is declared to be an umbilic if the following two conditions are met: </p><ul>
<li>
the function \( k_1-k_2\) has its minimum at \( v\) amongst all the vertices of the patch; </li>
<li>
the deviation \( \delta\) of any principal direction along the patch boundary, traversed counter-clock-wise (CCW), has prescribed properties: <ul>
<li>
\( \delta \in ]\pi/2,3\pi/2[\), then the umbilic is called elliptic, </li>
<li>
\( \delta \in ]-3\pi/2,-\pi/2[\), then the umbilic is called a hyperbolic, </li>
<li>
otherwise the umbilic is called non-generic. </li>
</ul>
</li>
</ul>
<p><b>Finding patches around vertices.</b></p>
<p>Given a vertex \( v\) and a parameter \( t\), we aim at defining a collection of triangles around \( v\) so that (i) this collection defines a topological disk on the triangulation \( T\) and (ii) its size depends on \( t\). First we collect the 1-ring triangles. We define the size \( s\) of this 1-ring patch as the (Euclidean) distance from \( v\) to its farthest 1-ring vertex neighbor. We then collect recursively adjacent triangles so that the patch remains a topological disk and such that these triangles are at distance less than \( s\times t\). Parameter \( t\) is the only parameter of the algorithm.</p>
<p><b>Umbilical patches versus ridges.</b> On a generic surface, generic umbilics are traversed by one or three ridges. For compliant meshes, an umbilic can thus be connected to the ridge points located on the boundary of its patch. This functionality is not provided, and the interested reader is referred to <a class="el" href="citelist.html#CITEREF_cgal:cp-tdare-05">[2]</a> for more details.</p>
<h1><a class="anchor" id="Ridges_3Software"></a>
Software Design</h1>
<p><a class="anchor" id="soft"></a> All classes of this package are templated by the parameter <code>TriangleMesh</code>, which defines the type of the mesh to which the approximation algorithms operate.</p>
<p>The differential quantities are provided at vertices of this mesh via property maps, a concept commonly used in the Boost library. Property maps enables the user to store scalars and vectors associated to a vertex either <em>internally</em> in extended vertices or <em>externally</em> with a <code>std::map</code> combined with a <a href="https://www.boost.org/libs/property_map/doc/associative_property_map.html"><code>boost::associative_property_map</code></a>.</p>
<p>Output of ridges or umbilics are provided via output iterators.</p>
<p>Approximation of ridges and umbilics are performed by two independent classes, which we now further describe.</p>
<h2><a class="anchor" id="Ridges_3RidgeApproximation"></a>
Ridge Approximation</h2>
<p>The main class is <code><a class="el" href="classCGAL_1_1Ridge__approximation.html" title="The class Ridge_approximation computes the approximation of ridges of a triangular polyhedral surface...">Ridge_approximation</a>&lt;TriangleMesh,VertexFTMap,VertexVectorMap&gt;</code>. Its construction requires the mesh and the property maps defining the differential quantities for principal curvatures \( k_1\) and \( k_2\), the third order extremalities \( b_0\) and \( b_3\), the principal directions of curvature \( d_1\) and \( d_2\), and the fourth order quantities \( P_1\) and \( P_2\) if the tagging of ridges as elliptic or hyperbolic is to be done using the polynomials \( P_1\) and \( P_2\).</p>
<p>Three functions (provided as members and also as global functions) enable the computation of different types of ridges : </p><ul>
<li>
<code><a class="el" href="group__PkgRidges__3.html#gacbcb335296cafd49ca33420d2fea8c24" title="The function compute_max_ridges() is a shortcut to the method Ridge_approximation::compute_max_ridges...">compute_max_ridges()</a></code> (resp. <code><a class="el" href="group__PkgRidges__3.html#ga03c751ca758e75a4e00c9c60843e0eb5" title="The function compute_min_ridges() is a shortcut to the method Ridge_approximation::compute_min_ridges...">compute_min_ridges()</a></code>) outputs ridges of types <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aad6458197d2d914616a1229703641fc26">MAX_ELLIPTIC_RIDGE</a> and <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aafff4a2edf212ef44875cd3fd82f1fc6a">MAX_HYPERBOLIC_RIDGE</a> (resp. <code>MIN_ELLIPTIC_RIDGE</code> and <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aac4a20a4d417d135de77f1d7c6cb4cdaf">MIN_HYPERBOLIC_RIDGE</a>). </li>
<li>
<code><a class="el" href="group__PkgRidges__3.html#ga160ff11edf5b6fd969f94461703d4e35" title="The function compute_crest_ridges() is a shortcut to the method Ridge_approximation::compute_crest_ri...">compute_crest_ridges()</a></code> outputs ridges of types <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aa8476643dc6a52935b0413cf080bb8ed4">MAX_CREST_RIDGE</a> and <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aa224c1b10b418e4511734720d6db26049">MIN_CREST_RIDGE</a>. </li>
</ul>
<p>These functions allows the user to specify how the elliptic/hyperbolic tagging is carried out. Notice the rationale for the choice of these three functions is simple: each computation needs a single pass over the triangles of the mesh. This should be clear for the min and max ridges. For crests, just notice max and min crests cannot intersect over a triangle.<br />
</p>
<p><br />
</p>
<p>The ridge lines are stored in <code><a class="el" href="classCGAL_1_1Ridge__line.html" title="The class Ridge_line stores the description of a ridge line. ">Ridge_line</a></code> objects and output through an iterator. Each ridge line is represented as a list of halfedges of the mesh it crosses with a scalar defining the barycentric coordinate of the crossing point with respect to the half-egde endpoints. Each ridge line comes with its type <code>Ridge_type</code>, its strength and sharpness.</p>
<p>If one chooses to use only third order quantities, the quantities \( P_i\) do not have to be defined. Then the sharpness will not be defined.</p>
<h2><a class="anchor" id="Ridges_3UmbilicApproximation"></a>
Umbilic Approximation</h2>
<p>The main class is <code><a class="el" href="classCGAL_1_1Umbilic__approximation.html" title="The class Umbilic_approximation computes the approximation of umbilics on a triangular polyhedral sur...">Umbilic_approximation</a>&lt;TriangleMesh,VertexFTMap,VertexVectorMap&gt;</code>. Its construction requires the mesh and the property maps defining the differential quantities for principal curvatures \( k_1\) and \( k_2\), and the principal directions of curvature \( d_1\) and \( d_2\). The member function <code>compute()</code> (or the global function <code><a class="el" href="group__PkgRidges__3.html#gaec8861e49a5cddc02ac9723f8f2b88ba" title="The function compute_umbilics() is a shortcut to the method Umbilic_approximation::compute(). ">compute_umbilics()</a></code>) has a parameter to define the size of the neighborhood of the umbilic.</p>
<p>Umbilics are stored in <code><a class="el" href="classCGAL_1_1Umbilic.html" title="The class Umbilic stores the description of an umbilic. ">Umbilic</a></code> objects, they come with their type : <a class="el" href="group__PkgRidges__3Enums.html#gga4a6962972d77b9dcc9dfd82fdb5cf822afb00126ebe97b59d3426f9bf4cc93e98">ELLIPTIC_UMBILIC</a>, <a class="el" href="group__PkgRidges__3Enums.html#gga4a6962972d77b9dcc9dfd82fdb5cf822a08e952e539375e05e9b2575bb413dcd9">HYPERBOLIC_UMBILIC</a> or <a class="el" href="group__PkgRidges__3Enums.html#gga4a6962972d77b9dcc9dfd82fdb5cf822a34921ace95210d956a9ba2c8615933a7">NON_GENERIC_UMBILIC</a>; the vertex of the mesh they are associated to and the list of half-edges representing the contour of the neighborhood.</p>
<h1><a class="anchor" id="Ridges_3Examples"></a>
Examples</h1>
<h2><a class="anchor" id="Ridges_3Exampleprogram"></a>
Example Program</h2>
<p>The following program computes ridges and umbilics from an off file.<span class="footnote">Model data may be downloaded via <a href="ftp://ftp.mpi-sb.mpg.de/pub/outgoing/CGAL/Ridges_3_datafiles.tgz">ftp://ftp.mpi-sb.mpg.de/pub/outgoing/CGAL/Ridges_3_datafiles.tgz</a> . The mechanical part model has been provided courtesy of Dassault System to produce <a class="el" href="index.html#fig__figmechanical_crest_filteredintro">Figure 69.6</a>, due to copyright issues the available model is not the same, it is provided by the AIM@SHAPE Shape Repository.</span> It uses the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgJet_fitting_3Summary">Estimation of Local Differential Properties of Point-Sampled Surfaces</a> to estimate the differential quantities. The default output file gives rough data for visualization purpose, a verbose output file may also be asked for. Parameters are </p><ul>
<li>
\( d\), the degree of the jet for the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Jet_fitting_3.tag:../Jet_fitting_3/" href="../Jet_fitting_3/classCGAL_1_1Monge__via__jet__fitting.html">Monge_via_jet_fitting</a></code> class, \( d\) must be greater or equal to 3 which is the default value; </li>
<li>
\( m\), the degree of the Monge representation for the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Jet_fitting_3.tag:../Jet_fitting_3/" href="../Jet_fitting_3/classCGAL_1_1Monge__via__jet__fitting.html">Monge_via_jet_fitting</a></code> class, \( m\) must be 3 (the default value) or 4 and smaller than \( d\); </li>
<li>
\( a\), the number of rings of neighbors collected for the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Jet_fitting_3.tag:../Jet_fitting_3/" href="../Jet_fitting_3/classCGAL_1_1Monge__via__jet__fitting.html">Monge_via_jet_fitting</a></code> class, in addition the number of vertices collected must be greater than \( Nd:=(d+1)(d+2)/2\) to make the approximation possible. \( a\) may be an integer greater than 1, the value 0 (which is the default) means that the minimum number of rings is collected to make the approximation possible. (Alternatively option \( p\) allows the specification of a constant number of neighbors); </li>
<li>
\( t\), the <code>Ridge_order</code> for the distinction between elliptic and hyperbolic ridges, \( t\) is 3 (default) or 4; </li>
<li>
\( u\), the parameter for umbilic patch size, \( u \geq 1\) (default is 1). </li>
</ul>
<div class="fragment"><div class="line"><span class="comment">//this is an enriched Polyhedron with facets' normal</span></div><div class="line"><span class="preprocessor">#include "PolyhedralSurf.h"</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Ridges.h&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;CGAL/Umbilics.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> PolyhedralSurf::Traits <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;PolyhedralSurf&gt;::vertex_descriptor  vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;PolyhedralSurf&gt;::vertex_iterator vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;PolyhedralSurf&gt;::face_descriptor face_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor, FT&gt; VertexFT_map;</div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt; VertexFT_map &gt; VertexFT_property_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor, Vector_3&gt; VertexVector_map;</div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt; VertexVector_map &gt; VertexVector_property_map;</div><div class="line"></div><div class="line"><span class="comment">//RIDGES</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Ridge__line.html">CGAL::Ridge_line&lt;PolyhedralSurf&gt;</a> Ridge_line;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Ridge__approximation.html">CGAL::Ridge_approximation</a> &lt;PolyhedralSurf,</div><div class="line">                                   VertexFT_property_map,</div><div class="line">                                   VertexVector_property_map &gt; Ridge_approximation;</div><div class="line"><span class="comment">//UMBILICS</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Umbilic.html">CGAL::Umbilic&lt;PolyhedralSurf&gt;</a> Umbilic;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Umbilic__approximation.html">CGAL::Umbilic_approximation</a> &lt; PolyhedralSurf,</div><div class="line">                                      VertexFT_property_map, </div><div class="line">                                      VertexVector_property_map &gt; Umbilic_approximation;</div><div class="line"></div><div class="line"><span class="comment">//create property maps</span></div><div class="line">VertexFT_map vertex_k1_map, vertex_k2_map, </div><div class="line">  vertex_b0_map, vertex_b3_map, </div><div class="line">  vertex_P1_map, vertex_P2_map;</div><div class="line">  VertexVector_map vertex_d1_map, vertex_d2_map;</div><div class="line"></div><div class="line">VertexFT_property_map vertex_k1_pm(vertex_k1_map), vertex_k2_pm(vertex_k2_map), </div><div class="line">  vertex_b0_pm(vertex_b0_map), vertex_b3_pm(vertex_b3_map), </div><div class="line">  vertex_P1_pm(vertex_P1_map), vertex_P2_pm(vertex_P2_map);</div><div class="line">  VertexVector_property_map vertex_d1_pm(vertex_d1_map), vertex_d2_pm(vertex_d2_map);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{ </div><div class="line">  <span class="comment">//compute differential quantities with the jet fitting package</span></div><div class="line">  ...</div><div class="line">  <span class="comment">//initialize the property maps</span></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">//Ridges</span></div><div class="line">  <span class="comment">//--------------------------------------------------------------------------</span></div><div class="line">  Ridge_approximation ridge_approximation(P, </div><div class="line">                                          vertex_k1_pm, vertex_k2_pm,</div><div class="line">                                          vertex_b0_pm, vertex_b3_pm,</div><div class="line">                                          vertex_P1_pm, vertex_P2_pm,</div><div class="line">                                          vertex_d1_pm, vertex_d2_pm);</div><div class="line">  std::vector&lt;Ridge_line*&gt; ridge_lines;</div><div class="line">  std::back_insert_iterator&lt;std::vector&lt;Ridge_line*&gt; &gt; ii(ridge_lines);</div><div class="line"></div><div class="line">  <span class="comment">//Find MAX_RIDGE, MIN_RIDGE, CREST or all ridges</span></div><div class="line">  ridge_approximation.compute_max_ridges(ii, tag_order); </div><div class="line">  ridge_approximation.compute_min_ridges(ii, tag_order); </div><div class="line">  ridge_approximation.compute_crest_ridges(ii, tag_order); </div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// UMBILICS</span></div><div class="line">  <span class="comment">//--------------------------------------------------------------------------</span></div><div class="line">  Umbilic_approximation umbilic_approximation(P, </div><div class="line">                                              vertex_k1_pm, vertex_k2_pm,</div><div class="line">                                              vertex_d1_pm, vertex_d2_pm);</div><div class="line">  std::vector&lt;Umbilic*&gt; umbilics;</div><div class="line">  std::back_insert_iterator&lt;std::vector&lt;Umbilic*&gt; &gt; umb_it(umbilics);</div><div class="line">  umbilic_approximation.compute(umb_it, umb_size);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Ridges_3ExampleRidgesandUmbilicsonanEllipsoid"></a>
Example: Ridges and Umbilics on an Ellipsoid</h2>
<p>For <a class="el" href="index.html#fig__ellipsoidridgesexample">Figure 69.5</a>, the data have been computed as follows:</p>
<div class="fragment"><div class="line">./Compute_Ridges_Umbilics -f data/ellipsoid_u_0.02.off -d 4 -m 4 -a 3 -t 3</div></div><!-- fragment --><p>In addition, the four elliptic umbilics are detected, the standard output being</p>
<div class="fragment"><div class="line">nb of umbilics 4</div><div class="line">Umbilic at location (-0.80899 0.00426003 0.293896) of type elliptic</div><div class="line">Umbilic at location (-0.811197 0.0122098 -0.292259) of type elliptic</div><div class="line">Umbilic at location (0.808372 -0.00551307 -0.29431) of type elliptic</div><div class="line">Umbilic at location (0.81413 0.0018689 0.290339) of type elliptic</div></div><!-- fragment --><p><a class="anchor" id="fig__ellipsoidridgesexample"></a></p><div class="image">
<img src="ellipsoid_ridges.png" alt="ellipsoid_ridges.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__ellipsoidridgesexample">Figure 69.5</a> Ridges on the ellipsoid, normals pointing outward. <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Color.html">Color</a> coding : <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aad6458197d2d914616a1229703641fc26">MAX_ELLIPTIC_RIDGE</a> are blue, <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aafff4a2edf212ef44875cd3fd82f1fc6a">MAX_HYPERBOLIC_RIDGE</a> are green, <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aaf28972caa9c208fa7096a992139b582c">MIN_ELLIPTIC_RIDGE</a> are red and <a class="el" href="group__PkgRidges__3Enums.html#gga52a2c136a49dc8f32e146aa8204cb65aac4a20a4d417d135de77f1d7c6cb4cdaf">MIN_HYPERBOLIC_RIDGE</a> are yellow.  </div>  <br />

<h2><a class="anchor" id="Ridges_3ExampleFilteringofCrestRidgesona"></a>
Example: Filtering of Crest Ridges on a Mechanical Part</h2>
<p><a class="el" href="index.html#fig__figmechanical_crest_filteredintro">Figure 69.6</a> illustrates the filtering of crest ridges on a mechanical model, and has been computed as follows:</p>
<div class="fragment"><div class="line">./Compute_Ridges_Umbilics -f data/mecanic.off -d 4 -m 4 -a 4 -t 4</div></div><!-- fragment --><p><a class="anchor" id="fig__figmechanical_crest_filteredintro"></a></p><div class="image">
<img src="mecanic-sub1_crest-jpg.png" alt="mecanic-sub1_crest-jpg.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figmechanical_crest_filteredintro">Figure 69.6</a> Mechanical part (37k pts). Left: All crest lines. Middle: crests filtered with the strength threshold 1. Right: crests filtered with the sharpness threshold 100 000. Notice that any point on a flat or cylindrical part lies on two ridges, so that the noise observed on the first two figures is unavoidable. It is however easily filtered out with the sharpness as can be seen on the right figure.  </div>  <br />
 
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:54 for CGAL 4.13 - Approximation of Ridges and Umbilics on Triangulated Surface Meshes by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
