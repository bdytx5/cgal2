<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Box_intersection_d/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Intersecting Sequences of dD Iso-oriented Boxes: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Intersecting Sequences of dD Iso-oriented Boxes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Intersecting_Sequences_of_dD_Iso-oriented_Boxes"></a><a class="anchor" id="chapterBoxIntersection"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Lutz Kettner, Andreas Meyer, and Afra Zomorodian</dd></dl>
<h1><a class="anchor" id="Box_intersection_dIntroduction"></a>
Introduction</h1>
<p>Simple questions on geometric primitives, such as intersection and distance computations, can themselves become quite expensive if the primitives are not so simple anymore, for example, three-dimensional triangles and facets of polyhedral surfaces. Thus algorithms operating on these primitives tend to be slow in practice. A common (heuristic) optimization approximates the geometric primitives with their axis-aligned bounding boxes, runs a suitable modification of the algorithm on the boxes, and whenever a pair of boxes has an interesting interaction <span class="footnote">Boxes represent volumes or point-sets. So, <em>intersection</em> means intersection of the point-set enclosed by the box and not only intersection of the boundary, of course.</span>, only then the exact answer is computed on the complicated geometric primitives contained in the boxes.</p>
<div class="image">
<img src="box_inters.png" alt="box_inters.png" />
</div>
 <p>We provide an efficient algorithm <a class="el" href="citelist.html#CITEREF_cgal:ze-fsbi-02">[2]</a> for finding all intersecting pairs for large numbers of iso-oriented boxes, i.e., typically these will be such bounding boxes of more complicated geometries. One immediate application of this algorithm is the detection of all intersections (and self-intersections) for polyhedral surfaces, i.e., applying the algorithm on a large set of triangles in space, we give an example program later in this chapter. Not so obvious applications are proximity queries and distance computations among such surfaces, see Section <a class="el" href="index.html#secbox_inters_example_proximity">Example for Point Proximity Search with a Custom Traits Class</a> for an example and <a class="el" href="citelist.html#CITEREF_cgal:ze-fsbi-02">[2]</a> for more details.</p>
<h1><a class="anchor" id="secboxintersdef"></a>
Definition</h1>
<p>A \( d\)-dimensional iso-oriented box is defined as the Cartesian product of \( d\) intervals. We call the box <em>half-open</em> if the \( d\) intervals \( \{ [lo_i,hi_i) \,|\, 0 \leq i &lt; d\}\) are half-open intervals, and we call the box <em>closed</em> if the \( d\) intervals \( \{ [lo_i,hi_i] \,|\, 0 \leq i &lt; d\}\) are closed intervals. Note that closed boxes support zero-width boxes and they can intersect at their boundaries, while non-empty half-open boxes always have a positive volume and they only intersect iff their interiors overlap. The distinction between closed and half-open boxes does not require a different representation of boxes, just a different interpretation when comparing boxes, which is selected with the two possible values for the <code>topology</code> parameter:</p>
<ul>
<li>
<code><a class="el" href="namespaceCGAL_1_1Box__intersection__d.html#ac1b7703e33d0fe5d9d484493189c9cd8ae829505cc850e61a5190ade8ad6098b5">Box_intersection_d::HALF_OPEN</a></code> and </li>
<li>
<code><a class="el" href="namespaceCGAL_1_1Box__intersection__d.html#ac1b7703e33d0fe5d9d484493189c9cd8af287bd8f3714b65e743d5ec571e89b82">Box_intersection_d::CLOSED</a></code>. </li>
</ul>
<p>The number type of the interval boundaries must be one of the built-in types <code>int</code>, <code>unsigned int</code>, <code>double</code> or <code>float</code>.</p>
<p>In addition, a box has a unique <code>id</code>-number. It is used to order boxes consistently in each dimension even if boxes have identical coordinates. In consequence, the algorithm guarantees that a pair of intersecting boxes is reported only once. Note that boxes with equal <code>id</code>-number are not reported since they obviously intersect trivially.</p>
<p>The box intersection algorithm comes in two flavors: One algorithm works on a single sequence of boxes and computes all pairwise intersections, which is called the <em>complete</em> case, and used, for example, in the self-intersection test. The other algorithm works on two sequences of boxes and computes the pairwise intersections between boxes from the first sequence with boxes from the second sequence, which is called the <em>bipartite</em> case. For each pairwise intersection found a callback function is called with two arguments; the first argument is a box from the first sequence and the second argument a box from the second sequence. In the complete case, the second argument is a box from an internal copy of the first sequence.</p>
<h1><a class="anchor" id="Box_intersection_dSoftware"></a>
Software Design</h1>
<p>The box intersection algorithm is implemented as a family of generic functions; the functions for the complete case accept one iterator range, and the functions for the bipartite case accept two iterator ranges. The callback function for reporting the intersecting pairs is provided as a template parameter of the <code>BinaryFunction</code> concept. The two principle function calls utilizing all default arguments look as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/box_intersection_d.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomAccessIterator, <span class="keyword">class</span> Callback &gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgBoxIntersectionD__box__intersection__d.html#ga5526579aad16bc9c3ed830dd8fc58f6a">box_intersection_d</a>(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a> begin, </div><div class="line">                        <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a> end,</div><div class="line">                        Callback callback);</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class </span>RandomAccessIterator1, </div><div class="line">          <span class="keyword">class </span>RandomAccessIterator2, </div><div class="line">          <span class="keyword">class </span>Callback &gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgBoxIntersectionD__box__intersection__d.html#ga5526579aad16bc9c3ed830dd8fc58f6a">box_intersection_d</a>(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,</div><div class="line">                        RandomAccessIterator2 begin2, RandomAccessIterator2 end2,</div><div class="line">                        Callback callback);</div></div><!-- fragment --><p>Additional parameters to the functions calls are a <em>cutoff</em> value to adjust performance trade-offs, and a <em>topology</em> parameter selecting between topologically closed boxes (the default) and topologically half-open boxes.</p>
<p>The algorithm reorders the boxes in the course of the algorithm. Now, depending on the size of a box it can be faster to copy the boxes, or to work with pointers to boxes and copy only pointers. We offer automatic support for both options. To simplify the description, let us call the <code>value_type</code> of the iterator ranges <em>box handle</em>. The <em>box handle</em> can either be our box type itself or a pointer (or const pointer) to the box type; these choices represent both options from above.</p>
<p>In general, the algorithms treat the box type as opaque type and just assume that they are models of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classAssignable.html">Assignable</a></code> concept, so that the algorithms can modify the input sequences and reorder the boxes. The access to the box dimension and box coordinates is mediated with a traits class of the <code><a class="el" href="classBoxIntersectionTraits__d.html" title="The BoxIntersectionTraits_d concept is used for the intersection algorithms for sequences of iso-orie...">BoxIntersectionTraits_d</a></code> concept. A default traits class is provided that assumes that the box type is a model of the <code><a class="el" href="classBoxIntersectionBox__d.html" title="The BoxIntersectionBox_d concept is used in the context of the intersection algorithms for sequences ...">BoxIntersectionBox_d</a></code> concept and that the box handle, i.e., the iterators value type, is identical to the box type or a pointer to the box type (see the previous paragraph for the value versus pointer nature of the box handle).</p>
<p>Two implementations of iso-oriented boxes are provided; <code><a class="el" href="classCGAL_1_1Box__intersection__d_1_1Box__d.html" title="Box_d is a generic iso-oriented bounding box in dimension . ">Box_intersection_d::Box_d</a></code> as a plain box, and <code><a class="el" href="classCGAL_1_1Box__intersection__d_1_1Box__with__handle__d.html" title="Box_with_handle_d is a generic iso-oriented bounding box in dimension  that stores additionally a han...">Box_intersection_d::Box_with_handle_d</a></code> as a box plus a handle that can be used to point to the full geometry that is approximated by the box. Both implementations have template parameters for the number type used for the interval bounds, for the fixed dimension of the box, and for a policy class <a class="el" href="citelist.html#CITEREF_cgal:a-mcdgp-01">[1]</a> selecting among several solutions for providing the <code>id</code>-number.</p>
<p>The function signatures for the bipartite case look as follows. The signatures for the complete case with the <code><a class="el" href="group__PkgBoxIntersectionD__box__self__intersection__d.html#ga3eed2bdb2a9e49a3fac1bca900087ec7" title="Invocation of box intersection with default box traits Box_intersection_d::Box_traits_d&lt;Box_handle&gt;, where Box_handle corresponds to the iterator value type of RandomAccessIterator. ">box_self_intersection_d()</a></code> function look the same except for the single iterator range.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include CGAL/box_intersection_d.h</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class </span>RandomAccessIterator1, </div><div class="line">          <span class="keyword">class </span>RandomAccessIterator2, </div><div class="line">          <span class="keyword">class </span>Callback &gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgBoxIntersectionD__box__intersection__d.html#ga5526579aad16bc9c3ed830dd8fc58f6a">box_intersection_d</a>(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,</div><div class="line">                        RandomAccessIterator2 begin2, RandomAccessIterator2 end2,</div><div class="line">                        Callback callback, std::ptrdiff_t cutoff = 10,</div><div class="line">                        <a class="code" href="namespaceCGAL_1_1Box__intersection__d.html#ac1b7703e33d0fe5d9d484493189c9cd8">Box_intersection_d::Topology</a> topology = <a class="code" href="namespaceCGAL_1_1Box__intersection__d.html#ac1b7703e33d0fe5d9d484493189c9cd8af287bd8f3714b65e743d5ec571e89b82">Box_intersection_d::CLOSED</a>,</div><div class="line">                        <a class="code" href="namespaceCGAL_1_1Box__intersection__d.html#a7539d6db67bbedc4e4dc9ffe53d13d42">Box_intersection_d::Setting</a> setting = <a class="code" href="namespaceCGAL_1_1Box__intersection__d.html#a7539d6db67bbedc4e4dc9ffe53d13d42a92e93ad5ad25555be14763a2c2799395">Box_intersection_d::BIPARTITE</a>);</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class </span>RandomAccessIterator1,</div><div class="line">          <span class="keyword">class </span>RandomAccessIterator2,</div><div class="line">          <span class="keyword">class </span>Callback, <span class="keyword">class </span>BoxTraits &gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgBoxIntersectionD__box__intersection__d.html#ga5526579aad16bc9c3ed830dd8fc58f6a">box_intersection_d</a>(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,</div><div class="line">                        RandomAccessIterator2 begin2, RandomAccessIterator2 end2,</div><div class="line">                        Callback callback, BoxTraits box_traits,</div><div class="line">                        std::ptrdiff cutoff = 10,</div><div class="line">                        <a class="code" href="namespaceCGAL_1_1Box__intersection__d.html#ac1b7703e33d0fe5d9d484493189c9cd8">Box_intersection_d::Topology</a> topology = <a class="code" href="namespaceCGAL_1_1Box__intersection__d.html#ac1b7703e33d0fe5d9d484493189c9cd8af287bd8f3714b65e743d5ec571e89b82">Box_intersection_d::CLOSED</a>,</div><div class="line">                        <a class="code" href="namespaceCGAL_1_1Box__intersection__d.html#a7539d6db67bbedc4e4dc9ffe53d13d42">Box_intersection_d::Setting</a> setting = <a class="code" href="namespaceCGAL_1_1Box__intersection__d.html#a7539d6db67bbedc4e4dc9ffe53d13d42a92e93ad5ad25555be14763a2c2799395">Box_intersection_d::BIPARTITE</a>);</div></div><!-- fragment --><h1><a class="anchor" id="secboxintersectminimal"></a>
Minimal Example for Intersecting Boxes</h1>
<p>The box implementation provided with <code><a class="el" href="classCGAL_1_1Box__intersection__d_1_1Box__d.html" title="Box_d is a generic iso-oriented bounding box in dimension . ">Box_intersection_d::Box_d</a>&lt;double,2&gt;</code> has a dedicated constructor for the <span style="font-variant: small-caps;">CGAL</span> bounding box type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__2.html">Bbox_2</a></code> (similar for dimension 3). We use this in our minimal example to create easily nine two-dimensional <code>boxes</code> in a grid layout of \( 3 \times 3\) boxes. Additionally we pick the center box and the box in the upper-right corner as our second box sequence <code>query</code>.</p>
<p>The default policy of the box type implements the <code>id</code>-number with an explicit counter in the boxes, which is the default choice since it always works, but it costs space that could potentially be avoided, see the example in the next section. We use the <code>id</code>-number in our callback function to report the result of the intersection algorithm. The result will be that the first <code>query</code> box intersects all nine <code>boxes</code> and the second <code>query</code> box intersects the four boxes in the upper-right quadrant. See Section <a class="el" href="index.html#secboxintersparams">Example Using the Topology and the Cutoff Parameters</a> for the change of the <code>topology</code> parameter and its effect.</p>
<p><br />
<b>File</b> <a class="el" href="Box_intersection_d_2minimal_8cpp-example.html">Box_intersection_d/minimal.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/box_intersection_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Bbox_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Box__intersection__d_1_1Box__d.html">CGAL::Box_intersection_d::Box_d&lt;double,2&gt;</a> Box;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__2.html">CGAL::Bbox_2</a>                              Bbox;</div><div class="line">                                                     <span class="comment">// 9 boxes of a grid</span></div><div class="line">Box boxes[9] = { Bbox( 0,0,1,1), Bbox( 1,0,2,1), Bbox( 2,0,3,1), <span class="comment">// low</span></div><div class="line">                 Bbox( 0,1,1,2), Bbox( 1,1,2,2), Bbox( 2,1,3,2), <span class="comment">// middle</span></div><div class="line">                 Bbox( 0,2,1,3), Bbox( 1,2,2,3), Bbox( 2,2,3,3)};<span class="comment">// upper</span></div><div class="line"><span class="comment">// 2 selected boxes as query; center and upper right</span></div><div class="line">Box query[2] = { Bbox( 1,1,2,2), Bbox( 2,2,3,3)};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> callback( <span class="keyword">const</span> Box&amp; a, <span class="keyword">const</span> Box&amp; b ) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"box "</span> &lt;&lt; a.id() &lt;&lt; <span class="stringliteral">" intersects box "</span> &lt;&lt; b.id() &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__PkgBoxIntersectionD__box__intersection__d.html#ga5526579aad16bc9c3ed830dd8fc58f6a">CGAL::box_intersection_d</a>( boxes, boxes+9, query, query+2, callback);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Box_intersection_dExample_1"></a>
Example for Finding Intersecting 3D Triangles</h1>
<p>The conventional application of the axis-aligned box intersection algorithm will start from complex geometry, here 3D triangles, approximate them with their bounding box, compute the intersecting pairs of boxes, and check only for those if the original triangles intersect as well.</p>
<p>We start in the <code>main</code> function and create ten triangles with endpoints chosen randomly in a cube \( [-1,+1)^3\). We store the triangles in a vector called <code>triangles</code>.</p>
<p>Next we create a vector for the bounding boxes of the triangles called <code>boxes</code>. For the boxes we choose the type <code>Box_with_handle_d&lt;double,3,<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classIterator.html">Iterator</a>&gt;</code> that works nicely together with the <span style="font-variant: small-caps;">CGAL</span> bounding boxes of type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">Bbox_3</a></code>. In addition, each box stores the iterator to the corresponding triangle.</p>
<p>The default policy of this box type uses for the <code>id</code>-number the address of the value of the iterator, i.e., the address of the triangle. This is a good choice that works correctly iff the boxes have unique iterators, i.e., there is a one-to-one mapping between boxes and approximated geometry, which is the case here. It saves us the extra space that was needed for the explicit <code>id</code>-number in the previous example.</p>
<p>We run the self intersection algorithm with the <code>report_inters</code> function as callback. This callback reports the intersecting boxes. It uses the <code>handle</code> and the global <code>triangles</code> vector to calculate the triangle numbers. Then it checks the triangles themselves for intersection and reports if not only the boxes but also the triangles intersect. We take some precautions before the intersection test in order to avoid problems, although unlikely, with degenerate triangles that we might have created with the random process.</p>
<p>This example can be easily extended to test polyhedral surfaces of the <code>Polyhedron_3</code> class for (self-) intersections. The main difference are the numerous cases of incidences between triangles in the polyhedral surface that should not be reported as intersections, see the <code>examples/Polyhedron/polyhedron_self_intersection.cpp</code> example program in the <span style="font-variant: small-caps;">CGAL</span> distribution.</p>
<p><br />
<b>File</b> <a class="el" href="Box_intersection_d_2triangle_self_intersect_8cpp-example.html">Box_intersection_d/triangle_self_intersect.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/box_intersection_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                       Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Triangle__3.html">Kernel::Triangle_3</a>                                    Triangle_3;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Triangle_3&gt;                               Triangles;</div><div class="line"><span class="keyword">typedef</span> Triangles::iterator                                   <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classIterator.html">Iterator</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Box__intersection__d_1_1Box__with__handle__d.html">CGAL::Box_intersection_d::Box_with_handle_d&lt;double,3,Iterator&gt;</a> Box;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Report {</div><div class="line">  Triangles* triangles;</div><div class="line"></div><div class="line">  Report(Triangles&amp; triangles)</div><div class="line">    : triangles(&amp;triangles)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="comment">// callback functor that reports all truly intersecting triangles</span></div><div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> Box&amp; a, <span class="keyword">const</span> Box&amp; b)<span class="keyword"> const </span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Box "</span> &lt;&lt; (a.handle() - triangles-&gt;begin()) &lt;&lt; <span class="stringliteral">" and "</span></div><div class="line">              &lt;&lt; (b.handle() - triangles-&gt;begin()) &lt;&lt; <span class="stringliteral">" intersect"</span>;</div><div class="line">    <span class="keywordflow">if</span> ( ! a.handle()-&gt;is_degenerate() &amp;&amp; ! b.handle()-&gt;is_degenerate()</div><div class="line">         &amp;&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__do__intersect__linear__grp.html#ga9514a218a097ac392d21775368d3dd0d">CGAL::do_intersect</a>( *(a.handle()), *(b.handle()))) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">", and the triangles intersect also"</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">'.'</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<span class="stringliteral">"data/triangles.xyz"</span>);</div><div class="line">  Triangles triangles;</div><div class="line">  Triangle_3 t;</div><div class="line">  <span class="keywordflow">while</span>(in &gt;&gt; t){</div><div class="line">    triangles.push_back(t);</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="comment">// Create the corresponding vector of bounding boxes</span></div><div class="line">  std::vector&lt;Box&gt; boxes;</div><div class="line">  <span class="keywordflow">for</span> ( Iterator i = triangles.begin(); i != triangles.end(); ++i)</div><div class="line">    boxes.push_back( Box( i-&gt;bbox(), i));</div><div class="line">  </div><div class="line">  <span class="comment">// Run the self intersection algorithm with all defaults</span></div><div class="line">  <a class="code" href="group__PkgBoxIntersectionD__box__self__intersection__d.html#ga3eed2bdb2a9e49a3fac1bca900087ec7">CGAL::box_self_intersection_d</a>( boxes.begin(), boxes.end(), Report(triangles));</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Box_intersection_dExample_2"></a>
Example for Using Pointers to Boxes</h1>
<p>We modify the previous example, finding intersecting 3D triangles, and add an additional vector <code>ptr</code> that stores pointers to the bounding boxes, so that the intersection algorithm will work on a sequence of pointers and not on a sequence of boxes. The change just affects the preparation of the additional vector and the call of the box intersection function. The box intersection function (actually its default traits class) detects automatically that the value type of the iterators is a pointer type and not a class type.</p>
<div class="fragment"><div class="line"><span class="comment">// Create the corresponding vector of pointers to bounding boxes</span></div><div class="line">std::vector&lt;Box *&gt; ptr;</div><div class="line"><span class="keywordflow">for</span> ( std::vector&lt;Box&gt;::iterator i = boxes.begin(); i != boxes.end(); ++i)</div><div class="line">ptr.push_back( &amp;*i);</div><div class="line"></div><div class="line"><span class="comment">// Run the self intersection algorithm with all defaults on the </span></div><div class="line"><span class="comment">// indirect pointers to bounding boxes. Avoids copying the boxes.</span></div><div class="line"><a class="code" href="group__PkgBoxIntersectionD__box__self__intersection__d.html#ga3eed2bdb2a9e49a3fac1bca900087ec7">CGAL::box_self_intersection_d</a>( ptr.begin(), ptr.end(), report_inters);</div></div><!-- fragment --><p>In addition, the callback function <code>report_inters()</code> needs to be changed to work with pointers to boxes. The full example program looks as follows:</p>
<p><br />
<b>File</b> <a class="el" href="Box_intersection_d_2triangle_self_intersect_pointers_8cpp-example.html">Box_intersection_d/triangle_self_intersect_pointers.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/box_intersection_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                       Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Triangle__3.html">Kernel::Triangle_3</a>                                    Triangle_3;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Triangle_3&gt;                               Triangles;</div><div class="line"><span class="keyword">typedef</span> Triangles::iterator                                   Iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Box__intersection__d_1_1Box__with__handle__d.html">CGAL::Box_intersection_d::Box_with_handle_d&lt;double,3,Iterator&gt;</a> Box;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Report {</div><div class="line">  Triangles* triangles;</div><div class="line"></div><div class="line">  Report(Triangles&amp; triangles)</div><div class="line">    : triangles(&amp;triangles)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="comment">// callback functor that reports all truly intersecting triangles</span></div><div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> Box* a, <span class="keyword">const</span> Box* b)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Box "</span> &lt;&lt; (a-&gt;handle() - triangles-&gt;begin()) &lt;&lt; <span class="stringliteral">" and "</span></div><div class="line">              &lt;&lt; (b-&gt;handle() - triangles-&gt;begin()) &lt;&lt; <span class="stringliteral">" intersect"</span>;</div><div class="line">    <span class="keywordflow">if</span> ( ! a-&gt;handle()-&gt;is_degenerate() &amp;&amp; ! b-&gt;handle()-&gt;is_degenerate()</div><div class="line">         &amp;&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__do__intersect__linear__grp.html#ga9514a218a097ac392d21775368d3dd0d">CGAL::do_intersect</a>( *(a-&gt;handle()), *(b-&gt;handle()))) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">", and the triangles intersect also"</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">'.'</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<span class="stringliteral">"data/triangles.xyz"</span>);</div><div class="line">  Triangles triangles;</div><div class="line">  Triangle_3 t;</div><div class="line">  <span class="keywordflow">while</span>(in &gt;&gt; t){</div><div class="line">    triangles.push_back(t);</div><div class="line">  }</div><div class="line">  <span class="comment">// Create the corresponding vector of bounding boxes</span></div><div class="line">  std::vector&lt;Box&gt; boxes;</div><div class="line">  <span class="keywordflow">for</span> ( Iterator i = triangles.begin(); i != triangles.end(); ++i)</div><div class="line">    boxes.push_back( Box( i-&gt;bbox(), i));</div><div class="line">  </div><div class="line">  <span class="comment">// Create the corresponding vector of pointers to bounding boxes</span></div><div class="line">  std::vector&lt;Box *&gt; ptr;</div><div class="line">  <span class="keywordflow">for</span> ( std::vector&lt;Box&gt;::iterator i = boxes.begin(); i != boxes.end(); ++i)</div><div class="line">    ptr.push_back( &amp;*i);</div><div class="line">  </div><div class="line">  <span class="comment">// Run the self intersection algorithm with all defaults on the</span></div><div class="line">  <span class="comment">// indirect pointers to bounding boxes. Avoids copying the boxes.</span></div><div class="line">  <a class="code" href="group__PkgBoxIntersectionD__box__self__intersection__d.html#ga3eed2bdb2a9e49a3fac1bca900087ec7">CGAL::box_self_intersection_d</a>( ptr.begin(), ptr.end(), Report(triangles));</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>A note on performance: The algorithm sorts and partitions the input sequences. It is clearly costly to copy a large box compared to a simple pointer. However, the algorithm benefits from memory locality in the later stages when it copies the boxes, while the pointers would refer to boxes that become wildly scattered in memory. These two effects, copying costs and memory locality, counteract each other. For small box sizes, i.e., small dimension, memory locality wins and one should work with boxes, while for larger box sizes one should work with pointers. The exact threshold depends on the memory hierarchy (caching) of the hardware platform and the size of the boxes, most notably the type used to represent the box coordinates. A concrete example; on a laptop with an Intel Mobile Pentium4 running at 1.80GHz with 512KB cache and 254MB main memory under Linux this version with pointers was 20% faster than the version above that copies the boxes for 10000 boxes, but the picture reversed for 100000 boxes, where the version above that copies the boxes becomes 300% faster.</p>
<p>Note that switching to the built-in type <code>float</code> is supported by the box intersection algorithm, but the interfacing with the <span style="font-variant: small-caps;">CGAL</span> bounding box <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">Bbox_3</a></code> would not be that easy. In particular, just converting from the <code>double</code> to the <code>float</code> representation incurs rounding that needs to be controlled properly, otherwise the box might shrink and one might miss intersections.</p>
<h1><a class="anchor" id="secboxintersparams"></a>
Example Using the Topology and the Cutoff Parameters</h1>
<p>Boxes can be interpreted by the box intersection algorithm as closed or as half-open boxes, see also Section <a class="el" href="index.html#secboxintersdef">Definition</a>. Closed boxes support zero-width boxes and they can intersect at their boundaries, while half-open boxes always have a positive volume and they only intersect iff their interiors overlap. The choice between closed or half-open boxes is selected with the <code>topology</code> parameter and its two values:</p>
<ul>
<li>
<code><a class="el" href="namespaceCGAL_1_1Box__intersection__d.html#ac1b7703e33d0fe5d9d484493189c9cd8ae829505cc850e61a5190ade8ad6098b5">Box_intersection_d::HALF_OPEN</a></code> and </li>
<li>
<code><a class="el" href="namespaceCGAL_1_1Box__intersection__d.html#ac1b7703e33d0fe5d9d484493189c9cd8af287bd8f3714b65e743d5ec571e89b82">Box_intersection_d::CLOSED</a></code>. </li>
</ul>
<p>The example program uses a two-dimensional box with <code>int</code> coordinates and <code>id</code>-numbers that are by default explicitly stored. We create the same boxes as in the minimal example in Section <a class="el" href="index.html#secboxintersectminimal">Minimal Example for Intersecting Boxes</a>. We create a \( 3 \times 3\) grid of <code>boxes</code>, and two boxes for the <code>query</code> sequence, namely the box at the center and the box from the upper-right corner of the grid.</p>
<p>We write a more involved callback function object <code>Report</code> that stores an output iterator and writes the <code>id</code>-number of the box in the first argument to the output iterator. We also provide a small helper function <code>report()</code> that simplifies the use of the function object.</p>
<p>We call the box intersection algorithm twice; once for the default <code>topology</code>, which is the closed box topology, and once for the half-open box topology. We sort the resulting output for better readability and verify its correctness with the <code>check1</code> and <code>check2</code> data. For the closed box topology, the center box in <code>query</code> intersects all <code>boxes</code>, and the upper-right box in <code>query</code> intersects the four boxes of the upper-right quadrant in <code>boxes</code>. Almost all intersections are with the box boundaries, thus, for the half-open topology only one intersection remains per <code>query</code> box, namely its corresponding box in <code>boxes</code>. So, the output of the algorithm will be:</p>
<pre class="fragment">0 1 2 3 4 4 5 5 6 7 7 8 8 
4 8 
</pre><p>For the second box intersection function call we have to specify the <code>cutoff</code> parameter explicitly. See the Section <a class="el" href="index.html#secboxintersperformance">Runtime Performance</a> below for a detailed discussion.</p>
<p><br />
<b>File</b> <a class="el" href="Box_intersection_d_2box_grid_8cpp-example.html">Box_intersection_d/box_grid.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/box_intersection_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Box__intersection__d_1_1Box__d.html">CGAL::Box_intersection_d::Box_d&lt;int,2&gt;</a> Box;</div><div class="line"></div><div class="line"><span class="comment">// coordinates for 9 boxes of a grid</span></div><div class="line"><span class="keywordtype">int</span> p[9*4]   = { 0,0,1,1,  1,0,2,1,  2,0,3,1, <span class="comment">// lower</span></div><div class="line">                 0,1,1,2,  1,1,2,2,  2,1,3,2, <span class="comment">// middle</span></div><div class="line">                 0,2,1,3,  1,2,2,3,  2,2,3,3};<span class="comment">// upper</span></div><div class="line"><span class="comment">// 9 boxes</span></div><div class="line">Box boxes[9] = { Box( p,    p+ 2),  Box( p+ 4, p+ 6),  Box( p+ 8, p+10),</div><div class="line">                 Box( p+12, p+14),  Box( p+16, p+18),  Box( p+20, p+22),</div><div class="line">                 Box( p+24, p+26),  Box( p+28, p+30),  Box( p+32, p+34)};</div><div class="line"><span class="comment">// 2 selected boxes as query; center and upper right</span></div><div class="line">Box query[2] = { Box( p+16, p+18),  Box( p+32, p+34)};</div><div class="line"></div><div class="line"><span class="comment">// callback function object writing results to an output iterator</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;</div><div class="line"><span class="keyword">struct </span>Report {</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> it;</div><div class="line">    Report( <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> i) : it(i) {} <span class="comment">// store iterator in object</span></div><div class="line">    <span class="comment">// We write the id-number of box a to the output iterator assuming</span></div><div class="line">    <span class="comment">// that box b (the query box) is not interesting in the result.</span></div><div class="line">    <span class="keywordtype">void</span> operator()( <span class="keyword">const</span> Box&amp; a, <span class="keyword">const</span> Box&amp;) { *it++ = a.id(); }</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iter&gt; <span class="comment">// helper function to create the function object</span></div><div class="line">Report&lt;Iter&gt; report( Iter it) { <span class="keywordflow">return</span> Report&lt;Iter&gt;(it); }</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// run the intersection algorithm and store results in a vector</span></div><div class="line">    std::vector&lt;std::size_t&gt; result;</div><div class="line">    <a class="code" href="group__PkgBoxIntersectionD__box__intersection__d.html#ga5526579aad16bc9c3ed830dd8fc58f6a">CGAL::box_intersection_d</a>( boxes, boxes+9, query, query+2,</div><div class="line">                              report( std::back_inserter( result)));</div><div class="line">    <span class="comment">// sort, check, and show result</span></div><div class="line">    std::sort( result.begin(), result.end());</div><div class="line">    std::size_t check1[13] = {0,1,2,3,4,4,5,5,6,7,7,8,8};</div><div class="line">    assert(result.size() == 13 &amp;&amp; std::equal(check1,check1+13,result.begin()));</div><div class="line">    std::copy( result.begin(), result.end(),</div><div class="line">               std::ostream_iterator&lt;std::size_t&gt;( std::cout, <span class="stringliteral">" "</span>));</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// run it again but for different cutoff value and half-open boxes</span></div><div class="line">    result.clear();</div><div class="line">    <a class="code" href="group__PkgBoxIntersectionD__box__intersection__d.html#ga5526579aad16bc9c3ed830dd8fc58f6a">CGAL::box_intersection_d</a>( boxes, boxes+9, query, query+2,</div><div class="line">                              report( std::back_inserter( result)),</div><div class="line">                              std::ptrdiff_t(1),</div><div class="line">                              <a class="code" href="namespaceCGAL_1_1Box__intersection__d.html#ac1b7703e33d0fe5d9d484493189c9cd8ae829505cc850e61a5190ade8ad6098b5">CGAL::Box_intersection_d::HALF_OPEN</a>);</div><div class="line">    <span class="comment">// sort, check, and show result</span></div><div class="line">    std::sort( result.begin(), result.end());</div><div class="line">    std::size_t check2[2]  = {4,8};</div><div class="line">    assert(result.size() == 2 &amp;&amp; std::equal(check2, check2+2, result.begin()));</div><div class="line">    std::copy( result.begin(), result.end(),</div><div class="line">               std::ostream_iterator&lt;std::size_t&gt;( std::cout, <span class="stringliteral">" "</span>));</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="secboxintersperformance"></a>
Runtime Performance</h1>
<p>The implemented algorithm is described in <a class="el" href="citelist.html#CITEREF_cgal:ze-fsbi-02">[2]</a> as version two. Its performance depends on a <code>cutoff</code> parameter. When the size of both iterator ranges drops below the <code>cutoff</code> parameter the function switches from the streamed segment-tree algorithm to the two-way-scan algorithm, see <a class="el" href="citelist.html#CITEREF_cgal:ze-fsbi-02">[2]</a> for the details.</p>
<p>The streamed segment-tree algorithm needs \( O(n \log^d (n) + k)\) worst-case running time and \( O(n)\) space, where \( n\) is the number of boxes in both input sequences, \( d\) the (constant) dimension of the boxes, and \( k\) the output complexity, i.e., the number of pairwise intersections of the boxes. The two-way-scan algorithm needs \( O(n \log (n) + l)\) worst-case running time and \( O(n)\) space, where \( l\) is the number of pairwise overlapping intervals in one dimensions (the dimension where the algorithm is used instead of the segment tree). Note that \( l\) is not necessarily related to \( k\) and using the two-way-scan algorithm is a heuristic.</p>
<p>Unfortunately, we have no general method to automatically determine an optimal cutoff parameter, since it depends on the used hardware, the runtime ratio between callback runtime and segment-tree runtime, and of course the number of boxes to be checked and their distribution. In cases where the callback runtime is dominant, it may be best to make the threshold parameter small. Otherwise a <code>cutoff</code> \( =\sqrt{n}\) can lead to acceptable results. For well distributed boxes the original paper <a class="el" href="citelist.html#CITEREF_cgal:ze-fsbi-02">[2]</a> gives optimal cutoffs in the thousands. Anyway, for optimal runtime some experiments to compare different cutoff parameters are recommended.</p>
<p>To demonstrate that box intersection can be done quite fast, different box sequences are intersected in the range between 4 and 800000 boxes total. We use three-dimensional default boxes of closed topology with <code>float</code> coordinates and without additional data fields. The algorithm works directly on the boxes, not on pointer to boxes. Each box intersection is reported to an empty dummy callback.</p>
<p>For each box set, a near-optimal cutoff parameter is determined using an adaptive approximation. The runtime required for streaming is compared against usual scanning. Results on a Xeon 2.4GHz with 4GB main memory can be seen in <a class="el" href="index.html#fig__fig_benchmark">Figure 80.1</a>. For a small number of boxes, pure scanning is still faster than streaming with optimal cutoff, which would just delegate the box sets to the scanning algorithm. As there are more and more boxes, the overhead becomes less important.</p>
<p><a class="anchor" id="fig__fig_benchmark"></a></p><div class="image">
<img src="benchmark.png" alt="benchmark.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_benchmark">Figure 80.1</a> Runtime comparison between the scanning and the streaming algorithm.  </div>  <br />

<h1><a class="anchor" id="Box_intersection_dExample_3"></a>
Example Using a Custom Box Implementation</h1>
<p>The example in the previous Section <a class="el" href="index.html#secboxintersparams">Example Using the Topology and the Cutoff Parameters</a> uses an array to provide the coordinates and then creates another array for the boxes. In the following example we write our own box class <code>Box</code> that we can initialize directly with the four coordinates and create the array of boxes directly. We also omit the explicitly stored <code>id</code>-number and use the address of the box itself as <code>id</code>-number. This works only if the boxes do not change their position, i.e., we work with pointers to the boxes in the intersection algorithm.</p>
<p>We follow with our own box class <code>Box</code> the <code><a class="el" href="classBoxIntersectionBox__d.html" title="The BoxIntersectionBox_d concept is used in the context of the intersection algorithms for sequences ...">BoxIntersectionBox_d</a></code> concept, which allows us to reuse the default traits implementation, i.e., we can use the same default function call to compute all intersections. See the example in the next section for a self-written traits class. So, in principle, the remainder of the example stays the same and we omit the part from the previous example for brevity that illustrates the half-open box topology.</p>
<p>The requirements for the box implementation are best studied on the reference manual page of <code><a class="el" href="classBoxIntersectionBox__d.html" title="The BoxIntersectionBox_d concept is used in the context of the intersection algorithms for sequences ...">BoxIntersectionBox_d</a></code>. In a nutshell, we have to define the type <code>NT</code> for the box coordinates and the type <code>ID</code> for the <code>id</code>-number. Member functions give access to the coordinates and the <code>id</code>-number. A static member function returns the dimension.</p>
<p><br />
<b>File</b> <a class="el" href="Box_intersection_d_2custom_box_grid_8cpp-example.html">Box_intersection_d/custom_box_grid.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/box_intersection_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Box {</div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">int</span>            NT;</div><div class="line">    <span class="keyword">typedef</span> std::ptrdiff_t ID;</div><div class="line">    <span class="keywordtype">int</span> lo[2], hi[2];</div><div class="line">    Box( <span class="keywordtype">int</span> lo0, <span class="keywordtype">int</span> lo1, <span class="keywordtype">int</span> hi0, <span class="keywordtype">int</span> hi1) { lo[0]=lo0; lo[1]=lo1; hi[0]=hi0; hi[1]=hi1;}</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> dimension() { <span class="keywordflow">return</span> 2; }</div><div class="line">    <span class="keywordtype">int</span> min_coord(<span class="keywordtype">int</span> dim)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> lo[dim]; }</div><div class="line">    <span class="keywordtype">int</span> max_coord(<span class="keywordtype">int</span> dim)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> hi[dim]; }</div><div class="line">    <span class="comment">// id-function using address of current box,</span></div><div class="line">    <span class="comment">// requires to work with pointers to boxes later</span></div><div class="line">    std::ptrdiff_t id()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (std::ptrdiff_t)(<span class="keyword">this</span>); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 9 boxes of a grid</span></div><div class="line">Box boxes[9] = { Box( 0,0,1,1),  Box( 1,0,2,1),  Box( 2,0,3,1), <span class="comment">// low</span></div><div class="line">                 Box( 0,1,1,2),  Box( 1,1,2,2),  Box( 2,1,3,2), <span class="comment">// middle</span></div><div class="line">                 Box( 0,2,1,3),  Box( 1,2,2,3),  Box( 2,2,3,3)};<span class="comment">// upper</span></div><div class="line"><span class="comment">// 2 selected boxes as query; center and upper right</span></div><div class="line">Box query[2] = { Box( 1,1,2,2),  Box( 2,2,3,3)};</div><div class="line"></div><div class="line"><span class="comment">// With the special id-function we need to work on box pointers</span></div><div class="line">Box* b_ptr[9] = { boxes,   boxes+1, boxes+2, boxes+3, boxes+4, boxes+5,</div><div class="line">                  boxes+6, boxes+7, boxes+8};</div><div class="line">Box* q_ptr[2] = { query,   query+1};</div><div class="line"></div><div class="line"><span class="comment">// callback function object writing results to an output iterator</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;</div><div class="line"><span class="keyword">struct </span>Report {</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> it;</div><div class="line">    Report( <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> i) : it(i) {} <span class="comment">// store iterator in object</span></div><div class="line">    <span class="comment">// We write the position with respect to 'boxes' to the output iterator</span></div><div class="line">    <span class="comment">// assuming that box b (the query box) is not interesting in the result.</span></div><div class="line">    <span class="keywordtype">void</span> operator()( <span class="keyword">const</span> Box* a, <span class="keyword">const</span> Box*) {</div><div class="line">        *it++ = ( <span class="keyword">reinterpret_cast&lt;</span>Box*<span class="keyword">&gt;</span>(a-&gt;id()) - boxes);</div><div class="line">    }</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iter&gt; <span class="comment">// helper function to create the function object</span></div><div class="line">Report&lt;Iter&gt; report( Iter it) { <span class="keywordflow">return</span> Report&lt;Iter&gt;(it); }</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// run the intersection algorithm and store results in a vector</span></div><div class="line">    std::vector&lt;std::size_t&gt; result;</div><div class="line">    <a class="code" href="group__PkgBoxIntersectionD__box__intersection__d.html#ga5526579aad16bc9c3ed830dd8fc58f6a">CGAL::box_intersection_d</a>( b_ptr, b_ptr+9, q_ptr, q_ptr+2,</div><div class="line">                              report( std::back_inserter( result)),</div><div class="line">                              std::ptrdiff_t(0));</div><div class="line">    <span class="comment">// sort and check result</span></div><div class="line">    std::sort( result.begin(), result.end());</div><div class="line">    std::size_t chk[13] = {0,1,2,3,4,4,5,5,6,7,7,8,8};</div><div class="line">    assert( result.size()==13 &amp;&amp; std::equal(chk,chk+13,result.begin()));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="secbox_inters_example_proximity"></a>
Example for Point Proximity Search with a Custom Traits Class</h1>
<p>Given a set of 3D points, we want to find all pairs of points that are less than a certain distance apart. We use the box intersection algorithm to find good candidates, namely those that are less than this specified distance apart in the \( L_\infty\) norm, which is a good approximation of the Euclidean norm.</p>
<p>We use an unusual representation for the box, namely pointers to the 3D points themselves. We implement a special box traits class that interprets the point as a box of the dimensions \( [-\)<code>eps</code> \( ,+\)<code>eps</code> \( ]^3\) centered at this point. The value for <code>eps</code> is half the specified distance from above, i.e., points are reported if their distance is smaller than <code>2*eps</code>.</p>
<p>The requirements for the box traits class are best studied on the reference manual page of <code><a class="el" href="classBoxIntersectionTraits__d.html" title="The BoxIntersectionTraits_d concept is used for the intersection algorithms for sequences of iso-orie...">BoxIntersectionTraits_d</a></code>. In a nutshell, we have to define the type <code>NT</code> for the box coordinates, the type <code>ID</code> for the <code>id</code>-number, and the type <code>Box_parameter</code> similar to the box handle, here <code>Point_3*</code> since we work with the pointers. All member functions in the traits class are static. Two functions give access to the max and min coordinates that we compute from the point coordinates plus or minus the <code>eps</code> value, respectively. For the <code>id</code>-number function the address of the point itself is sufficient, since the points stay stable. Another function returns the dimension.</p>
<p>The <code>report</code> callback function computes than the Euclidean distance and prints a message for points that are close enough.</p>
<p>Note that we need to reserve sufficient space in the <code>points</code> vector to avoid reallocations while we create the <code>points</code> vector and the <code>boxes</code> vector in parallel, since otherwise the <code>points</code> vector might reallocate and invalidate all pointers stored in the <code>boxes</code> so far.</p>
<p><br />
<b>File</b> <a class="el" href="Box_intersection_d_2proximity_custom_box_traits_8cpp-example.html">Box_intersection_d/proximity_custom_box_traits.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/box_intersection_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;float&gt;</a>             Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                           Point_3;</div><div class="line"></div><div class="line">std::vector&lt;Point_3&gt;  points;</div><div class="line">std::vector&lt;Point_3*&gt; boxes;     <span class="comment">// boxes are just pointers to points</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span>           eps = 0.1f; <span class="comment">// finds point pairs of distance &lt; 2*eps</span></div><div class="line"></div><div class="line"><span class="comment">// Boxes are just pointers to 3d points. The traits class adds the</span></div><div class="line"><span class="comment">// +- eps size to each interval around the point, effectively building</span></div><div class="line"><span class="comment">// on the fly a box of size 2*eps centered at the point.</span></div><div class="line"><span class="keyword">struct </span>Traits {</div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">float</span>          NT;</div><div class="line">    <span class="keyword">typedef</span> Point_3*       Box_parameter;</div><div class="line">    <span class="keyword">typedef</span> std::ptrdiff_t ID;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span>   dimension() { <span class="keywordflow">return</span> 3; }</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">float</span> coord( Box_parameter b, <span class="keywordtype">int</span> d) {</div><div class="line">        <span class="keywordflow">return</span> (d == 0) ? b-&gt;x() : ((d == 1) ? b-&gt;y() : b-&gt;z());</div><div class="line">    }</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">float</span> min_coord( Box_parameter b, <span class="keywordtype">int</span> d) { <span class="keywordflow">return</span> coord(b,d)-eps;}</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">float</span> max_coord( Box_parameter b, <span class="keywordtype">int</span> d) { <span class="keywordflow">return</span> coord(b,d)+eps;}</div><div class="line">    <span class="comment">// id-function using address of current box,</span></div><div class="line">    <span class="comment">// requires to work with pointers to boxes later</span></div><div class="line">    <span class="keyword">static</span> std::ptrdiff_t id(Box_parameter b) { <span class="keywordflow">return</span> (std::ptrdiff_t)(b); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// callback function reports pairs in close proximity</span></div><div class="line"><span class="keywordtype">void</span> report( <span class="keyword">const</span> Point_3* a, <span class="keyword">const</span> Point_3* b) {</div><div class="line">    <span class="keywordtype">float</span> dist = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>( <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a>( *a, *b));</div><div class="line">    <span class="keywordflow">if</span> ( dist &lt; 2*eps) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Point "</span> &lt;&lt; (a - &amp;(points.front())) &lt;&lt; <span class="stringliteral">" and Point "</span></div><div class="line">                  &lt;&lt; (b - &amp;(points.front())) &lt;&lt; <span class="stringliteral">" have distance "</span> &lt;&lt; dist</div><div class="line">                  &lt;&lt; <span class="stringliteral">"."</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[]) {</div><div class="line">  </div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<span class="stringliteral">"data/points.xyz"</span>);</div><div class="line">  Point_3 p;</div><div class="line">  <span class="keywordflow">while</span>(in &gt;&gt; p){</div><div class="line">    points.push_back(p);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i&lt; points.size();++i) {</div><div class="line">    boxes.push_back( &amp;points[i]);</div><div class="line">  }</div><div class="line">  <span class="comment">// run the intersection algorithm and report proximity pairs</span></div><div class="line">  <a class="code" href="group__PkgBoxIntersectionD__box__self__intersection__d.html#ga3eed2bdb2a9e49a3fac1bca900087ec7">CGAL::box_self_intersection_d</a>( boxes.begin(), boxes.end(),</div><div class="line">                                 report, Traits());</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Box_intersection_dDesign"></a>
Design and Implementation History</h1>
<p>Lutz Kettner and Andreas Meyer implemented the algorithms starting from the publication <a class="el" href="citelist.html#CITEREF_cgal:ze-fsbi-02">[2]</a>. We had access to the original C implementation of Afra Zomorodian, which helped clarifying some questions, and we are grateful to the help of Afra Zomorodian in answering our questions during his visit. We thank Steve Robbins for an excellent review for this package. Steve Robbins provided an independent and earlier implementation of this algorithm, however, we learned too late about this implementation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:50 for CGAL 4.13 - Intersecting Sequences of dD Iso-oriented Boxes by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
