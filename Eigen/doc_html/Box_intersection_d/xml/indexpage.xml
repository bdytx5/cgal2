<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Intersecting_Sequences_of_dD_Iso-oriented_Boxes"/><anchor id="index_1chapterBoxIntersection"/> <simplesect kind="authors"><para>Lutz Kettner, Andreas Meyer, and Afra Zomorodian</para></simplesect>
</para><sect1 id="index_1Box_intersection_dIntroduction">
<title>Introduction</title>
<para>Simple questions on geometric primitives, such as intersection and distance computations, can themselves become quite expensive if the primitives are not so simple anymore, for example, three-dimensional triangles and facets of polyhedral surfaces. Thus algorithms operating on these primitives tend to be slow in practice. A common (heuristic) optimization approximates the geometric primitives with their axis-aligned bounding boxes, runs a suitable modification of the algorithm on the boxes, and whenever a pair of boxes has an interesting interaction Boxes represent volumes or point-sets. So, <emphasis>intersection</emphasis> means intersection of the point-set enclosed by the box and not only intersection of the boundary, of course., only then the exact answer is computed on the complicated geometric primitives contained in the boxes.</para><para><image type="html" name="box_inters.png"></image>
 <image type="latex" name="box_inters.png"></image>
</para><para>We provide an efficient algorithm <ref refid="citelist_1CITEREF_cgal:ze-fsbi-02" kindref="member">[2]</ref> for finding all intersecting pairs for large numbers of iso-oriented boxes, i.e., typically these will be such bounding boxes of more complicated geometries. One immediate application of this algorithm is the detection of all intersections (and self-intersections) for polyhedral surfaces, i.e., applying the algorithm on a large set of triangles in space, we give an example program later in this chapter. Not so obvious applications are proximity queries and distance computations among such surfaces, see Section <ref refid="index_1secbox_inters_example_proximity" kindref="member">Example for Point Proximity Search with a Custom Traits Class</ref> for an example and <ref refid="citelist_1CITEREF_cgal:ze-fsbi-02" kindref="member">[2]</ref> for more details.</para></sect1>
<sect1 id="index_1secboxintersdef">
<title>Definition</title>
<para>A <formula id="0">$ d$</formula>-dimensional iso-oriented box is defined as the Cartesian product of <formula id="0">$ d$</formula> intervals. We call the box <emphasis>half-open</emphasis> if the <formula id="0">$ d$</formula> intervals <formula id="1">$ \{ [lo_i,hi_i) \,|\, 0 \leq i &lt; d\}$</formula> are half-open intervals, and we call the box <emphasis>closed</emphasis> if the <formula id="0">$ d$</formula> intervals <formula id="2">$ \{ [lo_i,hi_i] \,|\, 0 \leq i &lt; d\}$</formula> are closed intervals. Note that closed boxes support zero-width boxes and they can intersect at their boundaries, while non-empty half-open boxes always have a positive volume and they only intersect iff their interiors overlap. The distinction between closed and half-open boxes does not require a different representation of boxes, just a different interpretation when comparing boxes, which is selected with the two possible values for the <computeroutput>topology</computeroutput> parameter:</para><para><itemizedlist>
<listitem>
<para><computeroutput><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8ae829505cc850e61a5190ade8ad6098b5" kindref="member">Box_intersection_d::HALF_OPEN</ref></computeroutput> and </para></listitem>
<listitem>
<para><computeroutput><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8af287bd8f3714b65e743d5ec571e89b82" kindref="member">Box_intersection_d::CLOSED</ref></computeroutput>. </para></listitem>
</itemizedlist>
</para><para>The number type of the interval boundaries must be one of the built-in types <computeroutput>int</computeroutput>, <computeroutput>unsigned int</computeroutput>, <computeroutput>double</computeroutput> or <computeroutput>float</computeroutput>.</para><para>In addition, a box has a unique <computeroutput>id</computeroutput>-number. It is used to order boxes consistently in each dimension even if boxes have identical coordinates. In consequence, the algorithm guarantees that a pair of intersecting boxes is reported only once. Note that boxes with equal <computeroutput>id</computeroutput>-number are not reported since they obviously intersect trivially.</para><para>The box intersection algorithm comes in two flavors: One algorithm works on a single sequence of boxes and computes all pairwise intersections, which is called the <emphasis>complete</emphasis> case, and used, for example, in the self-intersection test. The other algorithm works on two sequences of boxes and computes the pairwise intersections between boxes from the first sequence with boxes from the second sequence, which is called the <emphasis>bipartite</emphasis> case. For each pairwise intersection found a callback function is called with two arguments; the first argument is a box from the first sequence and the second argument a box from the second sequence. In the complete case, the second argument is a box from an internal copy of the first sequence.</para></sect1>
<sect1 id="index_1Box_intersection_dSoftware">
<title>Software Design</title>
<para>The box intersection algorithm is implemented as a family of generic functions; the functions for the complete case accept one iterator range, and the functions for the bipartite case accept two iterator ranges. The callback function for reporting the intersecting pairs is provided as a template parameter of the <computeroutput>BinaryFunction</computeroutput> concept. The two principle function calls utilizing all default arguments look as follows:</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/box_intersection_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>RandomAccessIterator,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Callback<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" kindref="member">box_intersection_d</ref>(<ref refid="classRandomAccessIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref><sp/>begin,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classRandomAccessIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref><sp/>end,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Callback<sp/>callback);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">RandomAccessIterator1,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">RandomAccessIterator2,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Callback<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" kindref="member">box_intersection_d</ref>(RandomAccessIterator1<sp/>begin1,<sp/>RandomAccessIterator1<sp/>end1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RandomAccessIterator2<sp/>begin2,<sp/>RandomAccessIterator2<sp/>end2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Callback<sp/>callback);</highlight></codeline>
</programlisting></para><para>Additional parameters to the functions calls are a <emphasis>cutoff</emphasis> value to adjust performance trade-offs, and a <emphasis>topology</emphasis> parameter selecting between topologically closed boxes (the default) and topologically half-open boxes.</para><para>The algorithm reorders the boxes in the course of the algorithm. Now, depending on the size of a box it can be faster to copy the boxes, or to work with pointers to boxes and copy only pointers. We offer automatic support for both options. To simplify the description, let us call the <computeroutput>value_type</computeroutput> of the iterator ranges <emphasis>box handle</emphasis>. The <emphasis>box handle</emphasis> can either be our box type itself or a pointer (or const pointer) to the box type; these choices represent both options from above.</para><para>In general, the algorithms treat the box type as opaque type and just assume that they are models of the <computeroutput><ref refid="classAssignable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Assignable</ref></computeroutput> concept, so that the algorithms can modify the input sequences and reorder the boxes. The access to the box dimension and box coordinates is mediated with a traits class of the <computeroutput><ref refid="classBoxIntersectionTraits__d" kindref="compound">BoxIntersectionTraits_d</ref></computeroutput> concept. A default traits class is provided that assumes that the box type is a model of the <computeroutput><ref refid="classBoxIntersectionBox__d" kindref="compound">BoxIntersectionBox_d</ref></computeroutput> concept and that the box handle, i.e., the iterators value type, is identical to the box type or a pointer to the box type (see the previous paragraph for the value versus pointer nature of the box handle).</para><para>Two implementations of iso-oriented boxes are provided; <computeroutput><ref refid="classCGAL_1_1Box__intersection__d_1_1Box__d" kindref="compound">Box_intersection_d::Box_d</ref></computeroutput> as a plain box, and <computeroutput><ref refid="classCGAL_1_1Box__intersection__d_1_1Box__with__handle__d" kindref="compound">Box_intersection_d::Box_with_handle_d</ref></computeroutput> as a box plus a handle that can be used to point to the full geometry that is approximated by the box. Both implementations have template parameters for the number type used for the interval bounds, for the fixed dimension of the box, and for a policy class <ref refid="citelist_1CITEREF_cgal:a-mcdgp-01" kindref="member">[1]</ref> selecting among several solutions for providing the <computeroutput>id</computeroutput>-number.</para><para>The function signatures for the bipartite case look as follows. The signatures for the complete case with the <computeroutput><ref refid="group__PkgBoxIntersectionD__box__self__intersection__d_1ga3eed2bdb2a9e49a3fac1bca900087ec7" kindref="member">box_self_intersection_d()</ref></computeroutput> function look the same except for the single iterator range.</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>CGAL/box_intersection_d.h</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">RandomAccessIterator1,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">RandomAccessIterator2,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Callback<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" kindref="member">box_intersection_d</ref>(RandomAccessIterator1<sp/>begin1,<sp/>RandomAccessIterator1<sp/>end1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RandomAccessIterator2<sp/>begin2,<sp/>RandomAccessIterator2<sp/>end2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Callback<sp/>callback,<sp/>std::ptrdiff_t<sp/>cutoff<sp/>=<sp/>10,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8" kindref="member">Box_intersection_d::Topology</ref><sp/>topology<sp/>=<sp/><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8af287bd8f3714b65e743d5ec571e89b82" kindref="member">Box_intersection_d::CLOSED</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1_1Box__intersection__d_1a7539d6db67bbedc4e4dc9ffe53d13d42" kindref="member">Box_intersection_d::Setting</ref><sp/>setting<sp/>=<sp/><ref refid="namespaceCGAL_1_1Box__intersection__d_1a7539d6db67bbedc4e4dc9ffe53d13d42a92e93ad5ad25555be14763a2c2799395" kindref="member">Box_intersection_d::BIPARTITE</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">RandomAccessIterator1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">RandomAccessIterator2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Callback,<sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">BoxTraits<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" kindref="member">box_intersection_d</ref>(RandomAccessIterator1<sp/>begin1,<sp/>RandomAccessIterator1<sp/>end1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RandomAccessIterator2<sp/>begin2,<sp/>RandomAccessIterator2<sp/>end2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Callback<sp/>callback,<sp/>BoxTraits<sp/>box_traits,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ptrdiff<sp/>cutoff<sp/>=<sp/>10,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8" kindref="member">Box_intersection_d::Topology</ref><sp/>topology<sp/>=<sp/><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8af287bd8f3714b65e743d5ec571e89b82" kindref="member">Box_intersection_d::CLOSED</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1_1Box__intersection__d_1a7539d6db67bbedc4e4dc9ffe53d13d42" kindref="member">Box_intersection_d::Setting</ref><sp/>setting<sp/>=<sp/><ref refid="namespaceCGAL_1_1Box__intersection__d_1a7539d6db67bbedc4e4dc9ffe53d13d42a92e93ad5ad25555be14763a2c2799395" kindref="member">Box_intersection_d::BIPARTITE</ref>);</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1secboxintersectminimal">
<title>Minimal Example for Intersecting Boxes</title>
<para>The box implementation provided with <computeroutput><ref refid="classCGAL_1_1Box__intersection__d_1_1Box__d" kindref="compound">Box_intersection_d::Box_d</ref>&lt;double,2&gt;</computeroutput> has a dedicated constructor for the CGAL bounding box type <computeroutput><ref refid="classCGAL_1_1Bbox__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Bbox_2</ref></computeroutput> (similar for dimension 3). We use this in our minimal example to create easily nine two-dimensional <computeroutput>boxes</computeroutput> in a grid layout of <formula id="3">$ 3 \times 3$</formula> boxes. Additionally we pick the center box and the box in the upper-right corner as our second box sequence <computeroutput>query</computeroutput>.</para><para>The default policy of the box type implements the <computeroutput>id</computeroutput>-number with an explicit counter in the boxes, which is the default choice since it always works, but it costs space that could potentially be avoided, see the example in the next section. We use the <computeroutput>id</computeroutput>-number in our callback function to report the result of the intersection algorithm. The result will be that the first <computeroutput>query</computeroutput> box intersects all nine <computeroutput>boxes</computeroutput> and the second <computeroutput>query</computeroutput> box intersects the four boxes in the upper-right quadrant. See Section <ref refid="index_1secboxintersparams" kindref="member">Example Using the Topology and the Cutoff Parameters</ref> for the change of the <computeroutput>topology</computeroutput> parameter and its effect.</para><para><linebreak/>
<bold>File</bold> <ref refid="Box_intersection_d_2minimal_8cpp-example" kindref="compound">Box_intersection_d/minimal.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/box_intersection_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Bbox_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Box__intersection__d_1_1Box__d" kindref="compound">CGAL::Box_intersection_d::Box_d&lt;double,2&gt;</ref><sp/>Box;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Bbox__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Bbox_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bbox;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>9<sp/>boxes<sp/>of<sp/>a<sp/>grid</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Box<sp/>boxes[9]<sp/>=<sp/>{<sp/>Bbox(<sp/>0,0,1,1),<sp/>Bbox(<sp/>1,0,2,1),<sp/>Bbox(<sp/>2,0,3,1),<sp/></highlight><highlight class="comment">//<sp/>low</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bbox(<sp/>0,1,1,2),<sp/>Bbox(<sp/>1,1,2,2),<sp/>Bbox(<sp/>2,1,3,2),<sp/></highlight><highlight class="comment">//<sp/>middle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bbox(<sp/>0,2,1,3),<sp/>Bbox(<sp/>1,2,2,3),<sp/>Bbox(<sp/>2,2,3,3)};</highlight><highlight class="comment">//<sp/>upper</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>2<sp/>selected<sp/>boxes<sp/>as<sp/>query;<sp/>center<sp/>and<sp/>upper<sp/>right</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Box<sp/>query[2]<sp/>=<sp/>{<sp/>Bbox(<sp/>1,1,2,2),<sp/>Bbox(<sp/>2,2,3,3)};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>callback(<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box&amp;<sp/>a,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box&amp;<sp/>b<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;box<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>a.id()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>intersects<sp/>box<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>b.id()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" kindref="member">CGAL::box_intersection_d</ref>(<sp/>boxes,<sp/>boxes+9,<sp/>query,<sp/>query+2,<sp/>callback);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1Box_intersection_dExample_1">
<title>Example for Finding Intersecting 3D Triangles</title>
<para>The conventional application of the axis-aligned box intersection algorithm will start from complex geometry, here 3D triangles, approximate them with their bounding box, compute the intersecting pairs of boxes, and check only for those if the original triangles intersect as well.</para><para>We start in the <computeroutput>main</computeroutput> function and create ten triangles with endpoints chosen randomly in a cube <formula id="4">$ [-1,+1)^3$</formula>. We store the triangles in a vector called <computeroutput>triangles</computeroutput>.</para><para>Next we create a vector for the bounding boxes of the triangles called <computeroutput>boxes</computeroutput>. For the boxes we choose the type <computeroutput>Box_with_handle_d&lt;double,3,<ref refid="classIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Iterator</ref>&gt;</computeroutput> that works nicely together with the CGAL bounding boxes of type <computeroutput><ref refid="classCGAL_1_1Bbox__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Bbox_3</ref></computeroutput>. In addition, each box stores the iterator to the corresponding triangle.</para><para>The default policy of this box type uses for the <computeroutput>id</computeroutput>-number the address of the value of the iterator, i.e., the address of the triangle. This is a good choice that works correctly iff the boxes have unique iterators, i.e., there is a one-to-one mapping between boxes and approximated geometry, which is the case here. It saves us the extra space that was needed for the explicit <computeroutput>id</computeroutput>-number in the previous example.</para><para>We run the self intersection algorithm with the <computeroutput>report_inters</computeroutput> function as callback. This callback reports the intersecting boxes. It uses the <computeroutput>handle</computeroutput> and the global <computeroutput>triangles</computeroutput> vector to calculate the triangle numbers. Then it checks the triangles themselves for intersection and reports if not only the boxes but also the triangles intersect. We take some precautions before the intersection test in order to avoid problems, although unlikely, with degenerate triangles that we might have created with the random process.</para><para>This example can be easily extended to test polyhedral surfaces of the <computeroutput>Polyhedron_3</computeroutput> class for (self-) intersections. The main difference are the numerous cases of incidences between triangles in the polyhedral surface that should not be reported as intersections, see the <computeroutput>examples/Polyhedron/polyhedron_self_intersection.cpp</computeroutput> example program in the CGAL distribution.</para><para><linebreak/>
<bold>File</bold> <ref refid="Box_intersection_d_2triangle_self_intersect_8cpp-example" kindref="compound">Box_intersection_d/triangle_self_intersect.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/box_intersection_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Triangle__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Triangle_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangle_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Triangle_3&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangles;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangles::iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Box__intersection__d_1_1Box__with__handle__d" kindref="compound">CGAL::Box_intersection_d::Box_with_handle_d&lt;double,3,Iterator&gt;</ref><sp/>Box;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Report<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangles*<sp/>triangles;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Report(Triangles&amp;<sp/>triangles)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>triangles(&amp;triangles)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>callback<sp/>functor<sp/>that<sp/>reports<sp/>all<sp/>truly<sp/>intersecting<sp/>triangles</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box&amp;<sp/>a,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box&amp;<sp/>b)</highlight><highlight class="keyword"><sp/>const<sp/></highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Box<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(a.handle()<sp/>-<sp/>triangles-&gt;begin())<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>and<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>(b.handle()<sp/>-<sp/>triangles-&gt;begin())<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>intersect&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!<sp/>a.handle()-&gt;is_degenerate()<sp/>&amp;&amp;<sp/>!<sp/>b.handle()-&gt;is_degenerate()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/><ref refid="group__do__intersect__linear__grp_1ga9514a218a097ac392d21775368d3dd0d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::do_intersect</ref>(<sp/>*(a.handle()),<sp/>*(b.handle())))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>and<sp/>the<sp/>triangles<sp/>intersect<sp/>also&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;.&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in((argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/triangles.xyz&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangles<sp/>triangles;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangle_3<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(in<sp/>&gt;&gt;<sp/>t){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>triangles.push_back(t);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>the<sp/>corresponding<sp/>vector<sp/>of<sp/>bounding<sp/>boxes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Box&gt;<sp/>boxes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/>Iterator<sp/>i<sp/>=<sp/>triangles.begin();<sp/>i<sp/>!=<sp/>triangles.end();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boxes.push_back(<sp/>Box(<sp/>i-&gt;bbox(),<sp/>i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>the<sp/>self<sp/>intersection<sp/>algorithm<sp/>with<sp/>all<sp/>defaults</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBoxIntersectionD__box__self__intersection__d_1ga3eed2bdb2a9e49a3fac1bca900087ec7" kindref="member">CGAL::box_self_intersection_d</ref>(<sp/>boxes.begin(),<sp/>boxes.end(),<sp/>Report(triangles));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1Box_intersection_dExample_2">
<title>Example for Using Pointers to Boxes</title>
<para>We modify the previous example, finding intersecting 3D triangles, and add an additional vector <computeroutput>ptr</computeroutput> that stores pointers to the bounding boxes, so that the intersection algorithm will work on a sequence of pointers and not on a sequence of boxes. The change just affects the preparation of the additional vector and the call of the box intersection function. The box intersection function (actually its default traits class) detects automatically that the value type of the iterators is a pointer type and not a class type.</para><para><programlisting><codeline><highlight class="comment">//<sp/>Create<sp/>the<sp/>corresponding<sp/>vector<sp/>of<sp/>pointers<sp/>to<sp/>bounding<sp/>boxes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::vector&lt;Box<sp/>*&gt;<sp/>ptr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/>std::vector&lt;Box&gt;::iterator<sp/>i<sp/>=<sp/>boxes.begin();<sp/>i<sp/>!=<sp/>boxes.end();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal">ptr.push_back(<sp/>&amp;*i);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Run<sp/>the<sp/>self<sp/>intersection<sp/>algorithm<sp/>with<sp/>all<sp/>defaults<sp/>on<sp/>the<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>indirect<sp/>pointers<sp/>to<sp/>bounding<sp/>boxes.<sp/>Avoids<sp/>copying<sp/>the<sp/>boxes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__PkgBoxIntersectionD__box__self__intersection__d_1ga3eed2bdb2a9e49a3fac1bca900087ec7" kindref="member">CGAL::box_self_intersection_d</ref>(<sp/>ptr.begin(),<sp/>ptr.end(),<sp/>report_inters);</highlight></codeline>
</programlisting></para><para>In addition, the callback function <computeroutput>report_inters()</computeroutput> needs to be changed to work with pointers to boxes. The full example program looks as follows:</para><para><linebreak/>
<bold>File</bold> <ref refid="Box_intersection_d_2triangle_self_intersect_pointers_8cpp-example" kindref="compound">Box_intersection_d/triangle_self_intersect_pointers.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/box_intersection_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Triangle__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Triangle_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangle_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Triangle_3&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangles;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangles::iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Box__intersection__d_1_1Box__with__handle__d" kindref="compound">CGAL::Box_intersection_d::Box_with_handle_d&lt;double,3,Iterator&gt;</ref><sp/>Box;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Report<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangles*<sp/>triangles;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Report(Triangles&amp;<sp/>triangles)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>triangles(&amp;triangles)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>callback<sp/>functor<sp/>that<sp/>reports<sp/>all<sp/>truly<sp/>intersecting<sp/>triangles</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box*<sp/>a,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box*<sp/>b)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Box<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(a-&gt;handle()<sp/>-<sp/>triangles-&gt;begin())<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>and<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>(b-&gt;handle()<sp/>-<sp/>triangles-&gt;begin())<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>intersect&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!<sp/>a-&gt;handle()-&gt;is_degenerate()<sp/>&amp;&amp;<sp/>!<sp/>b-&gt;handle()-&gt;is_degenerate()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/><ref refid="group__do__intersect__linear__grp_1ga9514a218a097ac392d21775368d3dd0d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::do_intersect</ref>(<sp/>*(a-&gt;handle()),<sp/>*(b-&gt;handle())))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>and<sp/>the<sp/>triangles<sp/>intersect<sp/>also&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;.&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in((argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/triangles.xyz&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangles<sp/>triangles;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangle_3<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(in<sp/>&gt;&gt;<sp/>t){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>triangles.push_back(t);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>the<sp/>corresponding<sp/>vector<sp/>of<sp/>bounding<sp/>boxes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Box&gt;<sp/>boxes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/>Iterator<sp/>i<sp/>=<sp/>triangles.begin();<sp/>i<sp/>!=<sp/>triangles.end();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boxes.push_back(<sp/>Box(<sp/>i-&gt;bbox(),<sp/>i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>the<sp/>corresponding<sp/>vector<sp/>of<sp/>pointers<sp/>to<sp/>bounding<sp/>boxes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Box<sp/>*&gt;<sp/>ptr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/>std::vector&lt;Box&gt;::iterator<sp/>i<sp/>=<sp/>boxes.begin();<sp/>i<sp/>!=<sp/>boxes.end();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ptr.push_back(<sp/>&amp;*i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>the<sp/>self<sp/>intersection<sp/>algorithm<sp/>with<sp/>all<sp/>defaults<sp/>on<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>indirect<sp/>pointers<sp/>to<sp/>bounding<sp/>boxes.<sp/>Avoids<sp/>copying<sp/>the<sp/>boxes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBoxIntersectionD__box__self__intersection__d_1ga3eed2bdb2a9e49a3fac1bca900087ec7" kindref="member">CGAL::box_self_intersection_d</ref>(<sp/>ptr.begin(),<sp/>ptr.end(),<sp/>Report(triangles));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>A note on performance: The algorithm sorts and partitions the input sequences. It is clearly costly to copy a large box compared to a simple pointer. However, the algorithm benefits from memory locality in the later stages when it copies the boxes, while the pointers would refer to boxes that become wildly scattered in memory. These two effects, copying costs and memory locality, counteract each other. For small box sizes, i.e., small dimension, memory locality wins and one should work with boxes, while for larger box sizes one should work with pointers. The exact threshold depends on the memory hierarchy (caching) of the hardware platform and the size of the boxes, most notably the type used to represent the box coordinates. A concrete example; on a laptop with an Intel Mobile Pentium4 running at 1.80GHz with 512KB cache and 254MB main memory under Linux this version with pointers was 20% faster than the version above that copies the boxes for 10000 boxes, but the picture reversed for 100000 boxes, where the version above that copies the boxes becomes 300% faster.</para><para>Note that switching to the built-in type <computeroutput>float</computeroutput> is supported by the box intersection algorithm, but the interfacing with the CGAL bounding box <computeroutput><ref refid="classCGAL_1_1Bbox__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Bbox_3</ref></computeroutput> would not be that easy. In particular, just converting from the <computeroutput>double</computeroutput> to the <computeroutput>float</computeroutput> representation incurs rounding that needs to be controlled properly, otherwise the box might shrink and one might miss intersections.</para></sect1>
<sect1 id="index_1secboxintersparams">
<title>Example Using the Topology and the Cutoff Parameters</title>
<para>Boxes can be interpreted by the box intersection algorithm as closed or as half-open boxes, see also Section <ref refid="index_1secboxintersdef" kindref="member">Definition</ref>. Closed boxes support zero-width boxes and they can intersect at their boundaries, while half-open boxes always have a positive volume and they only intersect iff their interiors overlap. The choice between closed or half-open boxes is selected with the <computeroutput>topology</computeroutput> parameter and its two values:</para><para><itemizedlist>
<listitem>
<para><computeroutput><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8ae829505cc850e61a5190ade8ad6098b5" kindref="member">Box_intersection_d::HALF_OPEN</ref></computeroutput> and </para></listitem>
<listitem>
<para><computeroutput><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8af287bd8f3714b65e743d5ec571e89b82" kindref="member">Box_intersection_d::CLOSED</ref></computeroutput>. </para></listitem>
</itemizedlist>
</para><para>The example program uses a two-dimensional box with <computeroutput>int</computeroutput> coordinates and <computeroutput>id</computeroutput>-numbers that are by default explicitly stored. We create the same boxes as in the minimal example in Section <ref refid="index_1secboxintersectminimal" kindref="member">Minimal Example for Intersecting Boxes</ref>. We create a <formula id="3">$ 3 \times 3$</formula> grid of <computeroutput>boxes</computeroutput>, and two boxes for the <computeroutput>query</computeroutput> sequence, namely the box at the center and the box from the upper-right corner of the grid.</para><para>We write a more involved callback function object <computeroutput>Report</computeroutput> that stores an output iterator and writes the <computeroutput>id</computeroutput>-number of the box in the first argument to the output iterator. We also provide a small helper function <computeroutput>report()</computeroutput> that simplifies the use of the function object.</para><para>We call the box intersection algorithm twice; once for the default <computeroutput>topology</computeroutput>, which is the closed box topology, and once for the half-open box topology. We sort the resulting output for better readability and verify its correctness with the <computeroutput>check1</computeroutput> and <computeroutput>check2</computeroutput> data. For the closed box topology, the center box in <computeroutput>query</computeroutput> intersects all <computeroutput>boxes</computeroutput>, and the upper-right box in <computeroutput>query</computeroutput> intersects the four boxes of the upper-right quadrant in <computeroutput>boxes</computeroutput>. Almost all intersections are with the box boundaries, thus, for the half-open topology only one intersection remains per <computeroutput>query</computeroutput> box, namely its corresponding box in <computeroutput>boxes</computeroutput>. So, the output of the algorithm will be:</para><para><verbatim>0 1 2 3 4 4 5 5 6 7 7 8 8 
4 8 
</verbatim></para><para>For the second box intersection function call we have to specify the <computeroutput>cutoff</computeroutput> parameter explicitly. See the Section <ref refid="index_1secboxintersperformance" kindref="member">Runtime Performance</ref> below for a detailed discussion.</para><para><linebreak/>
<bold>File</bold> <ref refid="Box_intersection_d_2box_grid_8cpp-example" kindref="compound">Box_intersection_d/box_grid.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/box_intersection_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iterator&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Box__intersection__d_1_1Box__d" kindref="compound">CGAL::Box_intersection_d::Box_d&lt;int,2&gt;</ref><sp/>Box;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>coordinates<sp/>for<sp/>9<sp/>boxes<sp/>of<sp/>a<sp/>grid</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>p[9*4]<sp/><sp/><sp/>=<sp/>{<sp/>0,0,1,1,<sp/><sp/>1,0,2,1,<sp/><sp/>2,0,3,1,<sp/></highlight><highlight class="comment">//<sp/>lower</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,1,1,2,<sp/><sp/>1,1,2,2,<sp/><sp/>2,1,3,2,<sp/></highlight><highlight class="comment">//<sp/>middle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,2,1,3,<sp/><sp/>1,2,2,3,<sp/><sp/>2,2,3,3};</highlight><highlight class="comment">//<sp/>upper</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>9<sp/>boxes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Box<sp/>boxes[9]<sp/>=<sp/>{<sp/>Box(<sp/>p,<sp/><sp/><sp/><sp/>p+<sp/>2),<sp/><sp/>Box(<sp/>p+<sp/>4,<sp/>p+<sp/>6),<sp/><sp/>Box(<sp/>p+<sp/>8,<sp/>p+10),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Box(<sp/>p+12,<sp/>p+14),<sp/><sp/>Box(<sp/>p+16,<sp/>p+18),<sp/><sp/>Box(<sp/>p+20,<sp/>p+22),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Box(<sp/>p+24,<sp/>p+26),<sp/><sp/>Box(<sp/>p+28,<sp/>p+30),<sp/><sp/>Box(<sp/>p+32,<sp/>p+34)};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>2<sp/>selected<sp/>boxes<sp/>as<sp/>query;<sp/>center<sp/>and<sp/>upper<sp/>right</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Box<sp/>query[2]<sp/>=<sp/>{<sp/>Box(<sp/>p+16,<sp/>p+18),<sp/><sp/>Box(<sp/>p+32,<sp/>p+34)};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>callback<sp/>function<sp/>object<sp/>writing<sp/>results<sp/>to<sp/>an<sp/>output<sp/>iterator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>OutputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Report<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref><sp/>it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Report(<sp/><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref><sp/>i)<sp/>:<sp/>it(i)<sp/>{}<sp/></highlight><highlight class="comment">//<sp/>store<sp/>iterator<sp/>in<sp/>object</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>write<sp/>the<sp/>id-number<sp/>of<sp/>box<sp/>a<sp/>to<sp/>the<sp/>output<sp/>iterator<sp/>assuming</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>that<sp/>box<sp/>b<sp/>(the<sp/>query<sp/>box)<sp/>is<sp/>not<sp/>interesting<sp/>in<sp/>the<sp/>result.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box&amp;<sp/>a,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box&amp;)<sp/>{<sp/>*it++<sp/>=<sp/>a.id();<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Iter&gt;<sp/></highlight><highlight class="comment">//<sp/>helper<sp/>function<sp/>to<sp/>create<sp/>the<sp/>function<sp/>object</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Report&lt;Iter&gt;<sp/>report(<sp/>Iter<sp/>it)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Report&lt;Iter&gt;(it);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>the<sp/>intersection<sp/>algorithm<sp/>and<sp/>store<sp/>results<sp/>in<sp/>a<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::size_t&gt;<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" kindref="member">CGAL::box_intersection_d</ref>(<sp/>boxes,<sp/>boxes+9,<sp/>query,<sp/>query+2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>report(<sp/>std::back_inserter(<sp/>result)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>sort,<sp/>check,<sp/>and<sp/>show<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::sort(<sp/>result.begin(),<sp/>result.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::size_t<sp/>check1[13]<sp/>=<sp/>{0,1,2,3,4,4,5,5,6,7,7,8,8};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(result.size()<sp/>==<sp/>13<sp/>&amp;&amp;<sp/>std::equal(check1,check1+13,result.begin()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::copy(<sp/>result.begin(),<sp/>result.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ostream_iterator&lt;std::size_t&gt;(<sp/>std::cout,<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>it<sp/>again<sp/>but<sp/>for<sp/>different<sp/>cutoff<sp/>value<sp/>and<sp/>half-open<sp/>boxes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" kindref="member">CGAL::box_intersection_d</ref>(<sp/>boxes,<sp/>boxes+9,<sp/>query,<sp/>query+2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>report(<sp/>std::back_inserter(<sp/>result)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ptrdiff_t(1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8ae829505cc850e61a5190ade8ad6098b5" kindref="member">CGAL::Box_intersection_d::HALF_OPEN</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>sort,<sp/>check,<sp/>and<sp/>show<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::sort(<sp/>result.begin(),<sp/>result.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::size_t<sp/>check2[2]<sp/><sp/>=<sp/>{4,8};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(result.size()<sp/>==<sp/>2<sp/>&amp;&amp;<sp/>std::equal(check2,<sp/>check2+2,<sp/>result.begin()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::copy(<sp/>result.begin(),<sp/>result.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ostream_iterator&lt;std::size_t&gt;(<sp/>std::cout,<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1secboxintersperformance">
<title>Runtime Performance</title>
<para>The implemented algorithm is described in <ref refid="citelist_1CITEREF_cgal:ze-fsbi-02" kindref="member">[2]</ref> as version two. Its performance depends on a <computeroutput>cutoff</computeroutput> parameter. When the size of both iterator ranges drops below the <computeroutput>cutoff</computeroutput> parameter the function switches from the streamed segment-tree algorithm to the two-way-scan algorithm, see <ref refid="citelist_1CITEREF_cgal:ze-fsbi-02" kindref="member">[2]</ref> for the details.</para><para>The streamed segment-tree algorithm needs <formula id="5">$ O(n \log^d (n) + k)$</formula> worst-case running time and <formula id="6">$ O(n)$</formula> space, where <formula id="7">$ n$</formula> is the number of boxes in both input sequences, <formula id="0">$ d$</formula> the (constant) dimension of the boxes, and <formula id="8">$ k$</formula> the output complexity, i.e., the number of pairwise intersections of the boxes. The two-way-scan algorithm needs <formula id="9">$ O(n \log (n) + l)$</formula> worst-case running time and <formula id="6">$ O(n)$</formula> space, where <formula id="10">$ l$</formula> is the number of pairwise overlapping intervals in one dimensions (the dimension where the algorithm is used instead of the segment tree). Note that <formula id="10">$ l$</formula> is not necessarily related to <formula id="8">$ k$</formula> and using the two-way-scan algorithm is a heuristic.</para><para>Unfortunately, we have no general method to automatically determine an optimal cutoff parameter, since it depends on the used hardware, the runtime ratio between callback runtime and segment-tree runtime, and of course the number of boxes to be checked and their distribution. In cases where the callback runtime is dominant, it may be best to make the threshold parameter small. Otherwise a <computeroutput>cutoff</computeroutput> <formula id="11">$ =\sqrt{n}$</formula> can lead to acceptable results. For well distributed boxes the original paper <ref refid="citelist_1CITEREF_cgal:ze-fsbi-02" kindref="member">[2]</ref> gives optimal cutoffs in the thousands. Anyway, for optimal runtime some experiments to compare different cutoff parameters are recommended.</para><para>To demonstrate that box intersection can be done quite fast, different box sequences are intersected in the range between 4 and 800000 boxes total. We use three-dimensional default boxes of closed topology with <computeroutput>float</computeroutput> coordinates and without additional data fields. The algorithm works directly on the boxes, not on pointer to boxes. Each box intersection is reported to an empty dummy callback.</para><para>For each box set, a near-optimal cutoff parameter is determined using an adaptive approximation. The runtime required for streaming is compared against usual scanning. Results on a Xeon 2.4GHz with 4GB main memory can be seen in <ref refid="index_1fig__fig_benchmark" kindref="member">fig__fig_benchmark</ref>. For a small number of boxes, pure scanning is still faster than streaming with optimal cutoff, which would just delegate the box sets to the scanning algorithm. As there are more and more boxes, the overhead becomes less important.</para><para><anchor id="index_1fig__fig_benchmark"/><image type="html" name="benchmark.png"></image>
 <image type="latex" name="benchmark.png" width="15cm"></image>
  <ref refid="index_1fig__fig_benchmark" kindref="member">fig__fig_benchmark</ref> Runtime comparison between the scanning and the streaming algorithm.  <linebreak/>
</para></sect1>
<sect1 id="index_1Box_intersection_dExample_3">
<title>Example Using a Custom Box Implementation</title>
<para>The example in the previous Section <ref refid="index_1secboxintersparams" kindref="member">Example Using the Topology and the Cutoff Parameters</ref> uses an array to provide the coordinates and then creates another array for the boxes. In the following example we write our own box class <computeroutput>Box</computeroutput> that we can initialize directly with the four coordinates and create the array of boxes directly. We also omit the explicitly stored <computeroutput>id</computeroutput>-number and use the address of the box itself as <computeroutput>id</computeroutput>-number. This works only if the boxes do not change their position, i.e., we work with pointers to the boxes in the intersection algorithm.</para><para>We follow with our own box class <computeroutput>Box</computeroutput> the <computeroutput><ref refid="classBoxIntersectionBox__d" kindref="compound">BoxIntersectionBox_d</ref></computeroutput> concept, which allows us to reuse the default traits implementation, i.e., we can use the same default function call to compute all intersections. See the example in the next section for a self-written traits class. So, in principle, the remainder of the example stays the same and we omit the part from the previous example for brevity that illustrates the half-open box topology.</para><para>The requirements for the box implementation are best studied on the reference manual page of <computeroutput><ref refid="classBoxIntersectionBox__d" kindref="compound">BoxIntersectionBox_d</ref></computeroutput>. In a nutshell, we have to define the type <computeroutput>NT</computeroutput> for the box coordinates and the type <computeroutput>ID</computeroutput> for the <computeroutput>id</computeroutput>-number. Member functions give access to the coordinates and the <computeroutput>id</computeroutput>-number. A static member function returns the dimension.</para><para><linebreak/>
<bold>File</bold> <ref refid="Box_intersection_d_2custom_box_grid_8cpp-example" kindref="compound">Box_intersection_d/custom_box_grid.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/box_intersection_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iterator&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Box<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::ptrdiff_t<sp/>ID;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lo[2],<sp/>hi[2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Box(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lo0,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lo1,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>hi0,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>hi1)<sp/>{<sp/>lo[0]=lo0;<sp/>lo[1]=lo1;<sp/>hi[0]=hi0;<sp/>hi[1]=hi1;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>dimension()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>2;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>min_coord(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>dim)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>lo[dim];<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>max_coord(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>dim)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>hi[dim];<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>id-function<sp/>using<sp/>address<sp/>of<sp/>current<sp/>box,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>requires<sp/>to<sp/>work<sp/>with<sp/>pointers<sp/>to<sp/>boxes<sp/>later</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ptrdiff_t<sp/>id()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(std::ptrdiff_t)(</highlight><highlight class="keyword">this</highlight><highlight class="normal">);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>9<sp/>boxes<sp/>of<sp/>a<sp/>grid</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Box<sp/>boxes[9]<sp/>=<sp/>{<sp/>Box(<sp/>0,0,1,1),<sp/><sp/>Box(<sp/>1,0,2,1),<sp/><sp/>Box(<sp/>2,0,3,1),<sp/></highlight><highlight class="comment">//<sp/>low</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Box(<sp/>0,1,1,2),<sp/><sp/>Box(<sp/>1,1,2,2),<sp/><sp/>Box(<sp/>2,1,3,2),<sp/></highlight><highlight class="comment">//<sp/>middle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Box(<sp/>0,2,1,3),<sp/><sp/>Box(<sp/>1,2,2,3),<sp/><sp/>Box(<sp/>2,2,3,3)};</highlight><highlight class="comment">//<sp/>upper</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>2<sp/>selected<sp/>boxes<sp/>as<sp/>query;<sp/>center<sp/>and<sp/>upper<sp/>right</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Box<sp/>query[2]<sp/>=<sp/>{<sp/>Box(<sp/>1,1,2,2),<sp/><sp/>Box(<sp/>2,2,3,3)};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>With<sp/>the<sp/>special<sp/>id-function<sp/>we<sp/>need<sp/>to<sp/>work<sp/>on<sp/>box<sp/>pointers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Box*<sp/>b_ptr[9]<sp/>=<sp/>{<sp/>boxes,<sp/><sp/><sp/>boxes+1,<sp/>boxes+2,<sp/>boxes+3,<sp/>boxes+4,<sp/>boxes+5,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boxes+6,<sp/>boxes+7,<sp/>boxes+8};</highlight></codeline>
<codeline><highlight class="normal">Box*<sp/>q_ptr[2]<sp/>=<sp/>{<sp/>query,<sp/><sp/><sp/>query+1};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>callback<sp/>function<sp/>object<sp/>writing<sp/>results<sp/>to<sp/>an<sp/>output<sp/>iterator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>OutputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Report<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref><sp/>it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Report(<sp/><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref><sp/>i)<sp/>:<sp/>it(i)<sp/>{}<sp/></highlight><highlight class="comment">//<sp/>store<sp/>iterator<sp/>in<sp/>object</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>write<sp/>the<sp/>position<sp/>with<sp/>respect<sp/>to<sp/>&apos;boxes&apos;<sp/>to<sp/>the<sp/>output<sp/>iterator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>assuming<sp/>that<sp/>box<sp/>b<sp/>(the<sp/>query<sp/>box)<sp/>is<sp/>not<sp/>interesting<sp/>in<sp/>the<sp/>result.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box*<sp/>a,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box*)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*it++<sp/>=<sp/>(<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal">Box*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(a-&gt;id())<sp/>-<sp/>boxes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Iter&gt;<sp/></highlight><highlight class="comment">//<sp/>helper<sp/>function<sp/>to<sp/>create<sp/>the<sp/>function<sp/>object</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Report&lt;Iter&gt;<sp/>report(<sp/>Iter<sp/>it)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Report&lt;Iter&gt;(it);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>the<sp/>intersection<sp/>algorithm<sp/>and<sp/>store<sp/>results<sp/>in<sp/>a<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::size_t&gt;<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" kindref="member">CGAL::box_intersection_d</ref>(<sp/>b_ptr,<sp/>b_ptr+9,<sp/>q_ptr,<sp/>q_ptr+2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>report(<sp/>std::back_inserter(<sp/>result)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ptrdiff_t(0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>sort<sp/>and<sp/>check<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::sort(<sp/>result.begin(),<sp/>result.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::size_t<sp/>chk[13]<sp/>=<sp/>{0,1,2,3,4,4,5,5,6,7,7,8,8};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>result.size()==13<sp/>&amp;&amp;<sp/>std::equal(chk,chk+13,result.begin()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1secbox_inters_example_proximity">
<title>Example for Point Proximity Search with a Custom Traits Class</title>
<para>Given a set of 3D points, we want to find all pairs of points that are less than a certain distance apart. We use the box intersection algorithm to find good candidates, namely those that are less than this specified distance apart in the <formula id="12">$ L_\infty$</formula> norm, which is a good approximation of the Euclidean norm.</para><para>We use an unusual representation for the box, namely pointers to the 3D points themselves. We implement a special box traits class that interprets the point as a box of the dimensions <formula id="13">$ [-$</formula><computeroutput>eps</computeroutput> <formula id="14">$ ,+$</formula><computeroutput>eps</computeroutput> <formula id="15">$ ]^3$</formula> centered at this point. The value for <computeroutput>eps</computeroutput> is half the specified distance from above, i.e., points are reported if their distance is smaller than <computeroutput>2*eps</computeroutput>.</para><para>The requirements for the box traits class are best studied on the reference manual page of <computeroutput><ref refid="classBoxIntersectionTraits__d" kindref="compound">BoxIntersectionTraits_d</ref></computeroutput>. In a nutshell, we have to define the type <computeroutput>NT</computeroutput> for the box coordinates, the type <computeroutput>ID</computeroutput> for the <computeroutput>id</computeroutput>-number, and the type <computeroutput>Box_parameter</computeroutput> similar to the box handle, here <computeroutput>Point_3*</computeroutput> since we work with the pointers. All member functions in the traits class are static. Two functions give access to the max and min coordinates that we compute from the point coordinates plus or minus the <computeroutput>eps</computeroutput> value, respectively. For the <computeroutput>id</computeroutput>-number function the address of the point itself is sufficient, since the points stay stable. Another function returns the dimension.</para><para>The <computeroutput>report</computeroutput> callback function computes than the Euclidean distance and prints a message for points that are close enough.</para><para>Note that we need to reserve sufficient space in the <computeroutput>points</computeroutput> vector to avoid reallocations while we create the <computeroutput>points</computeroutput> vector and the <computeroutput>boxes</computeroutput> vector in parallel, since otherwise the <computeroutput>points</computeroutput> vector might reallocate and invalidate all pointers stored in the <computeroutput>boxes</computeroutput> so far.</para><para><linebreak/>
<bold>File</bold> <ref refid="Box_intersection_d_2proximity_custom_box_traits_8cpp-example" kindref="compound">Box_intersection_d/proximity_custom_box_traits.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/box_intersection_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;float&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::vector&lt;Point_3&gt;<sp/><sp/>points;</highlight></codeline>
<codeline><highlight class="normal">std::vector&lt;Point_3*&gt;<sp/>boxes;<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>boxes<sp/>are<sp/>just<sp/>pointers<sp/>to<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>eps<sp/>=<sp/>0.1f;<sp/></highlight><highlight class="comment">//<sp/>finds<sp/>point<sp/>pairs<sp/>of<sp/>distance<sp/>&lt;<sp/>2*eps</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Boxes<sp/>are<sp/>just<sp/>pointers<sp/>to<sp/>3d<sp/>points.<sp/>The<sp/>traits<sp/>class<sp/>adds<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>+-<sp/>eps<sp/>size<sp/>to<sp/>each<sp/>interval<sp/>around<sp/>the<sp/>point,<sp/>effectively<sp/>building</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>on<sp/>the<sp/>fly<sp/>a<sp/>box<sp/>of<sp/>size<sp/>2*eps<sp/>centered<sp/>at<sp/>the<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Traits<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_3*<sp/><sp/><sp/><sp/><sp/><sp/><sp/>Box_parameter;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::ptrdiff_t<sp/>ID;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/>dimension()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>3;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>coord(<sp/>Box_parameter<sp/>b,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>d)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(d<sp/>==<sp/>0)<sp/>?<sp/>b-&gt;x()<sp/>:<sp/>((d<sp/>==<sp/>1)<sp/>?<sp/>b-&gt;y()<sp/>:<sp/>b-&gt;z());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>min_coord(<sp/>Box_parameter<sp/>b,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>d)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>coord(b,d)-eps;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>max_coord(<sp/>Box_parameter<sp/>b,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>d)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>coord(b,d)+eps;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>id-function<sp/>using<sp/>address<sp/>of<sp/>current<sp/>box,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>requires<sp/>to<sp/>work<sp/>with<sp/>pointers<sp/>to<sp/>boxes<sp/>later</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>std::ptrdiff_t<sp/>id(Box_parameter<sp/>b)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(std::ptrdiff_t)(b);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>callback<sp/>function<sp/>reports<sp/>pairs<sp/>in<sp/>close<sp/>proximity</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>report(<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_3*<sp/>a,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_3*<sp/>b)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>dist<sp/>=<sp/><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">std::sqrt</ref>(<sp/><ref refid="group__squared__distance__grp_1ga1ff73525660a052564d33fbdd61a4f71" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::squared_distance</ref>(<sp/>*a,<sp/>*b));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>dist<sp/>&lt;<sp/>2*eps)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Point<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(a<sp/>-<sp/>&amp;(points.front()))<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>and<sp/>Point<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>(b<sp/>-<sp/>&amp;(points.front()))<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>have<sp/>distance<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dist</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in((argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/points.xyz&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_3<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(in<sp/>&gt;&gt;<sp/>p){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points.push_back(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i&lt;<sp/>points.size();++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boxes.push_back(<sp/>&amp;points[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>the<sp/>intersection<sp/>algorithm<sp/>and<sp/>report<sp/>proximity<sp/>pairs</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBoxIntersectionD__box__self__intersection__d_1ga3eed2bdb2a9e49a3fac1bca900087ec7" kindref="member">CGAL::box_self_intersection_d</ref>(<sp/>boxes.begin(),<sp/>boxes.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>report,<sp/>Traits());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1Box_intersection_dDesign">
<title>Design and Implementation History</title>
<para>Lutz Kettner and Andreas Meyer implemented the algorithms starting from the publication <ref refid="citelist_1CITEREF_cgal:ze-fsbi-02" kindref="member">[2]</ref>. We had access to the original C implementation of Afra Zomorodian, which helped clarifying some questions, and we are grateful to the help of Afra Zomorodian in answering our questions during his visit. We thank Steve Robbins for an excellent review for this package. Steve Robbins provided an independent and earlier implementation of this algorithm, however, we learned too late about this implementation. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
