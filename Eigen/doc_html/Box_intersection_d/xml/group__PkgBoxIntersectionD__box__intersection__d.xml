<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="group__PkgBoxIntersectionD__box__intersection__d" kind="group">
    <compoundname>PkgBoxIntersectionD_box_intersection_d</compoundname>
    <title>CGAL::box_intersection_d()</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class RandomAccessIterator1</type>
          </param>
          <param>
            <type>class RandomAccessIterator2</type>
          </param>
          <param>
            <type>class Callback</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::box_intersection_d</definition>
        <argsstring>(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator2 end2, Callback callback, std::ptrdiff_t cutoff=10, CGAL::Box_intersection_d::Topology topology=CGAL::Box_intersection_d::CLOSED, CGAL::Box_intersection_d::Setting setting=CGAL::Box_intersection_d::BIPARTITE)</argsstring>
        <name>box_intersection_d</name>
        <param>
          <type>RandomAccessIterator1</type>
          <declname>begin1</declname>
        </param>
        <param>
          <type>RandomAccessIterator1</type>
          <declname>end1</declname>
        </param>
        <param>
          <type>RandomAccessIterator2</type>
          <declname>begin2</declname>
        </param>
        <param>
          <type>RandomAccessIterator2</type>
          <declname>end2</declname>
        </param>
        <param>
          <type>Callback</type>
          <declname>callback</declname>
        </param>
        <param>
          <type>std::ptrdiff_t</type>
          <declname>cutoff</declname>
          <defval>10</defval>
        </param>
        <param>
          <type><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8" kindref="member">CGAL::Box_intersection_d::Topology</ref></type>
          <declname>topology</declname>
          <defval><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8af287bd8f3714b65e743d5ec571e89b82" kindref="member">CGAL::Box_intersection_d::CLOSED</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceCGAL_1_1Box__intersection__d_1a7539d6db67bbedc4e4dc9ffe53d13d42" kindref="member">CGAL::Box_intersection_d::Setting</ref></type>
          <declname>setting</declname>
          <defval><ref refid="namespaceCGAL_1_1Box__intersection__d_1a7539d6db67bbedc4e4dc9ffe53d13d42a92e93ad5ad25555be14763a2c2799395" kindref="member">CGAL::Box_intersection_d::BIPARTITE</ref></defval>
        </param>
        <briefdescription>
<para>Invocation of box intersection with default box traits <computeroutput><ref refid="structCGAL_1_1Box__intersection__d_1_1Box__traits__d" kindref="compound">Box_intersection_d::Box_traits_d</ref>&lt;Box_handle&gt;</computeroutput>, where <computeroutput>Box_handle</computeroutput> corresponds to the iterator value type of <computeroutput>RandomAccessIterator1</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/box_intersection_d.h" line="280" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgBoxIntersectionD__box__intersection__d_1ga8d0c33bc98dc6e45bc2e49e8c3fc0cee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class RandomAccessIterator1</type>
          </param>
          <param>
            <type>class RandomAccessIterator2</type>
          </param>
          <param>
            <type>class Callback</type>
          </param>
          <param>
            <type>class BoxTraits</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::box_intersection_d</definition>
        <argsstring>(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator2 end2, Callback callback, BoxTraits box_traits, std::ptrdiff_t cutoff=10, CGAL::Box_intersection_d::Topology topology=CGAL::Box_intersection_d::CLOSED, CGAL::Box_intersection_d::Setting setting=CGAL::Box_intersection_d::BIPARTITE)</argsstring>
        <name>box_intersection_d</name>
        <param>
          <type>RandomAccessIterator1</type>
          <declname>begin1</declname>
        </param>
        <param>
          <type>RandomAccessIterator1</type>
          <declname>end1</declname>
        </param>
        <param>
          <type>RandomAccessIterator2</type>
          <declname>begin2</declname>
        </param>
        <param>
          <type>RandomAccessIterator2</type>
          <declname>end2</declname>
        </param>
        <param>
          <type>Callback</type>
          <declname>callback</declname>
        </param>
        <param>
          <type>BoxTraits</type>
          <declname>box_traits</declname>
        </param>
        <param>
          <type>std::ptrdiff_t</type>
          <declname>cutoff</declname>
          <defval>10</defval>
        </param>
        <param>
          <type><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8" kindref="member">CGAL::Box_intersection_d::Topology</ref></type>
          <declname>topology</declname>
          <defval><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8af287bd8f3714b65e743d5ec571e89b82" kindref="member">CGAL::Box_intersection_d::CLOSED</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceCGAL_1_1Box__intersection__d_1a7539d6db67bbedc4e4dc9ffe53d13d42" kindref="member">CGAL::Box_intersection_d::Setting</ref></type>
          <declname>setting</declname>
          <defval><ref refid="namespaceCGAL_1_1Box__intersection__d_1a7539d6db67bbedc4e4dc9ffe53d13d42a92e93ad5ad25555be14763a2c2799395" kindref="member">CGAL::Box_intersection_d::BIPARTITE</ref></defval>
        </param>
        <briefdescription>
<para>Invocation with custom box traits. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/box_intersection_d.h" line="297" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" kindref="member">box_intersection_d()</ref></computeroutput> computes the pairwise intersecting boxes between two sequences of iso-oriented boxes in arbitrary dimension. </para>    </briefdescription>
    <detaileddescription>
<para>The sequences of boxes are given with two random-access iterator ranges and will be reordered in the course of the algorithm. For each intersecting pair of boxes a <computeroutput>callback</computeroutput> function object is called with the two intersecting boxes as argument; the first argument is a box from the first sequence, the second argument a box from the second sequence. The performance of the algorithm can be tuned with a <computeroutput>cutoff</computeroutput> parameter, see the implementation section below for more details.</para><para>The algorithm reorders the boxes in the course of the algorithm. Now, depending on the size of a box it can be faster to copy the boxes, or to work with pointers to boxes and copy only pointers. We offer automatic support for both options. To simplify the description, let us call the <computeroutput>value_type</computeroutput> of the iterators <emphasis>box handle</emphasis>. The <emphasis>box handle</emphasis> can either be our box type itself or a pointer (or const pointer) to the box type.</para><para>A <formula id="0">$ d$</formula>-dimensional iso-oriented box is defined as the Cartesian product of <formula id="0">$ d$</formula> intervals. We call the box <emphasis>half-open</emphasis> if the <formula id="0">$ d$</formula> intervals <formula id="1">$ \{ [lo_i,hi_i) \,|\, 0 \leq i &lt; d\}$</formula> are half-open intervals, and we call the box <emphasis>closed</emphasis> if the <formula id="0">$ d$</formula> intervals <formula id="2">$ \{ [lo_i,hi_i] \,|\, 0 \leq i &lt; d\}$</formula> are closed intervals. Note that closed boxes support zero-width boxes and they can intersect at their boundaries, while non-empty half-open boxes always have a positive volume and they only intersect iff their interiors overlap. The distinction between closed or half-open boxes does not require a different representation of boxes, just a different interpretation when comparing boxes, which is selected with the <computeroutput>topology</computeroutput> parameter and its two values, <computeroutput><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8ae829505cc850e61a5190ade8ad6098b5" kindref="member">Box_intersection_d::HALF_OPEN</ref></computeroutput> and <computeroutput><ref refid="namespaceCGAL_1_1Box__intersection__d_1ac1b7703e33d0fe5d9d484493189c9cd8af287bd8f3714b65e743d5ec571e89b82" kindref="member">Box_intersection_d::CLOSED</ref></computeroutput>.</para><para>In addition, a box has a unique <computeroutput>id</computeroutput>-number. It is used to order boxes consistently in each dimension even if boxes have identical coordinates. In consequence, the algorithm guarantees that a pair of intersecting boxes is reported only once. Boxes with equal <computeroutput>id</computeroutput>-number are not reported since they obviously intersect trivially.</para><para>The algorithm uses a traits class of the <computeroutput><ref refid="classBoxIntersectionTraits__d" kindref="compound">BoxIntersectionTraits_d</ref></computeroutput> concept to access the boxes. A default traits class is provided that assumes that the box type is a model of the <computeroutput><ref refid="classBoxIntersectionBox__d" kindref="compound">BoxIntersectionBox_d</ref></computeroutput> concept and that the box handle, i.e., the iterators value type, is identical to the box type or a pointer to the box type.</para><para>An important special application of this algorithm is the test for self-intersections where the second box sequence is an identical copy of the first sequence including the preserved <computeroutput>id</computeroutput>-number. Note that this implies that the address of the box is not sufficient for the <computeroutput>id</computeroutput>-number if boxes are copied by value. To ease the use of this special case we offer a simplified version of this function with one iterator range only, which then creates internally the second copy of the boxes, under the name <computeroutput><ref refid="group__PkgBoxIntersectionD__box__self__intersection__d_1ga3eed2bdb2a9e49a3fac1bca900087ec7" kindref="member">box_self_intersection_d()</ref></computeroutput>.</para><para>In the general case, we distinguish between the bipartite case (the boxes are from different sequences) and the complete case (the boxes are from the same sequence, i.e., the self intersection case). The default is the bipartite case, since the complete case is typically handled with the simplified function call mentioned above. However, the general function call offers the <computeroutput>setting</computeroutput> parameter with the values <computeroutput><ref refid="namespaceCGAL_1_1Box__intersection__d_1a7539d6db67bbedc4e4dc9ffe53d13d42a4e3148a70fdfc4e7449a985121ec2252" kindref="member">Box_intersection_d::COMPLETE</ref></computeroutput> and <computeroutput><ref refid="namespaceCGAL_1_1Box__intersection__d_1a7539d6db67bbedc4e4dc9ffe53d13d42a92e93ad5ad25555be14763a2c2799395" kindref="member">Box_intersection_d::BIPARTITE</ref></computeroutput>.</para><para><simplesect kind="warning"><para>The two sequences of boxes passed to <computeroutput><ref refid="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" kindref="member">box_intersection_d()</ref></computeroutput> can be ranges created from the same container, but these ranges must not contain any common element.</para></simplesect>
<bold>Requirements</bold><linebreak/>
</para><para><itemizedlist>
<listitem>
<para><computeroutput>RandomAccessIterator1</computeroutput>, and <formula id="26">$ \ldots$</formula> <computeroutput>2</computeroutput>, must meet the requirements of <computeroutput><ref refid="classRandomAccessIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref></computeroutput> and both value types must be the same. We call this value type <computeroutput>Box_handle</computeroutput> in the following. </para></listitem>
<listitem>
<para><computeroutput>Callback</computeroutput> must be of the <computeroutput>BinaryFunction</computeroutput> concept. The <computeroutput>Box_handle</computeroutput> must be convertible to both argument types. The return type is not used and can be <computeroutput>void</computeroutput>. </para></listitem>
<listitem>
<para>The <computeroutput>Box_handle</computeroutput> must be a model of the <computeroutput><ref refid="classAssignable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Assignable</ref></computeroutput> concept. </para></listitem>
<listitem>
<para>In addition, if the default box traits is used the <computeroutput>Box_handle</computeroutput> must be a class type <computeroutput>T</computeroutput> or a pointer to a class type <computeroutput>T</computeroutput>, where <computeroutput>T</computeroutput> must be a model of the <computeroutput><ref refid="classBoxIntersectionBox__d" kindref="compound">BoxIntersectionBox_d</ref></computeroutput> concept. In both cases, the default box traits specializes to a suitable implementation. </para></listitem>
<listitem>
<para><computeroutput>BoxTraits</computeroutput> must be of the <computeroutput><ref refid="classBoxIntersectionTraits__d" kindref="compound">BoxIntersectionTraits_d</ref></computeroutput> concept. </para></listitem>
</itemizedlist>
</para><para><simplesect kind="see"><para><ref refid="group__PkgBoxIntersectionD__box__self__intersection__d" kindref="compound"><computeroutput>CGAL::box_self_intersection_d()</computeroutput> </ref> </para></simplesect>
<simplesect kind="see"><para><ref refid="group__PkgBoxIntersectionD__box__intersection__all__pairs__d" kindref="compound"><computeroutput>CGAL::box_intersection_all_pairs_d()</computeroutput> </ref> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="structCGAL_1_1Box__intersection__d_1_1Box__traits__d" kindref="compound">CGAL::Box_intersection_d::Box_traits_d</ref>&lt;BoxHandle&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classBoxIntersectionBox__d" kindref="compound">BoxIntersectionBox_d</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classBoxIntersectionTraits__d" kindref="compound">BoxIntersectionTraits_d</ref></computeroutput></para></simplesect>
<bold>Implementation</bold><linebreak/>
</para><para>The implemented algorithm is described in <ref refid="citelist_1CITEREF_cgal:ze-fsbi-02" kindref="member">[2]</ref> as version two. Its performance depends on a <computeroutput>cutoff</computeroutput> parameter. When the size of both iterator ranges drops below the <computeroutput>cutoff</computeroutput> parameter the function switches from the streamed segment-tree algorithm to the two-way-scan algorithm, see <ref refid="citelist_1CITEREF_cgal:ze-fsbi-02" kindref="member">[2]</ref> for the details.</para><para>The streamed segment-tree algorithm needs <formula id="5">$ O(n \log^d (n) + k)$</formula> worst-case running time and <formula id="6">$ O(n)$</formula> space, where <formula id="7">$ n$</formula> is the number of boxes in both input sequences, <formula id="0">$ d$</formula> the (constant) dimension of the boxes, and <formula id="8">$ k$</formula> the output complexity, i.e., the number of pairwise intersections of the boxes. The two-way-scan algorithm needs <formula id="9">$ O(n \log (n) + l)$</formula> worst-case running time and <formula id="6">$ O(n)$</formula> space, where <formula id="10">$ l$</formula> is the number of pairwise overlapping intervals in one dimensions (the dimension where the algorithm is used instead of the segment tree). Note that <formula id="10">$ l$</formula> is not necessarily related to <formula id="8">$ k$</formula> and using the two-way-scan algorithm is a heuristic.</para><para>Unfortunately, we have no general method to automatically determine an optimal cutoff parameter, since it depends on the used hardware, the runtime ratio between callback runtime and segment-tree runtime, and of course the number of boxes to be checked and their distribution. In cases where the callback runtime is dominant, it may be best to make the threshold parameter small. Otherwise a <computeroutput>cutoff</computeroutput> <formula id="11">$ =\sqrt{n}$</formula> can lead to acceptable results. For well distributed boxes the original paper <ref refid="citelist_1CITEREF_cgal:ze-fsbi-02" kindref="member">[2]</ref> gives optimal cutoffs in the thousands. Anyway, for optimal runtime some experiments to compare different cutoff parameters are recommended. See also Section <ref refid="index_1secboxintersperformance" kindref="member">Runtime Performance</ref> .</para><para><bold>Example</bold><linebreak/>
</para><para>The box implementation provided with <computeroutput><ref refid="classCGAL_1_1Box__intersection__d_1_1Box__d" kindref="compound">Box_intersection_d::Box_d</ref>&lt;double,2&gt;</computeroutput> has a special constructor for the CGAL bounding box type <computeroutput><ref refid="classCGAL_1_1Bbox__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Bbox_2</ref></computeroutput> (and similar for dimension 3). We use this in the example to create <formula id="3">$ 3 \times 3$</formula> <computeroutput>boxes</computeroutput> in a grid layout. Additionally we pick the center box and the box in the upper-right corner as our second box sequence <computeroutput>query</computeroutput>.</para><para>The default policy of the box type implements the <computeroutput>id</computeroutput>-number with an explicit counter in the boxes, which is the default choice since it always works. We use the <computeroutput>id</computeroutput>-number in our callback function to report the result of the intersection algorithm call. The result will be that the first <computeroutput>query</computeroutput> box intersects all nine <computeroutput>boxes</computeroutput> and the second <computeroutput>query</computeroutput> box intersects the four boxes in the upper-right quadrant.</para><para><linebreak/>
<bold>File</bold> <ref refid="Box_intersection_d_2minimal_8cpp-example" kindref="compound">Box_intersection_d/minimal.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/box_intersection_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Bbox_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Box__intersection__d_1_1Box__d" kindref="compound">CGAL::Box_intersection_d::Box_d&lt;double,2&gt;</ref><sp/>Box;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Bbox__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Bbox_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bbox;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>9<sp/>boxes<sp/>of<sp/>a<sp/>grid</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Box<sp/>boxes[9]<sp/>=<sp/>{<sp/>Bbox(<sp/>0,0,1,1),<sp/>Bbox(<sp/>1,0,2,1),<sp/>Bbox(<sp/>2,0,3,1),<sp/></highlight><highlight class="comment">//<sp/>low</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bbox(<sp/>0,1,1,2),<sp/>Bbox(<sp/>1,1,2,2),<sp/>Bbox(<sp/>2,1,3,2),<sp/></highlight><highlight class="comment">//<sp/>middle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bbox(<sp/>0,2,1,3),<sp/>Bbox(<sp/>1,2,2,3),<sp/>Bbox(<sp/>2,2,3,3)};</highlight><highlight class="comment">//<sp/>upper</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>2<sp/>selected<sp/>boxes<sp/>as<sp/>query;<sp/>center<sp/>and<sp/>upper<sp/>right</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Box<sp/>query[2]<sp/>=<sp/>{<sp/>Bbox(<sp/>1,1,2,2),<sp/>Bbox(<sp/>2,2,3,3)};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>callback(<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box&amp;<sp/>a,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Box&amp;<sp/>b<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;box<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>a.id()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>intersects<sp/>box<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>b.id()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBoxIntersectionD__box__intersection__d_1ga5526579aad16bc9c3ed830dd8fc58f6a" kindref="member">CGAL::box_intersection_d</ref>(<sp/>boxes,<sp/>boxes+9,<sp/>query,<sp/>query+2,<sp/>callback);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>    </detaileddescription>
  </compounddef>
</doxygen>
