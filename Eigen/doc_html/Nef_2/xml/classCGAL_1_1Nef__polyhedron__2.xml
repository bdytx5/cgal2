<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classCGAL_1_1Nef__polyhedron__2" kind="class" language="C++" prot="public">
    <compoundname>CGAL::Nef_polyhedron_2</compoundname>
    <includes local="no">CGAL/Nef_polyhedron_2.h</includes>
    <innerclass refid="classCGAL_1_1Nef__polyhedron__2_1_1Explorer" prot="public">CGAL::Nef_polyhedron_2::Explorer</innerclass>
    <innerclass refid="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer" prot="public">CGAL::Nef_polyhedron_2::Topological_explorer</innerclass>
    <templateparamlist>
      <param>
        <type>typename</type>
        <declname>T</declname>
        <defname>T</defname>
      </param>
    </templateparamlist>
      <sectiondef kind="user-defined">
      <header>Types</header>
      <memberdef kind="enum" id="classCGAL_1_1Nef__polyhedron__2_1a8cb9d4db15905d56ae4be1d502aab8ff" prot="public" static="no">
        <name>Boundary</name>
        <enumvalue id="classCGAL_1_1Nef__polyhedron__2_1a8cb9d4db15905d56ae4be1d502aab8ffa94a77215e20d6be276e5b7ec032c3139" prot="public">
          <name>EXCLUDED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classCGAL_1_1Nef__polyhedron__2_1a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43" prot="public">
          <name>INCLUDED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>construction selection. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="126" column="1" bodyfile="CGAL/Nef_polyhedron_2.h" bodystart="126" bodyend="126"/>
      </memberdef>
      <memberdef kind="enum" id="classCGAL_1_1Nef__polyhedron__2_1ab5f1c19c50d23c0a759c2d2b1bb60bd0" prot="public" static="no">
        <name>Content</name>
        <enumvalue id="classCGAL_1_1Nef__polyhedron__2_1ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c" prot="public">
          <name>EMPTY</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classCGAL_1_1Nef__polyhedron__2_1ab5f1c19c50d23c0a759c2d2b1bb60bd0acbd2d7c6e526cfad582f001a6a0042a3" prot="public">
          <name>COMPLETE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>construction selection </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="131" column="1" bodyfile="CGAL/Nef_polyhedron_2.h" bodystart="131" bodyend="131"/>
      </memberdef>
      <memberdef kind="enum" id="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abc" prot="public" static="no">
        <name>Location_mode</name>
        <enumvalue id="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af" prot="public">
          <name>DEFAULT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abcaca828eed6da20a9383aeb13ef1dcdbed" prot="public">
          <name>NAIVE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abca775e12588827baac52ff0b8d3dec1616" prot="public">
          <name>LMWT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>selectionflag for the point location mode. </para>        </briefdescription>
        <detaileddescription>
<para>LMWT stands for Locally Minimum Weight Triangulation, a locally optimized constrained triangulation where the weight corresponds to the length of the edges of the triangulation. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="780" column="1" bodyfile="CGAL/Nef_polyhedron_2.h" bodystart="780" bodyend="780"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Nef__polyhedron__2_1a1e0e9aa5868dc87384c1cb65df4b2828" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Nef_polyhedron_2&lt; T &gt;::Line</definition>
        <argsstring></argsstring>
        <name>Line</name>
        <briefdescription>
<para>the oriented lines modeling halfplanes. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="101" column="1" bodyfile="CGAL/Nef_polyhedron_2.h" bodystart="101" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Nef__polyhedron__2_1a5dba79fcf624dbb9e3163f68f4f75e00" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Nef_polyhedron_2&lt; T &gt;::Point</definition>
        <argsstring></argsstring>
        <name>Point</name>
        <briefdescription>
<para>the affine points of the plane. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="106" column="1" bodyfile="CGAL/Nef_polyhedron_2.h" bodystart="106" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Nef__polyhedron__2_1ac5779dcd0d9aa9007e4bafe0bceb3ae4" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Nef_polyhedron_2&lt; T &gt;::Direction</definition>
        <argsstring></argsstring>
        <name>Direction</name>
        <briefdescription>
<para>directions in our plane. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="111" column="1" bodyfile="CGAL/Nef_polyhedron_2.h" bodystart="111" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Nef__polyhedron__2_1ac640be6a8130703344a89ad4859d4867" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Nef_polyhedron_2&lt; T &gt;::Polygons_tag</definition>
        <argsstring></argsstring>
        <name>Polygons_tag</name>
        <briefdescription>
<para>tag for calling polygon constructor. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="116" column="1" bodyfile="CGAL/Nef_polyhedron_2.h" bodystart="116" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Nef__polyhedron__2_1afa372c8392eae26070c04575ec8d198d" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Nef_polyhedron_2&lt; T &gt;::Polylines_tag</definition>
        <argsstring></argsstring>
        <name>Polylines_tag</name>
        <briefdescription>
<para>tag for calling polyline constructor. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="121" column="1" bodyfile="CGAL/Nef_polyhedron_2.h" bodystart="121" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Nef__polyhedron__2_1a2ae6d7ad3ab6fa5417b87d9cfec493af" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Nef_polyhedron_2&lt; T &gt;::Object_handle</definition>
        <argsstring></argsstring>
        <name>Object_handle</name>
        <briefdescription>
<para>a generic handle to an object of the underlying plane map. </para>        </briefdescription>
        <detaileddescription>
<para>The kind of object <computeroutput>(vertex, halfedge, face)</computeroutput> can be determined and the object can be assigned to a corresponding handle by the three functions:</para><para><computeroutput>bool assign(Vertex_const_handle&amp; h, Object_handle)</computeroutput></para><para><computeroutput>bool assign(Halfedge_const_handle&amp; h, Object_handle)</computeroutput></para><para><computeroutput>bool assign(Face_const_handle&amp; h, Object_handle)</computeroutput></para><para>where each function returns <computeroutput>true</computeroutput> iff the assignment to <computeroutput>h</computeroutput> was done. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="772" column="1" bodyfile="CGAL/Nef_polyhedron_2.h" bodystart="772" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Creation</header>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1ab4af61958347b01b464fb87ce06d7571" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Nef_polyhedron_2&lt; T &gt;::Nef_polyhedron_2</definition>
        <argsstring>(Content plane=EMPTY)</argsstring>
        <name>Nef_polyhedron_2</name>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1ab5f1c19c50d23c0a759c2d2b1bb60bd0" kindref="member">Content</ref></type>
          <declname>plane</declname>
          <defval><ref refid="classCGAL_1_1Nef__polyhedron__2_1ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c" kindref="member">EMPTY</ref></defval>
        </param>
        <briefdescription>
<para>creates an instance <computeroutput>N</computeroutput> of type <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt;T&gt;</computeroutput> and initializes it to the empty set if <computeroutput>plane == EMPTY</computeroutput> and to the whole plane if <computeroutput>plane == COMPLETE</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="121" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a5c6718ebe574d776b5cc9c767eff9acf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Nef_polyhedron_2&lt; T &gt;::Nef_polyhedron_2</definition>
        <argsstring>(Line l, Boundary line=INCLUDED)</argsstring>
        <name>Nef_polyhedron_2</name>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1a1e0e9aa5868dc87384c1cb65df4b2828" kindref="member">Line</ref></type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1a8cb9d4db15905d56ae4be1d502aab8ff" kindref="member">Boundary</ref></type>
          <declname>line</declname>
          <defval><ref refid="classCGAL_1_1Nef__polyhedron__2_1a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43" kindref="member">INCLUDED</ref></defval>
        </param>
        <briefdescription>
<para>creates a Nef polyhedron <computeroutput>N</computeroutput> containing the halfplane left of <computeroutput>l</computeroutput> including <computeroutput>l</computeroutput> if <computeroutput>line==INCLUDED</computeroutput>, excluding <computeroutput>l</computeroutput> if <computeroutput>line==EXCLUDED</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="121" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1ab97de249020e516c3e6a599f18a1f745" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Forward_iterator</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>CGAL::Nef_polyhedron_2&lt; T &gt;::Nef_polyhedron_2</definition>
        <argsstring>(Forward_iterator it, Forward_iterator end, Boundary b=INCLUDED)</argsstring>
        <name>Nef_polyhedron_2</name>
        <param>
          <type>Forward_iterator</type>
          <declname>it</declname>
        </param>
        <param>
          <type>Forward_iterator</type>
          <declname>end</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1a8cb9d4db15905d56ae4be1d502aab8ff" kindref="member">Boundary</ref></type>
          <declname>b</declname>
          <defval><ref refid="classCGAL_1_1Nef__polyhedron__2_1a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43" kindref="member">INCLUDED</ref></defval>
        </param>
        <briefdescription>
<para>creates a Nef polyhedron <computeroutput>N</computeroutput> from the simple polygon <computeroutput>P</computeroutput> spanned by the list of points in the iterator range <computeroutput>[it,end)</computeroutput> and including its boundary if <computeroutput>b = INCLUDED</computeroutput> excluding the boundary otherwise. </para>        </briefdescription>
        <detaileddescription>
<para><computeroutput>Forward_iterator</computeroutput> has to be an iterator with value type <computeroutput>Point</computeroutput>. This construction expects that <computeroutput>P</computeroutput> is simple. The degenerate cases where <computeroutput>P</computeroutput> contains no point, one point or spans just one segment (two points) are correctly handled. In all degenerate cases there&apos;s only one unbounded face adjacent to the degenerate polygon. If <computeroutput>b == INCLUDED</computeroutput> then <computeroutput>N</computeroutput> is just the boundary. If <computeroutput>b == EXCLUDED</computeroutput> then <computeroutput>N</computeroutput> is the whole plane without the boundary. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="121" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1ad68e86a3bdeddb587363bf73edaae184" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Forward_iterator</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>CGAL::Nef_polyhedron_2&lt; T &gt;::Nef_polyhedron_2</definition>
        <argsstring>(Forward_iterator it, Forward_iterator end, Polygons_tag)</argsstring>
        <name>Nef_polyhedron_2</name>
        <param>
          <type>Forward_iterator</type>
          <declname>it</declname>
        </param>
        <param>
          <type>Forward_iterator</type>
          <declname>end</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1ac640be6a8130703344a89ad4859d4867" kindref="member">Polygons_tag</ref></type>
        </param>
        <briefdescription>
<para>The iterator range [it, end) defines a set point ranges, each of which defines the boundary of simple polygon. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="121" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1af756cab6f8712b0aaaeddb72f6115aee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Forward_iterator</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>CGAL::Nef_polyhedron_2&lt; T &gt;::Nef_polyhedron_2</definition>
        <argsstring>(Forward_iterator it, Forward_iterator end, Polylines_tag)</argsstring>
        <name>Nef_polyhedron_2</name>
        <param>
          <type>Forward_iterator</type>
          <declname>it</declname>
        </param>
        <param>
          <type>Forward_iterator</type>
          <declname>end</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1afa372c8392eae26070c04575ec8d198d" kindref="member">Polylines_tag</ref></type>
        </param>
        <briefdescription>
<para>The iterator range [it, end) defines a set point ranges, each of which defines a polyline. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="121" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Operations</header>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1ad8a2c296b76e8bb29c715bbabac6654b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CGAL::Nef_polyhedron_2&lt; T &gt;::clear</definition>
        <argsstring>(Content plane=EMPTY)</argsstring>
        <name>clear</name>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1ab5f1c19c50d23c0a759c2d2b1bb60bd0" kindref="member">Content</ref></type>
          <declname>plane</declname>
          <defval><ref refid="classCGAL_1_1Nef__polyhedron__2_1ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c" kindref="member">EMPTY</ref></defval>
        </param>
        <briefdescription>
<para>makes <computeroutput>N</computeroutput> the empty set if <computeroutput>plane == EMPTY</computeroutput> and the full plane if <computeroutput>plane == COMPLETE</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="200" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a5014cbf16cdb80a88729b259741bf16f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Nef_polyhedron_2&lt; T &gt;::is_empty</definition>
        <argsstring>()</argsstring>
        <name>is_empty</name>
        <briefdescription>
<para>returns true if <computeroutput>N</computeroutput> is empty, false otherwise. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="206" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1ada3ed3315cae400bdfdfcac4c9be5bce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Nef_polyhedron_2&lt; T &gt;::is_plane</definition>
        <argsstring>()</argsstring>
        <name>is_plane</name>
        <briefdescription>
<para>returns true if <computeroutput>N</computeroutput> is the whole plane, false otherwise. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="212" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a8de0d51fb5bc6e9e73f87047fa0f1f3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Nef_polyhedron_2&lt; T &gt;::contains</definition>
        <argsstring>(Object_handle h)</argsstring>
        <name>contains</name>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1a2ae6d7ad3ab6fa5417b87d9cfec493af" kindref="member">Object_handle</ref></type>
          <declname>h</declname>
        </param>
        <briefdescription>
<para>returns true iff the object <computeroutput>h</computeroutput> is contained in the set represented by <computeroutput>N</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="792" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1ae40387867733e7ddc47f5a29f33cac02" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Nef_polyhedron_2&lt; T &gt;::contained_in_boundary</definition>
        <argsstring>(Object_handle h)</argsstring>
        <name>contained_in_boundary</name>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1a2ae6d7ad3ab6fa5417b87d9cfec493af" kindref="member">Object_handle</ref></type>
          <declname>h</declname>
        </param>
        <briefdescription>
<para>returns true iff the object <computeroutput>h</computeroutput> is contained in the <formula id="15">$ 1$</formula>-skeleton of <computeroutput>N</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="799" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a1eca334fed696603f7bed85da151582c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1a2ae6d7ad3ab6fa5417b87d9cfec493af" kindref="member">Object_handle</ref></type>
        <definition>Object_handle CGAL::Nef_polyhedron_2&lt; T &gt;::locate</definition>
        <argsstring>(const Point &amp;p, Location_mode m=DEFAULT)</argsstring>
        <name>locate</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Nef__polyhedron__2_1a5dba79fcf624dbb9e3163f68f4f75e00" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abc" kindref="member">Location_mode</ref></type>
          <declname>m</declname>
          <defval><ref refid="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af" kindref="member">DEFAULT</ref></defval>
        </param>
        <briefdescription>
<para>returns a generic handle <computeroutput>h</computeroutput> to an object (face, halfedge, vertex) of the underlying plane map that contains the point <computeroutput>p</computeroutput> in its relative interior. </para>        </briefdescription>
        <detaileddescription>
<para>The point <computeroutput>p</computeroutput> is contained in the set represented by <computeroutput>N</computeroutput> if <computeroutput>N.contains(h)</computeroutput> is true. The location mode flag <computeroutput>m</computeroutput> allows one to choose between different point location strategies. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="809" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a59903a8983c436a9be57e4bf9d49cfd8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1a2ae6d7ad3ab6fa5417b87d9cfec493af" kindref="member">Object_handle</ref></type>
        <definition>Object_handle CGAL::Nef_polyhedron_2&lt; T &gt;::ray_shoot</definition>
        <argsstring>(const Point &amp;p, const Direction &amp;d, Location_mode m=DEFAULT)</argsstring>
        <name>ray_shoot</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Nef__polyhedron__2_1a5dba79fcf624dbb9e3163f68f4f75e00" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Nef__polyhedron__2_1ac5779dcd0d9aa9007e4bafe0bceb3ae4" kindref="member">Direction</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abc" kindref="member">Location_mode</ref></type>
          <declname>m</declname>
          <defval><ref refid="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af" kindref="member">DEFAULT</ref></defval>
        </param>
        <briefdescription>
<para>returns a handle <computeroutput>h</computeroutput> with <computeroutput>N.contains(h)</computeroutput>, that can be converted to a <computeroutput>Vertex_/Halfedge_/Face_const_handle</computeroutput> as described above. </para>        </briefdescription>
        <detaileddescription>
<para>The object returned is intersected by the ray starting in <computeroutput>p</computeroutput> with direction <computeroutput>d</computeroutput> and has minimal distance to <computeroutput>p</computeroutput>. The operation returns an empty <computeroutput>Object_handle</computeroutput> if the ray shoot along <computeroutput>d</computeroutput> does not hit any object <computeroutput>h</computeroutput> of <computeroutput>N</computeroutput> with <computeroutput>N.contains(h)</computeroutput>. The location mode flag <computeroutput>m</computeroutput> allows one to choose between different point location strategies. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="823" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a7e858bf751d797d0299e312238bd0688" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1a2ae6d7ad3ab6fa5417b87d9cfec493af" kindref="member">Object_handle</ref></type>
        <definition>Object_handle CGAL::Nef_polyhedron_2&lt; T &gt;::ray_shoot_to_boundary</definition>
        <argsstring>(const Point &amp;p, const Direction &amp;d, Location_mode m=DEFAULT)</argsstring>
        <name>ray_shoot_to_boundary</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Nef__polyhedron__2_1a5dba79fcf624dbb9e3163f68f4f75e00" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Nef__polyhedron__2_1ac5779dcd0d9aa9007e4bafe0bceb3ae4" kindref="member">Direction</ref> &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abc" kindref="member">Location_mode</ref></type>
          <declname>m</declname>
          <defval><ref refid="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af" kindref="member">DEFAULT</ref></defval>
        </param>
        <briefdescription>
<para>returns a handle <computeroutput>h</computeroutput>, that can be converted to a <computeroutput>Vertex_/Halfedge_const_handle</computeroutput> as described above. </para>        </briefdescription>
        <detaileddescription>
<para>The object returned is part of the <formula id="15">$ 1$</formula>-skeleton of <computeroutput>N</computeroutput>, intersected by the ray starting in <computeroutput>p</computeroutput> with direction <computeroutput>d</computeroutput> and has minimal distance to <computeroutput>p</computeroutput>. The operation returns an empty <computeroutput>Object_handle</computeroutput> if the ray shoot along <computeroutput>d</computeroutput> does not hit any <formula id="15">$ 1$</formula>-skeleton object <computeroutput>h</computeroutput> of <computeroutput>N</computeroutput>. The location mode flag <computeroutput>m</computeroutput> allows one to choose between different point location strategies. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="837" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a067bf42f1a6b9b13a6fcc45baa30299b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2_1_1Explorer" kindref="compound">Explorer</ref></type>
        <definition>Explorer CGAL::Nef_polyhedron_2&lt; T &gt;::explorer</definition>
        <argsstring>()</argsstring>
        <name>explorer</name>
        <briefdescription>
<para>returns a decorator object that allows read-only access of the underlying plane map. </para>        </briefdescription>
        <detaileddescription>
<para>See the manual page <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2_1_1Explorer" kindref="compound">Explorer</ref></computeroutput> for its usage. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="846" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Constructive Operations</header>
      <description><para>Additionally there are operators <computeroutput>*,+,-,^,!</computeroutput> which implement the binary operations <emphasis>intersection</emphasis>, <emphasis>join</emphasis>, <emphasis>difference</emphasis>, <emphasis>symmetric difference</emphasis>, and the unary operation <emphasis>complement</emphasis>, respectively.</para><para>There are also the corresponding modification operations There are also comparison operations like <computeroutput>&lt;,&lt;=,&gt;,&gt;=,==,!=</computeroutput> which implement the relations subset, subset or equal, superset, superset or equal, equality, inequality, respectively. </para></description>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a6d563177e49fd01a39e44f1183797a96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt;</type>
        <definition>Nef_polyhedron_2&lt;T&gt; CGAL::Nef_polyhedron_2&lt; T &gt;::complement</definition>
        <argsstring>()</argsstring>
        <name>complement</name>
        <briefdescription>
<para>returns the complement of <computeroutput>N</computeroutput> in the plane. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="231" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a3b82c78fe42d878d9418023fe02590f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt;</type>
        <definition>Nef_polyhedron_2&lt;T&gt; CGAL::Nef_polyhedron_2&lt; T &gt;::interior</definition>
        <argsstring>()</argsstring>
        <name>interior</name>
        <briefdescription>
<para>returns the interior of <computeroutput>N</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="237" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a7250e12e77f1d7e64a773243cb413b8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt;</type>
        <definition>Nef_polyhedron_2&lt;T&gt; CGAL::Nef_polyhedron_2&lt; T &gt;::closure</definition>
        <argsstring>()</argsstring>
        <name>closure</name>
        <briefdescription>
<para>returns the closure of <computeroutput>N</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="243" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a5caead26e295b819211f52c2e616b568" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt;</type>
        <definition>Nef_polyhedron_2&lt;T&gt; CGAL::Nef_polyhedron_2&lt; T &gt;::boundary</definition>
        <argsstring>()</argsstring>
        <name>boundary</name>
        <briefdescription>
<para>returns the boundary of <computeroutput>N</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="249" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a1d0ed6d7b4eb2a47d449c097cdc5cfff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt;</type>
        <definition>Nef_polyhedron_2&lt;T&gt; CGAL::Nef_polyhedron_2&lt; T &gt;::regularization</definition>
        <argsstring>()</argsstring>
        <name>regularization</name>
        <briefdescription>
<para>returns the regularized polyhedron (closure of interior). </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="255" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1ab341639df2691491b20e8adf96b94d62" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt;</type>
        <definition>Nef_polyhedron_2&lt;T&gt; CGAL::Nef_polyhedron_2&lt; T &gt;::intersection</definition>
        <argsstring>(const Nef_polyhedron_2&lt; T &gt; &amp;N1)</argsstring>
        <name>intersection</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt; &amp;</type>
          <declname>N1</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>N</computeroutput> <formula id="5">$ \cap$</formula> <computeroutput>N1</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="261" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1acfd32f367b34bb3fd67028b61082888b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt;</type>
        <definition>Nef_polyhedron_2&lt;T&gt; CGAL::Nef_polyhedron_2&lt; T &gt;::join</definition>
        <argsstring>(const Nef_polyhedron_2&lt; T &gt; &amp;N1)</argsstring>
        <name>join</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt; &amp;</type>
          <declname>N1</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>N</computeroutput> <formula id="6">$ \cup$</formula> <computeroutput>N1</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>Note that &quot;union&quot; is a keyword of C++ and cannot be used for this operation. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="268" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1a6a312aa40e2b58167279881c1d14d62f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt;</type>
        <definition>Nef_polyhedron_2&lt;T&gt; CGAL::Nef_polyhedron_2&lt; T &gt;::difference</definition>
        <argsstring>(const Nef_polyhedron_2&lt; T &gt; &amp;N1)</argsstring>
        <name>difference</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt; &amp;</type>
          <declname>N1</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>N</computeroutput> <formula id="7">$ -$</formula> <computeroutput>N1</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="274" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Nef__polyhedron__2_1ab33879f34f12f89054eff83437dd34f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt;</type>
        <definition>Nef_polyhedron_2&lt;T&gt; CGAL::Nef_polyhedron_2&lt; T &gt;::symmetric_difference</definition>
        <argsstring>(const Nef_polyhedron_2&lt; T &gt; &amp;N1)</argsstring>
        <name>symmetric_difference</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; T &gt; &amp;</type>
          <declname>N1</declname>
        </param>
        <briefdescription>
<para>returns the symmectric difference <computeroutput>N - T</computeroutput> <formula id="6">$ \cup$</formula> <computeroutput>T - N</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Nef_polyhedron_2.h" line="280" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-type">
      </sectiondef>
    <briefdescription>
<para>An instance of data type <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt;T&gt;</computeroutput> is a subset of the plane that is the result of forming complements and intersections starting from a finite set <computeroutput>H</computeroutput> of halfspaces. </para>    </briefdescription>
    <detaileddescription>
<para><computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref></computeroutput> is closed under all binary set operations <computeroutput>intersection</computeroutput>, <computeroutput>union</computeroutput>, <computeroutput>difference</computeroutput>, <computeroutput>complement</computeroutput> and under the topological operations <computeroutput>boundary</computeroutput>, <computeroutput>closure</computeroutput>, and <computeroutput>interior</computeroutput>.</para><para>The template parameter <computeroutput>T</computeroutput> is specified via an extended kernel concept. <computeroutput>T</computeroutput> must be a model of the concept <computeroutput><ref refid="classExtendedKernelTraits__2" kindref="compound">ExtendedKernelTraits_2</ref></computeroutput>.</para><para><bold>Exploration - Point location - Ray shooting</bold><linebreak/>
</para><para>As Nef polyhedra are the result of forming complements and intersections starting from a set <computeroutput>H</computeroutput> of halfspaces that are defined by oriented lines in the plane, they can be represented by an attributed plane map <formula id="0">$ M = (V,E,F)$</formula>. For topological queries within <computeroutput>M</computeroutput> the following types and operations allow exploration access to this structure.</para><para><bold>Implementation</bold><linebreak/>
</para><para>Nef polyhedra are implemented on top of a halfedge data structure and use linear space in the number of vertices, edges and facets. Operations like <computeroutput>empty</computeroutput> take constant time. The operations <computeroutput>clear</computeroutput>, <computeroutput>complement</computeroutput>, <computeroutput>interior</computeroutput>, <computeroutput>closure</computeroutput>, <computeroutput>boundary</computeroutput>, <computeroutput>regularization</computeroutput>, input and output take linear time. All binary set operations and comparison operations take time <formula id="1">$ O(n \log n)$</formula> where <formula id="2">$ n$</formula> is the size of the output plus the size of the input.</para><para>The point location and ray shooting operations are implemented in two flavors. The <computeroutput>NAIVE</computeroutput> operations run in linear query time without any preprocessing, the <computeroutput>DEFAULT</computeroutput> operations (equals <computeroutput>LMWT</computeroutput>) run in sub-linear query time, but preprocessing is triggered with the first operation. Preprocessing takes time <formula id="3">$ O(N^2)$</formula>, the sub-linear point location time is either logarithmic when LEDA&apos;s persistent dictionaries are present or if not then the point location time is worst-case linear, but experiments show often sublinear runtimes. Ray shooting equals point location plus a walk in the constrained triangulation overlayed on the plane map representation. The cost of the walk is proportional to the number of triangles passed in direction <computeroutput>d</computeroutput> until an obstacle is met. In a minimum weight triangulation of the obstacles (the plane map representing the polyhedron) the theory provides a <formula id="4">$ O(\sqrt{n})$</formula> bound for the number of steps. Our locally minimum weight triangulation approximates the minimum weight triangulation only heuristically (the calculation of the minimum weight triangulation is conjectured to be NP hard). Thus we have no runtime guarantee but a strong experimental motivation for its approximation.</para><para><bold>Example</bold><linebreak/>
</para><para>Nef polyhedra are parameterized by a so-called extended geometric kernel. There are three kernels, one based on a homogeneous representation of extended points called <computeroutput><ref refid="classCGAL_1_1Extended__homogeneous" kindref="compound">Extended_homogeneous</ref>&lt;RT&gt;</computeroutput> where <computeroutput>RT</computeroutput> is a ring type providing additionally a <computeroutput>gcd</computeroutput> operation, one based on a Cartesian representation of extended points called <computeroutput><ref refid="classCGAL_1_1Extended__cartesian" kindref="compound">Extended_cartesian</ref>&lt;NT&gt;</computeroutput> where <computeroutput>NT</computeroutput> is a field type, and finally <computeroutput><ref refid="classCGAL_1_1Filtered__extended__homogeneous" kindref="compound">Filtered_extended_homogeneous</ref>&lt;RT&gt;</computeroutput> (an optimized version of the first). The following example uses the filtered homogeneous kernel to construct the intersection of two halfspaces.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_2_2nef_2_intersection_8cpp-example" kindref="compound">Nef_2/nef_2_intersection.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Filtered_extended_homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_integer</ref><sp/>RT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Filtered__extended__homogeneous" kindref="compound">CGAL::Filtered_extended_homogeneous&lt;RT&gt;</ref><sp/>Extended_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">CGAL::Nef_polyhedron_2&lt;Extended_kernel&gt;</ref><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Line<sp/><sp/><ref refid="classCGAL_1_1Nef__polyhedron__2_1a1e0e9aa5868dc87384c1cb65df4b2828" kindref="member">Line</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N1(<ref refid="classCGAL_1_1Nef__polyhedron__2_1a1e0e9aa5868dc87384c1cb65df4b2828" kindref="member">Line</ref>(1,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N2(<ref refid="classCGAL_1_1Nef__polyhedron__2_1a1e0e9aa5868dc87384c1cb65df4b2828" kindref="member">Line</ref>(0,1,0),<sp/>Nef_polyhedron::EXCLUDED);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N3<sp/>=<sp/>N1<sp/>*<sp/>N2;<sp/></highlight><highlight class="comment">//<sp/>line<sp/>(*)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>After line (*) <computeroutput>N3</computeroutput> is the intersection of <computeroutput>N1</computeroutput> and <computeroutput>N2</computeroutput>. The member types of <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt; <ref refid="classCGAL_1_1Extended__homogeneous" kindref="compound">Extended_homogeneous</ref>&lt;NT&gt; &gt;</computeroutput> map to corresponding types of the standard CGAL geometry kernel (type equality in pseudo-code notation):</para><para><programlisting><codeline><highlight class="normal"><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">CGAL::Nef_polyhedron_2&lt; CGAL::Extended_cartesian&lt; FT &gt;</ref><sp/>&gt;::Point<sp/>==<sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;FT&gt;::Point_2</ref><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">CGAL::Nef_polyhedron_2&lt; CGAL::Extended_homogeneous&lt; RT &gt;</ref><sp/>&gt;::Point<sp/>==<sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt; RT &gt;::Point_2</ref></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">CGAL::Nef_polyhedron_2&lt; CGAL::Filtered_extended_homogeneous&lt;RT&gt;</ref><sp/>&gt;::Point<sp/>==<sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;RT&gt;::Point_2</ref><sp/></highlight></codeline>
</programlisting></para><para>The same holds for the types <computeroutput>Line</computeroutput> and <computeroutput>Direction</computeroutput> in the local scope of <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt;...&gt;</computeroutput>. </para>    </detaileddescription>
    <location file="CGAL/Nef_polyhedron_2.h" line="92" column="1" bodyfile="CGAL/Nef_polyhedron_2.h" bodystart="92" bodyend="850"/>
    <listofallmembers>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a8cb9d4db15905d56ae4be1d502aab8ff" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Boundary</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a5caead26e295b819211f52c2e616b568" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>boundary</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ad8a2c296b76e8bb29c715bbabac6654b" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>clear</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a7250e12e77f1d7e64a773243cb413b8f" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>closure</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a6d563177e49fd01a39e44f1183797a96" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>complement</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ab5f1c19c50d23c0a759c2d2b1bb60bd0acbd2d7c6e526cfad582f001a6a0042a3" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>COMPLETE</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ae40387867733e7ddc47f5a29f33cac02" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>contained_in_boundary</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a8de0d51fb5bc6e9e73f87047fa0f1f3f" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>contains</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ab5f1c19c50d23c0a759c2d2b1bb60bd0" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Content</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>DEFAULT</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a6a312aa40e2b58167279881c1d14d62f" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>difference</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ac5779dcd0d9aa9007e4bafe0bceb3ae4" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Direction</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>EMPTY</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a8cb9d4db15905d56ae4be1d502aab8ffa94a77215e20d6be276e5b7ec032c3139" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>EXCLUDED</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a067bf42f1a6b9b13a6fcc45baa30299b" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>explorer</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>INCLUDED</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a3b82c78fe42d878d9418023fe02590f9" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>interior</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ab341639df2691491b20e8adf96b94d62" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>intersection</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a5014cbf16cdb80a88729b259741bf16f" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>is_empty</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ada3ed3315cae400bdfdfcac4c9be5bce" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>is_plane</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1acfd32f367b34bb3fd67028b61082888b" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>join</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a1e0e9aa5868dc87384c1cb65df4b2828" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Line</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abca775e12588827baac52ff0b8d3dec1616" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>LMWT</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a1eca334fed696603f7bed85da151582c" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>locate</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abc" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Location_mode</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1aa7cddcb2fffffe488f897da1f3cf4abcaca828eed6da20a9383aeb13ef1dcdbed" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>NAIVE</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ab4af61958347b01b464fb87ce06d7571" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Nef_polyhedron_2</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a5c6718ebe574d776b5cc9c767eff9acf" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Nef_polyhedron_2</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ab97de249020e516c3e6a599f18a1f745" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Nef_polyhedron_2</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ad68e86a3bdeddb587363bf73edaae184" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Nef_polyhedron_2</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1af756cab6f8712b0aaaeddb72f6115aee" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Nef_polyhedron_2</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a2ae6d7ad3ab6fa5417b87d9cfec493af" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Object_handle</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a5dba79fcf624dbb9e3163f68f4f75e00" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Point</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ac640be6a8130703344a89ad4859d4867" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Polygons_tag</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1afa372c8392eae26070c04575ec8d198d" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>Polylines_tag</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a59903a8983c436a9be57e4bf9d49cfd8" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>ray_shoot</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a7e858bf751d797d0299e312238bd0688" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>ray_shoot_to_boundary</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1a1d0ed6d7b4eb2a47d449c097cdc5cfff" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>regularization</name></member>
      <member refid="classCGAL_1_1Nef__polyhedron__2_1ab33879f34f12f89054eff83437dd34f0" prot="public" virt="non-virtual"><scope>CGAL::Nef_polyhedron_2</scope><name>symmetric_difference</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
