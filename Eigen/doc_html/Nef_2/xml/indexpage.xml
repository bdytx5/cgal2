<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Boolean_Operations_on_Nef_Polygons"/><anchor id="index_1chapnef2"/> <simplesect kind="author"><para>Michael Seel</para></simplesect>
</para><sect1 id="index_1Nef_2Introduction">
<title>Introduction</title>
<para>When working with polygonal and polyhedral sets, the mathematical model determines the kind of point set that can be represented. Nef polyhedra are the most general rectilinear polyhedral model.</para><para>Topological simpler models that are contained in the domain of Nef polyhedra are: <itemizedlist>
<listitem>
<para><emphasis>convex polytopes</emphasis> normally defined as the convex hull of a nonempty finite set of points. Convex polytopes are compact closed and manifold sets. </para></listitem>
<listitem>
<para><emphasis>elementary polyhedra</emphasis> normally defined as the union of a finite number of convex polytopes. </para></listitem>
<listitem>
<para><emphasis>polyhedral sets</emphasis> nomally defined as the intersection of a finite number of closed halfspaces. Such sets are closed and convex but need not to be compact. </para></listitem>
<listitem>
<para><emphasis>linear polyhedra</emphasis> normally defined as the set of all points belonging to the simplices of a <emphasis>simplicial complex</emphasis>. </para></listitem>
</itemizedlist>
</para><para>A planar <emphasis>Nef polyhedron</emphasis> is any set that can be obtained from a finite set of open halfspaces by set complement and set intersection operations. Due to the fact that all other binary set operations like union, difference and symmetric difference can be reduced to intersection and complement calculations, Nef polyhedra are also closed under those operations. Apart from the set complement operation there are more topological unary set operations that are closed in the domain of Nef polyhedra. Given a Nef polyhedron one can determine its interior, its boundary, and its closure, and also composed operations like regularization (defined to be the closure of the interior or a point set).</para><para><anchor id="index_1fig__nefexamples"/><image type="html" name="halfplane.png"></image>
 <image type="latex" name="halfplane.png" width="15cm"></image>
  <ref refid="index_1fig__nefexamples" kindref="member">fig__nefexamples</ref> Two Nef polyhedra in the plane. A closed halfspace on the left and a complex polyhedron on the right. Note that the points on the squared boundary are at infinity.  <linebreak/>
</para></sect1>
<sect1 id="index_1Nef_2Construction">
<title>Construction and Composition</title>
<para>Following the above definition, the data type <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt;T&gt;</computeroutput> allows construction of elementary Nef polyhedra and the binary and unary composition by the mentioned set operations.</para><para>In the following examples skip the typedefs at the beginning at first and take the types <computeroutput>Point</computeroutput> and <computeroutput>Line</computeroutput> to be models of the standard two-dimensional CGAL kernel (<computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>&lt;K&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Line__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Line_2</ref>&lt;K&gt;</computeroutput>). Their user interface is thus defined in the corresponding reference pages.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_2_2nef_2_construction_8cpp-example" kindref="compound">Nef_2/nef_2_construction.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Filtered_extended_homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_integer</ref><sp/>RT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Filtered__extended__homogeneous" kindref="compound">CGAL::Filtered_extended_homogeneous&lt;RT&gt;</ref><sp/>Extended_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">CGAL::Nef_polyhedron_2&lt;Extended_kernel&gt;</ref><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Point<sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Line<sp/><sp/>Line;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N1(Nef_polyhedron::COMPLETE);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Line<sp/>l(2,4,2);<sp/></highlight><highlight class="comment">//<sp/>l<sp/>:<sp/>2x<sp/>+<sp/>4y<sp/>+<sp/>2<sp/>=<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N2(l,Nef_polyhedron::INCLUDED);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N3<sp/>=<sp/>N2.complement();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N1<sp/>==<sp/>N2.join(N3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p1(0,0),<sp/>p2(10,10),<sp/>p3(-20,15);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>triangle[3]<sp/>=<sp/>{<sp/>p1,<sp/>p2,<sp/>p3<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N4(triangle,<sp/>triangle+3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N5<sp/>=<sp/>N2.intersection(N4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N5<sp/>&lt;=<sp/>N2<sp/>&amp;&amp;<sp/>N5<sp/>&lt;=<sp/>N4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Planar halfspaces (as used in the definition) are modelled by oriented lines. In the previous example <computeroutput>N1</computeroutput> is the Nef polyhedron representing the full plane, <computeroutput>N2</computeroutput> is the closed halfspace left of the oriented line with equation <formula id="37">$ 2x + 4y + 2 = 0$</formula> including the line, <computeroutput>N3</computeroutput> is the complement of <computeroutput>N2</computeroutput> and therefore it must hold that <formula id="38">$ N2 \cup N3 = N1$</formula>.</para><para>Additionally one can construct Nef polyhedra from iterator ranges that hold simple polygonal chains. In the example <computeroutput>N4</computeroutput> is the triangle spanned by the vertices <formula id="39">$ (0,0)$</formula>, <formula id="40">$ (10,10)$</formula>, <formula id="41">$ (-20,15)$</formula>. Note that the construction from a simple polygonal chain has several cases and preconditions that are described in the reference manual page of <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt;T&gt;</computeroutput>. The <computeroutput>operator&lt;=</computeroutput> in the last assertion is a subset-or-equal comparison of two polyhedra.</para><para>Nef polyhedra have input and output operators that allows one to output them via streams and read them from streams. Graphical output is currently possible. For an elaborate example see the demo programs in the directory <computeroutput>demo/Nef_2</computeroutput>.</para></sect1>
<sect1 id="index_1Nef_2Exploration">
<title>Exploration</title>
<para>By recursively composing binary and unary operations one can end with a very complex rectilinear structure. To explore that structure there is a data type <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2_1_1Explorer" kindref="compound">Nef_polyhedron_2::Explorer</ref></computeroutput> that allows read-only exploration of the rectilinear structure. To understand its usability we need more knowledge about the representation of Nef polyhedra.</para><para>The rectilinear structure underlying a Nef polyhedron is stored in a selective plane map. Plane map here means a straightline embedded bidirected graph with face objects such that each point in the plane can be uniquely assigned to an object (vertex, edge, face) of the planar subdivision defined by the graph. Selective means that each object (vertex, edge, face) has a Boolean value associated with it to indicate set inclusion or exclusion.</para><para>The plane map is defined by the interface data type <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer" kindref="compound">Nef_polyhedron_2::Topological_explorer</ref></computeroutput>. Embedding the vertices by standard affine points does not suffice to model the unboundedness of halfspaces and ray-like structures. Therefore the planar subdivision is bounded symbolically by an axis-parallel square box of infimaximal size centered at the origin of our coordinate system. All structures extending to infinity are pruned by the box. Lines and rays have symbolic endpoints on the box. Faces are circularly closed. Infimaximal here means that its geometric extend is always large enough (but finite for our intuition). Assume you approach the box with an affine point, then this point is always inside the box. The same holds for straight lines; they always intersect the box. There are more accurate notions of &quot;large enough&quot;, but the previous propositions are enough at this point. Due to the fact that the infimaximal box is included in the plane map, the vertices and edges are partitioned with respect to this box.</para><para>Vertices inside the box are called standard vertices and they are embedded by affine points of type <computeroutput>Explorer::Point</computeroutput>. Vertices on the box are called non-standard vertices and they get their embedding where a ray intersects the box (their embedding is defined by an object of type <computeroutput>Explorer::Ray</computeroutput>). By their straightline embedding, edges represent either segments, rays, lines, or box segments depending on the character of their source and target vertices.</para><para>During exploration, box objects can be tracked down by the interface of <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2_1_1Explorer" kindref="compound">Nef_polyhedron_2::Explorer</ref></computeroutput> that is derived from <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer" kindref="compound">Nef_polyhedron_2::Topological_explorer</ref></computeroutput> and adds just the box exploration functionality to the interface of the latter. In the following code fragment we iterate over all vertices of a Nef polyhedron and check whether their embedding is an affine point or a point on the infimaximal frame.</para><para><programlisting><codeline><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Explorer<sp/>Explorer;</highlight></codeline>
<codeline><highlight class="normal">Explorer<sp/>E<sp/>=<sp/>N4.explorer();</highlight></codeline>
<codeline><highlight class="normal">Explorer::Vertex_const_iterator<sp/>v;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(v<sp/>=<sp/>E.vertices_begin();<sp/>v<sp/>!=<sp/>E.vertices_end();<sp/>++v)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>E.is_standard(v)<sp/>)<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Explorer::Point<sp/>p<sp/>=<sp/>E.point(v)<sp/></highlight><highlight class="comment">//<sp/>affine<sp/>embedding<sp/>of<sp/>v</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">/*<sp/>non-standard<sp/>*/</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Explorer::Ray<sp/>r<sp/>=<sp/>E.ray(v)<sp/></highlight><highlight class="comment">//<sp/>extended<sp/>embedding<sp/>of<sp/>v</highlight></codeline>
</programlisting></para><para>Note that box edges only serve as boundary edges (combinatorically) to close the faces that extend to infinity (geometrically). Their status can be queried by the following operation:</para><para><programlisting><codeline><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Explorer<sp/>Explorer;</highlight></codeline>
<codeline><highlight class="normal">Explorer<sp/>E<sp/>=<sp/>N4.explorer();</highlight></codeline>
<codeline><highlight class="normal">Explorer::Halfedge_const_iterator<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(e<sp/>=<sp/>E.halfedges_begin();<sp/>e<sp/>!=<sp/>E.halfedges_end();<sp/>++e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>E.is_frame_edge(e)<sp/>)<sp/></highlight><highlight class="comment">//<sp/>e<sp/>is<sp/>part<sp/>of<sp/>square<sp/>box.</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1Nef_2Traits">
<title>Traits Classes</title>
<para>Now finally we clarify what the template parameter of class <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref>&lt;T&gt;</computeroutput> actually models. <computeroutput>T</computeroutput> carries the implementation of a so-called extended geometric kernel.</para><para>Currently there are three kernel models: <computeroutput><ref refid="classCGAL_1_1Extended__cartesian" kindref="compound">Extended_cartesian</ref>&lt;FT&gt;</computeroutput>, <computeroutput><ref refid="classCGAL_1_1Extended__homogeneous" kindref="compound">Extended_homogeneous</ref>&lt;RT&gt;</computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Filtered__extended__homogeneous" kindref="compound">Filtered_extended_homogeneous</ref>&lt;RT&gt;</computeroutput>. The latter is the most optimized one. The former two are simpler versions corresponding to the simple planar affine kernels. Actually, it holds that (type equality in pseudo-code notation):</para><para><programlisting><codeline><highlight class="normal"><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">CGAL::Nef_polyhedron_2&lt; CGAL::Extended_cartesian&lt;FT&gt;</ref><sp/>&gt;::Point<sp/>==<sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;FT&gt;::Point_2</ref></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">CGAL::Nef_polyhedron_2&lt; CGAL::Extended_homogeneous&lt;RT&gt;</ref><sp/>&gt;::Point<sp/>==<sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;RT&gt;::Point_2</ref></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">CGAL::Nef_polyhedron_2&lt; CGAL::Filtered_extended_homogeneous&lt;RT&gt;</ref><sp/>&gt;::Point<sp/>==<sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;RT&gt;::Point_2</ref></highlight></codeline>
</programlisting></para><para>Similar equations hold for the types <computeroutput>Line</computeroutput> and <computeroutput>Direction</computeroutput> in the local scope of <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__2" kindref="compound">Nef_polyhedron_2</ref></computeroutput>.</para><para>For its notions and requirements see the desciption of the concept <computeroutput><ref refid="classExtendedKernelTraits__2" kindref="compound">ExtendedKernelTraits_2</ref></computeroutput> in the reference manual.</para></sect1>
<sect1 id="index_1Nef_2Implementation">
<title>Implementation</title>
<para>The underlying set operations are realized by an efficient and complete algorithm for the overlay of two plane maps. The algorithm is efficient in the sense that its running time is bounded by the size of the inputs plus the size of the output times a logarithmic factor. The algorithm is complete in the sense that it can handle all inputs and requires no general position assumption. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
