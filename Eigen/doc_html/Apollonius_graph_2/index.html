<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Apollonius_graph_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Apollonius Graphs (Delaunay Graphs of Disks): User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Apollonius Graphs (Delaunay Graphs of Disks)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Apollonius_Graphs"></a><a class="anchor" id="chapterapollonius2"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Menelaos Karavelas and Mariette Yvinec</dd></dl>
<p>This chapter describes the two-dimensional Apollonius graph of <span style="font-variant: small-caps;">CGAL</span>. We start with a few definitions in Section <a class="el" href="index.html#secapollonius2definitions">Definitions</a>. The software design of the 2D Apollonius graph package is described in Section <a class="el" href="index.html#secapollonius2design">Software Design</a>. In Section <a class="el" href="index.html#secapollonius2traits">The Geometric Traits</a> we discuss the geometric traits of the 2D Apollonius graph package and in Section <a class="el" href="index.html#secapollonius2hierarchy">The Apollonius Graph Hierarchy</a> the Apollonius graph hierarchy, a data structure suitable for fast nearest neighbor queries, is briefly described.</p>
<h1><a class="anchor" id="secapollonius2definitions"></a>
Definitions</h1>
<p><a class="anchor" id="fig__figapollonius"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="apollonius_diagram.png" alt="apollonius_diagram.png" />
</div>
   </td><td><div class="image">
<img src="apollonius_graph.png" alt="apollonius_graph.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__figapollonius">Figure 50.1</a> The Apollonius diagram (left) and its dual the Apollonius graph (right).  </div>  <br />

<p>The 2D Apollonius graph class of <span style="font-variant: small-caps;">CGAL</span> is designed to compute the dual of the <em>Apollonius diagram</em> or, as it is also known, the <em>Additively weighted Voronoi diagram</em>. The algorithm that has been implemented is dynamic, which means that we can perform insertions and deletions on line. The corresponding <span style="font-variant: small-caps;">CGAL</span> class is called <code><a class="el" href="classCGAL_1_1Apollonius__graph__2.html" title="The class Apollonius_graph_2 represents the Apollonius graph. ">Apollonius_graph_2</a>&lt;<a class="el" href="classApolloniusGraphTraits__2.html">ApolloniusGraphTraits_2</a>,<a class="el" href="classApolloniusGraphDataStructure__2.html" title="The concept ApolloniusGraphDataStructure_2 refines the concept TriangulationDataStructure_2. In addition it provides two methods for the insertion and removal of a degree 2 vertex in the data structure. The insertion method adds a new vertex to the specified edge, thus creating two new edges. Moreover, it creates two new faces that have the two newly created edges in common (see figure below). The removal method performs the reverse operation. ">ApolloniusGraphDataStructure_2</a>&gt;</code> and will be discussed in more detail in the sequel. The interested reader may want to refer to the paper by Karavelas and Yvinec <a class="el" href="citelist.html#CITEREF_cgal:ky-dawvd-02">[5]</a> for the general idea as well as the details of the algorithm implemented.</p>
<p>Before describing the details of the implementation we make a brief introduction to the theory of Apollonius diagrams. The Apollonius diagram is defined over a set of sites \( P_i=(c_i,w_i)\), \( i=1,\ldots,n\), where \( c_i\) is the point and \( w_i\) the weight of \( P_i\). It is a subdivision of the plane into connected regions, called <em>cells</em>, associated with the sites (see <a class="el" href="index.html#fig__figapollonius">Figure 50.1</a> (left)). The cell of a site \( P_i\) is the locus of points on the plane that are closer to \( P_i\) than any other site \( P_j\), \( j\neq i\). The distance \( \delta(x, P_i)\) of a point \( x\) in the plane to a site \( P_i\) is defined as: </p><p class="formulaDsp">
\[ \delta(x,P_i)=\|x-c_i\|-w_i, \]
</p>
<p> where \( \|\cdot\|\) denotes the Euclidean norm. It can easily be seen that it is a generalization of the Voronoi diagram for points, which can actually be obtained if all the weights \( w_i\) are equal. Unlike the case of points, however, it is possible that a site \( P_i\) might have an empty cell. This can also happen in the case of the power diagram, whose dual is the regular triangulation (see Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/index.html#Section_2D_Triangulations_Regular">Regular Triangulations</a> ). If this is the case we call the site <em>hidden</em> (these are the black circles in <a class="el" href="index.html#fig__figapollonius">Figure 50.1</a> ). A site which is not hidden will be referred to as <em>visible</em>.</p>
<p>If all weights \( w_i\) are non-negative, the Apollonius diagram can be viewed as the Voronoi diagram of the set of circles \( \{P_1,\ldots, P_n\}\), where \( c_i\) is the center of the circle \( P_i\) and \( w_i\) its radius. If the weights are allowed to be negative, we need to go to 3D in order to explain what the Apollonius diagram means geometrically. We identify the 2D Euclidean plane with the \( xy\)-plane in 3D. Then the Voronoi diagram of a set of points can be seen as the vertical projection on the \( xy\)-plane of the lower envelope of a set of 3D cones defined as follows: for each point \( p\) in the set of 2D points we have a cone \( C_p\) whose apex is the point \( p\). The axis of \( C_p\) is a line parallel to the \( z\)-axis passing through \( p\), the angle of \( C_p\) is \( 45^\circ\) and, finally \( C_p\) is facing in the positive \( z\)-direction (that is, \( C_p\) is contained in the positive \( z\)-halfspace). The Apollonius diagram corresponds to shifting the apexes of these cones in the \( z\)-direction by a quantity equal to the weight. Sites with negative weight will give rise to cones whose apex is in the negative \( z\)-halfspace and sites with positive weight will give rise to cones whose apex is in the positive \( z\)-halfspace. In a manner analogous to the case of points, the Apollonius diagram can then be defined as the vertical projection on the \( xy\)-plane of the lower envelope of the set of shifted cones. Notice that when all apexes are translated along the \( z\)-direction by the same amount, the projection of the lower envelope of the set of cones does not change. In particular, we can translate all cones by a large enough amount so that all apexes are in the positive \( z\)-halfspace. Algebraically, this means that the Apollonius diagram does not change if we add to all weights the same quantity, which in particular, implies that we can assume without loss of generality that all weights are positive. Given the observations above and in order to simplify our discussion of Apollonius diagrams, we will, from now on, assume that all weights are positive, and we will refer to the sites as circles.</p>
<p>The Apollonius diagram is a planar graph, and so is its dual, the Apollonius graph. There are many ways to embed it on the plane and one such way is shown in <a class="el" href="index.html#fig__figapollonius">Figure 50.1</a> (right). The Apollonius graph is uniquely defined once we have the Apollonius diagram. If the circles are in <em>general position</em> (see precise definition below), then the Apollonius graph is a graph with triangular faces away from the convex hull of the set of circles (by triangular we mean that every face has exactly three edges). Near the convex hull we may have some spikes (i.e., vertices of degree 1). To unify our approach and handling of the Apollonius graph we add to the set of (finite) circles a fictitious circle at infinity, which we call the <em>site at infinity</em>. We can then connect all vertices of the outer face of the Apollonius graph to the site at infinity which gives us a graph with the property that all of its faces are now triangular. However, the Apollonius graph is not a triangulation for two main reasons: we cannot always embed it on the plane with straight line segments that yield a triangulation and, moreover, we may have two faces of the graph that have two edges in common, which is not allowed in a triangulation. Both of these particularities appear when we consider the Apollonius graph of the set of circles in <a class="el" href="index.html#fig__figapollonius">Figure 50.1</a>.</p>
<p>We would like to finish our brief introduction to the theory of Apollonius graphs by discussing the concept of general position. We say that a set of circles is in general position if no two triplets of circles have the same tritangent circle. This statement is rather technical and it is best understood in the context of points. The equivalent statement for points is that we have no two triplets of points that define the same circumcircle, or equivalently that no four points are co-circular. The statement about general position made above is a direct generalization of the (much simpler to understand) statement about points. On the contrary, when we have circles in degenerate position, the Apollonius graph has faces with more than three edges on their boundary. We can get a triangulated version of the graph by simply <em>triangulating</em> the corresponding faces in an arbitrary way. In fact the algorithm that has been implemented in <span style="font-variant: small-caps;">CGAL</span> has the property that it always returns a valid <em>triangulated</em> version of the Apollonius graph. By valid we mean that it contains the actual Apollonius graph (i.e., the actual dual of the Apollonius diagram) and whenever there are faces with more than three faces then they are triangulated. The way that they are triangulated depends on the order of insertion and deletion of the circles in the diagram.</p>
<p>One final point has to be made about hidden circles. First of all we would like to be more precise about our definition of hidden circles: we say that a circle is hidden if its cell has empty interior. This definition allows us to guarantee that all visible circles have cells that are two-dimensional regions. Geometrically the fact that a circle is hidden means that it is contained in the closure of the disk of another circle (see again <a class="el" href="index.html#fig__figapollonius">Figure 50.1</a> ). Note that a circle contained in the union of several disks, but not in the closure of any one of them, is not hidden.</p>
<p>Hidden circles pose an additional difficulty to our algorithm and software design. Since we allow circles to be inserted and deleted at wish, it is possible that a circle that was hidden at some point in time, may become visible at a later point in time; for example this can happen if we delete the circle that hides it. For this purpose we store hidden circles and have them reappear when they become visible. We will discuss this issue in detail below. For the time being it suffices to say that the user has the ability to control this behavior. More specifically it is possible to discard the circles that become hidden. This choice is totally natural when for example we expect to do only insertions, since in this case a circle that becomes hidden will never reappear. On the other hand if deletions are expected as well, then we lose the ability to have the hidden circles reappear.</p>
<p><b>Degenerate Dimensions.</b></p>
<p>The dimension of the Apollonius graph is in general 2. The exceptions to this rule are as follows: </p><ul>
<li>
The dimension is \( -1\) if the Apollonius graph contains no circles. </li>
<li>
The dimension is \( 0\) if the Apollonius graph contains exactly one visible circle. </li>
<li>
The dimension is \( 1\) is the Apollonius graph contains exactly two visible circles. </li>
</ul>
<h1><a class="anchor" id="secapollonius2design"></a>
Software Design</h1>
<p>The 2D Apollonius graph class <code><a class="el" href="classCGAL_1_1Apollonius__graph__2.html" title="The class Apollonius_graph_2 represents the Apollonius graph. ">Apollonius_graph_2</a>&lt;<a class="el" href="classApolloniusGraphTraits__2.html">ApolloniusGraphTraits_2</a>,<a class="el" href="classApolloniusGraphDataStructure__2.html" title="The concept ApolloniusGraphDataStructure_2 refines the concept TriangulationDataStructure_2. In addition it provides two methods for the insertion and removal of a degree 2 vertex in the data structure. The insertion method adds a new vertex to the specified edge, thus creating two new edges. Moreover, it creates two new faces that have the two newly created edges in common (see figure below). The removal method performs the reverse operation. ">ApolloniusGraphDataStructure_2</a>&gt;</code> follows the design of the triangulation package of <span style="font-variant: small-caps;">CGAL</span>. It is parametrized by two arguments: </p><ul>
<li>
the <b>geometric traits</b> class. It provides the basic geometric objects involved in the algorithm, such as sites, points etc. It also provides the geometric predicates for the computation of the Apollonius graph, as well as some basic constructions that can be used, for example, to visualize the Apollonius graph or the Apollonius diagram. The geometric traits for the Apollonius graph will be discussed in more detail in the next section. </li>
<li>
the <b>Apollonius graph data structure</b>. This is essentially the same as the triangulation data structure (discussed in Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/index.html#Chapter_2D_Triangulation_Data_Structure">Chapter_2D_Triangulation_Data_Structure</a> ), augmented with some additional operations that are specific to Apollonius graphs. The corresponding concept is that of <code><a class="el" href="classApolloniusGraphDataStructure__2.html" title="The concept ApolloniusGraphDataStructure_2 refines the concept TriangulationDataStructure_2. In addition it provides two methods for the insertion and removal of a degree 2 vertex in the data structure. The insertion method adds a new vertex to the specified edge, thus creating two new edges. Moreover, it creates two new faces that have the two newly created edges in common (see figure below). The removal method performs the reverse operation. ">ApolloniusGraphDataStructure_2</a></code>, which in fact is a refinement of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classTriangulationDataStructure__2.html">TriangulationDataStructure_2</a></code> concept. The class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">Triangulation_data_structure_2</a>&lt;Vb,Fb&gt;</code> is a model of the concept <code><a class="el" href="classApolloniusGraphDataStructure__2.html" title="The concept ApolloniusGraphDataStructure_2 refines the concept TriangulationDataStructure_2. In addition it provides two methods for the insertion and removal of a degree 2 vertex in the data structure. The insertion method adds a new vertex to the specified edge, thus creating two new edges. Moreover, it creates two new faces that have the two newly created edges in common (see figure below). The removal method performs the reverse operation. ">ApolloniusGraphDataStructure_2</a></code>. A default value for the corresponding template parameter is provided, so the user does not need to specify it. </li>
</ul>
<p><b>Storing Hidden Sites.</b></p>
<p>As we have already mentioned a circle is hidden if it is contained inside some visible circle. This creates a parent-child relationship between visible and hidden circles: the parent of a hidden circle is the visible circle that contains it. If more than one visible circles contain a hidden circle then the hidden circle can be assigned to any of the visible circles arbitrarily.</p>
<p>To store hidden circles we assign to every visible circle a list. This list comprises the hidden circles that are contained in the visible circle. The user can access the hidden circles associated with a visible circle through an iterator called <code>Hidden_sites_iterator</code>. This iterator is defined in the <code><a class="el" href="classApolloniusGraphVertexBase__2.html">ApolloniusGraphVertexBase_2</a></code> concept and is implemented by its model, the <code><a class="el" href="classCGAL_1_1Apollonius__graph__vertex__base__2.html" title="The class Apollonius_graph_vertex_base_2 provides a model for the ApolloniusGraphVertexBase_2 concept...">Apollonius_graph_vertex_base_2</a>&lt;Gt,StoreHidden&gt;</code> class. It is also possible to iterate through the entire set of hidden sites using an homonymous iterator defined by the <code><a class="el" href="classCGAL_1_1Apollonius__graph__2.html" title="The class Apollonius_graph_2 represents the Apollonius graph. ">Apollonius_graph_2</a>&lt;Gt,Agds&gt;</code> class.</p>
<p>Since storing hidden sites may not be of interest in some cases (e.g., for example this is the case if we only perform insertions in the Apollonius graph), the user has the possibility of controlling this behavior. More precisely, the class <code><a class="el" href="classCGAL_1_1Apollonius__graph__vertex__base__2.html" title="The class Apollonius_graph_vertex_base_2 provides a model for the ApolloniusGraphVertexBase_2 concept...">Apollonius_graph_vertex_base_2</a>&lt;Gt,StoreHidden&gt;</code> has two template parameters, the second of which is a Boolean value. This value is by default <code>true</code> and it indicates that hidden sites should be stored. The user can indicate that hidden sites may be discarded by setting this value to <code>false</code>.</p>
<h1><a class="anchor" id="secapollonius2traits"></a>
The Geometric Traits</h1>
<p>The predicates required for the computation of the Apollonius graph are rather complicated. It is not the purpose of this document to discuss them in detail. The interested reader may refer to the papers by Karavelas and Emiris for the details <a class="el" href="citelist.html#CITEREF_cgal:ke-ppawv-02">[3]</a>, <a class="el" href="citelist.html#CITEREF_cgal:ke-rctac-03">[4]</a>. However, we would like to give a brief overview of what they compute. There are several predicates needed by this algorithm. We will discuss the most important/complicated ones. It turns out that it is much easier to describe them in terms of the Apollonius diagram, rather than the Apollonius graph. Whenever it is applicable we will also describe their meaning in terms of the Apollonius graph.</p>
<p>The first two geometric predicates are called <code>Is_hidden_2</code> and <code>Oriented_side_of_bisector_2</code>. The first one involves two circles, say \( P_1\) and \( P_2\). It determines if \( P_1\) is hidden with respect to \( P_2\); more precisely it checks whether the circle \( P_1\) is contained in the closure of the disk defined by the circle \( P_2\). As its name indicates, it determines if a circle is hidden or not. The second predicate involves two circles \( P_1\) and \( P_2\) and a point \( q\). It answers the question whether \( q\) is closer to \( P_1\) or \( P_2\). Its name stems from the fact that answering the aforementioned question is equivalent to determining the oriented side of the bisector of \( P_1\) and \( P_2\) that contains the query point \( q\). This predicate is used by the algorithm for closest neighbor queries for points.</p>
<p>The next geometric predicate is called <code>Vertex_conflict_2</code> and it involves four circles \( P_1\), \( P_2\), \( P_3\), and \( P_4\) (see <a class="el" href="index.html#fig__figag2vc">Figure 50.2</a> ). The first three (red circles in <a class="el" href="index.html#fig__figag2vc">Figure 50.2</a> ) define a tritangent circle (yellow circle in <a class="el" href="index.html#fig__figag2vc">Figure 50.2</a> ). What we want to determine is the sign of the distance of the green circle from the yellow circle. The distance between two circles \( K_1=(c_1,r_1)\) and \( K_2=(c_2, r_2)\) is defined as the distance of their centers minus their radii: </p><p class="formulaDsp">
\[ \delta(K_1, K_2) = \|c_1-c_2\|-r_1-r_2. \]
</p>
<p> This predicate determines if a vertex in the Apollonius diagram (the center of the yellow circle) is destroyed when a new circle is inserted in the diagram (the green circle). In the Apollonius graph it tells us if a triangular face of the diagram is to be destroyed or not.</p>
<p><a class="anchor" id="fig__figag2vc"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="apollonius-vertex_conflict-false.png" alt="apollonius-vertex_conflict-false.png" />
</div>
   </td><td><div class="image">
<img src="apollonius-vertex_conflict-true.png" alt="apollonius-vertex_conflict-true.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__figag2vc">Figure 50.2</a> The <code>Vertex_conflict_2</code> predicate. The left-most, bottom-most and top-most circles define the tritangent circle in the middle. We want to determine the sign of the distance of the left-most circle from the one in the middle. The almost horizontal curve is the bisector of the top-most and bottom-most circles. Left: the predicate returns <code>NEGATIVE</code>. Right: the predicate returns <code>POSITIVE</code>.  </div>  <br />

<p>What we essentially want to compute when we construct incrementally a Voronoi diagram, is whether the object to be inserted destroys an edge of the Voronoi diagram or not. In the case of points this is really easy and it amounts to the well known <em>incircle</em> test. In the case of circles the situation is more complicated. We can have six possible outcomes as to what portion of an edge of the Apollonius diagram the new circle destroys (see <a class="el" href="index.html#fig__figag2edgeconflict">Figure 50.3</a> ). The first two can be answered directly by the <code>Vertex_conflict_2</code> predicate evaluated for the two endpoints of the Apollonius diagram edge. This is due to the fact that the value of the <code>Vertex_conflict_2</code> predicate is different for the two endpoints. If the two values are the same then we need an additional test which determines if the interior of the Apollonius diagram edge is destroyed by the new circle. This is what the <code>Finite_edge_interior_conflict_2</code> and <code>Infinite_edge_interior_conflict_2</code> predicates do. In essence, it is the same predicate (same idea) applied to two different types of edges in the Apollonius diagram: a finite or an infinite edge. An edge is infinite if its dual edge in the Apollonius graph connects the site at infinity with the vertex corresponding to a (finite) circle; otherwise it is a finite edge.</p>
<p><a class="anchor" id="fig__figag2edgeconflict"></a></p><center> <table class="doxtable">
<tr>
<td><div class="image">
<img src="apollonius-left_vertex.png" alt="apollonius-left_vertex.png" />
</div>
   </td><td><div class="image">
<img src="apollonius-right_vertex.png" alt="apollonius-right_vertex.png" />
</div>
    </td></tr>
<tr>
<td><div class="image">
<img src="apollonius-no_conflict.png" alt="apollonius-no_conflict.png" />
</div>
   </td><td><div class="image">
<img src="apollonius-entire_edge.png" alt="apollonius-entire_edge.png" />
</div>
    </td></tr>
<tr>
<td><div class="image">
<img src="apollonius-interior.png" alt="apollonius-interior.png" />
</div>
   </td><td><div class="image">
<img src="apollonius-both_vertices.png" alt="apollonius-both_vertices.png" />
</div>
    </td></tr>
</table>
</center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figag2edgeconflict">Figure 50.3</a> The 6 possible outcomes of the <code>Finite_edge_interior_conflict_2</code> predicate. Top left: only a neighborhood around the left-most endpoint of the edge will be destroyed. Top right: only a neighborhood around the right-most endpoint of the edge will be destroyed. Middle left: no portion of the edge is destroyed. Middle right: the entire edge will be destroyed. Bottom left: a neighborhood in the interior of the edge will be destroyed; the regions near the endpoints remain unaffected. Bottom right: The neighborhood around the two endpoints will be destroyed, but an interval in the interior of the edge will remain in the new diagram.  </div>  <br />

<p>The last predicate that we want to discuss is called <code>Is_degenerate_edge_2</code>. It tells us whether an edge in the Apollonius diagram is degenerate, that is if its two endpoints coincide. In the Apollonius graph such an edge corresponds to one of the additional edges that we use to triangulate the non-triangular faces.</p>
<p>The aforementioned predicates are part of the <code><a class="el" href="classApolloniusGraphTraits__2.html">ApolloniusGraphTraits_2</a></code> concept of <span style="font-variant: small-caps;">CGAL</span>. <span style="font-variant: small-caps;">CGAL</span> also provides a model for this concept, the <code><a class="el" href="classCGAL_1_1Apollonius__graph__traits__2.html" title="The class Apollonius_graph_traits_2 provides a model for the ApolloniusGraphTraits_2 concept...">Apollonius_graph_traits_2</a>&lt;K,Method_tag&gt;</code> class. The first template parameter of this class must be a model of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> concept. The second template parameter is a tag that indicates what operations are allowed in the computations that take place within the traits class. The two possible values of the <code>Method_tag</code> parameter are <code>Ring_tag</code> and <code>Sqrt_field_tag</code>. When <code>Ring_tag</code> is used, only ring operations are used during the evaluation of the predicates, whereas if <code>Sqrt_field_tag</code> is chosen, all four field operations, as well as square roots, are used during the predicate evaluation.</p>
<p>The <code><a class="el" href="classCGAL_1_1Apollonius__graph__traits__2.html" title="The class Apollonius_graph_traits_2 provides a model for the ApolloniusGraphTraits_2 concept...">Apollonius_graph_traits_2</a>&lt;K,Method_tag&gt;</code> class provides exact predicates if the number type in the kernel <code>K</code> is an exact number type. This is to be associated with the type of operations allowed for the predicate evaluation. For example <code>MP_Float</code> as number type, with <code>Ring_tag</code> as tag will give exact predicates, whereas <code>MP_Float</code> with <code>Sqrt_field_tag</code> will give inexact predicates.</p>
<p>Since using an exact number type may be too slow, the <code><a class="el" href="classCGAL_1_1Apollonius__graph__traits__2.html" title="The class Apollonius_graph_traits_2 provides a model for the ApolloniusGraphTraits_2 concept...">Apollonius_graph_traits_2</a>&lt;K,Method_tag&gt;</code> class is designed to support the dynamic filtering of <span style="font-variant: small-caps;">CGAL</span> through the <code>Filtered_exact&lt;CT,ET&gt;</code> mechanism. In particular if <code>CT</code> is an inexact number type that supports the operations denoted by the tag <code>Method_tag</code> and <code>ET</code> is an exact number type for these operations, then kernel with number type <code>Filtered_exact&lt;CT,ET&gt;</code> will yield exact predicates for the Apollonius graph traits. To give a concrete example, <code>CGAL::Filtered_exact&lt;double,CGAL::MP_Float&gt;</code> with <code>Ring_tag</code> will produce exact predicates.</p>
<p>Another possibility for fast and exact predicate evaluation is to use the <code><a class="el" href="classCGAL_1_1Apollonius__graph__filtered__traits__2.html" title="The class Apollonius_graph_filtered_traits_2 provides a model for the ApolloniusGraphTraits_2 concept...">Apollonius_graph_filtered_traits_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> class. This class is the analog of a filtered kernel. It takes a constructions kernel <code>CK</code>, a filtering kernel <code>FK</code> and an exact kernel <code>EK</code>, as well as the corresponding tags (<code>CM</code>, <code>FM</code> and <code>EM</code>, respectively). It evaluates the predicates by first using the filtering kernel, and if this fails the evaluation is performed using the exact kernel. The constructions are done using the kernel <code>CK</code>, which means that they are not necessarily exact. All template parameters except <code>CK</code> have default values, which are explained in the reference manual.</p>
<h1><a class="anchor" id="secapollonius2hierarchy"></a>
The Apollonius Graph Hierarchy</h1>
<p>The <code><a class="el" href="classCGAL_1_1Apollonius__graph__hierarchy__2.html" title="We provide an alternative to the class Apollonius_graph_2&lt;Gt,Agds&gt; for the dynamic construction of th...">Apollonius_graph_hierarchy_2</a>&lt;<a class="el" href="classApolloniusGraphTraits__2.html">ApolloniusGraphTraits_2</a>,<a class="el" href="classApolloniusGraphDataStructure__2.html" title="The concept ApolloniusGraphDataStructure_2 refines the concept TriangulationDataStructure_2. In addition it provides two methods for the insertion and removal of a degree 2 vertex in the data structure. The insertion method adds a new vertex to the specified edge, thus creating two new edges. Moreover, it creates two new faces that have the two newly created edges in common (see figure below). The removal method performs the reverse operation. ">ApolloniusGraphDataStructure_2</a>&gt;</code> class is nothing but the equivalent of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__hierarchy__2.html">Triangulation_hierarchy_2</a></code> class, applied to the Apollonius graph. It consists of a series of Apollonius graphs constructed in a manner analogous to the Delaunay hierarchy by Devillers <a class="el" href="citelist.html#CITEREF_d-iirdt-98">[2]</a>. The class <code><a class="el" href="classCGAL_1_1Apollonius__graph__hierarchy__2.html" title="We provide an alternative to the class Apollonius_graph_2&lt;Gt,Agds&gt; for the dynamic construction of th...">Apollonius_graph_hierarchy_2</a>&lt;<a class="el" href="classApolloniusGraphTraits__2.html">ApolloniusGraphTraits_2</a>,<a class="el" href="classApolloniusGraphDataStructure__2.html" title="The concept ApolloniusGraphDataStructure_2 refines the concept TriangulationDataStructure_2. In addition it provides two methods for the insertion and removal of a degree 2 vertex in the data structure. The insertion method adds a new vertex to the specified edge, thus creating two new edges. Moreover, it creates two new faces that have the two newly created edges in common (see figure below). The removal method performs the reverse operation. ">ApolloniusGraphDataStructure_2</a>&gt;</code> has exactly the same interface and functionality as the <code><a class="el" href="classCGAL_1_1Apollonius__graph__2.html" title="The class Apollonius_graph_2 represents the Apollonius graph. ">Apollonius_graph_2</a>&lt;<a class="el" href="classApolloniusGraphTraits__2.html">ApolloniusGraphTraits_2</a>,<a class="el" href="classApolloniusGraphDataStructure__2.html" title="The concept ApolloniusGraphDataStructure_2 refines the concept TriangulationDataStructure_2. In addition it provides two methods for the insertion and removal of a degree 2 vertex in the data structure. The insertion method adds a new vertex to the specified edge, thus creating two new edges. Moreover, it creates two new faces that have the two newly created edges in common (see figure below). The removal method performs the reverse operation. ">ApolloniusGraphDataStructure_2</a>&gt;</code> class. Using the Apollonius graph hierarchy involves an additional cost in space and time for maintaining the hierarchy. Our experiments have shown that it usually pays off to use the hierarchy for inputs consisting of more than 1,000 circles. This threshold holds for both the construction of the Apollonius diagram itself, as well as for nearest neighbor queries.</p>
<h1><a class="anchor" id="secapollonius2examples"></a>
Examples</h1>
<h2><a class="anchor" id="Apollonius_graph_2FirstExample"></a>
First Example</h2>
<p><br />
<b>File</b> <a class="el" href="Apollonius_graph_2_2ag2_exact_traits_8cpp-example.html">Apollonius_graph_2/ag2_exact_traits.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// the number type</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/MP_Float.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// example that uses an exact number type</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::MP_Float NT;</div><div class="line"></div><div class="line"><span class="comment">// *** WARNING ***</span></div><div class="line"><span class="comment">// The use of a kernel based on an exact number type is highly inefficient.</span></div><div class="line"><span class="comment">// It is used in this example primarily for illustration purposes.</span></div><div class="line"><span class="comment">// In an efficiency critical context, and/or for the purposes of</span></div><div class="line"><span class="comment">// benchmarking the Apollonius_graph_filtered_traits_2&lt;&gt; class should</span></div><div class="line"><span class="comment">// be used.</span></div><div class="line"></div><div class="line"><span class="comment">// choose the kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;NT&gt;</a>  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Apollonius_graph_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Apollonius_graph_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Apollonius__graph__traits__2.html">CGAL::Apollonius_graph_traits_2&lt;Kernel&gt;</a>   Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Apollonius__graph__2.html">CGAL::Apollonius_graph_2&lt;Traits&gt;</a>          Apollonius_graph;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::ifstream ifs(<span class="stringliteral">"data/sites.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  Apollonius_graph ag;</div><div class="line">  Apollonius_graph::Site_2 site;</div><div class="line"></div><div class="line">  <span class="comment">// read the sites and insert them in the Apollonius graph</span></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) {</div><div class="line">    ag.<a class="code" href="classCGAL_1_1Apollonius__graph__2.html#a30a25b908f475dc7c495a06799a8a11a">insert</a>(site);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// validate the Apollonius graph</span></div><div class="line">  assert( ag.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Apollonius_graph_2SecondExample"></a>
Second Example</h2>
<p><br />
<b>File</b> <a class="el" href="Apollonius_graph_2_2ag2_exact_traits_sqrt_8cpp-example.html">Apollonius_graph_2/ag2_exact_traits_sqrt.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if defined CGAL_USE_LEDA</span></div><div class="line"><span class="preprocessor">#  include &lt;CGAL/leda_real.h&gt;</span></div><div class="line"><span class="preprocessor">#elif defined CGAL_USE_CORE</span></div><div class="line"><span class="preprocessor">#  include &lt;CGAL/CORE_Expr.h&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">// *** WARNING ***</span></div><div class="line"><span class="comment">// The use of a kernel based on an exact number type is highly inefficient.</span></div><div class="line"><span class="comment">// It is used in this example primarily for illustration purposes.</span></div><div class="line"><span class="comment">// In an efficiency critical context, and/or for the purposes of</span></div><div class="line"><span class="comment">// benchmarking the Apollonius_graph_filtered_traits_2&lt;&gt; class should</span></div><div class="line"><span class="comment">// be used.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if defined CGAL_USE_LEDA</span></div><div class="line"><span class="comment">// If LEDA is present use leda_real as the exact number type</span></div><div class="line"><span class="keyword">typedef</span> leda_real NT;</div><div class="line"></div><div class="line"><span class="preprocessor">#elif defined CGAL_USE_CORE</span></div><div class="line"><span class="comment">// Otherwise if CORE is present use CORE's Expr as the exact number type</span></div><div class="line"><span class="keyword">typedef</span> CORE::Expr NT;</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="comment">// Otherwise just use double. This may cause numerical errors but it</span></div><div class="line"><span class="comment">// is still worth doing it to show how to define correctly the traits</span></div><div class="line"><span class="comment">// class</span></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span> NT;</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;NT&gt;</a>  Kernel;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Apollonius_graph_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Apollonius_graph_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// the traits class is now going to assume that the operations</span></div><div class="line"><span class="comment">// +,-,*,/ and sqrt are supported exactly</span></div><div class="line"><span class="keyword">typedef</span></div><div class="line"><a class="code" href="classCGAL_1_1Apollonius__graph__traits__2.html">CGAL::Apollonius_graph_traits_2&lt;Kernel,CGAL::Field_with_sqrt_tag&gt;</a> Traits;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Apollonius__graph__2.html">CGAL::Apollonius_graph_2&lt;Traits&gt;</a> Apollonius_graph;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::ifstream ifs(<span class="stringliteral">"data/sites.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  Apollonius_graph ag;</div><div class="line">  Apollonius_graph::Site_2 site;</div><div class="line"></div><div class="line">  <span class="comment">// read the sites and insert them in the Apollonius graph</span></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) {</div><div class="line">    ag.insert(site);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// validate the Apollonius graph</span></div><div class="line">  assert( ag.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Apollonius_graph_2ThirdExample"></a>
Third Example</h2>
<p><br />
<b>File</b> <a class="el" href="Apollonius_graph_2_2ag2_filtered_traits_no_hidden_8cpp-example.html">Apollonius_graph_2/ag2_filtered_traits_no_hidden.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// example that uses the filtered traits</span></div><div class="line"></div><div class="line"><span class="comment">// choose the representation</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Rep;</div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Apollonius_graph_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_data_structure_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Apollonius_graph_vertex_base_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_face_base_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Apollonius_graph_filtered_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// typedef for the traits; the filtered traits class is used</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Apollonius__graph__filtered__traits__2.html">CGAL::Apollonius_graph_filtered_traits_2&lt;Rep&gt;</a> Traits;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the algorithm</span></div><div class="line"></div><div class="line"><span class="comment">// With the second template argument in the vertex base class being</span></div><div class="line"><span class="comment">// false, we indicate that there is no need to store the hidden sites.</span></div><div class="line"><span class="comment">// One case where this is indeed not needed is when we only do</span></div><div class="line"><span class="comment">// insertions, like in the main program below.</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Apollonius__graph__vertex__base__2.html">CGAL::Apollonius_graph_vertex_base_2&lt;Traits,false&gt;</a>   Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__2.html">CGAL::Triangulation_face_base_2&lt;Traits&gt;</a>              Fb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;</a>       Agds;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Apollonius__graph__2.html">CGAL::Apollonius_graph_2&lt;Traits,Agds&gt;</a>    Apollonius_graph;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::ifstream ifs(<span class="stringliteral">"data/sites.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  Apollonius_graph ag;</div><div class="line">  Apollonius_graph::Site_2 site;</div><div class="line"></div><div class="line">  <span class="comment">// read the sites and insert them in the Apollonius graph</span></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) {</div><div class="line">    ag.insert(site);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// validate the Apollonius graph</span></div><div class="line">  assert( ag.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// now remove all sites</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Removing all sites... "</span> &lt;&lt; std::flush;</div><div class="line">  <span class="keywordflow">while</span> ( ag.number_of_vertices() &gt; 0 ) {</div><div class="line">    ag.remove( ag.finite_vertex() );</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"done!"</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Apollonius_graph_2FourthExample"></a>
Fourth Example</h2>
<p><br />
<b>File</b> <a class="el" href="Apollonius_graph_2_2ag2_hierarchy_8cpp-example.html">Apollonius_graph_2/ag2_hierarchy.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// example that uses the filtered traits</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/MP_Float.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// constructions kernel (inexact)</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> CK;</div><div class="line"></div><div class="line"><span class="comment">// exact kernel</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;CGAL::MP_Float&gt;</a> EK;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Apollonius_graph_hierarchy_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Apollonius_graph_filtered_traits_2.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Type definition for the traits class.</span></div><div class="line"><span class="comment">// In this example we explicitly define the exact kernel. We also</span></div><div class="line"><span class="comment">// explicitly define what operations to use for the evaluation of the</span></div><div class="line"><span class="comment">// predicates and constructions, when the filtering and the exact</span></div><div class="line"><span class="comment">// kernels are used respectively.</span></div><div class="line"><span class="comment">// Note that the operations allowed for the filtering and the</span></div><div class="line"><span class="comment">// constructions (field operations plus square roots) are different</span></div><div class="line"><span class="comment">// from the operations allowed when the exact kernel is used (ring</span></div><div class="line"><span class="comment">// operations).</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/structCGAL_1_1Field__with__sqrt__tag.html">CGAL::Field_with_sqrt_tag</a>  CM;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/structCGAL_1_1Integral__domain__without__division__tag.html">CGAL::Integral_domain_without_division_tag</a>        EM;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Apollonius__graph__filtered__traits__2.html">CGAL::Apollonius_graph_filtered_traits_2&lt;CK,CM,EK,EM&gt;</a> Traits;</div><div class="line"></div><div class="line"><span class="comment">// Now we use the Apollonius graph hierarchy.</span></div><div class="line"><span class="comment">// The hierarchy is faster for inputs consisting of about more than</span></div><div class="line"><span class="comment">// 1,000 sites</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Apollonius__graph__hierarchy__2.html">CGAL::Apollonius_graph_hierarchy_2&lt;Traits&gt;</a> Apollonius_graph;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::ifstream ifs(<span class="stringliteral">"data/hierarchy.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  Apollonius_graph ag;</div><div class="line">  Apollonius_graph::Site_2 site;</div><div class="line"></div><div class="line">  <span class="comment">// read the sites and insert them in the Apollonius graph</span></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) {</div><div class="line">    ag.insert(site);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// validate the Apollonius graph</span></div><div class="line">  assert( ag.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:10 for CGAL 4.13 - 2D Apollonius Graphs (Delaunay Graphs of Disks) by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
