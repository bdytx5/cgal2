<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Apollonius_Graphs"/><anchor id="index_1chapterapollonius2"/> <simplesect kind="authors"><para>Menelaos Karavelas and Mariette Yvinec</para></simplesect>
This chapter describes the two-dimensional Apollonius graph of CGAL. We start with a few definitions in Section <ref refid="index_1secapollonius2definitions" kindref="member">Definitions</ref>. The software design of the 2D Apollonius graph package is described in Section <ref refid="index_1secapollonius2design" kindref="member">Software Design</ref>. In Section <ref refid="index_1secapollonius2traits" kindref="member">The Geometric Traits</ref> we discuss the geometric traits of the 2D Apollonius graph package and in Section <ref refid="index_1secapollonius2hierarchy" kindref="member">The Apollonius Graph Hierarchy</ref> the Apollonius graph hierarchy, a data structure suitable for fast nearest neighbor queries, is briefly described.</para><sect1 id="index_1secapollonius2definitions">
<title>Definitions</title>
<para><anchor id="index_1fig__figapollonius"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="apollonius_diagram.png"></image>
 <image type="latex" name="apollonius_diagram.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="apollonius_graph.png"></image>
 <image type="latex" name="apollonius_graph.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__figapollonius" kindref="member">fig__figapollonius</ref> The Apollonius diagram (left) and its dual the Apollonius graph (right).  <linebreak/>
</para><para>The 2D Apollonius graph class of CGAL is designed to compute the dual of the <emphasis>Apollonius diagram</emphasis> or, as it is also known, the <emphasis>Additively weighted Voronoi diagram</emphasis>. The algorithm that has been implemented is dynamic, which means that we can perform insertions and deletions on line. The corresponding CGAL class is called <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__2" kindref="compound">Apollonius_graph_2</ref>&lt;<ref refid="classApolloniusGraphTraits__2" kindref="compound">ApolloniusGraphTraits_2</ref>,<ref refid="classApolloniusGraphDataStructure__2" kindref="compound">ApolloniusGraphDataStructure_2</ref>&gt;</computeroutput> and will be discussed in more detail in the sequel. The interested reader may want to refer to the paper by Karavelas and Yvinec <ref refid="citelist_1CITEREF_cgal:ky-dawvd-02" kindref="member">[5]</ref> for the general idea as well as the details of the algorithm implemented.</para><para>Before describing the details of the implementation we make a brief introduction to the theory of Apollonius diagrams. The Apollonius diagram is defined over a set of sites <formula id="0">$ P_i=(c_i,w_i)$</formula>, <formula id="1">$ i=1,\ldots,n$</formula>, where <formula id="2">$ c_i$</formula> is the point and <formula id="3">$ w_i$</formula> the weight of <formula id="4">$ P_i$</formula>. It is a subdivision of the plane into connected regions, called <emphasis>cells</emphasis>, associated with the sites (see <ref refid="index_1fig__figapollonius" kindref="member">fig__figapollonius</ref> (left)). The cell of a site <formula id="4">$ P_i$</formula> is the locus of points on the plane that are closer to <formula id="4">$ P_i$</formula> than any other site <formula id="5">$ P_j$</formula>, <formula id="6">$ j\neq i$</formula>. The distance <formula id="7">$ \delta(x, P_i)$</formula> of a point <formula id="8">$ x$</formula> in the plane to a site <formula id="4">$ P_i$</formula> is defined as: <formula id="9">\[ \delta(x,P_i)=\|x-c_i\|-w_i, \]</formula> where <formula id="10">$ \|\cdot\|$</formula> denotes the Euclidean norm. It can easily be seen that it is a generalization of the Voronoi diagram for points, which can actually be obtained if all the weights <formula id="3">$ w_i$</formula> are equal. Unlike the case of points, however, it is possible that a site <formula id="4">$ P_i$</formula> might have an empty cell. This can also happen in the case of the power diagram, whose dual is the regular triangulation (see Section <ref refid="index_1Section_2D_Triangulations_Regular" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Regular Triangulations</ref> ). If this is the case we call the site <emphasis>hidden</emphasis> (these are the black circles in <ref refid="index_1fig__figapollonius" kindref="member">fig__figapollonius</ref> ). A site which is not hidden will be referred to as <emphasis>visible</emphasis>.</para><para>If all weights <formula id="3">$ w_i$</formula> are non-negative, the Apollonius diagram can be viewed as the Voronoi diagram of the set of circles <formula id="11">$ \{P_1,\ldots, P_n\}$</formula>, where <formula id="2">$ c_i$</formula> is the center of the circle <formula id="4">$ P_i$</formula> and <formula id="3">$ w_i$</formula> its radius. If the weights are allowed to be negative, we need to go to 3D in order to explain what the Apollonius diagram means geometrically. We identify the 2D Euclidean plane with the <formula id="12">$ xy$</formula>-plane in 3D. Then the Voronoi diagram of a set of points can be seen as the vertical projection on the <formula id="12">$ xy$</formula>-plane of the lower envelope of a set of 3D cones defined as follows: for each point <formula id="13">$ p$</formula> in the set of 2D points we have a cone <formula id="14">$ C_p$</formula> whose apex is the point <formula id="13">$ p$</formula>. The axis of <formula id="14">$ C_p$</formula> is a line parallel to the <formula id="15">$ z$</formula>-axis passing through <formula id="13">$ p$</formula>, the angle of <formula id="14">$ C_p$</formula> is <formula id="16">$ 45^\circ$</formula> and, finally <formula id="14">$ C_p$</formula> is facing in the positive <formula id="15">$ z$</formula>-direction (that is, <formula id="14">$ C_p$</formula> is contained in the positive <formula id="15">$ z$</formula>-halfspace). The Apollonius diagram corresponds to shifting the apexes of these cones in the <formula id="15">$ z$</formula>-direction by a quantity equal to the weight. Sites with negative weight will give rise to cones whose apex is in the negative <formula id="15">$ z$</formula>-halfspace and sites with positive weight will give rise to cones whose apex is in the positive <formula id="15">$ z$</formula>-halfspace. In a manner analogous to the case of points, the Apollonius diagram can then be defined as the vertical projection on the <formula id="12">$ xy$</formula>-plane of the lower envelope of the set of shifted cones. Notice that when all apexes are translated along the <formula id="15">$ z$</formula>-direction by the same amount, the projection of the lower envelope of the set of cones does not change. In particular, we can translate all cones by a large enough amount so that all apexes are in the positive <formula id="15">$ z$</formula>-halfspace. Algebraically, this means that the Apollonius diagram does not change if we add to all weights the same quantity, which in particular, implies that we can assume without loss of generality that all weights are positive. Given the observations above and in order to simplify our discussion of Apollonius diagrams, we will, from now on, assume that all weights are positive, and we will refer to the sites as circles.</para><para>The Apollonius diagram is a planar graph, and so is its dual, the Apollonius graph. There are many ways to embed it on the plane and one such way is shown in <ref refid="index_1fig__figapollonius" kindref="member">fig__figapollonius</ref> (right). The Apollonius graph is uniquely defined once we have the Apollonius diagram. If the circles are in <emphasis>general position</emphasis> (see precise definition below), then the Apollonius graph is a graph with triangular faces away from the convex hull of the set of circles (by triangular we mean that every face has exactly three edges). Near the convex hull we may have some spikes (i.e., vertices of degree 1). To unify our approach and handling of the Apollonius graph we add to the set of (finite) circles a fictitious circle at infinity, which we call the <emphasis>site at infinity</emphasis>. We can then connect all vertices of the outer face of the Apollonius graph to the site at infinity which gives us a graph with the property that all of its faces are now triangular. However, the Apollonius graph is not a triangulation for two main reasons: we cannot always embed it on the plane with straight line segments that yield a triangulation and, moreover, we may have two faces of the graph that have two edges in common, which is not allowed in a triangulation. Both of these particularities appear when we consider the Apollonius graph of the set of circles in <ref refid="index_1fig__figapollonius" kindref="member">fig__figapollonius</ref>.</para><para>We would like to finish our brief introduction to the theory of Apollonius graphs by discussing the concept of general position. We say that a set of circles is in general position if no two triplets of circles have the same tritangent circle. This statement is rather technical and it is best understood in the context of points. The equivalent statement for points is that we have no two triplets of points that define the same circumcircle, or equivalently that no four points are co-circular. The statement about general position made above is a direct generalization of the (much simpler to understand) statement about points. On the contrary, when we have circles in degenerate position, the Apollonius graph has faces with more than three edges on their boundary. We can get a triangulated version of the graph by simply <emphasis>triangulating</emphasis> the corresponding faces in an arbitrary way. In fact the algorithm that has been implemented in CGAL has the property that it always returns a valid <emphasis>triangulated</emphasis> version of the Apollonius graph. By valid we mean that it contains the actual Apollonius graph (i.e., the actual dual of the Apollonius diagram) and whenever there are faces with more than three faces then they are triangulated. The way that they are triangulated depends on the order of insertion and deletion of the circles in the diagram.</para><para>One final point has to be made about hidden circles. First of all we would like to be more precise about our definition of hidden circles: we say that a circle is hidden if its cell has empty interior. This definition allows us to guarantee that all visible circles have cells that are two-dimensional regions. Geometrically the fact that a circle is hidden means that it is contained in the closure of the disk of another circle (see again <ref refid="index_1fig__figapollonius" kindref="member">fig__figapollonius</ref> ). Note that a circle contained in the union of several disks, but not in the closure of any one of them, is not hidden.</para><para>Hidden circles pose an additional difficulty to our algorithm and software design. Since we allow circles to be inserted and deleted at wish, it is possible that a circle that was hidden at some point in time, may become visible at a later point in time; for example this can happen if we delete the circle that hides it. For this purpose we store hidden circles and have them reappear when they become visible. We will discuss this issue in detail below. For the time being it suffices to say that the user has the ability to control this behavior. More specifically it is possible to discard the circles that become hidden. This choice is totally natural when for example we expect to do only insertions, since in this case a circle that becomes hidden will never reappear. On the other hand if deletions are expected as well, then we lose the ability to have the hidden circles reappear.</para><para><bold>Degenerate Dimensions.</bold></para><para>The dimension of the Apollonius graph is in general 2. The exceptions to this rule are as follows: <itemizedlist>
<listitem>
<para>The dimension is <formula id="17">$ -1$</formula> if the Apollonius graph contains no circles. </para></listitem>
<listitem>
<para>The dimension is <formula id="18">$ 0$</formula> if the Apollonius graph contains exactly one visible circle. </para></listitem>
<listitem>
<para>The dimension is <formula id="19">$ 1$</formula> is the Apollonius graph contains exactly two visible circles. </para></listitem>
</itemizedlist>
</para></sect1>
<sect1 id="index_1secapollonius2design">
<title>Software Design</title>
<para>The 2D Apollonius graph class <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__2" kindref="compound">Apollonius_graph_2</ref>&lt;<ref refid="classApolloniusGraphTraits__2" kindref="compound">ApolloniusGraphTraits_2</ref>,<ref refid="classApolloniusGraphDataStructure__2" kindref="compound">ApolloniusGraphDataStructure_2</ref>&gt;</computeroutput> follows the design of the triangulation package of CGAL. It is parametrized by two arguments: <itemizedlist>
<listitem>
<para>the <bold>geometric traits</bold> class. It provides the basic geometric objects involved in the algorithm, such as sites, points etc. It also provides the geometric predicates for the computation of the Apollonius graph, as well as some basic constructions that can be used, for example, to visualize the Apollonius graph or the Apollonius diagram. The geometric traits for the Apollonius graph will be discussed in more detail in the next section. </para></listitem>
<listitem>
<para>the <bold>Apollonius graph data structure</bold>. This is essentially the same as the triangulation data structure (discussed in Chapter <ref refid="index_1Chapter_2D_Triangulation_Data_Structure" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">Chapter_2D_Triangulation_Data_Structure</ref> ), augmented with some additional operations that are specific to Apollonius graphs. The corresponding concept is that of <computeroutput><ref refid="classApolloniusGraphDataStructure__2" kindref="compound">ApolloniusGraphDataStructure_2</ref></computeroutput>, which in fact is a refinement of the <computeroutput><ref refid="classTriangulationDataStructure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">TriangulationDataStructure_2</ref></computeroutput> concept. The class <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">Triangulation_data_structure_2</ref>&lt;Vb,Fb&gt;</computeroutput> is a model of the concept <computeroutput><ref refid="classApolloniusGraphDataStructure__2" kindref="compound">ApolloniusGraphDataStructure_2</ref></computeroutput>. A default value for the corresponding template parameter is provided, so the user does not need to specify it. </para></listitem>
</itemizedlist>
</para><para><bold>Storing Hidden Sites.</bold></para><para>As we have already mentioned a circle is hidden if it is contained inside some visible circle. This creates a parent-child relationship between visible and hidden circles: the parent of a hidden circle is the visible circle that contains it. If more than one visible circles contain a hidden circle then the hidden circle can be assigned to any of the visible circles arbitrarily.</para><para>To store hidden circles we assign to every visible circle a list. This list comprises the hidden circles that are contained in the visible circle. The user can access the hidden circles associated with a visible circle through an iterator called <computeroutput>Hidden_sites_iterator</computeroutput>. This iterator is defined in the <computeroutput><ref refid="classApolloniusGraphVertexBase__2" kindref="compound">ApolloniusGraphVertexBase_2</ref></computeroutput> concept and is implemented by its model, the <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__vertex__base__2" kindref="compound">Apollonius_graph_vertex_base_2</ref>&lt;Gt,StoreHidden&gt;</computeroutput> class. It is also possible to iterate through the entire set of hidden sites using an homonymous iterator defined by the <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__2" kindref="compound">Apollonius_graph_2</ref>&lt;Gt,Agds&gt;</computeroutput> class.</para><para>Since storing hidden sites may not be of interest in some cases (e.g., for example this is the case if we only perform insertions in the Apollonius graph), the user has the possibility of controlling this behavior. More precisely, the class <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__vertex__base__2" kindref="compound">Apollonius_graph_vertex_base_2</ref>&lt;Gt,StoreHidden&gt;</computeroutput> has two template parameters, the second of which is a Boolean value. This value is by default <computeroutput>true</computeroutput> and it indicates that hidden sites should be stored. The user can indicate that hidden sites may be discarded by setting this value to <computeroutput>false</computeroutput>.</para></sect1>
<sect1 id="index_1secapollonius2traits">
<title>The Geometric Traits</title>
<para>The predicates required for the computation of the Apollonius graph are rather complicated. It is not the purpose of this document to discuss them in detail. The interested reader may refer to the papers by Karavelas and Emiris for the details <ref refid="citelist_1CITEREF_cgal:ke-ppawv-02" kindref="member">[3]</ref>, <ref refid="citelist_1CITEREF_cgal:ke-rctac-03" kindref="member">[4]</ref>. However, we would like to give a brief overview of what they compute. There are several predicates needed by this algorithm. We will discuss the most important/complicated ones. It turns out that it is much easier to describe them in terms of the Apollonius diagram, rather than the Apollonius graph. Whenever it is applicable we will also describe their meaning in terms of the Apollonius graph.</para><para>The first two geometric predicates are called <computeroutput>Is_hidden_2</computeroutput> and <computeroutput>Oriented_side_of_bisector_2</computeroutput>. The first one involves two circles, say <formula id="20">$ P_1$</formula> and <formula id="21">$ P_2$</formula>. It determines if <formula id="20">$ P_1$</formula> is hidden with respect to <formula id="21">$ P_2$</formula>; more precisely it checks whether the circle <formula id="20">$ P_1$</formula> is contained in the closure of the disk defined by the circle <formula id="21">$ P_2$</formula>. As its name indicates, it determines if a circle is hidden or not. The second predicate involves two circles <formula id="20">$ P_1$</formula> and <formula id="21">$ P_2$</formula> and a point <formula id="22">$ q$</formula>. It answers the question whether <formula id="22">$ q$</formula> is closer to <formula id="20">$ P_1$</formula> or <formula id="21">$ P_2$</formula>. Its name stems from the fact that answering the aforementioned question is equivalent to determining the oriented side of the bisector of <formula id="20">$ P_1$</formula> and <formula id="21">$ P_2$</formula> that contains the query point <formula id="22">$ q$</formula>. This predicate is used by the algorithm for closest neighbor queries for points.</para><para>The next geometric predicate is called <computeroutput>Vertex_conflict_2</computeroutput> and it involves four circles <formula id="20">$ P_1$</formula>, <formula id="21">$ P_2$</formula>, <formula id="23">$ P_3$</formula>, and <formula id="24">$ P_4$</formula> (see <ref refid="index_1fig__figag2vc" kindref="member">fig__figag2vc</ref> ). The first three (red circles in <ref refid="index_1fig__figag2vc" kindref="member">fig__figag2vc</ref> ) define a tritangent circle (yellow circle in <ref refid="index_1fig__figag2vc" kindref="member">fig__figag2vc</ref> ). What we want to determine is the sign of the distance of the green circle from the yellow circle. The distance between two circles <formula id="25">$ K_1=(c_1,r_1)$</formula> and <formula id="26">$ K_2=(c_2, r_2)$</formula> is defined as the distance of their centers minus their radii: <formula id="27">\[ \delta(K_1, K_2) = \|c_1-c_2\|-r_1-r_2. \]</formula> This predicate determines if a vertex in the Apollonius diagram (the center of the yellow circle) is destroyed when a new circle is inserted in the diagram (the green circle). In the Apollonius graph it tells us if a triangular face of the diagram is to be destroyed or not.</para><para><anchor id="index_1fig__figag2vc"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="apollonius-vertex_conflict-false.png"></image>
 <image type="latex" name="apollonius-vertex_conflict-false.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="apollonius-vertex_conflict-true.png"></image>
 <image type="latex" name="apollonius-vertex_conflict-true.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__figag2vc" kindref="member">fig__figag2vc</ref> The <computeroutput>Vertex_conflict_2</computeroutput> predicate. The left-most, bottom-most and top-most circles define the tritangent circle in the middle. We want to determine the sign of the distance of the left-most circle from the one in the middle. The almost horizontal curve is the bisector of the top-most and bottom-most circles. Left: the predicate returns <computeroutput>NEGATIVE</computeroutput>. Right: the predicate returns <computeroutput>POSITIVE</computeroutput>.  <linebreak/>
</para><para>What we essentially want to compute when we construct incrementally a Voronoi diagram, is whether the object to be inserted destroys an edge of the Voronoi diagram or not. In the case of points this is really easy and it amounts to the well known <emphasis>incircle</emphasis> test. In the case of circles the situation is more complicated. We can have six possible outcomes as to what portion of an edge of the Apollonius diagram the new circle destroys (see <ref refid="index_1fig__figag2edgeconflict" kindref="member">fig__figag2edgeconflict</ref> ). The first two can be answered directly by the <computeroutput>Vertex_conflict_2</computeroutput> predicate evaluated for the two endpoints of the Apollonius diagram edge. This is due to the fact that the value of the <computeroutput>Vertex_conflict_2</computeroutput> predicate is different for the two endpoints. If the two values are the same then we need an additional test which determines if the interior of the Apollonius diagram edge is destroyed by the new circle. This is what the <computeroutput>Finite_edge_interior_conflict_2</computeroutput> and <computeroutput>Infinite_edge_interior_conflict_2</computeroutput> predicates do. In essence, it is the same predicate (same idea) applied to two different types of edges in the Apollonius diagram: a finite or an infinite edge. An edge is infinite if its dual edge in the Apollonius graph connects the site at infinity with the vertex corresponding to a (finite) circle; otherwise it is a finite edge.</para><para><anchor id="index_1fig__figag2edgeconflict"/><center> <table rows="3" cols="2"><row>
<entry thead="no"><para><image type="html" name="apollonius-left_vertex.png"></image>
 <image type="latex" name="apollonius-left_vertex.png"></image>
  </para></entry><entry thead="no"><para><image type="html" name="apollonius-right_vertex.png"></image>
 <image type="latex" name="apollonius-right_vertex.png"></image>
   </para></entry></row>
<row>
<entry thead="no"><para><image type="html" name="apollonius-no_conflict.png"></image>
 <image type="latex" name="apollonius-no_conflict.png"></image>
  </para></entry><entry thead="no"><para><image type="html" name="apollonius-entire_edge.png"></image>
 <image type="latex" name="apollonius-entire_edge.png"></image>
   </para></entry></row>
<row>
<entry thead="no"><para><image type="html" name="apollonius-interior.png"></image>
 <image type="latex" name="apollonius-interior.png"></image>
  </para></entry><entry thead="no"><para><image type="html" name="apollonius-both_vertices.png"></image>
 <image type="latex" name="apollonius-both_vertices.png"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__figag2edgeconflict" kindref="member">fig__figag2edgeconflict</ref> The 6 possible outcomes of the <computeroutput>Finite_edge_interior_conflict_2</computeroutput> predicate. Top left: only a neighborhood around the left-most endpoint of the edge will be destroyed. Top right: only a neighborhood around the right-most endpoint of the edge will be destroyed. Middle left: no portion of the edge is destroyed. Middle right: the entire edge will be destroyed. Bottom left: a neighborhood in the interior of the edge will be destroyed; the regions near the endpoints remain unaffected. Bottom right: The neighborhood around the two endpoints will be destroyed, but an interval in the interior of the edge will remain in the new diagram.  <linebreak/>
</para><para>The last predicate that we want to discuss is called <computeroutput>Is_degenerate_edge_2</computeroutput>. It tells us whether an edge in the Apollonius diagram is degenerate, that is if its two endpoints coincide. In the Apollonius graph such an edge corresponds to one of the additional edges that we use to triangulate the non-triangular faces.</para><para>The aforementioned predicates are part of the <computeroutput><ref refid="classApolloniusGraphTraits__2" kindref="compound">ApolloniusGraphTraits_2</ref></computeroutput> concept of CGAL. CGAL also provides a model for this concept, the <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__traits__2" kindref="compound">Apollonius_graph_traits_2</ref>&lt;K,Method_tag&gt;</computeroutput> class. The first template parameter of this class must be a model of the <computeroutput><ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> concept. The second template parameter is a tag that indicates what operations are allowed in the computations that take place within the traits class. The two possible values of the <computeroutput>Method_tag</computeroutput> parameter are <computeroutput>Ring_tag</computeroutput> and <computeroutput>Sqrt_field_tag</computeroutput>. When <computeroutput>Ring_tag</computeroutput> is used, only ring operations are used during the evaluation of the predicates, whereas if <computeroutput>Sqrt_field_tag</computeroutput> is chosen, all four field operations, as well as square roots, are used during the predicate evaluation.</para><para>The <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__traits__2" kindref="compound">Apollonius_graph_traits_2</ref>&lt;K,Method_tag&gt;</computeroutput> class provides exact predicates if the number type in the kernel <computeroutput>K</computeroutput> is an exact number type. This is to be associated with the type of operations allowed for the predicate evaluation. For example <computeroutput>MP_Float</computeroutput> as number type, with <computeroutput>Ring_tag</computeroutput> as tag will give exact predicates, whereas <computeroutput>MP_Float</computeroutput> with <computeroutput>Sqrt_field_tag</computeroutput> will give inexact predicates.</para><para>Since using an exact number type may be too slow, the <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__traits__2" kindref="compound">Apollonius_graph_traits_2</ref>&lt;K,Method_tag&gt;</computeroutput> class is designed to support the dynamic filtering of CGAL through the <computeroutput>Filtered_exact&lt;CT,ET&gt;</computeroutput> mechanism. In particular if <computeroutput>CT</computeroutput> is an inexact number type that supports the operations denoted by the tag <computeroutput>Method_tag</computeroutput> and <computeroutput>ET</computeroutput> is an exact number type for these operations, then kernel with number type <computeroutput>Filtered_exact&lt;CT,ET&gt;</computeroutput> will yield exact predicates for the Apollonius graph traits. To give a concrete example, <computeroutput>CGAL::Filtered_exact&lt;double,CGAL::MP_Float&gt;</computeroutput> with <computeroutput>Ring_tag</computeroutput> will produce exact predicates.</para><para>Another possibility for fast and exact predicate evaluation is to use the <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__filtered__traits__2" kindref="compound">Apollonius_graph_filtered_traits_2</ref>&lt;CK,CM,EK,EM,FK,FM&gt;</computeroutput> class. This class is the analog of a filtered kernel. It takes a constructions kernel <computeroutput>CK</computeroutput>, a filtering kernel <computeroutput>FK</computeroutput> and an exact kernel <computeroutput>EK</computeroutput>, as well as the corresponding tags (<computeroutput>CM</computeroutput>, <computeroutput>FM</computeroutput> and <computeroutput>EM</computeroutput>, respectively). It evaluates the predicates by first using the filtering kernel, and if this fails the evaluation is performed using the exact kernel. The constructions are done using the kernel <computeroutput>CK</computeroutput>, which means that they are not necessarily exact. All template parameters except <computeroutput>CK</computeroutput> have default values, which are explained in the reference manual.</para></sect1>
<sect1 id="index_1secapollonius2hierarchy">
<title>The Apollonius Graph Hierarchy</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__hierarchy__2" kindref="compound">Apollonius_graph_hierarchy_2</ref>&lt;<ref refid="classApolloniusGraphTraits__2" kindref="compound">ApolloniusGraphTraits_2</ref>,<ref refid="classApolloniusGraphDataStructure__2" kindref="compound">ApolloniusGraphDataStructure_2</ref>&gt;</computeroutput> class is nothing but the equivalent of the <computeroutput><ref refid="classCGAL_1_1Triangulation__hierarchy__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Triangulation_hierarchy_2</ref></computeroutput> class, applied to the Apollonius graph. It consists of a series of Apollonius graphs constructed in a manner analogous to the Delaunay hierarchy by Devillers <ref refid="citelist_1CITEREF_d-iirdt-98" kindref="member">[2]</ref>. The class <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__hierarchy__2" kindref="compound">Apollonius_graph_hierarchy_2</ref>&lt;<ref refid="classApolloniusGraphTraits__2" kindref="compound">ApolloniusGraphTraits_2</ref>,<ref refid="classApolloniusGraphDataStructure__2" kindref="compound">ApolloniusGraphDataStructure_2</ref>&gt;</computeroutput> has exactly the same interface and functionality as the <computeroutput><ref refid="classCGAL_1_1Apollonius__graph__2" kindref="compound">Apollonius_graph_2</ref>&lt;<ref refid="classApolloniusGraphTraits__2" kindref="compound">ApolloniusGraphTraits_2</ref>,<ref refid="classApolloniusGraphDataStructure__2" kindref="compound">ApolloniusGraphDataStructure_2</ref>&gt;</computeroutput> class. Using the Apollonius graph hierarchy involves an additional cost in space and time for maintaining the hierarchy. Our experiments have shown that it usually pays off to use the hierarchy for inputs consisting of more than 1,000 circles. This threshold holds for both the construction of the Apollonius diagram itself, as well as for nearest neighbor queries.</para></sect1>
<sect1 id="index_1secapollonius2examples">
<title>Examples</title>
<sect2 id="index_1Apollonius_graph_2FirstExample">
<title>First Example</title>
<para><linebreak/>
<bold>File</bold> <ref refid="Apollonius_graph_2_2ag2_exact_traits_8cpp-example" kindref="compound">Apollonius_graph_2/ag2_exact_traits.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>number<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/MP_Float.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>that<sp/>uses<sp/>an<sp/>exact<sp/>number<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::MP_Float<sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>***<sp/>WARNING<sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>use<sp/>of<sp/>a<sp/>kernel<sp/>based<sp/>on<sp/>an<sp/>exact<sp/>number<sp/>type<sp/>is<sp/>highly<sp/>inefficient.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>It<sp/>is<sp/>used<sp/>in<sp/>this<sp/>example<sp/>primarily<sp/>for<sp/>illustration<sp/>purposes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>In<sp/>an<sp/>efficiency<sp/>critical<sp/>context,<sp/>and/or<sp/>for<sp/>the<sp/>purposes<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>benchmarking<sp/>the<sp/>Apollonius_graph_filtered_traits_2&lt;&gt;<sp/>class<sp/>should</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>be<sp/>used.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>choose<sp/>the<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;NT&gt;</ref><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Apollonius_graph_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Apollonius_graph_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Apollonius__graph__traits__2" kindref="compound">CGAL::Apollonius_graph_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Apollonius__graph__2" kindref="compound">CGAL::Apollonius_graph_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Apollonius_graph;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>ifs(</highlight><highlight class="stringliteral">&quot;data/sites.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Apollonius_graph<sp/>ag;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Apollonius_graph::Site_2<sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>the<sp/>sites<sp/>and<sp/>insert<sp/>them<sp/>in<sp/>the<sp/>Apollonius<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ag.insert(site);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>Apollonius<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ag.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Apollonius_graph_2SecondExample">
<title>Second Example</title>
<para><linebreak/>
<bold>File</bold> <ref refid="Apollonius_graph_2_2ag2_exact_traits_sqrt_8cpp-example" kindref="compound">Apollonius_graph_2/ag2_exact_traits_sqrt.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined<sp/>CGAL_USE_LEDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>include<sp/>&lt;CGAL/leda_real.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>include<sp/>&lt;CGAL/CORE_Expr.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>***<sp/>WARNING<sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>use<sp/>of<sp/>a<sp/>kernel<sp/>based<sp/>on<sp/>an<sp/>exact<sp/>number<sp/>type<sp/>is<sp/>highly<sp/>inefficient.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>It<sp/>is<sp/>used<sp/>in<sp/>this<sp/>example<sp/>primarily<sp/>for<sp/>illustration<sp/>purposes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>In<sp/>an<sp/>efficiency<sp/>critical<sp/>context,<sp/>and/or<sp/>for<sp/>the<sp/>purposes<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>benchmarking<sp/>the<sp/>Apollonius_graph_filtered_traits_2&lt;&gt;<sp/>class<sp/>should</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>be<sp/>used.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined<sp/>CGAL_USE_LEDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>If<sp/>LEDA<sp/>is<sp/>present<sp/>use<sp/>leda_real<sp/>as<sp/>the<sp/>exact<sp/>number<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>leda_real<sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Otherwise<sp/>if<sp/>CORE<sp/>is<sp/>present<sp/>use<sp/>CORE&apos;s<sp/>Expr<sp/>as<sp/>the<sp/>exact<sp/>number<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CORE::Expr<sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Otherwise<sp/>just<sp/>use<sp/>double.<sp/>This<sp/>may<sp/>cause<sp/>numerical<sp/>errors<sp/>but<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>is<sp/>still<sp/>worth<sp/>doing<sp/>it<sp/>to<sp/>show<sp/>how<sp/>to<sp/>define<sp/>correctly<sp/>the<sp/>traits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>class</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;NT&gt;</ref><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Apollonius_graph_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Apollonius_graph_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>traits<sp/>class<sp/>is<sp/>now<sp/>going<sp/>to<sp/>assume<sp/>that<sp/>the<sp/>operations</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>+,-,*,/<sp/>and<sp/>sqrt<sp/>are<sp/>supported<sp/>exactly</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Apollonius__graph__traits__2" kindref="compound">CGAL::Apollonius_graph_traits_2&lt;Kernel,CGAL::Field_with_sqrt_tag&gt;</ref><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Apollonius__graph__2" kindref="compound">CGAL::Apollonius_graph_2&lt;Traits&gt;</ref><sp/>Apollonius_graph;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>ifs(</highlight><highlight class="stringliteral">&quot;data/sites.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Apollonius_graph<sp/>ag;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Apollonius_graph::Site_2<sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>the<sp/>sites<sp/>and<sp/>insert<sp/>them<sp/>in<sp/>the<sp/>Apollonius<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ag.insert(site);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>Apollonius<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ag.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Apollonius_graph_2ThirdExample">
<title>Third Example</title>
<para><linebreak/>
<bold>File</bold> <ref refid="Apollonius_graph_2_2ag2_filtered_traits_no_hidden_8cpp-example" kindref="compound">Apollonius_graph_2/ag2_filtered_traits_no_hidden.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>that<sp/>uses<sp/>the<sp/>filtered<sp/>traits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>choose<sp/>the<sp/>representation</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Rep;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Apollonius_graph_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_data_structure_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Apollonius_graph_vertex_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_face_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Apollonius_graph_filtered_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedef<sp/>for<sp/>the<sp/>traits;<sp/>the<sp/>filtered<sp/>traits<sp/>class<sp/>is<sp/>used</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Apollonius__graph__filtered__traits__2" kindref="compound">CGAL::Apollonius_graph_filtered_traits_2&lt;Rep&gt;</ref><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>With<sp/>the<sp/>second<sp/>template<sp/>argument<sp/>in<sp/>the<sp/>vertex<sp/>base<sp/>class<sp/>being</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>false,<sp/>we<sp/>indicate<sp/>that<sp/>there<sp/>is<sp/>no<sp/>need<sp/>to<sp/>store<sp/>the<sp/>hidden<sp/>sites.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>One<sp/>case<sp/>where<sp/>this<sp/>is<sp/>indeed<sp/>not<sp/>needed<sp/>is<sp/>when<sp/>we<sp/>only<sp/>do</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>insertions,<sp/>like<sp/>in<sp/>the<sp/>main<sp/>program<sp/>below.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Apollonius__graph__vertex__base__2" kindref="compound">CGAL::Apollonius_graph_vertex_base_2&lt;Traits,false&gt;</ref><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__face__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::Triangulation_face_base_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Agds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Apollonius__graph__2" kindref="compound">CGAL::Apollonius_graph_2&lt;Traits,Agds&gt;</ref><sp/><sp/><sp/><sp/>Apollonius_graph;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>ifs(</highlight><highlight class="stringliteral">&quot;data/sites.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Apollonius_graph<sp/>ag;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Apollonius_graph::Site_2<sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>the<sp/>sites<sp/>and<sp/>insert<sp/>them<sp/>in<sp/>the<sp/>Apollonius<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ag.insert(site);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>Apollonius<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ag.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>now<sp/>remove<sp/>all<sp/>sites</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Removing<sp/>all<sp/>sites...<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::flush;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ag.number_of_vertices()<sp/>&gt;<sp/>0<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ag.remove(<sp/>ag.finite_vertex()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Apollonius_graph_2FourthExample">
<title>Fourth Example</title>
<para><linebreak/>
<bold>File</bold> <ref refid="Apollonius_graph_2_2ag2_hierarchy_8cpp-example" kindref="compound">Apollonius_graph_2/ag2_hierarchy.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>that<sp/>uses<sp/>the<sp/>filtered<sp/>traits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/MP_Float.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>constructions<sp/>kernel<sp/>(inexact)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>CK;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>exact<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;CGAL::MP_Float&gt;</ref><sp/>EK;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Apollonius_graph_hierarchy_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Apollonius_graph_filtered_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Type<sp/>definition<sp/>for<sp/>the<sp/>traits<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>In<sp/>this<sp/>example<sp/>we<sp/>explicitly<sp/>define<sp/>the<sp/>exact<sp/>kernel.<sp/>We<sp/>also</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>explicitly<sp/>define<sp/>what<sp/>operations<sp/>to<sp/>use<sp/>for<sp/>the<sp/>evaluation<sp/>of<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>predicates<sp/>and<sp/>constructions,<sp/>when<sp/>the<sp/>filtering<sp/>and<sp/>the<sp/>exact</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>kernels<sp/>are<sp/>used<sp/>respectively.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>the<sp/>operations<sp/>allowed<sp/>for<sp/>the<sp/>filtering<sp/>and<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>constructions<sp/>(field<sp/>operations<sp/>plus<sp/>square<sp/>roots)<sp/>are<sp/>different</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>from<sp/>the<sp/>operations<sp/>allowed<sp/>when<sp/>the<sp/>exact<sp/>kernel<sp/>is<sp/>used<sp/>(ring</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>operations).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Field__with__sqrt__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::Field_with_sqrt_tag</ref><sp/><sp/>CM;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Integral__domain__without__division__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::Integral_domain_without_division_tag</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EM;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Apollonius__graph__filtered__traits__2" kindref="compound">CGAL::Apollonius_graph_filtered_traits_2&lt;CK,CM,EK,EM&gt;</ref><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Now<sp/>we<sp/>use<sp/>the<sp/>Apollonius<sp/>graph<sp/>hierarchy.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>hierarchy<sp/>is<sp/>faster<sp/>for<sp/>inputs<sp/>consisting<sp/>of<sp/>about<sp/>more<sp/>than</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>1,000<sp/>sites</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Apollonius__graph__hierarchy__2" kindref="compound">CGAL::Apollonius_graph_hierarchy_2&lt;Traits&gt;</ref><sp/>Apollonius_graph;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>ifs(</highlight><highlight class="stringliteral">&quot;data/hierarchy.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Apollonius_graph<sp/>ag;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Apollonius_graph::Site_2<sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>the<sp/>sites<sp/>and<sp/>insert<sp/>them<sp/>in<sp/>the<sp/>Apollonius<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ag.insert(site);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>Apollonius<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ag.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
