<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Jet_fitting_3/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Estimation of Local Differential Properties of Point-Sampled Surfaces: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Estimation of Local Differential Properties of Point-Sampled Surfaces
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Estimation_of_Local_Differential_Properties_of_Point-Sampled_Surfaces"></a><a class="anchor" id="chapJetfitting3"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Marc Pouget and Frédéric Cazals</dd></dl>
<p><a class="anchor" id="fig__figjet3figdavid"></a></p><div class="image">
<img src="david-dirmaxkmin-white-back.jpg" alt="david-dirmaxkmin-white-back.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figjet3figdavid">Figure 70.1</a> Principal directions associated with \(k_{max}\) scaled by \( k_{min}\).  </div>  <br />

<p>This package allows the estimation of local differential quantities of a surface from a point sample, given either as a mesh or as point cloud.</p>
<p>Note that this package needs the third party library <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/installation.html#thirdpartyEigen">Eigen</a> to be installed to compile the example code..</p>
<h1><a class="anchor" id="secintro"></a>
Introduction</h1>
<h2><a class="anchor" id="Jet_fitting_3Overview"></a>
Overview</h2>
<p>Consider a sampled smooth surface, and assume we are given a collection of points \( P\) about a given sample \( p\). We aim at estimating the differential properties up to any fixed order of the surface at point \( p\) from the point set \( P^+ = P\cup \{ p\}\) - we denote \( N=\mid P^+\mid\). More precisely, first order properties correspond to the normal or the tangent plane; second order properties provide the principal curvatures and directions, third order properties provide the directional derivatives of the principal curvatures along the curvature lines, etc. Most of the time, estimating first and second order differential quantities is sufficient. However, some applications involving shape analysis require estimating third and fourth order differential quantities. Many different estimators have been proposed in the vast literature of applied geometry <a class="el" href="citelist.html#CITEREF_cgal:p-smrqt-01">[4]</a> (section 3, page 7), and all of them need to define a neighborhood around the point at which the estimation is computed. Our method relies on smooth differential geometry calculations, carried out on smooth objects <em>fitted</em> from the sample points. Datasets amenable to such a processing are naturally unstructured point clouds, as well as meshes - whose topological information may be discarded.</p>
<p>Estimating differential properties from discrete date always raises a philosophical issue. On one hand, estimating differential quantities subsumes a smooth surface does exist. In this spirit one wishes to recover its differential properties, so that any estimation method must come with an asymptotic convergence analysis of the results returned. For the method developed in this <span style="font-variant: small-caps;">CGAL</span> package, the interested will find such an analysis in <a class="el" href="citelist.html#CITEREF_cgal:cp-edqpf-05">[1]</a>, (Theorem 3) - it should be stressed the error bounds proved therein are optimal.</p>
<p>On the other hand, any estimation method may be applied to arbitrarily data - surface unknown, surface piecewise smooth etc. In such a case, no analysis can be carried out, and it is up to the users to check the results match their needs.</p>
<p>Unlike most of the <span style="font-variant: small-caps;">CGAL</span> packages, this package uses approximation methods and is not intended to provide an exact canonical result in any sense. This is why internal computations are performed with a number type possibly different from that of the input data, even if for convenience the results are returned with this original number type. A reasonable choice for this internal number type is for example the <code>double</code> type.</p>
<h2><a class="anchor" id="Jet_fitting_3SmoothSurfacesdJetsandtheMonge"></a>
Smooth Surfaces, d-Jets and the Monge Form</h2>
<p>To present the method, we shall need the following notions. Consider a smooth surface. About one of its points, consider a coordinate system whose \( z\)-axis does not belong to the tangent space. In such a frame, the surface can locally be written as the graph of a bivariate function. Letting \( h.o.t.\) stand for <em>higher order terms</em>, one has :</p>
<p class="formulaDsp">
\[ \begin{equation} z(x,y)=J_{B,d}(x,y) + h.o.t. \ ; \quad J_{B,d}(x,y)=\ccSum{k=0}{d}{(\ccSum{i=0}{i}{ \frac{B_{k-i,i}x^{k-i}y^{i}}{i!(k-i)!}})}. \end{equation} \]
</p>
<p>The degree \( d\) polynomial \( J_{B,d}\) is the Taylor expansion of the function \( z\), and is called its <em> \( d\)-jet</em>. Notice that a \( d\)-jet contains \( N_d=(d+1)(d+2)/2\) coefficients.</p>
<p>Recall that an umbilical point of a surface - or umbilic for short, is a point where both principal curvatures are identical. At any point of the surface which is not an umbilic, principal directions \( d_1, d_2\) are well defined, and these (non oriented) directions together with the normal vector \( n\) define two direct orthonormal frames. If \( v_1\) is a unit vector of direction \( d_1\), there exists a unique unit vector \( v_2\) so that \( (v_1,v_2,n)\) is direct; and the other possible frame is \( (-v_1,-v_2,n)\). Both these coordinate systems are known as the <em>Monge coordinate systems</em>. In both these systems, the surface is said to be given in the Monge form and its jet has the following canonical form :</p>
<p class="formulaDsp">
\begin{eqnarray} z(x,y) = &amp; \frac{1}{2}(k_1x^2 + k_2y^2)+ \frac{1}{6}(b_0x^3+3b_1x^2y+3b_2xy^2+b_3y^3) \\ &amp; +\frac{1}{24}(c_0x^4+4c_1x^3y+6c_2x^2y^2+4c_3xy^3+c_4y^4) + h.o.t. \end{eqnarray}
</p>
<p>The coefficients \( k_1, k_2\) are the principal curvatures, \( b_0,b_3\) are the directional derivatives of \( k_1,k_2\) along their respective curvature line, while \( b_1,b_2\) are the directional derivatives of \( k_1,k_2\) along the other curvature lines.</p>
<p>The Monge coordinate system can be computed from any \( d\)-jet ( \( d\geq 2\)), and so are the Monge coefficients. These informations characterize the local geometry of the surface in a canonical way, and are the quantities returned by our algorithm.</p>
<h2><a class="anchor" id="Jet_fitting_3Algorithm"></a>
Algorithm</h2>
<p>Based on the above concepts, the algorithm consists of 4 steps. </p><ol>
<li>
We perform a Principal Component Analysis (PCA) on \( P^+\). This analysis outputs three orthonormal eigenvectors and the associated eigenvalues. The fitting basis consists of these three vectors so that the vector associated to the smallest eigenvalue is the last vector of the basis. (Indeed, if the surface is well sampled, one expects the PCA to provide one small and two large eigenvalues, the eigenvector associated to the small one approximating the normal vector.) </li>
<li>
We perform a change of coordinates to move the samples into the coordinate system of the fitting basis and with origin the point \( p\) at which the estimation is sought. We then resort to polynomial fitting, so as to either interpolate or approximate the \( d\)-jet of the surface in this coordinate system. This bivariate polynomial approximation reduces to linear algebra operations. </li>
<li>
From the fitted \( d\)-jet, we compute the Monge basis \( (d_1,d_2,n)\). </li>
<li>
Finally, we compute the Monge coefficients : \( k_i, b_i, c_i\). </li>
</ol>
<p>Further details can be found in section <a class="el" href="index.html#Jet_fitting_3Mathematical">Mathematical and Algorithmic Details</a> and in <a class="el" href="citelist.html#CITEREF_cgal:cp-edqpf-05">[1]</a> (section 6).</p>
<h2><a class="anchor" id="secdegcases"></a>
Degenerate Cases</h2>
<p>As usual, the fitting procedure may run into (almost) degenerate cases: </p><ul>
<li>
<p class="startli">Due to poor sampling, the PCA used to determine a rough normal vector may not be good. The nearer this direction to the tangent plane the worse the estimation.</p>
<p class="endli"></p>
</li>
<li>
As observed in <a class="el" href="citelist.html#CITEREF_cgal:cp-edqpf-05">[1]</a> (section 3.1), the interpolating problem is not well posed if the points project, into the fitting frame, onto an algebraic curve of degree \( d\). More generally, the problem is ill posed if the condition number is too large. </li>
</ul>
<p>In these cases, even if a result is provided, the estimation may not be relevant. To inform the user of these issues, we provide the PCA results and the condition number of the fitting. In any case, it is up to the user to judge if the result meets its need.</p>
<h1><a class="anchor" id="Jet_fitting_3Software"></a>
Software Design</h1>
<h2><a class="anchor" id="Jet_fitting_3OptionsandInterfaceSpecifications"></a>
Options and Interface Specifications</h2>
<p>The fitting strategy performed by the class <code><a class="el" href="classCGAL_1_1Monge__via__jet__fitting.html" title="The class Monge_via_jet_fitting is designed to perform the estimation of the local differential quant...">Monge_via_jet_fitting</a></code> requires the following parameters: </p><ul>
<li>
the degree \( d\) of the fitted polynomial ( \( d \geq 1\)), </li>
<li>
the degree \( d'\) of the Monge coefficients sought, with \( 1 \leq d' \leq \min(d,4) \), </li>
<li>
a range of \( N\) input points on the surface, with the precondition that \( N \geq N_d = (d+1)(d+2)/2\). Note that if \( N=N_d\), interpolation is performed; and if \( N &gt;N_d\), approximation is used. </li>
</ul>
<h2><a class="anchor" id="Jet_fitting_3Output"></a>
Output</h2>
<p>As explained in Section <a class="el" href="index.html#secintro">Introduction</a> , the output consists of a coordinate system, the Monge basis, together with the Monge coefficients which are stored in the <code><a class="el" href="classCGAL_1_1Monge__via__jet__fitting_1_1Monge__form.html" title="The class Monge_form stores the Monge representation, i.e., the Monge coordinate system and the coeff...">CGAL::Monge_via_jet_fitting::Monge_form</a></code> class. In addition, more information on the computational issues are stored in the <code><a class="el" href="classCGAL_1_1Monge__via__jet__fitting.html" title="The class Monge_via_jet_fitting is designed to perform the estimation of the local differential quant...">Monge_via_jet_fitting</a></code> class.</p>
<p>The <code><a class="el" href="classCGAL_1_1Monge__via__jet__fitting_1_1Monge__form.html" title="The class Monge_form stores the Monge representation, i.e., the Monge coordinate system and the coeff...">CGAL::Monge_via_jet_fitting::Monge_form</a></code> class provides the following information.</p>
<ul>
<li>
<p class="startli">Origin. This is the point on the fitted polynomial surface where the differential quantities have been computed. In the approximation case, it differs from the input point \( p\) : it is the projection of \( p\) onto the fitted surface following the \( z\)-direction of the fitting basis.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Monge Basis. The Monge basis \( (d_1,d_2,n)\) is orthonormal direct, and the maximal, minimal curvatures are defined wrt this basis. If the user has a predefined normal \( n_0\) (e.g. the sample points come from an oriented mesh) then if \( n_0 . n &gt;0\) then max-min is correct; if not, i.e. \( n_0 . n &lt;0\), the user should switch to the orthonormal direct basis \( (d_1',d_2',n')=(d_2,d_1,-n)\) with the maximal curvature \( k_1'=-k_2\) and the minimal curvature \( k_2'=-k_1\). If \( n_0 . n =0\) or is small, the orientation of the surface is clearly ill-defined, and the user may proof-check the samples used to comply with its predefined normal.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Monge Coefficients. The coefficient of the Monge form is \( (k_1, k_2 (\leq k_1), b_0, b_1, b_2, b_3, c_0, c_1, c_2, c_3, c_4)\) for \( d' = 4\).</p>
<p class="endli"></p>
</li>
</ul>
<p>In addition, the class <code><a class="el" href="classCGAL_1_1Monge__via__jet__fitting.html" title="The class Monge_via_jet_fitting is designed to perform the estimation of the local differential quant...">Monge_via_jet_fitting</a></code> stores </p><ul>
<li>
the condition number of the fitting system, </li>
<li>
the coordinate system of the PCA (in which the fitting is performed). </li>
</ul>
<h2><a class="anchor" id="Jet_fitting_3TemplateParameters"></a>
Template Parameters</h2>
<h3><a class="anchor" id="Jet_fitting_3TemplateparameterDataKernel"></a>
Template parameter DataKernel</h3>
<p>This concept provides the types for the input sample points, together with \( 3d\) vectors and a number type. It is used as template for the class <code><a class="el" href="classCGAL_1_1Monge__via__jet__fitting.html" title="The class Monge_via_jet_fitting is designed to perform the estimation of the local differential quant...">Monge_via_jet_fitting</a>&lt;<a class="el" href="classDataKernel.html" title="The concept DataKernel describes the set of requirements to be fulfilled by any class used to instant...">DataKernel</a>, <a class="el" href="classLocalKernel.html" title="The concept LocalKernel describes the set of requirements to be fulfilled by any class used to instan...">LocalKernel</a>, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classSvdTraits.html">SvdTraits</a>&gt;</code>. Typically, one can use <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a>&lt; double &gt;</code>.</p>
<h3><a class="anchor" id="Jet_fitting_3TemplateparameterLocalKernel"></a>
Template parameter LocalKernel</h3>
<p>This is a parameter of the class <code><a class="el" href="classCGAL_1_1Monge__via__jet__fitting.html" title="The class Monge_via_jet_fitting is designed to perform the estimation of the local differential quant...">Monge_via_jet_fitting</a>&lt;<a class="el" href="classDataKernel.html" title="The concept DataKernel describes the set of requirements to be fulfilled by any class used to instant...">DataKernel</a>, <a class="el" href="classLocalKernel.html" title="The concept LocalKernel describes the set of requirements to be fulfilled by any class used to instan...">LocalKernel</a>, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classSvdTraits.html">SvdTraits</a>&gt;</code>. This concept defines the vector and number types used for local computations and to store the PCA basis data.</p>
<p>Input points of type <code><a class="el" href="classDataKernel.html" title="The concept DataKernel describes the set of requirements to be fulfilled by any class used to instant...">DataKernel</a>::Point_3</code> are converted to <code><a class="el" href="classLocalKernel.html" title="The concept LocalKernel describes the set of requirements to be fulfilled by any class used to instan...">LocalKernel</a>::Point_3</code>. For output of the <code><a class="el" href="classCGAL_1_1Monge__via__jet__fitting_1_1Monge__form.html" title="The class Monge_form stores the Monge representation, i.e., the Monge coordinate system and the coeff...">CGAL::Monge_via_jet_fitting::Monge_form</a></code> class, these types are converted back to <code><a class="el" href="classDataKernel.html" title="The concept DataKernel describes the set of requirements to be fulfilled by any class used to instant...">DataKernel</a></code> ones. Typically, one can use <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a>&lt; double &gt;</code> which is the default.</p>
<h3><a class="anchor" id="Jet_fitting_3TemplateparameterSvdTraits"></a>
Template parameter SvdTraits</h3>
<p>This concept provides the number, vector and matrix types for algebra operations required by the fitting method in <code><a class="el" href="classCGAL_1_1Monge__via__jet__fitting.html" title="The class Monge_via_jet_fitting is designed to perform the estimation of the local differential quant...">Monge_via_jet_fitting</a>&lt;<a class="el" href="classDataKernel.html" title="The concept DataKernel describes the set of requirements to be fulfilled by any class used to instant...">DataKernel</a>, <a class="el" href="classLocalKernel.html" title="The concept LocalKernel describes the set of requirements to be fulfilled by any class used to instan...">LocalKernel</a>, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classSvdTraits.html">SvdTraits</a>&gt;</code> . The main method is a linear solver using a singular value decomposition.</p>
<h3><a class="anchor" id="Jet_fitting_3CompatibilityRequirements"></a>
Compatibility Requirements</h3>
<p>To solve the fitting problem, the sample points are first converted from the <code><a class="el" href="classDataKernel.html" title="The concept DataKernel describes the set of requirements to be fulfilled by any class used to instant...">DataKernel</a></code> to the <code><a class="el" href="classLocalKernel.html" title="The concept LocalKernel describes the set of requirements to be fulfilled by any class used to instan...">LocalKernel</a></code> (this is done using the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Cartesian__converter.html">Cartesian_converter</a></code>). Then change of coordinate systems and linear algebra operations are performed with this kernel. This implies that the number types <code><a class="el" href="classLocalKernel.html" title="The concept LocalKernel describes the set of requirements to be fulfilled by any class used to instan...">LocalKernel</a>::FT</code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classSvdTraits.html">SvdTraits</a>::FT</code> must be identical. Second the Monge basis and coefficients, computed with the <code><a class="el" href="classLocalKernel.html" title="The concept LocalKernel describes the set of requirements to be fulfilled by any class used to instan...">LocalKernel</a></code>, are converted back to the <code><a class="el" href="classDataKernel.html" title="The concept DataKernel describes the set of requirements to be fulfilled by any class used to instant...">DataKernel</a></code> (this is done using the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Cartesian__converter.html">Cartesian_converter</a></code> and the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/structCGAL_1_1NT__converter.html">NT_converter</a></code>).</p>
<h1><a class="anchor" id="Jet_fitting_3Examples"></a>
Examples</h1>
<h2><a class="anchor" id="Jet_fitting_3SingleEstimationaboutaPoint"></a>
Single Estimation about a Point of a Point Cloud</h2>
<p>The first example illustrates the computation of the local differential quantities from a set of points given in a text file as input. The first point of the list is the one at which the computation is performed. The user has to specify a file for the input points and the degrees \( d\) and \( d'\). <br />
<b>File</b> <a class="el" href="Jet_fitting_3_2Single_estimation_8cpp-example.html">Jet_fitting_3/Single_estimation.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Monge_via_jet_fitting.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span>                   DFT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;DFT&gt;</a>     Data_Kernel;</div><div class="line"><span class="keyword">typedef</span> Data_Kernel::Point_3     DPoint;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Monge__via__jet__fitting.html">CGAL::Monge_via_jet_fitting&lt;Data_Kernel&gt;</a> My_Monge_via_jet_fitting;</div><div class="line"><span class="keyword">typedef</span> My_Monge_via_jet_fitting::Monge_form     My_Monge_form;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordtype">size_t</span> d_fitting = 4;</div><div class="line">  <span class="keywordtype">size_t</span> d_monge = 4;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* name_file_in = <span class="stringliteral">"data/in_points_d4.txt"</span>;</div><div class="line">  <span class="comment">//check command line</span></div><div class="line">  <span class="keywordflow">if</span> (argc&lt;4)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">" Usage : "</span> &lt;&lt; argv[0]</div><div class="line">                &lt;&lt; <span class="stringliteral">" &lt;inputPoints.txt&gt; &lt;d_fitting&gt; &lt;d_monge&gt;"</span> &lt;&lt; std::endl</div><div class="line">        &lt;&lt; <span class="stringliteral">"test with default arguments"</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> {</div><div class="line">    name_file_in = argv[1];</div><div class="line">    d_fitting = std::atoi(argv[2]);</div><div class="line">    d_monge = std::atoi(argv[3]);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//open the input file</span></div><div class="line">  std::ifstream inFile(name_file_in);</div><div class="line">  <span class="keywordflow">if</span> ( !inFile )</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"cannot open file for input\n"</span>;</div><div class="line">      exit(-1);</div><div class="line">    }</div><div class="line">  </div><div class="line">  <span class="comment">//initalize the in_points container</span></div><div class="line">  <span class="keywordtype">double</span> x, y, z;</div><div class="line">  std::vector&lt;DPoint&gt; in_points;</div><div class="line">  <span class="keywordflow">while</span> (inFile &gt;&gt; x) {</div><div class="line">    inFile &gt;&gt; y &gt;&gt; z;</div><div class="line">    DPoint p(x,y,z);</div><div class="line">    in_points.push_back(p);</div><div class="line">  }</div><div class="line">  inFile.close();</div><div class="line">  <span class="comment">// fct parameters</span></div><div class="line"></div><div class="line">  My_Monge_form monge_form;</div><div class="line">  My_Monge_via_jet_fitting monge_fit;</div><div class="line">  monge_form = monge_fit(in_points.begin(), in_points.end(), d_fitting, d_monge);</div><div class="line"></div><div class="line">  <span class="comment">//OUTPUT on std::cout</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#ga2f2176255429973ea7bf156804a53857">CGAL::set_pretty_mode</a>(std::cout);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"vertex : "</span> &lt;&lt; in_points[0] &lt;&lt; std::endl</div><div class="line">        &lt;&lt; <span class="stringliteral">"number of points used : "</span> &lt;&lt; in_points.size() &lt;&lt; std::endl</div><div class="line">        &lt;&lt; monge_form;</div><div class="line">  std::cout  &lt;&lt; <span class="stringliteral">"condition_number : "</span> &lt;&lt; monge_fit.condition_number() &lt;&lt; std::endl</div><div class="line">         &lt;&lt; <span class="stringliteral">"pca_eigen_vals and associated pca_eigen_vecs :"</span>  &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;3; i++)</div><div class="line">    std::cout &lt;&lt; monge_fit.pca_basis(i).first &lt;&lt; std::endl</div><div class="line">          &lt;&lt; monge_fit.pca_basis(i).second  &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Jet_fitting_3OnaMesh"></a>
On a Mesh</h2>
<p>The second example (cf Mesh_estimation.cpp in the example directory) illustrates the computation of local differential quantities for all vertices of a given mesh. The neighborhood of a given vertex is computed using rings on the triangulation. Results are twofold: </p><ul>
<li>
a human readable text file featuring the <code><a class="el" href="classCGAL_1_1Monge__via__jet__fitting_1_1Monge__form.html" title="The class Monge_form stores the Monge representation, i.e., the Monge coordinate system and the coeff...">CGAL::Monge_via_jet_fitting::Monge_form</a></code> and numerical informations on the computation: condition number and the PCA basis; </li>
<li>
another text file that records raw data (better for a vizualization post-processing). </li>
</ul>
<p><a class="el" href="index.html#fig__figjet3figdavid">Figure 70.1</a> and <a class="el" href="index.html#fig__figjet3figellipticparaboloid">Figure 70.2</a> provide illustrations of principal directions of curvature.</p>
<p><a class="anchor" id="fig__figjet3figellipticparaboloid"></a></p><div class="image">
<img src="ppal_curv_poly2x2+y2.jpg" alt="ppal_curv_poly2x2+y2.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figjet3figellipticparaboloid">Figure 70.2</a> Principal directions of curvature and normals at vertices of a mesh of the graph of the function \( f(x,y)=2x^2+y^2\).  </div>  <br />

<h1><a class="anchor" id="Jet_fitting_3Mathematical"></a>
Mathematical and Algorithmic Details</h1>
<p><a class="anchor" id="secdetails"></a>In this Section, we detail the mathematics involved, in order to justify the design choices made. To begin with, observe the fitting problem involves three relevant direct orthonormal basis: the world-basis \( (w_x,w_y,w_z)\), the fitting-basis \( (f_x,f_y,f_z)\), the Monge basis \( (d_1,d_2,n)\).</p>
<p><a class="anchor" id="fig__figjet_fitting_basis"></a></p><div class="image">
<img src="jet_fitting_basis.png" alt="jet_fitting_basis.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figjet_fitting_basis">Figure 70.3</a> The three bases involved in the estimation.  </div>  <br />

<h2><a class="anchor" id="Jet_fitting_3ComputingaBasisfortheFitting"></a>
Computing a Basis for the Fitting</h2>
<p><b>Input: samples Output: fitting-basis</b></p>
<p>Performing a PCA requires diagonalizing a symmetric matrix. This analysis gives an orthonormal basis whose \( z\)-axis is provided by the eigenvector associated to the smallest eigenvalue.<span class="footnote">Another possibility is to choose as z-axis the axis of the world-basis with the least angle with the axis determined with the PCA. Then the change of basis reduces to a permutation of axis.</span> Note one may have to swap the orientation of a vector to get a direct basis.</p>
<p>Let us denote \( P_{W\rightarrow F}\) the matrix that changes coordinates from the world-basis \( (w_x,w_y,w_z)\) to the fitting-basis \( (f_x,f_y,f_z)\). The rows of \( P_{W\rightarrow F}\) are the coordinates of the vectors \( (f_x,f_y,f_z)\) in the world-basis. This matrix represents a orthogonal transformation hence its inverse is its transpose. To obtain the coordinates of a point in the fitting-basis from the coordinates in the world-basis, one has to multiply by \( P_{W\rightarrow F}\).</p>
<p>As mentioned above, the eigenvalues are returned, from which the sampling quality can be assessed. For a good sampling, the eigenvector associated to the smallest eigenvalue should roughly give the normal direction.</p>
<h2><a class="anchor" id="secsolving"></a>
Solving the Interpolation / Approximation Problem</h2>
<p><b>Input: samples, fitting-basis Output: coefficients \( A_{i,j}\) of the bivariate fitted polynomial in the fitting-basis </b></p>
<p>Computations are done in the fitting-basis and the origin is the point \( p\). First, one has to transform coordinates of sample points with a translation ( \( -p\)) and multiplication by \( P_{W\rightarrow F}\).</p>
<p>The fitting process consists of finding the coefficients \( A_{i,j}\) of the degree \( d\) polynomial</p>
<p><a class="anchor" id="eqanswer"></a> </p><p class="formulaDsp">
\[ \begin{equation} J_{A,d}= \ccSum{k=0}{d}{(\ccSum{i=0}{k}{ \frac{A_{k-i,i}x^{k-i}y^{i}}{i!(k-i)!}})}. \end{equation} \]
</p>
<p>Denote \( p_i=(x_i,y_i,z_i), \ i=1,\ldots , N\) the coordinates of the sample points of \( P^+\). For interpolation the linear equations to solve are \( A(x_i,y_i)=z_i \ i=1,\ldots,N\), and for approximation one has to minimize \( \sum_{i=1}^N (A(x_i,y_i)-z_i)^2\). The linear algebra formulation of the problem is given by</p>
<p><a class="anchor" id="eqfitlinalg"></a> </p><p class="formulaDsp">
\begin{eqnarray} A = &amp; (A_{0,0}, A_{1,0},A_{0,1}, \ldots , A_{0,d})^T \\ Z= &amp;(z_1, z_2,\ldots , z_N)^T \\ M= &amp;(1,x_i,\ y_i,\ \frac{x_i^2}{2},\ldots , \ \frac{x_iy_i^{d-1}}{(d-1)!},\ \frac{y_i^d}{d!})_{i=1,...,N}\\ \end{eqnarray}
</p>
<p>The equations for interpolation become \( MA=Z\). For approximation, the system \( MA=Z\) is solved in the least square sense, i.e. one seeks the vector \( A\) such that \( A = \arg \min_A ||MA-Z||_2\).</p>
<p>In any case, there is a preconditioning of the matrix \( M\) so as to improve the condition number. Assuming the \( \{x_i\}\), \( \{y_i\}\) are of order \( h\), the pre-conditioning consists of performing a column scaling by dividing each monomial \( x_i^ky_i^l\) by \( h^{k+l}\) - refer to Eq. ( <a class="el" href="index.html#eqfitlinalg">eqfitlinalg</a> ). Practically, the parameter \( h\) is chosen as the mean value of the \( \{x_i\}\) and \( \{y_i\}\). In other words, the new system is \( M'Y=(MD^{-1})(DA)=Z\) with \( D\) the diagonal matrix \( D=(1,h,h,h^2,\ldots,h^d,h^d)\), so that the solution \( A\) of the original system is \( A=D^{-1}Y\).</p>
<p>There is always a single solution since for under constrained systems we also minimize \( ||A||_2\). The method uses a singular value decomposition of the \( N\times N_d\) matrix \( M= U S V^T\), where \( U\) is a \( N \times N\) orthogonal matrix, \( V\) is a \( N_d \times N_d\) orthogonal matrix and \( S\) is a \( N\times N_d\) matrix with the singular values on its diagonal. Denote \( r\) the rank of \( M\), we can decompose \( S= \left( \begin{array}{cc} D_r &amp; 0_{r,\ N_d-r}\\ 0_{N-r,\ r} &amp; 0_{N-r,\ N_d-r} \end{array} \right). \) The number \( r\), which is the number of non zero singular values, is strictly lower than \( N_d\) if the system is under constrained. In any case, the unique solution which minimize \( ||A||_2\) is given by:</p>
<p class="formulaDsp">
\[ \begin{equation} A= V \left( \begin{array}{cc} D_r^{-1} &amp; 0_{N_d-r,\ r}\\ 0_{r,\ N-r} &amp; 0_{N_d-r,\ N-r} \end{array} \right) U^TZ. \end{equation} \]
</p>
<p>One can provide the condition number of the matrix \( M\) (after preconditioning) which is the ratio of the maximal and the minimal singular values. It is infinite if the system is under constrained, that is the smallest singular value is zero.</p>
<p><b>Implementation details.</b></p>
<p>We assume a <code>solve</code> function is provided by the traits <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classSvdTraits.html">SvdTraits</a></code>. This function solves the system MX=B (in the least square sense if M is not square) using a Singular Value Decomposition and gives the condition number of M.<br />
</p>
<p><br />
</p>
<p>Remark: as an alternative, other methods may be used to solve the system. A \( QR\) decomposition can be substituted to the \( SVD\). One can also use the normal equation \( M^TMX=MTB\) and apply methods for square systems such as \( LU\), \( QR\) or Cholesky since \( M^TM\) is symmetric definite positive when \( M\) has full rank. The advantages of the \( SVD\) is that it works directly on the rectangular system and gives the condition number of the system. For more on these alternatives, see <a class="el" href="citelist.html#CITEREF_gl-mc-83">[3]</a> (Chap. 5).</p>
<h2><a class="anchor" id="Jet_fitting_3PrincipalCurvatureDirections"></a>
Principal Curvature / Directions</h2>
<p><b>Input: coefficients of the fit \( A_{i,j}\), fitting-basis</b></p>
<p><b>Output: Monge basis wrt fitting-basis and world-basis </b></p>
<p>In the fitting basis, we have determined a height function expressed by Eq. ( <a class="el" href="index.html#eqanswer">eqanswer</a> ). Computations are done in the fitting-basis. The partial derivatives, evaluated at \( (x,y)=(0,0)\), of the fitted polynomial \( J_{A,d}(x,y)\) are \( A_{i,j}=\frac{\partial^{i+j}J_{A,d}}{\partial^ix \partial^jy}\) Expanding Eq. ( <a class="el" href="index.html#eqanswer">eqanswer</a> ) yields:</p>
<p class="formulaDsp">
\begin{eqnarray} J_{A,d}(x,y)&amp;= A_{0,0}+A_{1,0}x+A_{0,1}y+\frac{1}{2}(A_{2,0}x^2+2A_{1,1}xy+A_{0,2}y^2) + \frac{1}{6}(A_{3,0}x^3+3A_{2,1}x^2y+\ldots )+ \ldots \end{eqnarray}
</p>
<ul>
<li>
The origin, that is the point of the fitted surface where the estimation is performed, is \( (0,0,A_{0,0})\). </li>
<li>
The normal is \( n=(-A_{1,0},-A_{0,1},1)/\sqrt{A_{1,0}^2+A_{0,1}^2+1}\). </li>
<li>
Curvature related properties are retrieved resorting to standard differential calculus <a class="el" href="citelist.html#CITEREF_c-dgcs-76">[2]</a> (Chap. 3). More precisely, the Weingarten operator \( W=-I^{-1}II\) is first computed in the basis of the tangent plane \( \{ (1,0,A_{1,0}), (0,1,A_{0,1}) \}\). We compute an orthonormal basis of the tangent plane using the Gram-Schmidt algorithm, and then we compute Weingarten in this basis (applying a change of basis with the matrix \( W'=P^{-1}WP\)). In this orthonormal basis, the matrix of the Weingarten map is symmetric and we diagonalize it. One finally gets the principal curvatures which are the eigenvalues of \( W\), and the associated principal directions. This gives an orthonormal direct basis \( (d_1,d_2,n)\). Let us denote \( P_{F \rightarrow M}\) the matrix to change coordinates from the fitting-basis to the Monge basis. Its rows are the coordinates of the vectors \( (d_1,d_2,n)\) in the fitting-basis. It is an orthogonal matrix \( P_{F \rightarrow M}^{-1}=P_{F \rightarrow M}^T\). The Monge basis expressed in the world-basis is obtained by multiplying the coordinates of \( (d_1,d_2,n)\) in the fitting-basis by \( P_{W\rightarrow F}^{-1}\), (the same holds for the origin point which has in addition to be translated by \( p\), i.e. the coordinates of the origin point are \( P_{W\rightarrow F}^{-1} (0,0,A_{0,0}) +p\). </li>
</ul>
<h2><a class="anchor" id="Jet_fitting_3ComputingHigherOrderMongeCoefficients"></a>
Computing Higher Order Monge Coefficients</h2>
<p><b>Input: coefficients of the fit, Monge basis wrt fitting-basis ( \( P_{F \rightarrow M}\))</b></p>
<p><b>Output: third and fourth order coefficients of Monge</b></p>
<p>We use explicit formula. The implicit equation of the fitted polynomial surface in the fitting-basis with origin the point \( (0,0,A_{0,0})\) is \( Q=0\) with</p>
<p class="formulaDsp">
\[ \begin{equation} Q=-w-A_{0,0} +\ccSum{i,j}{}{\frac{A_{i,j}u^iv^j}{i!j!}}. \end{equation} \]
</p>
<p>The equation in the Monge basis is obtained by substituting \( (u,v,w)\) by \( P^T_{F\rightarrow M}(x,y,z)\). Denote \( f(x,y,z)=0\) this implicit equation. By definition of the Monge basis, we have locally (at \( (0,0,0)\))</p>
<p class="formulaDsp">
\[ \begin{equation} f(x,y,z)=0 \Leftrightarrow z=g(x,y) \end{equation} \]
</p>
<p>and the Taylor expansion of \( g\) at \( (0,0)\) are the Monge coefficients sought. Let us denote the partial derivatives evaluated at the origin of \( f\) and \( g\) by \( f_{i,j,k}=\frac{\partial^{i+j+k}f}{\partial^ix \partial^jy \partial^kz}\) and \( g_{i,j}=\frac{\partial^{i+j}g}{\partial^ix \partial^jy}\). One has \( f_{1,0,0}=f_{0,1,0}=f_{1,1,0}=0\), \( g_{0,0}=g_{1,0}=g_{0,1}=g_{1,1}=0\) and \( g_{2,0}=k_1\), \( g_{0,2}=k_2\). The partial derivative of order \( n\) of \( f\) depends on the matrix \( P_{F\rightarrow M}\) and the partial derivatives of order at most \( n\) of \( J_{A,d}\). The third and fourth order coefficients of are computed with the implicit function theorem. For instance:</p>
<p class="formulaDsp">
\begin{eqnarray*} &amp;b_0=g_{3,0}=-{\frac { f_{3,0,0} f_{0,0,1} -3\, f_{1,0,1} f_{2,0,0} }{ f_{0,0,1} ^{2}}} \\ &amp;b_1=g_{2,1}=-{\frac {- f_{0,1,1} f_{2,0,0} + f_{2,1,0} f_{0,0,1} }{ f_{0,0,1} ^{2}}} \\ &amp; .... \\ \end{eqnarray*}
</p>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:06 for CGAL 4.13 - Estimation of Local Differential Properties of Point-Sampled Surfaces by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
