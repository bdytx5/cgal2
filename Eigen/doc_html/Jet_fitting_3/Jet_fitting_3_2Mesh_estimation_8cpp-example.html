<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Jet_fitting_3/Jet_fitting_3_2Mesh_estimation_8cpp-example.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Estimation of Local Differential Properties of Point-Sampled Surfaces: Jet_fitting_3/Mesh_estimation.cpp</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Estimation of Local Differential Properties of Point-Sampled Surfaces
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Jet_fitting_3_2Mesh_estimation_8cpp-example.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Jet_fitting_3/Mesh_estimation.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Monge_via_jet_fitting.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if defined(CGAL_USE_BOOST_PROGRAM_OPTIONS) &amp;&amp; ! defined(DONT_USE_BOOST_PROGRAM_OPTIONS)</span></div><div class="line"><span class="preprocessor">#include &lt;boost/program_options.hpp&gt;</span></div><div class="line"><span class="keyword">namespace </span>po = boost::program_options;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#include "PolyhedralSurf.h"</span></div><div class="line"><span class="preprocessor">#include "PolyhedralSurf_operations.h"</span></div><div class="line"><span class="preprocessor">#include "PolyhedralSurf_rings.h"</span></div><div class="line"></div><div class="line"><span class="comment">//Kernel of the PolyhedralSurf</span></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span>                DFT;</div><div class="line"><span class="keyword">typedef</span> <a name="_a0" id="_a0"></a><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;DFT&gt;</a>  Data_Kernel;</div><div class="line"><span class="keyword">typedef</span> Data_Kernel::Point_3  DPoint;</div><div class="line"><span class="keyword">typedef</span> Data_Kernel::Vector_3 DVector;</div><div class="line"></div><div class="line"><span class="comment">//HDS</span></div><div class="line"><span class="keyword">typedef</span> PolyhedralSurf::Vertex_handle Vertex_handle;</div><div class="line"><span class="keyword">typedef</span> PolyhedralSurf::Vertex Vertex;</div><div class="line"><span class="keyword">typedef</span> PolyhedralSurf::Halfedge_handle Halfedge_handle;</div><div class="line"><span class="keyword">typedef</span> PolyhedralSurf::Halfedge Halfedge;</div><div class="line"><span class="keyword">typedef</span> PolyhedralSurf::Vertex_iterator Vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> PolyhedralSurf::Facet_handle Facet_handle;</div><div class="line"><span class="keyword">typedef</span> PolyhedralSurf::Facet Facet;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Hedge_cmp{</div><div class="line">  <span class="keywordtype">bool</span> operator()(Halfedge_handle a,  Halfedge_handle b)<span class="keyword"> const</span>{</div><div class="line">    <span class="keywordflow">return</span> &amp;*a &lt; &amp;*b;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Facet_cmp{</div><div class="line">  <span class="keywordtype">bool</span> operator()(Facet_handle a, Facet_handle b)<span class="keyword"> const</span>{</div><div class="line">    <span class="keywordflow">return</span> &amp;*a &lt; &amp;*b;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">//Vertex property map, with std::map</span></div><div class="line"><span class="keyword">typedef</span> std::map&lt;Vertex*, int&gt; Vertex2int_map_type;</div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt; Vertex2int_map_type &gt; Vertex_PM_type;</div><div class="line"><span class="keyword">typedef</span> T_PolyhedralSurf_rings&lt;PolyhedralSurf, Vertex_PM_type &gt; Poly_rings;</div><div class="line"></div><div class="line"><span class="comment">//Hedge property map, with enriched Halfedge with its length</span></div><div class="line"><span class="comment">// typedef HEdge_PM&lt;PolyhedralSurf&gt; Hedge_PM_type;</span></div><div class="line"><span class="comment">// typedef T_PolyhedralSurf_hedge_ops&lt;PolyhedralSurf, Hedge_PM_type&gt; Poly_hedge_ops;</span></div><div class="line"><span class="comment">//Hedge property map, with std::map</span></div><div class="line"><span class="keyword">typedef</span> std::map&lt;Halfedge_handle, double, Hedge_cmp&gt; Hedge2double_map_type;</div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Hedge2double_map_type&gt; Hedge_PM_type;</div><div class="line"><span class="keyword">typedef</span> T_PolyhedralSurf_hedge_ops&lt;PolyhedralSurf, Hedge_PM_type&gt; Poly_hedge_ops;</div><div class="line"></div><div class="line"><span class="comment">// //Facet property map with enriched Facet with its normal</span></div><div class="line"><span class="comment">// typedef Facet_PM&lt;PolyhedralSurf&gt; Facet_PM_type;</span></div><div class="line"><span class="comment">// typedef T_PolyhedralSurf_facet_ops&lt;PolyhedralSurf, Facet_PM_type&gt; Poly_facet_ops;</span></div><div class="line"><span class="comment">//Facet property map, with std::map</span></div><div class="line"><span class="keyword">typedef</span> std::map&lt;Facet_handle, Vector_3, Facet_cmp&gt; Facet2normal_map_type;</div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Facet2normal_map_type&gt; Facet_PM_type;</div><div class="line"><span class="keyword">typedef</span> T_PolyhedralSurf_facet_ops&lt;PolyhedralSurf, Facet_PM_type&gt; Poly_facet_ops;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span>                   LFT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;LFT&gt;</a>     Local_Kernel;</div><div class="line"><span class="keyword">typedef</span> <a name="_a1" id="_a1"></a><a class="code" href="classCGAL_1_1Monge__via__jet__fitting.html">CGAL::Monge_via_jet_fitting&lt;Data_Kernel&gt;</a> My_Monge_via_jet_fitting;</div><div class="line"><span class="keyword">typedef</span> My_Monge_via_jet_fitting::Monge_form My_Monge_form;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// default parameter values and global variables</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d_fitting = 2;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d_monge = 2;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_rings = 0;<span class="comment">//seek min # of rings to get the required #pts</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_points_to_use = 0;<span class="comment">//</span></div><div class="line"><span class="keywordtype">bool</span> verbose = <span class="keyword">false</span>;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_nb_points = (d_fitting + 1) * (d_fitting + 2) / 2;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//gather points around the vertex v using rings on the</span></div><div class="line"><span class="comment">//polyhedralsurf. the collection of points resorts to 3 alternatives:</span></div><div class="line"><span class="comment">// 1. the exact number of points to be used</span></div><div class="line"><span class="comment">// 2. the exact number of rings to be used</span></div><div class="line"><span class="comment">// 3. nothing is specified</span></div><div class="line"><span class="keywordtype">void</span> gather_fitting_points(Vertex* v,</div><div class="line">               std::vector&lt;DPoint&gt; &amp;in_points,</div><div class="line">               Vertex_PM_type&amp; vpm)</div><div class="line">{</div><div class="line">  <span class="comment">//container to collect vertices of v on the PolyhedralSurf</span></div><div class="line">  std::vector&lt;Vertex*&gt; gathered;</div><div class="line">  <span class="comment">//initialize</span></div><div class="line">  in_points.clear();</div><div class="line"></div><div class="line">  <span class="comment">//OPTION -p nb_points_to_use, with nb_points_to_use != 0. Collect</span></div><div class="line">  <span class="comment">//enough rings and discard some points of the last collected ring to</span></div><div class="line">  <span class="comment">//get the exact "nb_points_to_use"</span></div><div class="line">  <span class="keywordflow">if</span> ( nb_points_to_use != 0 ) {</div><div class="line">    Poly_rings::collect_enough_rings(v, nb_points_to_use, gathered, vpm);</div><div class="line">    <span class="keywordflow">if</span> ( gathered.size() &gt; nb_points_to_use ) gathered.resize(nb_points_to_use);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> { <span class="comment">// nb_points_to_use=0, this is the default and the option -p is not considered;</span></div><div class="line">    <span class="comment">// then option -a nb_rings is checked. If nb_rings=0, collect</span></div><div class="line">    <span class="comment">// enough rings to get the min_nb_points required for the fitting</span></div><div class="line">    <span class="comment">// else collect the nb_rings required</span></div><div class="line">    <span class="keywordflow">if</span> ( nb_rings == 0 )</div><div class="line">      Poly_rings::collect_enough_rings(v, min_nb_points, gathered, vpm);</div><div class="line">    <span class="keywordflow">else</span> Poly_rings::collect_i_rings(v, nb_rings, gathered, vpm);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//store the gathered points</span></div><div class="line">  std::vector&lt;Vertex*&gt;::iterator</div><div class="line">    itb = gathered.begin(), ite = gathered.end();</div><div class="line">  <a name="a2" id="a2"></a><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/group__PkgHandlesAndCirculatorsFunctions.html#gae4f6b9dc3b933f01f2d0275a7bf8b308">CGAL_For_all</a>(itb,ite) in_points.push_back((*itb)-&gt;point());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#if defined(CGAL_USE_BOOST_PROGRAM_OPTIONS) &amp;&amp; ! defined(DONT_USE_BOOST_PROGRAM_OPTIONS)</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">{</div><div class="line">  <span class="keywordtype">string</span> if_name_string;</div><div class="line">  <span class="keywordtype">string</span> if_name; <span class="comment">//input file name</span></div><div class="line">  <span class="keywordtype">string</span> w_if_name;  <span class="comment">//as above, but / replaced by _</span></div><div class="line">  <span class="keywordtype">string</span> res4openGL_fname;</div><div class="line">  <span class="keywordtype">string</span> verbose_fname;</div><div class="line">  std::ofstream out_4ogl, out_verbose;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line"><span class="preprocessor">#if defined(CGAL_USE_BOOST_PROGRAM_OPTIONS) &amp;&amp; ! defined(DONT_USE_BOOST_PROGRAM_OPTIONS)</span></div><div class="line">    po::options_description desc(<span class="stringliteral">"Allowed options"</span>);</div><div class="line">    desc.add_options()</div><div class="line">      (<span class="stringliteral">"help,h"</span>, <span class="stringliteral">"produce help message."</span>)</div><div class="line">      (<span class="stringliteral">"input-file,f"</span>, po::value&lt;string&gt;(&amp;if_name_string)-&gt;default_value(<span class="stringliteral">"data/ellipe0.003.off"</span>),</div><div class="line">       <span class="stringliteral">"name of the input off file"</span>)</div><div class="line">      (<span class="stringliteral">"degree-jet,d"</span>, po::value&lt;unsigned int&gt;(&amp;d_fitting)-&gt;default_value(2),</div><div class="line">       <span class="stringliteral">"degree of the jet, 1 &lt;= degre-jet &lt;= 4"</span>)</div><div class="line">      (<span class="stringliteral">"degree-monge,m"</span>, po::value&lt;unsigned int&gt;(&amp;d_monge)-&gt;default_value(2),</div><div class="line">       <span class="stringliteral">"degree of the Monge rep, 1 &lt;= degree-monge &lt;= degree-jet"</span>)</div><div class="line">      (<span class="stringliteral">"nb-rings,a"</span>, po::value&lt;unsigned int&gt;(&amp;nb_rings)-&gt;default_value(0),</div><div class="line">       <span class="stringliteral">"number of rings to collect neighbors. 0 means collect enough rings to make appro possible a&gt;=1 fixes the nb of rings to be collected"</span>)</div><div class="line">      (<span class="stringliteral">"nb-points,p"</span>, po::value&lt;unsigned int&gt;(&amp;nb_points_to_use)-&gt;default_value(0),</div><div class="line">       <span class="stringliteral">"number of neighbors to use.  0 means this option is not considered, this is the default p&gt;=1 fixes the nb of points to be used"</span>)</div><div class="line">      (<span class="stringliteral">"verbose,v"</span>, po::value&lt;bool&gt;(&amp;verbose)-&gt;default_value(<span class="keyword">false</span>),</div><div class="line">       <span class="stringliteral">"verbose output on text file"</span>)</div><div class="line">      ;</div><div class="line"></div><div class="line">    po::variables_map vm;</div><div class="line">    po::store(po::parse_command_line(argc, argv, desc), vm);</div><div class="line">    po::notify(vm);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (vm.count(<span class="stringliteral">"help"</span>)) {</div><div class="line">      cout &lt;&lt; desc &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Command-line options require Boost.ProgramOptions"</span> &lt;&lt; std::endl;</div><div class="line">    if_name_string = <span class="stringliteral">"data/ellipe0.003.off"</span>;</div><div class="line">    d_fitting = 2;</div><div class="line">    d_monge = 2;</div><div class="line">    nb_rings = 0;</div><div class="line">    nb_points_to_use = 0;</div><div class="line">    verbose = <span class="keyword">false</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">catch</span>(exception&amp; e) {</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">"error: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">catch</span>(...) {</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">"Exception of unknown type!\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//modify global variables which are fct of options:</span></div><div class="line">  min_nb_points = (d_fitting + 1) * (d_fitting + 2) / 2;</div><div class="line">  <span class="keywordflow">if</span> (nb_points_to_use &lt; min_nb_points &amp;&amp; nb_points_to_use != 0)</div><div class="line">    {std::cerr &lt;&lt; <span class="stringliteral">"the nb of points asked is not enough to perform the fitting"</span> &lt;&lt; std::endl; exit(0);}</div><div class="line"></div><div class="line">  <span class="comment">//prepare output file names</span></div><div class="line">  <span class="comment">//--------------------------</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"if_name_string"</span> &lt;&lt; if_name_string  &lt;&lt; std::endl;</div><div class="line">  if_name = if_name_string;</div><div class="line"></div><div class="line">  w_if_name = if_name;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;w_if_name.size(); i++)</div><div class="line">    <span class="keywordflow">if</span> (w_if_name[i] == <span class="charliteral">'/'</span>) w_if_name[i]=<span class="charliteral">'_'</span>;</div><div class="line">  cerr &lt;&lt; if_name &lt;&lt; <span class="charliteral">'\n'</span>;</div><div class="line">  cerr &lt;&lt; w_if_name &lt;&lt; <span class="charliteral">'\n'</span>;</div><div class="line"></div><div class="line">  res4openGL_fname = w_if_name + <span class="stringliteral">".4ogl.txt"</span>;</div><div class="line">std::cerr &lt;&lt; <span class="stringliteral">"res4openGL_fname"</span> &lt;&lt; res4openGL_fname  &lt;&lt; std::endl;</div><div class="line">  out_4ogl.open(res4openGL_fname.c_str(), std::ios::out);</div><div class="line">  assert(out_4ogl.good());</div><div class="line">  <span class="comment">//if verbose only...</span></div><div class="line">  <span class="keywordflow">if</span>(verbose){</div><div class="line">    verbose_fname  = w_if_name + <span class="stringliteral">".verb.txt"</span>;</div><div class="line">    out_verbose.open(verbose_fname.c_str(), std::ios::out);</div><div class="line">    assert(out_verbose.good());</div><div class="line">    <a name="a3" id="a3"></a><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#ga2f2176255429973ea7bf156804a53857">CGAL::set_pretty_mode</a>(out_verbose);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_vertices_considered = 0;<span class="comment">//count vertices for verbose</span></div><div class="line"></div><div class="line">  <span class="comment">//load the model from &lt;mesh.off&gt;</span></div><div class="line">  <span class="comment">//------------------------------</span></div><div class="line">  PolyhedralSurf P;</div><div class="line">  std::ifstream stream(if_name.c_str());</div><div class="line">  stream &gt;&gt; P;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"loadMesh...  "</span>&lt;&lt; <span class="stringliteral">"Polysurf with "</span> &lt;&lt; P.size_of_vertices()</div><div class="line">        &lt;&lt; <span class="stringliteral">" vertices and "</span> &lt;&lt; P.size_of_facets()</div><div class="line">        &lt;&lt; <span class="stringliteral">" facets. "</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(verbose)</div><div class="line">    out_verbose &lt;&lt; <span class="stringliteral">"Polysurf with "</span> &lt;&lt; P.size_of_vertices()</div><div class="line">                &lt;&lt; <span class="stringliteral">" vertices and "</span> &lt;&lt; P.size_of_facets()</div><div class="line">                &lt;&lt; <span class="stringliteral">" facets. "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//exit if not enough points in the model</span></div><div class="line">  <span class="keywordflow">if</span> (min_nb_points &gt; P.size_of_vertices())    exit(0);</div><div class="line"></div><div class="line">  <span class="comment">//create property maps</span></div><div class="line">  <span class="comment">//-----------------------------</span></div><div class="line">  <span class="comment">//Vertex, using a std::map</span></div><div class="line">  Vertex2int_map_type vertex2props;</div><div class="line">  Vertex_PM_type vpm(vertex2props);</div><div class="line"></div><div class="line">  <span class="comment">//Hedge, with enriched hedge</span></div><div class="line">  <span class="comment">//HEdgePM_type hepm = get_hepm(boost::edge_weight_t(), P);</span></div><div class="line">  <span class="comment">//Hedge, using a std::map</span></div><div class="line">  Hedge2double_map_type hedge2props;</div><div class="line">  Hedge_PM_type hepm(hedge2props);</div><div class="line"></div><div class="line">  <span class="comment">//Facet PM, with enriched Facet</span></div><div class="line">  <span class="comment">//FacetPM_type fpm = get_fpm(boost::vertex_attribute_t(), P);</span></div><div class="line">  <span class="comment">//Facet PM, with std::map</span></div><div class="line">  Facet2normal_map_type facet2props;</div><div class="line">  Facet_PM_type fpm(facet2props);</div><div class="line"></div><div class="line">  <span class="comment">//initialize Polyhedral data : length of edges, normal of facets</span></div><div class="line">  Poly_hedge_ops::compute_edges_length(P, hepm);</div><div class="line">  Poly_facet_ops::compute_facets_normals(P, fpm);</div><div class="line"></div><div class="line">  <span class="comment">//MAIN LOOP: perform calculation for each vertex</span></div><div class="line">  <span class="comment">//----------------------------------------------</span></div><div class="line">  std::vector&lt;DPoint&gt; in_points;  <span class="comment">//container for data points</span></div><div class="line">  Vertex_iterator vitb, vite;</div><div class="line"></div><div class="line">  <span class="comment">//initialize the tag of all vertices to -1</span></div><div class="line">  vitb = P.vertices_begin(); vite = P.vertices_end();</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/group__PkgHandlesAndCirculatorsFunctions.html#gae4f6b9dc3b933f01f2d0275a7bf8b308">CGAL_For_all</a>(vitb,vite) put(vpm, &amp;(*vitb), -1);</div><div class="line"></div><div class="line">  vitb = P.vertices_begin(); vite = P.vertices_end();</div><div class="line">  <span class="keywordflow">for</span> (; vitb != vite; vitb++) {</div><div class="line">    <span class="comment">//initialize</span></div><div class="line">    Vertex* v = &amp;(*vitb);</div><div class="line">    in_points.clear();</div><div class="line">    My_Monge_form monge_form;</div><div class="line"></div><div class="line">    <span class="comment">//gather points around the vertex using rings</span></div><div class="line">    gather_fitting_points(v, in_points, vpm);</div><div class="line"></div><div class="line">    <span class="comment">//skip if the nb of points is to small</span></div><div class="line">    <span class="keywordflow">if</span> ( in_points.size() &lt; min_nb_points )</div><div class="line">      {std::cerr &lt;&lt; <span class="stringliteral">"not enough pts for fitting this vertex"</span> &lt;&lt; in_points.size() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">continue</span>;}</div><div class="line"></div><div class="line">    <span class="comment">// perform the fitting</span></div><div class="line">    My_Monge_via_jet_fitting monge_fit;</div><div class="line">    monge_form = monge_fit(in_points.begin(), in_points.end(),</div><div class="line">               d_fitting, d_monge);</div><div class="line">    <span class="comment">//switch min-max ppal curv/dir wrt the mesh orientation</span></div><div class="line">    <span class="keyword">const</span> DVector normal_mesh = Poly_facet_ops::compute_vertex_average_unit_normal(v, fpm);</div><div class="line">    monge_form.comply_wrt_given_normal(normal_mesh);</div><div class="line"></div><div class="line">    <span class="comment">//OpenGL output. Scaling for ppal dir, may be optimized with a</span></div><div class="line">    <span class="comment">//global mean edges length computed only once on all edges of P</span></div><div class="line">    DFT scale_ppal_dir = Poly_hedge_ops::compute_mean_edges_length_around_vertex(v, hepm)/2;</div><div class="line"></div><div class="line">    out_4ogl &lt;&lt; v-&gt;point()  &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    monge_form.dump_4ogl(out_4ogl, scale_ppal_dir);</div><div class="line"></div><div class="line">    <span class="comment">//verbose txt output</span></div><div class="line">    <span class="keywordflow">if</span> (verbose) {</div><div class="line">      std::vector&lt;DPoint&gt;::iterator itbp = in_points.begin(), itep = in_points.end();</div><div class="line">      out_verbose &lt;&lt; <span class="stringliteral">"in_points list : "</span> &lt;&lt; std::endl ;</div><div class="line">      <span class="keywordflow">for</span> (;itbp!=itep;itbp++) out_verbose &lt;&lt; *itbp &lt;&lt; std::endl ;</div><div class="line"></div><div class="line">      out_verbose &lt;&lt; <span class="stringliteral">"--- vertex "</span> &lt;&lt;  ++nb_vertices_considered</div><div class="line">                  &lt;&lt;    <span class="stringliteral">" : "</span> &lt;&lt; v-&gt;point() &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">"number of points used : "</span> &lt;&lt; in_points.size() &lt;&lt; std::endl</div><div class="line">    ;<span class="comment">// &lt;&lt; monge_form;</span></div><div class="line">    }</div><div class="line">  } <span class="comment">//all vertices processed</span></div><div class="line"></div><div class="line">  <span class="comment">//cleanup filenames</span></div><div class="line">  <span class="comment">//------------------</span></div><div class="line">  out_4ogl.close();</div><div class="line">  <span class="keywordflow">if</span>(verbose) {</div><div class="line">    out_verbose.close();</div><div class="line">  }  </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:06 for CGAL 4.13 - Estimation of Local Differential Properties of Point-Sampled Surfaces by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
