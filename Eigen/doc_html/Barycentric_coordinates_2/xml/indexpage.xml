<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Generalized_Barycentric_Coordinates"/></para><para><simplesect kind="authors"><para>Dmitry Anisimov, David Bommes, Kai Hormann, and Pierre Alliez</para></simplesect>
</para><sect1 id="index_1gbc_introduction">
<title>Introduction</title>
<para>The package <emphasis>2D Generalized Barycentric Coordinates</emphasis> offers an efficient and robust implementation of two-dimensional closed-form generalized barycentric coordinates defined for simple two-dimensional polygons. If coordinates with respect to multivariate scattered points instead of a polygon are required, please refer to natural neighbour coordinates from the package <ref refid="packages_1PkgInterpolation2Summary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">2D and Surface Function Interpolation</ref>.</para><para>In particular, the package includes an implementation of <ref refid="index_1wp_example" kindref="member">Wachspress</ref>, <ref refid="index_1mv_example" kindref="member">mean value</ref>, and <ref refid="index_1dh_example" kindref="member">discrete harmonic</ref> coordinates and provides some extra functions to compute barycentric coordinates with respect to segments (<ref refid="index_1seg_example" kindref="member">segment coordinates</ref>) and triangles (<ref refid="index_1tri_example" kindref="member">triangle coordinates</ref>). The section <ref refid="index_1gbc_theory" kindref="member">Theory of 2D Generalized Barycentric Coordinates</ref> gives a short introduction to the topic of barycentric coordinates.</para></sect1>
<sect1 id="index_1gbc_interface">
<title>Interface</title>
<para>Each class that computes barycentric coordinates is parameterized by a traits class. This traits class specifies types and geometric primitives that are used in the computation and must be a model of the concept <computeroutput><ref refid="classBarycentricTraits__2" kindref="compound">BarycentricTraits_2</ref></computeroutput>.</para><para>The main entry point to the component is an input iterator over the vertices of a polygon. The polygon&apos;s vertices must follow clockwise or anticlockwise ordering and can be of any type. However, internally the classes use the type <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Point_2</ref></computeroutput>, that is why an appropriate traits class that converts the user&apos;s type to <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Point_2</ref></computeroutput> must be provided. The same argument holds for query points.</para><para>Mean value coordinates are the most generic coordinates in this package because they allow an arbitrary simple polygon as input. Wachspress and discrete harmonic coordinates are, by definition, limited to strictly convex polygons. Segment coordinates take as input any non-degenerate segment, and triangle coordinates allow an arbitrary non-degenerate triangle.</para><para>Segment and triangle coordinates can be computed by using either a global function or creating the corresponding class. All other generalized coordinates can be computed by creating an instance of the class <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2</ref></computeroutput> parameterized by an appropriate coordinate type that must be a model of the concept <computeroutput><ref refid="classBarycentricCoordinates__2" kindref="compound">BarycentricCoordinates_2</ref></computeroutput>.</para><para>Any point in the plane may be taken as a query point. However, we do not recommend to use Wachspress and discrete harmonic coordinates with query points outside the closure of a polygon because at some of those points these coordinates are not well-defined, as explained in the Section <ref refid="index_1gbc_degeneracies" kindref="member">Degeneracies and Special Cases</ref>.</para><para>Once instantiated for some polygon, the coordinates can be computed multiple times for different query points with respect to all the vertices of the provided polygon. Use the <ref refid="group__PkgBarycentric__coordinates__2" kindref="compound">Reference Manual</ref> for the detailed interface.</para><para>The output of the computation is a set of coordinate values at the current query point with respect to all the vertices of the polygon. This output can be stored in an arbitrary container providing an appropriate output iterator. In addition, all the classes return a pointer to the last stored element and a status of the computation (Boolean true or false).</para></sect1>
<sect1 id="index_1gbc_examples">
<title>Examples</title>
<sect2 id="index_1seg_example">
<title>Segment Coordinates</title>
<para>This is a simple example to show the use of the global function <ref refid="classCGAL_1_1Barycentric__coordinates_1_1Segment__coordinates__2_1seg_coord_global" kindref="member">CGAL::Barycentric_coordinates::compute_segment_coordinates_2()</ref>. We compute coordinates at three green points along the segment <formula id="0">$[v_0, v_1]$</formula> and at two blue points outside this segment but along its supporting line. We use the exact kernel and return coordinates as an array of two values. Again, the symmetry of the query points helps us to recognize errors that may have occured during the computation.</para><para><anchor id="index_1seg_coord_example"/><anchor id="index_1fig__seg__example"/><image type="html" name="segment_coordinates_example.png"></image>
 <image type="latex" name="segment_coordinates_example.png" width="15cm"></image>
  <ref refid="index_1fig__seg__example" kindref="member">fig__seg__example</ref> Example&apos;s point pattern.  <linebreak/>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2Segment_coordinates_example_8cpp-example" kindref="compound">Barycentric_coordinates_2/Segment_coordinates_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Segment_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Namespace<sp/>alias.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">BC<sp/>=<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates" kindref="compound">CGAL::Barycentric_coordinates</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Some<sp/>convenient<sp/>typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/><sp/><sp/><sp/><sp/><sp/>Scalar;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1cpp11_1_1array" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::array&lt;Scalar,2&gt;</ref><sp/>Pair;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cout;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>segment.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/><sp/>first_vertex(0,<sp/>Scalar(2)/Scalar(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>second_vertex(2,<sp/>Scalar(2)/Scalar(5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>three<sp/>interior<sp/>and<sp/>two<sp/>exterior<sp/>query<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>query_points[5]<sp/>=<sp/>{<sp/>Point(Scalar(2)<sp/>/Scalar(5),<sp/>Scalar(2)/Scalar(5)),<sp/></highlight><highlight class="comment">//<sp/>interior<sp/>query<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>Scalar(2)/Scalar(5)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(Scalar(8)<sp/>/Scalar(5),<sp/>Scalar(2)/Scalar(5)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(Scalar(-1)/Scalar(5),<sp/>Scalar(2)/Scalar(5)),<sp/></highlight><highlight class="comment">//<sp/>exterior<sp/>query<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(Scalar(11)/Scalar(5),<sp/>Scalar(2)/Scalar(5))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>segment<sp/>coordinates<sp/>for<sp/>all<sp/>the<sp/>defined<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>a<sp/>global<sp/>function<sp/>and<sp/>return<sp/>the<sp/>segment<sp/>coordinates<sp/>stored<sp/>in<sp/>an<sp/>array<sp/>of<sp/>the<sp/>type<sp/>CGAL::cpp11::array&lt;FT,2&gt;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Computed<sp/>segment<sp/>coordinates:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>5;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Pair<sp/>pair<sp/>=<sp/>BC::compute_segment_coordinates_2(first_vertex,<sp/>second_vertex,<sp/>query_points[i],<sp/>Kernel());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>both<sp/>coordinates<sp/>for<sp/>each<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Pair<sp/>of<sp/>coordinates<sp/>#<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>=<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>pair[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>pair[1]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;);&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1tri_example">
<title>Triangle Coordinates</title>
<para>In this example we show how to use the class <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Triangle__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Triangle_coordinates_2</ref></computeroutput> with the <computeroutput><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Simple_cartesian</ref></computeroutput> kernel for double type. We compute coordinates for three sets of points: interior (green), boundary (red), and exterior (blue). Note that some of the coordinate values for the exterior points are negative. We use a standard container of the type <ulink url="http://en.cppreference.com/w/cpp/container/vector"><computeroutput>std::vector</computeroutput></ulink> and <ulink url="http://en.cppreference.com/w/cpp/iterator/insert_iterator"><computeroutput>std::insert_iterator</computeroutput></ulink> to access and store the resulting coordinate values.</para><para><anchor id="index_1tri_coord_example"/><anchor id="index_1fig__tri__example"/><image type="html" name="triangle_coordinates_example.png"></image>
 <image type="latex" name="triangle_coordinates_example.png" width="15cm"></image>
  <ref refid="index_1fig__tri__example" kindref="member">fig__tri__example</ref> Example&apos;s point pattern.  <linebreak/>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2Triangle_coordinates_example_8cpp-example" kindref="compound">Barycentric_coordinates_2/Triangle_coordinates_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Triangle_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Some<sp/>convenient<sp/>typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/><sp/><sp/><sp/><sp/><sp/>Scalar;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Scalar&gt;<sp/>Scalar_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Triangle__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Triangle_coordinates_2&lt;Kernel&gt;</ref><sp/>Triangle_coordinates;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cout;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>triangle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/><sp/>first_vertex(0.0f,<sp/>0.0f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>second_vertex(2.0f,<sp/>0.5f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/><sp/>third_vertex(1.0f,<sp/>2.0f);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>std::vector<sp/>to<sp/>store<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Scalar_vector<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>the<sp/>class<sp/>Triangle_coordinates_2<sp/>for<sp/>the<sp/>triangle<sp/>defined<sp/>above.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Triangle_coordinates<sp/>triangle_coordinates(first_vertex,<sp/>second_vertex,<sp/>third_vertex);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>some<sp/>information<sp/>about<sp/>the<sp/>triangle<sp/>and<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>triangle_coordinates.print_information();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>some<sp/>interior,<sp/>boundary,<sp/>and<sp/>exterior<sp/>query<sp/>points<sp/>for<sp/>which<sp/>we<sp/>compute<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_query_points<sp/>=<sp/>18;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>query_points[]<sp/>=<sp/>{<sp/>Point(0.5f<sp/>,<sp/>0.5f<sp/>),<sp/>Point(1.0f,<sp/>0.5f<sp/>),<sp/>Point(1.0f<sp/>,<sp/>0.75f),<sp/>Point(1.0f<sp/>,<sp/>1.0f),<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>interior<sp/>query<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(1.0f<sp/>,<sp/>1.25f),<sp/>Point(1.0f,<sp/>1.5f<sp/>),<sp/>Point(0.75f,<sp/>1.0f<sp/>),<sp/>Point(1.25f,<sp/>1.0f),<sp/>Point(1.5f,<sp/>0.75f),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(1.0f<sp/>,<sp/>0.25f),<sp/>Point(0.5f,<sp/>1.0f<sp/>),<sp/>Point(1.5f<sp/>,<sp/>1.25f),<sp/>Point(1.0f<sp/>,<sp/>2.0f),<sp/>Point(2.0f,<sp/>0.5f<sp/>),<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>query<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(0.25f,<sp/>1.0f<sp/>),<sp/>Point(0.5f,<sp/>1.75f),<sp/>Point(1.5f<sp/>,<sp/>1.75f),<sp/>Point(1.75f,<sp/>1.5f)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>exterior<sp/>query<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Reserve<sp/>memory<sp/>to<sp/>store<sp/>triangle<sp/>coordinates<sp/>for<sp/>18<sp/>query<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates.reserve(number_of_query_points<sp/>*<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>triangle<sp/>coordinates<sp/>for<sp/>these<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Computed<sp/>triangle<sp/>coordinates:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>number_of_query_points;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triangle_coordinates(query_points[i],<sp/>std::inserter(coordinates,<sp/>coordinates.end()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>the<sp/>coordinates<sp/>for<sp/>each<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Point<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>3;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;coordinate<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>j<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>coordinates[i<sp/>*<sp/>3<sp/>+<sp/>j]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1wp_example">
<title>Wachspress Coordinates</title>
<para>In the following example we create 1000 random points, then we take the convex hull of this set of points as our polygon, and compute Wachspress coordinates at all the defined points. We use the <computeroutput><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Simple_cartesian</ref></computeroutput> kernel with double type as a traits class and store obtained coordinate values in a container of the type <ulink url="http://en.cppreference.com/w/cpp/container/vector"><computeroutput>std::vector</computeroutput></ulink>. The output iterator is <ulink url="http://en.cppreference.com/w/cpp/iterator/back_insert_iterator"><computeroutput>std::back_insert_iterator</computeroutput></ulink>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2Wachspress_coordinates_example_8cpp-example" kindref="compound">Barycentric_coordinates_2/Wachspress_coordinates_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/convex_hull_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Wachspress_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Generalized_barycentric_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Some<sp/>convenient<sp/>typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/><sp/><sp/><sp/><sp/><sp/>Scalar;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Scalar&gt;<sp/>Scalar_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point&gt;<sp/><sp/>Point_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;double, Point&gt;</ref><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Wachspress__2" kindref="compound">CGAL::Barycentric_coordinates::Wachspress_2&lt;Kernel&gt;</ref><sp/>Wachspress;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2&lt;Wachspress, Kernel&gt;</ref><sp/>Wachspress_coordinates;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cout;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Choose<sp/>how<sp/>many<sp/>random<sp/>points<sp/>we<sp/>want<sp/>to<sp/>generate.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_points<sp/>=<sp/>1000;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>vectors<sp/>to<sp/>store<sp/>generated<sp/>points<sp/>and<sp/>vertices<sp/>of<sp/>a<sp/>convex<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_vector<sp/>points,<sp/>vertices;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Generate<sp/>a<sp/>set<sp/>of<sp/>random<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Random__points__in__square__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Generator.tag">CGAL::Random_points_in_square_2&lt;Point,Creator&gt;</ref><sp/>point_generator(1.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__STLAlgos_1gadba21cc5c30a79519438dfe0f9264255" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::copy_n</ref>(point_generator,<sp/>number_of_points,<sp/>std::back_inserter(points));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>the<sp/>convex<sp/>hull<sp/>of<sp/>the<sp/>generated<sp/>set<sp/>of<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>convex<sp/>hull<sp/>gives<sp/>the<sp/>vertices<sp/>of<sp/>a<sp/>convex<sp/>polygon<sp/>that<sp/>contains<sp/>all<sp/>the<sp/>generated<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgConvexHull2Functions_1ga8241d43969ff61cb9be46811c2e9e176" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">CGAL::convex_hull_2</ref>(points.begin(),<sp/>points.end(),<sp/>std::back_inserter(vertices));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>number_of_vertices<sp/>=<sp/>vertices.size();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>the<sp/>class<sp/>with<sp/>Wachspress<sp/>coordinates<sp/>for<sp/>the<sp/>convex<sp/>polygon<sp/>defined<sp/>above.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Wachspress_coordinates<sp/>wachspress_coordinates(vertices.begin(),<sp/>vertices.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>some<sp/>information<sp/>about<sp/>the<sp/>polygon<sp/>and<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wachspress_coordinates.print_information();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>Wachspress<sp/>coordinates<sp/>for<sp/>all<sp/>the<sp/>randomly<sp/>defined<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Computed<sp/>Wachspress<sp/>coordinates:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>number_of_points;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Scalar_vector<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>coordinates.reserve(number_of_vertices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wachspress_coordinates(points[i],<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>the<sp/>computed<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Point<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>int(number_of_vertices);<sp/>++j)<sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Coordinate<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>j<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>coordinates[j]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1dh_example">
<title>Discrete Harmonic Coordinates</title>
<para>In this example we compute discrete harmonic coordinates for a set of green (interior), red (boundary), and blue (exterior) points with respect to a unit square. We also show how to specify the location of a query point using additional function parameters. The used kernel is exact, and we use an output container of the type <ulink url="http://en.cppreference.com/w/cpp/container/vector"><computeroutput>std::vector</computeroutput></ulink>. Since all the points are symmetric, it is easy to debug the correctness of the obtained coordinate values. The output iterator is <ulink url="http://en.cppreference.com/w/cpp/iterator/back_insert_iterator"><computeroutput>std::back_insert_iterator</computeroutput></ulink>.</para><para><anchor id="index_1dh_coord_example"/><anchor id="index_1fig__dh__example"/><image type="html" name="discrete_harmonic_coordinates_example.png"></image>
 <image type="latex" name="discrete_harmonic_coordinates_example.png" width="15cm"></image>
  <ref refid="index_1fig__dh__example" kindref="member">fig__dh__example</ref> Example&apos;s point pattern.  <linebreak/>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2Discrete_harmonic_coordinates_example_8cpp-example" kindref="compound">Barycentric_coordinates_2/Discrete_harmonic_coordinates_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Discrete_harmonic_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Generalized_barycentric_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Some<sp/>convenient<sp/>typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/><sp/><sp/><sp/><sp/><sp/>Scalar;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Scalar&gt;<sp/>Scalar_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point&gt;<sp/><sp/>Point_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::back_insert_iterator&lt;Scalar_vector&gt;<sp/>Vector_insert_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::optional&lt;Vector_insert_iterator&gt;<sp/>Output_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Discrete__harmonic__2" kindref="compound">CGAL::Barycentric_coordinates::Discrete_harmonic_2&lt;Kernel&gt;</ref><sp/>Discrete_harmonic;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2&lt;Discrete_harmonic, Kernel&gt;</ref><sp/>Discrete_harmonic_coordinates;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cout;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>unit<sp/>square.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_vertices<sp/>=<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_vector<sp/>vertices(number_of_vertices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[0]<sp/>=<sp/>Point(0,<sp/>0);<sp/>vertices[1]<sp/>=<sp/>Point(1,<sp/>0);<sp/>vertices[2]<sp/>=<sp/>Point(1,<sp/>1);<sp/>vertices[3]<sp/>=<sp/>Point(0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>std::vector<sp/>to<sp/>store<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Scalar_vector<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>the<sp/>class<sp/>with<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>for<sp/>the<sp/>unit<sp/>square<sp/>defined<sp/>above.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Discrete_harmonic_coordinates<sp/>discrete_harmonic_coordinates(vertices.begin(),<sp/>vertices.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>some<sp/>information<sp/>about<sp/>the<sp/>polygon<sp/>and<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>discrete_harmonic_coordinates.print_information();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>the<sp/>center<sp/>point<sp/>of<sp/>the<sp/>unit<sp/>square.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>center(Scalar(1)/Scalar(2),<sp/>Scalar(1)/Scalar(2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>for<sp/>the<sp/>center<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>the<sp/>parameter<sp/>query_point_location<sp/>=<sp/>CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Output_type<sp/>result<sp/>=<sp/>discrete_harmonic_coordinates(center,<sp/>std::back_inserter(coordinates),<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1aedeeb072a2024053a016afd15e591331ae39bd08a2cdcb80b675b80d816742e6c" kindref="member">CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>other<sp/>4<sp/>interior<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_interior_points<sp/>=<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>interior_points[number_of_interior_points]<sp/>=<sp/>{<sp/>Point(Scalar(1)/Scalar(5),<sp/>Scalar(1)/Scalar(5))<sp/><sp/>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(Scalar(4)/Scalar(5),<sp/>Scalar(1)/Scalar(5))<sp/><sp/>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(Scalar(4)/Scalar(5),<sp/>Scalar(4)/Scalar(5))<sp/><sp/>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(Scalar(1)/Scalar(5),<sp/>Scalar(4)/Scalar(5))<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>for<sp/>these<sp/>points<sp/>and<sp/>store<sp/>them<sp/>at<sp/>the<sp/>same<sp/>vector<sp/>&quot;coordinates&quot;<sp/>as<sp/>before.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>number_of_interior_points;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>discrete_harmonic_coordinates(interior_points[i],<sp/>std::back_inserter(coordinates),<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1aedeeb072a2024053a016afd15e591331ae39bd08a2cdcb80b675b80d816742e6c" kindref="member">CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>2<sp/>boundary<sp/>points<sp/>on<sp/>the<sp/>second<sp/>and<sp/>last<sp/>edges.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>second_edge(1,<sp/>Scalar(4)/Scalar(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/><sp/><sp/>last_edge(0,<sp/>Scalar(4)/Scalar(5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>for<sp/>these<sp/>2<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>the<sp/>parameter<sp/>query_point_location<sp/>=<sp/>CGAL::Barycentric_coordinates::ON_BOUNDARY.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>discrete_harmonic_coordinates(second_edge,<sp/>std::back_inserter(coordinates),<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1aedeeb072a2024053a016afd15e591331a3ec95e5787c2784177ee121601e54cda" kindref="member">CGAL::Barycentric_coordinates::ON_BOUNDARY</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>discrete_harmonic_coordinates(last_edge<sp/><sp/>,<sp/>std::back_inserter(coordinates),<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1aedeeb072a2024053a016afd15e591331a3ec95e5787c2784177ee121601e54cda" kindref="member">CGAL::Barycentric_coordinates::ON_BOUNDARY</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>2<sp/>other<sp/>boundary<sp/>points<sp/>on<sp/>the<sp/>first<sp/>and<sp/>third<sp/>edges.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>first_edge(Scalar(1)/Scalar(2),<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>third_edge(Scalar(1)/Scalar(2),<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>using<sp/>index<sp/>of<sp/>an<sp/>appropriate<sp/>edge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Do<sp/>not<sp/>forget<sp/>that<sp/>index<sp/>counting<sp/>starts<sp/>from<sp/>zero.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>discrete_harmonic_coordinates.compute_on_edge(first_edge,<sp/>0,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>discrete_harmonic_coordinates.compute_on_edge(third_edge,<sp/>2,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>for<sp/>the<sp/>points<sp/>at<sp/>the<sp/>first<sp/>and<sp/>third<sp/>vertex<sp/>of<sp/>the<sp/>unit<sp/>square.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>discrete_harmonic_coordinates.compute_on_vertex(0,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>discrete_harmonic_coordinates.compute_on_vertex(2,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>points<sp/>at<sp/>the<sp/>second<sp/>and<sp/>fourth<sp/>vertex<sp/>of<sp/>the<sp/>unit<sp/>square.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>second_vertex(1,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>fourth_vertex(0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>for<sp/>these<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>the<sp/>parameter<sp/>query_point_location<sp/>=<sp/>CGAL::Barycentric_coordinates::ON_VERTEX.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>discrete_harmonic_coordinates(second_vertex,<sp/>std::back_inserter(coordinates),<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1aedeeb072a2024053a016afd15e591331a17f3ca7a9b64a6aa68a50cbc71736588" kindref="member">CGAL::Barycentric_coordinates::ON_VERTEX</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>discrete_harmonic_coordinates(fourth_vertex,<sp/>std::back_inserter(coordinates),<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1aedeeb072a2024053a016afd15e591331a17f3ca7a9b64a6aa68a50cbc71736588" kindref="member">CGAL::Barycentric_coordinates::ON_VERTEX</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>2<sp/>points<sp/>outside<sp/>the<sp/>unit<sp/>square<sp/>-<sp/>one<sp/>from<sp/>the<sp/>left<sp/>and<sp/>one<sp/>from<sp/>the<sp/>right.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>left_most(Scalar(-1)/Scalar(2),<sp/>Scalar(1)/Scalar(2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>right_most(Scalar(3)/Scalar(2),<sp/>Scalar(1)/Scalar(2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>for<sp/>these<sp/>2<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>the<sp/>parameter<sp/>query_point_location<sp/>=<sp/>CGAL::Barycentric_coordinates::ON_UNBOUNDED_SIDE.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>discrete_harmonic_coordinates(left_most<sp/>,<sp/>std::back_inserter(coordinates),<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1aedeeb072a2024053a016afd15e591331aa70930d8955740f21091d1353b2dae28" kindref="member">CGAL::Barycentric_coordinates::ON_UNBOUNDED_SIDE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/>discrete_harmonic_coordinates(right_most,<sp/>std::back_inserter(coordinates),<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1aedeeb072a2024053a016afd15e591331aa70930d8955740f21091d1353b2dae28" kindref="member">CGAL::Barycentric_coordinates::ON_UNBOUNDED_SIDE</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>the<sp/>computed<sp/>coordinate<sp/>values.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Exact<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>for<sp/>all<sp/>the<sp/>defined<sp/>points:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>number_of_query_points<sp/>=<sp/>coordinates.size();<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>0;<sp/>index<sp/>&lt;<sp/>int(number_of_query_points);<sp/>++index)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Coordinate<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>index<sp/>%<sp/>number_of_vertices<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>coordinates[index]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((index<sp/>+<sp/><sp/>1)<sp/>%<sp/><sp/><sp/><sp/><sp/><sp/>number_of_vertices<sp/><sp/>==<sp/>0)<sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((index<sp/>+<sp/>13)<sp/>%<sp/>(4<sp/>*<sp/>number_of_vertices)<sp/>==<sp/>0)<sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Return<sp/>status<sp/>of<sp/>the<sp/>last<sp/>computation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>status<sp/>=<sp/>(result<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;SUCCESS.&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;FAILURE.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Status<sp/>of<sp/>the<sp/>last<sp/>computation:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>status<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1mv_example">
<title>Mean Value Coordinates</title>
<para>This is an example that shows how to compute mean value coordinates for a set of green points in a star-shaped polygon. We note that this type of coordinates is well-defined for such a concave polygon while Wachspress and discrete harmonic coordinates are not. However, it may give negative coordinate values for points outside <ulink url="https://en.wikipedia.org/wiki/Star-shaped_polygon">the polygon&apos;s kernel</ulink> (shown in red). We use an inexact data type, an output container of the type <ulink url="http://en.cppreference.com/w/cpp/container/vector"><computeroutput>std::vector</computeroutput></ulink>, and an output iterator of the type <ulink url="http://en.cppreference.com/w/cpp/iterator/back_insert_iterator">std::back_insert_iterator</ulink> to compute, access, and store the resulting coordinate values. We also show how to choose different algorithms to compute generalized barycentric coordinates (one is more precise while the other is faster).</para><para><anchor id="index_1mv_coord_example"/><anchor id="index_1fig__mv__example"/><image type="html" name="mean_value_coordinates_example.png"></image>
 <image type="latex" name="mean_value_coordinates_example.png" width="15cm"></image>
  <ref refid="index_1fig__mv__example" kindref="member">fig__mv__example</ref> Example&apos;s point pattern.  <linebreak/>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2Mean_value_coordinates_example_8cpp-example" kindref="compound">Barycentric_coordinates_2/Mean_value_coordinates_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Mean_value_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Generalized_barycentric_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Some<sp/>convenient<sp/>typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/><sp/><sp/><sp/><sp/><sp/>Scalar;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Scalar&gt;<sp/>Scalar_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point&gt;<sp/><sp/>Point_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::back_insert_iterator&lt;Scalar_vector&gt;<sp/>Vector_insert_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::optional&lt;Vector_insert_iterator&gt;<sp/>Output_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__2" kindref="compound">CGAL::Barycentric_coordinates::Mean_value_2&lt;Kernel&gt;</ref><sp/>Mean_value;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2&lt;Mean_value, Kernel&gt;</ref><sp/>Mean_value_coordinates;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cout;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>star-shaped<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_vertices<sp/>=<sp/>10;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_vector<sp/>vertices(number_of_vertices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[0]<sp/>=<sp/>Point(0.0,<sp/>0.0);<sp/>vertices[1]<sp/>=<sp/>Point(0.1,<sp/>-0.8);<sp/>vertices[2]<sp/>=<sp/>Point(0.3,<sp/>0.0);<sp/>vertices[3]<sp/>=<sp/>Point(0.6,<sp/>-0.5);<sp/>vertices[4]<sp/><sp/>=<sp/>Point(0.6<sp/>,<sp/>0.1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[5]<sp/>=<sp/>Point(1.1,<sp/>0.6);<sp/>vertices[6]<sp/>=<sp/>Point(0.3,<sp/><sp/>0.2);<sp/>vertices[7]<sp/>=<sp/>Point(0.1,<sp/>0.8);<sp/>vertices[8]<sp/>=<sp/>Point(0.1,<sp/><sp/>0.2);<sp/>vertices[9]<sp/>=<sp/>Point(-0.7,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>std::vector<sp/>to<sp/>store<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Scalar_vector<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>the<sp/>class<sp/>with<sp/>mean<sp/>value<sp/>coordinates<sp/>for<sp/>the<sp/>polygon<sp/>defined<sp/>above.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Mean_value_coordinates<sp/>mean_value_coordinates(vertices.begin(),<sp/>vertices.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>some<sp/>information<sp/>about<sp/>the<sp/>polygon<sp/>and<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mean_value_coordinates.print_information();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>some<sp/>interior<sp/>points<sp/>in<sp/>the<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_interior_points<sp/>=<sp/>8;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>interior_points[]<sp/>=<sp/>{<sp/>Point(0.12,<sp/>-0.45),<sp/>Point(0.55,<sp/>-0.3),<sp/>Point(0.9<sp/>,<sp/>0.45),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(0.15,<sp/><sp/>0.35),<sp/>Point(-0.4,<sp/>0.04),<sp/>Point(0.11,<sp/>0.11),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(0.28,<sp/><sp/>0.12),<sp/></highlight><highlight class="comment">//<sp/>the<sp/>only<sp/>point<sp/>in<sp/>the<sp/>kernel<sp/>of<sp/>the<sp/>star<sp/>shaped<sp/>polygon</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(0.55,<sp/><sp/>0.11)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>mean<sp/>value<sp/>coordinates<sp/>for<sp/>all<sp/>the<sp/>defined<sp/>interior<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>speed<sp/>up<sp/>the<sp/>computation<sp/>using<sp/>the<sp/>O(n)<sp/>algorithm<sp/>called<sp/>with<sp/>the<sp/>parameter<sp/>CGAL::Barycentric_coordinates::FAST.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>default<sp/>one<sp/>is<sp/>CGAL::Barycentric_coordinates::PRECISE.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1a5e5682512438422f23d6080edc49c05b" kindref="member">CGAL::Barycentric_coordinates::Type_of_algorithm</ref><sp/>type_of_algorithm<sp/>=<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1a5e5682512438422f23d6080edc49c05baa29350a20af70a27cca8f0715055118f" kindref="member">CGAL::Barycentric_coordinates::FAST</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>also<sp/>speed<sp/>up<sp/>the<sp/>computation<sp/>by<sp/>using<sp/>the<sp/>parameter<sp/>query_point_location<sp/>=<sp/>CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1aedeeb072a2024053a016afd15e591331" kindref="member">CGAL::Barycentric_coordinates::Query_point_location</ref><sp/>query_point_location<sp/>=<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1aedeeb072a2024053a016afd15e591331ae39bd08a2cdcb80b675b80d816742e6c" kindref="member">CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>number_of_interior_points;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Output_type<sp/>result<sp/>=<sp/>mean_value_coordinates(interior_points[i],<sp/>std::back_inserter(coordinates),<sp/>query_point_location,<sp/>type_of_algorithm);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>the<sp/>coordinates<sp/>for<sp/>each<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>status<sp/>=<sp/>(result<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;SUCCESS.&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;FAILURE.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;For<sp/>the<sp/>point<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>status<sp/>of<sp/>the<sp/>computation:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>status<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>number_of_vertices;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Coordinate<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>j<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>coordinates[i<sp/>*<sp/>number_of_vertices<sp/>+<sp/>j]<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>we<sp/>need<sp/>only<sp/>the<sp/>unnormalized<sp/>weights<sp/>for<sp/>some<sp/>point<sp/>(lets<sp/>take<sp/>the<sp/>last<sp/>one),<sp/>we<sp/>can<sp/>compute<sp/>them<sp/>as<sp/>follows.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>an<sp/>std::vector<sp/>to<sp/>store<sp/>weights.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Scalar_vector<sp/>weights;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>mean<sp/>value<sp/>weights.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>last_point_index<sp/>=<sp/>number_of_interior_points<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Output_type<sp/>result<sp/>=<sp/>mean_value_coordinates.compute_weights(interior_points[last_point_index],<sp/>std::back_inserter(weights));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>their<sp/>sum.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Scalar<sp/>mv_denominator<sp/>=<sp/>Scalar(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>number_of_vertices;<sp/>++j)<sp/>mv_denominator<sp/>+=<sp/>weights[j];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Invert<sp/>this<sp/>sum.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Scalar<sp/>mv_inverted_denominator<sp/>=<sp/>Scalar(1)<sp/>/<sp/>mv_denominator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>the<sp/>mean<sp/>value<sp/>weights.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>status<sp/>=<sp/>(result<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;SUCCESS.&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;FAILURE.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Status<sp/>of<sp/>the<sp/>weights&apos;<sp/>computation<sp/>for<sp/>the<sp/>point<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>last_point_index<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>status<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>number_of_vertices;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Weight<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>j<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>weights[j]<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Now,<sp/>if<sp/>we<sp/>normalize<sp/>the<sp/>weights,<sp/>we<sp/>recover<sp/>values<sp/>of<sp/>the<sp/>mean<sp/>value<sp/>coordinates<sp/>for<sp/>the<sp/>last<sp/>point<sp/>computed<sp/>earlier.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;After<sp/>normalization,<sp/>for<sp/>the<sp/>point<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>last_point_index<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>mean<sp/>value<sp/>coordinates<sp/>are<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>number_of_vertices;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Coordinate<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>j<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>weights[j]<sp/>*<sp/>mv_inverted_denominator<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1height_inter_example">
<title>Height Interpolation for Terrain Modeling</title>
<para>This is an advanced example that shows how to use generalized barycentric coordinates for height interpolation with applications to terrain modelling. It also shows how to use a non-default traits class with our package instead of a <computeroutput><ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> traits class. Suppose we know the boundary of three-dimensional piece of terrain that can be represented as a polygon with several three-dimensional vertices, where the third dimension gives the corresponding height. The task is to propagate the height from the known sample points on the boundary to the polygon&apos;s interior. This gives an approximate estimation of the terrain&apos;s surface in this region.</para><para><anchor id="index_1fig__terrain__example"/><image type="html" name="terrain.png"></image>
 <image type="latex" name="terrain.png" width="15cm"></image>
  <ref refid="index_1fig__terrain__example" kindref="member">fig__terrain__example</ref> A 2D polygon with 50 vertices representing a piece of terrain with convex and concave parts. The height is not shown.  <linebreak/>
</para><para>In this example we project a three-dimensional polygon orthogonally onto the two-dimensional plane using the class <computeroutput><ref refid="classCGAL_1_1Projection__traits__xy__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Projection_traits_xy_3</ref></computeroutput>, triangulate its interior using the class <computeroutput><ref refid="classCGAL_1_1Delaunay__mesher__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Mesh_2.tag">CGAL::Delaunay_mesher_2</ref></computeroutput>, and compute mean value coordinates for all the obtained points with respect to all the polygon&apos;s vertices. Finally, we interpolate the height data from the polygon&apos;s boundary to its interior using the computed coordinates and the global interpolation function from the package <ref refid="packages_1PkgInterpolation2Summary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">2D and Surface Function Interpolation</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2Terrain_height_modeling_8cpp-example" kindref="compound">Barycentric_coordinates_2/Terrain_height_modeling.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_mesher_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Interpolation_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Projection_traits_xy_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/interpolation_functions.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_mesh_face_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_mesh_size_criteria_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Mean_value_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Generalized_barycentric_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Some<sp/>convenient<sp/>typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>General.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Projection__traits__xy__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Projection;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Projection::FT<sp/><sp/><sp/><sp/><sp/><sp/>Scalar;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Projection::Point_2<sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Scalar&gt;<sp/>Scalar_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point&gt;<sp/><sp/>Point_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Coordinates<sp/>related.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__2" kindref="compound">CGAL::Barycentric_coordinates::Mean_value_2&lt;Projection&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Mean_value;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2&lt;Mean_value, Projection&gt;</ref><sp/>Mean_value_coordinates;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Triangulation<sp/>related.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__mesh__face__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Mesh_2.tag">CGAL::Delaunay_mesh_face_base_2&lt;Projection&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_base;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::Triangulation_vertex_base_2&lt;Projection&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_base;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_2&lt;Vertex_base,<sp/>Face_base&gt;<sp/>TDS;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Constrained__Delaunay__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::Constrained_Delaunay_triangulation_2&lt;Projection, TDS&gt;</ref><sp/><sp/>CDT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__mesh__size__criteria__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Mesh_2.tag">CGAL::Delaunay_mesh_size_criteria_2&lt;CDT&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Criteria;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__mesher__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Mesh_2.tag">CGAL::Delaunay_mesher_2&lt;CDT, Criteria&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Mesher;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CDT::Finite_vertices_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CDT::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Interpolation<sp/>related.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Interpolation__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Interpolation.tag">CGAL::Interpolation_traits_2&lt;Projection&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Interpolation_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Data__access" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Interpolation.tag">CGAL::Data_access&lt; std::map&lt;Point, Scalar, Projection::Less_xy_2 &gt;</ref><sp/>&gt;<sp/>Value_access;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>STD.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cout;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>polygon<sp/>bounding<sp/>a<sp/>piece<sp/>of<sp/>three-dimensional<sp/>terrain.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>z-coordinate<sp/>of<sp/>each<sp/>vertex<sp/>represents<sp/>the<sp/>height<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Projection<sp/>in<sp/>2D<sp/>is<sp/>done<sp/>automatically<sp/>by<sp/>the<sp/>Projection<sp/>traits<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_vertices<sp/>=<sp/>50;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_vector<sp/>vertices(number_of_vertices);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[0]<sp/><sp/>=<sp/>Point(0.03,<sp/>0.05,<sp/>0.000);<sp/>vertices[1]<sp/><sp/>=<sp/>Point(0.07,<sp/>0.04,<sp/>10.00);<sp/>vertices[2]<sp/><sp/>=<sp/>Point(0.10,<sp/>0.04,<sp/>20.00);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[3]<sp/><sp/>=<sp/>Point(0.14,<sp/>0.04,<sp/>30.00);<sp/>vertices[4]<sp/><sp/>=<sp/>Point(0.17,<sp/>0.07,<sp/>40.00);<sp/>vertices[5]<sp/><sp/>=<sp/>Point(0.19,<sp/>0.09,<sp/>50.00);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[6]<sp/><sp/>=<sp/>Point(0.22,<sp/>0.11,<sp/>60.00);<sp/>vertices[7]<sp/><sp/>=<sp/>Point(0.25,<sp/>0.11,<sp/>70.00);<sp/>vertices[8]<sp/><sp/>=<sp/>Point(0.27,<sp/>0.10,<sp/>80.00);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[9]<sp/><sp/>=<sp/>Point(0.30,<sp/>0.07,<sp/>90.00);<sp/>vertices[10]<sp/>=<sp/>Point(0.31,<sp/>0.04,<sp/>100.0);<sp/>vertices[11]<sp/>=<sp/>Point(0.34,<sp/>0.03,<sp/>110.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[12]<sp/>=<sp/>Point(0.37,<sp/>0.02,<sp/>120.0);<sp/>vertices[13]<sp/>=<sp/>Point(0.40,<sp/>0.03,<sp/>130.0);<sp/>vertices[14]<sp/>=<sp/>Point(0.42,<sp/>0.04,<sp/>140.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[15]<sp/>=<sp/>Point(0.44,<sp/>0.07,<sp/>150.0);<sp/>vertices[16]<sp/>=<sp/>Point(0.45,<sp/>0.10,<sp/>160.0);<sp/>vertices[17]<sp/>=<sp/>Point(0.46,<sp/>0.13,<sp/>170.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[18]<sp/>=<sp/>Point(0.46,<sp/>0.19,<sp/>180.0);<sp/>vertices[19]<sp/>=<sp/>Point(0.47,<sp/>0.26,<sp/>190.0);<sp/>vertices[20]<sp/>=<sp/>Point(0.47,<sp/>0.31,<sp/>200.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[21]<sp/>=<sp/>Point(0.47,<sp/>0.35,<sp/>210.0);<sp/>vertices[22]<sp/>=<sp/>Point(0.45,<sp/>0.37,<sp/>220.0);<sp/>vertices[23]<sp/>=<sp/>Point(0.41,<sp/>0.38,<sp/>230.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[24]<sp/>=<sp/>Point(0.38,<sp/>0.37,<sp/>240.0);<sp/>vertices[25]<sp/>=<sp/>Point(0.35,<sp/>0.36,<sp/>250.0);<sp/>vertices[26]<sp/>=<sp/>Point(0.32,<sp/>0.35,<sp/>260.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[27]<sp/>=<sp/>Point(0.30,<sp/>0.37,<sp/>270.0);<sp/>vertices[28]<sp/>=<sp/>Point(0.28,<sp/>0.39,<sp/>280.0);<sp/>vertices[29]<sp/>=<sp/>Point(0.25,<sp/>0.40,<sp/>290.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[30]<sp/>=<sp/>Point(0.23,<sp/>0.39,<sp/>300.0);<sp/>vertices[31]<sp/>=<sp/>Point(0.21,<sp/>0.37,<sp/>310.0);<sp/>vertices[32]<sp/>=<sp/>Point(0.21,<sp/>0.34,<sp/>320.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[33]<sp/>=<sp/>Point(0.23,<sp/>0.32,<sp/>330.0);<sp/>vertices[34]<sp/>=<sp/>Point(0.24,<sp/>0.29,<sp/>340.0);<sp/>vertices[35]<sp/>=<sp/>Point(0.27,<sp/>0.24,<sp/>350.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[36]<sp/>=<sp/>Point(0.29,<sp/>0.21,<sp/>360.0);<sp/>vertices[37]<sp/>=<sp/>Point(0.29,<sp/>0.18,<sp/>370.0);<sp/>vertices[38]<sp/>=<sp/>Point(0.26,<sp/>0.16,<sp/>380.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[39]<sp/>=<sp/>Point(0.24,<sp/>0.17,<sp/>390.0);<sp/>vertices[40]<sp/>=<sp/>Point(0.23,<sp/>0.19,<sp/>400.0);<sp/>vertices[41]<sp/>=<sp/>Point(0.24,<sp/>0.22,<sp/>410.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[42]<sp/>=<sp/>Point(0.24,<sp/>0.25,<sp/>420.0);<sp/>vertices[43]<sp/>=<sp/>Point(0.21,<sp/>0.26,<sp/>430.0);<sp/>vertices[44]<sp/>=<sp/>Point(0.17,<sp/>0.26,<sp/>440.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[45]<sp/>=<sp/>Point(0.12,<sp/>0.24,<sp/>450.0);<sp/>vertices[46]<sp/>=<sp/>Point(0.07,<sp/>0.20,<sp/>460.0);<sp/>vertices[47]<sp/>=<sp/>Point(0.03,<sp/>0.15,<sp/>470.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices[48]<sp/>=<sp/>Point(0.01,<sp/>0.10,<sp/>480.0);<sp/>vertices[49]<sp/>=<sp/>Point(0.02,<sp/>0.07,<sp/>490.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Mesh<sp/>this<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>constrained<sp/>Delaunay<sp/>triangulation.<sp/><sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CDT<sp/>cdt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Vertex_handle&gt;<sp/>vertex_handle(number_of_vertices);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>vertices<sp/>of<sp/>the<sp/>polygon<sp/>as<sp/>our<sp/>initial<sp/>point<sp/>set.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>number_of_vertices;<sp/>++i)<sp/>vertex_handle[i]<sp/>=<sp/>cdt.insert(vertices[i]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>constraints<sp/>-<sp/>edges<sp/>of<sp/>the<sp/>polygon<sp/>-<sp/>in<sp/>order<sp/>to<sp/>mesh<sp/>only<sp/>the<sp/>polygon&apos;s<sp/>interior.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>number_of_vertices;<sp/>++i)<sp/>cdt.insert_constraint(vertex_handle[i],<sp/>vertex_handle[(i<sp/>+<sp/>1)<sp/>%<sp/>number_of_vertices]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Mesher<sp/>mesher(cdt);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>a<sp/>criteria<sp/>on<sp/>how<sp/>to<sp/>mesh.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mesher.set_criteria(Criteria(0.01,<sp/>0.01));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Mesh<sp/>the<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mesher.refine_mesh();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>mean<sp/>value<sp/>coordinates<sp/>and<sp/>use<sp/>them<sp/>to<sp/>interpolate<sp/>data<sp/>from<sp/>the<sp/>polygon&apos;s<sp/>boundary<sp/>to<sp/>its<sp/>interior.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Associate<sp/>each<sp/>point<sp/>with<sp/>the<sp/>corresponding<sp/>function<sp/>value<sp/>and<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::map&lt;Point,<sp/>Scalar,<sp/>Projection::Less_xy_2&gt;<sp/>point_function_value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;<sp/>std::pair&lt;Point,<sp/>Scalar&gt;<sp/>&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point_coordinates(number_of_vertices);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>number_of_vertices;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point_function_value.insert(std::make_pair(vertices[i],<sp/>vertices[i].z()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>class<sp/>with<sp/>mean<sp/>value<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Mean_value_coordinates<sp/>mean_value_coordinates(vertices.begin(),<sp/>vertices.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Store<sp/>all<sp/>new<sp/>interior<sp/>points<sp/>with<sp/>interpolated<sp/>data<sp/>here.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Point&gt;<sp/>points(cdt.number_of_vertices());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Result<sp/>of<sp/>the<sp/>height<sp/>interpolation:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>coordinates<sp/>and<sp/>interpolate<sp/>the<sp/>boundary<sp/>data<sp/>to<sp/>the<sp/>polygon&apos;s<sp/>interior.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Vertex_iterator<sp/>vertex_iterator<sp/>=<sp/>cdt.finite_vertices_begin();<sp/>vertex_iterator<sp/>!=<sp/>cdt.finite_vertices_end();<sp/>++vertex_iterator)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Scalar_vector<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>&amp;point<sp/>=<sp/>vertex_iterator-&gt;point();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mean_value_coordinates(point,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>number_of_vertices;<sp/>++j)<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point_coordinates[j]<sp/>=<sp/>std::make_pair(vertices[j],<sp/>coordinates[j]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Scalar<sp/>f<sp/>=<sp/><ref refid="group__PkgInterpolation2Interpolation_1ga2f8a2f88b5b91b9f3db2d5e40bfa1df7" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Interpolation.tag">CGAL::linear_interpolation</ref>(point_coordinates.begin(),<sp/>point_coordinates.end(),<sp/>Scalar(1),<sp/>Value_access(point_function_value));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points[index]<sp/>=<sp/>Point(point.x(),<sp/>point.y(),<sp/>f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>interpolated<sp/>height<sp/>with<sp/>index<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>index<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>is<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>f<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;;&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++index;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>As a result we get a smooth function inside the polygon that approximates the underlying terrain&apos;s surface.</para><para><anchor id="index_1fig__terrain__inter__example"/><image type="html" name="terrain_interpolated.png"></image>
 <image type="latex" name="terrain_interpolated.png" width="15cm"></image>
  <ref refid="index_1fig__terrain__inter__example" kindref="member">fig__terrain__inter__example</ref> The interpolated data. The colour bar represents the corresponding height.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1gbc_degeneracies">
<title>Degeneracies and Special Cases</title>
<para><anchor id="index_1compute_seg_coord"/></para><sect2 id="index_1gbc_deg_segment_coordinates">
<title>Segment Coordinates</title>
<para>Segment coordinates can be computed exactly if an exact data type is chosen. The segment itself, with respect to which we compute coordinates, must be non-degenerate. If both conditions are satisfied, then the computation never fails. However, to compute coordinates, the user must be sure about the query point being exactly on the line <formula id="1">$L$</formula> supporting the segment. Since in many applications this is not the case, and a query point may lie very close but not exactly on this line, the class is also able to handle this situation.</para><para><anchor id="index_1fig__projection"/><image type="html" name="projection.png"></image>
 <image type="latex" name="projection.png" width="15cm"></image>
  <ref refid="index_1fig__projection" kindref="member">fig__projection</ref> The orthogonal projection <formula id="2">$p&apos;$</formula> of the vector <formula id="3">$p$</formula> (green) onto the vector <formula id="4">$q$</formula> (red).  <linebreak/>
</para><para>Suppose that some query point <formula id="5">$v$</formula> does not lie exactly on the line <formula id="1">$L$</formula>, but is some distance <formula id="6">$d$</formula> away as shown in the figure above. If we want to compute the segment barycentric coordinate <formula id="7">$b_1(v)$</formula> with respect to the vertex <formula id="8">$v_1$</formula>, we first find the orthogonal projection <formula id="2">$p&apos;$</formula> of the vector <formula id="3">$p$</formula> onto the vector <formula id="4">$q$</formula> and then normalize it by the length of <formula id="4">$q$</formula>. This gives the segment barycentric coordinate <formula id="9">$b_1(v&apos;) = b_1(v)$</formula> if <formula id="5">$v$</formula> lies exactly on the line.</para><para><bold>Warning:</bold> do not abuse the feature described above because it does not give correct segment barycentric coordinates for the point <formula id="5">$v$</formula> but rather those for <formula id="10">$v&apos;$</formula>. Moreover, segment barycentric coordinates for a point <formula id="5">$v$</formula>, which does not lie exactly on the line <formula id="1">$L$</formula>, do not exist. But if the non-zero distance <formula id="6">$d$</formula> is due to some numerical instability when computing the location of the point <formula id="5">$v$</formula> or any other problem, which causes the point to be not exactly on the line, the final segment coordinates will be, at least approximately, correct.</para><para>With inexact data types, the resulting coordinate values are correct up to the precision of the chosen type.</para></sect2>
<sect2 id="index_1gbc_deg_triangular_coordinates">
<title>Triangle Coordinates</title>
<para>These coordinates can be computed exactly if an exact data type is chosen, for any query point in the plane and with respect to any non-degenerate triangle. No special cases are handled. The computation always gives the correct result. The notion of correctness depends on the precision of the used data type. Note that for exterior points some coordinate values will be negative.</para></sect2>
<sect2 id="index_1gbc_deg_wachspress_coordinates">
<title>Wachspress Coordinates</title>
<para>Wachspress coordinates are well-defined in the closure of any <emphasis>strictly convex polygon</emphasis>. Therefore, for any query point from the polygon&apos;s closure with an exact data type, these coordinates are computed exactly and no false result is expected. For inexact data types, the resulting precision of the computation is due to the involved algorithm and chosen data type. In the following paragraph we discuss two available algorithms for computing Wachspress coordinates. One of them is <computeroutput><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1a5e5682512438422f23d6080edc49c05ba03442337422ef674615d3a2d148c726f" kindref="member">CGAL::Barycentric_coordinates::PRECISE</ref></computeroutput>, the other is <computeroutput><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1a5e5682512438422f23d6080edc49c05baa29350a20af70a27cca8f0715055118f" kindref="member">CGAL::Barycentric_coordinates::FAST</ref></computeroutput>.</para><para><anchor id="index_1wp_polygon"/><anchor id="index_1fig__wp__notations"/><image type="html" name="wp_notations.png"></image>
 <image type="latex" name="wp_notations.png" width="15cm"></image>
  <ref refid="index_1fig__wp__notations" kindref="member">fig__wp__notations</ref> Notation for Wachspress coordinates.  <linebreak/>
</para><para>To compute Wachspress weights, we follow <ref refid="citelist_1CITEREF_cgal:bc:fhk-gcbcocp-06" kindref="member">[2]</ref> and use the formula</para><para><center> <formula id="11">$w_i = \frac{C_i}{A_{i-1}A_i}$</formula></center></para><para>with <formula id="12">$i = 1\dots n$</formula> where <formula id="13">$n$</formula> is the number of the polygon&apos;s vertices. In order to compute the coordinates, we normalize these weights,</para><para><center> <formula id="14">$b_i = \frac{w_i}{W^{wp}}\qquad$</formula> with <formula id="15">$\qquad W^{wp} = \sum_{j=1}^n w_j.$</formula></center></para><para>This formula becomes unstable when approaching the boundary of the polygon ( <formula id="16">$\approx 1.0e-10$</formula> and closer). To fix the problem, we modify the weights <formula id="17">$w_i$</formula> as</para><para><center> <formula id="18">$\bar{w}_i = C_i\prod_{j\not=i-1,i} A_j$</formula>.</center></para><para>After the normalization as above, this gives us the precise algorithm to compute Wachspress coordinates but with <formula id="19">$O(n^2)$</formula> performance only. The fast <formula id="20">$O(n)$</formula> algorithm uses the standard weights <formula id="17">$w_i$</formula>. Note that mathematically this modification does not change the coordinates.</para><para>It is known that for strictly convex polygons the denominator&apos;s zero set of the Wachspress coordinates ( <formula id="21">$W^{wp} = 0~$</formula>) is a curve, which (in many cases) lies quite far away from the polygon. Speaking precisely, it interpolates the intersection points of the continuations of the polygon&apos;s edges. Therefore, the computation of Wachspress coordinates outside the polygon is possible only at points that do not belong to this curve.</para><para><anchor id="index_1fig__zero__set"/><image type="html" name="zero_set.png"></image>
 <image type="latex" name="zero_set.png" width="15cm"></image>
  <ref refid="index_1fig__zero__set" kindref="member">fig__zero__set</ref> Zero set (red) of the Wachspress coordinates&apos; denominator <formula id="22">$W^{wp}$</formula> for a non-regular hexagon.  <linebreak/>
</para><para><bold>Warning:</bold> we do not recommend to use Wachspress coordinates for exterior points!</para></sect2>
<sect2 id="index_1gbc_deg_discrete_harmonic_coordinates">
<title>Discrete Harmonic Coordinates</title>
<para>Discrete harmonic coordinates have the same requirements as Wachspress coordinates. They are well-defined in the closure of any <emphasis>strictly convex polygon</emphasis> and, if an exact data type is chosen, they are computed exactly. But, unlike Wachspress basis functions, these coordinates are not necessarily positive. In particular, the weight <formula id="17">$w_i$</formula> is positive if and only if <formula id="23">$\alpha+\beta &lt; \pi$</formula> (see the figure below for notation). For inexact data types, the precision of the computation is due to the involved algorithm and chosen data type. Again, we describe two algorithms to compute the coordinates: one is precise and one is fast.</para><para><anchor id="index_1dh_polygon"/><anchor id="index_1fig__dh__notations"/><image type="html" name="dh_notations.png"></image>
 <image type="latex" name="dh_notations.png" width="15cm"></image>
  <ref refid="index_1fig__dh__notations" kindref="member">fig__dh__notations</ref> Notation for discrete harmonic coordinates.  <linebreak/>
</para><para>To compute discrete harmonic weights, we follow <ref refid="citelist_1CITEREF_cgal:bc:fhk-gcbcocp-06" kindref="member">[2]</ref> and use the formula</para><para><center> <formula id="24">$w_i = \frac{r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i}{A_{i-1}A_i}$</formula></center></para><para>with <formula id="12">$i = 1\dots n$</formula> where <formula id="13">$n$</formula> is the number of the polygon&apos;s vertices. In order to compute the coordinates, we normalize these weights,</para><para><center> <formula id="25">$b_i = \frac{w_i}{W^{dh}}\qquad$</formula> with <formula id="26">$\qquad W^{dh} = \sum_{j=1}^n w_j.$</formula></center></para><para>This formula becomes unstable when approaching the boundary of the polygon ( <formula id="16">$\approx 1.0e-10$</formula> and closer). To fix the problem, similarly to the previous subsection, we modify the weights <formula id="17">$w_i$</formula> as</para><para><center> <formula id="27">$\bar{w}_i = (r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i)\prod_{j\not=i-1,i} A_j$</formula>.</center></para><para>After the normalization as above, this gives the precise algorithm to compute discrete harmonic coordinates but with <formula id="19">$O(n^2)$</formula> performance only. The fast <formula id="20">$O(n)$</formula> algorithm uses the standard weights <formula id="17">$w_i$</formula>. Again, mathematically this modification does not change the coordinates.</para><para><bold>Warning:</bold> as for Wachspress coordinates, we do not recommend to use discrete harmonic coordinates for exterior points because the curve <formula id="28">$W^{dh} = 0$</formula> may have several components, and one of them interpolates the polygon&apos;s vertices. However, if you are sure that the query point does not belong to this curve, you can compute the coordinates as shown in <ref refid="index_1dh_example" kindref="member">this example</ref>.</para></sect2>
<sect2 id="index_1gbc_deg_mean_value_coordinates">
<title>Mean Value Coordinates</title>
<para>Unlike the previous coordinates, mean value coordinates cannot be computed exactly due to an inevitable square root operation. Although, if an exact data type is used, the default precision of the computation depends only on two CGAL functions: <computeroutput>CGAL::to_double()</computeroutput> and <computeroutput>CGAL::sqrt()</computeroutput>. On the other hand, mean value coordinates are well-defined everywhere in the plane for any simple polygon. In addition, if your traits class provides a more precise version of the square root function, the final precision of the computation with exact data types will depend only on the precision of that function.</para><para><anchor id="index_1mv_polygon"/><anchor id="index_1fig__mv__notations"/><image type="html" name="mv_notations.png"></image>
 <image type="latex" name="mv_notations.png" width="15cm"></image>
  <ref refid="index_1fig__mv__notations" kindref="member">fig__mv__notations</ref> Notation for mean value coordinates.  <linebreak/>
</para><para>For these coordinates we also have two algorithms: one is precise and one is fast. The first one works everywhere in the plane, and the precision of the computation depends only on the chosen data type, including the remarks above. This algorithm is based on the following weight formula from <ref refid="citelist_1CITEREF_cgal:bc:f-wmvc-14" kindref="member">[4]</ref></para><para><center> <formula id="29">$w_i = \sigma_i\bar{w}_i\qquad$</formula> with <formula id="30">$\qquad\bar{w}_i = (r_{i-1}r_{i+1}-d_{i-1}d_{i+1})^{1/2}\prod_{j\not= i-1,i}(r_jr_{j+1} + d_jd_{j+1})^{1/2}\qquad$</formula> where <formula id="31">$\qquad r_i = \|d_i\|.$</formula></center></para><para>Since <formula id="32">$\bar{w}_i$</formula> is always positive, we have to append to it the proper sign <formula id="33">$\sigma_i$</formula> of the signed mean value weight, which can be found efficiently (see the figures below). Basically, this weight is always positive to the left of the red piecewise linear curve, and it is negative to the right of this curve, moving in anticlockwise direction.</para><para><anchor id="index_1fig__mv__weight__signs"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="mv_weight_signs_convex.png"></image>
 <image type="latex" name="mv_weight_signs_convex.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="mv_weight_signs_concave.png"></image>
 <image type="latex" name="mv_weight_signs_concave.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__mv__weight__signs" kindref="member">fig__mv__weight__signs</ref> Signs of the mean value weight <formula id="17">$w_i$</formula> depending on the region with respect to a convex polygon <formula id="34">$P$</formula> and a concave polygon <formula id="35">$P&apos;$</formula>.  <linebreak/>
</para><para>After the normalization of these weights as before</para><para><center> <formula id="36">$b_i = \frac{w_i}{W^{mv}}\qquad$</formula> with <formula id="37">$\qquad W^{mv} = \sum_{j=1}^n w_j$</formula></center></para><para>we obtain the precise <formula id="19">$O(n^2)$</formula> algorithm. The fast O(n) algorithm computes the weights <formula id="17">$w_i$</formula> using the pseudocode from <ulink url="http://www.inf.usi.ch/hormann/nsfworkshop/presentations/Hormann.pdf">here</ulink>. These weights</para><para><center> <formula id="38">$w_i = \frac{t_{i-1} + t_i}{r_i}\qquad$</formula> with <formula id="39">$\qquad t_i = \frac{\text{det}(d_i, d_{i+1})}{r_ir_{i+1} + d_id_{i+1}}$</formula></center></para><para>are also normalized. Note that they are unstable if a query point is closer than <formula id="16">$\approx 1.0e-10$</formula> to the polygon&apos;s boundary, similarly to Wachspress and discrete harmonic coordinates.</para></sect2>
</sect1>
<sect1 id="index_1gbc_performance">
<title>Performance</title>
<para>Apart from the most important requirement on barycentric coordinates to be as precise as possible, it is very important for them to be as fast as possible to evaluate. These coordinates are used in many applications where they must be computed for millions of points and, thus, the real time usage of coordinates is crucial. When writing the code, we tried to fulfil this important requirement, and in this section we present a few results about the computation times of the implemented coordinates.</para><para>The structure of the speed test that we ran for all functions consists of computing coordinate values (or weights) at &gt;= 1 million strictly interior points with respect to some polygon (or triangle, or segment). At each iteration of the loop we create a query point, pass it to the function, and compute all the related coordinates. We run this loop 10 times in a row, and the time presented in the log-log scale plot at the end of the section is the arithmetic mean of all trials.</para><para>A typical example of this performance test for triangle coordinates with reduced number of query points can be found below. This example also illustrates how to construct an iterator and pass it to the class. In this example we create an iterator that writes coordinate values for each new query point over coordinate values of the previous point in the fixed-size standard C++ array, so that memory is allocated only once.</para><para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2Triangle_coordinates_speed_test_8cpp-example" kindref="compound">Barycentric_coordinates_2/Triangle_coordinates_speed_test.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Real_timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Triangle_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>iterator<sp/>that<sp/>takes<sp/>as<sp/>input<sp/>the<sp/>current<sp/>data<sp/>type<sp/>and<sp/>pointer<sp/>to<sp/>the<sp/>first<sp/>element<sp/>in<sp/>the<sp/>standard<sp/>C++<sp/>array.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Scalar&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">overwrite_iterator</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Scalar*<sp/>pointer;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">explicit</highlight><highlight class="normal"><sp/>overwrite_iterator(Scalar*<sp/>new_pointer)<sp/>:<sp/>pointer(new_pointer)<sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>are<sp/>only<sp/>two<sp/>operations<sp/>that<sp/>we<sp/>need<sp/>to<sp/>overload<sp/>in<sp/>order<sp/>to<sp/>use<sp/>the<sp/>class<sp/>Triangle_coordinates_2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>operation<sp/>is<sp/>intended<sp/>to<sp/>return<sp/>the<sp/>current<sp/>coordinate<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>Scalar&amp;<sp/><ref refid="group__Kernel__operator__prod_1ga8427cff04588dc338b8acf3e1b116dce" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">operator* </ref>()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*pointer;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>operation<sp/>is<sp/>intended<sp/>to<sp/>increase<sp/>the<sp/>index<sp/>of<sp/>the<sp/>coordinate.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgGenerators_1gac38f30d4c4e8520612409327d2913c4a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Generator.tag">operator++ </ref>()<sp/>{<sp/>++pointer;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Some<sp/>convenient<sp/>typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Real_timer<sp/>Timer;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/><sp/><sp/><sp/><sp/><sp/>Scalar;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>overwrite_iterator&lt;Scalar&gt;<sp/>Overwrite_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Triangle__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Triangle_coordinates_2&lt;Kernel&gt;</ref><sp/>Triangle_coordinates;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cout;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::endl;<sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::string;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Number<sp/>of<sp/>x<sp/>and<sp/>y<sp/>coordinates<sp/>together<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_x_coordinates<sp/>=<sp/>100000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_y_coordinates<sp/>=<sp/>1000;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Number<sp/>of<sp/>runs<sp/>to<sp/>compute<sp/>the<sp/>arithmetic<sp/>mean<sp/>of<sp/>the<sp/>time.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_runs<sp/>=<sp/>10;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>uniform<sp/>step<sp/>size<sp/>along<sp/>x<sp/>and<sp/>y<sp/>directions<sp/>to<sp/>change<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Scalar<sp/>zero<sp/>=<sp/>Scalar(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Scalar<sp/>one<sp/><sp/>=<sp/>Scalar(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Scalar<sp/>two<sp/><sp/>=<sp/>Scalar(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Scalar<sp/>x_step<sp/>=<sp/>one<sp/>/<sp/>Scalar(number_of_x_coordinates);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Scalar<sp/>y_step<sp/>=<sp/>one<sp/>/<sp/>Scalar(number_of_y_coordinates);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>right<sp/>triangle<sp/>with<sp/>a<sp/>slight<sp/>offset<sp/>from<sp/>zero.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/><sp/>first_vertex(zero<sp/>-<sp/>x_step,<sp/>zero<sp/>-<sp/>x_step);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>second_vertex(two<sp/><sp/>+<sp/>y_step,<sp/>zero<sp/>-<sp/>x_step);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/><sp/>third_vertex(zero<sp/>-<sp/>x_step,<sp/>two<sp/><sp/>+<sp/>y_step);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>the<sp/>class<sp/>Triangle_coordinates_2<sp/>for<sp/>the<sp/>right<sp/>triangle<sp/>defined<sp/>above.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Triangle_coordinates<sp/>triangle_coordinates(first_vertex,<sp/>second_vertex,<sp/>third_vertex);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>standard<sp/>C++<sp/>array<sp/>to<sp/>store<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>It<sp/>has<sp/>the<sp/>fixed<sp/>size<sp/>=<sp/>3<sp/>=<sp/>number<sp/>of<sp/>vertices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Scalar<sp/>coordinates<sp/>[3]<sp/>=<sp/>{0,<sp/>0,<sp/>0};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Pass<sp/>pointer<sp/>to<sp/>the<sp/>first<sp/>element<sp/>of<sp/>the<sp/>array<sp/>with<sp/>coordinates<sp/>in<sp/>order<sp/>to<sp/>overwrite<sp/>them.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Overwrite_iterator<sp/>it(<sp/>&amp;(coordinates[0])<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>timer.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Timer<sp/>time_to_compute;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>time<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>number_of_runs;<sp/>++i)<sp/>{<sp/></highlight><highlight class="comment">//<sp/>Number<sp/>of<sp/>runs</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>time_to_compute.start();<sp/></highlight><highlight class="comment">//<sp/>Start<sp/>clock</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Scalar<sp/>x<sp/>=<sp/>zero;<sp/>x<sp/>&lt;=<sp/>one;<sp/>x<sp/>+=<sp/>x_step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Scalar<sp/>y<sp/>=<sp/>zero;<sp/>y<sp/>&lt;=<sp/>one;<sp/>y<sp/>+=<sp/>y_step)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triangle_coordinates(Point(x,<sp/>y),<sp/>it);<sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>3<sp/>coordinate<sp/>values<sp/>for<sp/>each<sp/>generated<sp/>point</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>time_to_compute.stop();<sp/></highlight><highlight class="comment">//<sp/>Stop<sp/>clock</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>time<sp/>+=<sp/>time_to_compute.time();<sp/></highlight><highlight class="comment">//<sp/>Add<sp/>time<sp/>of<sp/>the<sp/>current<sp/>run<sp/>to<sp/>the<sp/>whole<sp/>time</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>time_to_compute.reset();<sp/></highlight><highlight class="comment">//<sp/>Reset<sp/>time</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>arithmetic<sp/>mean<sp/>of<sp/>all<sp/>the<sp/>runs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>mean_time<sp/>=<sp/>time<sp/>/<sp/>number_of_runs;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>the<sp/>resulting<sp/>time.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout.precision(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;CPU<sp/>time<sp/>to<sp/>compute<sp/>triangle<sp/>coordinates<sp/>for<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>number_of_x_coordinates<sp/>*<sp/>number_of_y_coordinates<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>mean_time<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The time to compute coordinates depends on many factors such as memory allocation, input kernel, output container, number of points, etc. In our tests we used the most standard C++ and CGAL features with minimum memory allocation. Therefore, the final time presented is the average time that can be expected without deep optimization but still with efficient memory allocation. It also means that it may vary depending on the usage of the package.</para><para>For all tests we used a MacBook Pro 2011 with 2 GHz Intel Core i7 processor (2 cores) and 8 GB 1333 MHz DDR3 memory. The installed operating system was OS X 10.9 Maverick. In order to compile the speed test suite, we used the Clang 5.0 64bit compiler. The resulting timings can be found in the figure below.</para><para><anchor id="index_1fig__time"/><image type="html" name="time.png"></image>
 <image type="latex" name="time.png" width="15cm"></image>
  <ref refid="index_1fig__time" kindref="member">fig__time</ref> Time in seconds to compute <formula id="13">$n$</formula> coordinate values for a polygon with <formula id="13">$n$</formula> vertices at 1 million points with the fast <formula id="20">$O(n)$</formula> algorithms (dashed) and the slow <formula id="40">$0(n^2)$</formula> algorithms (solid) for Wachspress (blue), discrete harmonic (red), and mean value (green) coordinates.  <linebreak/>
</para><para>From the figure above it is easy to see that the <formula id="19">$O(n^2)$</formula> algorithm is as fast as the <formula id="20">$O(n)$</formula> algorithm if we have a polygon with a small number of vertices. But as the number of vertices is increased, the linear algorithm outperforms the squared one, as expected. One of the reasons for this behaviour is that for a small number of vertices the multiplications for <formula id="41">$n-2$</formula> elements inside the <formula id="19">$O(n^2)$</formula> algorithm with the fast <formula id="20">$O(n)$</formula> algorithms (dashed) and the slow <formula id="19">$O(n^2)$</formula> algorithms (solid) take almost the same time as the corresponding division in the <formula id="20">$O(n)$</formula> algorithm. For a polygon with many vertices this multiplication is much slower.</para></sect1>
<sect1 id="index_1gbc_implementation">
<title>Implementation Details</title>
<para>The generic design of the package was developed in 2013 by Dmitry Anisimov and David Bommes with many useful comments by Kai Hormann and Pierre Alliez. The package consists of 6 classes, 2 enumerations, and one namespace. Appropriate iterators are used to provide an efficient access to data and to pass them to one of the generic algorithms for computing coordinates. Once instantiated for a polygon (triangle, segment), the coordinates can be computed multiple times for different query points with respect to all the vertices of the provided polygon (triangle, segment). All the classes are fully templated and have a simple and similar design. In particular, we follow the same naming convention for all functions. Yet, the number of functions can differ from one class to another.</para><para>The implemented algorithms for computing coordinates do not depend on a particular kernel, and all the coordinates can be computed exactly, if an exact kernel is used, apart from mean value coordinates. The latter coordinates involve a square root operation, which results in a slightly worse precision with exact data types due to temporal conversion into a floating point type. The computed coordinates can be stored in an arbitrary container if an appropriate <ulink url="http://en.cppreference.com/w/cpp/concept/OutputIterator">output iterator</ulink> is provided.</para><para>It is worth noting that the class <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Segment__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Segment_coordinates_2</ref></computeroutput> is used to compute generalized barycentric coordinates along the polygon&apos;s boundary. Hence, one can use the trick for segment coordinates from Section <ref refid="index_1gbc_degeneracies" kindref="member">Degeneracies and Special Cases</ref> if one is convinced that a point must lie exactly on the polygon&apos;s boundary but due to some numerical instabilities it does not.</para><para>The package is implemented in a way that later, if needed, other two-dimensional generalized barycentric coordinates can be easily added to this package.</para></sect1>
<sect1 id="index_1gbc_theory">
<title>Theory of 2D Generalized Barycentric Coordinates</title>
<para>In 1827, the German mathematician and theoretical astronomer <ulink url="http://en.wikipedia.org/wiki/August_Ferdinand_Mbius">August Ferdinand Mbius</ulink> (1790<ndash/>1868) proposed a method <ref refid="citelist_1CITEREF_cgal:bc:m-dbc-27" kindref="member">[7]</ref> to find coordinates of a point in the plane with respect to the vertices of a triangle. These coordinates are called <ulink url="http://mathworld.wolfram.com/BarycentricCoordinates.html">triangle barycentric coordinates</ulink> (sometimes <ulink url="http://en.wikipedia.org/wiki/Barycentric_coordinate_system">area coordinates</ulink>), and they are widely used in a variety of applications. Some of these applications are linear interpolation over a triangle and a triangle inclusion test. The first one is used for so-called <ulink url="http://en.wikipedia.org/wiki/Shading">shading</ulink>, and the second one arises in the <ulink url="http://en.wikipedia.org/wiki/Rasterization">rasterization</ulink> step when an image in vector graphics format needs to be converted into a raster image.</para><para>Triangle barycentric coordinates have many important properties, including <emphasis>constant</emphasis> and <emphasis>linear precision</emphasis>, <emphasis> the Lagrange property</emphasis>, and <emphasis>positivity inside a triangle</emphasis>. These properties make these coordinates a unique tool in many scientific fields. If we restrict triangle coordinates to one of the edges of a triangle and its supporting line, we get barycentric coordinates with respect to a segment and call them <ref refid="index_1compute_seg_coord" kindref="member">segment coordinates</ref>.</para><para>Let us show a couple of plots for the coordinates described above. To plot segment coordinates, we take a line <formula id="42">$y = 0.4$</formula> and define <ref refid="index_1fig__seg__example" kindref="member">a segment</ref> <formula id="0">$[v_0, v_1]$</formula> on this line. Then we sample this segment and compute segment coordinates for all the sample points. If we plot the segment coordinate function at all the defined points with respect to the vertex <formula id="8">$v_1$</formula>, we get the blue line depicted in the figure below. It grows from zero at the vertex <formula id="43">$v_0$</formula> to one at the vertex <formula id="8">$v_1$</formula>.</para><para><anchor id="index_1fig__seg__coord__interp"/><image type="html" name="seg__coord__interp.png"></image>
 <image type="latex" name="seg__coord__interp.png" width="15cm"></image>
  <ref refid="index_1fig__seg__coord__interp" kindref="member">fig__seg__coord__interp</ref> Segment coordinates (blue) for all the segment points (green) with respect to the vertex <formula id="44">$v_1 = (2.0,\ 0.4)$</formula>.  <linebreak/>
</para><para>If we want to plot triangle coordinates, we follow a similar approach. We take <ref refid="index_1fig__tri__example" kindref="member">a triangle</ref> <formula id="45">$[v_0, v_1, v_2]$</formula> in the plane and sample its interior and boundary with a number of points. Once we have this sampling, we plot one of the triangle coordinate functions (here with respect to the third vertex of the triangle) at all the defined sample points. Likewise, we can plot the coordinate function with respect to the first or second vertex. The resulting function is linear (shown in the figure below) that grows from zero along the first edge <formula id="0">$[v_0, v_1]$</formula> to one at the chosen vertex <formula id="46">$v_2$</formula>.</para><para><anchor id="index_1fig__tri__coord__interp"/><image type="html" name="tri__coord__interp.png"></image>
 <image type="latex" name="tri__coord__interp.png" width="15cm"></image>
  <ref refid="index_1fig__tri__coord__interp" kindref="member">fig__tri__coord__interp</ref> Triangle coordinates with respect to <formula id="47">$v_2 = (1.0,\ 2.0)$</formula>. The colour bar indicates the range of values for the chosen coordinate.  <linebreak/>
</para><para>Since many applications require to work with more complex planar geometric shapes than segments and triangles, it seems natural to investigate a generalized version of triangle coordinates with respect to arbitrary polygons. The first attempt was taken in 1975 by E. L. Wachspress <ref refid="citelist_1CITEREF_cgal:bc:w-rfeb-75" kindref="member">[9]</ref>, and the resulting generalized barycentric coordinates are now called Wachspress coordinates <ref refid="citelist_1CITEREF_cgal:bc:mlbd-gbcip-02" kindref="member">[6]</ref>. <ref refid="index_1gbc_deg_wachspress_coordinates" kindref="member">These coordinates</ref> are well-defined for arbitrary <emphasis>strictly convex polygons</emphasis> and have all the properties of triangle coordinates <ref refid="citelist_1CITEREF_cgal:bc:fhk-gcbcocp-06" kindref="member">[2]</ref>. Unfortunately, they are not well-defined for weakly convex and concave polygons.</para><para>Analogously to the previous cases, we want to plot the Wachspress coordinates and see how they look like. Let us choose a <ref refid="index_1wp_polygon" kindref="member">non-regular hexagon</ref>, slightly rotate it, and move one of its vertices towards the line through its two adjacent neighbours. We sample the interior and the boundary of this polygon as before and plot the coordinate function with respect to the vertex that we moved at all the sample points. We see that we get a smooth function, which is linear along all edges and grows from zero to one, as the colour bar indicates.</para><para><anchor id="index_1wp_plot"/><anchor id="index_1fig__wp__coord__interp"/><image type="html" name="wp__coord__interp.png"></image>
 <image type="latex" name="wp__coord__interp.png" width="15cm"></image>
  <ref refid="index_1fig__wp__coord__interp" kindref="member">fig__wp__coord__interp</ref> The Wachspress coordinate function with respect to the indicated vertex with values from zero to one as the colour bar indicates.  <linebreak/>
</para><para>Another type of generalized barycentric coordinates goes back to Pinkall and Polthier in 1993 <ref refid="citelist_1CITEREF_cgal:pp-cdmsc-93" kindref="member">[8]</ref> and Eck et al. in 1995 <ref refid="citelist_1CITEREF_cgal:bc:eddhls-maam-95" kindref="member">[1]</ref> in the context of <ref refid="packages_1PkgSurfaceParameterizationSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">triangle mesh parameterization</ref>. They are called discrete harmonic coordinates. <ref refid="index_1gbc_deg_discrete_harmonic_coordinates" kindref="member">These coordinates</ref> are well-defined, similarly to Wachspress coordinates, for arbitrary <emphasis>strictly convex polygons</emphasis> and inherit all the properties of triangle coordinates <emphasis>apart from the positivity inside a polygon</emphasis> because they can take on negative values <ref refid="index_1gbc_deg_discrete_harmonic_coordinates" kindref="member">for some polygons</ref>. Another interesting property of these coordinate functions is that they coincide with Wachspress coordinates for any polygon whose vertices lie on a common circle.</para><para>To plot discrete harmonic coordinates we take <ref refid="index_1wp_plot" kindref="member">the same polygon</ref> as for Wachspress coordinates and plot the coordinate function with respect to the same vertex. Again, we get a smooth function, which is linear along all edges and grows from zero to one. Isolines in the plot show the difference between discrete harmonic and Wachspress coordinates for the chosen polygon and vertex.</para><para><anchor id="index_1dh_plot"/><anchor id="index_1fig__dh__coord__interp"/><image type="html" name="dh__coord__interp.png"></image>
 <image type="latex" name="dh__coord__interp.png" width="15cm"></image>
  <ref refid="index_1fig__dh__coord__interp" kindref="member">fig__dh__coord__interp</ref> The discrete harmonic coordinate function with respect to the indicated vertex with values from zero to one as the colour bar indicates.  <linebreak/>
</para><para>The last type of generalized barycentric coordinates that we discuss are mean value coordinates <ref refid="citelist_1CITEREF_cgal:f-mvc-03" kindref="member">[3]</ref> proposed by M. Floater in 2003. Based on the <ulink url="http://en.wikipedia.org/wiki/Mean_value_theorem">mean value theorem</ulink>, <ref refid="index_1gbc_deg_mean_value_coordinates" kindref="member">these coordinates</ref>, unlike Wachspress and discrete harmonic coordinates, are well-defined for arbitrary <emphasis>simple polygons</emphasis>, inherit all the properties of triangle coordinates for any convex polygon, and <emphasis>lack only the positivity property for general concave polygons</emphasis>. Hormann and Floater prove in <ref refid="citelist_1CITEREF_cgal:bc:hf-mvcapp-06" kindref="member">[5]</ref> that these coordinates are positive inside the kernel of a <ulink url="https://en.wikipedia.org/wiki/Star-shaped_polygon">star-shaped polygon</ulink>. They are also positive in the closure of any quadrilateral. Like discrete harmonic weights, mean value weights are often used in the context of <ref refid="packages_1PkgSurfaceParameterizationSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">triangle mesh parameterization.</ref></para><para>In order to show the particular behaviour of mean value coordinates with an application to concave polygons, we take <ref refid="index_1fig__mv__example" kindref="member">a star-shaped polygon</ref> with ten vertices <formula id="48">$[v_0, \dots, v_9]$</formula>, sample its interior and boundary, and plot the coordinate function with respect to the fourth vertex <formula id="49">$v_3$</formula>. As the colour bar indicates, the obtained function grows from a slightly negative value to one at the chosen vertex. It is also smooth inside the polygon and linear along all edges.</para><para><anchor id="index_1fig__mv__coord__interp"/><image type="html" name="mv__coord__interp.png"></image>
 <image type="latex" name="mv__coord__interp.png" width="15cm"></image>
  <ref refid="index_1fig__mv__coord__interp" kindref="member">fig__mv__coord__interp</ref> Mean value coordinates with respect to <formula id="49">$v_3$</formula>. The colour bar indicates the range of values for the chosen coordinate function.  <linebreak/>
</para><para><bold>Interesting fact</bold>: all the coordinates discussed in this section and implemented in the package come from one and the same family of generalized barycentric coordinates named <emphasis>3-point family of coordinates</emphasis> <ref refid="citelist_1CITEREF_cgal:bc:fhk-gcbcocp-06" kindref="member">[2]</ref>.</para></sect1>
<sect1 id="index_1gbc_acknowledgments">
<title>Acknowledgments</title>
<para>The authors wish to thank <ulink url="http://www.inf.usi.ch/phd/schneider/">Teseo Schneider</ulink> and <ulink url="http://search.usi.ch/people/5ae37d3d990b431a02b95b0b606da2e6/Schaerfig-Randolf">Randolf Schaerfig</ulink> for helpful comments and discussions. We also appreciate the great effort invested in this package by our reviewers <ulink url="http://geometryfactory.com/who-we-are/">Andreas Fabri and Sbastien Loriot</ulink>. Finally, to create pictures for this manual, we used two programs: <ulink url="http://www.geogebra.org/cms/en/">Geogebra</ulink> and <ulink url="http://www.mathworks.com/products/matlab/">Matlab</ulink>. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
