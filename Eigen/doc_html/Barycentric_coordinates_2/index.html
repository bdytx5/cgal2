<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Barycentric_coordinates_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Generalized Barycentric Coordinates: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Generalized Barycentric Coordinates
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Generalized_Barycentric_Coordinates"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Dmitry Anisimov, David Bommes, Kai Hormann, and Pierre Alliez</dd></dl>
<h1><a class="anchor" id="gbc_introduction"></a>
Introduction</h1>
<p>The package <em>2D Generalized Barycentric Coordinates</em> offers an efficient and robust implementation of two-dimensional closed-form generalized barycentric coordinates defined for simple two-dimensional polygons. If coordinates with respect to multivariate scattered points instead of a polygon are required, please refer to natural neighbour coordinates from the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgInterpolation2Summary">2D and Surface Function Interpolation</a>.</p>
<p>In particular, the package includes an implementation of <a class="el" href="index.html#wp_example">Wachspress</a>, <a class="el" href="index.html#mv_example">mean value</a>, and <a class="el" href="index.html#dh_example">discrete harmonic</a> coordinates and provides some extra functions to compute barycentric coordinates with respect to segments (<a class="el" href="index.html#seg_example">segment coordinates</a>) and triangles (<a class="el" href="index.html#tri_example">triangle coordinates</a>). The section <a class="el" href="index.html#gbc_theory">Theory of 2D Generalized Barycentric Coordinates</a> gives a short introduction to the topic of barycentric coordinates.</p>
<h1><a class="anchor" id="gbc_interface"></a>
Interface</h1>
<p>Each class that computes barycentric coordinates is parameterized by a traits class. This traits class specifies types and geometric primitives that are used in the computation and must be a model of the concept <code><a class="el" href="classBarycentricTraits__2.html" title="Requirements of the template parameter Traits for all the classes with two-dimensional barycentric co...">BarycentricTraits_2</a></code>.</p>
<p>The main entry point to the component is an input iterator over the vertices of a polygon. The polygon's vertices must follow clockwise or anticlockwise ordering and can be of any type. However, internally the classes use the type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">CGAL::Point_2</a></code>, that is why an appropriate traits class that converts the user's type to <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">CGAL::Point_2</a></code> must be provided. The same argument holds for query points.</p>
<p>Mean value coordinates are the most generic coordinates in this package because they allow an arbitrary simple polygon as input. Wachspress and discrete harmonic coordinates are, by definition, limited to strictly convex polygons. Segment coordinates take as input any non-degenerate segment, and triangle coordinates allow an arbitrary non-degenerate triangle.</p>
<p>Segment and triangle coordinates can be computed by using either a global function or creating the corresponding class. All other generalized coordinates can be computed by creating an instance of the class <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2.html" title="The class Generalized_barycentric_coordinates_2 implements generalized barycentric coordinates along ...">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2</a></code> parameterized by an appropriate coordinate type that must be a model of the concept <code><a class="el" href="classBarycentricCoordinates__2.html" title="Requirements of the template parameter Coordinate_2 for the class CGAL::Barycentric_coordinates::Gene...">BarycentricCoordinates_2</a></code>.</p>
<p>Any point in the plane may be taken as a query point. However, we do not recommend to use Wachspress and discrete harmonic coordinates with query points outside the closure of a polygon because at some of those points these coordinates are not well-defined, as explained in the Section <a class="el" href="index.html#gbc_degeneracies">Degeneracies and Special Cases</a>.</p>
<p>Once instantiated for some polygon, the coordinates can be computed multiple times for different query points with respect to all the vertices of the provided polygon. Use the <a class="el" href="group__PkgBarycentric__coordinates__2.html">Reference Manual</a> for the detailed interface.</p>
<p>The output of the computation is a set of coordinate values at the current query point with respect to all the vertices of the polygon. This output can be stored in an arbitrary container providing an appropriate output iterator. In addition, all the classes return a pointer to the last stored element and a status of the computation (Boolean true or false).</p>
<h1><a class="anchor" id="gbc_examples"></a>
Examples</h1>
<h2><a class="anchor" id="seg_example"></a>
Segment Coordinates</h2>
<p>This is a simple example to show the use of the global function <a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1Segment__coordinates__2.html#seg_coord_global">CGAL::Barycentric_coordinates::compute_segment_coordinates_2()</a>. We compute coordinates at three green points along the segment \([v_0, v_1]\) and at two blue points outside this segment but along its supporting line. We use the exact kernel and return coordinates as an array of two values. Again, the symmetry of the query points helps us to recognize errors that may have occured during the computation.</p>
<p><a class="anchor" id="seg_coord_example"></a><a class="anchor" id="fig__seg__example"></a></p><div class="image">
<img src="segment_coordinates_example.png" alt="segment_coordinates_example.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__seg__example">Figure 88.1</a> Example's point pattern.  </div>  <br />

<p><br />
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2Segment_coordinates_example_8cpp-example.html">Barycentric_coordinates_2/Segment_coordinates_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Segment_coordinates_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Namespace alias.</span></div><div class="line"><span class="keyword">namespace </span>BC = <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html">CGAL::Barycentric_coordinates</a>;</div><div class="line"></div><div class="line"><span class="comment">// Some convenient typedefs.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>      Scalar;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1cpp11_1_1array.html">CGAL::cpp11::array&lt;Scalar,2&gt;</a> Pair;</div><div class="line"></div><div class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::string;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// Construct a segment.</span></div><div class="line">    <span class="keyword">const</span> Point  first_vertex(0, Scalar(2)/Scalar(5));</div><div class="line">    <span class="keyword">const</span> Point second_vertex(2, Scalar(2)/Scalar(5));</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate three interior and two exterior query points.</span></div><div class="line">    <span class="keyword">const</span> Point query_points[5] = { Point(Scalar(2) /Scalar(5), Scalar(2)/Scalar(5)), <span class="comment">// interior query points</span></div><div class="line">                                    Point(1                   , Scalar(2)/Scalar(5)),</div><div class="line">                                    Point(Scalar(8) /Scalar(5), Scalar(2)/Scalar(5)),</div><div class="line">                                    Point(Scalar(-1)/Scalar(5), Scalar(2)/Scalar(5)), <span class="comment">// exterior query points</span></div><div class="line">                                    Point(Scalar(11)/Scalar(5), Scalar(2)/Scalar(5))</div><div class="line">                                  };</div><div class="line"></div><div class="line">    <span class="comment">// Compute segment coordinates for all the defined points.</span></div><div class="line">    <span class="comment">// We use a global function and return the segment coordinates stored in an array of the type CGAL::cpp11::array&lt;FT,2&gt;.</span></div><div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Computed segment coordinates: "</span> &lt;&lt; endl &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 5; ++i) {</div><div class="line">        <span class="keyword">const</span> Pair pair = BC::compute_segment_coordinates_2(first_vertex, second_vertex, query_points[i], <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>());</div><div class="line"></div><div class="line">        <span class="comment">// Output both coordinates for each point.</span></div><div class="line">        cout &lt;&lt; <span class="stringliteral">"Pair of coordinates # "</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">" = ("</span> &lt;&lt; pair[0] &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; pair[1] &lt;&lt; <span class="stringliteral">");"</span> &lt;&lt; endl;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="tri_example"></a>
Triangle Coordinates</h2>
<p>In this example we show how to use the class <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1Triangle__coordinates__2.html" title="The class Triangle_coordinates_2 implements barycentric coordinates ( [1], [2] ) with respect to an a...">CGAL::Barycentric_coordinates::Triangle_coordinates_2</a></code> with the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">Simple_cartesian</a></code> kernel for double type. We compute coordinates for three sets of points: interior (green), boundary (red), and exterior (blue). Note that some of the coordinate values for the exterior points are negative. We use a standard container of the type <a href="http://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a> and <a href="http://en.cppreference.com/w/cpp/iterator/insert_iterator"><code>std::insert_iterator</code></a> to access and store the resulting coordinate values.</p>
<p><a class="anchor" id="tri_coord_example"></a><a class="anchor" id="fig__tri__example"></a></p><div class="image">
<img src="triangle_coordinates_example.png" alt="triangle_coordinates_example.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__tri__example">Figure 88.2</a> Example's point pattern.  </div>  <br />

<p><br />
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2Triangle_coordinates_example_8cpp-example.html">Barycentric_coordinates_2/Triangle_coordinates_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Triangle_coordinates_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Some convenient typedefs.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>      Scalar;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Scalar&gt; Scalar_vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Triangle__coordinates__2.html">CGAL::Barycentric_coordinates::Triangle_coordinates_2&lt;Kernel&gt;</a> Triangle_coordinates;</div><div class="line"></div><div class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::string;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// Construct a triangle.</span></div><div class="line">    <span class="keyword">const</span> Point  first_vertex(0.0f, 0.0f);</div><div class="line">    <span class="keyword">const</span> Point second_vertex(2.0f, 0.5f);</div><div class="line">    <span class="keyword">const</span> Point  third_vertex(1.0f, 2.0f);</div><div class="line"></div><div class="line">    <span class="comment">// Create an std::vector to store coordinates.</span></div><div class="line">    Scalar_vector coordinates;</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate the class Triangle_coordinates_2 for the triangle defined above.</span></div><div class="line">    Triangle_coordinates triangle_coordinates(first_vertex, second_vertex, third_vertex);</div><div class="line"></div><div class="line">    <span class="comment">// Print some information about the triangle and coordinates.</span></div><div class="line">    triangle_coordinates.print_information();</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate some interior, boundary, and exterior query points for which we compute coordinates.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_query_points = 18;</div><div class="line">    <span class="keyword">const</span> Point query_points[] = { Point(0.5f , 0.5f ), Point(1.0f, 0.5f ), Point(1.0f , 0.75f), Point(1.0f , 1.0f),                     <span class="comment">// interior query points</span></div><div class="line">                                   Point(1.0f , 1.25f), Point(1.0f, 1.5f ), Point(0.75f, 1.0f ), Point(1.25f, 1.0f), Point(1.5f, 0.75f),</div><div class="line">                                   Point(1.0f , 0.25f), Point(0.5f, 1.0f ), Point(1.5f , 1.25f), Point(1.0f , 2.0f), Point(2.0f, 0.5f ), <span class="comment">// boundary query points</span></div><div class="line">                                   Point(0.25f, 1.0f ), Point(0.5f, 1.75f), Point(1.5f , 1.75f), Point(1.75f, 1.5f)                      <span class="comment">// exterior query points</span></div><div class="line">                                 };</div><div class="line"></div><div class="line">    <span class="comment">// Reserve memory to store triangle coordinates for 18 query points.</span></div><div class="line">    coordinates.reserve(number_of_query_points * 3);</div><div class="line"></div><div class="line">    <span class="comment">// Compute triangle coordinates for these points.</span></div><div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Computed triangle coordinates: "</span> &lt;&lt; endl &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_query_points; ++i) {</div><div class="line"></div><div class="line">        triangle_coordinates(query_points[i], std::inserter(coordinates, coordinates.end()));</div><div class="line"></div><div class="line">        <span class="comment">// Output the coordinates for each point.</span></div><div class="line">        cout &lt;&lt; <span class="stringliteral">"Point "</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">": "</span>;</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 3; ++j)</div><div class="line">            cout &lt;&lt; <span class="stringliteral">"coordinate "</span> &lt;&lt; j + 1 &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; coordinates[i * 3 + j] &lt;&lt; <span class="stringliteral">"; "</span>;</div><div class="line">        cout &lt;&lt; endl &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="wp_example"></a>
Wachspress Coordinates</h2>
<p>In the following example we create 1000 random points, then we take the convex hull of this set of points as our polygon, and compute Wachspress coordinates at all the defined points. We use the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">Simple_cartesian</a></code> kernel with double type as a traits class and store obtained coordinate values in a container of the type <a href="http://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a>. The output iterator is <a href="http://en.cppreference.com/w/cpp/iterator/back_insert_iterator"><code>std::back_insert_iterator</code></a>.</p>
<p><br />
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2Wachspress_coordinates_example_8cpp-example.html">Barycentric_coordinates_2/Wachspress_coordinates_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/convex_hull_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Wachspress_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Generalized_barycentric_coordinates_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Some convenient typedefs.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>      Scalar;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Scalar&gt; Scalar_vector;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt;  Point_vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">CGAL::Creator_uniform_2&lt;double, Point&gt;</a> Creator;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Wachspress__2.html">CGAL::Barycentric_coordinates::Wachspress_2&lt;Kernel&gt;</a> Wachspress;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2.html">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2&lt;Wachspress, Kernel&gt;</a> Wachspress_coordinates;</div><div class="line"></div><div class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::string;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// Choose how many random points we want to generate.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_points = 1000;</div><div class="line"></div><div class="line">    <span class="comment">// Create vectors to store generated points and vertices of a convex polygon.</span></div><div class="line">    Point_vector points, vertices;</div><div class="line"></div><div class="line">    <span class="comment">// Generate a set of random points.</span></div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Generator.tag:../Generator/" href="../Generator/classCGAL_1_1Random__points__in__square__2.html">CGAL::Random_points_in_square_2&lt;Point,Creator&gt;</a> point_generator(1.0);</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gadba21cc5c30a79519438dfe0f9264255">CGAL::cpp11::copy_n</a>(point_generator, number_of_points, std::back_inserter(points));</div><div class="line"></div><div class="line">    <span class="comment">// Find the convex hull of the generated set of points.</span></div><div class="line">    <span class="comment">// This convex hull gives the vertices of a convex polygon that contains all the generated points.</span></div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">CGAL::convex_hull_2</a>(points.begin(), points.end(), std::back_inserter(vertices));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_vertices = vertices.size();</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate the class with Wachspress coordinates for the convex polygon defined above.</span></div><div class="line">    Wachspress_coordinates wachspress_coordinates(vertices.begin(), vertices.end());</div><div class="line"></div><div class="line">    <span class="comment">// Print some information about the polygon and coordinates.</span></div><div class="line">    wachspress_coordinates.print_information();</div><div class="line">    </div><div class="line">    <span class="comment">// Compute Wachspress coordinates for all the randomly defined points.</span></div><div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Computed Wachspress coordinates: "</span> &lt;&lt; endl &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_points; ++i) {</div><div class="line">        <span class="comment">// Compute coordinates.</span></div><div class="line">        Scalar_vector coordinates;</div><div class="line">        coordinates.reserve(number_of_vertices);</div><div class="line">        wachspress_coordinates(points[i], std::back_inserter(coordinates));</div><div class="line"></div><div class="line">        <span class="comment">// Output the computed coordinates.</span></div><div class="line">        cout &lt;&lt; <span class="stringliteral">"Point "</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; endl;</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; int(number_of_vertices); ++j)  cout &lt;&lt; <span class="stringliteral">"Coordinate "</span> &lt;&lt; j + 1 &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; coordinates[j] &lt;&lt; <span class="stringliteral">"; "</span> &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="dh_example"></a>
Discrete Harmonic Coordinates</h2>
<p>In this example we compute discrete harmonic coordinates for a set of green (interior), red (boundary), and blue (exterior) points with respect to a unit square. We also show how to specify the location of a query point using additional function parameters. The used kernel is exact, and we use an output container of the type <a href="http://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a>. Since all the points are symmetric, it is easy to debug the correctness of the obtained coordinate values. The output iterator is <a href="http://en.cppreference.com/w/cpp/iterator/back_insert_iterator"><code>std::back_insert_iterator</code></a>.</p>
<p><a class="anchor" id="dh_coord_example"></a><a class="anchor" id="fig__dh__example"></a></p><div class="image">
<img src="discrete_harmonic_coordinates_example.png" alt="discrete_harmonic_coordinates_example.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__dh__example">Figure 88.3</a> Example's point pattern.  </div>  <br />

<p><br />
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2Discrete_harmonic_coordinates_example_8cpp-example.html">Barycentric_coordinates_2/Discrete_harmonic_coordinates_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Discrete_harmonic_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Generalized_barycentric_coordinates_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Some convenient typedefs.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> Kernel;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>      Scalar;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Scalar&gt; Scalar_vector;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt;  Point_vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::back_insert_iterator&lt;Scalar_vector&gt; Vector_insert_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::optional&lt;Vector_insert_iterator&gt; Output_type;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Discrete__harmonic__2.html">CGAL::Barycentric_coordinates::Discrete_harmonic_2&lt;Kernel&gt;</a> Discrete_harmonic;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2.html">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2&lt;Discrete_harmonic, Kernel&gt;</a> Discrete_harmonic_coordinates;</div><div class="line"></div><div class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::string;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// Construct a unit square.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_vertices = 4;</div><div class="line">    Point_vector vertices(number_of_vertices);</div><div class="line">    </div><div class="line">    vertices[0] = Point(0, 0); vertices[1] = Point(1, 0); vertices[2] = Point(1, 1); vertices[3] = Point(0, 1);</div><div class="line"></div><div class="line">    <span class="comment">// Create an std::vector to store coordinates.</span></div><div class="line">    Scalar_vector coordinates;</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate the class with discrete harmonic coordinates for the unit square defined above.</span></div><div class="line">    Discrete_harmonic_coordinates discrete_harmonic_coordinates(vertices.begin(), vertices.end());</div><div class="line"></div><div class="line">    <span class="comment">// Print some information about the polygon and coordinates.</span></div><div class="line">    discrete_harmonic_coordinates.print_information();</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate the center point of the unit square.</span></div><div class="line">    <span class="keyword">const</span> Point center(Scalar(1)/Scalar(2), Scalar(1)/Scalar(2));</div><div class="line"></div><div class="line">    <span class="comment">// Compute discrete harmonic coordinates for the center point.</span></div><div class="line">    <span class="comment">// Use the parameter query_point_location = CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE.</span></div><div class="line">    Output_type result = discrete_harmonic_coordinates(center, std::back_inserter(coordinates), <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331ae39bd08a2cdcb80b675b80d816742e6c">CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate other 4 interior points.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_interior_points = 4;</div><div class="line">    <span class="keyword">const</span> Point interior_points[number_of_interior_points] = { Point(Scalar(1)/Scalar(5), Scalar(1)/Scalar(5))  ,</div><div class="line">                                                               Point(Scalar(4)/Scalar(5), Scalar(1)/Scalar(5))  ,</div><div class="line">                                                               Point(Scalar(4)/Scalar(5), Scalar(4)/Scalar(5))  ,</div><div class="line">                                                               Point(Scalar(1)/Scalar(5), Scalar(4)/Scalar(5)) };</div><div class="line"></div><div class="line">    <span class="comment">// Compute discrete harmonic coordinates for these points and store them at the same vector "coordinates" as before.</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_interior_points; ++i)</div><div class="line">        result = discrete_harmonic_coordinates(interior_points[i], std::back_inserter(coordinates), <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331ae39bd08a2cdcb80b675b80d816742e6c">CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate 2 boundary points on the second and last edges.</span></div><div class="line">    <span class="keyword">const</span> Point second_edge(1, Scalar(4)/Scalar(5));</div><div class="line">    <span class="keyword">const</span> Point   last_edge(0, Scalar(4)/Scalar(5));</div><div class="line"></div><div class="line">    <span class="comment">// Compute discrete harmonic coordinates for these 2 points.</span></div><div class="line">    <span class="comment">// Use the parameter query_point_location = CGAL::Barycentric_coordinates::ON_BOUNDARY.</span></div><div class="line">    result = discrete_harmonic_coordinates(second_edge, std::back_inserter(coordinates), <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331a3ec95e5787c2784177ee121601e54cda">CGAL::Barycentric_coordinates::ON_BOUNDARY</a>);</div><div class="line">    result = discrete_harmonic_coordinates(last_edge  , std::back_inserter(coordinates), <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331a3ec95e5787c2784177ee121601e54cda">CGAL::Barycentric_coordinates::ON_BOUNDARY</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate 2 other boundary points on the first and third edges.</span></div><div class="line">    <span class="keyword">const</span> Point first_edge(Scalar(1)/Scalar(2), 0);</div><div class="line">    <span class="keyword">const</span> Point third_edge(Scalar(1)/Scalar(2), 1);</div><div class="line"></div><div class="line">    <span class="comment">// Compute discrete harmonic coordinates using index of an appropriate edge.</span></div><div class="line">    <span class="comment">// Do not forget that index counting starts from zero.</span></div><div class="line">    result = discrete_harmonic_coordinates.compute_on_edge(first_edge, 0, std::back_inserter(coordinates));</div><div class="line">    result = discrete_harmonic_coordinates.compute_on_edge(third_edge, 2, std::back_inserter(coordinates));</div><div class="line"></div><div class="line">    <span class="comment">// Compute discrete harmonic coordinates for the points at the first and third vertex of the unit square.</span></div><div class="line">    result = discrete_harmonic_coordinates.compute_on_vertex(0, std::back_inserter(coordinates));</div><div class="line">    result = discrete_harmonic_coordinates.compute_on_vertex(2, std::back_inserter(coordinates));</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate points at the second and fourth vertex of the unit square.</span></div><div class="line">    <span class="keyword">const</span> Point second_vertex(1, 0);</div><div class="line">    <span class="keyword">const</span> Point fourth_vertex(0, 1);</div><div class="line"></div><div class="line">    <span class="comment">// Compute discrete harmonic coordinates for these points.</span></div><div class="line">    <span class="comment">// Use the parameter query_point_location = CGAL::Barycentric_coordinates::ON_VERTEX.</span></div><div class="line">    result = discrete_harmonic_coordinates(second_vertex, std::back_inserter(coordinates), <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331a17f3ca7a9b64a6aa68a50cbc71736588">CGAL::Barycentric_coordinates::ON_VERTEX</a>);</div><div class="line">    result = discrete_harmonic_coordinates(fourth_vertex, std::back_inserter(coordinates), <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331a17f3ca7a9b64a6aa68a50cbc71736588">CGAL::Barycentric_coordinates::ON_VERTEX</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate 2 points outside the unit square - one from the left and one from the right.</span></div><div class="line">    <span class="keyword">const</span> Point left_most(Scalar(-1)/Scalar(2), Scalar(1)/Scalar(2));</div><div class="line">    <span class="keyword">const</span> Point right_most(Scalar(3)/Scalar(2), Scalar(1)/Scalar(2));</div><div class="line"></div><div class="line">    <span class="comment">// Compute discrete harmonic coordinates for these 2 points.</span></div><div class="line">    <span class="comment">// Use the parameter query_point_location = CGAL::Barycentric_coordinates::ON_UNBOUNDED_SIDE.</span></div><div class="line">    result = discrete_harmonic_coordinates(left_most , std::back_inserter(coordinates), <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331aa70930d8955740f21091d1353b2dae28">CGAL::Barycentric_coordinates::ON_UNBOUNDED_SIDE</a>);</div><div class="line">    result = discrete_harmonic_coordinates(right_most, std::back_inserter(coordinates), <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331aa70930d8955740f21091d1353b2dae28">CGAL::Barycentric_coordinates::ON_UNBOUNDED_SIDE</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Output the computed coordinate values.</span></div><div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Exact discrete harmonic coordinates for all the defined points: "</span> &lt;&lt; endl &lt;&lt; endl;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_query_points = coordinates.size(); </div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> index = 0; index &lt; int(number_of_query_points); ++index) {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">"Coordinate "</span> &lt;&lt; index % number_of_vertices + 1 &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; coordinates[index] &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">        <span class="keywordflow">if</span>((index +  1) %      number_of_vertices  == 0) cout &lt;&lt; endl;</div><div class="line">        <span class="keywordflow">if</span>((index + 13) % (4 * number_of_vertices) == 0) cout &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Return status of the last computation.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">string</span> status = (result ? <span class="stringliteral">"SUCCESS."</span> : <span class="stringliteral">"FAILURE."</span>);</div><div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Status of the last computation: "</span> &lt;&lt; status &lt;&lt; endl &lt;&lt; endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="mv_example"></a>
Mean Value Coordinates</h2>
<p>This is an example that shows how to compute mean value coordinates for a set of green points in a star-shaped polygon. We note that this type of coordinates is well-defined for such a concave polygon while Wachspress and discrete harmonic coordinates are not. However, it may give negative coordinate values for points outside <a href="https://en.wikipedia.org/wiki/Star-shaped_polygon">the polygon's kernel</a> (shown in red). We use an inexact data type, an output container of the type <a href="http://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a>, and an output iterator of the type <a href="http://en.cppreference.com/w/cpp/iterator/back_insert_iterator">std::back_insert_iterator</a> to compute, access, and store the resulting coordinate values. We also show how to choose different algorithms to compute generalized barycentric coordinates (one is more precise while the other is faster).</p>
<p><a class="anchor" id="mv_coord_example"></a><a class="anchor" id="fig__mv__example"></a></p><div class="image">
<img src="mean_value_coordinates_example.png" alt="mean_value_coordinates_example.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__mv__example">Figure 88.4</a> Example's point pattern.  </div>  <br />

<p><br />
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2Mean_value_coordinates_example_8cpp-example.html">Barycentric_coordinates_2/Mean_value_coordinates_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Mean_value_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Generalized_barycentric_coordinates_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Some convenient typedefs.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>      Scalar;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Scalar&gt; Scalar_vector;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt;  Point_vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::back_insert_iterator&lt;Scalar_vector&gt; Vector_insert_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::optional&lt;Vector_insert_iterator&gt; Output_type;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__2.html">CGAL::Barycentric_coordinates::Mean_value_2&lt;Kernel&gt;</a> Mean_value;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2.html">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2&lt;Mean_value, Kernel&gt;</a> Mean_value_coordinates;</div><div class="line"></div><div class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::string;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{    </div><div class="line">    <span class="comment">// Construct a star-shaped polygon.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_vertices = 10;</div><div class="line">    Point_vector vertices(number_of_vertices);</div><div class="line">    </div><div class="line">    vertices[0] = Point(0.0, 0.0); vertices[1] = Point(0.1, -0.8); vertices[2] = Point(0.3, 0.0); vertices[3] = Point(0.6, -0.5); vertices[4]  = Point(0.6 , 0.1);</div><div class="line">    vertices[5] = Point(1.1, 0.6); vertices[6] = Point(0.3,  0.2); vertices[7] = Point(0.1, 0.8); vertices[8] = Point(0.1,  0.2); vertices[9] = Point(-0.7, 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// Create an std::vector to store coordinates.</span></div><div class="line">    Scalar_vector coordinates;</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate the class with mean value coordinates for the polygon defined above.</span></div><div class="line">    Mean_value_coordinates mean_value_coordinates(vertices.begin(), vertices.end());</div><div class="line"></div><div class="line">    <span class="comment">// Print some information about the polygon and coordinates.</span></div><div class="line">    mean_value_coordinates.print_information();</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate some interior points in the polygon.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_interior_points = 8;</div><div class="line">    <span class="keyword">const</span> Point interior_points[] = { Point(0.12, -0.45), Point(0.55, -0.3), Point(0.9 , 0.45),</div><div class="line">                                      Point(0.15,  0.35), Point(-0.4, 0.04), Point(0.11, 0.11),</div><div class="line">                                      Point(0.28,  0.12), <span class="comment">// the only point in the kernel of the star shaped polygon</span></div><div class="line">                                      Point(0.55,  0.11)</div><div class="line">                                    };</div><div class="line"></div><div class="line">    <span class="comment">// Compute mean value coordinates for all the defined interior points.</span></div><div class="line"></div><div class="line">    <span class="comment">// We speed up the computation using the O(n) algorithm called with the parameter CGAL::Barycentric_coordinates::FAST.</span></div><div class="line">    <span class="comment">// The default one is CGAL::Barycentric_coordinates::PRECISE.</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#a5e5682512438422f23d6080edc49c05b">CGAL::Barycentric_coordinates::Type_of_algorithm</a> type_of_algorithm = <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#a5e5682512438422f23d6080edc49c05baa29350a20af70a27cca8f0715055118f">CGAL::Barycentric_coordinates::FAST</a>;</div><div class="line"></div><div class="line">    <span class="comment">// We also speed up the computation by using the parameter query_point_location = CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE.</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331">CGAL::Barycentric_coordinates::Query_point_location</a> query_point_location = <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331ae39bd08a2cdcb80b675b80d816742e6c">CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE</a>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_interior_points; ++i) {</div><div class="line">        <span class="keyword">const</span> Output_type result = mean_value_coordinates(interior_points[i], std::back_inserter(coordinates), query_point_location, type_of_algorithm);</div><div class="line"></div><div class="line">        <span class="comment">// Output the coordinates for each point.</span></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">string</span> status = (result ? <span class="stringliteral">"SUCCESS."</span> : <span class="stringliteral">"FAILURE."</span>);</div><div class="line">        cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"For the point "</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">" status of the computation: "</span> &lt;&lt; status &lt;&lt; endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; number_of_vertices; ++j)</div><div class="line">            cout &lt;&lt; <span class="stringliteral">"Coordinate "</span> &lt;&lt; j + 1 &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; coordinates[i * number_of_vertices + j] &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// If we need only the unnormalized weights for some point (lets take the last one), we can compute them as follows.</span></div><div class="line"></div><div class="line">    <span class="comment">// Instantiate an std::vector to store weights.</span></div><div class="line">    Scalar_vector weights;</div><div class="line"></div><div class="line">    <span class="comment">// Compute mean value weights.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> last_point_index = number_of_interior_points - 1;</div><div class="line">    <span class="keyword">const</span> Output_type result = mean_value_coordinates.compute_weights(interior_points[last_point_index], std::back_inserter(weights));</div><div class="line"></div><div class="line">    <span class="comment">// Compute their sum.</span></div><div class="line">    Scalar mv_denominator = Scalar(0);</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; number_of_vertices; ++j) mv_denominator += weights[j];</div><div class="line"></div><div class="line">    <span class="comment">// Invert this sum.</span></div><div class="line">    <span class="keyword">const</span> Scalar mv_inverted_denominator = Scalar(1) / mv_denominator;</div><div class="line"></div><div class="line">    <span class="comment">// Output the mean value weights.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">string</span> status = (result ? <span class="stringliteral">"SUCCESS."</span> : <span class="stringliteral">"FAILURE."</span>);</div><div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Status of the weights' computation for the point "</span> &lt;&lt; last_point_index + 1 &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; status &lt;&lt; endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; number_of_vertices; ++j)</div><div class="line">        cout &lt;&lt; <span class="stringliteral">"Weight "</span> &lt;&lt; j + 1 &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; weights[j] &lt;&lt; endl;</div><div class="line"></div><div class="line">    <span class="comment">// Now, if we normalize the weights, we recover values of the mean value coordinates for the last point computed earlier.</span></div><div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"After normalization, for the point "</span> &lt;&lt; last_point_index + 1 &lt;&lt; <span class="stringliteral">" mean value coordinates are "</span> &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; number_of_vertices; ++j)</div><div class="line">        cout &lt;&lt; <span class="stringliteral">"Coordinate "</span> &lt;&lt; j + 1 &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; weights[j] * mv_inverted_denominator &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="height_inter_example"></a>
Height Interpolation for Terrain Modeling</h2>
<p>This is an advanced example that shows how to use generalized barycentric coordinates for height interpolation with applications to terrain modelling. It also shows how to use a non-default traits class with our package instead of a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> traits class. Suppose we know the boundary of three-dimensional piece of terrain that can be represented as a polygon with several three-dimensional vertices, where the third dimension gives the corresponding height. The task is to propagate the height from the known sample points on the boundary to the polygon's interior. This gives an approximate estimation of the terrain's surface in this region.</p>
<p><a class="anchor" id="fig__terrain__example"></a></p><div class="image">
<img src="terrain.png" alt="terrain.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__terrain__example">Figure 88.5</a> A 2D polygon with 50 vertices representing a piece of terrain with convex and concave parts. The height is not shown.  </div>  <br />

<p>In this example we project a three-dimensional polygon orthogonally onto the two-dimensional plane using the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3</a></code>, triangulate its interior using the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Mesh_2.tag:../Mesh_2/" href="../Mesh_2/classCGAL_1_1Delaunay__mesher__2.html">CGAL::Delaunay_mesher_2</a></code>, and compute mean value coordinates for all the obtained points with respect to all the polygon's vertices. Finally, we interpolate the height data from the polygon's boundary to its interior using the computed coordinates and the global interpolation function from the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgInterpolation2Summary">2D and Surface Function Interpolation</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2Terrain_height_modeling_8cpp-example.html">Barycentric_coordinates_2/Terrain_height_modeling.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_mesher_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Interpolation_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_traits_xy_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/interpolation_functions.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_mesh_face_base_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_mesh_size_criteria_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Mean_value_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Generalized_barycentric_coordinates_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Some convenient typedefs.</span></div><div class="line"></div><div class="line"><span class="comment">// General.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</a>                Projection;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Projection::FT      Scalar;</div><div class="line"><span class="keyword">typedef</span> Projection::Point_2 Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Scalar&gt; Scalar_vector;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt;  Point_vector;</div><div class="line"></div><div class="line"><span class="comment">// Coordinates related.</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__2.html">CGAL::Barycentric_coordinates::Mean_value_2&lt;Projection&gt;</a>                                      Mean_value;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2.html">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2&lt;Mean_value, Projection&gt;</a> Mean_value_coordinates;</div><div class="line"></div><div class="line"><span class="comment">// Triangulation related.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Mesh_2.tag:../Mesh_2/" href="../Mesh_2/classCGAL_1_1Delaunay__mesh__face__base__2.html">CGAL::Delaunay_mesh_face_base_2&lt;Projection&gt;</a>                  Face_base;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__2.html">CGAL::Triangulation_vertex_base_2&lt;Projection&gt;</a>                Vertex_base;</div><div class="line"><span class="keyword">typedef</span> CGAL::Triangulation_data_structure_2&lt;Vertex_base, Face_base&gt; TDS;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;Projection, TDS&gt;</a>  CDT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Mesh_2.tag:../Mesh_2/" href="../Mesh_2/classCGAL_1_1Delaunay__mesh__size__criteria__2.html">CGAL::Delaunay_mesh_size_criteria_2&lt;CDT&gt;</a>                     Criteria;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Mesh_2.tag:../Mesh_2/" href="../Mesh_2/classCGAL_1_1Delaunay__mesher__2.html">CGAL::Delaunay_mesher_2&lt;CDT, Criteria&gt;</a>                       Mesher;</div><div class="line"><span class="keyword">typedef</span> CDT::Finite_vertices_iterator                                Vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> CDT::Vertex_handle                                           Vertex_handle;</div><div class="line"></div><div class="line"><span class="comment">// Interpolation related.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Interpolation.tag:../Interpolation/" href="../Interpolation/classCGAL_1_1Interpolation__traits__2.html">CGAL::Interpolation_traits_2&lt;Projection&gt;</a>                             Interpolation_traits;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Interpolation.tag:../Interpolation/" href="../Interpolation/structCGAL_1_1Data__access.html">CGAL::Data_access&lt; std::map&lt;Point, Scalar, Projection::Less_xy_2 &gt;</a> &gt; Value_access;</div><div class="line"></div><div class="line"><span class="comment">// STD.</span></div><div class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::string;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// Construct a polygon bounding a piece of three-dimensional terrain.</span></div><div class="line">    <span class="comment">// Note that z-coordinate of each vertex represents the height function.</span></div><div class="line">    <span class="comment">// Projection in 2D is done automatically by the Projection traits class.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_vertices = 50;</div><div class="line">    Point_vector vertices(number_of_vertices);</div><div class="line"></div><div class="line">    vertices[0]  = Point(0.03, 0.05, 0.000); vertices[1]  = Point(0.07, 0.04, 10.00); vertices[2]  = Point(0.10, 0.04, 20.00);</div><div class="line">    vertices[3]  = Point(0.14, 0.04, 30.00); vertices[4]  = Point(0.17, 0.07, 40.00); vertices[5]  = Point(0.19, 0.09, 50.00);</div><div class="line">    vertices[6]  = Point(0.22, 0.11, 60.00); vertices[7]  = Point(0.25, 0.11, 70.00); vertices[8]  = Point(0.27, 0.10, 80.00);</div><div class="line">    vertices[9]  = Point(0.30, 0.07, 90.00); vertices[10] = Point(0.31, 0.04, 100.0); vertices[11] = Point(0.34, 0.03, 110.0);</div><div class="line">    vertices[12] = Point(0.37, 0.02, 120.0); vertices[13] = Point(0.40, 0.03, 130.0); vertices[14] = Point(0.42, 0.04, 140.0);</div><div class="line">    vertices[15] = Point(0.44, 0.07, 150.0); vertices[16] = Point(0.45, 0.10, 160.0); vertices[17] = Point(0.46, 0.13, 170.0);</div><div class="line">    vertices[18] = Point(0.46, 0.19, 180.0); vertices[19] = Point(0.47, 0.26, 190.0); vertices[20] = Point(0.47, 0.31, 200.0);</div><div class="line">    vertices[21] = Point(0.47, 0.35, 210.0); vertices[22] = Point(0.45, 0.37, 220.0); vertices[23] = Point(0.41, 0.38, 230.0);</div><div class="line">    vertices[24] = Point(0.38, 0.37, 240.0); vertices[25] = Point(0.35, 0.36, 250.0); vertices[26] = Point(0.32, 0.35, 260.0);</div><div class="line">    vertices[27] = Point(0.30, 0.37, 270.0); vertices[28] = Point(0.28, 0.39, 280.0); vertices[29] = Point(0.25, 0.40, 290.0);</div><div class="line">    vertices[30] = Point(0.23, 0.39, 300.0); vertices[31] = Point(0.21, 0.37, 310.0); vertices[32] = Point(0.21, 0.34, 320.0);</div><div class="line">    vertices[33] = Point(0.23, 0.32, 330.0); vertices[34] = Point(0.24, 0.29, 340.0); vertices[35] = Point(0.27, 0.24, 350.0);</div><div class="line">    vertices[36] = Point(0.29, 0.21, 360.0); vertices[37] = Point(0.29, 0.18, 370.0); vertices[38] = Point(0.26, 0.16, 380.0);</div><div class="line">    vertices[39] = Point(0.24, 0.17, 390.0); vertices[40] = Point(0.23, 0.19, 400.0); vertices[41] = Point(0.24, 0.22, 410.0);</div><div class="line">    vertices[42] = Point(0.24, 0.25, 420.0); vertices[43] = Point(0.21, 0.26, 430.0); vertices[44] = Point(0.17, 0.26, 440.0);</div><div class="line">    vertices[45] = Point(0.12, 0.24, 450.0); vertices[46] = Point(0.07, 0.20, 460.0); vertices[47] = Point(0.03, 0.15, 470.0);</div><div class="line">    vertices[48] = Point(0.01, 0.10, 480.0); vertices[49] = Point(0.02, 0.07, 490.0);</div><div class="line"></div><div class="line">    <span class="comment">// Mesh this polygon.</span></div><div class="line"></div><div class="line">    <span class="comment">// Create a constrained Delaunay triangulation.  </span></div><div class="line">    CDT cdt;</div><div class="line"></div><div class="line">    std::vector&lt;Vertex_handle&gt; vertex_handle(number_of_vertices);</div><div class="line"></div><div class="line">    <span class="comment">// Insert vertices of the polygon as our initial point set.</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_vertices; ++i) vertex_handle[i] = cdt.insert(vertices[i]);</div><div class="line"></div><div class="line">    <span class="comment">// Insert constraints - edges of the polygon - in order to mesh only the polygon's interior.</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_vertices; ++i) cdt.insert_constraint(vertex_handle[i], vertex_handle[(i + 1) % number_of_vertices]);</div><div class="line"></div><div class="line">    Mesher mesher(cdt);</div><div class="line"></div><div class="line">    <span class="comment">// Set a criteria on how to mesh.</span></div><div class="line">    mesher.set_criteria(Criteria(0.01, 0.01));</div><div class="line"></div><div class="line">    <span class="comment">// Mesh the polygon.</span></div><div class="line">    mesher.refine_mesh();</div><div class="line"></div><div class="line">    <span class="comment">// Compute mean value coordinates and use them to interpolate data from the polygon's boundary to its interior.</span></div><div class="line"></div><div class="line">    <span class="comment">// Associate each point with the corresponding function value and coordinates.</span></div><div class="line">    std::map&lt;Point, Scalar, Projection::Less_xy_2&gt; point_function_value;</div><div class="line">    std::vector&lt; std::pair&lt;Point, Scalar&gt; &gt;        point_coordinates(number_of_vertices);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_vertices; ++i)</div><div class="line">            point_function_value.insert(std::make_pair(vertices[i], vertices[i].z()));</div><div class="line"></div><div class="line">    <span class="comment">// Create an instance of the class with mean value coordinates.</span></div><div class="line">    Mean_value_coordinates mean_value_coordinates(vertices.begin(), vertices.end());</div><div class="line"></div><div class="line">    <span class="comment">// Store all new interior points with interpolated data here.</span></div><div class="line">    std::vector&lt;Point&gt; points(cdt.number_of_vertices());</div><div class="line"></div><div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Result of the height interpolation: "</span> &lt;&lt; endl &lt;&lt; endl;</div><div class="line"></div><div class="line">    <span class="comment">// Compute coordinates and interpolate the boundary data to the polygon's interior.</span></div><div class="line">    <span class="keywordtype">int</span> index = 0;</div><div class="line">    <span class="keywordflow">for</span>(Vertex_iterator vertex_iterator = cdt.finite_vertices_begin(); vertex_iterator != cdt.finite_vertices_end(); ++vertex_iterator) {</div><div class="line">        Scalar_vector coordinates;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> Point &amp;point = vertex_iterator-&gt;point();</div><div class="line">        mean_value_coordinates(point, std::back_inserter(coordinates));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; number_of_vertices; ++j) </div><div class="line">            point_coordinates[j] = std::make_pair(vertices[j], coordinates[j]);</div><div class="line"></div><div class="line">        Scalar f = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Interpolation.tag:../Interpolation/" href="../Interpolation/group__PkgInterpolation2Interpolation.html#ga2f8a2f88b5b91b9f3db2d5e40bfa1df7">CGAL::linear_interpolation</a>(point_coordinates.begin(), point_coordinates.end(), Scalar(1), Value_access(point_function_value));</div><div class="line">        points[index] = Point(point.x(), point.y(), f);</div><div class="line">        cout &lt;&lt; <span class="stringliteral">"The interpolated height with index "</span> &lt;&lt; index &lt;&lt; <span class="stringliteral">" is "</span> &lt;&lt; f &lt;&lt; <span class="stringliteral">";"</span> &lt;&lt; endl;</div><div class="line">        ++index;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>As a result we get a smooth function inside the polygon that approximates the underlying terrain's surface.</p>
<p><a class="anchor" id="fig__terrain__inter__example"></a></p><div class="image">
<img src="terrain_interpolated.png" alt="terrain_interpolated.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__terrain__inter__example">Figure 88.6</a> The interpolated data. The colour bar represents the corresponding height.  </div>  <br />

<h1><a class="anchor" id="gbc_degeneracies"></a>
Degeneracies and Special Cases</h1>
<p><a class="anchor" id="compute_seg_coord"></a></p>
<h2><a class="anchor" id="gbc_deg_segment_coordinates"></a>
Segment Coordinates</h2>
<p>Segment coordinates can be computed exactly if an exact data type is chosen. The segment itself, with respect to which we compute coordinates, must be non-degenerate. If both conditions are satisfied, then the computation never fails. However, to compute coordinates, the user must be sure about the query point being exactly on the line \(L\) supporting the segment. Since in many applications this is not the case, and a query point may lie very close but not exactly on this line, the class is also able to handle this situation.</p>
<p><a class="anchor" id="fig__projection"></a></p><div class="image">
<img src="projection.png" alt="projection.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__projection">Figure 88.7</a> The orthogonal projection \(p'\) of the vector \(p\) (green) onto the vector \(q\) (red).  </div>  <br />

<p>Suppose that some query point \(v\) does not lie exactly on the line \(L\), but is some distance \(d\) away as shown in the figure above. If we want to compute the segment barycentric coordinate \(b_1(v)\) with respect to the vertex \(v_1\), we first find the orthogonal projection \(p'\) of the vector \(p\) onto the vector \(q\) and then normalize it by the length of \(q\). This gives the segment barycentric coordinate \(b_1(v') = b_1(v)\) if \(v\) lies exactly on the line.</p>
<p><b>Warning:</b> do not abuse the feature described above because it does not give correct segment barycentric coordinates for the point \(v\) but rather those for \(v'\). Moreover, segment barycentric coordinates for a point \(v\), which does not lie exactly on the line \(L\), do not exist. But if the non-zero distance \(d\) is due to some numerical instability when computing the location of the point \(v\) or any other problem, which causes the point to be not exactly on the line, the final segment coordinates will be, at least approximately, correct.</p>
<p>With inexact data types, the resulting coordinate values are correct up to the precision of the chosen type.</p>
<h2><a class="anchor" id="gbc_deg_triangular_coordinates"></a>
Triangle Coordinates</h2>
<p>These coordinates can be computed exactly if an exact data type is chosen, for any query point in the plane and with respect to any non-degenerate triangle. No special cases are handled. The computation always gives the correct result. The notion of correctness depends on the precision of the used data type. Note that for exterior points some coordinate values will be negative.</p>
<h2><a class="anchor" id="gbc_deg_wachspress_coordinates"></a>
Wachspress Coordinates</h2>
<p>Wachspress coordinates are well-defined in the closure of any <em>strictly convex polygon</em>. Therefore, for any query point from the polygon's closure with an exact data type, these coordinates are computed exactly and no false result is expected. For inexact data types, the resulting precision of the computation is due to the involved algorithm and chosen data type. In the following paragraph we discuss two available algorithms for computing Wachspress coordinates. One of them is <code><a class="el" href="namespaceCGAL_1_1Barycentric__coordinates.html#a5e5682512438422f23d6080edc49c05ba03442337422ef674615d3a2d148c726f" title="A default slow algorithm, which is as precise as possible. ">CGAL::Barycentric_coordinates::PRECISE</a></code>, the other is <code><a class="el" href="namespaceCGAL_1_1Barycentric__coordinates.html#a5e5682512438422f23d6080edc49c05baa29350a20af70a27cca8f0715055118f" title="A fast algorithm, which is less precise but much faster. ">CGAL::Barycentric_coordinates::FAST</a></code>.</p>
<p><a class="anchor" id="wp_polygon"></a><a class="anchor" id="fig__wp__notations"></a></p><div class="image">
<img src="wp_notations.png" alt="wp_notations.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__wp__notations">Figure 88.8</a> Notation for Wachspress coordinates.  </div>  <br />

<p>To compute Wachspress weights, we follow <a class="el" href="citelist.html#CITEREF_cgal:bc:fhk-gcbcocp-06">[2]</a> and use the formula</p>
<center> \(w_i = \frac{C_i}{A_{i-1}A_i}\)</center><p>with \(i = 1\dots n\) where \(n\) is the number of the polygon's vertices. In order to compute the coordinates, we normalize these weights,</p>
<center> \(b_i = \frac{w_i}{W^{wp}}\qquad\) with \(\qquad W^{wp} = \sum_{j=1}^n w_j.\)</center><p>This formula becomes unstable when approaching the boundary of the polygon ( \(\approx 1.0e-10\) and closer). To fix the problem, we modify the weights \(w_i\) as</p>
<center> \(\bar{w}_i = C_i\prod_{j\not=i-1,i} A_j\).</center><p>After the normalization as above, this gives us the precise algorithm to compute Wachspress coordinates but with \(O(n^2)\) performance only. The fast \(O(n)\) algorithm uses the standard weights \(w_i\). Note that mathematically this modification does not change the coordinates.</p>
<p>It is known that for strictly convex polygons the denominator's zero set of the Wachspress coordinates ( \(W^{wp} = 0~\)) is a curve, which (in many cases) lies quite far away from the polygon. Speaking precisely, it interpolates the intersection points of the continuations of the polygon's edges. Therefore, the computation of Wachspress coordinates outside the polygon is possible only at points that do not belong to this curve.</p>
<p><a class="anchor" id="fig__zero__set"></a></p><div class="image">
<img src="zero_set.png" alt="zero_set.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__zero__set">Figure 88.9</a> Zero set (red) of the Wachspress coordinates' denominator \(W^{wp}\) for a non-regular hexagon.  </div>  <br />

<p><b>Warning:</b> we do not recommend to use Wachspress coordinates for exterior points!</p>
<h2><a class="anchor" id="gbc_deg_discrete_harmonic_coordinates"></a>
Discrete Harmonic Coordinates</h2>
<p>Discrete harmonic coordinates have the same requirements as Wachspress coordinates. They are well-defined in the closure of any <em>strictly convex polygon</em> and, if an exact data type is chosen, they are computed exactly. But, unlike Wachspress basis functions, these coordinates are not necessarily positive. In particular, the weight \(w_i\) is positive if and only if \(\alpha+\beta &lt; \pi\) (see the figure below for notation). For inexact data types, the precision of the computation is due to the involved algorithm and chosen data type. Again, we describe two algorithms to compute the coordinates: one is precise and one is fast.</p>
<p><a class="anchor" id="dh_polygon"></a><a class="anchor" id="fig__dh__notations"></a></p><div class="image">
<img src="dh_notations.png" alt="dh_notations.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__dh__notations">Figure 88.10</a> Notation for discrete harmonic coordinates.  </div>  <br />

<p>To compute discrete harmonic weights, we follow <a class="el" href="citelist.html#CITEREF_cgal:bc:fhk-gcbcocp-06">[2]</a> and use the formula</p>
<center> \(w_i = \frac{r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i}{A_{i-1}A_i}\)</center><p>with \(i = 1\dots n\) where \(n\) is the number of the polygon's vertices. In order to compute the coordinates, we normalize these weights,</p>
<center> \(b_i = \frac{w_i}{W^{dh}}\qquad\) with \(\qquad W^{dh} = \sum_{j=1}^n w_j.\)</center><p>This formula becomes unstable when approaching the boundary of the polygon ( \(\approx 1.0e-10\) and closer). To fix the problem, similarly to the previous subsection, we modify the weights \(w_i\) as</p>
<center> \(\bar{w}_i = (r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i)\prod_{j\not=i-1,i} A_j\).</center><p>After the normalization as above, this gives the precise algorithm to compute discrete harmonic coordinates but with \(O(n^2)\) performance only. The fast \(O(n)\) algorithm uses the standard weights \(w_i\). Again, mathematically this modification does not change the coordinates.</p>
<p><b>Warning:</b> as for Wachspress coordinates, we do not recommend to use discrete harmonic coordinates for exterior points because the curve \(W^{dh} = 0\) may have several components, and one of them interpolates the polygon's vertices. However, if you are sure that the query point does not belong to this curve, you can compute the coordinates as shown in <a class="el" href="index.html#dh_example">this example</a>.</p>
<h2><a class="anchor" id="gbc_deg_mean_value_coordinates"></a>
Mean Value Coordinates</h2>
<p>Unlike the previous coordinates, mean value coordinates cannot be computed exactly due to an inevitable square root operation. Although, if an exact data type is used, the default precision of the computation depends only on two <span style="font-variant: small-caps;">CGAL</span> functions: <code>CGAL::to_double()</code> and <code>CGAL::sqrt()</code>. On the other hand, mean value coordinates are well-defined everywhere in the plane for any simple polygon. In addition, if your traits class provides a more precise version of the square root function, the final precision of the computation with exact data types will depend only on the precision of that function.</p>
<p><a class="anchor" id="mv_polygon"></a><a class="anchor" id="fig__mv__notations"></a></p><div class="image">
<img src="mv_notations.png" alt="mv_notations.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__mv__notations">Figure 88.11</a> Notation for mean value coordinates.  </div>  <br />

<p>For these coordinates we also have two algorithms: one is precise and one is fast. The first one works everywhere in the plane, and the precision of the computation depends only on the chosen data type, including the remarks above. This algorithm is based on the following weight formula from <a class="el" href="citelist.html#CITEREF_cgal:bc:f-wmvc-14">[4]</a></p>
<center> \(w_i = \sigma_i\bar{w}_i\qquad\) with \(\qquad\bar{w}_i = (r_{i-1}r_{i+1}-d_{i-1}d_{i+1})^{1/2}\prod_{j\not= i-1,i}(r_jr_{j+1} + d_jd_{j+1})^{1/2}\qquad\) where \(\qquad r_i = \|d_i\|.\)</center><p>Since \(\bar{w}_i\) is always positive, we have to append to it the proper sign \(\sigma_i\) of the signed mean value weight, which can be found efficiently (see the figures below). Basically, this weight is always positive to the left of the red piecewise linear curve, and it is negative to the right of this curve, moving in anticlockwise direction.</p>
<p><a class="anchor" id="fig__mv__weight__signs"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="mv_weight_signs_convex.png" alt="mv_weight_signs_convex.png" />
</div>
   </td><td><div class="image">
<img src="mv_weight_signs_concave.png" alt="mv_weight_signs_concave.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__mv__weight__signs">Figure 88.12</a> Signs of the mean value weight \(w_i\) depending on the region with respect to a convex polygon \(P\) and a concave polygon \(P'\).  </div>  <br />

<p>After the normalization of these weights as before</p>
<center> \(b_i = \frac{w_i}{W^{mv}}\qquad\) with \(\qquad W^{mv} = \sum_{j=1}^n w_j\)</center><p>we obtain the precise \(O(n^2)\) algorithm. The fast O(n) algorithm computes the weights \(w_i\) using the pseudocode from <a href="http://www.inf.usi.ch/hormann/nsfworkshop/presentations/Hormann.pdf">here</a>. These weights</p>
<center> \(w_i = \frac{t_{i-1} + t_i}{r_i}\qquad\) with \(\qquad t_i = \frac{\text{det}(d_i, d_{i+1})}{r_ir_{i+1} + d_id_{i+1}}\)</center><p>are also normalized. Note that they are unstable if a query point is closer than \(\approx 1.0e-10\) to the polygon's boundary, similarly to Wachspress and discrete harmonic coordinates.</p>
<h1><a class="anchor" id="gbc_performance"></a>
Performance</h1>
<p>Apart from the most important requirement on barycentric coordinates to be as precise as possible, it is very important for them to be as fast as possible to evaluate. These coordinates are used in many applications where they must be computed for millions of points and, thus, the real time usage of coordinates is crucial. When writing the code, we tried to fulfil this important requirement, and in this section we present a few results about the computation times of the implemented coordinates.</p>
<p>The structure of the speed test that we ran for all functions consists of computing coordinate values (or weights) at &gt;= 1 million strictly interior points with respect to some polygon (or triangle, or segment). At each iteration of the loop we create a query point, pass it to the function, and compute all the related coordinates. We run this loop 10 times in a row, and the time presented in the log-log scale plot at the end of the section is the arithmetic mean of all trials.</p>
<p>A typical example of this performance test for triangle coordinates with reduced number of query points can be found below. This example also illustrates how to construct an iterator and pass it to the class. In this example we create an iterator that writes coordinate values for each new query point over coordinate values of the previous point in the fixed-size standard C++ array, so that memory is allocated only once.</p>
<p><br />
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2Triangle_coordinates_speed_test_8cpp-example.html">Barycentric_coordinates_2/Triangle_coordinates_speed_test.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Triangle_coordinates_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Construct an iterator that takes as input the current data type and pointer to the first element in the standard C++ array.</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;</div><div class="line">    <span class="keyword">class </span>overwrite_iterator</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Scalar* pointer;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> overwrite_iterator(Scalar* new_pointer) : pointer(new_pointer) { }</div><div class="line"></div><div class="line">    <span class="comment">// There are only two operations that we need to overload in order to use the class Triangle_coordinates_2.</span></div><div class="line"></div><div class="line">    <span class="comment">// This operation is intended to return the current coordinate value.</span></div><div class="line">    <span class="keyword">inline</span> Scalar&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__Kernel__operator__prod.html#ga8427cff04588dc338b8acf3e1b116dce">operator* </a>() { <span class="keywordflow">return</span> *pointer; }</div><div class="line"></div><div class="line">    <span class="comment">// This operation is intended to increase the index of the coordinate.</span></div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Generator.tag:../Generator/" href="../Generator/group__PkgGenerators.html#gac38f30d4c4e8520612409327d2913c4a">operator++ </a>() { ++pointer; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Some convenient typedefs.</span></div><div class="line"><span class="keyword">typedef</span> CGAL::Real_timer Timer;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>      Scalar;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> overwrite_iterator&lt;Scalar&gt; Overwrite_iterator;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Triangle__coordinates__2.html">CGAL::Barycentric_coordinates::Triangle_coordinates_2&lt;Kernel&gt;</a> Triangle_coordinates;</div><div class="line"></div><div class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::string;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// Number of x and y coordinates together gives the number of points.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_x_coordinates = 100000;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_y_coordinates = 1000;</div><div class="line"></div><div class="line">    <span class="comment">// Number of runs to compute the arithmetic mean of the time.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_runs = 10;</div><div class="line"></div><div class="line">    <span class="comment">// Compute the uniform step size along x and y directions to change coordinates.</span></div><div class="line">    <span class="keyword">const</span> Scalar zero = Scalar(0);</div><div class="line">    <span class="keyword">const</span> Scalar one  = Scalar(1);</div><div class="line">    <span class="keyword">const</span> Scalar two  = Scalar(2);</div><div class="line">    <span class="keyword">const</span> Scalar x_step = one / Scalar(number_of_x_coordinates);</div><div class="line">    <span class="keyword">const</span> Scalar y_step = one / Scalar(number_of_y_coordinates);</div><div class="line"></div><div class="line">    <span class="comment">// Create a right triangle with a slight offset from zero.</span></div><div class="line">    <span class="keyword">const</span> Point  first_vertex(zero - x_step, zero - x_step);</div><div class="line">    <span class="keyword">const</span> Point second_vertex(two  + y_step, zero - x_step);</div><div class="line">    <span class="keyword">const</span> Point  third_vertex(zero - x_step, two  + y_step);</div><div class="line"></div><div class="line">    <span class="comment">// Instantiate the class Triangle_coordinates_2 for the right triangle defined above.</span></div><div class="line">    Triangle_coordinates triangle_coordinates(first_vertex, second_vertex, third_vertex);</div><div class="line"></div><div class="line">    <span class="comment">// Create an instance of the standard C++ array to store coordinates.</span></div><div class="line">    <span class="comment">// It has the fixed size = 3 = number of vertices.</span></div><div class="line">    Scalar coordinates [3] = {0, 0, 0};</div><div class="line"></div><div class="line">    <span class="comment">// Pass pointer to the first element of the array with coordinates in order to overwrite them.</span></div><div class="line">    Overwrite_iterator it( &amp;(coordinates[0]) );</div><div class="line"></div><div class="line">    <span class="comment">// Create a timer.</span></div><div class="line">    Timer time_to_compute;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> time = 0.0;</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_runs; ++i) { <span class="comment">// Number of runs</span></div><div class="line"></div><div class="line">        time_to_compute.start(); <span class="comment">// Start clock</span></div><div class="line">        <span class="keywordflow">for</span>(Scalar x = zero; x &lt;= one; x += x_step) {</div><div class="line">            <span class="keywordflow">for</span>(Scalar y = zero; y &lt;= one; y += y_step)</div><div class="line">                triangle_coordinates(Point(x, y), it); <span class="comment">// Compute 3 coordinate values for each generated point</span></div><div class="line">        }</div><div class="line">        time_to_compute.stop(); <span class="comment">// Stop clock</span></div><div class="line"></div><div class="line">        time += time_to_compute.time(); <span class="comment">// Add time of the current run to the whole time</span></div><div class="line"></div><div class="line">        time_to_compute.reset(); <span class="comment">// Reset time</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Compute the arithmetic mean of all the runs.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mean_time = time / number_of_runs;</div><div class="line"></div><div class="line">    <span class="comment">// Output the resulting time.</span></div><div class="line">    cout.precision(10);</div><div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"CPU time to compute triangle coordinates for "</span></div><div class="line">         &lt;&lt; number_of_x_coordinates * number_of_y_coordinates &lt;&lt; <span class="stringliteral">" points = "</span> &lt;&lt; mean_time &lt;&lt; <span class="stringliteral">" seconds."</span>;</div><div class="line">    cout &lt;&lt; endl &lt;&lt; endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>The time to compute coordinates depends on many factors such as memory allocation, input kernel, output container, number of points, etc. In our tests we used the most standard C++ and <span style="font-variant: small-caps;">CGAL</span> features with minimum memory allocation. Therefore, the final time presented is the average time that can be expected without deep optimization but still with efficient memory allocation. It also means that it may vary depending on the usage of the package.</p>
<p>For all tests we used a MacBook Pro 2011 with 2 GHz Intel Core i7 processor (2 cores) and 8 GB 1333 MHz DDR3 memory. The installed operating system was OS X 10.9 Maverick. In order to compile the speed test suite, we used the Clang 5.0 64bit compiler. The resulting timings can be found in the figure below.</p>
<p><a class="anchor" id="fig__time"></a></p><div class="image">
<img src="time.png" alt="time.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__time">Figure 88.13</a> Time in seconds to compute \(n\) coordinate values for a polygon with \(n\) vertices at 1 million points with the fast \(O(n)\) algorithms (dashed) and the slow \(0(n^2)\) algorithms (solid) for Wachspress (blue), discrete harmonic (red), and mean value (green) coordinates.  </div>  <br />

<p>From the figure above it is easy to see that the \(O(n^2)\) algorithm is as fast as the \(O(n)\) algorithm if we have a polygon with a small number of vertices. But as the number of vertices is increased, the linear algorithm outperforms the squared one, as expected. One of the reasons for this behaviour is that for a small number of vertices the multiplications for \(n-2\) elements inside the \(O(n^2)\) algorithm with the fast \(O(n)\) algorithms (dashed) and the slow \(O(n^2)\) algorithms (solid) take almost the same time as the corresponding division in the \(O(n)\) algorithm. For a polygon with many vertices this multiplication is much slower.</p>
<h1><a class="anchor" id="gbc_implementation"></a>
Implementation Details</h1>
<p>The generic design of the package was developed in 2013 by Dmitry Anisimov and David Bommes with many useful comments by Kai Hormann and Pierre Alliez. The package consists of 6 classes, 2 enumerations, and one namespace. Appropriate iterators are used to provide an efficient access to data and to pass them to one of the generic algorithms for computing coordinates. Once instantiated for a polygon (triangle, segment), the coordinates can be computed multiple times for different query points with respect to all the vertices of the provided polygon (triangle, segment). All the classes are fully templated and have a simple and similar design. In particular, we follow the same naming convention for all functions. Yet, the number of functions can differ from one class to another.</p>
<p>The implemented algorithms for computing coordinates do not depend on a particular kernel, and all the coordinates can be computed exactly, if an exact kernel is used, apart from mean value coordinates. The latter coordinates involve a square root operation, which results in a slightly worse precision with exact data types due to temporal conversion into a floating point type. The computed coordinates can be stored in an arbitrary container if an appropriate <a href="http://en.cppreference.com/w/cpp/concept/OutputIterator">output iterator</a> is provided.</p>
<p>It is worth noting that the class <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1Segment__coordinates__2.html" title="The class Segment_coordinates_2 implements barycentric coordinates with respect to an arbitrary non-d...">CGAL::Barycentric_coordinates::Segment_coordinates_2</a></code> is used to compute generalized barycentric coordinates along the polygon's boundary. Hence, one can use the trick for segment coordinates from Section <a class="el" href="index.html#gbc_degeneracies">Degeneracies and Special Cases</a> if one is convinced that a point must lie exactly on the polygon's boundary but due to some numerical instabilities it does not.</p>
<p>The package is implemented in a way that later, if needed, other two-dimensional generalized barycentric coordinates can be easily added to this package.</p>
<h1><a class="anchor" id="gbc_theory"></a>
Theory of 2D Generalized Barycentric Coordinates</h1>
<p>In 1827, the German mathematician and theoretical astronomer <a href="http://en.wikipedia.org/wiki/August_Ferdinand_Mbius">August Ferdinand Mbius</a> (17901868) proposed a method <a class="el" href="citelist.html#CITEREF_cgal:bc:m-dbc-27">[7]</a> to find coordinates of a point in the plane with respect to the vertices of a triangle. These coordinates are called <a href="http://mathworld.wolfram.com/BarycentricCoordinates.html">triangle barycentric coordinates</a> (sometimes <a href="http://en.wikipedia.org/wiki/Barycentric_coordinate_system">area coordinates</a>), and they are widely used in a variety of applications. Some of these applications are linear interpolation over a triangle and a triangle inclusion test. The first one is used for so-called <a href="http://en.wikipedia.org/wiki/Shading">shading</a>, and the second one arises in the <a href="http://en.wikipedia.org/wiki/Rasterization">rasterization</a> step when an image in vector graphics format needs to be converted into a raster image.</p>
<p>Triangle barycentric coordinates have many important properties, including <em>constant</em> and <em>linear precision</em>, <em> the Lagrange property</em>, and <em>positivity inside a triangle</em>. These properties make these coordinates a unique tool in many scientific fields. If we restrict triangle coordinates to one of the edges of a triangle and its supporting line, we get barycentric coordinates with respect to a segment and call them <a class="el" href="index.html#compute_seg_coord">segment coordinates</a>.</p>
<p>Let us show a couple of plots for the coordinates described above. To plot segment coordinates, we take a line \(y = 0.4\) and define <a class="el" href="index.html#fig__seg__example">a segment</a> \([v_0, v_1]\) on this line. Then we sample this segment and compute segment coordinates for all the sample points. If we plot the segment coordinate function at all the defined points with respect to the vertex \(v_1\), we get the blue line depicted in the figure below. It grows from zero at the vertex \(v_0\) to one at the vertex \(v_1\).</p>
<p><a class="anchor" id="fig__seg__coord__interp"></a></p><div class="image">
<img src="seg__coord__interp.png" alt="seg__coord__interp.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__seg__coord__interp">Figure 88.14</a> Segment coordinates (blue) for all the segment points (green) with respect to the vertex \(v_1 = (2.0,\ 0.4)\).  </div>  <br />

<p>If we want to plot triangle coordinates, we follow a similar approach. We take <a class="el" href="index.html#fig__tri__example">a triangle</a> \([v_0, v_1, v_2]\) in the plane and sample its interior and boundary with a number of points. Once we have this sampling, we plot one of the triangle coordinate functions (here with respect to the third vertex of the triangle) at all the defined sample points. Likewise, we can plot the coordinate function with respect to the first or second vertex. The resulting function is linear (shown in the figure below) that grows from zero along the first edge \([v_0, v_1]\) to one at the chosen vertex \(v_2\).</p>
<p><a class="anchor" id="fig__tri__coord__interp"></a></p><div class="image">
<img src="tri__coord__interp.png" alt="tri__coord__interp.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__tri__coord__interp">Figure 88.15</a> Triangle coordinates with respect to \(v_2 = (1.0,\ 2.0)\). The colour bar indicates the range of values for the chosen coordinate.  </div>  <br />

<p>Since many applications require to work with more complex planar geometric shapes than segments and triangles, it seems natural to investigate a generalized version of triangle coordinates with respect to arbitrary polygons. The first attempt was taken in 1975 by E. L. Wachspress <a class="el" href="citelist.html#CITEREF_cgal:bc:w-rfeb-75">[9]</a>, and the resulting generalized barycentric coordinates are now called Wachspress coordinates <a class="el" href="citelist.html#CITEREF_cgal:bc:mlbd-gbcip-02">[6]</a>. <a class="el" href="index.html#gbc_deg_wachspress_coordinates">These coordinates</a> are well-defined for arbitrary <em>strictly convex polygons</em> and have all the properties of triangle coordinates <a class="el" href="citelist.html#CITEREF_cgal:bc:fhk-gcbcocp-06">[2]</a>. Unfortunately, they are not well-defined for weakly convex and concave polygons.</p>
<p>Analogously to the previous cases, we want to plot the Wachspress coordinates and see how they look like. Let us choose a <a class="el" href="index.html#wp_polygon">non-regular hexagon</a>, slightly rotate it, and move one of its vertices towards the line through its two adjacent neighbours. We sample the interior and the boundary of this polygon as before and plot the coordinate function with respect to the vertex that we moved at all the sample points. We see that we get a smooth function, which is linear along all edges and grows from zero to one, as the colour bar indicates.</p>
<p><a class="anchor" id="wp_plot"></a><a class="anchor" id="fig__wp__coord__interp"></a></p><div class="image">
<img src="wp__coord__interp.png" alt="wp__coord__interp.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__wp__coord__interp">Figure 88.16</a> The Wachspress coordinate function with respect to the indicated vertex with values from zero to one as the colour bar indicates.  </div>  <br />

<p>Another type of generalized barycentric coordinates goes back to Pinkall and Polthier in 1993 <a class="el" href="citelist.html#CITEREF_cgal:pp-cdmsc-93">[8]</a> and Eck et al. in 1995 <a class="el" href="citelist.html#CITEREF_cgal:bc:eddhls-maam-95">[1]</a> in the context of <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceParameterizationSummary">triangle mesh parameterization</a>. They are called discrete harmonic coordinates. <a class="el" href="index.html#gbc_deg_discrete_harmonic_coordinates">These coordinates</a> are well-defined, similarly to Wachspress coordinates, for arbitrary <em>strictly convex polygons</em> and inherit all the properties of triangle coordinates <em>apart from the positivity inside a polygon</em> because they can take on negative values <a class="el" href="index.html#gbc_deg_discrete_harmonic_coordinates">for some polygons</a>. Another interesting property of these coordinate functions is that they coincide with Wachspress coordinates for any polygon whose vertices lie on a common circle.</p>
<p>To plot discrete harmonic coordinates we take <a class="el" href="index.html#wp_plot">the same polygon</a> as for Wachspress coordinates and plot the coordinate function with respect to the same vertex. Again, we get a smooth function, which is linear along all edges and grows from zero to one. Isolines in the plot show the difference between discrete harmonic and Wachspress coordinates for the chosen polygon and vertex.</p>
<p><a class="anchor" id="dh_plot"></a><a class="anchor" id="fig__dh__coord__interp"></a></p><div class="image">
<img src="dh__coord__interp.png" alt="dh__coord__interp.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__dh__coord__interp">Figure 88.17</a> The discrete harmonic coordinate function with respect to the indicated vertex with values from zero to one as the colour bar indicates.  </div>  <br />

<p>The last type of generalized barycentric coordinates that we discuss are mean value coordinates <a class="el" href="citelist.html#CITEREF_cgal:f-mvc-03">[3]</a> proposed by M. Floater in 2003. Based on the <a href="http://en.wikipedia.org/wiki/Mean_value_theorem">mean value theorem</a>, <a class="el" href="index.html#gbc_deg_mean_value_coordinates">these coordinates</a>, unlike Wachspress and discrete harmonic coordinates, are well-defined for arbitrary <em>simple polygons</em>, inherit all the properties of triangle coordinates for any convex polygon, and <em>lack only the positivity property for general concave polygons</em>. Hormann and Floater prove in <a class="el" href="citelist.html#CITEREF_cgal:bc:hf-mvcapp-06">[5]</a> that these coordinates are positive inside the kernel of a <a href="https://en.wikipedia.org/wiki/Star-shaped_polygon">star-shaped polygon</a>. They are also positive in the closure of any quadrilateral. Like discrete harmonic weights, mean value weights are often used in the context of <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceParameterizationSummary">triangle mesh parameterization.</a></p>
<p>In order to show the particular behaviour of mean value coordinates with an application to concave polygons, we take <a class="el" href="index.html#fig__mv__example">a star-shaped polygon</a> with ten vertices \([v_0, \dots, v_9]\), sample its interior and boundary, and plot the coordinate function with respect to the fourth vertex \(v_3\). As the colour bar indicates, the obtained function grows from a slightly negative value to one at the chosen vertex. It is also smooth inside the polygon and linear along all edges.</p>
<p><a class="anchor" id="fig__mv__coord__interp"></a></p><div class="image">
<img src="mv__coord__interp.png" alt="mv__coord__interp.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__mv__coord__interp">Figure 88.18</a> Mean value coordinates with respect to \(v_3\). The colour bar indicates the range of values for the chosen coordinate function.  </div>  <br />

<p><b>Interesting fact</b>: all the coordinates discussed in this section and implemented in the package come from one and the same family of generalized barycentric coordinates named <em>3-point family of coordinates</em> <a class="el" href="citelist.html#CITEREF_cgal:bc:fhk-gcbcocp-06">[2]</a>.</p>
<h1><a class="anchor" id="gbc_acknowledgments"></a>
Acknowledgments</h1>
<p>The authors wish to thank <a href="http://www.inf.usi.ch/phd/schneider/">Teseo Schneider</a> and <a href="http://search.usi.ch/people/5ae37d3d990b431a02b95b0b606da2e6/Schaerfig-Randolf">Randolf Schaerfig</a> for helpful comments and discussions. We also appreciate the great effort invested in this package by our reviewers <a href="http://geometryfactory.com/who-we-are/">Andreas Fabri and Sbastien Loriot</a>. Finally, to create pictures for this manual, we used two programs: <a href="http://www.geogebra.org/cms/en/">Geogebra</a> and <a href="http://www.mathworks.com/products/matlab/">Matlab</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:54 for CGAL 4.13 - 2D Generalized Barycentric Coordinates by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
