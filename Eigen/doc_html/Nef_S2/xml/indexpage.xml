<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Boolean_Operations_on_Nef_Polygons_Embedded_on_the_Sphere"/></para><para><simplesect kind="authors"><para>Peter Hachenberger and Lutz Kettner</para></simplesect>
</para><sect1 id="index_1Nef_S2Introduction">
<title>Introduction</title>
<para>Nef polyhedra are defined as a subset of the d-dimensional space obtained by a finite number of set complement and set intersection operations on halfspaces.</para><para>Due to the fact that all other binary set operations like union, difference and symmetric difference can be reduced to intersection and complement calculations, Nef polyhedra are also closed under those operations. Also, Nef polyhedra are closed under topological unary set operations. Given a Nef polyhedron one can determine its interior, its boundary, and its closure.</para><para><anchor id="index_1fig__nefsexamples"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="halfspace.png"></image>
 <image type="latex" name="halfspace.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="complex.png"></image>
 <image type="latex" name="complex.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__nefsexamples" kindref="member">fig__nefsexamples</ref> Two spherical Nef polyhedra. A closed halfspace on the left and a complex polyhedron on the right. The different colors indicate selected and unselected regions, lines and points.  <linebreak/>
</para><para>Additionally, a d-dimensional Nef polyhedron has the property, that its boundary is a (d-1)-dimensional Nef polyhedron. This property can be used as a way to represent 3-dimensional Nef polyhedra by means of planar Nef polyhedra. This is done by intersecting the neighborhood of a vertex in a 3D Nef polyhedron with an <formula id="19">$ \epsilon$</formula>-sphere. The result is a planar Nef polyhedron embedded on the sphere.</para><para>The intersection of a halfspace going through the center of the <formula id="19">$ \epsilon$</formula>-sphere, with the <formula id="19">$ \epsilon$</formula>-sphere, results in a halfsphere which is bounded by a great circle. A binary operation of two halfspheres cuts the great circles into great arcs.</para><para><image type="html" name="shalfloopB.png"></image>
 <image type="latex" name="shalfloopB.png"></image>
</para><para>The incidence structure of planar Nef polyhedra can be reused. The items are denoted as <emphasis>svertex</emphasis>, <emphasis>shalfedge</emphasis> and <emphasis>sface</emphasis>, analogous to their counterparts in <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound">Nef_polyhedron_S2</ref></computeroutput>. Additionally, there is the <emphasis>shalfloop</emphasis> representing the great circles. The incidences are illustrated in the figure above.</para></sect1>
<sect1 id="index_1Nef_S2Restricted">
<title>Restricted Spherical Geometry</title>
<para>We introduce geometric objects that are part of the spherical surface <formula id="0">$ S_2$</formula> and operations on them. We define types <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__point" kindref="compound">Nef_polyhedron_S2::Sphere_point</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__circle" kindref="compound">Nef_polyhedron_S2::Sphere_circle</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__segment" kindref="compound">Nef_polyhedron_S2::Sphere_segment</ref></computeroutput>, and <computeroutput>Nef_polyhedron_S2::Sphere_direction</computeroutput>. <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__point" kindref="compound">Nef_polyhedron_S2::Sphere_point</ref></computeroutput>s are points on <formula id="0">$ S_2$</formula>, <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__circle" kindref="compound">Nef_polyhedron_S2::Sphere_circle</ref></computeroutput>s are oriented great circles of <formula id="0">$ S_2$</formula>, <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__segment" kindref="compound">Nef_polyhedron_S2::Sphere_segment</ref></computeroutput>s are oriented parts of <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__circle" kindref="compound">Nef_polyhedron_S2::Sphere_circle</ref></computeroutput> bounded by a pair of <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__point" kindref="compound">Nef_polyhedron_S2::Sphere_point</ref></computeroutput>s, and <computeroutput>Nef_polyhedron_S2::Sphere_direction</computeroutput>s are directions that are part of great circles. (a direction is usually defined to be a vector without length, that floats around in its underlying space and can be used to specify a movement at any point of the underlying space; in our case we use directions only at points that are part of the great circle that underlies also the direction.)</para><para>Note that we have to consider special geometric properties of the objects. For example two points that are part of a great circle define two <computeroutput>Sphere_segment</computeroutput>s, and two arbitrary <computeroutput>Sphere_segment</computeroutput>s can intersect in two points.</para><para>If we restrict our geometric objects to a so-called perfect hemisphere of <formula id="0">$ S_2$</formula>A perfect hemisphere of <formula id="0">$ S_2$</formula> is an open half-sphere plus an open half-circle in the boundary of the open half-sphere plus one endpoint of the half-circle. then the restricted objects behave like in classical geometry, e.g., two points define exactly one segment, two segments intersect in at most one interior point (non-degenerately), or three non-cocircular sphere points can be qualified as being positively or negatively oriented.</para></sect1>
<sect1 id="index_1sectionNef_S2Examples">
<title>Example Programs</title>
<sect2 id="index_1Nef_S2FirstExample">
<title>First Example</title>
<para>In this first example <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound">Nef_polyhedron_S2</ref></computeroutput> is parametrized with a CGAL <ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref> as traits class. The types comprising the spherical geometry can be retrieved from the type <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound">Nef_polyhedron_S2</ref>&lt;Traits&gt;</computeroutput> as is done in the example with the type <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__circle" kindref="compound">Nef_polyhedron_S2::Sphere_circle</ref></computeroutput>. Then three Nef polyhedra are created: <formula id="20">$ N1$</formula> is a halfsphere including the boundary, <formula id="21">$ N2$</formula> is another halfsphere without the boundary, and <formula id="22">$ N3$</formula> is the intersection of <formula id="20">$ N1$</formula> and <formula id="21">$ N2$</formula>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_S2_2nef_s2_simple_8cpp-example" kindref="compound">Nef_S2/nef_s2_simple.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_integer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_S2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_integer<sp/>RT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;RT&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound">CGAL::Nef_polyhedron_S2&lt;Kernel&gt;</ref><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Sphere_circle<sp/>Sphere_circle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N1(Sphere_circle(1,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N2(Sphere_circle(0,1,0),<sp/>Nef_polyhedron::EXCLUDED);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N3<sp/>=<sp/>N1<sp/>*<sp/>N2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Nef_S2ConstructionandCombinations">
<title>Construction and Combinations</title>
<para>Th example shows the different types of constructors: <formula id="20">$ N1$</formula> is the complete sphere, <formula id="21">$ N2$</formula> is a halfsphere which includes the boundary, <formula id="22">$ N3$</formula> is created with the copy constructor, <formula id="23">$ N4$</formula> is created as an arrangement of a set of <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__segment" kindref="compound">Nef_polyhedron_S2::Sphere_segment</ref></computeroutput>s, and <formula id="24">$ N5$</formula> is created as the empty set.</para><para>The example also shows the use of unary set operations, binary operations, and binary predicates: <formula id="22">$ N3$</formula> is defined as the complement of <formula id="21">$ N2$</formula>, <formula id="20">$ N1$</formula> is compared with the union of <formula id="21">$ N2$</formula> and <formula id="22">$ N3$</formula>, <formula id="24">$ N5$</formula> is united with <formula id="21">$ N2$</formula> and then intersected with <formula id="23">$ N4$</formula>. At last, it is tested if <formula id="24">$ N5$</formula> is a subset of <formula id="21">$ N2$</formula> and if <formula id="24">$ N5$</formula> is not equal to <formula id="23">$ N4$</formula>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_S2_2nef_s2_construction_8cpp-example" kindref="compound">Nef_S2/nef_s2_construction.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_integer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_S2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_integer<sp/>RT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;RT&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound">CGAL::Nef_polyhedron_S2&lt;Kernel&gt;</ref><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Sphere_point<sp/>Sphere_point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Sphere_segment<sp/>Sphere_segment;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Sphere_circle<sp/>Sphere_circle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N1(Nef_polyhedron::COMPLETE);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sphere_circle<sp/>c(1,1,1);<sp/></highlight><highlight class="comment">//<sp/>c<sp/>:<sp/>x<sp/>+<sp/>y<sp/>+<sp/>z<sp/>=<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N2(c,<sp/>Nef_polyhedron::INCLUDED);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N3(N2.complement());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N1<sp/>==<sp/>N2.join(N3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sphere_point<sp/><sp/><sp/>p1(1,0,0),<sp/>p2(0,1,0),<sp/>p3(0,0,1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sphere_segment<sp/>s1(p1,p2),<sp/>s2(p2,p3),<sp/>s3(p3,p1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sphere_segment<sp/>triangle[3]<sp/>=<sp/>{<sp/>s1,<sp/>s2,<sp/>s3<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N4(triangle,<sp/>triangle+3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>N5<sp/>+=<sp/>N2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>N5<sp/>=<sp/>N5.intersection(N4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N5<sp/>&lt;=<sp/>N2<sp/>&amp;&amp;<sp/>N5<sp/>!=<sp/>N4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Nef_S2Exploration">
<title>Exploration</title>
<para>By recursively composing binary and unary operations one can end with a very complex rectilinear structure. <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound">Nef_polyhedron_S2</ref></computeroutput> allows read-only exploration of the structure.</para><para>In the following example, a random <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound">Nef_polyhedron_S2</ref> S</computeroutput> created from <computeroutput>n</computeroutput> halfspheres is explored. Each sface is composed of one outer sface cycles and an arbitrary number of inner sfaces cycles. The outer cycle is either an shalfloop or a cycle of shalfedges. An inner cycles additionally can be an isolated vertex. The example shows how to get the entry item <computeroutput>it</computeroutput> to all sface cycles of an sface <computeroutput>sf</computeroutput> and how to find out what type of item it is.</para><para>The macro <computeroutput>CGAL_forall_sface_cycles_of</computeroutput> is equivalent to a for-loop on the range <computeroutput>[sf-&gt;sface_cycles_begin(), sf-&gt;sface_cycles_end())</computeroutput>. An <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a8bf70a1ec332bb0c1af5bea79a51fc72" kindref="member">Nef_polyhedron_S2::SFace_cycle_const_iterator</ref></computeroutput> either represents a <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1ab8c065032149003b2a13676eead440e8" kindref="member">Nef_polyhedron_S2::SVertex_const_handle</ref></computeroutput>, a <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a451791355a3c6f37c518201f868fb481" kindref="member">Nef_polyhedron_S2::SHalfedge_const_handle</ref></computeroutput> or a <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a5e369fac0476252aa4922cd418ec3f11" kindref="member">Nef_polyhedron_S2::SHalfloop_const_handle</ref></computeroutput>. In order to find out which handle type is represented, the functions <computeroutput>Nef_polyhedron_S2::is_svertex()</computeroutput>, <computeroutput>Nef_polyhedron_S2::is_shalfedge()</computeroutput> and <computeroutput>Nef_polyhedron_S2::is_shalfloop()</computeroutput> are provided. Afterwards the iterator can be casted to the proper handle type.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_S2_2nef_s2_exploration_8cpp-example" kindref="compound">Nef_S2/nef_s2_exploration.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_rational.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_S2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_S2/create_random_Nef_S2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_rational<sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;FT&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound">CGAL::Nef_polyhedron_S2&lt;Kernel&gt;</ref><sp/>Nef_polyhedron_S2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1ab8c065032149003b2a13676eead440e8" kindref="member">Nef_polyhedron_S2::SVertex_const_handle</ref><sp/>SVertex_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a451791355a3c6f37c518201f868fb481" kindref="member">Nef_polyhedron_S2::SHalfedge_const_handle</ref><sp/>SHalfedge_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a5e369fac0476252aa4922cd418ec3f11" kindref="member">Nef_polyhedron_S2::SHalfloop_const_handle</ref><sp/>SHalfloop_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a6e922713ff9859c939b90320cdcdd06c" kindref="member">Nef_polyhedron_S2::SFace_const_iterator</ref><sp/>SFace_const_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a8bf70a1ec332bb0c1af5bea79a51fc72" kindref="member">Nef_polyhedron_S2::SFace_cycle_const_iterator</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SFace_cycle_const_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron_S2<sp/>S;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::create_random_Nef_S2(S,5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SFace_const_iterator<sp/>sf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_forall_sfaces(sf,S)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SFace_cycle_const_iterator<sp/>it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;the<sp/>sface<sp/>cycles<sp/>of<sp/>sface<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>start<sp/>with<sp/>an<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_forall_sface_cycles_of(it,sf)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it.is_svertex())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>svertex<sp/>at<sp/>position<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>SVertex_const_handle(it)-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it.is_shalfedge())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>shalfedge<sp/>from<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>SHalfedge_const_handle(it)-&gt;source()-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>to<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>SHalfedge_const_handle(it)-&gt;target()-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it.is_shalfloop())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>shalfloop<sp/>lying<sp/>in<sp/>the<sp/>plane<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>SHalfloop_const_handle(it)-&gt;circle()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;something<sp/>is<sp/>wrong&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Nef_S2PointLocation">
<title>Point Location</title>
<para>Using the <computeroutput>locate</computeroutput> function, it is possible to retrive an item at a certain location on the sphere. In the following example, the item at location <computeroutput>Sphere_point(1,0,0)</computeroutput> in a random <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound">Nef_polyhedron_S2</ref></computeroutput> is retrieved. <computeroutput>locate</computeroutput> returns an instance of type <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1ade3314ff1e537734fecd18250fe35d66" kindref="member">Nef_polyhedron_S2::Object_handle</ref></computeroutput>, which is a container for any handle type. Here, it either a <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1ab8c065032149003b2a13676eead440e8" kindref="member">Nef_polyhedron_S2::SVertex_const_handle</ref></computeroutput>, a <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a451791355a3c6f37c518201f868fb481" kindref="member">Nef_polyhedron_S2::SHalfedge_const_handle</ref></computeroutput>, a <computeroutput>Nef_polyhedron_S2::SHafloop_const_handle</computeroutput> or a <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a54eeaf9cfa515807ca7f78966758a817" kindref="member">Nef_polyhedron_S2::SFace_const_handle</ref></computeroutput>. The function <computeroutput>assign()</computeroutput> performs the cast operation and returns a Boolean which indicates whether the cast was successful or not.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_S2_2nef_s2_point_location_8cpp-example" kindref="compound">Nef_S2/nef_s2_point_location.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_rational.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_S2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_S2/create_random_Nef_S2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_rational<sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;FT&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound">CGAL::Nef_polyhedron_S2&lt;Kernel&gt;</ref><sp/>Nef_polyhedron_S2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1ab8c065032149003b2a13676eead440e8" kindref="member">Nef_polyhedron_S2::SVertex_const_handle</ref><sp/>SVertex_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a451791355a3c6f37c518201f868fb481" kindref="member">Nef_polyhedron_S2::SHalfedge_const_handle</ref><sp/>SHalfedge_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a5e369fac0476252aa4922cd418ec3f11" kindref="member">Nef_polyhedron_S2::SHalfloop_const_handle</ref><sp/>SHalfloop_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a54eeaf9cfa515807ca7f78966758a817" kindref="member">Nef_polyhedron_S2::SFace_const_handle</ref><sp/>SFace_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1ade3314ff1e537734fecd18250fe35d66" kindref="member">Nef_polyhedron_S2::Object_handle</ref><sp/>Object_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron_S2::Sphere_point<sp/>Sphere_point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron_S2<sp/>S;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::create_random_Nef_S2(S,5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SVertex_const_handle<sp/>sv;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SHalfedge_const_handle<sp/>se;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SHalfloop_const_handle<sp/>sl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SFace_const_handle<sp/>sf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Object_handle<sp/>o<sp/>=<sp/>S.locate(Sphere_point(1,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(CGAL::assign(sv,o))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Locating<sp/>svertex&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(CGAL::assign(se,o))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Locating<sp/>shalfedge&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(CGAL::assign(sl,o))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Locating<sp/>shalfloop&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(CGAL::assign(sf,o))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Locating<sp/>sface&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;something<sp/>wrong&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
