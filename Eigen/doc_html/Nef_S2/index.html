<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Nef_S2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Boolean Operations on Nef Polygons Embedded on the Sphere: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Boolean Operations on Nef Polygons Embedded on the Sphere
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Boolean_Operations_on_Nef_Polygons_Embedded_on_the_Sphere"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Peter Hachenberger and Lutz Kettner</dd></dl>
<h1><a class="anchor" id="Nef_S2Introduction"></a>
Introduction</h1>
<p>Nef polyhedra are defined as a subset of the d-dimensional space obtained by a finite number of set complement and set intersection operations on halfspaces.</p>
<p>Due to the fact that all other binary set operations like union, difference and symmetric difference can be reduced to intersection and complement calculations, Nef polyhedra are also closed under those operations. Also, Nef polyhedra are closed under topological unary set operations. Given a Nef polyhedron one can determine its interior, its boundary, and its closure.</p>
<p><a class="anchor" id="fig__nefsexamples"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="halfspace.png" alt="halfspace.png" />
</div>
   </td><td><div class="image">
<img src="complex.png" alt="complex.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__nefsexamples">Figure 18.1</a> Two spherical Nef polyhedra. A closed halfspace on the left and a complex polyhedron on the right. The different colors indicate selected and unselected regions, lines and points.  </div>  <br />

<p>Additionally, a d-dimensional Nef polyhedron has the property, that its boundary is a (d-1)-dimensional Nef polyhedron. This property can be used as a way to represent 3-dimensional Nef polyhedra by means of planar Nef polyhedra. This is done by intersecting the neighborhood of a vertex in a 3D Nef polyhedron with an \( \epsilon\)-sphere. The result is a planar Nef polyhedron embedded on the sphere.</p>
<p>The intersection of a halfspace going through the center of the \( \epsilon\)-sphere, with the \( \epsilon\)-sphere, results in a halfsphere which is bounded by a great circle. A binary operation of two halfspheres cuts the great circles into great arcs.</p>
<div class="image">
<img src="shalfloopB.png" alt="shalfloopB.png" />
</div>
 <p>The incidence structure of planar Nef polyhedra can be reused. The items are denoted as <em>svertex</em>, <em>shalfedge</em> and <em>sface</em>, analogous to their counterparts in <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html" title="An instance of data type Nef_polyhedron_S2&lt;Traits&gt; is a subset of the sphere  that is the result of f...">Nef_polyhedron_S2</a></code>. Additionally, there is the <em>shalfloop</em> representing the great circles. The incidences are illustrated in the figure above.</p>
<h1><a class="anchor" id="Nef_S2Restricted"></a>
Restricted Spherical Geometry</h1>
<p>We introduce geometric objects that are part of the spherical surface \( S_2\) and operations on them. We define types <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__point.html" title="An object p of type Sphere_point&lt;R&gt; is a point on the surface of a unit sphere. ">Nef_polyhedron_S2::Sphere_point</a></code>, <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__circle.html" title="An object c of type Sphere_circle is an oriented great circle on the surface of a unit sphere...">Nef_polyhedron_S2::Sphere_circle</a></code>, <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__segment.html" title="An object s of type Sphere_segment is a segment in the surface of a unit sphere that is part of a gre...">Nef_polyhedron_S2::Sphere_segment</a></code>, and <code>Nef_polyhedron_S2::Sphere_direction</code>. <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__point.html" title="An object p of type Sphere_point&lt;R&gt; is a point on the surface of a unit sphere. ">Nef_polyhedron_S2::Sphere_point</a></code>s are points on \( S_2\), <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__circle.html" title="An object c of type Sphere_circle is an oriented great circle on the surface of a unit sphere...">Nef_polyhedron_S2::Sphere_circle</a></code>s are oriented great circles of \( S_2\), <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__segment.html" title="An object s of type Sphere_segment is a segment in the surface of a unit sphere that is part of a gre...">Nef_polyhedron_S2::Sphere_segment</a></code>s are oriented parts of <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__circle.html" title="An object c of type Sphere_circle is an oriented great circle on the surface of a unit sphere...">Nef_polyhedron_S2::Sphere_circle</a></code> bounded by a pair of <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__point.html" title="An object p of type Sphere_point&lt;R&gt; is a point on the surface of a unit sphere. ">Nef_polyhedron_S2::Sphere_point</a></code>s, and <code>Nef_polyhedron_S2::Sphere_direction</code>s are directions that are part of great circles. (a direction is usually defined to be a vector without length, that floats around in its underlying space and can be used to specify a movement at any point of the underlying space; in our case we use directions only at points that are part of the great circle that underlies also the direction.)</p>
<p>Note that we have to consider special geometric properties of the objects. For example two points that are part of a great circle define two <code>Sphere_segment</code>s, and two arbitrary <code>Sphere_segment</code>s can intersect in two points.</p>
<p>If we restrict our geometric objects to a so-called perfect hemisphere of \( S_2\)<span class="footnote">A perfect hemisphere of \( S_2\) is an open half-sphere plus an open half-circle in the boundary of the open half-sphere plus one endpoint of the half-circle.</span> then the restricted objects behave like in classical geometry, e.g., two points define exactly one segment, two segments intersect in at most one interior point (non-degenerately), or three non-cocircular sphere points can be qualified as being positively or negatively oriented.</p>
<h1><a class="anchor" id="sectionNef_S2Examples"></a>
Example Programs</h1>
<h2><a class="anchor" id="Nef_S2FirstExample"></a>
First Example</h2>
<p>In this first example <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html" title="An instance of data type Nef_polyhedron_S2&lt;Traits&gt; is a subset of the sphere  that is the result of f...">Nef_polyhedron_S2</a></code> is parametrized with a CGAL <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a> as traits class. The types comprising the spherical geometry can be retrieved from the type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html" title="An instance of data type Nef_polyhedron_S2&lt;Traits&gt; is a subset of the sphere  that is the result of f...">Nef_polyhedron_S2</a>&lt;Traits&gt;</code> as is done in the example with the type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__circle.html" title="An object c of type Sphere_circle is an oriented great circle on the surface of a unit sphere...">Nef_polyhedron_S2::Sphere_circle</a></code>. Then three Nef polyhedra are created: \( N1\) is a halfsphere including the boundary, \( N2\) is another halfsphere without the boundary, and \( N3\) is the intersection of \( N1\) and \( N2\).</p>
<p><br />
<b>File</b> <a class="el" href="Nef_S2_2nef_s2_simple_8cpp-example.html">Nef_S2/nef_s2_simple.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_integer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Homogeneous.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Nef_polyhedron_S2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Exact_integer RT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous&lt;RT&gt;</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html">CGAL::Nef_polyhedron_S2&lt;Kernel&gt;</a> Nef_polyhedron;</div><div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Sphere_circle Sphere_circle;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Nef_polyhedron N1(Sphere_circle(1,0,0));</div><div class="line">  Nef_polyhedron N2(Sphere_circle(0,1,0), Nef_polyhedron::EXCLUDED);</div><div class="line">  Nef_polyhedron N3 = N1 * N2;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Nef_S2ConstructionandCombinations"></a>
Construction and Combinations</h2>
<p>Th example shows the different types of constructors: \( N1\) is the complete sphere, \( N2\) is a halfsphere which includes the boundary, \( N3\) is created with the copy constructor, \( N4\) is created as an arrangement of a set of <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2_1_1Sphere__segment.html" title="An object s of type Sphere_segment is a segment in the surface of a unit sphere that is part of a gre...">Nef_polyhedron_S2::Sphere_segment</a></code>s, and \( N5\) is created as the empty set.</p>
<p>The example also shows the use of unary set operations, binary operations, and binary predicates: \( N3\) is defined as the complement of \( N2\), \( N1\) is compared with the union of \( N2\) and \( N3\), \( N5\) is united with \( N2\) and then intersected with \( N4\). At last, it is tested if \( N5\) is a subset of \( N2\) and if \( N5\) is not equal to \( N4\).</p>
<p><br />
<b>File</b> <a class="el" href="Nef_S2_2nef_s2_construction_8cpp-example.html">Nef_S2/nef_s2_construction.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_integer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Homogeneous.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Nef_polyhedron_S2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Exact_integer RT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous&lt;RT&gt;</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html">CGAL::Nef_polyhedron_S2&lt;Kernel&gt;</a> Nef_polyhedron;</div><div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Sphere_point Sphere_point;</div><div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Sphere_segment Sphere_segment;</div><div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Sphere_circle Sphere_circle;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Nef_polyhedron N1(Nef_polyhedron::COMPLETE);</div><div class="line"></div><div class="line">  Sphere_circle c(1,1,1); <span class="comment">// c : x + y + z = 0</span></div><div class="line">  Nef_polyhedron N2(c, Nef_polyhedron::INCLUDED);</div><div class="line">  Nef_polyhedron N3(N2.complement());</div><div class="line">  CGAL_assertion(N1 == N2.join(N3));</div><div class="line"></div><div class="line">  Sphere_point   p1(1,0,0), p2(0,1,0), p3(0,0,1);</div><div class="line">  Sphere_segment s1(p1,p2), s2(p2,p3), s3(p3,p1);</div><div class="line">  Sphere_segment triangle[3] = { s1, s2, s3 };</div><div class="line">  Nef_polyhedron N4(triangle, triangle+3);</div><div class="line">  Nef_polyhedron N5;</div><div class="line">  N5 += N2;</div><div class="line">  N5 = N5.intersection(N4);</div><div class="line">  CGAL_assertion(N5 &lt;= N2 &amp;&amp; N5 != N4);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Nef_S2Exploration"></a>
Exploration</h2>
<p>By recursively composing binary and unary operations one can end with a very complex rectilinear structure. <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html" title="An instance of data type Nef_polyhedron_S2&lt;Traits&gt; is a subset of the sphere  that is the result of f...">Nef_polyhedron_S2</a></code> allows read-only exploration of the structure.</p>
<p>In the following example, a random <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html" title="An instance of data type Nef_polyhedron_S2&lt;Traits&gt; is a subset of the sphere  that is the result of f...">Nef_polyhedron_S2</a> S</code> created from <code>n</code> halfspheres is explored. Each sface is composed of one outer sface cycles and an arbitrary number of inner sfaces cycles. The outer cycle is either an shalfloop or a cycle of shalfedges. An inner cycles additionally can be an isolated vertex. The example shows how to get the entry item <code>it</code> to all sface cycles of an sface <code>sf</code> and how to find out what type of item it is.</p>
<p>The macro <code>CGAL_forall_sface_cycles_of</code> is equivalent to a for-loop on the range <code>[sf-&gt;sface_cycles_begin(), sf-&gt;sface_cycles_end())</code>. An <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html#a8bf70a1ec332bb0c1af5bea79a51fc72" title="iterating all sface cycles of an sface f. ">Nef_polyhedron_S2::SFace_cycle_const_iterator</a></code> either represents a <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html#ab8c065032149003b2a13676eead440e8" title="non-mutable handle to svertex. ">Nef_polyhedron_S2::SVertex_const_handle</a></code>, a <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html#a451791355a3c6f37c518201f868fb481" title="non-mutable handle to shalfedge. ">Nef_polyhedron_S2::SHalfedge_const_handle</a></code> or a <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html#a5e369fac0476252aa4922cd418ec3f11" title="non-mutable handle to shalfloop. ">Nef_polyhedron_S2::SHalfloop_const_handle</a></code>. In order to find out which handle type is represented, the functions <code>Nef_polyhedron_S2::is_svertex()</code>, <code>Nef_polyhedron_S2::is_shalfedge()</code> and <code>Nef_polyhedron_S2::is_shalfloop()</code> are provided. Afterwards the iterator can be casted to the proper handle type.</p>
<p><br />
<b>File</b> <a class="el" href="Nef_S2_2nef_s2_exploration_8cpp-example.html">Nef_S2/nef_s2_exploration.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_rational.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Nef_polyhedron_S2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Nef_S2/create_random_Nef_S2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Exact_rational FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;FT&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html">CGAL::Nef_polyhedron_S2&lt;Kernel&gt;</a> Nef_polyhedron_S2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html#ab8c065032149003b2a13676eead440e8">Nef_polyhedron_S2::SVertex_const_handle</a> SVertex_const_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html#a451791355a3c6f37c518201f868fb481">Nef_polyhedron_S2::SHalfedge_const_handle</a> SHalfedge_const_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html#a5e369fac0476252aa4922cd418ec3f11">Nef_polyhedron_S2::SHalfloop_const_handle</a> SHalfloop_const_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html#a6e922713ff9859c939b90320cdcdd06c">Nef_polyhedron_S2::SFace_const_iterator</a> SFace_const_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html#a8bf70a1ec332bb0c1af5bea79a51fc72">Nef_polyhedron_S2::SFace_cycle_const_iterator</a></div><div class="line">                           SFace_cycle_const_iterator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Nef_polyhedron_S2 S;</div><div class="line">  CGAL::create_random_Nef_S2(S,5);</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> i=0;</div><div class="line">  SFace_const_iterator sf;</div><div class="line">  CGAL_forall_sfaces(sf,S) {</div><div class="line">    SFace_cycle_const_iterator it;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"the sface cycles of sface "</span> &lt;&lt; i++;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" start with an "</span> &lt;&lt; std::endl;</div><div class="line">    CGAL_forall_sface_cycles_of(it,sf) {</div><div class="line">      <span class="keywordflow">if</span> (it.is_svertex()) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"  svertex at position "</span>;</div><div class="line">    std::cout &lt;&lt; SVertex_const_handle(it)-&gt;point() &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (it.is_shalfedge()) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"  shalfedge from "</span>;</div><div class="line">    std::cout &lt;&lt; SHalfedge_const_handle(it)-&gt;source()-&gt;point() &lt;&lt; <span class="stringliteral">" to "</span>;</div><div class="line">    std::cout &lt;&lt; SHalfedge_const_handle(it)-&gt;target()-&gt;point() &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (it.is_shalfloop()) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"  shalfloop lying in the plane "</span>;</div><div class="line">    std::cout &lt;&lt; SHalfloop_const_handle(it)-&gt;circle() &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"something is wrong"</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Nef_S2PointLocation"></a>
Point Location</h2>
<p>Using the <code>locate</code> function, it is possible to retrive an item at a certain location on the sphere. In the following example, the item at location <code>Sphere_point(1,0,0)</code> in a random <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html" title="An instance of data type Nef_polyhedron_S2&lt;Traits&gt; is a subset of the sphere  that is the result of f...">Nef_polyhedron_S2</a></code> is retrieved. <code>locate</code> returns an instance of type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html#ade3314ff1e537734fecd18250fe35d66" title="a generic handle to an object of the underlying plane map. ">Nef_polyhedron_S2::Object_handle</a></code>, which is a container for any handle type. Here, it either a <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html#ab8c065032149003b2a13676eead440e8" title="non-mutable handle to svertex. ">Nef_polyhedron_S2::SVertex_const_handle</a></code>, a <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html#a451791355a3c6f37c518201f868fb481" title="non-mutable handle to shalfedge. ">Nef_polyhedron_S2::SHalfedge_const_handle</a></code>, a <code>Nef_polyhedron_S2::SHafloop_const_handle</code> or a <code><a class="el" href="classCGAL_1_1Nef__polyhedron__S2.html#a54eeaf9cfa515807ca7f78966758a817" title="non-mutable handle to sface. ">Nef_polyhedron_S2::SFace_const_handle</a></code>. The function <code>assign()</code> performs the cast operation and returns a Boolean which indicates whether the cast was successful or not.</p>
<p><br />
<b>File</b> <a class="el" href="Nef_S2_2nef_s2_point_location_8cpp-example.html">Nef_S2/nef_s2_point_location.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_rational.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Nef_polyhedron_S2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Nef_S2/create_random_Nef_S2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Exact_rational FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;FT&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html">CGAL::Nef_polyhedron_S2&lt;Kernel&gt;</a> Nef_polyhedron_S2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html#ab8c065032149003b2a13676eead440e8">Nef_polyhedron_S2::SVertex_const_handle</a> SVertex_const_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html#a451791355a3c6f37c518201f868fb481">Nef_polyhedron_S2::SHalfedge_const_handle</a> SHalfedge_const_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html#a5e369fac0476252aa4922cd418ec3f11">Nef_polyhedron_S2::SHalfloop_const_handle</a> SHalfloop_const_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html#a54eeaf9cfa515807ca7f78966758a817">Nef_polyhedron_S2::SFace_const_handle</a> SFace_const_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__S2.html#ade3314ff1e537734fecd18250fe35d66">Nef_polyhedron_S2::Object_handle</a> Object_handle;</div><div class="line"><span class="keyword">typedef</span> Nef_polyhedron_S2::Sphere_point Sphere_point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Nef_polyhedron_S2 S;</div><div class="line">  CGAL::create_random_Nef_S2(S,5);</div><div class="line"></div><div class="line">  SVertex_const_handle sv;</div><div class="line">  SHalfedge_const_handle se;</div><div class="line">  SHalfloop_const_handle sl;</div><div class="line">  SFace_const_handle sf;</div><div class="line">  Object_handle o = S.locate(Sphere_point(1,0,0));</div><div class="line">  <span class="keywordflow">if</span>(CGAL::assign(sv,o))</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Locating svertex"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(CGAL::assign(se,o))</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Locating shalfedge"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(CGAL::assign(sl,o))</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Locating shalfloop"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(CGAL::assign(sf,o))</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Locating sface"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"something wrong"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:09 for CGAL 4.13 - 2D Boolean Operations on Nef Polygons Embedded on the Sphere by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
