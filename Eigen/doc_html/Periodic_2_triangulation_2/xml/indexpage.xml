<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Periodic_Triangulations"/><anchor id="index_1chapterP2Triangulation2"/>  <simplesect kind="author"><para>Nico Kruithof</para></simplesect>
<image type="html" name="3pts_unique.png"></image>
 <image type="latex" name="3pts_unique.png"></image>
</para><para>The periodic 2D-triangulation class of CGAL is designed to represent the triangulation of a set of points in the two-dimensional flat torus. The triangulation forms a partition of the space it is computed in. It is a simplicial complex, i.e. it contains all incident <formula id="26">$ j$</formula>-simplices ( <formula id="27">$ j&lt;k$</formula>) of any <formula id="28">$ k$</formula>-simplex and two <formula id="28">$ k$</formula>-simplices either do not intersect or share a common <formula id="26">$ j$</formula>-face, <formula id="27">$ j&lt;k$</formula>. The occurring simplices of dimension up to two are called <emphasis>vertex</emphasis>, <emphasis>edge</emphasis> and <emphasis>face</emphasis>, respectively.</para><sect1 id="index_1P2Triangulation2secspace">
<title>The Flat Torus</title>
<para>The 2D Periodic Triangulation package computes triangulations in the space <formula id="5">$ \mathbb T_c^2$</formula>, which is defined as follows: Let <formula id="29">$ c\in\mathbb R\setminus\{0\}$</formula> and <formula id="30">$ G$</formula> be the group <formula id="31">$ (c\cdot\mathbb Z^2, +)$</formula>, where <formula id="32">$ c\cdot\mathbb Z$</formula> denotes the set containing all integer multiples of <formula id="33">$ c$</formula>. The flat torus is the quotient space: <formula id="34">$ \mathbb T_c^2:=\mathbb R^2/G$</formula>. The parameter <formula id="33">$ c$</formula> defines the period.</para><para>The elements of <formula id="5">$ \mathbb T_c^2$</formula> are the equivalence classes of sets of points in <formula id="35">$ \mathbb R^2$</formula>. We call these points <emphasis>representatives</emphasis> of an element of <formula id="5">$ \mathbb T_c^2$</formula>. The implementation does not work directly on elements of <formula id="5">$ \mathbb T_c^2$</formula> but on some representatives in <formula id="35">$ \mathbb R^2$</formula>. So there need to be distinguished representatives to work on. Given <formula id="36">$ \alpha$</formula> and <formula id="37">$ \beta$</formula>, the square <formula id="38">$ [\alpha,\alpha+c)\times[\beta,\beta+c)$</formula> contains exactly one representative of each element in <formula id="5">$ \mathbb T_c^2$</formula>. We call it <emphasis>original domain</emphasis>. From now on, when we talk about <emphasis>points</emphasis>, we generally mean representatives of elements of <formula id="5">$ \mathbb T_c^2$</formula> that lie inside the original domain. Note that any input point is required to be an element of the half-open square representing the original domain as defined above.</para><para>There are simplices containing points inside the original domain but also points outside it. The points outside the original domain are periodic copies of points inside the original domain. So, to specify a simplex we need points together with some additional information that determines the respective periodic copy of each point. The set of representatives of an element of <formula id="5">$ \mathbb T_c^2$</formula> is a square point grid. We address each representative by a two-dimensional integer vector <formula id="39">$ (o_x,o_y)$</formula>, called <emphasis>offset</emphasis>. It represents the number of periods a representative in the original domain must be translated in <formula id="14">$ x$</formula>- and <formula id="15">$ y$</formula>-direction. The vector <formula id="40">$ (0,0)$</formula> corresponds to the representative in the original domain. To specify a <formula id="28">$ k$</formula>-simplex we need <formula id="41">$ k+1$</formula> point-offset pairs (cf. Fig. <ref refid="index_1fig__P2Triangulation2figoffsets" kindref="member">fig__P2Triangulation2figoffsets</ref>).</para><para><anchor id="index_1fig__P2Triangulation2figoffsets"/><image type="html" name="offsets.png"></image>
 <image type="latex" name="offsets.png" width="15cm"></image>
  <ref refid="index_1fig__P2Triangulation2figoffsets" kindref="member">fig__P2Triangulation2figoffsets</ref> Offsets in a face.  <linebreak/>
</para></sect1>
<sect1 id="index_1P2Triangulation2secintro">
<title>Representation</title>
<para>A triangulation is a collection of vertices and faces that are linked together through incidence and adjacency relations. Each face gives access to its three incident vertices, their corresponding offsets, and to its three adjacent faces. Each vertex gives access to one of its incident faces.</para><para>The three vertices of a face are indexed with 0, 1 and 2 in positive orientation. The orientation of a simplex in <formula id="5">$ \mathbb T_c^2$</formula> is defined as the orientation of the corresponding simplex in <formula id="35">$ \mathbb R^2$</formula> given by representatives determined by the respective offsets (see <ref refid="index_1fig__P2Triangulation2figorient" kindref="member">fig__P2Triangulation2figorient</ref>).</para><para><anchor id="index_1fig__P2Triangulation2figorient"/><image type="html" name="orient.png"></image>
 <image type="latex" name="orient.png" width="15cm"></image>
  <ref refid="index_1fig__P2Triangulation2figorient" kindref="member">fig__P2Triangulation2figorient</ref> Orientation of a face.  <linebreak/>
</para><para>As in the underlying combinatorial triangulation (see Chapter <ref refid="index_1Chapter_2D_Triangulation_Data_Structure" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">Chapter_2D_Triangulation_Data_Structure</ref>), the neighbors of a faces are indexed with 0, 1 and 2 in such a way that the neighbor indexed by <formula id="6">$ i$</formula> is opposite to the vertex with the same index. Edges ( <formula id="42">$ 1$</formula>-faces) are not explicitly represented: an edge is given by a face and an index (the edge <computeroutput>i</computeroutput> of a face <computeroutput>f</computeroutput> is the edge of <computeroutput>f</computeroutput> that is opposite to the vertex with index <computeroutput>i</computeroutput>). See <ref refid="index_1fig__P2Triangulation2figorient" kindref="member">fig__P2Triangulation2figorient</ref>.</para><para>Some point sets do not admit a triangulation in <formula id="5">$ \mathbb T_c^2$</formula>. In this case we use 9 periodic copies of the point set arranged in a square of edge length <formula id="43">$ 3c$</formula>. Any point set constructed in this way has a triangulation in <formula id="44">$ \mathbb R^2/G&apos;$</formula> with <formula id="45">$ G&apos;=(3c\cdot\mathbb Z)^2$</formula> <ref refid="citelist_1CITEREF_cgal:ct-c3pt-09" kindref="member">[1]</ref>. So we compute the triangulation in this space, which is a <emphasis>9-sheeted covering space</emphasis> of <formula id="5">$ \mathbb T_c^2$</formula> (see <ref refid="index_1fig__P2Triangulation2figcovering" kindref="member">fig__P2Triangulation2figcovering</ref>).</para><para><anchor id="index_1fig__P2Triangulation2figcovering"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="one_cover.png"></image>
 <image type="latex" name="one_cover.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="one_and_nine_cover.png"></image>
 <image type="latex" name="one_and_nine_cover.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__P2Triangulation2figcovering" kindref="member">fig__P2Triangulation2figcovering</ref> The same periodic triangulation in 1-sheeted covering space and 9-sheeted covering space.  <linebreak/>
</para><para>The machinery that manages the copies is largely hidden from the user. However there are some effects that cannot be ignored. For example if the point set does not permit a triangulation in <formula id="5">$ \mathbb T_c^2$</formula> then the combinatorial iterators (<computeroutput>Face_iterator</computeroutput>, <computeroutput>Edge_iterator</computeroutput> and <computeroutput>Vertex_iterator</computeroutput>) return all simplices that are internally stored, which correspond to 9 periodic copies of each geometric primitive (Triangle, Segment, and Point). This is necessary to ensure consistency in the adjacency relations. In case it is desired to have only one periodic copy of each primitive, we provide <emphasis>geometric</emphasis> iterators. They return geometric primitives of the triangulation without relations between them. Another effect is that when the algorithm switches from 9-sheeted covering to 1-sheeted covering the <computeroutput>Vertex_handle</computeroutput>s and <computeroutput>Face_handle</computeroutput>s referencing deleted items becomes invalid.</para><para>In the data structure each vertex stores the input point it corresponds to. If we are computing in 9-sheeted covering space, each vertex stores the representative <emphasis>inside</emphasis> the original domain it corresponds to. So, the 9 vertices corresponding to the same element of <formula id="5">$ \mathbb T_c^2$</formula> all store the same representative in <formula id="35">$ \mathbb R^2$</formula>, and not different periodic copies.</para><para><bold>Validity</bold></para><para>A periodic triangulation is said to be <computeroutput>locally valid</computeroutput> iff</para><para><bold>(a)-(b)</bold> Its underlying combinatorial graph, the triangulation data structure, is <computeroutput>locally valid</computeroutput> (see Chapter <ref refid="index_1Chapter_2D_Triangulation_Data_Structure" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">Chapter_2D_Triangulation_Data_Structure</ref>)</para><para><bold>(c)</bold> Any cell has its vertices ordered according to positive orientation. See <ref refid="index_1fig__P2Triangulation2figorient" kindref="member">fig__P2Triangulation2figorient</ref>.</para></sect1>
<sect1 id="index_1P2T2_Delaunay">
<title>Delaunay Triangulation</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">Periodic_2_Delaunay_triangulation_2</ref></computeroutput> implements Delaunay triangulations of point sets in <formula id="5">$ \mathbb T_c^2$</formula>.</para><para>Delaunay triangulations have the <emphasis>empty circle property</emphasis>, that is, the circumscribing circle of each face does not contain any other vertex of the triangulation in its interior. These triangulations are uniquely defined except in degenerate cases where four points are co-circular. Note however that the CGAL implementation computes a unique triangulation even in these cases <ref refid="citelist_1CITEREF_cgal:dt-pvr3d-03" kindref="member">[3]</ref>.</para><para>This implementation is fully dynamic: it supports both insertions of points and vertex removal.</para></sect1>
<sect1 id="index_1P2T2_Hierarchy">
<title>Triangulation Hierarchy</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Periodic__2__triangulation__hierarchy__2" kindref="compound">Periodic_2_triangulation_hierarchy_2</ref></computeroutput> is the adaptation of the hierarchical structure described in Chapter <ref refid="index_1Chapter_2D_Triangulations" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Chapter_2D_Triangulations</ref>, Section <ref refid="index_1Section_2D_Triangulations_Hierarchy" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">The Triangulation Hierarchy</ref> to the periodic case.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Periodic__2__triangulation__hierarchy__2" kindref="compound">Periodic_2_triangulation_hierarchy_2</ref>&lt;Tr&gt;</computeroutput> inherits from the triangulation type passed as template parameter <computeroutput>Tr</computeroutput>. The <computeroutput>insert</computeroutput>, <computeroutput>move</computeroutput>, and <computeroutput>remove</computeroutput> member functions are overwritten to update the data structure at each operation. The locate queries are also overwritten to take advantage of the data structure for a fast processing.</para></sect1>
<sect1 id="index_1P2Triangulation2secdesign">
<title>Software Design</title>
<para>We have chosen the prefix ``Periodic_2&apos;&apos; to emphasize that the triangulation is periodic in all two directions of space. There are also ``cylindrical&apos;&apos; periodicities where the triangulation is periodic only in one direction of the space.</para><para>The two main classes <computeroutput><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">Periodic_2_Delaunay_triangulation_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Periodic__2__triangulation__2" kindref="compound">Periodic_2_triangulation_2</ref></computeroutput> provide high-level geometric functionality and are responsible for the geometric validity. <computeroutput><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">Periodic_2_Delaunay_triangulation_2</ref></computeroutput> contains all the functionality that is special to Delaunay triangulations, such as point insertion and vertex removal, the side-of-circle test, finding the conflicting region of a given point, dual functions etc. <computeroutput><ref refid="classCGAL_1_1Periodic__2__triangulation__2" kindref="compound">Periodic_2_triangulation_2</ref></computeroutput> contains all the functionality that is common to triangulations in general, such as location of a point in the triangulation <ref refid="citelist_1CITEREF_cgal:dpt-wt-02" kindref="member">[4]</ref>, access functions, geometric queries like the orientation test etc.</para><para>They are built as layers on top of a triangulation data structure, which stores their combinatorial structure. This separation between the geometry and the combinatorics is reflected in the software design by the fact that the triangulation classes take two template parameters:<itemizedlist>
<listitem><para>the <bold>geometric traits</bold> class, which provides the type of points to use as well as the elementary operations on them (predicates and constructions). Furthermore it contains the offset type. The concept for this parameter is described in more detail in Section <ref refid="index_1P2Triangulation2secTraits" kindref="member">The Geometric Traits Parameter</ref>. The concepts that should be refined are <computeroutput><ref refid="classPeriodic__2TriangulationTraits__2" kindref="compound">Periodic_2TriangulationTraits_2</ref></computeroutput> (for <computeroutput><ref refid="classCGAL_1_1Periodic__2__triangulation__2" kindref="compound">Periodic_2_triangulation_2</ref></computeroutput>) and <computeroutput><ref refid="classPeriodic__2DelaunayTriangulationTraits__2" kindref="compound">Periodic_2DelaunayTriangulationTraits_2</ref></computeroutput> (for <computeroutput><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">Periodic_2_Delaunay_triangulation_2</ref></computeroutput>) in the reference manual and</para></listitem></itemizedlist>
<itemizedlist>
<listitem><para>the <bold>triangulation data structure</bold> class, which stores the combinatorial structure, described in Section <ref refid="index_1P2Triangulation2sectds" kindref="member">The Triangulation Data Structure Parameter</ref> and in more detail in Chapter <ref refid="index_1Chapter_2D_Triangulation_Data_Structure" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">Chapter_2D_Triangulation_Data_Structure</ref>. The triangulation data structure needs models of the concepts <computeroutput><ref refid="classPeriodic__2TriangulationFaceBase__2" kindref="compound">Periodic_2TriangulationFaceBase_2</ref></computeroutput> and <computeroutput><ref refid="classPeriodic__2TriangulationVertexBase__2" kindref="compound">Periodic_2TriangulationVertexBase_2</ref></computeroutput> as template parameters.</para></listitem></itemizedlist>
</para><sect2 id="index_1P2Triangulation2secTraits">
<title>The Geometric Traits Parameter</title>
<para>The first template parameter of the periodic triangulation class <computeroutput><ref refid="classCGAL_1_1Periodic__2__triangulation__2" kindref="compound">Periodic_2_triangulation_2</ref>&lt;Traits, Tds&gt;</computeroutput> is the geometric traits class, described by the concept <computeroutput><ref refid="classPeriodic__2TriangulationTraits__2" kindref="compound">Periodic_2TriangulationTraits_2</ref></computeroutput>. Similar, the first template parameter of the Delaunay triangulation class <computeroutput><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">Periodic_2_Delaunay_triangulation_2</ref>&lt;Traits,Tds&gt;</computeroutput> is the geometric traits class, described by the concept <computeroutput><ref refid="classPeriodic__2DelaunayTriangulationTraits__2" kindref="compound">Periodic_2DelaunayTriangulationTraits_2</ref></computeroutput>. These concepts are different from the <computeroutput><ref refid="classTriangulationTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">TriangulationTraits_2</ref></computeroutput> and <computeroutput><ref refid="classDelaunayTriangulationTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">DelaunayTriangulationTraits_2</ref></computeroutput> (see chapter <ref refid="index_1Triangulation_2TheGeometricTraits" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">The Geometric Traits</ref>) in that they also implement all objects, predicates and constructions with using offsets.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__traits__2" kindref="compound">Periodic_2_Delaunay_triangulation_traits_2</ref>&lt;Traits,<ref refid="classPeriodic__2Offset__2" kindref="compound">Periodic_2Offset_2</ref>&gt;</computeroutput> provides the required functionality. It expects two template parameters: A model of the concept <computeroutput><ref refid="classDelaunayTriangulationTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">DelaunayTriangulationTraits_2</ref></computeroutput> and a model of the concept <computeroutput><ref refid="classPeriodic__2Offset__2" kindref="compound">Periodic_2Offset_2</ref></computeroutput>. Since the concept <computeroutput><ref refid="classTriangulationTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">TriangulationTraits_2</ref></computeroutput> refines the concept <computeroutput><ref refid="classDelaunayTriangulationTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">DelaunayTriangulationTraits_2</ref></computeroutput>, the class <computeroutput><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__traits__2" kindref="compound">Periodic_2_Delaunay_triangulation_traits_2</ref>&lt;Traits,<ref refid="classPeriodic__2Offset__2" kindref="compound">Periodic_2Offset_2</ref>&gt;</computeroutput> is also a model for the concept <computeroutput><ref refid="classTriangulationTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">TriangulationTraits_2</ref></computeroutput>.</para><para>The kernels <computeroutput><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Homogeneous</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Simple_cartesian</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Simple__homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Simple_homogeneous</ref></computeroutput> and <computeroutput><ref refid="structCGAL_1_1Filtered__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Filtered_kernel</ref></computeroutput> can all be used as<xrefsect id="models_1_models000006"><xreftitle>Is Model Of</xreftitle><xrefdescription><para>for <computeroutput>Traits</computeroutput>. <computeroutput><ref refid="classCGAL_1_1Periodic__2__triangulation__traits__2" kindref="compound">Periodic_2_triangulation_traits_2</ref></computeroutput> provides exact predicates and exact constructions if <computeroutput>Traits</computeroutput> does. It provides exact predicates but not exact constructions if <computeroutput><ref refid="structCGAL_1_1Filtered__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Filtered_kernel</ref>&lt;CK&gt;</computeroutput> with <computeroutput>CK</computeroutput> an inexact kernel is used as its first template parameter. Using <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput> as <computeroutput>Traits</computeroutput> provides fast and exact predicates and not exact constructions, using <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput> provides fast and exact predicates and exact constructions. The latter is recommended if the dual constructions and constructions of points, segments, triangles, and tetrahedra are used.</para></xrefdescription></xrefsect></para><para>The second parameter <computeroutput><ref refid="classPeriodic__2Offset__2" kindref="compound">Periodic_2Offset_2</ref></computeroutput> defaults to <computeroutput><ref refid="classCGAL_1_1Periodic__2__offset__2" kindref="compound">Periodic_2_offset_2</ref></computeroutput>.</para></sect2>
<sect2 id="index_1P2Triangulation2sectds">
<title>The Triangulation Data Structure Parameter</title>
<para>The second template parameter of the main classes <computeroutput><ref refid="classCGAL_1_1Periodic__2__triangulation__2" kindref="compound">Periodic_2_triangulation_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">Periodic_2_Delaunay_triangulation_2</ref></computeroutput> is a triangulation data structure class. This class can be seen as a container for the faces and vertices maintaining incidence and adjacency relations (see Chapter <ref refid="index_1Chapter_2D_Triangulation_Data_Structure" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">Chapter_2D_Triangulation_Data_Structure</ref>). A model of this triangulation data structure is <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">Triangulation_data_structure_2</ref></computeroutput>, and it is described by the <computeroutput><ref refid="classTriangulationDataStructure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">TriangulationDataStructure_2</ref></computeroutput> concept. This model is itself parameterized by a vertex base class and a face base class, which gives the possibility to customize the vertices and cells used by the triangulation data structure, and hence by the geometric triangulation using it. To represent periodic triangulations the cell base and vertex base classes need to meet the concepts <computeroutput><ref refid="classPeriodic__2TriangulationFaceBase__2" kindref="compound">Periodic_2TriangulationFaceBase_2</ref></computeroutput> and <computeroutput><ref refid="classPeriodic__2TriangulationVertexBase__2" kindref="compound">Periodic_2TriangulationVertexBase_2</ref></computeroutput>.</para><para>A default value for the triangulation data structure parameter is provided in all the triangulation classes, so it does not need to be specified by the user unless he wants to use a different triangulation data structure or a different vertex or cell base class.</para></sect2>
<sect2 id="index_1P2T2FlexDesign">
<title>Flexibility of the Design</title>
<para><computeroutput><ref refid="classCGAL_1_1Periodic__2__triangulation__2" kindref="compound">Periodic_2_triangulation_2</ref></computeroutput> uses the <computeroutput><ref refid="classTriangulationDataStructure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">TriangulationDataStructure_2</ref></computeroutput> in essentially the same way as <computeroutput><ref refid="classCGAL_1_1Triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Triangulation_2</ref></computeroutput>. That is why the flexibility described in <ref refid="index_1Section_2D_Triangulations_Software_Design" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Software Design</ref> is applicable in exactly the same way. Also the classes <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Triangulation_vertex_base_with_info_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Triangulation__face__base__with__info__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Triangulation_face_base_with_info_2</ref></computeroutput> can be reused directly, see also Example <ref refid="index_1P2T2ExampleColor" kindref="member">Adding a color</ref>.</para></sect2>
</sect1>
<sect1 id="index_1P2Triangulation2secexamples">
<title>Examples</title>
<sect2 id="index_1P2T2ExampleBasic">
<title>Basic example</title>
<para>This example shows the incremental construction of a periodic 2D Delaunay triangulation, the location of a point and how to perform elementary operations on indices in a face. It uses the default parameter of the <computeroutput><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">Periodic_2_Delaunay_triangulation_2</ref></computeroutput> class for the triangulation data structure.</para><para><linebreak/>
<bold>File</bold> <ref refid="Periodic_2_triangulation_2_2p2t2_simple_example_8cpp-example" kindref="compound">Periodic_2_triangulation_2/p2t2_simple_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_traits_2&lt;K&gt;</ref><sp/>GT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_2&lt;GT&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PDT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PDT::Face_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PDT::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PDT::Locate_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Locate_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PDT::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PDT::Iso_rectangle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Iso_rectangle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Iso_rectangle<sp/>domain(-1,<sp/>-1,<sp/>2,<sp/>2);<sp/></highlight><highlight class="comment">//<sp/>The<sp/>cube<sp/>for<sp/>the<sp/>periodic<sp/>domain</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>construction<sp/>from<sp/>a<sp/>list<sp/>of<sp/>points<sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point&gt;<sp/>L;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>L.push_front(Point(0,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>L.push_front(Point(1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>L.push_front(Point(0,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PDT<sp/>T(L.begin(),<sp/>L.end(),<sp/>domain);<sp/></highlight><highlight class="comment">//<sp/>Put<sp/>the<sp/>domain<sp/>with<sp/>the<sp/>constructor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>T.number_of_vertices();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>insertion<sp/>from<sp/>a<sp/>vector<sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>V(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>V[0]<sp/>=<sp/>Point(0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>V[1]<sp/>=<sp/>Point(1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>V[2]<sp/>=<sp/>Point(-1,<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>n<sp/>=<sp/>n<sp/>+<sp/>T.insert(V.begin(),<sp/>V.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>n<sp/>==<sp/>5<sp/>);<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>6<sp/>points<sp/>have<sp/>been<sp/>inserted,<sp/>one<sp/>is<sp/>a<sp/>duplicate</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.is_valid()<sp/>);<sp/></highlight><highlight class="comment">//<sp/>checking<sp/>validity<sp/>of<sp/>T</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Locate_type<sp/>lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>li;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p(0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_handle<sp/>fh<sp/>=<sp/>T.locate(p,<sp/>lt,<sp/>li);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>p<sp/>is<sp/>the<sp/>vertex<sp/>of<sp/>c<sp/>of<sp/>index<sp/>li<sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>lt<sp/>==<sp/>PDT::VERTEX<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>fh-&gt;vertex(li)-&gt;point()<sp/>==<sp/>p<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v<sp/>=<sp/>fh-&gt;vertex(<sp/>(li<sp/>+<sp/>1)<sp/>%<sp/>3<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>v<sp/>is<sp/>another<sp/>vertex<sp/>of<sp/>c</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_handle<sp/>nb<sp/>=<sp/>fh-&gt;neighbor(li);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>nb<sp/>=<sp/>neighbor<sp/>of<sp/>fh<sp/>opposite<sp/>to<sp/>the<sp/>vertex<sp/>associated<sp/>with<sp/>p</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>nb<sp/>must<sp/>have<sp/>vertex<sp/>v<sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nli;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>nb-&gt;has_vertex(<sp/>v,<sp/>nli<sp/>)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>nli<sp/>is<sp/>the<sp/>index<sp/>of<sp/>v<sp/>in<sp/>nc</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>oFileT(</highlight><highlight class="stringliteral">&quot;output.tri&quot;</highlight><highlight class="normal">,<sp/>std::ios::out);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>writing<sp/>file<sp/>output;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>oFileT<sp/>&lt;&lt;<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PDT<sp/>T1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>iFileT(</highlight><highlight class="stringliteral">&quot;output.tri&quot;</highlight><highlight class="normal">,<sp/>std::ios::in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>reading<sp/>file<sp/>output;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>iFileT<sp/>&gt;&gt;<sp/>T1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T1.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T1.number_of_vertices()<sp/>==<sp/>T.number_of_vertices()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T1.number_of_faces()<sp/>==<sp/>T.number_of_faces()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1P2T2ExampleVertexBase">
<title>Changing the vertex base</title>
<para>The following two examples show how the user can plug his own vertex base in a triangulation. Changing the face base is similar.</para><sect3 id="index_1P2T2ExampleColor">
<title>Adding a color</title>
<para>If the user does not need to add a type in a vertex that depends on the <computeroutput><ref refid="classTriangulationDataStructure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">TriangulationDataStructure_2</ref></computeroutput> (e.g. a <computeroutput>Vertex_handle</computeroutput> or <computeroutput>Face_handle</computeroutput>), he can use the <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Triangulation_vertex_base_with_info_2</ref></computeroutput> class to add his own information easily in the vertices. The example below shows how to add a <computeroutput><ref refid="classCGAL_1_1Color" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::Color</ref></computeroutput> this way.</para><para><linebreak/>
<bold>File</bold> <ref refid="Periodic_2_triangulation_2_2p2t2_colored_vertices_8cpp-example" kindref="compound">Periodic_2_triangulation_2/p2t2_colored_vertices.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Color.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_traits_2&lt;K&gt;</ref><sp/>GT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__triangulation__vertex__base__2" kindref="compound">CGAL::Periodic_2_triangulation_vertex_base_2&lt;GT&gt;</ref><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::Triangulation_vertex_base_with_info_2&lt;CGAL::Color, GT, Vb&gt;</ref><sp/>VbInfo;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__triangulation__face__base__2" kindref="compound">CGAL::Periodic_2_triangulation_face_base_2&lt;GT&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;VbInfo, Fb&gt;</ref><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_2&lt;GT, Tds&gt;</ref><sp/><sp/>PDT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PDT::Point<sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PDT<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.<ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2_1a43cbaa4db314639bb57973f90a6aa3ae" kindref="member">insert</ref>(Point(0,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(.1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(0,<sp/>.1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(.2,<sp/>.2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(.9,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>the<sp/>color<sp/>of<sp/>vertices<sp/>with<sp/>degree<sp/>6<sp/>to<sp/>red.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PDT::Vertex_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>T.vertices_begin();<sp/>vit<sp/>!=<sp/>T.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(T.degree(vit)<sp/>==<sp/>6)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>vit-&gt;info()<sp/>=<sp/>CGAL::RED;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1P2T2ExampleAddingHandles">
<title>Adding handles</title>
<para>If the user needs to add a type in a vertex that depends on the <computeroutput><ref refid="classTriangulationDataStructure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">TriangulationDataStructure_2</ref></computeroutput> (e.g. a <computeroutput>Vertex_handle</computeroutput> or <computeroutput>Face_handle</computeroutput>), he has to derive his own vertex base class, as the following example shows.</para><para><linebreak/>
<bold>File</bold> <ref refid="Periodic_2_triangulation_2_2p2t2_adding_handles_8cpp-example" kindref="compound">Periodic_2_triangulation_2/p2t2_adding_handles.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>GT,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Vb<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_vertex_base</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Vb</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Vertex_handle<sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Face_handle<sp/><sp/><sp/><sp/>Face_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Tds2<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Rebind_TDS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::template<sp/>Rebind_TDS&lt;Tds2&gt;::Other<sp/><sp/><sp/><sp/><sp/>Vb2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>My_vertex_base&lt;GT,<sp/>Vb2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Other;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_base()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_base(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>Vb(p)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_base(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p,<sp/>Face_handle<sp/>c)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>Vb(p,<sp/>c)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>vh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_handle<sp/><sp/><sp/><sp/><sp/>fh;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_traits_2&lt;K&gt;</ref><sp/>GT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__triangulation__vertex__base__2" kindref="compound">CGAL::Periodic_2_triangulation_vertex_base_2&lt;GT&gt;</ref><sp/><sp/><sp/><sp/>VbDS;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>My_vertex_base&lt;GT,<sp/>VbDS&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__triangulation__face__base__2" kindref="compound">CGAL::Periodic_2_triangulation_face_base_2&lt;GT&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;Vb, Fb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_2&lt;GT, Tds&gt;</ref><sp/><sp/>PDT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PDT::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PDT::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PDT<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v0<sp/>=<sp/>T.<ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2_1a43cbaa4db314639bb57973f90a6aa3ae" kindref="member">insert</ref>(Point(0,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v1<sp/>=<sp/>T.insert(Point(.1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v2<sp/>=<sp/>T.insert(Point(0,<sp/>.1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v3<sp/>=<sp/>T.insert(Point(0,<sp/>0.2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v4<sp/>=<sp/>T.insert(Point(.2,<sp/>.2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v5<sp/>=<sp/>T.insert(Point(.9,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Now<sp/>we<sp/>can<sp/>link<sp/>the<sp/>vertices<sp/>as<sp/>we<sp/>like.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v0-&gt;vh<sp/>=<sp/>v1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v1-&gt;vh<sp/>=<sp/>v2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v2-&gt;vh<sp/>=<sp/>v3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v3-&gt;vh<sp/>=<sp/>v4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v4-&gt;vh<sp/>=<sp/>v5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v5-&gt;vh<sp/>=<sp/>v0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
</sect2>
<sect2 id="index_1P2T2ExampleCovering">
<title>9-sheeted covering</title>
<para>The user can check at any time whether a triangulation would be a simplicial complex in <formula id="5">$ \mathbb T_c^2$</formula> and force a conversion if so. However this should be done very carefully in order to be sure that the internal structure always remains a simplicial complex and thus a triangulation.</para><para>In this example we construct a triangulation that can be converted to the 1-sheeted covering. However, we can insert new points such that the point set does not have a Delaunay triangulation in the 1-sheeted covering anymore, so the triangulation is not <emphasis>extensible</emphasis>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Periodic_2_triangulation_2_2p2t2_covering_8cpp-example" kindref="compound">Periodic_2_triangulation_2/p2t2_covering.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_traits_2&lt;K&gt;</ref><sp/>GT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_2&lt;GT&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PDT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PDT::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PDT::Covering_sheets<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Covering_sheets;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PDT<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Input<sp/>point<sp/>grid<sp/>(27<sp/>points)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x<sp/>=<sp/>0.<sp/>;<sp/>x<sp/>&lt;<sp/>.9<sp/>;<sp/>x<sp/>+=<sp/>0.4)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y<sp/>=<sp/>0.<sp/>;<sp/>y<sp/>&lt;<sp/>.9<sp/>;<sp/>y<sp/>+=<sp/>0.4)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T.<ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2_1a43cbaa4db314639bb57973f90a6aa3ae" kindref="member">insert</ref>(Point(x,<sp/>y));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Covering_sheets<sp/>cs<sp/>=<sp/>T.number_of_sheets();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Current<sp/>covering:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>cs[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>cs[1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>T.is_triangulation_in_1_sheet()<sp/>)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>true</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_extensible<sp/>=<sp/>T.is_extensible_triangulation_in_1_sheet_h1()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>T.is_extensible_triangulation_in_1_sheet_h2();<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>false</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T.convert_to_1_sheeted_covering();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cs<sp/>=<sp/>T.number_of_sheets();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Current<sp/>covering:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>cs[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>cs[1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>is_extensible<sp/>)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>false</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;It<sp/>is<sp/>safe<sp/>to<sp/>change<sp/>the<sp/>triangulation<sp/>here.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;It<sp/>is<sp/>NOT<sp/>safe<sp/>to<sp/>change<sp/>the<sp/>triangulation<sp/>here!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T.convert_to_9_sheeted_covering();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cs<sp/>=<sp/>T.number_of_sheets();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Current<sp/>covering:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>cs[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>cs[1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;It<sp/>is<sp/>(again)<sp/>safe<sp/>to<sp/>modify<sp/>the<sp/>triangulation.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1P2T2ExampleLargePointSet">
<title>Large point set</title>
<para>For large point sets there are two optimizations available. Firstly, there is spatial sorting that sorts the input points according to a Hilbert curve, see chapter <ref refid="index_1secspatial_sorting" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Spatial_sorting.tag">Spatial Sorting</ref>. The second one inserts 12 appropriately chosen dummy points to avoid the use of a 9-sheeted covering in the beginning. The 12 dummy points are deleted in the end. If the point set turns out to not have a Delaunay triangulation in 1-sheeted covering, the triangulation is converted to 9-sheeted covering during the removal of the 12 dummy points. This might take even longer than computing the triangulation without using this optimization. In general, uniformly distributed random point sets of more than 1000 points have a Delaunay triangulation in 1-sheeted covering.</para><para>It is recommended to run this example only when compiled in release mode because of the relatively large number of points.</para><para><linebreak/>
<bold>File</bold> <ref refid="Periodic_2_triangulation_2_2p2t2_large_point_set_8cpp-example" kindref="compound">Periodic_2_triangulation_2/p2t2_large_point_set.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Random.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_traits_2&lt;K&gt;</ref><sp/>GT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_2&lt;GT&gt;</ref><sp/>PDT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PDT::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;double, Point&gt;</ref><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random<sp/>random(7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_square_2&lt;Point,<sp/>Creator&gt;<sp/>in_square(.5,<sp/>random);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>10000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PDT<sp/>PT1,<sp/>PT2,<sp/>PT3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Generating<sp/>n<sp/>random<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0<sp/>;<sp/>i<sp/>&lt;<sp/>n<sp/>;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point<sp/>p<sp/>=<sp/>*in_square;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in_square++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pts.push_back(Point(p.x()<sp/>+<sp/>.5,<sp/>p.y()<sp/>+<sp/>.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Standard<sp/>insertion</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0<sp/>;<sp/>i<sp/>&lt;<sp/>n<sp/>;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PT1.insert(pts[i]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>Time:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>sec.<sp/>(Standard<sp/>insertion)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Iterator<sp/>range<sp/>insertion<sp/>using<sp/>spatial<sp/>sorting<sp/>but<sp/>no<sp/>dummy<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT2.insert(pts.begin(),<sp/>pts.end());<sp/></highlight><highlight class="comment">//<sp/>third<sp/>parameter<sp/>defaults<sp/>to<sp/>false</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>Time:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>sec.<sp/>(with<sp/>spatial<sp/>sorting)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Iterator<sp/>range<sp/>insertion<sp/>using<sp/>spatial<sp/>sorting<sp/>and<sp/>dummy<sp/>point<sp/>heuristic</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT3.insert(pts.begin(),<sp/>pts.end(),<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>Time:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>sec.<sp/>(Dummy<sp/>point<sp/>heuristic)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1P2T2ExampleGeometricAccess">
<title>Geometric access</title>
<para>There might be applications that need the geometric primitives of a triangulation as an input but do not require a simplicial complex. For these cases we provide the geometric iterators that return only the geometric primitives fulfilling some properties. In the following example we use the <computeroutput>Periodic_triangle_iterator</computeroutput> with the option <computeroutput>UNIQUE_COVER_DOMAIN</computeroutput>. This means that only those triangles are returned that have a non-empty intersection with the original domain of the 1-sheeted covering space, see Figure <ref refid="classCGAL_1_1Periodic__2__triangulation__2_1P2Triangulation2figgeom_iterators" kindref="member">P2Triangulation2figgeom_iterators</ref>. The <computeroutput>Periodic_triangle</computeroutput> is actually a two-dimensional array of point-offset pairs. We check for all three entries of the periodic triangle whether the offset is (0,0,0) using the method <computeroutput>is_null</computeroutput>. If so, we convert the periodic triangle to a <computeroutput>PK::Triangle_2</computeroutput>, which requires <emphasis>exact constructions</emphasis>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Periodic_2_triangulation_2_2p2t2_geometric_access_8cpp-example" kindref="compound">Periodic_2_triangulation_2/p2t2_geometric_access.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_traits_2&lt;K&gt;</ref><sp/>PK;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound">CGAL::Periodic_2_Delaunay_triangulation_2&lt;PK&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P2DT2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PK::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PK::Triangle_2<sp/><sp/><sp/><sp/><sp/>Triangle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>P2DT2::Periodic_triangle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Periodic_triangle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>P2DT2::Periodic_triangle_iterator<sp/><sp/>Periodic_triangle_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>P2DT2::Iterator_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Iterator_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P2DT2<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.<ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2_1a43cbaa4db314639bb57973f90a6aa3ae" kindref="member">insert</ref>(Point(0,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(0,<sp/>0.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(0.5,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Periodic_triangle<sp/>pt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangle<sp/>t_bd;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Extracting<sp/>the<sp/>triangles<sp/>that<sp/>have<sp/>a<sp/>non-empty<sp/>intersection<sp/>with</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>original<sp/>domain<sp/>of<sp/>the<sp/>1-sheeted<sp/>covering<sp/>space</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Periodic_triangle_iterator<sp/>ptit<sp/>=<sp/>T.periodic_triangles_begin(P2DT2::UNIQUE_COVER_DOMAIN);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ptit<sp/>!=<sp/>T.periodic_triangles_end(P2DT2::UNIQUE_COVER_DOMAIN);<sp/>++ptit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pt<sp/>=<sp/>*ptit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>(pt[0].second.is_null()<sp/>&amp;&amp;<sp/>pt[1].second.is_null()<sp/>&amp;&amp;<sp/>pt[2].second.is_null())<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Convert<sp/>the<sp/>current<sp/>Periodic_triangle<sp/>to<sp/>a<sp/>Triangle<sp/>if<sp/>it<sp/>is</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>not<sp/>strictly<sp/>contained<sp/>inside<sp/>the<sp/>original<sp/>domain.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>this<sp/>requires<sp/>EXACT<sp/>constructions<sp/>to<sp/>be<sp/>exact!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t_bd<sp/>=<sp/>T.triangle(pt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1P2T2_Performance">
<title>Performance</title>
<para>The performance of the 2D periodic Delaunay triangulation is compared to the Euclidean 2D Delaunay triangulation. The points are inserted in the Euclidean 2D Delaunay triangulation using spatial sorting. In the Periodic triangulation the points are first inserted in random order until the triangulation is valid in the 1 sheeted covering space. The remaining points are then inserted using spatial sorting. For the large point set, first dummy points are inserted to create a valid triangulation in the 1 sheeted covering space. Then all points are inserted using spatial sorting. As a final step, the dummy points are removed again.</para><para>The plot shows the running time in seconds for different numbers of batch inserted points. The points are uniformly randomly distributed in the unit rectangle. The tests were done on an Intel i7 @ 2.67GHz.</para><para><image type="html" name="p2dt2_performance.png"></image>
 <image type="latex" name="p2dt2_performance.png"></image>
</para></sect1>
<sect1 id="index_1P2T2_Design">
<title>Design and Implementation History</title>
<para>The periodic 2D-triangulation is based on the 2D triangulation package developed by Mariette Yvinec and inspired by the periodic 3D-triangulation package developed by Manuel Caroli and Monique Teillaud. The periodic 3D-triangulation package is described in Manuel&apos;s PhD thesis <ref refid="citelist_1CITEREF_cgal:c-tpsos-10" kindref="member">[2]</ref> Triangulating Point Sets in Orbit Spaces and <ref refid="citelist_1CITEREF_cgal:ct-c3pt-09" kindref="member">[1]</ref>.</para><para>In 2009, Nico Kruithof started implementation of the <computeroutput><ref refid="classCGAL_1_1Periodic__2__triangulation__2" kindref="compound">Periodic_2_triangulation_2</ref></computeroutput> package. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
