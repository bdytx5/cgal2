<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Triangulations"/>  <simplesect kind="author"><para>Mariette Yvinec</para></simplesect>
<image type="html" name="tr1dt1.svg"></image>
 <image type="latex" name="tr1dt1.png"></image>
</para><para>This chapter describes the two dimensional triangulations of CGAL. Section <ref refid="index_1Section_2D_Triangulations_Definitions" kindref="member">Definitions</ref> recalls the main definitions about triangulations. Section <ref refid="index_1Section_2D_Triangulations_Representation" kindref="member">Representation</ref> discusses the way two-dimensional triangulations are represented in CGAL. Section <ref refid="index_1Section_2D_Triangulations_Software_Design" kindref="member">Software Design</ref> presents the overall software design of the 2D triangulations package. The next sections present the different two dimensional triangulations classes available in CGAL: basic triangulations (Section <ref refid="index_1Section_2D_Triangulations_Basic" kindref="member">Basic Triangulations</ref>), Delaunay triangulations (Section <ref refid="index_1Section_2D_Triangulations_Delaunay" kindref="member">Delaunay Triangulations</ref>), regular triangulations (Section <ref refid="index_1Section_2D_Triangulations_Regular" kindref="member">Regular Triangulations</ref>), constrained triangulations (Section <ref refid="index_1Section_2D_Triangulations_Constrained" kindref="member">Constrained Triangulations</ref>), and constrained Delaunay triangulations (Section <ref refid="index_1Section_2D_Triangulations_Constrained_Delaunay" kindref="member">Constrained Delaunay Triangulations</ref>). Section <ref refid="index_1Section_2D_Triangulations_Constrained_Plus" kindref="member">Constrained Triangulations with a Bidirectional Mapping between Constraints and Subconstraints</ref> describes a class which implements a constrained or constrained Delaunay triangulation with an additional data structure to describe how the constraints are refined by the edges of the triangulations. Section <ref refid="index_1Section_2D_Triangulations_Hierarchy" kindref="member">The Triangulation Hierarchy</ref> describes a hierarchical data structure for fast point location queries. At last, Section <ref refid="index_1Section_2D_Triangulations_Flexibility" kindref="member">Flexibility</ref> explains how the user can benefit from the flexibility of CGAL triangulations using customized classes for faces and vertices.</para><sect1 id="index_1Section_2D_Triangulations_Definitions">
<title>Definitions</title>
<para>A two dimensional triangulation can be roughly described as a set <formula id="52">$ T$</formula> of triangular facets such that:</para><para><itemizedlist>
<listitem><para>two facets either are disjoint or share a lower dimensional face (edge or vertex).</para></listitem><listitem><para>the set of facets in <formula id="52">$ T$</formula> is connected for the adjacency relation.</para></listitem><listitem><para>the domain <formula id="53">$ U_T$</formula> which is the union of facets in <formula id="52">$ T$</formula> has no singularity.</para></listitem></itemizedlist>
</para><para>More precisely, a triangulation can be described as a simplicial complex. Let us first record a few definitions.</para><para>A simplicial complex is a set <formula id="52">$ T$</formula> of simplices such that</para><para><itemizedlist>
<listitem><para>any face of a simplex in <formula id="52">$ T$</formula> is a simplex in <formula id="52">$ T$</formula></para></listitem><listitem><para>two simplices in <formula id="52">$ T$</formula> either are disjoint or share a common sub-face.</para></listitem></itemizedlist>
</para><para>The dimension <formula id="4">$ d$</formula> of a simplicial complex is the maximal dimension of its simplices.</para><para>A simplicial complex <formula id="52">$ T$</formula> is pure if any simplex of <formula id="52">$ T$</formula> is included in a simplex of <formula id="52">$ T$</formula> with maximal dimension.</para><para>Two simplexes in <formula id="52">$ T$</formula> with maximal dimension <formula id="4">$ d$</formula> are said to be adjacent if they share a <formula id="54">$ d-1$</formula> dimensional sub-face. A simplicial complex is connected if the adjacency relation defines a connected graph over the set of simplices of <formula id="52">$ T$</formula> with maximal dimension.</para><para>The union <formula id="53">$ U_T$</formula> of all simplices in <formula id="52">$ T$</formula> is called the domain of <formula id="52">$ T$</formula>. A point <formula id="14">$ p$</formula> in the domain of <formula id="52">$ T$</formula> is said to singular if its surrounding in <formula id="53">$ U_T$</formula> is neither a topological ball nor a topological disc.</para><para>Then, a two dimensional triangulation can be described as a two dimensional simplicial complex that is pure, connected and without singularity.</para><para>Each facet of a triangulation can be given an orientation which in turn induces an orientation on the edges incident to that facet. The orientation of two adjacent facets are said to be consistent if they induce opposite orientations on their common incident edge. A triangulation is said to be orientable if the orientation of each facet can be chosen in such a way that all pairs of incident facets have consistent orientations.</para><para>The data structure underlying CGAL triangulations allows the user to represent the combinatorics of any orientable two dimensional triangulations without boundaries. On top of this data structure, the 2D triangulations classes take care of the geometric embedding of the triangulation and are designed to handle planar triangulations. The plane of the triangulation may be embedded in a higher dimensional space.</para><para>The triangulations of CGAL are complete triangulations which means that their domain is the convex hull of their vertices. Because any planar triangulation can be completed, this is not a real restriction. For instance, a triangulation of a polygonal region can be constructed and represented as a subset of a constrained triangulation in which the region boundary edges have been input as constrained edges (see Section <ref refid="index_1Section_2D_Triangulations_Constrained" kindref="member">Constrained Triangulations</ref>, <ref refid="index_1Section_2D_Triangulations_Constrained_Delaunay" kindref="member">Constrained Delaunay Triangulations</ref> and <ref refid="index_1Section_2D_Triangulations_Constrained_Plus" kindref="member">Constrained Triangulations with a Bidirectional Mapping between Constraints and Subconstraints</ref>).</para><para>Strictly speaking, the term <emphasis>face</emphasis> should be used to design a face of any dimension, and the two-dimensional faces of a triangulation should be properly called <emphasis>facets</emphasis>. However, following a common usage, we hereafter often call <emphasis>faces</emphasis>, the facets of a two dimensional triangulation.</para></sect1>
<sect1 id="index_1Section_2D_Triangulations_Representation">
<title>Representation</title>
<sect2 id="index_1Triangulation_2TheSetofFaces">
<title>The Set of Faces</title>
<para>A 2D triangulation of CGAL can be viewed as a planar partition whose bounded faces are triangular and cover the convex hull of the set of vertices. The single unbounded face of this partition is the complementary of the convex hull. In many applications, such as Kirkpatrick&apos;s hierarchy or incremental Delaunay construction, it is convenient to deal with only triangular faces. Therefore, a fictitious vertex, called the <emphasis>infinite vertex</emphasis> is added to the triangulation as well as infinite edges* and <emphasis>infinite faces</emphasis> incident to it. Each infinite edge is incident to the infinite vertex and to a vertex of the convex hull. Each infinite face is incident to the infinite vertex and to a convex hull edge.</para><para>Therefore, each edge of the triangulation is incident to exactly two faces and the set of faces of a triangulation is topologically equivalent to a two-dimensional sphere. This extends to lower dimensional triangulations arising in degenerate cases or when the triangulations as less than three vertices. Including the infinite faces, a one dimensional triangulation is a ring of edges and vertices topologically equivalent to a <formula id="55">$ 1$</formula>-sphere. A zero dimensional triangulation, whose domain is reduced to a single point, is represented by two vertices that is topologically equivalent to a <formula id="38">$ 0$</formula>-sphere.</para><para>Note that the <emphasis>infinite vertex</emphasis> has no significant coordinates and that no geometric predicate can be applied on it nor on an infinite face.</para><para><anchor id="index_1fig__Triangulation_2D_Fig_infinite_vertex"/><image type="html" name="infinite.png"></image>
 <image type="latex" name="infinite.png" width="15cm"></image>
  <ref refid="index_1fig__Triangulation_2D_Fig_infinite_vertex" kindref="member">fig__Triangulation_2D_Fig_infinite_vertex</ref> Infinite vertex and infinite faces  <linebreak/>
</para></sect2>
<sect2 id="index_1Triangulation_2ARepresentationBasedonFaces">
<title>A Representation Based on Faces and Vertices</title>
<para>Because a triangulation is a set of triangular faces with constant-size complexity, triangulations are not implemented as a layer on top of a planar map. CGAL uses a proper internal representation of triangulations based on faces and vertices rather than on edges. Such a representation saves storage space and results in faster algorithms <ref refid="citelist_1CITEREF_bdty-tcgal-00" kindref="member">[1]</ref>.</para><para>The basic elements of the representation are vertices and faces. Each triangular face gives access to its three incident vertices and to its three adjacent faces. Each vertex gives access to one of its incident faces and through that face to the circular list of its incident faces.</para><para>The three vertices of a face are indexed with 0, 1 and 2 in counterclockwise order. The neighbors of a face are also indexed with 0,1,2 in such a way that the neighbor indexed by <computeroutput>i</computeroutput> is opposite to the vertex with the same index. See <ref refid="index_1fig__Triangulation_2D_Fig_neighbors1" kindref="member">fig__Triangulation_2D_Fig_neighbors1</ref>, the functions <computeroutput>ccw(i)</computeroutput> and <computeroutput>cw(i)</computeroutput> shown on this figure compute respectively <formula id="45">$ i+1$</formula> and <formula id="56">$ i-1$</formula> modulo 3.</para><para>The edges are not explicitly represented, they are only implicitly represented through the adjacency relations of two faces. Each edge has two implicit representations: the edge of a face <computeroutput>f</computeroutput> which is opposed to the vertex indexed <computeroutput>i</computeroutput>, can be represented as well as an edge of the <computeroutput>neighbor(i)</computeroutput> of <computeroutput>f</computeroutput>.</para><para><anchor id="index_1fig__Triangulation_2D_Fig_neighbors1"/><image type="html" name="rep_bis.png"></image>
 <image type="latex" name="rep_bis.png" width="15cm"></image>
  <ref refid="index_1fig__Triangulation_2D_Fig_neighbors1" kindref="member">fig__Triangulation_2D_Fig_neighbors1</ref> Vertices and neighbors.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1Section_2D_Triangulations_Software_Design">
<title>Software Design</title>
<para>The triangulations classes of CGAL provide high-level geometric functionalities such as location of a point in the triangulation, insertion, removal, or displacement of a point. They are build as a layer on top of a data structure called the triangulation data structure. The triangulation data structure can be thought of as a container for the faces and vertices of the triangulation. This data structure also takes care of all the combinatorial aspects of the triangulation.</para><para>This separation between the geometric aspect and the combinatorial part is reflected in the software design by the fact that the triangulation classes have two template parameters:</para><para><itemizedlist>
<listitem>
<para>the first parameter stands for a <bold>geometric traits</bold> class providing the geometric primitives (points, segments and triangles) of the triangulation and the elementary operations (predicate or constructions) on those objects.</para><para></para></listitem>
<listitem>
<para>the second parameter stands for a <bold>triangulation data structure</bold> class. The concept of triangulation data structure is described in Section <ref refid="index_1TDS_2D_Concept" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">Concepts</ref> of Chapter <ref refid="index_1Chapter_2D_Triangulation_Data_Structure" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">2D Triangulation Data Structure</ref>. The triangulation data structure defines the types used to represent the faces and vertices of the triangulation, as well as additional types (handles, iterators and circulators) to access and visit the faces and vertices.</para><para>CGAL provides the class <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">Triangulation_data_structure_2</ref>&lt;Vb,Fb&gt;</computeroutput> as a default model of triangulation data structure. The class <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">Triangulation_data_structure_2</ref>&lt;Vb,Fb&gt;</computeroutput> has two template parameters standing for a vertex class and a face class. CGAL defines concepts for these template parameters and provide default models for these concepts. The vertex and base classes are templated by the geometric traits class which enables them to obtain some knowledge of the geometric primitives of the triangulation. Those default vertex and face base classes can be replaced by user customized base classes in order, for example, to deal with additional properties attached to the vertices or faces of a triangulation. See Section <ref refid="index_1Section_2D_Triangulations_Flexibility" kindref="member">Flexibility</ref> for more details on the way to make use of this flexibility. </para></listitem>
</itemizedlist>
</para><para><ref refid="index_1fig__Triangulation_2D_Fig_three_levels" kindref="member">fig__Triangulation_2D_Fig_three_levels</ref> summarizes the design of the triangulation package, showing the three layers (base classes, triangulation data structure and triangulation) forming this design.</para><para><anchor id="index_1fig__Triangulation_2D_Fig_three_levels"/><image type="html" name="threelevels.png"></image>
 <image type="latex" name="threelevels.png" width="15cm"></image>
  <ref refid="index_1fig__Triangulation_2D_Fig_three_levels" kindref="member">fig__Triangulation_2D_Fig_three_levels</ref> The triangulations software design.  <linebreak/>
</para><para>The top triangulation level, responsible for the geometric embedding of the triangulation comes in different flavors according to the different kind of triangulations: basic, Delaunay, regular, constrained or constrained Delaunay. Each kind of triangulations correspond to a different class. <ref refid="index_1fig__Triangulation_2D_Fig_derivation_tree" kindref="member">fig__Triangulation_2D_Fig_derivation_tree</ref> summarizes the derivation dependencies of CGAL 2D triangulations classes. Any 2D triangulation class is parametrized by a geometric traits class and a triangulation data structure. While a unique concept <computeroutput><ref refid="classTriangulationDataStructure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">TriangulationDataStructure_2</ref></computeroutput> describes the triangulation data structure requirements for any triangulation class, the requirements on the geometric traits class actually depend on the triangulation class. In general, the requirements for the vertex and face base classes are described by the basic concepts <computeroutput><ref refid="classTriangulationVertexBase__2" kindref="compound">TriangulationVertexBase_2</ref></computeroutput> and <computeroutput><ref refid="classTriangulationFaceBase__2" kindref="compound">TriangulationFaceBase_2</ref></computeroutput>. However, some triangulation classes require base classes implementing refinements of the basic concepts.</para><para><anchor id="index_1fig__Triangulation_2D_Fig_derivation_tree"/><image type="html" name="derivation_tree.png"></image>
 <image type="latex" name="derivation_tree.png" width="15cm"></image>
  <ref refid="index_1fig__Triangulation_2D_Fig_derivation_tree" kindref="member">fig__Triangulation_2D_Fig_derivation_tree</ref> The derivation tree of 2D triangulations.  <linebreak/>
</para></sect1>
<sect1 id="index_1Section_2D_Triangulations_Basic">
<title>Basic Triangulations</title>
<sect2 id="index_1Subsection_2D_Triangulations_Basic_Description">
<title>Description</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Triangulation__2" kindref="compound">Triangulation_2</ref>&lt;Traits,Tds&gt;</computeroutput> serves as a base class for the other 2D triangulations classes and implements the user interface to a triangulation.</para><para>The vertices and faces of the triangulations are accessed through <computeroutput>handles</computeroutput>, <computeroutput>iterators</computeroutput> and <computeroutput>circulators</computeroutput>. A handle is a model of the concept <computeroutput><ref refid="classHandle" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circulator.tag">Handle</ref></computeroutput> which basically offers the two dereference operators <computeroutput>*</computeroutput> and <computeroutput>-&gt;</computeroutput>. A circulator is a type devoted to visit circular sequences. Handles are used whenever the accessed element is not part of a sequence. Iterators and circulators are used to visit all or parts of the triangulation.</para><para>The iterators and circulators are all bidirectional and non mutable. The circulators and iterators are convertible to the handles with the same value type, so that when calling a member function, any handle type argument can be replaced by an iterator or a circulator with the same value type.</para><para>The triangulation class provides a function to visit the vertices and neighbors of a face in clockwise or counterclockwise order.</para><para>There are circulators to visit the edges or faces incident to a given vertex or the vertices adjacent to it. Another circulator type enables the visit of all the faces traversed by a given line. Circulators step through infinite features as well as through finite ones.</para><para>The triangulation class offers some iterators to visit all the faces, edges or vertices and also iterators to visit selectively the finite faces, edges or vertices.</para><para>The triangulation class provides methods to test the infinite character of any feature, and also methods to test the presence in the triangulation of a particular feature (edge or face) given its vertices.</para><para>The triangulation class provides a method to locate a given point with respect to a triangulation. In particular, this method reports whether the point coincides with a vertex of the triangulation, lies on an edge, in a face or outside of the convex hull. In case of a degenerate lower dimensional triangulation, the query point may also lie outside the triangulation affine hull.</para><para>The triangulation class also provides methods to locate a point with respect to a given finite face of the triangulation or with respect to its circumcircle. The faces of the triangulation and their circumcircles have the counterclockwise orientation.</para><para>The triangulation can be modified by several functions: insertion of a point, removal of a vertex, displacement of a vertex, flipping of an edge. The flipping of an edge is possible when the union of the two incident faces forms a convex quadrilateral (see <ref refid="index_1fig__Triangulation_2D_fig_flip_bis" kindref="member">fig__Triangulation_2D_fig_flip_bis</ref>).</para><para><anchor id="index_1fig__Triangulation_2D_fig_flip_bis"/><image type="html" name="Flip.png"></image>
 <image type="latex" name="Flip.png" width="15cm"></image>
  <ref refid="index_1fig__Triangulation_2D_fig_flip_bis" kindref="member">fig__Triangulation_2D_fig_flip_bis</ref> Flip.  <linebreak/>
</para></sect2>
<sect2 id="index_1Triangulation_2Implementation">
<title>Implementation</title>
<para>Locate is implemented by a line walk. The walk begins at a vertex of the face which is given as an optional argument or at an arbitrary vertex of the triangulation if no optional argument is given. It takes time <formula id="7">$ O(n)$</formula> in the worst case, but only <formula id="34">$ O(\sqrt{n})$</formula> on average if the vertices are distributed uniformly at random. The class <computeroutput><ref refid="classCGAL_1_1Triangulation__hierarchy__2" kindref="compound">Triangulation_hierarchy_2</ref>&lt;Traits,Tds&gt;</computeroutput>, described in section <ref refid="index_1Section_2D_Triangulations_Hierarchy" kindref="member">The Triangulation Hierarchy</ref>, implements a data structure designed to offer an alternate more efficient point location algorithm.</para><para>Insertion of a point is done by locating a face that contains the point, and splitting this face into three new faces. If the point falls outside the convex hull, the triangulation is restored by flips. Apart from the location, insertion takes a time <formula id="5">$ O(1)$</formula>. This bound is only an amortized bound for points located outside the convex hull.</para><para>Removal of a vertex is done by removing all adjacent triangles, and re-triangulating the hole. Removal takes a time at most proportional to <formula id="57">$ d^2$</formula>, where <formula id="4">$ d$</formula> is the degree of the removed vertex, which is <formula id="5">$ O(1)$</formula> for a random vertex.</para><para>Displacement of a vertex is done by: first, verifying if the triangulation embedding remains planar after the displacement; if yes the vertex is directly placed at the new location; otherwise, a point is inserted at the new location and the vertex at the obsolete location is removed.</para><para>The face, edge, and vertex iterators on finite features are derived from their counterparts visiting all (finite and infinite) features which are themselves derived from the corresponding iterators of the triangulation data structure.</para></sect2>
<sect2 id="index_1Subsubsection_2D_Triangulation_Basic_Geometric_Traits">
<title>Geometric Traits</title>
<para>The geometric traits class of a triangulation is required to provide the geometric objects (points, segments and triangles) building up the triangulation together with the geometric predicates on those objects. The required predicates are:</para><para><itemizedlist>
<listitem><para>comparison of the <computeroutput>x</computeroutput> or <computeroutput>y</computeroutput> coordinates of two points.</para></listitem><listitem><para>the orientation test which computes the order type of three given point.</para></listitem></itemizedlist>
</para><para>The concept <computeroutput><ref refid="classTriangulationTraits__2" kindref="compound">TriangulationTraits_2</ref></computeroutput> describes the requirements for the geometric traits class of a triangulation. The CGAL kernel classes are models for this concept. The CGAL library also provides dedicated models of <computeroutput><ref refid="classTriangulationTraits__2" kindref="compound">TriangulationTraits_2</ref></computeroutput> using the kernel geometric objects and predicates. These classes are themselves templated with a CGAL kernel and extract the required types and predicates from the kernel. The class <computeroutput><ref refid="classCGAL_1_1Projection__traits__xy__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_xy_3</ref>&lt;R&gt;</computeroutput> is a geometric traits class to build the triangulation of a terrain. Such a triangulation is a two-dimensional triangulation embedded in three dimensional space. The data points are three-dimensional points. The triangulation is build according to the projections of those points on the <formula id="58">$ xy$</formula> plane and then lifted up to the original three-dimensional data points. This is especially useful to deal with GIS terrains. Instead of really projecting the three-dimensional points and maintaining a mapping between each point and its projection (which costs space and is error prone), the traits class supplies geometric predicates that ignore the <computeroutput>z</computeroutput>-coordinates of the points. See Section <ref refid="index_1Section_2D_Triangulations_Delaunay" kindref="member">Delaunay Triangulations</ref> for an example. CGAL provides also the geometric traits classes <computeroutput><ref refid="classCGAL_1_1Projection__traits__yz__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_yz_3</ref>&lt;R&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Projection__traits__xz__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_xz_3</ref>&lt;R&gt;</computeroutput> to deal with projections on the <computeroutput>yz</computeroutput> plane and <computeroutput>xz</computeroutput>-plane, respectively.</para></sect2>
<sect2 id="index_1Subsection_2D_Triangulations_Basic_Example">
<title>Example of a Basic Triangulation</title>
<para>The following program creates a triangulation of 2D points using the default kernel <computeroutput>Exact_predicate_inexact_constructions_kernel</computeroutput> as geometric traits class and the default triangulation data structure. The input points are read from a file and inserted in the triangulation. Finally points on the convex hull are written to <computeroutput>cout</computeroutput>. <linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2triangulation_prog1_8cpp-example" kindref="compound">Triangulation_2/triangulation_prog1.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__2" kindref="compound">CGAL::Triangulation_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Vertex_circulator<sp/>Vertex_circulator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(</highlight><highlight class="stringliteral">&quot;data/triangulation_prog1.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;Point&gt;<sp/>begin(in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;Point&gt;<sp/>end;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.insert(begin,<sp/>end);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_circulator<sp/>vc<sp/>=<sp/>t.incident_vertices(t.infinite_vertex()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>done(vc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vc<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{<sp/>std::cout<sp/>&lt;&lt;<sp/>vc-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(++vc<sp/>!=<sp/>done);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Triangulation2Draw">
<title>Draw a 2D Triangulation</title>
<para><anchor id="index_1ssecDrawT2"/> A 2D triangulation can be visualized by calling the <computeroutput><ref refid="group__PkgDrawTriangulation3_1ga6a09318e75a0fb017c3ee02521f62742" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::draw()</ref></computeroutput> function as shown in the following example. This function opens a new window showing the given 2D triangulation. The function is blocking, that is the program continues as soon as the user closes the window.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2draw_triangulation_2_8cpp-example" kindref="compound">Triangulation_2/draw_triangulation_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__2" kindref="compound">CGAL::Triangulation_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(</highlight><highlight class="stringliteral">&quot;data/triangulation_prog1.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;Point&gt;<sp/>begin(in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;Point&gt;<sp/>end;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.insert(begin,<sp/>end);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgDrawTriangulation3_1ga6a09318e75a0fb017c3ee02521f62742" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::draw</ref>(t);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This function requires CGAL_Qt5, and is only available if the flag CGAL_USE_BASIC_VIEWER is defined at compile time.</para><para><anchor id="index_1fig__fig_draw_triangulation_2"/><image type="html" name="draw_triangulation_2.png"></image>
 <image type="latex" name="draw_triangulation_2.png" width="15cm"></image>
  <ref refid="index_1fig__fig_draw_triangulation_2" kindref="member">fig__fig_draw_triangulation_2</ref> Result of the run of the draw_triangulation_2 program. A window shows the 2D triangulation and allows to navigate through the scene.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1Section_2D_Triangulations_Delaunay">
<title>Delaunay Triangulations</title>
<sect2 id="index_1Subsection_2D_Triangulations_Delaunay_Description">
<title>Description</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">Delaunay_triangulation_2</ref>&lt;Traits,Tds&gt;</computeroutput> is designed to represent the Delaunay triangulation of a set of data points in the plane. A Delaunay triangulation fulfills the following <emphasis>empty circle property</emphasis> (also called <emphasis>Delaunay property</emphasis>): the circumscribing circle of any facet of the triangulation contains no data point in its interior. For a point set with no subset of four co-circular points the Delaunay triangulation is unique, it is dual to the Voronoi diagram of the set of points.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">Delaunay_triangulation_2</ref>&lt;Traits,Tds&gt;</computeroutput> derives from the class <computeroutput><ref refid="classCGAL_1_1Triangulation__2" kindref="compound">Triangulation_2</ref>&lt;Traits,Tds&gt;</computeroutput>.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">Delaunay_triangulation_2</ref>&lt;Traits,Tds&gt;</computeroutput> inherits the types defined by the basic class <computeroutput><ref refid="classCGAL_1_1Triangulation__2" kindref="compound">Triangulation_2</ref>&lt;Traits,Tds&gt;</computeroutput>. Additional types, provided by the traits class, are defined to represent the dual Voronoi diagram.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">Delaunay_triangulation_2</ref>&lt;Traits,Tds&gt;</computeroutput> overwrites the member functions that insert, move, or remove a point in the triangulation to maintain the Delaunay property. It also has a member function (<computeroutput>Vertex_handle</computeroutput> <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__2_1a30e5bdf852f888b3b2fd33e9dbfa4bcb" kindref="member">Delaunay_triangulation_2::nearest_vertex</ref></computeroutput><computeroutput>(const Point&amp; p)</computeroutput>) to answer nearest neighbor queries and member functions to construct the elements (vertices and edges) of the dual Voronoi diagram.</para><para><heading level="2">Geometric Traits </heading>
</para><para>The geometric traits class has to be a model of the concept <computeroutput><ref refid="classDelaunayTriangulationTraits__2" kindref="compound">DelaunayTriangulationTraits_2</ref></computeroutput> which refines the concept <computeroutput><ref refid="classTriangulationTraits__2" kindref="compound">TriangulationTraits_2</ref></computeroutput>. In particular this concept provides the <computeroutput>side_of_oriented_circle</computeroutput> predicate which, given four points <computeroutput>p,q,r,s</computeroutput> decides the position of the point <formula id="59">$ s$</formula> with respect to the circle passing through <formula id="14">$ p$</formula>, <formula id="60">$ q$</formula> and <formula id="49">$ r$</formula>. The <computeroutput>side_of_oriented_circle</computeroutput> predicate actually defines the Delaunay triangulation. Changing this predicate allows the user to build variant of Delaunay triangulations for different metrics such that <formula id="0">$ L_1$</formula> or <formula id="1">$ L_{\infty}$</formula> metric or any metric defined by a convex object. However, the user of an exotic metric must be careful that the constructed triangulation has to be a triangulation of the convex hull which means that convex hull edges have to be Delaunay edges. This is granted for any smooth convex metric (like <formula id="2">$ L_2$</formula>) and can be ensured for other metrics (like <formula id="1">$ L_{\infty}$</formula>) by the addition to the point set of well chosen sentinel points.</para><para>The CGAL kernel classes are models of the concept <computeroutput><ref refid="classDelaunayTriangulationTraits__2" kindref="compound">DelaunayTriangulationTraits_2</ref></computeroutput> for the Euclidean metric. The traits class for terrains, <computeroutput><ref refid="classCGAL_1_1Projection__traits__xy__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_xy_3</ref>&lt;R&gt;</computeroutput>, <computeroutput><ref refid="classCGAL_1_1Projection__traits__yz__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_yz_3</ref>&lt;R&gt;</computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Projection__traits__xz__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_xz_3</ref>&lt;R&gt;</computeroutput> are also models of <computeroutput><ref refid="classDelaunayTriangulationTraits__2" kindref="compound">DelaunayTriangulationTraits_2</ref></computeroutput> except that they do not fulfill the requirements for the duality functions and nearest vertex queries.</para><para><heading level="2">Implementation </heading>
</para><para>The insertion of a new point in the Delaunay triangulation is performed using first the insertion member function of the basic triangulation and second performing a sequence of flips to restore the Delaunay property. The number of flips that have to be performed is <formula id="3">$ O(d)$</formula> if the new vertex has degree <formula id="4">$ d$</formula> in the updated Delaunay triangulation. For points distributed uniformly at random, each insertion takes time <formula id="5">$ O(1)$</formula> on average, once the point has been located in the triangulation.</para><para>Removal calls the removal in the triangulation and then re-triangulates the hole created in such a way that the Delaunay criterion is satisfied. Removal of a vertex of degree <formula id="4">$ d$</formula> takes time <formula id="6">$ O(d^2)$</formula>. The degree <formula id="4">$ d$</formula> is <formula id="5">$ O(1)$</formula> for a random vertex in the triangulation. When the degree of the removed vertex is small ( <formula id="61">$ \leq7$</formula>) a special procedure is used that allows to decrease global removal time by a factor of 2 for random points <ref refid="citelist_1CITEREF_d-vrtdd-09" kindref="member">[4]</ref>.</para><para>The displacement of a vertex <formula id="62">$ v$</formula> at a point <formula id="14">$ p$</formula> to a new location <formula id="63">$ p&apos;$</formula>, first checks whether the triangulation embedding remains planar or not after moving <formula id="62">$ v$</formula> to <formula id="63">$ p&apos;$</formula>. If yes, it moves <formula id="62">$ v$</formula> to <formula id="63">$ p&apos;$</formula> and simply performs a sequence of flips to restore the Delaunay property, which is <formula id="3">$ O(d)$</formula> where <formula id="4">$ d$</formula> is the degree of the vertex after the displacement. Otherwise, the displacement is done by inserting a vertex at the new location, and removing the obsolete vertex. The complexity is <formula id="7">$ O(n)$</formula> in the worst case, but only <formula id="64">$ O(1 + \delta \sqrt{n})$</formula> for evenly distributed vertices in the unit square, where <formula id="65">$ \delta$</formula> is the Euclidean distance between the new and old locations.</para><para>After having performed a point location, the nearest neighbor of a point is found in time <formula id="7">$ O(n)$</formula> in the worst case, but in time <formula id="5">$ O(1)$</formula> for vertices distributed uniformly at random and any query point.</para></sect2>
<sect2 id="index_1Subsection_2D_Triangulations_Delaunay_Terrain">
<title>Example: a Delaunay Terrain</title>
<para>The following code creates a Delaunay triangulation with the usual Euclidean metric for the vertical projection of a terrain model. The points have elevation, that is they are 3D points, but the predicates used to build the Delaunay triangulation are computed using only the <formula id="47">$ x$</formula> and <formula id="48">$ y$</formula> coordinates of these points.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Projection__traits__xy__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_xy_3</ref>&lt;K&gt;</computeroutput> is part of the 2D and 3D Linear Geometric <ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2terrain_8cpp-example" kindref="compound">Triangulation_2/terrain.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Projection_traits_xy_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Projection__traits__xy__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Projection_traits_xy_3&lt;K&gt;</ref><sp/><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">CGAL::Delaunay_triangulation_2&lt;Gt&gt;</ref><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_3<sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(</highlight><highlight class="stringliteral">&quot;data/terrain.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;Point&gt;<sp/>begin(in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;Point&gt;<sp/>end;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>dt(begin,<sp/>end);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>dt.number_of_vertices()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Subsection_2D_Triangulations_Voronoi">
<title>Example: Voronoi Diagram</title>
<para>The following code computes the edges of Voronoi diagram of a set of data points and counts the number of finite edges and the number of rays of this diagram <linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2voronoi_8cpp-example" kindref="compound">Triangulation_2/voronoi.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">CGAL::Delaunay_triangulation_2&lt;K&gt;</ref><sp/><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Edge_iterator<sp/><sp/>Edge_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(</highlight><highlight class="stringliteral">&quot;data/voronoi.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;Point&gt;<sp/>begin(in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;Point&gt;<sp/>end;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(begin,<sp/>end);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ns<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nr<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Edge_iterator<sp/>eit<sp/>=T.edges_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/>;<sp/>eit<sp/>!=T.edges_end();<sp/>++eit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Object" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Object</ref><sp/>o<sp/>=<sp/>T.dual(eit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CGAL::object_cast&lt;K::Segment_2&gt;(&amp;o))<sp/>{++ns;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CGAL::object_cast&lt;K::Ray_2&gt;(&amp;o))<sp/>{++nr;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>Voronoi<sp/>diagram<sp/>has<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>ns<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>finite<sp/>edges<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>and<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>nr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>rays&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Subsection_2D_Triangulations_Cropped_Voronoi">
<title>Example: Print Voronoi Diagram Edges Restricted to a Rectangle</title>
<para>The following code computes the Delaunay triangulation of a set of points and prints the Voronoi edges restricted to a given rectangle.</para><para><anchor id="index_1fig__figurecropped_voronoi"/><image type="html" name="cropped_voronoi.png"></image>
 <image type="latex" name="cropped_voronoi.png" width="15cm"></image>
  <ref refid="index_1fig__figurecropped_voronoi" kindref="member">fig__figurecropped_voronoi</ref> Voronoi diagram (in red) of the black points restricted to the blue rectangle.  <linebreak/>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2print_cropped_voronoi_8cpp-example" kindref="compound">Triangulation_2/print_cropped_voronoi.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iterator&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Iso_rectangle_2<sp/>Iso_rectangle_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Segment_2<sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Ray_2<sp/>Ray_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Line_2<sp/>Line_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">CGAL::Delaunay_triangulation_2&lt;K&gt;</ref><sp/><sp/>Delaunay_triangulation_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//A<sp/>class<sp/>to<sp/>recover<sp/>Voronoi<sp/>diagram<sp/>from<sp/>stream.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//Rays,<sp/>lines<sp/>and<sp/>segments<sp/>are<sp/>cropped<sp/>to<sp/>a<sp/>rectangle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//so<sp/>that<sp/>only<sp/>segments<sp/>are<sp/>stored</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Cropped_voronoi_from_delaunay{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Segment_2&gt;<sp/>m_cropped_vd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Iso_rectangle_2<sp/>m_bbox;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Cropped_voronoi_from_delaunay(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Iso_rectangle_2&amp;<sp/>bbox):m_bbox(bbox){}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>RSL&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>crop_and_extract_segment(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>RSL&amp;<sp/>rsl){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Object" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Object</ref><sp/>obj<sp/>=<sp/><ref refid="group__intersection__linear__grp_1gab77f3cd98c4c4ff7acff59c98ab88ff0" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::intersection</ref>(rsl,m_bbox);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Segment_2*<sp/>s=CGAL::object_cast&lt;Segment_2&gt;(&amp;obj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(s)<sp/>m_cropped_vd.push_back(*s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__IOstreamOperators_1ga525f8afc1fb75eb966517c447f1968ea" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">operator&lt;&lt;</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Ray_2&amp;<sp/>ray)<sp/><sp/><sp/><sp/>{<sp/>crop_and_extract_segment(ray);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__IOstreamOperators_1ga525f8afc1fb75eb966517c447f1968ea" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">operator&lt;&lt;</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Line_2&amp;<sp/>line)<sp/><sp/>{<sp/>crop_and_extract_segment(line);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__IOstreamOperators_1ga525f8afc1fb75eb966517c447f1968ea" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">operator&lt;&lt;</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Segment_2&amp;<sp/>seg){<sp/>crop_and_extract_segment(seg);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//consider<sp/>some<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_2(0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_2(1,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_2(0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay_triangulation_2<sp/>dt2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//insert<sp/>points<sp/>into<sp/>the<sp/>triangulation</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>dt2.insert(points.begin(),points.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//construct<sp/>a<sp/>rectangle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Iso_rectangle_2<sp/>bbox(-1,-1,2,2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Cropped_voronoi_from_delaunay<sp/>vor(bbox);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//extract<sp/>the<sp/>cropped<sp/>Voronoi<sp/>diagram</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>dt2.draw_dual(vor);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//print<sp/>the<sp/>cropped<sp/>Voronoi<sp/>diagram<sp/>as<sp/>segments</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::copy(vor.m_cropped_vd.begin(),vor.m_cropped_vd.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ostream_iterator&lt;Segment_2&gt;(std::cout,</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Section_2D_Triangulations_Regular">
<title>Regular Triangulations</title>
<sect2 id="index_1Subsection_2D_Triangulations_Regular_Description">
<title>Description</title>
<para>Let <formula id="66">$ { PW} = \{(p_i, w_i) | i = 1, \ldots , n \}$</formula> be a set of weighted points where each <formula id="9">$ p_i$</formula> is a point and each <formula id="10">$ w_i$</formula> is a scalar called the weight of point <formula id="9">$ p_i$</formula>. Alternatively, each weighted point <formula id="11">$ (p_i, w_i)$</formula> can be regarded as a sphere (or a circle, depending on the dimensionality of <formula id="9">$ p_i$</formula>) with center <formula id="9">$ p_i$</formula> and radius <formula id="12">$ r_i=\sqrt{w_i}$</formula>.</para><para>The power diagram of the set <formula id="13">$ { PW}$</formula> is a space partition in which each cell corresponds to a sphere <formula id="11">$ (p_i, w_i)$</formula> of <formula id="13">$ { PW}$</formula> and is the locus of points <formula id="14">$ p$</formula> whose power with respect to <formula id="11">$ (p_i, w_i)$</formula> is less than its power with respect to any other sphere in <formula id="13">$ { PW}$</formula>. In the two-dimensional space, the dual of this diagram is a triangulation whose domain covers the convex hull of the set <formula id="67">$ { P}= \{ p_i | i = 1, \ldots , n \}$</formula> of center points and whose vertices form a subset of <formula id="17">$ { P}$</formula>. Such a triangulation is called a regular triangulation. Three points <formula id="18">$ p_i, p_j$</formula> and <formula id="19">$ p_k$</formula> of <formula id="17">$ { P}$</formula> form a triangle in the regular triangulation of <formula id="13">$ { PW}$</formula> iff there is a point <formula id="14">$ p$</formula> of the plane with equal powers with respect to <formula id="11">$ (p_i, w_i)$</formula>, <formula id="15">$ (p_j, w_j)$</formula> and <formula id="20">$ (p_k, w_k)$</formula> and such that this power is less than the power of <formula id="14">$ p$</formula> with respect to any other sphere in <formula id="13">$ { PW}$</formula>.</para><para>Let us defined the power product of two weighted points <formula id="11">$ (p_i, w_i)$</formula> and <formula id="15">$ (p_j, w_j)$</formula> as: <formula id="68">\[ \Pi(p_i, w_i, p_j, w_j) = p_ip_j ^2 - w_i - w_j . \]</formula> <formula id="69">$ \Pi(p_i, w_i, p_j, 0)$</formula> is simply the power of point <formula id="23">$ p_j$</formula> with respect to the sphere <formula id="11">$ (p_i, w_i)$</formula>, and two weighted points are said to be orthogonal if their power product is null. The power circle of three weighted points <formula id="11">$ (p_i, w_i)$</formula>, <formula id="15">$ (p_j, w_j)$</formula> and <formula id="20">$ (p_k, w_k)$</formula> is defined as the unique circle <formula id="24">$ (\pi, \omega)$</formula> orthogonal to <formula id="11">$ (p_i, w_i)$</formula>, <formula id="15">$ (p_j, w_j)$</formula> and <formula id="20">$ (p_k, w_k)$</formula>.</para><para>The regular triangulation of the sets <formula id="13">$ { PW}$</formula> satisfies the following <emphasis>regular property</emphasis> (which just reduces to the Delaunay property when all the weights are null): a triangle <formula id="25">$ p_ip_jp_k$</formula> is a face of the regular triangulation of <formula id="13">$ { PW}$</formula> iff the power product of any weighted point <formula id="26">$ (p_l, w_l)$</formula> of <formula id="13">$ { PW}$</formula> with the power circle of <formula id="11">$ (p_i, w_i)$</formula>, <formula id="15">$ (p_j, w_j)$</formula> and <formula id="20">$ (p_k, w_k)$</formula> is positive or null. We call power test of <formula id="11">$ (p_i, w_i)$</formula>, <formula id="15">$ (p_j, w_j)$</formula>, <formula id="20">$ (p_k, w_k)$</formula>, and <formula id="26">$ (p_l, w_l)$</formula>, the predicates which amount to compute the sign of the power product of <formula id="26">$ (p_l, w_l)$</formula> with respect to the power circle of <formula id="11">$ (p_i, w_i)$</formula>, <formula id="15">$ (p_j, w_j)$</formula> and <formula id="20">$ (p_k, w_k)$</formula>. This predicate amounts to computing the sign of the following determinant <formula id="27">\[ \left| \begin{array}{cccc} 1 &amp; x_i &amp; y_i &amp; x_i ^2 + y_i ^2 - w_i \\ 1 &amp; x_j &amp; y_j &amp; x_j ^2 + y_j ^2 - w_j \\ 1 &amp; x_k &amp; y_k &amp; x_k ^2 + y_k ^2 - w_k \\ 1 &amp; x_l &amp; y_l &amp; x_l ^2 + y_l ^2 - w_l \end{array} \right| \]</formula></para><para>A pair of neighboring faces <formula id="25">$ p_ip_jp_k$</formula> and <formula id="28">$ p_ip_jp_l$</formula> is said to be locally regular (with respect to the weights in <formula id="13">$ { PW}$</formula>) if the power test of <formula id="11">$ (p_i, w_i)$</formula>, <formula id="15">$ (p_j, w_j)$</formula>, <formula id="20">$ (p_k, w_k)$</formula>, and <formula id="26">$ (p_l, w_l)$</formula> is positive. A classical result of computational geometry establishes that a triangulation of the convex hull of <formula id="17">$ { P}$</formula> such that any pair of neighboring faces is regular with respect to <formula id="13">$ { PW}$</formula>, is a regular triangulation of <formula id="13">$ { PW}$</formula>.</para><para>Alternatively, the regular triangulation of the weighted points set <formula id="13">$ { PW}$</formula> can be obtained as the projection on the two dimensional plane of the convex hull of the set of three dimensional points <formula id="70">$ { P&apos;}= \{ (p_i,p_i ^2 - w_i ) | i = 1, \ldots , n \}$</formula>.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__2" kindref="compound">Regular_triangulation_2</ref>&lt;Traits, Tds&gt;</computeroutput> is designed to maintain the regular triangulation of a set of <formula id="71">$ 2d$</formula> weighted points. It derives from the class <computeroutput><ref refid="classCGAL_1_1Triangulation__2" kindref="compound">Triangulation_2</ref>&lt;Traits, Tds&gt;</computeroutput>. The functions <computeroutput>insert</computeroutput> and <computeroutput>remove</computeroutput> are overwritten to handle weighted points and maintain the regular property. The function <computeroutput>move()</computeroutput> is not overwritten and thus does not preserve the regular property. The vertices of the regular triangulation of a set of weighted points <formula id="72">$ {PW}$</formula> correspond only to a subset of <formula id="72">$ {PW}$</formula>. Some of the input weighted points have no cell in the dual power diagrams and therefore do not correspond to a vertex of the regular triangulation. Such a point is called a hidden point. Because hidden points can reappear later on as vertices when some other point is removed, they have to be stored somewhere. The regular triangulation store those points in special vertices, called hidden vertices. A hidden point can reappear as vertex of the triangulation only when the two dimensional face that hides it is removed from the triangulation. To deal with this feature, each face of a regular triangulation stores a list of hidden vertices. The points in those vertices are reinserted in the triangulation when the face is removed.</para><para>Regular triangulation have member functions to construct the vertices and edges of the dual power diagrams.</para></sect2>
<sect2 id="index_1Triangulation_2TheGeometricTraits">
<title>The Geometric Traits</title>
<para>The geometric traits class of a regular triangulation must provide a weighted point type and a power test on these weighted points. The concept <computeroutput><ref refid="classRegularTriangulationTraits__2" kindref="compound">RegularTriangulationTraits_2</ref></computeroutput>, is a refinement of the concept <computeroutput><ref refid="classTriangulationTraits__2" kindref="compound">TriangulationTraits_2</ref></computeroutput>. All CGAL kernels are a model for the traits concept <computeroutput><ref refid="classRegularTriangulationTraits__2" kindref="compound">RegularTriangulationTraits_2</ref></computeroutput>.</para></sect2>
<sect2 id="index_1Triangulation_2TheVertexTypeandFaceTypeof">
<title>The Vertex Type and Face Type of a Regular Triangulation</title>
<para>The base vertex type of a regular triangulation includes a Boolean data member to mark the hidden state of the vertex. Therefore CGAL defines the concept <computeroutput><ref refid="classRegularTriangulationVertexBase__2" kindref="compound">RegularTriangulationVertexBase_2</ref></computeroutput> which refine the concept <computeroutput><ref refid="classTriangulationVertexBase__2" kindref="compound">TriangulationVertexBase_2</ref></computeroutput> and provides a default model for this concept.</para><para>The face base type of a regular triangulation is required to provide a list of hidden vertices, designed to store the points hidden by the face. It has to be a model of the concept <computeroutput><ref refid="classRegularTriangulationFaceBase__2" kindref="compound">RegularTriangulationFaceBase_2</ref></computeroutput>. CGAL provides the templated class <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__face__base__2" kindref="compound">Regular_triangulation_face_base_2</ref>&lt;Traits&gt;</computeroutput> as a default base class for faces of regular triangulations.</para></sect2>
<sect2 id="index_1Subsection_2D_Triangulations_Regular_Example">
<title>Example: a Regular Triangulation</title>
<para>The following code creates a regular triangulation of a set of weighted points and output the number of vertices and the number of hidden vertices.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2regular_8cpp-example" kindref="compound">Triangulation_2/regular.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Regular_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__2" kindref="compound">CGAL::Regular_triangulation_2&lt;K&gt;</ref><sp/>Regular_triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::ifstream<sp/>in(</highlight><highlight class="stringliteral">&quot;data/regular.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Regular_triangulation::Weighted_point<sp/>wp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::vector&lt;Regular_triangulation::Weighted_point&gt;<sp/>wpoints;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(in<sp/>&gt;&gt;<sp/>wp){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>wpoints.push_back(wp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Regular_triangulation<sp/>rt(wpoints.begin(),<sp/>wpoints.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>rt.is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;number<sp/>of<sp/>inserted<sp/>points<sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>count<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;number<sp/>of<sp/>vertices<sp/>:<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>rt.number_of_vertices()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;number<sp/>of<sp/>hidden<sp/>vertices<sp/>:<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>rt.number_of_hidden_vertices()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Section_2D_Triangulations_Constrained">
<title>Constrained Triangulations</title>
<para>A constrained triangulation is a triangulation of a set of points that has to include among its edges a given set of polylines joining the points. The polylines are called <emphasis>constraints</emphasis>. The corresponding edges are called <emphasis>constrained edges</emphasis>.</para><para>The endpoints of constrained edges are of course vertices of the triangulation. However, the triangulation may include other vertices as well. There are three versions of constrained triangulations. <itemizedlist>
<listitem>
<para>In the basic version, the constrained triangulation does not handle intersecting constraints, and the set of input constraints is required to be a set of segments that do not intersect, except possibly at their endpoints. Any number of constrained edges may share the same endpoint. Constrained edges may be vertical or have zero length. </para></listitem>
<listitem>
<para>The two other versions support intersecting input constraints. In those versions, input constraints may consist of intersecting, overlapping or partially overlapping segments. The triangulation introduces additional vertices at each point that is the proper intersection point of two constraints. A single constraint intersecting other constraints will then appear as several constrained edges in the triangulation. There are two ways to deal with intersecting constraints. <itemizedlist>
<listitem>
<para>The first one is robust when predicates are evaluated exactly but constructions (i. e. intersection computations) are approximate. </para></listitem>
<listitem>
<para>The second one should be used with exact arithmetic (meaning exact evaluation of predicates and exact computation of intersections.) </para></listitem>
</itemizedlist>
</para></listitem>
</itemizedlist>
</para><para><image type="html" name="constraints.png"></image>
 <image type="latex" name="constraints.png"></image>
</para><para>A constrained triangulation is represented in the CGAL library as an object of the class <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__2" kindref="compound">Constrained_triangulation_2</ref>&lt;Traits,Tds,Itag&gt;</computeroutput>. The third parameter <computeroutput>Itag</computeroutput> is the intersection tag which serves to choose how intersecting constraints are dealt with. This parameter has to be instantiated by one of the following classes:<itemizedlist>
<listitem><para><computeroutput><ref refid="structCGAL_1_1No__intersection__tag" kindref="compound">No_intersection_tag</ref></computeroutput> when input constraints do not intersect</para></listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1Exact__predicates__tag" kindref="compound">Exact_predicates_tag</ref></computeroutput> if the geometric traits class provides exact predicates but approximate constructions</para></listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1Exact__intersections__tag" kindref="compound">Exact_intersections_tag</ref></computeroutput> when exact predicates and exact constructions are provided.</para></listitem></itemizedlist>
</para><para>The class <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__2" kindref="compound">Constrained_triangulation_2</ref>&lt;Traits,Tds, Itag&gt;</computeroutput> inherits from <computeroutput><ref refid="classCGAL_1_1Triangulation__2" kindref="compound">Triangulation_2</ref>&lt;Traits,Tds&gt;</computeroutput>. A constrained triangulation can be created from a list of pairs of points which represent the constraints.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__2" kindref="compound">Constrained_triangulation_2</ref>&lt;Traits,Tds,Itag&gt;</computeroutput> overrides the insertion and removal of a point to take care of the information about constrained edges. The class also allows the user online insertion of a new constraint, given as sequence of points, or the removal of a constraint. In the current version, the function <computeroutput>move()</computeroutput> is not overwritten and thus does not handle vertices of constraints.</para><para>In order to retrieve the constrained edges of a constraint, or the constraints overlapping with a constrained edge, we provide the class <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__plus__2" kindref="compound">Constrained_triangulation_plus_2</ref></computeroutput>. See Section <ref refid="index_1Section_2D_Triangulations_Constrained_Plus" kindref="member">Constrained Triangulations with a Bidirectional Mapping between Constraints and Subconstraints</ref> for details. This class should also be used when doing exact intersection computations as it avoids the cascading of intersection computations.</para><sect2 id="index_1Triangulation_2TheGeometricTraits_1">
<title>The Geometric Traits</title>
<para>The geometric traits class of a constraint triangulation has to be a model of the concept <computeroutput><ref refid="classTriangulationTraits__2" kindref="compound">TriangulationTraits_2</ref></computeroutput>. When intersections of input constraints are supported, the geometric traits class has to be a model of the concept <computeroutput><ref refid="classConstrainedTriangulationTraits__2" kindref="compound">ConstrainedTriangulationTraits_2</ref></computeroutput>, which refines the concept <computeroutput><ref refid="classTriangulationTraits__2" kindref="compound">TriangulationTraits_2</ref></computeroutput> providing additional function object types to compute the intersection of two segments.</para></sect2>
<sect2 id="index_1Triangulation_2TheFaceBaseClassofaConstrained">
<title>The Face Base Class of a Constrained Triangulation</title>
<para>The information about constrained edges is stored in the faces of the triangulation. The face base of a Constrained Triangulation has to be a model for the concept <computeroutput><ref refid="classConstrainedTriangulationFaceBase__2" kindref="compound">ConstrainedTriangulationFaceBase_2</ref></computeroutput> which refines the concept <computeroutput><ref refid="classTriangulationFaceBase__2" kindref="compound">TriangulationFaceBase_2</ref></computeroutput>. The concept <computeroutput><ref refid="classConstrainedTriangulationFaceBase__2" kindref="compound">ConstrainedTriangulationFaceBase_2</ref></computeroutput> requires member functions that get and set the constrained status of the edges.</para><para>CGAL provides a default face base class for constrained triangulations. This class, named <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__face__base__2" kindref="compound">Constrained_triangulation_face_base_2</ref>&lt;Traits&gt;</computeroutput>, derives from the class <computeroutput><ref refid="classCGAL_1_1Triangulation__face__base__2" kindref="compound">Triangulation_face_base_2</ref>&lt;Traits&gt;</computeroutput> and adds three Boolean data members to store the status of its edges.</para><para><anchor id="index_1fig__Triangulation_2D_Fig_constrained"/><image type="html" name="poisson_del_poisson.svg"></image>
 <image type="latex" name="poisson_del_poisson.svg" width="15cm"></image>
  <ref refid="index_1fig__Triangulation_2D_Fig_constrained" kindref="member">fig__Triangulation_2D_Fig_constrained</ref> Constrained and Constrained Delaunay triangulation: the constraining edges are the black edges, a constrained triangulation is shown on the left, the constrained Delaunay triangulation with two examples of circumcircles is shown on the right.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1Section_2D_Triangulations_Constrained_Delaunay">
<title>Constrained Delaunay Triangulations</title>
<para>A constrained Delaunay triangulation is a triangulation with constrained edges which try to be as much Delaunay as possible. As constrained edges are not necessarily Delaunay edges, the triangles of a constrained Delaunay triangulation do not necessarily fulfill the empty circle property but they fulfill a weaker <emphasis>constrained empty circle property</emphasis>. To state this property, it is convenient to think of constrained edges as blocking the view. Then, a triangulation is constrained Delaunay iff the circumscribing circle of any facet encloses no vertex visible from the interior of the facet. As in the case of constrained triangulations, three different versions of Delaunay constrained triangulations are provided. The first version handles a set of constraints which do not intersect except possibly at the endpoints. The two other versions handle intersecting input constraints. One of them is designed to be robust when used in conjunction with a geometric traits class providing exact predicates and approximate constructions (such as a <computeroutput><ref refid="structCGAL_1_1Filtered__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Filtered_kernel</ref></computeroutput> or any kernel providing filtered exact predicates). The third version is designed to be used with an exact arithmetic number type.</para><para>The CGAL class <computeroutput><ref refid="classCGAL_1_1Constrained__Delaunay__triangulation__2" kindref="compound">Constrained_Delaunay_triangulation_2</ref>&lt;Traits,Tds,Itag&gt;</computeroutput> is designed to represent constrained Delaunay triangulations.</para><para>As in the case of constrained triangulations, the third parameter <computeroutput>Itag</computeroutput> is the intersection tag and serves to choose how intersecting constraints are dealt with. It can be instantiated with one of the following classes: <computeroutput><ref refid="structCGAL_1_1No__intersection__tag" kindref="compound">No_intersection_tag</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Exact__predicates__tag" kindref="compound">Exact_predicates_tag</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Exact__intersections__tag" kindref="compound">Exact_intersections_tag</ref></computeroutput> (see Section <ref refid="index_1Section_2D_Triangulations_Constrained" kindref="member">Constrained Triangulations</ref>).</para><para>A constrained Delaunay triangulation is not a Delaunay triangulation but it is a constrained triangulation. Therefore the class <computeroutput><ref refid="classCGAL_1_1Constrained__Delaunay__triangulation__2" kindref="compound">Constrained_Delaunay_triangulation_2</ref>&lt;Traits,Tds,Itag&gt;</computeroutput> derives from the class <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__2" kindref="compound">Constrained_triangulation_2</ref>&lt;Traits,Tds,Itag&gt;</computeroutput>.</para><para>The constrained Delaunay triangulation has member functions to override the insertion and removal of a point or of a constraint. Each of those member functions takes care to restore the constrained empty circle property.</para><sect2 id="index_1Triangulation_2TheGeometricTraits_2">
<title>The Geometric Traits</title>
<para>The geometric traits class of a constrained Delaunay triangulation is required to provide the <computeroutput>side_of_oriented_circle</computeroutput> predicate as the geometric traits class of a Delaunay triangulation, and has to be a model of the concept <computeroutput><ref refid="classDelaunayTriangulationTraits__2" kindref="compound">DelaunayTriangulationTraits_2</ref></computeroutput>. When intersecting input constraints is supported, the geometric traits class is further required to provide function objects to compute constraints intersections. Then, the geometric traits class has to be at the same time a model of the concept <computeroutput><ref refid="classConstrainedTriangulationTraits__2" kindref="compound">ConstrainedTriangulationTraits_2</ref></computeroutput>.</para></sect2>
<sect2 id="index_1Triangulation_2TheFaceBaseClass">
<title>The Face Base Class</title>
<para>Information about the status (constrained or not) of the edges of the triangulation has to be stored in the face class, and the face base class of a constrained Delaunay triangulation has to be a model of <computeroutput><ref refid="classConstrainedTriangulationFaceBase__2" kindref="compound">ConstrainedTriangulationFaceBase_2</ref></computeroutput>.</para></sect2>
<sect2 id="index_1Subsection_2D_Triangulations_Constrained_Delaunay_Example">
<title>Example: a Constrained Delaunay Triangulation</title>
<para>The following code inserts a set of intersecting constraint segments into a triangulation and counts the number of constrained edges of the resulting triangulation.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2constrained_8cpp-example" kindref="compound">Triangulation_2/constrained.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Exact__predicates__tag" kindref="compound">CGAL::Exact_predicates_tag</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Itag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Constrained__Delaunay__triangulation__2" kindref="compound">CGAL::Constrained_Delaunay_triangulation_2&lt;K, CGAL::Default, Itag&gt;</ref><sp/>CDT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CDT::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">main(<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CDT<sp/>cdt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Inserting<sp/>a<sp/>grid<sp/>of<sp/>5x5<sp/>constraints<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>1;<sp/>i<sp/>&lt;<sp/>6;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cdt.<ref refid="classCGAL_1_1Constrained__Delaunay__triangulation__2_1a4374cf307382b6ceee07db4bdc1e4e61" kindref="member">insert_constraint</ref>(<sp/>Point(0,i),<sp/>Point(6,i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>1;<sp/>j<sp/>&lt;<sp/>6;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cdt.insert_constraint(<sp/>Point(j,0),<sp/>Point(j,6));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(cdt.is_valid());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(CDT::Finite_edges_iterator<sp/>eit<sp/>=<sp/>cdt.finite_edges_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>eit<sp/>!=<sp/>cdt.finite_edges_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++eit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(cdt.is_constrained(*eit))<sp/>++count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>number<sp/>of<sp/>resulting<sp/>constrained<sp/>edges<sp/>is<sp/><sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/><sp/>count<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Subsection_2D_Triangulations_Polygon_triangulation">
<title>Example: Triangulating a Polygonal Domain</title>
<para>The following code inserts two nested polygons into a constrained Delaunay triangulation and counts the number of facets that are inside the domain delimited by these polygons. Note that the following code does not work if the boundaries of the polygons intersect.</para><para><anchor id="index_1fig__figuretri_domain"/><image type="html" name="tri_domain.png"></image>
 <image type="latex" name="tri_domain.png" width="15cm"></image>
  <ref refid="index_1fig__figuretri_domain" kindref="member">fig__figuretri_domain</ref> Triangulation (in blue) of the domain delimited by the red polygons.  <linebreak/>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2polygon_triangulation_8cpp-example" kindref="compound">Triangulation_2/polygon_triangulation.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_face_base_with_info_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">FaceInfo2</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FaceInfo2(){}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nesting_level;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>in_domain(){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>nesting_level%2<sp/>==<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__2" kindref="compound">CGAL::Triangulation_vertex_base_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__face__base__with__info__2" kindref="compound">CGAL::Triangulation_face_base_with_info_2&lt;FaceInfo2,K&gt;</ref><sp/><sp/><sp/><sp/>Fbb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Constrained__triangulation__face__base__2" kindref="compound">CGAL::Constrained_triangulation_face_base_2&lt;K,Fbb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TDS;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Exact__predicates__tag" kindref="compound">CGAL::Exact_predicates_tag</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Itag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Constrained__Delaunay__triangulation__2" kindref="compound">CGAL::Constrained_Delaunay_triangulation_2&lt;K, TDS, Itag&gt;</ref><sp/><sp/>CDT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CDT::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">mark_domains(CDT&amp;<sp/>ct,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CDT::Face_handle<sp/>start,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::list&lt;CDT::Edge&gt;&amp;<sp/>border<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(start-&gt;info().nesting_level<sp/>!=<sp/>-1){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;CDT::Face_handle&gt;<sp/>queue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue.push_back(start);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(!<sp/>queue.empty()){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CDT::Face_handle<sp/>fh<sp/>=<sp/>queue.front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>queue.pop_front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(fh-&gt;info().nesting_level<sp/>==<sp/>-1){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>fh-&gt;info().nesting_level<sp/>=<sp/>index;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>3;<sp/>i++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CDT::Edge<sp/>e(fh,i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CDT::Face_handle<sp/>n<sp/>=<sp/>fh-&gt;neighbor(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(n-&gt;info().nesting_level<sp/>==<sp/>-1){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(ct.is_constrained(e))<sp/>border.push_back(e);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>queue.push_back(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//explore<sp/>set<sp/>of<sp/>facets<sp/>connected<sp/>with<sp/>non<sp/>constrained<sp/>edges,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//and<sp/>attribute<sp/>to<sp/>each<sp/>such<sp/>set<sp/>a<sp/>nesting<sp/>level.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//We<sp/>start<sp/>from<sp/>facets<sp/>incident<sp/>to<sp/>the<sp/>infinite<sp/>vertex,<sp/>with<sp/>a<sp/>nesting</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//level<sp/>of<sp/>0.<sp/>Then<sp/>we<sp/>recursively<sp/>consider<sp/>the<sp/>non-explored<sp/>facets<sp/>incident<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//to<sp/>constrained<sp/>edges<sp/>bounding<sp/>the<sp/>former<sp/>set<sp/>and<sp/>increase<sp/>the<sp/>nesting<sp/>level<sp/>by<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//Facets<sp/>in<sp/>the<sp/>domain<sp/>are<sp/>those<sp/>with<sp/>an<sp/>odd<sp/>nesting<sp/>level.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">mark_domains(CDT&amp;<sp/>cdt)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(CDT::All_faces_iterator<sp/>it<sp/>=<sp/>cdt.all_faces_begin();<sp/>it<sp/>!=<sp/>cdt.all_faces_end();<sp/>++it){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>it-&gt;info().nesting_level<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;CDT::Edge&gt;<sp/>border;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mark_domains(cdt,<sp/>cdt.infinite_face(),<sp/>0,<sp/>border);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(!<sp/>border.empty()){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CDT::Edge<sp/>e<sp/>=<sp/>border.front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>border.pop_front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CDT::Face_handle<sp/>n<sp/>=<sp/>e.first-&gt;neighbor(e.second);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(n-&gt;info().nesting_level<sp/>==<sp/>-1){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mark_domains(cdt,<sp/>n,<sp/>e.first-&gt;info().nesting_level+1,<sp/>border);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//construct<sp/>two<sp/>non-intersecting<sp/>nested<sp/>polygons<sp/><sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>polygon1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon1.push_back(Point(0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon1.push_back(Point(2,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon1.push_back(Point(2,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon1.push_back(Point(0,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>polygon2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon2.push_back(Point(0.5,0.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon2.push_back(Point(1.5,0.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon2.push_back(Point(1.5,1.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon2.push_back(Point(0.5,1.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Insert<sp/>the<sp/>polygons<sp/>into<sp/>a<sp/>constrained<sp/>triangulation</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CDT<sp/>cdt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cdt.insert_constraint(polygon1.vertices_begin(),<sp/>polygon1.vertices_end(),<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cdt.insert_constraint(polygon2.vertices_begin(),<sp/>polygon2.vertices_end(),<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Mark<sp/>facets<sp/>that<sp/>are<sp/>inside<sp/>the<sp/>domain<sp/>bounded<sp/>by<sp/>the<sp/>polygon</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mark_domains(cdt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(CDT::Finite_faces_iterator<sp/>fit=cdt.finite_faces_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fit!=cdt.finite_faces_end();++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>fit-&gt;info().in_domain()<sp/>)<sp/>++count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;There<sp/>are<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>count<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>facets<sp/>in<sp/>the<sp/>domain.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Section_2D_Triangulations_Constrained_Plus">
<title>Constrained Triangulations with a Bidirectional Mapping between Constraints and Subconstraints</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__plus__2" kindref="compound">Constrained_triangulation_plus_2</ref>&lt;Tr&gt;</computeroutput> provides a constrained triangulation with an additional data structure that keeps track of the input constraints and of their refinement in the triangulation. The class <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__plus__2" kindref="compound">Constrained_triangulation_plus_2</ref>&lt;Tr&gt;</computeroutput> inherits from its template parameter Tr, which has to be instantiated by a constrained or constrained Delaunay triangulation. According to its intersection tag, the base class will support intersecting input constraints or not. When intersections of input constraints are supported, the base class constructs a triangulation of the arrangement of the constraints, introducing new vertices at each proper intersection point.</para><para>The triangulation maintains for each input constraint the sequence of vertices on this constraint. These vertices are either vertices of the input constraint or intersection points.</para><para>Two consecutive vertices of an input constraint form a <emphasis>subconstraint</emphasis>. The triangulation enables the retrieval of the set of subconstraints of the triangulation (not ordered along constraints).</para><para>It further enables the retrieval of the set of input constraints that induce a subconstraint. As it is straightforward to obtain a subconstraint from a constrained edge <computeroutput>e</computeroutput>, one can easily obtain the input constraints that induce <computeroutput>e</computeroutput>.</para><sect2 id="index_1Subsection_Edges_and_Constraints">
<title>Edges, Constrained Edges, Constraints, and Subconstraints</title>
<para>All triangulation classes define the type <computeroutput>Edge</computeroutput> as <computeroutput>typedef std::pair&lt;Face_handle, int&gt; Edge</computeroutput>. For a pair <computeroutput>(fh,i)</computeroutput> it is the edge of the face <computeroutput>*fh</computeroutput>, which is opposite to the <computeroutput>i</computeroutput>&apos;th vertex.</para><para>A <emphasis>constrained edge</emphasis> <computeroutput>e</computeroutput> is an edge of a constrained triangulation <computeroutput>ct</computeroutput>, for which <computeroutput>ct.is_constrained(e)</computeroutput> returns <computeroutput>true</computeroutput>.</para><para>A <emphasis>constraint</emphasis> is a polyline which is given as input (in the simplest case just a segment), and which is split into constrained edges in the triangulation.</para><para>The type <computeroutput>Subconstraint</computeroutput> is defined as <computeroutput>typedef std::pair&lt;Vertex_handle,Vertex_handle&gt; Subconstraint</computeroutput>. The two vertex handles must be the vertices of a constrained edge.</para><para>The type <computeroutput>Constraint_id</computeroutput> identifies a constraint.</para><para>All constrained triangulation classes of CGAL provide functions to insert constraints, have the notion of constrained edges, and offer a <computeroutput>Constrained_edges_iterator</computeroutput>.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__plus__2" kindref="compound">Constrained_triangulation_plus_2</ref></computeroutput> additionally provides the means to<itemizedlist>
<listitem><para>traverse all the constraints of the triangulation using an iterator of type <computeroutput>Constraint_iterator</computeroutput> the value type of which is <computeroutput>Constraint_id</computeroutput>,</para></listitem><listitem><para>obtain all constraints that induce a constrained edge or a subconstraint,</para></listitem><listitem><para>traverse the sequence of vertices of a constraint using an iterator of type <computeroutput>Vertices_in_constraint_iterator</computeroutput>, the value type of which is <computeroutput>Vertex_handle</computeroutput></para></listitem><listitem><para>traverse the subconstraints in the triangulation using an iterator of type <computeroutput>Subconstraint_iterator</computeroutput>,the value type of which is <computeroutput>Subconstraint</computeroutput>.</para></listitem></itemizedlist>
</para><para>Note that the <computeroutput>Constrained_edges_iterator</computeroutput> and the <computeroutput>Subconstraint_iterator</computeroutput> are quite similar. The <computeroutput>Constrained_edges_iterator</computeroutput> traverses all edges and skips those that are <emphasis>not</emphasis> constrained, which means that the time of traversal will be linear in the number of total edges. whereas the <computeroutput>Subconstraint_iterator</computeroutput> traverses a set of subconstraints stored in the triangulation.</para><para>On the other hand, as a subconstraint is only a pair of vertex handles, determining the corresponding <computeroutput>Edge</computeroutput> takes the smaller degree of the two vertices, wheresas obtaining an Edge from a subconstraint is a constant time operation.</para></sect2>
<sect2 id="index_1Subsection_Constrained_plus_avoids_cascacding">
<title>The Intersection Tag</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__plus__2" kindref="compound">Constrained_triangulation_plus_2</ref>&lt;Tr&gt;</computeroutput> is especially useful when the base constrained triangulation class handles intersections of constraints and uses an exact number type, i.e. when its intersection tag is <computeroutput><ref refid="structCGAL_1_1Exact__intersections__tag" kindref="compound">Exact_intersections_tag</ref></computeroutput>. In this case, the <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__plus__2" kindref="compound">Constrained_triangulation_plus_2</ref>&lt;Tr&gt;</computeroutput> avoids cascading in the computations of intersection points.</para><para>This is best explained with an example.</para><para><anchor id="index_1fig__figuretri_avoidcascading"/><image type="html" name="CDTplusAvoidCascading.png"></image>
 <image type="latex" name="CDTplusAvoidCascading.png" width="15cm"></image>
  <ref refid="index_1fig__figuretri_avoidcascading" kindref="member">fig__figuretri_avoidcascading</ref> Computation of an intersection with an input constraint instead of with an edge.  <linebreak/>
</para><para>When inserting a constraint, say a segment <computeroutput>s</computeroutput> in the triangulation, this segment may intersect a constrained edge <computeroutput>e</computeroutput> with the vertices <computeroutput>p</computeroutput> and <computeroutput>q</computeroutput>. The algorithm could compute the intersection point <computeroutput>i</computeroutput> of <computeroutput>s</computeroutput> with the segment <computeroutput>[p,q]</computeroutput>. Because these points may be previously constructed intersection points, as <computeroutput>q</computeroutput> in the figure above, it is better to use an input constraint <computeroutput>c</computeroutput> that induce the edge. If <computeroutput>c</computeroutput> is a segment, the algorithm intersects <computeroutput>s</computeroutput> with <computeroutput>c</computeroutput>. If <computeroutput>c</computeroutput> is a polyline, the algorithm finds two vertices from the input constraint that define an input segment that induce <computeroutput>e</computeroutput>.</para></sect2>
<sect2 id="index_1Triangulation_2ExampleBuildingaTriangulated">
<title>Example: Building a Triangulated Arrangement of Polylines</title>
<para>The following code inserts two polyline constraints into a triangulation. Note that if the triangulation supports intersections we can have arbitrary complicated overlapping polylines. They can share any number of edges, and a polyline may pass several times through the same edge.</para><para>For an edge we can further find out how many and which polyline constraints pass through it. For an edge we can obtain an iterator range with value type <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__plus__2_1_1Context" kindref="compound">Constrained_triangulation_plus_2::Context</ref></computeroutput>. From a context we can obtain the <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__plus__2_1a136e59f7ed41cac6f861ae614bba1f3d" kindref="member">Constrained_triangulation_plus_2::Constraint_id</ref></computeroutput>, and an iterator pointing at the vertex in the polyline constraint that passes through the edge.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2polylines_triangulation_8cpp-example" kindref="compound">Triangulation_2/polylines_triangulation.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Constrained_triangulation_plus_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Exact__intersections__tag" kindref="compound">CGAL::Exact_intersections_tag</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Itag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Constrained__Delaunay__triangulation__2" kindref="compound">CGAL::Constrained_Delaunay_triangulation_2&lt;K,CGAL::Default, Itag&gt;</ref><sp/>CDT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Constrained__triangulation__plus__2" kindref="compound">CGAL::Constrained_triangulation_plus_2&lt;CDT&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CDTP;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CDTP::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CDTP::Constraint_id<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cid;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CDTP::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">print(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>CDTP&amp;<sp/>cdtp,<sp/>Cid<sp/>cid)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CDTP::Vertices_in_constraint<sp/>Vertices_in_constraint;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Polyline<sp/>constraint:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Vertices_in_constraint<sp/>it<sp/>=<sp/>cdtp.vertices_in_constraint_begin(cid);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>!=cdtp.vertices_in_constraint_end(cid);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>it++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vertex_handle<sp/>vh<sp/>=<sp/>*it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>vh-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">contexts(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>CDTP&amp;<sp/>cdtp)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CDTP::Subconstraint_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>beg<sp/>=<sp/>cdtp.<ref refid="classCGAL_1_1Constrained__triangulation__plus__2_1ad02088fd486bc5b753d8fc781e867630" kindref="member">subconstraints_begin</ref>(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>end<sp/>=<sp/>cdtp.subconstraints_end();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(;<sp/>beg!=end;<sp/>++beg){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vertex_handle<sp/>vp<sp/>=<sp/>beg-&gt;first.first,<sp/>vq<sp/>=<sp/>beg-&gt;first.second;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(cdtp.number_of_enclosing_constraints(vp,<sp/>vq)<sp/>==<sp/>2){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CDTP::Context_iterator<sp/>cbeg<sp/>=<sp/>cdtp.contexts_begin(vp,vq),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cend<sp/>=<sp/>cdtp.contexts_end(vp,vq);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;subconstraint<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vp-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vq-&gt;point()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>is<sp/>on<sp/>constraints<sp/>starting<sp/>at:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(;<sp/>cbeg<sp/>!=<sp/><sp/>cend;<sp/>++cbeg){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CDTP::Context<sp/>c<sp/>=<sp/>*cbeg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>(*(c.vertices_begin()))-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">main(<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CDTP<sp/>cdtp;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cdtp.insert_constraint(Point(0,0),<sp/>Point(1,1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(1,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(5,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(6,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(3,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Cid<sp/>id1<sp/>=<sp/>cdtp.insert_constraint(points.begin(),<sp/>points.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print(cdtp,<sp/>id1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>poly;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(Point(2,3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(Point(4,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(Point(5,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>poly.push_back(Point(6,2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Cid<sp/>id2<sp/>=<sp/>cdtp.insert_constraint(poly.vertices_begin(),<sp/>poly.vertices_end(),<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print(cdtp,<sp/>id1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print(cdtp,<sp/>id2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>contexts(cdtp);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Section_2D_Triangulations_Hierarchy">
<title>The Triangulation Hierarchy</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Triangulation__hierarchy__2" kindref="compound">Triangulation_hierarchy_2</ref>&lt;Tr&gt;</computeroutput> implements a triangulation augmented with a data structure to efficiently answer point location queries. The data structure is a hierarchy of triangulations. The triangulation at the lowest level is the original triangulation where operations and point location are to be performed. Then at each succeeding level, the data structure stores a triangulation of a small random sample of the vertices of the triangulation at the preceding level. Point location is done through a top down nearest neighbor query. The nearest neighbor query is first performed naively in the top level triangulation. Then, at each following level, the nearest neighbor at that level is found through a linear walk performed from the nearest neighbor found at the preceding level. Because the number of vertices in each triangulation is only a small fraction of the number of vertices of the preceding triangulation, the data structure remains small and achieves fast point location queries on real data. As proved in <ref refid="citelist_1CITEREF_d-iirdt-98" kindref="member">[3]</ref>, this structure has an optimal behavior when it is built for Delaunay triangulations. However, it can be used as well for other triangulations and the class <computeroutput><ref refid="classCGAL_1_1Triangulation__hierarchy__2" kindref="compound">Triangulation_hierarchy_2</ref>&lt;Tr&gt;</computeroutput> is templated by a parameter which is to be instantiated by one of the CGAL triangulation classes.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Triangulation__hierarchy__2" kindref="compound">Triangulation_hierarchy_2</ref>&lt;Tr&gt;</computeroutput> inherits from the triangulation type passed as template parameter <computeroutput>Tr</computeroutput>. The <computeroutput>insert</computeroutput>, <computeroutput>move</computeroutput>, and <computeroutput>remove</computeroutput> member functions are overwritten to update the data structure at each operation. The locate queries are also overwritten to take advantage of the data structure for a fast processing.</para><sect2 id="index_1Triangulation_2TheVertexofaTriangulation">
<title>The Vertex of a Triangulation Hierarchy</title>
<para>The base vertex class of a triangulation hierarchy has to be a model of the concept <computeroutput><ref refid="classTriangulationHierarchyVertexBase__2" kindref="compound">TriangulationHierarchyVertexBase_2</ref></computeroutput> which extends the concept <computeroutput><ref refid="classTriangulationVertexBase__2" kindref="compound">TriangulationVertexBase_2</ref></computeroutput>. This extension adds access and setting member functions for two pointers to the corresponding vertices in the triangulations of the next and preceding levels.</para><para>CGAL provides the class <computeroutput><ref refid="classCGAL_1_1Triangulation__hierarchy__vertex__base__2" kindref="compound">Triangulation_hierarchy_vertex_base_2</ref>&lt;Vb&gt;</computeroutput> which is a model for the concept <computeroutput><ref refid="classTriangulationHierarchyVertexBase__2" kindref="compound">TriangulationHierarchyVertexBase_2</ref></computeroutput>. This class is templated by a parameter <computeroutput>Vb</computeroutput> which is to be instantiated by a model of the concept <computeroutput><ref refid="classTriangulationVertexBase__2" kindref="compound">TriangulationVertexBase_2</ref></computeroutput>. The class <computeroutput><ref refid="classCGAL_1_1Triangulation__hierarchy__vertex__base__2" kindref="compound">Triangulation_hierarchy_vertex_base_2</ref>&lt;Vb&gt;</computeroutput> inherits from its template parameter <computeroutput>Vb</computeroutput>. This design enables the usage of either the default vertex class or a user customized vertex class with additional functionalities for <computeroutput>Vb</computeroutput>.</para></sect2>
<sect2 id="index_1Subsection_2D_Triangulations_Hierarchy_Examples">
<title>Examples For the Use of a Triangulation Hierarchy</title>
<para>The following program is an example for the standard use of a triangulation hierarchy to enhance the efficiency of a Delaunay triangulation. The program outputs the number of vertices at the different levels of the hierarchy. <linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2hierarchy_8cpp-example" kindref="compound">Triangulation_2/hierarchy.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_hierarchy_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/algorithm.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__2" kindref="compound">CGAL::Triangulation_vertex_base_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vbb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__hierarchy__vertex__base__2" kindref="compound">CGAL::Triangulation_hierarchy_vertex_base_2&lt;Vbb&gt;</ref><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__face__base__2" kindref="compound">CGAL::Triangulation_face_base_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">CGAL::Delaunay_triangulation_2&lt;K,Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__hierarchy__2" kindref="compound">CGAL::Triangulation_hierarchy_2&lt;Dt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;double,Point&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;insertion<sp/>of<sp/>1000<sp/>random<sp/>points&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_square_2&lt;Point,Creator&gt;<sp/>g(1.);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__STLAlgos_1gadba21cc5c30a79519438dfe0f9264255" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::copy_n</ref>(<sp/>g,<sp/>1000,<sp/>std::back_inserter(t));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//verbose<sp/>mode<sp/>of<sp/>is_valid<sp/>;<sp/>shows<sp/>the<sp/>number<sp/>of<sp/>vertices<sp/>at<sp/>each<sp/><sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>number<sp/>of<sp/>vertices<sp/>at<sp/>successive<sp/>levels&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(t.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The following program shows how to use a triangulation hierarchy in conjunction with a constrained triangulation with a constaint hierarchy.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2constrained_hierarchy_plus_8cpp-example" kindref="compound">Triangulation_2/constrained_hierarchy_plus.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_hierarchy_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Constrained_triangulation_plus_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__2" kindref="compound">CGAL::Triangulation_vertex_base_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vbb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__hierarchy__vertex__base__2" kindref="compound">CGAL::Triangulation_hierarchy_vertex_base_2&lt;Vbb&gt;</ref><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Constrained__triangulation__face__base__2" kindref="compound">CGAL::Constrained_triangulation_face_base_2&lt;K&gt;</ref><sp/><sp/><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>TDS;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Exact__predicates__tag" kindref="compound">CGAL::Exact_predicates_tag</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Itag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Constrained__Delaunay__triangulation__2" kindref="compound">CGAL::Constrained_Delaunay_triangulation_2&lt;K,TDS,Itag&gt;</ref><sp/>CDT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__hierarchy__2" kindref="compound">CGAL::Triangulation_hierarchy_2&lt;CDT&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CDTH;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Constrained__triangulation__plus__2" kindref="compound">CGAL::Constrained_triangulation_plus_2&lt;CDTH&gt;</ref><sp/><sp/><sp/><sp/><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">main(<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>cdt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Inserting<sp/>a<sp/>grid<sp/>5<sp/>x<sp/>5<sp/>of<sp/><sp/>constraints<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>1;<sp/>i<sp/>&lt;<sp/>6;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cdt.<ref refid="classCGAL_1_1Constrained__triangulation__plus__2_1aa8870c3ead46efaac0c7c7f3916b4ed5" kindref="member">insert_constraint</ref>(<sp/>Point(0,i),<sp/>Point(6,i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>1;<sp/>j<sp/>&lt;<sp/>6;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cdt.insert_constraint(<sp/>Point(j,0),<sp/>Point(j,6));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Triangulation::Subconstraint_iterator<sp/>scit<sp/>=<sp/>cdt.subconstraints_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scit<sp/>!=<sp/>cdt.subconstraints_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++scit)<sp/><sp/>++count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>number<sp/>of<sp/>resulting<sp/>constrained<sp/>edges<sp/>is<sp/><sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/><sp/>count<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//verbose<sp/>mode<sp/>of<sp/>is_valid<sp/>;<sp/>shows<sp/>the<sp/>number<sp/>of<sp/>vertices<sp/>at<sp/>each<sp/><sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>number<sp/>of<sp/>vertices<sp/>at<sp/>successive<sp/>levels&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(cdt.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Section_2D_Triangulations_Flexibility">
<title>Flexibility</title>
<sect2 id="index_1Triangulation_2UsingCustomizedVerticesand">
<title>Using Customized Vertices and Faces</title>
<para>To be able to adapt to various needs, a highly flexible design has been selected for 2D triangulations. We have already seen that the triangulation classes have two parameters: a geometric traits class and a triangulation data structure class which the user can instantiate with his own customized classes.</para><para>The most useful flexibility however comes from the fact that the triangulation data structure itself has two template parameters to be instantiated by classes for the vertices and faces of the triangulation. Using his own customized classes to instantiate these parameters, the user can easily build up a triangulation with additional information or functionality in the vertices and faces.</para></sect2>
<sect2 id="index_1Triangulation_2ACyclicDependency">
<title>A Cyclic Dependency</title>
<para>To insure flexibility, the triangulation data structure is templated by the vertex and face base classes. Also since incidence and adjacency relations are stored in vertices and faces, the base classes have to know the types of handles on vertices and faces provided by the triangulation data structure. Thus the vertex and face base classes have to be themselves parameterized by the triangulation data structure, and there is a cyclic dependency on template parameter.</para><para><anchor id="index_1fig__Triangulation_2D_Fig_three_levels_2"/><image type="html" name="threelevels2.png"></image>
 <image type="latex" name="threelevels2.png" width="15cm"></image>
  <ref refid="index_1fig__Triangulation_2D_Fig_three_levels_2" kindref="member">fig__Triangulation_2D_Fig_three_levels_2</ref> The cyclic dependency in triangulations software design.  <linebreak/>
</para><para>Previously, this cyclic dependency was avoided by using only <computeroutput>void*</computeroutput> pointers in the interface of base classes. These <computeroutput>void*</computeroutput> were converted to appropriate types at the triangulation data structure levels. This solution had some drawbacks : mainly the user could not add in the vertices or faces of the triangulation a functionality related to types defined by the triangulation data structure, for instance a handle to a vertex, and he was lead to use himself <computeroutput>void*</computeroutput> pointers). The new solution to resolve the template dependency is based on a rebind mechanism similar to the mechanism used in the standard allocator class std::allocator. The rebind mechanism is described in Section <ref refid="index_1TDS_2D_default" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">The Default Triangulation Data Structure</ref> of Chapter <ref refid="index_1Chapter_2D_Triangulation_Data_Structure" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">2D Triangulation Data Structure</ref>. For now, we will just notice that the design requires the existence in the vertex and face base classes of a nested template class <computeroutput>Rebind_TDS</computeroutput> defining a type <computeroutput>Other</computeroutput> used by the rebinding mechanism.</para><para>The two following examples show how the user can put in use the flexibility offered by the base classes parameters.</para></sect2>
<sect2 id="index_1Triangulation_2AddingColors">
<title>Adding Colors</title>
<para>The first example corresponds to a case where the user wishes to add in the vertices or faces of the triangulation an additional information that does not depend on types provided by the triangulation data structure. In that case, predefined classes <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__2" kindref="compound">Triangulation_vertex_base_with_info_2</ref>&lt;Info,Traits,Vb&gt;</computeroutput> or <computeroutput><ref refid="classCGAL_1_1Triangulation__face__base__with__info__2" kindref="compound">Triangulation_face_base_with_info_2</ref>&lt;Info,Traits,Vb&gt;</computeroutput> can be used. Those classes have a template parameter <computeroutput>Info</computeroutput> devoted to handle additional information. The following example shows how to add a <computeroutput><ref refid="classCGAL_1_1Color" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">Color</ref></computeroutput> in the triangulation faces.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2colored_face_8cpp-example" kindref="compound">Triangulation_2/colored_face.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Color.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_face_base_with_info_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__2" kindref="compound">CGAL::Triangulation_vertex_base_2&lt;K&gt;</ref><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__face__base__with__info__2" kindref="compound">CGAL::Triangulation_face_base_with_info_2&lt;CGAL::Color,K&gt;</ref><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;</ref><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__2" kindref="compound">CGAL::Triangulation_2&lt;K,Tds&gt;</ref><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Face_handle<sp/>Face_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Finite_faces_iterator<sp/>Finite_faces_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Point<sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.<ref refid="classCGAL_1_1Triangulation__2_1a1025cd7e7226ccb44d82f0fb1d63ad4e" kindref="member">insert</ref>(Point(0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.insert(Point(0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.insert(Point(2,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.insert(Point(2,2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Finite_faces_iterator<sp/>fc<sp/>=<sp/>t.finite_faces_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/>;<sp/>fc<sp/>!=<sp/>t.finite_faces_end();<sp/>++fc)<sp/><sp/>fc-&gt;info()<sp/>=<sp/>CGAL::BLUE;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p(0.5,0.5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_handle<sp/>fh<sp/>=<sp/>t.locate(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fh-&gt;info()<sp/>=<sp/>CGAL::RED;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The second example adds a <computeroutput>std::string</computeroutput> in the vertices of a terrain.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2terrain_with_info_8cpp-example" kindref="compound">Triangulation_2/terrain_with_info.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Projection_traits_xy_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Projection__traits__xy__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Projection_traits_xy_3&lt;K&gt;</ref><sp/><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__2" kindref="compound">CGAL::Triangulation_vertex_base_with_info_2&lt;std::string, Gt&gt;</ref><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;Vb&gt;</ref><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">CGAL::Delaunay_triangulation_2&lt;Gt,Tds&gt;</ref><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_3<sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>dt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay::Vertex_handle<sp/>vh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vh<sp/><sp/>=<sp/>dt.<ref refid="classCGAL_1_1Delaunay__triangulation__2_1a81efeca7e8a7605aba1d3b4f951a96dc" kindref="member">insert</ref>(Point(0,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vh-&gt;info()<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;Paris&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vh<sp/>=<sp/>dt.insert(Point(1,0,0.1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vh-&gt;info()<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;London&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vh<sp/>=<sp/>dt.insert(Point(0,1,0.2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vh-&gt;info()<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;New<sp/>York&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Triangulation_2AddingHandles">
<title>Adding Handles</title>
<para>This example shows how the user can still derive and plug in his own vertex or face class when he would like to have additional functionalities depending on types provided by the triangulation data structure.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2adding_handles_8cpp-example" kindref="compound">Triangulation_2/adding_handles.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>A<sp/>vertex<sp/>class<sp/>with<sp/>an<sp/>additionnal<sp/>handle<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Gt,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Vb<sp/>=<sp/>CGAL::Triangulation_vertex_base_2&lt;Gt&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_vertex_base</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><sp/>Vb</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Vb<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Base;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Face_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>TDS2<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Rebind_TDS<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::template<sp/>Rebind_TDS&lt;TDS2&gt;::Other<sp/><sp/><sp/><sp/>Vb2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>My_vertex_base&lt;Gt,Vb2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Other;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/>va_;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_base()<sp/>:<sp/>Base()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_base(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>&amp;<sp/>p)<sp/>:<sp/>Base(p)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_base(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>&amp;<sp/>p,<sp/>Face_handle<sp/>f)<sp/>:<sp/>Base(f,p)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_base(Face_handle<sp/>f)<sp/>:<sp/>Base(f)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>set_associated_vertex(Vertex_handle<sp/>va)<sp/>{<sp/>va_<sp/>=<sp/>va;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>get_associated_vertex()<sp/>{</highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>va_<sp/>;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>My_vertex_base&lt;K&gt;<sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;Vb&gt;</ref><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__2" kindref="compound">CGAL::Triangulation_2&lt;K,Tds&gt;</ref><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Vertex_handle<sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Finite_faces_iterator<sp/>Finite_faces_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Point<sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v0<sp/>=<sp/>t.<ref refid="classCGAL_1_1Triangulation__2_1a1025cd7e7226ccb44d82f0fb1d63ad4e" kindref="member">insert</ref>(Point(0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v1<sp/>=<sp/>t.insert(Point(0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v2<sp/>=<sp/>t.insert(Point(2,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v3<sp/>=<sp/>t.insert(Point(2,2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>associate<sp/>vertices<sp/>as<sp/>you<sp/>like</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v0-&gt;set_associated_vertex(v1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v1-&gt;set_associated_vertex(v2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v2-&gt;set_associated_vertex(v3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v3-&gt;set_associated_vertex(v0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>v0-&gt;get_associated_vertex()<sp/>==<sp/>v1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Triangulation_2SettingInformationWhileInserting">
<title>Setting Information While Inserting a Range of Points</title>
<para>The most efficient method to insert (weighted) points in a Delaunay (or regular) triangulation is to provide an iterator range over (weighted) points to the insert function. However, an iterator range of (weighted) points does not allow the user to set different information to each vertex. To solve this problem, in the case the vertex type of the triangulation is a model of the concept <computeroutput><ref refid="classTriangulationVertexBaseWithInfo__2" kindref="compound">TriangulationVertexBaseWithInfo_2</ref></computeroutput> (such as <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__2" kindref="compound">Triangulation_vertex_base_with_info_2</ref></computeroutput>), we provide three examples doing the same operation: set an unsigned integer as the information of each vertex. The value of this unsigned integer is the initial order of the corresponding point given in the range.</para></sect2>
<sect2 id="index_1Triangulation_2UsinganIteratorOverPairs">
<title>Using an Iterator Over Pairs</title>
<para>Each point and its information are gathered into a pair. We provide the <computeroutput>insert</computeroutput> function of the triangulation with a range of such pairs. <linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2info_insert_with_pair_iterator_2_8cpp-example" kindref="compound">Triangulation_2/info_insert_with_pair_iterator_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__2" kindref="compound">CGAL::Triangulation_vertex_base_with_info_2&lt;unsigned, K&gt;</ref><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;Vb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;<sp/>std::pair&lt;Point,unsigned&gt;<sp/>&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(0,0),0)<sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(1,0),1)<sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(0,1),2)<sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(14,4),3)<sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(2,2),4)<sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(-4,0),5)<sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(<sp/>points.begin(),points.end()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>T.number_of_vertices()<sp/>==<sp/>6<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>that<sp/>the<sp/>info<sp/>was<sp/>correctly<sp/>set.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay::Finite_vertices_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>T.finite_vertices_begin();<sp/>vit<sp/>!=<sp/>T.finite_vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>points[<sp/>vit-&gt;info()<sp/>].first<sp/>!=<sp/>vit-&gt;point()<sp/>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error<sp/>different<sp/>info&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>exit(EXIT_FAILURE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;OK&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Triangulation_2UsingtheBoostZipIterator">
<title>Using the Boost Zip Iterator</title>
<para>Information and points are in separate containers. We use <ulink url="http://www.boost.org/libs/iterator/doc/index.html#specialized-adaptors"><computeroutput>boost::zip_iterator</computeroutput></ulink> to provide an iterator gathering them.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2info_insert_with_zip_iterator_2_8cpp-example" kindref="compound">Triangulation_2/info_insert_with_zip_iterator_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/iterator/zip_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__2" kindref="compound">CGAL::Triangulation_vertex_base_with_info_2&lt;unsigned, K&gt;</ref><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;Vb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;unsigned&gt;<sp/>indices;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(5);<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(1,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(1,47));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(2,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(-1,0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(<sp/>boost::make_zip_iterator(boost::make_tuple(<sp/>points.begin(),indices.begin()<sp/>)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::make_zip_iterator(boost::make_tuple(<sp/>points.end(),indices.end()<sp/>)<sp/>)<sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>T.number_of_vertices()<sp/>==<sp/>6<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>that<sp/>the<sp/>info<sp/>was<sp/>correctly<sp/>set.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay::Finite_vertices_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>T.finite_vertices_begin();<sp/>vit<sp/>!=<sp/>T.finite_vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>points[<sp/>vit-&gt;info()<sp/>]<sp/>!=<sp/>vit-&gt;point()<sp/>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error<sp/>different<sp/>info&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>exit(EXIT_FAILURE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Triangulation_2UsingtheBoostTransformIterator">
<title>Using the Boost Transform Iterator</title>
<para>We define a functor <computeroutput>Auto_count</computeroutput> used together with <ulink url="http://www.boost.org/libs/iterator/doc/index.html#specialized-adaptors"><computeroutput>boost::transform_iterator</computeroutput></ulink> to set the order of each point in the range. Note that this is correct because the iterator is dereferenced only once per point during the insertion. <linebreak/>
<bold>File</bold> <ref refid="Triangulation_2_2info_insert_with_transform_iterator_2_8cpp-example" kindref="compound">Triangulation_2/info_insert_with_transform_iterator_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/iterator/transform_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__2" kindref="compound">CGAL::Triangulation_vertex_base_with_info_2&lt;unsigned, K&gt;</ref><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2&lt;Vb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//a<sp/>functor<sp/>that<sp/>returns<sp/>a<sp/>std::pair&lt;Point,unsigned&gt;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//the<sp/>unsigned<sp/>integer<sp/>is<sp/>incremented<sp/>at<sp/>each<sp/>call<sp/>to<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//operator()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Auto_count<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1cpp98_1_1unary__function" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp98::unary_function</ref>&lt;const<sp/>Point&amp;,std::pair&lt;Point,unsigned&gt;<sp/>&gt;{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">mutable</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Auto_count()<sp/>:<sp/>i(0){}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::pair&lt;Point,unsigned&gt;<sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_pair(p,i++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(1,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(4,10));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(2,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(-1,0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(<sp/>boost::make_transform_iterator(points.begin(),Auto_count()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::make_transform_iterator(points.end(),<sp/><sp/>Auto_count()<sp/>)<sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>T.number_of_vertices()<sp/>==<sp/>6<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>that<sp/>the<sp/>info<sp/>was<sp/>correctly<sp/>set.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay::Finite_vertices_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>T.finite_vertices_begin();<sp/>vit<sp/>!=<sp/>T.finite_vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>points[<sp/>vit-&gt;info()<sp/>]<sp/>!=<sp/>vit-&gt;point()<sp/>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error<sp/>different<sp/>info&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>exit(EXIT_FAILURE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;OK&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Triangulation_2Design">
<title>Design and Implementation History</title>
<para>The code of this package is the result of a long development process. Here follows a tentative list of people who added their stone to this package: Jean-Daniel Boissonnat, Herv<eacute/> Br<oumlaut/>nnimann, Olivier Devillers, Andreas Fabri, Fr<eacute/>d<eacute/>ric Fichel, Julia Fl<oumlaut/>totto, Monique Teillaud and Mariette Yvinec. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
