<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Triangulation_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Triangulation: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Triangulation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Triangulations"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Mariette Yvinec</dd></dl>
<div class="image">
<object type="image/svg+xml" data="tr1dt1.svg">tr1dt1.svg</object>
</div>
 <p>This chapter describes the two dimensional triangulations of <span style="font-variant: small-caps;">CGAL</span>. Section <a class="el" href="index.html#Section_2D_Triangulations_Definitions">Definitions</a> recalls the main definitions about triangulations. Section <a class="el" href="index.html#Section_2D_Triangulations_Representation">Representation</a> discusses the way two-dimensional triangulations are represented in <span style="font-variant: small-caps;">CGAL</span>. Section <a class="el" href="index.html#Section_2D_Triangulations_Software_Design">Software Design</a> presents the overall software design of the 2D triangulations package. The next sections present the different two dimensional triangulations classes available in <span style="font-variant: small-caps;">CGAL</span>: basic triangulations (Section <a class="el" href="index.html#Section_2D_Triangulations_Basic">Basic Triangulations</a>), Delaunay triangulations (Section <a class="el" href="index.html#Section_2D_Triangulations_Delaunay">Delaunay Triangulations</a>), regular triangulations (Section <a class="el" href="index.html#Section_2D_Triangulations_Regular">Regular Triangulations</a>), constrained triangulations (Section <a class="el" href="index.html#Section_2D_Triangulations_Constrained">Constrained Triangulations</a>), and constrained Delaunay triangulations (Section <a class="el" href="index.html#Section_2D_Triangulations_Constrained_Delaunay">Constrained Delaunay Triangulations</a>). Section <a class="el" href="index.html#Section_2D_Triangulations_Constrained_Plus">Constrained Triangulations with a Bidirectional Mapping between Constraints and Subconstraints</a> describes a class which implements a constrained or constrained Delaunay triangulation with an additional data structure to describe how the constraints are refined by the edges of the triangulations. Section <a class="el" href="index.html#Section_2D_Triangulations_Hierarchy">The Triangulation Hierarchy</a> describes a hierarchical data structure for fast point location queries. At last, Section <a class="el" href="index.html#Section_2D_Triangulations_Flexibility">Flexibility</a> explains how the user can benefit from the flexibility of <span style="font-variant: small-caps;">CGAL</span> triangulations using customized classes for faces and vertices.</p>
<h1><a class="anchor" id="Section_2D_Triangulations_Definitions"></a>
Definitions</h1>
<p>A two dimensional triangulation can be roughly described as a set \( T\) of triangular facets such that:</p>
<ul>
<li>two facets either are disjoint or share a lower dimensional face (edge or vertex).</li>
<li>the set of facets in \( T\) is connected for the adjacency relation.</li>
<li>the domain \( U_T\) which is the union of facets in \( T\) has no singularity.</li>
</ul>
<p>More precisely, a triangulation can be described as a simplicial complex. Let us first record a few definitions.</p>
<p>A simplicial complex is a set \( T\) of simplices such that</p>
<ul>
<li>any face of a simplex in \( T\) is a simplex in \( T\)</li>
<li>two simplices in \( T\) either are disjoint or share a common sub-face.</li>
</ul>
<p>The dimension \( d\) of a simplicial complex is the maximal dimension of its simplices.</p>
<p>A simplicial complex \( T\) is pure if any simplex of \( T\) is included in a simplex of \( T\) with maximal dimension.</p>
<p>Two simplexes in \( T\) with maximal dimension \( d\) are said to be adjacent if they share a \( d-1\) dimensional sub-face. A simplicial complex is connected if the adjacency relation defines a connected graph over the set of simplices of \( T\) with maximal dimension.</p>
<p>The union \( U_T\) of all simplices in \( T\) is called the domain of \( T\). A point \( p\) in the domain of \( T\) is said to singular if its surrounding in \( U_T\) is neither a topological ball nor a topological disc.</p>
<p>Then, a two dimensional triangulation can be described as a two dimensional simplicial complex that is pure, connected and without singularity.</p>
<p>Each facet of a triangulation can be given an orientation which in turn induces an orientation on the edges incident to that facet. The orientation of two adjacent facets are said to be consistent if they induce opposite orientations on their common incident edge. A triangulation is said to be orientable if the orientation of each facet can be chosen in such a way that all pairs of incident facets have consistent orientations.</p>
<p>The data structure underlying <span style="font-variant: small-caps;">CGAL</span> triangulations allows the user to represent the combinatorics of any orientable two dimensional triangulations without boundaries. On top of this data structure, the 2D triangulations classes take care of the geometric embedding of the triangulation and are designed to handle planar triangulations. The plane of the triangulation may be embedded in a higher dimensional space.</p>
<p>The triangulations of <span style="font-variant: small-caps;">CGAL</span> are complete triangulations which means that their domain is the convex hull of their vertices. Because any planar triangulation can be completed, this is not a real restriction. For instance, a triangulation of a polygonal region can be constructed and represented as a subset of a constrained triangulation in which the region boundary edges have been input as constrained edges (see Section <a class="el" href="index.html#Section_2D_Triangulations_Constrained">Constrained Triangulations</a>, <a class="el" href="index.html#Section_2D_Triangulations_Constrained_Delaunay">Constrained Delaunay Triangulations</a> and <a class="el" href="index.html#Section_2D_Triangulations_Constrained_Plus">Constrained Triangulations with a Bidirectional Mapping between Constraints and Subconstraints</a>).</p>
<p>Strictly speaking, the term <em>face</em> should be used to design a face of any dimension, and the two-dimensional faces of a triangulation should be properly called <em>facets</em>. However, following a common usage, we hereafter often call <em>faces</em>, the facets of a two dimensional triangulation.</p>
<h1><a class="anchor" id="Section_2D_Triangulations_Representation"></a>
Representation</h1>
<h2><a class="anchor" id="Triangulation_2TheSetofFaces"></a>
The Set of Faces</h2>
<p>A 2D triangulation of <span style="font-variant: small-caps;">CGAL</span> can be viewed as a planar partition whose bounded faces are triangular and cover the convex hull of the set of vertices. The single unbounded face of this partition is the complementary of the convex hull. In many applications, such as Kirkpatrick's hierarchy or incremental Delaunay construction, it is convenient to deal with only triangular faces. Therefore, a fictitious vertex, called the <em>infinite vertex</em> is added to the triangulation as well as infinite edges* and <em>infinite faces</em> incident to it. Each infinite edge is incident to the infinite vertex and to a vertex of the convex hull. Each infinite face is incident to the infinite vertex and to a convex hull edge.</p>
<p>Therefore, each edge of the triangulation is incident to exactly two faces and the set of faces of a triangulation is topologically equivalent to a two-dimensional sphere. This extends to lower dimensional triangulations arising in degenerate cases or when the triangulations as less than three vertices. Including the infinite faces, a one dimensional triangulation is a ring of edges and vertices topologically equivalent to a \( 1\)-sphere. A zero dimensional triangulation, whose domain is reduced to a single point, is represented by two vertices that is topologically equivalent to a \( 0\)-sphere.</p>
<p>Note that the <em>infinite vertex</em> has no significant coordinates and that no geometric predicate can be applied on it nor on an infinite face.</p>
<p><a class="anchor" id="fig__Triangulation_2D_Fig_infinite_vertex"></a></p><div class="image">
<img src="infinite.png" alt="infinite.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Triangulation_2D_Fig_infinite_vertex">Figure 39.1</a> Infinite vertex and infinite faces  </div>  <br />

<h2><a class="anchor" id="Triangulation_2ARepresentationBasedonFaces"></a>
A Representation Based on Faces and Vertices</h2>
<p>Because a triangulation is a set of triangular faces with constant-size complexity, triangulations are not implemented as a layer on top of a planar map. <span style="font-variant: small-caps;">CGAL</span> uses a proper internal representation of triangulations based on faces and vertices rather than on edges. Such a representation saves storage space and results in faster algorithms <a class="el" href="citelist.html#CITEREF_bdty-tcgal-00">[1]</a>.</p>
<p>The basic elements of the representation are vertices and faces. Each triangular face gives access to its three incident vertices and to its three adjacent faces. Each vertex gives access to one of its incident faces and through that face to the circular list of its incident faces.</p>
<p>The three vertices of a face are indexed with 0, 1 and 2 in counterclockwise order. The neighbors of a face are also indexed with 0,1,2 in such a way that the neighbor indexed by <code>i</code> is opposite to the vertex with the same index. See <a class="el" href="index.html#fig__Triangulation_2D_Fig_neighbors1">Figure 39.2</a>, the functions <code>ccw(i)</code> and <code>cw(i)</code> shown on this figure compute respectively \( i+1\) and \( i-1\) modulo 3.</p>
<p>The edges are not explicitly represented, they are only implicitly represented through the adjacency relations of two faces. Each edge has two implicit representations: the edge of a face <code>f</code> which is opposed to the vertex indexed <code>i</code>, can be represented as well as an edge of the <code>neighbor(i)</code> of <code>f</code>.</p>
<p><a class="anchor" id="fig__Triangulation_2D_Fig_neighbors1"></a></p><div class="image">
<img src="rep_bis.png" alt="rep_bis.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Triangulation_2D_Fig_neighbors1">Figure 39.2</a> Vertices and neighbors.  </div>  <br />

<h1><a class="anchor" id="Section_2D_Triangulations_Software_Design"></a>
Software Design</h1>
<p>The triangulations classes of <span style="font-variant: small-caps;">CGAL</span> provide high-level geometric functionalities such as location of a point in the triangulation, insertion, removal, or displacement of a point. They are build as a layer on top of a data structure called the triangulation data structure. The triangulation data structure can be thought of as a container for the faces and vertices of the triangulation. This data structure also takes care of all the combinatorial aspects of the triangulation.</p>
<p>This separation between the geometric aspect and the combinatorial part is reflected in the software design by the fact that the triangulation classes have two template parameters:</p>
<ul>
<li>
<p class="startli">the first parameter stands for a <b>geometric traits</b> class providing the geometric primitives (points, segments and triangles) of the triangulation and the elementary operations (predicate or constructions) on those objects.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">the second parameter stands for a <b>triangulation data structure</b> class. The concept of triangulation data structure is described in Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/index.html#TDS_2D_Concept">Concepts</a> of Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/index.html#Chapter_2D_Triangulation_Data_Structure">2D Triangulation Data Structure</a>. The triangulation data structure defines the types used to represent the faces and vertices of the triangulation, as well as additional types (handles, iterators and circulators) to access and visit the faces and vertices.</p>
<p class="endli"><span style="font-variant: small-caps;">CGAL</span> provides the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">Triangulation_data_structure_2</a>&lt;Vb,Fb&gt;</code> as a default model of triangulation data structure. The class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">Triangulation_data_structure_2</a>&lt;Vb,Fb&gt;</code> has two template parameters standing for a vertex class and a face class. <span style="font-variant: small-caps;">CGAL</span> defines concepts for these template parameters and provide default models for these concepts. The vertex and base classes are templated by the geometric traits class which enables them to obtain some knowledge of the geometric primitives of the triangulation. Those default vertex and face base classes can be replaced by user customized base classes in order, for example, to deal with additional properties attached to the vertices or faces of a triangulation. See Section <a class="el" href="index.html#Section_2D_Triangulations_Flexibility">Flexibility</a> for more details on the way to make use of this flexibility. </p>
</li>
</ul>
<p><a class="el" href="index.html#fig__Triangulation_2D_Fig_three_levels">Figure 39.3</a> summarizes the design of the triangulation package, showing the three layers (base classes, triangulation data structure and triangulation) forming this design.</p>
<p><a class="anchor" id="fig__Triangulation_2D_Fig_three_levels"></a></p><div class="image">
<img src="threelevels.png" alt="threelevels.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Triangulation_2D_Fig_three_levels">Figure 39.3</a> The triangulations software design.  </div>  <br />

<p>The top triangulation level, responsible for the geometric embedding of the triangulation comes in different flavors according to the different kind of triangulations: basic, Delaunay, regular, constrained or constrained Delaunay. Each kind of triangulations correspond to a different class. <a class="el" href="index.html#fig__Triangulation_2D_Fig_derivation_tree">Figure 39.4</a> summarizes the derivation dependencies of <span style="font-variant: small-caps;">CGAL</span> 2D triangulations classes. Any 2D triangulation class is parametrized by a geometric traits class and a triangulation data structure. While a unique concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classTriangulationDataStructure__2.html">TriangulationDataStructure_2</a></code> describes the triangulation data structure requirements for any triangulation class, the requirements on the geometric traits class actually depend on the triangulation class. In general, the requirements for the vertex and face base classes are described by the basic concepts <code><a class="el" href="classTriangulationVertexBase__2.html" title="The concept TriangulationVertexBase_2 describes the requirements for the vertex base class of a trian...">TriangulationVertexBase_2</a></code> and <code><a class="el" href="classTriangulationFaceBase__2.html" title="The concept TriangulationFaceBase_2 describes the requirements for the base face class of a triangula...">TriangulationFaceBase_2</a></code>. However, some triangulation classes require base classes implementing refinements of the basic concepts.</p>
<p><a class="anchor" id="fig__Triangulation_2D_Fig_derivation_tree"></a></p><div class="image">
<img src="derivation_tree.png" alt="derivation_tree.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Triangulation_2D_Fig_derivation_tree">Figure 39.4</a> The derivation tree of 2D triangulations.  </div>  <br />

<h1><a class="anchor" id="Section_2D_Triangulations_Basic"></a>
Basic Triangulations</h1>
<h2><a class="anchor" id="Subsection_2D_Triangulations_Basic_Description"></a>
Description</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Triangulation__2.html" title="The class Triangulation_2 is the basic class designed to handle triangulations of set of points  in t...">Triangulation_2</a>&lt;Traits,Tds&gt;</code> serves as a base class for the other 2D triangulations classes and implements the user interface to a triangulation.</p>
<p>The vertices and faces of the triangulations are accessed through <code>handles</code>, <code>iterators</code> and <code>circulators</code>. A handle is a model of the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/classHandle.html">Handle</a></code> which basically offers the two dereference operators <code>*</code> and <code>-&gt;</code>. A circulator is a type devoted to visit circular sequences. Handles are used whenever the accessed element is not part of a sequence. Iterators and circulators are used to visit all or parts of the triangulation.</p>
<p>The iterators and circulators are all bidirectional and non mutable. The circulators and iterators are convertible to the handles with the same value type, so that when calling a member function, any handle type argument can be replaced by an iterator or a circulator with the same value type.</p>
<p>The triangulation class provides a function to visit the vertices and neighbors of a face in clockwise or counterclockwise order.</p>
<p>There are circulators to visit the edges or faces incident to a given vertex or the vertices adjacent to it. Another circulator type enables the visit of all the faces traversed by a given line. Circulators step through infinite features as well as through finite ones.</p>
<p>The triangulation class offers some iterators to visit all the faces, edges or vertices and also iterators to visit selectively the finite faces, edges or vertices.</p>
<p>The triangulation class provides methods to test the infinite character of any feature, and also methods to test the presence in the triangulation of a particular feature (edge or face) given its vertices.</p>
<p>The triangulation class provides a method to locate a given point with respect to a triangulation. In particular, this method reports whether the point coincides with a vertex of the triangulation, lies on an edge, in a face or outside of the convex hull. In case of a degenerate lower dimensional triangulation, the query point may also lie outside the triangulation affine hull.</p>
<p>The triangulation class also provides methods to locate a point with respect to a given finite face of the triangulation or with respect to its circumcircle. The faces of the triangulation and their circumcircles have the counterclockwise orientation.</p>
<p>The triangulation can be modified by several functions: insertion of a point, removal of a vertex, displacement of a vertex, flipping of an edge. The flipping of an edge is possible when the union of the two incident faces forms a convex quadrilateral (see <a class="el" href="index.html#fig__Triangulation_2D_fig_flip_bis">Figure 39.5</a>).</p>
<p><a class="anchor" id="fig__Triangulation_2D_fig_flip_bis"></a></p><div class="image">
<img src="Flip.png" alt="Flip.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Triangulation_2D_fig_flip_bis">Figure 39.5</a> Flip.  </div>  <br />

<h2><a class="anchor" id="Triangulation_2Implementation"></a>
Implementation</h2>
<p>Locate is implemented by a line walk. The walk begins at a vertex of the face which is given as an optional argument or at an arbitrary vertex of the triangulation if no optional argument is given. It takes time \( O(n)\) in the worst case, but only \( O(\sqrt{n})\) on average if the vertices are distributed uniformly at random. The class <code><a class="el" href="classCGAL_1_1Triangulation__hierarchy__2.html" title="The class Triangulation_hierarchy_2 implements a triangulation augmented with a data structure which ...">Triangulation_hierarchy_2</a>&lt;Traits,Tds&gt;</code>, described in section <a class="el" href="index.html#Section_2D_Triangulations_Hierarchy">The Triangulation Hierarchy</a>, implements a data structure designed to offer an alternate more efficient point location algorithm.</p>
<p>Insertion of a point is done by locating a face that contains the point, and splitting this face into three new faces. If the point falls outside the convex hull, the triangulation is restored by flips. Apart from the location, insertion takes a time \( O(1)\). This bound is only an amortized bound for points located outside the convex hull.</p>
<p>Removal of a vertex is done by removing all adjacent triangles, and re-triangulating the hole. Removal takes a time at most proportional to \( d^2\), where \( d\) is the degree of the removed vertex, which is \( O(1)\) for a random vertex.</p>
<p>Displacement of a vertex is done by: first, verifying if the triangulation embedding remains planar after the displacement; if yes the vertex is directly placed at the new location; otherwise, a point is inserted at the new location and the vertex at the obsolete location is removed.</p>
<p>The face, edge, and vertex iterators on finite features are derived from their counterparts visiting all (finite and infinite) features which are themselves derived from the corresponding iterators of the triangulation data structure.</p>
<h2><a class="anchor" id="Subsubsection_2D_Triangulation_Basic_Geometric_Traits"></a>
Geometric Traits</h2>
<p>The geometric traits class of a triangulation is required to provide the geometric objects (points, segments and triangles) building up the triangulation together with the geometric predicates on those objects. The required predicates are:</p>
<ul>
<li>comparison of the <code>x</code> or <code>y</code> coordinates of two points.</li>
<li>the orientation test which computes the order type of three given point.</li>
</ul>
<p>The concept <code><a class="el" href="classTriangulationTraits__2.html">TriangulationTraits_2</a></code> describes the requirements for the geometric traits class of a triangulation. The <span style="font-variant: small-caps;">CGAL</span> kernel classes are models for this concept. The <span style="font-variant: small-caps;">CGAL</span> library also provides dedicated models of <code><a class="el" href="classTriangulationTraits__2.html">TriangulationTraits_2</a></code> using the kernel geometric objects and predicates. These classes are themselves templated with a <span style="font-variant: small-caps;">CGAL</span> kernel and extract the required types and predicates from the kernel. The class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">Projection_traits_xy_3</a>&lt;R&gt;</code> is a geometric traits class to build the triangulation of a terrain. Such a triangulation is a two-dimensional triangulation embedded in three dimensional space. The data points are three-dimensional points. The triangulation is build according to the projections of those points on the \( xy\) plane and then lifted up to the original three-dimensional data points. This is especially useful to deal with GIS terrains. Instead of really projecting the three-dimensional points and maintaining a mapping between each point and its projection (which costs space and is error prone), the traits class supplies geometric predicates that ignore the <code>z</code>-coordinates of the points. See Section <a class="el" href="index.html#Section_2D_Triangulations_Delaunay">Delaunay Triangulations</a> for an example. <span style="font-variant: small-caps;">CGAL</span> provides also the geometric traits classes <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__yz__3.html">Projection_traits_yz_3</a>&lt;R&gt;</code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xz__3.html">Projection_traits_xz_3</a>&lt;R&gt;</code> to deal with projections on the <code>yz</code> plane and <code>xz</code>-plane, respectively.</p>
<h2><a class="anchor" id="Subsection_2D_Triangulations_Basic_Example"></a>
Example of a Basic Triangulation</h2>
<p>The following program creates a triangulation of 2D points using the default kernel <code>Exact_predicate_inexact_constructions_kernel</code> as geometric traits class and the default triangulation data structure. The input points are read from a file and inserted in the triangulation. Finally points on the convex hull are written to <code>cout</code>. <br />
<b>File</b> <a class="el" href="Triangulation_2_2triangulation_prog1_8cpp-example.html">Triangulation_2/triangulation_prog1.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2&lt;K&gt;</a>         Triangulation;</div><div class="line"><span class="keyword">typedef</span> Triangulation::Vertex_circulator Vertex_circulator;</div><div class="line"><span class="keyword">typedef</span> Triangulation::Point             Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::ifstream in(<span class="stringliteral">"data/triangulation_prog1.cin"</span>);</div><div class="line">  std::istream_iterator&lt;Point&gt; begin(in);</div><div class="line">  std::istream_iterator&lt;Point&gt; end;</div><div class="line"></div><div class="line">  Triangulation t;</div><div class="line">  t.insert(begin, end);</div><div class="line"></div><div class="line">  Vertex_circulator vc = t.incident_vertices(t.infinite_vertex()),</div><div class="line">    done(vc);</div><div class="line">  <span class="keywordflow">if</span> (vc != 0) {</div><div class="line">    <span class="keywordflow">do</span> { std::cout &lt;&lt; vc-&gt;point() &lt;&lt; std::endl;</div><div class="line">    }<span class="keywordflow">while</span>(++vc != done);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Triangulation2Draw"></a>
Draw a 2D Triangulation</h2>
<p><a class="anchor" id="ssecDrawT2"></a> A 2D triangulation can be visualized by calling the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_3.tag:../Triangulation_3/" href="../Triangulation_3/group__PkgDrawTriangulation3.html#ga6a09318e75a0fb017c3ee02521f62742">CGAL::draw()</a></code> function as shown in the following example. This function opens a new window showing the given 2D triangulation. The function is blocking, that is the program continues as soon as the user closes the window.</p>
<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2draw_triangulation_2_8cpp-example.html">Triangulation_2/draw_triangulation_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/draw_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2&lt;K&gt;</a>                            Triangulation;</div><div class="line"><span class="keyword">typedef</span> Triangulation::Point                                Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::ifstream in(<span class="stringliteral">"data/triangulation_prog1.cin"</span>);</div><div class="line">  std::istream_iterator&lt;Point&gt; begin(in);</div><div class="line">  std::istream_iterator&lt;Point&gt; end;</div><div class="line"></div><div class="line">  Triangulation t;</div><div class="line">  t.insert(begin, end);</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_3.tag:../Triangulation_3/" href="../Triangulation_3/group__PkgDrawTriangulation3.html#ga6a09318e75a0fb017c3ee02521f62742">CGAL::draw</a>(t);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>This function requires CGAL_Qt5, and is only available if the flag CGAL_USE_BASIC_VIEWER is defined at compile time.</p>
<p><a class="anchor" id="fig__fig_draw_triangulation_2"></a></p><div class="image">
<img src="draw_triangulation_2.png" alt="draw_triangulation_2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_draw_triangulation_2">Figure 39.6</a> Result of the run of the draw_triangulation_2 program. A window shows the 2D triangulation and allows to navigate through the scene.  </div>  <br />

<h1><a class="anchor" id="Section_2D_Triangulations_Delaunay"></a>
Delaunay Triangulations</h1>
<h2><a class="anchor" id="Subsection_2D_Triangulations_Delaunay_Description"></a>
Description</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Delaunay__triangulation__2.html" title="The class Delaunay_triangulation_2 is designed to represent the Delaunay triangulation of a set of po...">Delaunay_triangulation_2</a>&lt;Traits,Tds&gt;</code> is designed to represent the Delaunay triangulation of a set of data points in the plane. A Delaunay triangulation fulfills the following <em>empty circle property</em> (also called <em>Delaunay property</em>): the circumscribing circle of any facet of the triangulation contains no data point in its interior. For a point set with no subset of four co-circular points the Delaunay triangulation is unique, it is dual to the Voronoi diagram of the set of points.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Delaunay__triangulation__2.html" title="The class Delaunay_triangulation_2 is designed to represent the Delaunay triangulation of a set of po...">Delaunay_triangulation_2</a>&lt;Traits,Tds&gt;</code> derives from the class <code><a class="el" href="classCGAL_1_1Triangulation__2.html" title="The class Triangulation_2 is the basic class designed to handle triangulations of set of points  in t...">Triangulation_2</a>&lt;Traits,Tds&gt;</code>.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Delaunay__triangulation__2.html" title="The class Delaunay_triangulation_2 is designed to represent the Delaunay triangulation of a set of po...">Delaunay_triangulation_2</a>&lt;Traits,Tds&gt;</code> inherits the types defined by the basic class <code><a class="el" href="classCGAL_1_1Triangulation__2.html" title="The class Triangulation_2 is the basic class designed to handle triangulations of set of points  in t...">Triangulation_2</a>&lt;Traits,Tds&gt;</code>. Additional types, provided by the traits class, are defined to represent the dual Voronoi diagram.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Delaunay__triangulation__2.html" title="The class Delaunay_triangulation_2 is designed to represent the Delaunay triangulation of a set of po...">Delaunay_triangulation_2</a>&lt;Traits,Tds&gt;</code> overwrites the member functions that insert, move, or remove a point in the triangulation to maintain the Delaunay property. It also has a member function (<code>Vertex_handle</code> <code><a class="el" href="classCGAL_1_1Delaunay__triangulation__2.html#a30e5bdf852f888b3b2fd33e9dbfa4bcb" title="returns any nearest vertex of p. ">Delaunay_triangulation_2::nearest_vertex</a></code><code>(const Point&amp; p)</code>) to answer nearest neighbor queries and member functions to construct the elements (vertices and edges) of the dual Voronoi diagram.</p>
<h2>Geometric Traits </h2>
<p>The geometric traits class has to be a model of the concept <code><a class="el" href="classDelaunayTriangulationTraits__2.html" title="In addition to the requirements of the concept TriangulationTraits_2 the concept DelaunayTriangulatio...">DelaunayTriangulationTraits_2</a></code> which refines the concept <code><a class="el" href="classTriangulationTraits__2.html">TriangulationTraits_2</a></code>. In particular this concept provides the <code>side_of_oriented_circle</code> predicate which, given four points <code>p,q,r,s</code> decides the position of the point \( s\) with respect to the circle passing through \( p\), \( q\) and \( r\). The <code>side_of_oriented_circle</code> predicate actually defines the Delaunay triangulation. Changing this predicate allows the user to build variant of Delaunay triangulations for different metrics such that \( L_1\) or \( L_{\infty}\) metric or any metric defined by a convex object. However, the user of an exotic metric must be careful that the constructed triangulation has to be a triangulation of the convex hull which means that convex hull edges have to be Delaunay edges. This is granted for any smooth convex metric (like \( L_2\)) and can be ensured for other metrics (like \( L_{\infty}\)) by the addition to the point set of well chosen sentinel points.</p>
<p>The <span style="font-variant: small-caps;">CGAL</span> kernel classes are models of the concept <code><a class="el" href="classDelaunayTriangulationTraits__2.html" title="In addition to the requirements of the concept TriangulationTraits_2 the concept DelaunayTriangulatio...">DelaunayTriangulationTraits_2</a></code> for the Euclidean metric. The traits class for terrains, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">Projection_traits_xy_3</a>&lt;R&gt;</code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__yz__3.html">Projection_traits_yz_3</a>&lt;R&gt;</code>, and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xz__3.html">Projection_traits_xz_3</a>&lt;R&gt;</code> are also models of <code><a class="el" href="classDelaunayTriangulationTraits__2.html" title="In addition to the requirements of the concept TriangulationTraits_2 the concept DelaunayTriangulatio...">DelaunayTriangulationTraits_2</a></code> except that they do not fulfill the requirements for the duality functions and nearest vertex queries.</p>
<h2>Implementation </h2>
<p>The insertion of a new point in the Delaunay triangulation is performed using first the insertion member function of the basic triangulation and second performing a sequence of flips to restore the Delaunay property. The number of flips that have to be performed is \( O(d)\) if the new vertex has degree \( d\) in the updated Delaunay triangulation. For points distributed uniformly at random, each insertion takes time \( O(1)\) on average, once the point has been located in the triangulation.</p>
<p>Removal calls the removal in the triangulation and then re-triangulates the hole created in such a way that the Delaunay criterion is satisfied. Removal of a vertex of degree \( d\) takes time \( O(d^2)\). The degree \( d\) is \( O(1)\) for a random vertex in the triangulation. When the degree of the removed vertex is small ( \( \leq7\)) a special procedure is used that allows to decrease global removal time by a factor of 2 for random points <a class="el" href="citelist.html#CITEREF_d-vrtdd-09">[4]</a>.</p>
<p>The displacement of a vertex \( v\) at a point \( p\) to a new location \( p'\), first checks whether the triangulation embedding remains planar or not after moving \( v\) to \( p'\). If yes, it moves \( v\) to \( p'\) and simply performs a sequence of flips to restore the Delaunay property, which is \( O(d)\) where \( d\) is the degree of the vertex after the displacement. Otherwise, the displacement is done by inserting a vertex at the new location, and removing the obsolete vertex. The complexity is \( O(n)\) in the worst case, but only \( O(1 + \delta \sqrt{n})\) for evenly distributed vertices in the unit square, where \( \delta\) is the Euclidean distance between the new and old locations.</p>
<p>After having performed a point location, the nearest neighbor of a point is found in time \( O(n)\) in the worst case, but in time \( O(1)\) for vertices distributed uniformly at random and any query point.</p>
<h2><a class="anchor" id="Subsection_2D_Triangulations_Delaunay_Terrain"></a>
Example: a Delaunay Terrain</h2>
<p>The following code creates a Delaunay triangulation with the usual Euclidean metric for the vertical projection of a terrain model. The points have elevation, that is they are 3D points, but the predicates used to build the Delaunay triangulation are computed using only the \( x\) and \( y\) coordinates of these points.</p>
<p>The class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">Projection_traits_xy_3</a>&lt;K&gt;</code> is part of the 2D and 3D Linear Geometric <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2terrain_8cpp-example.html">Triangulation_2/terrain.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_traits_xy_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;K&gt;</a>  Gt;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Gt&gt;</a> Delaunay;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> K::Point_3   Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::ifstream in(<span class="stringliteral">"data/terrain.cin"</span>);</div><div class="line">  std::istream_iterator&lt;Point&gt; begin(in);</div><div class="line">  std::istream_iterator&lt;Point&gt; end;</div><div class="line"></div><div class="line">  Delaunay dt(begin, end);</div><div class="line">  std::cout &lt;&lt; dt.number_of_vertices() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Subsection_2D_Triangulations_Voronoi"></a>
Example: Voronoi Diagram</h2>
<p>The following code computes the edges of Voronoi diagram of a set of data points and counts the number of finite edges and the number of rays of this diagram <br />
<b>File</b> <a class="el" href="Triangulation_2_2voronoi_8cpp-example.html">Triangulation_2/voronoi.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K&gt;</a>  Triangulation;</div><div class="line"><span class="keyword">typedef</span> Triangulation::Edge_iterator  Edge_iterator;</div><div class="line"><span class="keyword">typedef</span> Triangulation::Point          Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( )</div><div class="line">{</div><div class="line">  std::ifstream in(<span class="stringliteral">"data/voronoi.cin"</span>);</div><div class="line">  std::istream_iterator&lt;Point&gt; begin(in);</div><div class="line">  std::istream_iterator&lt;Point&gt; end;</div><div class="line">  Triangulation T;</div><div class="line">  T.insert(begin, end);</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> ns = 0;</div><div class="line">  <span class="keywordtype">int</span> nr = 0;</div><div class="line">  Edge_iterator eit =T.edges_begin();</div><div class="line">  <span class="keywordflow">for</span> ( ; eit !=T.edges_end(); ++eit) {</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Object.html">CGAL::Object</a> o = T.dual(eit);</div><div class="line">    <span class="keywordflow">if</span> (CGAL::object_cast&lt;K::Segment_2&gt;(&amp;o)) {++ns;}</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CGAL::object_cast&lt;K::Ray_2&gt;(&amp;o)) {++nr;}</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The Voronoi diagram has "</span> &lt;&lt; ns &lt;&lt; <span class="stringliteral">" finite edges "</span></div><div class="line">        &lt;&lt; <span class="stringliteral">" and "</span> &lt;&lt; nr &lt;&lt; <span class="stringliteral">" rays"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Subsection_2D_Triangulations_Cropped_Voronoi"></a>
Example: Print Voronoi Diagram Edges Restricted to a Rectangle</h2>
<p>The following code computes the Delaunay triangulation of a set of points and prints the Voronoi edges restricted to a given rectangle.</p>
<p><a class="anchor" id="fig__figurecropped_voronoi"></a></p><div class="image">
<img src="cropped_voronoi.png" alt="cropped_voronoi.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figurecropped_voronoi">Figure 39.7</a> Voronoi diagram (in red) of the black points restricted to the blue rectangle.  </div>  <br />

<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2print_cropped_voronoi_8cpp-example.html">Triangulation_2/print_cropped_voronoi.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2 Point_2;</div><div class="line"><span class="keyword">typedef</span> K::Iso_rectangle_2 Iso_rectangle_2;</div><div class="line"><span class="keyword">typedef</span> K::Segment_2 Segment_2;</div><div class="line"><span class="keyword">typedef</span> K::Ray_2 Ray_2;</div><div class="line"><span class="keyword">typedef</span> K::Line_2 Line_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K&gt;</a>  Delaunay_triangulation_2;</div><div class="line"></div><div class="line"><span class="comment">//A class to recover Voronoi diagram from stream.</span></div><div class="line"><span class="comment">//Rays, lines and segments are cropped to a rectangle</span></div><div class="line"><span class="comment">//so that only segments are stored</span></div><div class="line"><span class="keyword">struct </span>Cropped_voronoi_from_delaunay{</div><div class="line">  std::list&lt;Segment_2&gt; m_cropped_vd;</div><div class="line">  Iso_rectangle_2 m_bbox;</div><div class="line">  </div><div class="line">  Cropped_voronoi_from_delaunay(<span class="keyword">const</span> Iso_rectangle_2&amp; bbox):m_bbox(bbox){}</div><div class="line">  </div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> RSL&gt;</div><div class="line">  <span class="keywordtype">void</span> crop_and_extract_segment(<span class="keyword">const</span> RSL&amp; rsl){</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Object.html">CGAL::Object</a> obj = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__intersection__linear__grp.html#gab77f3cd98c4c4ff7acff59c98ab88ff0">CGAL::intersection</a>(rsl,m_bbox);</div><div class="line">    <span class="keyword">const</span> Segment_2* s=CGAL::object_cast&lt;Segment_2&gt;(&amp;obj);</div><div class="line">    <span class="keywordflow">if</span> (s) m_cropped_vd.push_back(*s);</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="keywordtype">void</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamOperators.html#ga525f8afc1fb75eb966517c447f1968ea">operator&lt;&lt;</a>(<span class="keyword">const</span> Ray_2&amp; ray)    { crop_and_extract_segment(ray); }</div><div class="line">  <span class="keywordtype">void</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamOperators.html#ga525f8afc1fb75eb966517c447f1968ea">operator&lt;&lt;</a>(<span class="keyword">const</span> Line_2&amp; line)  { crop_and_extract_segment(line); }</div><div class="line">  <span class="keywordtype">void</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamOperators.html#ga525f8afc1fb75eb966517c447f1968ea">operator&lt;&lt;</a>(<span class="keyword">const</span> Segment_2&amp; seg){ crop_and_extract_segment(seg); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">  <span class="comment">//consider some points</span></div><div class="line">  std::vector&lt;Point_2&gt; points;</div><div class="line">  points.push_back(Point_2(0,0));</div><div class="line">  points.push_back(Point_2(1,1));</div><div class="line">  points.push_back(Point_2(0,1));</div><div class="line">  </div><div class="line">  Delaunay_triangulation_2 dt2;</div><div class="line">  <span class="comment">//insert points into the triangulation</span></div><div class="line">  dt2.insert(points.begin(),points.end());</div><div class="line">  <span class="comment">//construct a rectangle</span></div><div class="line">  Iso_rectangle_2 bbox(-1,-1,2,2);</div><div class="line">  Cropped_voronoi_from_delaunay vor(bbox);</div><div class="line">  <span class="comment">//extract the cropped Voronoi diagram</span></div><div class="line">  dt2.draw_dual(vor);</div><div class="line">  <span class="comment">//print the cropped Voronoi diagram as segments</span></div><div class="line">  std::copy(vor.m_cropped_vd.begin(),vor.m_cropped_vd.end(),</div><div class="line">    std::ostream_iterator&lt;Segment_2&gt;(std::cout,<span class="stringliteral">"\n"</span>));</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Section_2D_Triangulations_Regular"></a>
Regular Triangulations</h1>
<h2><a class="anchor" id="Subsection_2D_Triangulations_Regular_Description"></a>
Description</h2>
<p>Let \( { PW} = \{(p_i, w_i) | i = 1, \ldots , n \}\) be a set of weighted points where each \( p_i\) is a point and each \( w_i\) is a scalar called the weight of point \( p_i\). Alternatively, each weighted point \( (p_i, w_i)\) can be regarded as a sphere (or a circle, depending on the dimensionality of \( p_i\)) with center \( p_i\) and radius \( r_i=\sqrt{w_i}\).</p>
<p>The power diagram of the set \( { PW}\) is a space partition in which each cell corresponds to a sphere \( (p_i, w_i)\) of \( { PW}\) and is the locus of points \( p\) whose power with respect to \( (p_i, w_i)\) is less than its power with respect to any other sphere in \( { PW}\). In the two-dimensional space, the dual of this diagram is a triangulation whose domain covers the convex hull of the set \( { P}= \{ p_i | i = 1, \ldots , n \}\) of center points and whose vertices form a subset of \( { P}\). Such a triangulation is called a regular triangulation. Three points \( p_i, p_j\) and \( p_k\) of \( { P}\) form a triangle in the regular triangulation of \( { PW}\) iff there is a point \( p\) of the plane with equal powers with respect to \( (p_i, w_i)\), \( (p_j, w_j)\) and \( (p_k, w_k)\) and such that this power is less than the power of \( p\) with respect to any other sphere in \( { PW}\).</p>
<p>Let us defined the power product of two weighted points \( (p_i, w_i)\) and \( (p_j, w_j)\) as: </p><p class="formulaDsp">
\[ \Pi(p_i, w_i, p_j, w_j) = p_ip_j ^2 - w_i - w_j . \]
</p>
<p> \( \Pi(p_i, w_i, p_j, 0)\) is simply the power of point \( p_j\) with respect to the sphere \( (p_i, w_i)\), and two weighted points are said to be orthogonal if their power product is null. The power circle of three weighted points \( (p_i, w_i)\), \( (p_j, w_j)\) and \( (p_k, w_k)\) is defined as the unique circle \( (\pi, \omega)\) orthogonal to \( (p_i, w_i)\), \( (p_j, w_j)\) and \( (p_k, w_k)\).</p>
<p>The regular triangulation of the sets \( { PW}\) satisfies the following <em>regular property</em> (which just reduces to the Delaunay property when all the weights are null): a triangle \( p_ip_jp_k\) is a face of the regular triangulation of \( { PW}\) iff the power product of any weighted point \( (p_l, w_l)\) of \( { PW}\) with the power circle of \( (p_i, w_i)\), \( (p_j, w_j)\) and \( (p_k, w_k)\) is positive or null. We call power test of \( (p_i, w_i)\), \( (p_j, w_j)\), \( (p_k, w_k)\), and \( (p_l, w_l)\), the predicates which amount to compute the sign of the power product of \( (p_l, w_l)\) with respect to the power circle of \( (p_i, w_i)\), \( (p_j, w_j)\) and \( (p_k, w_k)\). This predicate amounts to computing the sign of the following determinant </p><p class="formulaDsp">
\[ \left| \begin{array}{cccc} 1 &amp; x_i &amp; y_i &amp; x_i ^2 + y_i ^2 - w_i \\ 1 &amp; x_j &amp; y_j &amp; x_j ^2 + y_j ^2 - w_j \\ 1 &amp; x_k &amp; y_k &amp; x_k ^2 + y_k ^2 - w_k \\ 1 &amp; x_l &amp; y_l &amp; x_l ^2 + y_l ^2 - w_l \end{array} \right| \]
</p>
<p>A pair of neighboring faces \( p_ip_jp_k\) and \( p_ip_jp_l\) is said to be locally regular (with respect to the weights in \( { PW}\)) if the power test of \( (p_i, w_i)\), \( (p_j, w_j)\), \( (p_k, w_k)\), and \( (p_l, w_l)\) is positive. A classical result of computational geometry establishes that a triangulation of the convex hull of \( { P}\) such that any pair of neighboring faces is regular with respect to \( { PW}\), is a regular triangulation of \( { PW}\).</p>
<p>Alternatively, the regular triangulation of the weighted points set \( { PW}\) can be obtained as the projection on the two dimensional plane of the convex hull of the set of three dimensional points \( { P'}= \{ (p_i,p_i ^2 - w_i ) | i = 1, \ldots , n \}\).</p>
<p>The class <code><a class="el" href="classCGAL_1_1Regular__triangulation__2.html" title="The class Regular_triangulation_2 is designed to maintain the regular triangulation of a set of weigh...">Regular_triangulation_2</a>&lt;Traits, Tds&gt;</code> is designed to maintain the regular triangulation of a set of \( 2d\) weighted points. It derives from the class <code><a class="el" href="classCGAL_1_1Triangulation__2.html" title="The class Triangulation_2 is the basic class designed to handle triangulations of set of points  in t...">Triangulation_2</a>&lt;Traits, Tds&gt;</code>. The functions <code>insert</code> and <code>remove</code> are overwritten to handle weighted points and maintain the regular property. The function <code>move()</code> is not overwritten and thus does not preserve the regular property. The vertices of the regular triangulation of a set of weighted points \( {PW}\) correspond only to a subset of \( {PW}\). Some of the input weighted points have no cell in the dual power diagrams and therefore do not correspond to a vertex of the regular triangulation. Such a point is called a hidden point. Because hidden points can reappear later on as vertices when some other point is removed, they have to be stored somewhere. The regular triangulation store those points in special vertices, called hidden vertices. A hidden point can reappear as vertex of the triangulation only when the two dimensional face that hides it is removed from the triangulation. To deal with this feature, each face of a regular triangulation stores a list of hidden vertices. The points in those vertices are reinserted in the triangulation when the face is removed.</p>
<p>Regular triangulation have member functions to construct the vertices and edges of the dual power diagrams.</p>
<h2><a class="anchor" id="Triangulation_2TheGeometricTraits"></a>
The Geometric Traits</h2>
<p>The geometric traits class of a regular triangulation must provide a weighted point type and a power test on these weighted points. The concept <code><a class="el" href="classRegularTriangulationTraits__2.html" title="The concept RegularTriangulationTraits_2 describes the requirements for the traits class of regular t...">RegularTriangulationTraits_2</a></code>, is a refinement of the concept <code><a class="el" href="classTriangulationTraits__2.html">TriangulationTraits_2</a></code>. All <span style="font-variant: small-caps;">CGAL</span> kernels are a model for the traits concept <code><a class="el" href="classRegularTriangulationTraits__2.html" title="The concept RegularTriangulationTraits_2 describes the requirements for the traits class of regular t...">RegularTriangulationTraits_2</a></code>.</p>
<h2><a class="anchor" id="Triangulation_2TheVertexTypeandFaceTypeof"></a>
The Vertex Type and Face Type of a Regular Triangulation</h2>
<p>The base vertex type of a regular triangulation includes a Boolean data member to mark the hidden state of the vertex. Therefore <span style="font-variant: small-caps;">CGAL</span> defines the concept <code><a class="el" href="classRegularTriangulationVertexBase__2.html" title="The regular triangulation of a set of weighted points does not necessarily have one vertex for each o...">RegularTriangulationVertexBase_2</a></code> which refine the concept <code><a class="el" href="classTriangulationVertexBase__2.html" title="The concept TriangulationVertexBase_2 describes the requirements for the vertex base class of a trian...">TriangulationVertexBase_2</a></code> and provides a default model for this concept.</p>
<p>The face base type of a regular triangulation is required to provide a list of hidden vertices, designed to store the points hidden by the face. It has to be a model of the concept <code><a class="el" href="classRegularTriangulationFaceBase__2.html" title="The regular triangulation of a set of weighted points does not necessarily have one vertex for each o...">RegularTriangulationFaceBase_2</a></code>. <span style="font-variant: small-caps;">CGAL</span> provides the templated class <code><a class="el" href="classCGAL_1_1Regular__triangulation__face__base__2.html" title="The class Regular_triangulation_face_base_2 is a model of the concept RegularTriangulationFaceBase_2...">Regular_triangulation_face_base_2</a>&lt;Traits&gt;</code> as a default base class for faces of regular triangulations.</p>
<h2><a class="anchor" id="Subsection_2D_Triangulations_Regular_Example"></a>
Example: a Regular Triangulation</h2>
<p>The following code creates a regular triangulation of a set of weighted points and output the number of vertices and the number of hidden vertices.</p>
<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2regular_8cpp-example.html">Triangulation_2/regular.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Regular_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Regular__triangulation__2.html">CGAL::Regular_triangulation_2&lt;K&gt;</a> Regular_triangulation;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">   std::ifstream in(<span class="stringliteral">"data/regular.cin"</span>);</div><div class="line"></div><div class="line">   Regular_triangulation::Weighted_point wp;</div><div class="line">   <span class="keywordtype">int</span> count = 0;</div><div class="line">   std::vector&lt;Regular_triangulation::Weighted_point&gt; wpoints;</div><div class="line">   <span class="keywordflow">while</span>(in &gt;&gt; wp){</div><div class="line">       count++;</div><div class="line">     wpoints.push_back(wp);</div><div class="line">   }</div><div class="line">   Regular_triangulation rt(wpoints.begin(), wpoints.end());</div><div class="line">   rt.is_valid();</div><div class="line">   std::cout &lt;&lt; <span class="stringliteral">"number of inserted points : "</span> &lt;&lt; count &lt;&lt; std::endl;</div><div class="line">   std::cout &lt;&lt; <span class="stringliteral">"number of vertices :  "</span> ;</div><div class="line">   std::cout &lt;&lt; rt.number_of_vertices() &lt;&lt; std::endl;</div><div class="line">   std::cout &lt;&lt; <span class="stringliteral">"number of hidden vertices :  "</span> ;</div><div class="line">   std::cout &lt;&lt; rt.number_of_hidden_vertices() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Section_2D_Triangulations_Constrained"></a>
Constrained Triangulations</h1>
<p>A constrained triangulation is a triangulation of a set of points that has to include among its edges a given set of polylines joining the points. The polylines are called <em>constraints</em>. The corresponding edges are called <em>constrained edges</em>.</p>
<p>The endpoints of constrained edges are of course vertices of the triangulation. However, the triangulation may include other vertices as well. There are three versions of constrained triangulations. </p><ul>
<li>
In the basic version, the constrained triangulation does not handle intersecting constraints, and the set of input constraints is required to be a set of segments that do not intersect, except possibly at their endpoints. Any number of constrained edges may share the same endpoint. Constrained edges may be vertical or have zero length. </li>
<li>
The two other versions support intersecting input constraints. In those versions, input constraints may consist of intersecting, overlapping or partially overlapping segments. The triangulation introduces additional vertices at each point that is the proper intersection point of two constraints. A single constraint intersecting other constraints will then appear as several constrained edges in the triangulation. There are two ways to deal with intersecting constraints. <ul>
<li>
The first one is robust when predicates are evaluated exactly but constructions (i. e. intersection computations) are approximate. </li>
<li>
The second one should be used with exact arithmetic (meaning exact evaluation of predicates and exact computation of intersections.) </li>
</ul>
</li>
</ul>
<div class="image">
<img src="constraints.png" alt="constraints.png" />
</div>
 <p>A constrained triangulation is represented in the <span style="font-variant: small-caps;">CGAL</span> library as an object of the class <code><a class="el" href="classCGAL_1_1Constrained__triangulation__2.html" title="A constrained triangulation is a triangulation of a set of points which has to include among its edge...">Constrained_triangulation_2</a>&lt;Traits,Tds,Itag&gt;</code>. The third parameter <code>Itag</code> is the intersection tag which serves to choose how intersecting constraints are dealt with. This parameter has to be instantiated by one of the following classes:</p><ul>
<li><code><a class="el" href="structCGAL_1_1No__intersection__tag.html" title="Intersection tag for constrained triangulations, when input constraints do not intersect. ">No_intersection_tag</a></code> when input constraints do not intersect</li>
<li><code><a class="el" href="structCGAL_1_1Exact__predicates__tag.html" title="Intersection tag for constrained triangulations, if the geometric traits provides exact predicates bu...">Exact_predicates_tag</a></code> if the geometric traits class provides exact predicates but approximate constructions</li>
<li><code><a class="el" href="structCGAL_1_1Exact__intersections__tag.html" title="Intersection tag for constrained triangulations, if exact predicates and exact constructions are prov...">Exact_intersections_tag</a></code> when exact predicates and exact constructions are provided.</li>
</ul>
<p>The class <code><a class="el" href="classCGAL_1_1Constrained__triangulation__2.html" title="A constrained triangulation is a triangulation of a set of points which has to include among its edge...">Constrained_triangulation_2</a>&lt;Traits,Tds, Itag&gt;</code> inherits from <code><a class="el" href="classCGAL_1_1Triangulation__2.html" title="The class Triangulation_2 is the basic class designed to handle triangulations of set of points  in t...">Triangulation_2</a>&lt;Traits,Tds&gt;</code>. A constrained triangulation can be created from a list of pairs of points which represent the constraints.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Constrained__triangulation__2.html" title="A constrained triangulation is a triangulation of a set of points which has to include among its edge...">Constrained_triangulation_2</a>&lt;Traits,Tds,Itag&gt;</code> overrides the insertion and removal of a point to take care of the information about constrained edges. The class also allows the user online insertion of a new constraint, given as sequence of points, or the removal of a constraint. In the current version, the function <code>move()</code> is not overwritten and thus does not handle vertices of constraints.</p>
<p>In order to retrieve the constrained edges of a constraint, or the constraints overlapping with a constrained edge, we provide the class <code><a class="el" href="classCGAL_1_1Constrained__triangulation__plus__2.html" title="The class Constrained_triangulation_plus_2&lt;Tr&gt; provides a constrained triangulation with an additiona...">Constrained_triangulation_plus_2</a></code>. See Section <a class="el" href="index.html#Section_2D_Triangulations_Constrained_Plus">Constrained Triangulations with a Bidirectional Mapping between Constraints and Subconstraints</a> for details. This class should also be used when doing exact intersection computations as it avoids the cascading of intersection computations.</p>
<h2><a class="anchor" id="Triangulation_2TheGeometricTraits_1"></a>
The Geometric Traits</h2>
<p>The geometric traits class of a constraint triangulation has to be a model of the concept <code><a class="el" href="classTriangulationTraits__2.html">TriangulationTraits_2</a></code>. When intersections of input constraints are supported, the geometric traits class has to be a model of the concept <code><a class="el" href="classConstrainedTriangulationTraits__2.html" title="The concept ConstrainedTriangulationTraits_2 defines the requirements for the geometric traits class ...">ConstrainedTriangulationTraits_2</a></code>, which refines the concept <code><a class="el" href="classTriangulationTraits__2.html">TriangulationTraits_2</a></code> providing additional function object types to compute the intersection of two segments.</p>
<h2><a class="anchor" id="Triangulation_2TheFaceBaseClassofaConstrained"></a>
The Face Base Class of a Constrained Triangulation</h2>
<p>The information about constrained edges is stored in the faces of the triangulation. The face base of a Constrained Triangulation has to be a model for the concept <code><a class="el" href="classConstrainedTriangulationFaceBase__2.html" title="In a constrained triangulation, the information about constrained edges is stored in the faces of the...">ConstrainedTriangulationFaceBase_2</a></code> which refines the concept <code><a class="el" href="classTriangulationFaceBase__2.html" title="The concept TriangulationFaceBase_2 describes the requirements for the base face class of a triangula...">TriangulationFaceBase_2</a></code>. The concept <code><a class="el" href="classConstrainedTriangulationFaceBase__2.html" title="In a constrained triangulation, the information about constrained edges is stored in the faces of the...">ConstrainedTriangulationFaceBase_2</a></code> requires member functions that get and set the constrained status of the edges.</p>
<p><span style="font-variant: small-caps;">CGAL</span> provides a default face base class for constrained triangulations. This class, named <code><a class="el" href="classCGAL_1_1Constrained__triangulation__face__base__2.html" title="The class Constrained_triangulation_face_base_2 is the default model for the concept ConstrainedTrian...">Constrained_triangulation_face_base_2</a>&lt;Traits&gt;</code>, derives from the class <code><a class="el" href="classCGAL_1_1Triangulation__face__base__2.html" title="The class Triangulation_face_base_2 is a model for the concept TriangulationFaceBase_2. ">Triangulation_face_base_2</a>&lt;Traits&gt;</code> and adds three Boolean data members to store the status of its edges.</p>
<p><a class="anchor" id="fig__Triangulation_2D_Fig_constrained"></a></p><div class="image">
<object type="image/svg+xml" data="poisson_del_poisson.svg">poisson_del_poisson.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Triangulation_2D_Fig_constrained">Figure 39.8</a> Constrained and Constrained Delaunay triangulation: the constraining edges are the black edges, a constrained triangulation is shown on the left, the constrained Delaunay triangulation with two examples of circumcircles is shown on the right.  </div>  <br />

<h1><a class="anchor" id="Section_2D_Triangulations_Constrained_Delaunay"></a>
Constrained Delaunay Triangulations</h1>
<p>A constrained Delaunay triangulation is a triangulation with constrained edges which try to be as much Delaunay as possible. As constrained edges are not necessarily Delaunay edges, the triangles of a constrained Delaunay triangulation do not necessarily fulfill the empty circle property but they fulfill a weaker <em>constrained empty circle property</em>. To state this property, it is convenient to think of constrained edges as blocking the view. Then, a triangulation is constrained Delaunay iff the circumscribing circle of any facet encloses no vertex visible from the interior of the facet. As in the case of constrained triangulations, three different versions of Delaunay constrained triangulations are provided. The first version handles a set of constraints which do not intersect except possibly at the endpoints. The two other versions handle intersecting input constraints. One of them is designed to be robust when used in conjunction with a geometric traits class providing exact predicates and approximate constructions (such as a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Filtered__kernel.html">Filtered_kernel</a></code> or any kernel providing filtered exact predicates). The third version is designed to be used with an exact arithmetic number type.</p>
<p>The <span style="font-variant: small-caps;">CGAL</span> class <code><a class="el" href="classCGAL_1_1Constrained__Delaunay__triangulation__2.html" title="A constrained Delaunay triangulation is a triangulation with constrained edges which tries to be as m...">Constrained_Delaunay_triangulation_2</a>&lt;Traits,Tds,Itag&gt;</code> is designed to represent constrained Delaunay triangulations.</p>
<p>As in the case of constrained triangulations, the third parameter <code>Itag</code> is the intersection tag and serves to choose how intersecting constraints are dealt with. It can be instantiated with one of the following classes: <code><a class="el" href="structCGAL_1_1No__intersection__tag.html" title="Intersection tag for constrained triangulations, when input constraints do not intersect. ">No_intersection_tag</a></code>, <code><a class="el" href="structCGAL_1_1Exact__predicates__tag.html" title="Intersection tag for constrained triangulations, if the geometric traits provides exact predicates bu...">Exact_predicates_tag</a></code>, <code><a class="el" href="structCGAL_1_1Exact__intersections__tag.html" title="Intersection tag for constrained triangulations, if exact predicates and exact constructions are prov...">Exact_intersections_tag</a></code> (see Section <a class="el" href="index.html#Section_2D_Triangulations_Constrained">Constrained Triangulations</a>).</p>
<p>A constrained Delaunay triangulation is not a Delaunay triangulation but it is a constrained triangulation. Therefore the class <code><a class="el" href="classCGAL_1_1Constrained__Delaunay__triangulation__2.html" title="A constrained Delaunay triangulation is a triangulation with constrained edges which tries to be as m...">Constrained_Delaunay_triangulation_2</a>&lt;Traits,Tds,Itag&gt;</code> derives from the class <code><a class="el" href="classCGAL_1_1Constrained__triangulation__2.html" title="A constrained triangulation is a triangulation of a set of points which has to include among its edge...">Constrained_triangulation_2</a>&lt;Traits,Tds,Itag&gt;</code>.</p>
<p>The constrained Delaunay triangulation has member functions to override the insertion and removal of a point or of a constraint. Each of those member functions takes care to restore the constrained empty circle property.</p>
<h2><a class="anchor" id="Triangulation_2TheGeometricTraits_2"></a>
The Geometric Traits</h2>
<p>The geometric traits class of a constrained Delaunay triangulation is required to provide the <code>side_of_oriented_circle</code> predicate as the geometric traits class of a Delaunay triangulation, and has to be a model of the concept <code><a class="el" href="classDelaunayTriangulationTraits__2.html" title="In addition to the requirements of the concept TriangulationTraits_2 the concept DelaunayTriangulatio...">DelaunayTriangulationTraits_2</a></code>. When intersecting input constraints is supported, the geometric traits class is further required to provide function objects to compute constraints intersections. Then, the geometric traits class has to be at the same time a model of the concept <code><a class="el" href="classConstrainedTriangulationTraits__2.html" title="The concept ConstrainedTriangulationTraits_2 defines the requirements for the geometric traits class ...">ConstrainedTriangulationTraits_2</a></code>.</p>
<h2><a class="anchor" id="Triangulation_2TheFaceBaseClass"></a>
The Face Base Class</h2>
<p>Information about the status (constrained or not) of the edges of the triangulation has to be stored in the face class, and the face base class of a constrained Delaunay triangulation has to be a model of <code><a class="el" href="classConstrainedTriangulationFaceBase__2.html" title="In a constrained triangulation, the information about constrained edges is stored in the faces of the...">ConstrainedTriangulationFaceBase_2</a></code>.</p>
<h2><a class="anchor" id="Subsection_2D_Triangulations_Constrained_Delaunay_Example"></a>
Example: a Constrained Delaunay Triangulation</h2>
<p>The following code inserts a set of intersecting constraint segments into a triangulation and counts the number of constrained edges of the resulting triangulation.</p>
<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2constrained_8cpp-example.html">Triangulation_2/constrained.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Exact__predicates__tag.html">CGAL::Exact_predicates_tag</a>                               Itag;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;K, CGAL::Default, Itag&gt;</a> CDT;</div><div class="line"><span class="keyword">typedef</span> CDT::Point          Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main( )</div><div class="line">{</div><div class="line">  CDT cdt;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Inserting a grid of 5x5 constraints "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 6; ++i)</div><div class="line">    cdt.<a class="code" href="classCGAL_1_1Constrained__Delaunay__triangulation__2.html#a4374cf307382b6ceee07db4bdc1e4e61">insert_constraint</a>( Point(0,i), Point(6,i));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt; 6; ++j)</div><div class="line">    cdt.insert_constraint( Point(j,0), Point(j,6));</div><div class="line"></div><div class="line">  assert(cdt.is_valid());</div><div class="line">  <span class="keywordtype">int</span> count = 0;</div><div class="line">  <span class="keywordflow">for</span> (CDT::Finite_edges_iterator eit = cdt.finite_edges_begin();</div><div class="line">       eit != cdt.finite_edges_end();</div><div class="line">       ++eit)</div><div class="line">    <span class="keywordflow">if</span> (cdt.is_constrained(*eit)) ++count;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The number of resulting constrained edges is  "</span>;</div><div class="line">  std::cout &lt;&lt;  count &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Subsection_2D_Triangulations_Polygon_triangulation"></a>
Example: Triangulating a Polygonal Domain</h2>
<p>The following code inserts two nested polygons into a constrained Delaunay triangulation and counts the number of facets that are inside the domain delimited by these polygons. Note that the following code does not work if the boundaries of the polygons intersect.</p>
<p><a class="anchor" id="fig__figuretri_domain"></a></p><div class="image">
<img src="tri_domain.png" alt="tri_domain.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figuretri_domain">Figure 39.9</a> Triangulation (in blue) of the domain delimited by the red polygons.  </div>  <br />

<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2polygon_triangulation_8cpp-example.html">Triangulation_2/polygon_triangulation.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_face_base_with_info_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>FaceInfo2</div><div class="line">{</div><div class="line">  FaceInfo2(){}</div><div class="line">  <span class="keywordtype">int</span> nesting_level;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> in_domain(){ </div><div class="line">    <span class="keywordflow">return</span> nesting_level%2 == 1;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>       K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__2.html">CGAL::Triangulation_vertex_base_2&lt;K&gt;</a>                      Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__face__base__with__info__2.html">CGAL::Triangulation_face_base_with_info_2&lt;FaceInfo2,K&gt;</a>    Fbb;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Constrained__triangulation__face__base__2.html">CGAL::Constrained_triangulation_face_base_2&lt;K,Fbb&gt;</a>        Fb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;</a>               TDS;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Exact__predicates__tag.html">CGAL::Exact_predicates_tag</a>                                Itag;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;K, TDS, Itag&gt;</a>  CDT;</div><div class="line"><span class="keyword">typedef</span> CDT::Point                                                Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;K&gt;</a>                                        Polygon_2;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> </div><div class="line">mark_domains(CDT&amp; ct, </div><div class="line">             CDT::Face_handle start, </div><div class="line">             <span class="keywordtype">int</span> index, </div><div class="line">             std::list&lt;CDT::Edge&gt;&amp; border )</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span>(start-&gt;info().nesting_level != -1){</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">  }</div><div class="line">  std::list&lt;CDT::Face_handle&gt; queue;</div><div class="line">  queue.push_back(start);</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span>(! queue.empty()){</div><div class="line">    CDT::Face_handle fh = queue.front();</div><div class="line">    queue.pop_front();</div><div class="line">    <span class="keywordflow">if</span>(fh-&gt;info().nesting_level == -1){</div><div class="line">      fh-&gt;info().nesting_level = index;</div><div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++){</div><div class="line">        CDT::Edge e(fh,i);</div><div class="line">        CDT::Face_handle n = fh-&gt;neighbor(i);</div><div class="line">        <span class="keywordflow">if</span>(n-&gt;info().nesting_level == -1){</div><div class="line">          <span class="keywordflow">if</span>(ct.is_constrained(e)) border.push_back(e);</div><div class="line">          <span class="keywordflow">else</span> queue.push_back(n);</div><div class="line">        }</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//explore set of facets connected with non constrained edges,</span></div><div class="line"><span class="comment">//and attribute to each such set a nesting level.</span></div><div class="line"><span class="comment">//We start from facets incident to the infinite vertex, with a nesting</span></div><div class="line"><span class="comment">//level of 0. Then we recursively consider the non-explored facets incident </span></div><div class="line"><span class="comment">//to constrained edges bounding the former set and increase the nesting level by 1.</span></div><div class="line"><span class="comment">//Facets in the domain are those with an odd nesting level.</span></div><div class="line"><span class="keywordtype">void</span></div><div class="line">mark_domains(CDT&amp; cdt)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span>(CDT::All_faces_iterator it = cdt.all_faces_begin(); it != cdt.all_faces_end(); ++it){</div><div class="line">    it-&gt;info().nesting_level = -1;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::list&lt;CDT::Edge&gt; border;</div><div class="line">  mark_domains(cdt, cdt.infinite_face(), 0, border);</div><div class="line">  <span class="keywordflow">while</span>(! border.empty()){</div><div class="line">    CDT::Edge e = border.front();</div><div class="line">    border.pop_front();</div><div class="line">    CDT::Face_handle n = e.first-&gt;neighbor(e.second);</div><div class="line">    <span class="keywordflow">if</span>(n-&gt;info().nesting_level == -1){</div><div class="line">      mark_domains(cdt, n, e.first-&gt;info().nesting_level+1, border);</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( )</div><div class="line">{</div><div class="line">  <span class="comment">//construct two non-intersecting nested polygons  </span></div><div class="line">  Polygon_2 polygon1;</div><div class="line">  polygon1.push_back(Point(0,0));</div><div class="line">  polygon1.push_back(Point(2,0));</div><div class="line">  polygon1.push_back(Point(2,2));</div><div class="line">  polygon1.push_back(Point(0,2));</div><div class="line">  Polygon_2 polygon2;</div><div class="line">  polygon2.push_back(Point(0.5,0.5));</div><div class="line">  polygon2.push_back(Point(1.5,0.5));</div><div class="line">  polygon2.push_back(Point(1.5,1.5));</div><div class="line">  polygon2.push_back(Point(0.5,1.5));</div><div class="line">  </div><div class="line">  <span class="comment">//Insert the polygons into a constrained triangulation</span></div><div class="line">  CDT cdt;</div><div class="line">  cdt.insert_constraint(polygon1.vertices_begin(), polygon1.vertices_end(), <span class="keyword">true</span>);</div><div class="line">  cdt.insert_constraint(polygon2.vertices_begin(), polygon2.vertices_end(), <span class="keyword">true</span>);</div><div class="line">  </div><div class="line">  <span class="comment">//Mark facets that are inside the domain bounded by the polygon</span></div><div class="line">  mark_domains(cdt);</div><div class="line">  </div><div class="line">  <span class="keywordtype">int</span> count=0;</div><div class="line">  <span class="keywordflow">for</span> (CDT::Finite_faces_iterator fit=cdt.finite_faces_begin();</div><div class="line">                                  fit!=cdt.finite_faces_end();++fit)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> ( fit-&gt;info().in_domain() ) ++count;</div><div class="line">  }</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"There are "</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">" facets in the domain."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Section_2D_Triangulations_Constrained_Plus"></a>
Constrained Triangulations with a Bidirectional Mapping between Constraints and Subconstraints</h1>
<p>The class <code><a class="el" href="classCGAL_1_1Constrained__triangulation__plus__2.html" title="The class Constrained_triangulation_plus_2&lt;Tr&gt; provides a constrained triangulation with an additiona...">Constrained_triangulation_plus_2</a>&lt;Tr&gt;</code> provides a constrained triangulation with an additional data structure that keeps track of the input constraints and of their refinement in the triangulation. The class <code><a class="el" href="classCGAL_1_1Constrained__triangulation__plus__2.html" title="The class Constrained_triangulation_plus_2&lt;Tr&gt; provides a constrained triangulation with an additiona...">Constrained_triangulation_plus_2</a>&lt;Tr&gt;</code> inherits from its template parameter Tr, which has to be instantiated by a constrained or constrained Delaunay triangulation. According to its intersection tag, the base class will support intersecting input constraints or not. When intersections of input constraints are supported, the base class constructs a triangulation of the arrangement of the constraints, introducing new vertices at each proper intersection point.</p>
<p>The triangulation maintains for each input constraint the sequence of vertices on this constraint. These vertices are either vertices of the input constraint or intersection points.</p>
<p>Two consecutive vertices of an input constraint form a <em>subconstraint</em>. The triangulation enables the retrieval of the set of subconstraints of the triangulation (not ordered along constraints).</p>
<p>It further enables the retrieval of the set of input constraints that induce a subconstraint. As it is straightforward to obtain a subconstraint from a constrained edge <code>e</code>, one can easily obtain the input constraints that induce <code>e</code>.</p>
<h2><a class="anchor" id="Subsection_Edges_and_Constraints"></a>
Edges, Constrained Edges, Constraints, and Subconstraints</h2>
<p>All triangulation classes define the type <code>Edge</code> as <code>typedef std::pair&lt;Face_handle, int&gt; Edge</code>. For a pair <code>(fh,i)</code> it is the edge of the face <code>*fh</code>, which is opposite to the <code>i</code>'th vertex.</p>
<p>A <em>constrained edge</em> <code>e</code> is an edge of a constrained triangulation <code>ct</code>, for which <code>ct.is_constrained(e)</code> returns <code>true</code>.</p>
<p>A <em>constraint</em> is a polyline which is given as input (in the simplest case just a segment), and which is split into constrained edges in the triangulation.</p>
<p>The type <code>Subconstraint</code> is defined as <code>typedef std::pair&lt;Vertex_handle,Vertex_handle&gt; Subconstraint</code>. The two vertex handles must be the vertices of a constrained edge.</p>
<p>The type <code>Constraint_id</code> identifies a constraint.</p>
<p>All constrained triangulation classes of <span style="font-variant: small-caps;">CGAL</span> provide functions to insert constraints, have the notion of constrained edges, and offer a <code>Constrained_edges_iterator</code>.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Constrained__triangulation__plus__2.html" title="The class Constrained_triangulation_plus_2&lt;Tr&gt; provides a constrained triangulation with an additiona...">Constrained_triangulation_plus_2</a></code> additionally provides the means to</p><ul>
<li>traverse all the constraints of the triangulation using an iterator of type <code>Constraint_iterator</code> the value type of which is <code>Constraint_id</code>,</li>
<li>obtain all constraints that induce a constrained edge or a subconstraint,</li>
<li>traverse the sequence of vertices of a constraint using an iterator of type <code>Vertices_in_constraint_iterator</code>, the value type of which is <code>Vertex_handle</code></li>
<li>traverse the subconstraints in the triangulation using an iterator of type <code>Subconstraint_iterator</code>,the value type of which is <code>Subconstraint</code>.</li>
</ul>
<p>Note that the <code>Constrained_edges_iterator</code> and the <code>Subconstraint_iterator</code> are quite similar. The <code>Constrained_edges_iterator</code> traverses all edges and skips those that are <em>not</em> constrained, which means that the time of traversal will be linear in the number of total edges. whereas the <code>Subconstraint_iterator</code> traverses a set of subconstraints stored in the triangulation.</p>
<p>On the other hand, as a subconstraint is only a pair of vertex handles, determining the corresponding <code>Edge</code> takes the smaller degree of the two vertices, wheresas obtaining an Edge from a subconstraint is a constant time operation.</p>
<h2><a class="anchor" id="Subsection_Constrained_plus_avoids_cascacding"></a>
The Intersection Tag</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Constrained__triangulation__plus__2.html" title="The class Constrained_triangulation_plus_2&lt;Tr&gt; provides a constrained triangulation with an additiona...">Constrained_triangulation_plus_2</a>&lt;Tr&gt;</code> is especially useful when the base constrained triangulation class handles intersections of constraints and uses an exact number type, i.e. when its intersection tag is <code><a class="el" href="structCGAL_1_1Exact__intersections__tag.html" title="Intersection tag for constrained triangulations, if exact predicates and exact constructions are prov...">Exact_intersections_tag</a></code>. In this case, the <code><a class="el" href="classCGAL_1_1Constrained__triangulation__plus__2.html" title="The class Constrained_triangulation_plus_2&lt;Tr&gt; provides a constrained triangulation with an additiona...">Constrained_triangulation_plus_2</a>&lt;Tr&gt;</code> avoids cascading in the computations of intersection points.</p>
<p>This is best explained with an example.</p>
<p><a class="anchor" id="fig__figuretri_avoidcascading"></a></p><div class="image">
<img src="CDTplusAvoidCascading.png" alt="CDTplusAvoidCascading.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figuretri_avoidcascading">Figure 39.10</a> Computation of an intersection with an input constraint instead of with an edge.  </div>  <br />

<p>When inserting a constraint, say a segment <code>s</code> in the triangulation, this segment may intersect a constrained edge <code>e</code> with the vertices <code>p</code> and <code>q</code>. The algorithm could compute the intersection point <code>i</code> of <code>s</code> with the segment <code>[p,q]</code>. Because these points may be previously constructed intersection points, as <code>q</code> in the figure above, it is better to use an input constraint <code>c</code> that induce the edge. If <code>c</code> is a segment, the algorithm intersects <code>s</code> with <code>c</code>. If <code>c</code> is a polyline, the algorithm finds two vertices from the input constraint that define an input segment that induce <code>e</code>.</p>
<h2><a class="anchor" id="Triangulation_2ExampleBuildingaTriangulated"></a>
Example: Building a Triangulated Arrangement of Polylines</h2>
<p>The following code inserts two polyline constraints into a triangulation. Note that if the triangulation supports intersections we can have arbitrary complicated overlapping polylines. They can share any number of edges, and a polyline may pass several times through the same edge.</p>
<p>For an edge we can further find out how many and which polyline constraints pass through it. For an edge we can obtain an iterator range with value type <code><a class="el" href="classCGAL_1_1Constrained__triangulation__plus__2_1_1Context.html" title="A context enables the access to the vertices of a constraint that pass through a subconstraint. ">Constrained_triangulation_plus_2::Context</a></code>. From a context we can obtain the <code><a class="el" href="classCGAL_1_1Constrained__triangulation__plus__2.html#a136e59f7ed41cac6f861ae614bba1f3d" title="The identifier of a polyline constraint. ">Constrained_triangulation_plus_2::Constraint_id</a></code>, and an iterator pointing at the vertex in the polyline constraint that passes through the edge.</p>
<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2polylines_triangulation_8cpp-example.html">Triangulation_2/polylines_triangulation.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_triangulation_plus_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>                 K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;K&gt;</a>                                                Polygon_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Exact__intersections__tag.html">CGAL::Exact_intersections_tag</a>                                     Itag;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;K,CGAL::Default, Itag&gt;</a> CDT;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2&lt;CDT&gt;</a>                       CDTP;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CDTP::Point                                                       Point;</div><div class="line"><span class="keyword">typedef</span> CDTP::Constraint_id                                               Cid;</div><div class="line"><span class="keyword">typedef</span> CDTP::Vertex_handle                                               Vertex_handle;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> </div><div class="line">print(<span class="keyword">const</span> CDTP&amp; cdtp, Cid cid)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> CDTP::Vertices_in_constraint Vertices_in_constraint;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Polyline constraint:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(Vertices_in_constraint it = cdtp.vertices_in_constraint_begin(cid);</div><div class="line">      it !=cdtp.vertices_in_constraint_end(cid);</div><div class="line">      it++){</div><div class="line">    Vertex_handle vh = *it;</div><div class="line">    std::cout &lt;&lt; vh-&gt;point() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> </div><div class="line">contexts(<span class="keyword">const</span> CDTP&amp; cdtp)</div><div class="line">{</div><div class="line">  CDTP::Subconstraint_iterator</div><div class="line">    beg = cdtp.<a class="code" href="classCGAL_1_1Constrained__triangulation__plus__2.html#ad02088fd486bc5b753d8fc781e867630">subconstraints_begin</a>(),</div><div class="line">    end = cdtp.subconstraints_end();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(; beg!=end; ++beg){</div><div class="line">    Vertex_handle vp = beg-&gt;first.first, vq = beg-&gt;first.second;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(cdtp.number_of_enclosing_constraints(vp, vq) == 2){</div><div class="line">      CDTP::Context_iterator cbeg = cdtp.contexts_begin(vp,vq),</div><div class="line">        cend = cdtp.contexts_end(vp,vq);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"subconstraint "</span> &lt;&lt; vp-&gt;point() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; vq-&gt;point() </div><div class="line">                &lt;&lt; <span class="stringliteral">" is on constraints starting at:\n"</span>;</div><div class="line">      <span class="keywordflow">for</span>(; cbeg !=  cend; ++cbeg){</div><div class="line">        CDTP::Context c = *cbeg;</div><div class="line">        std::cout &lt;&lt; (*(c.vertices_begin()))-&gt;point() &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main( )</div><div class="line">{</div><div class="line">  CDTP cdtp;</div><div class="line"></div><div class="line">  cdtp.insert_constraint(Point(0,0), Point(1,1));</div><div class="line"></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  points.push_back(Point(1,1));</div><div class="line">  points.push_back(Point(5,2));</div><div class="line">  points.push_back(Point(6,0));</div><div class="line">  points.push_back(Point(3,0));</div><div class="line">  Cid id1 = cdtp.insert_constraint(points.begin(), points.end());</div><div class="line"></div><div class="line">  print(cdtp, id1);</div><div class="line"></div><div class="line">  Polygon_2 poly;</div><div class="line">  poly.push_back(Point(2,3));</div><div class="line">  poly.push_back(Point(4,0));</div><div class="line">  poly.push_back(Point(5,0));</div><div class="line">  poly.push_back(Point(6,2));</div><div class="line"></div><div class="line">  Cid id2 = cdtp.insert_constraint(poly.vertices_begin(), poly.vertices_end(), <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  print(cdtp, id1);</div><div class="line">  print(cdtp, id2);</div><div class="line"></div><div class="line">  contexts(cdtp);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Section_2D_Triangulations_Hierarchy"></a>
The Triangulation Hierarchy</h1>
<p>The class <code><a class="el" href="classCGAL_1_1Triangulation__hierarchy__2.html" title="The class Triangulation_hierarchy_2 implements a triangulation augmented with a data structure which ...">Triangulation_hierarchy_2</a>&lt;Tr&gt;</code> implements a triangulation augmented with a data structure to efficiently answer point location queries. The data structure is a hierarchy of triangulations. The triangulation at the lowest level is the original triangulation where operations and point location are to be performed. Then at each succeeding level, the data structure stores a triangulation of a small random sample of the vertices of the triangulation at the preceding level. Point location is done through a top down nearest neighbor query. The nearest neighbor query is first performed naively in the top level triangulation. Then, at each following level, the nearest neighbor at that level is found through a linear walk performed from the nearest neighbor found at the preceding level. Because the number of vertices in each triangulation is only a small fraction of the number of vertices of the preceding triangulation, the data structure remains small and achieves fast point location queries on real data. As proved in <a class="el" href="citelist.html#CITEREF_d-iirdt-98">[3]</a>, this structure has an optimal behavior when it is built for Delaunay triangulations. However, it can be used as well for other triangulations and the class <code><a class="el" href="classCGAL_1_1Triangulation__hierarchy__2.html" title="The class Triangulation_hierarchy_2 implements a triangulation augmented with a data structure which ...">Triangulation_hierarchy_2</a>&lt;Tr&gt;</code> is templated by a parameter which is to be instantiated by one of the <span style="font-variant: small-caps;">CGAL</span> triangulation classes.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Triangulation__hierarchy__2.html" title="The class Triangulation_hierarchy_2 implements a triangulation augmented with a data structure which ...">Triangulation_hierarchy_2</a>&lt;Tr&gt;</code> inherits from the triangulation type passed as template parameter <code>Tr</code>. The <code>insert</code>, <code>move</code>, and <code>remove</code> member functions are overwritten to update the data structure at each operation. The locate queries are also overwritten to take advantage of the data structure for a fast processing.</p>
<h2><a class="anchor" id="Triangulation_2TheVertexofaTriangulation"></a>
The Vertex of a Triangulation Hierarchy</h2>
<p>The base vertex class of a triangulation hierarchy has to be a model of the concept <code><a class="el" href="classTriangulationHierarchyVertexBase__2.html" title="The vertex of a triangulation included in a triangulation hierarchy has to provide some pointers to t...">TriangulationHierarchyVertexBase_2</a></code> which extends the concept <code><a class="el" href="classTriangulationVertexBase__2.html" title="The concept TriangulationVertexBase_2 describes the requirements for the vertex base class of a trian...">TriangulationVertexBase_2</a></code>. This extension adds access and setting member functions for two pointers to the corresponding vertices in the triangulations of the next and preceding levels.</p>
<p><span style="font-variant: small-caps;">CGAL</span> provides the class <code><a class="el" href="classCGAL_1_1Triangulation__hierarchy__vertex__base__2.html" title="The class Triangulation_hierarchy_vertex_base_2 is designed to be used as a vertex base class of a tr...">Triangulation_hierarchy_vertex_base_2</a>&lt;Vb&gt;</code> which is a model for the concept <code><a class="el" href="classTriangulationHierarchyVertexBase__2.html" title="The vertex of a triangulation included in a triangulation hierarchy has to provide some pointers to t...">TriangulationHierarchyVertexBase_2</a></code>. This class is templated by a parameter <code>Vb</code> which is to be instantiated by a model of the concept <code><a class="el" href="classTriangulationVertexBase__2.html" title="The concept TriangulationVertexBase_2 describes the requirements for the vertex base class of a trian...">TriangulationVertexBase_2</a></code>. The class <code><a class="el" href="classCGAL_1_1Triangulation__hierarchy__vertex__base__2.html" title="The class Triangulation_hierarchy_vertex_base_2 is designed to be used as a vertex base class of a tr...">Triangulation_hierarchy_vertex_base_2</a>&lt;Vb&gt;</code> inherits from its template parameter <code>Vb</code>. This design enables the usage of either the default vertex class or a user customized vertex class with additional functionalities for <code>Vb</code>.</p>
<h2><a class="anchor" id="Subsection_2D_Triangulations_Hierarchy_Examples"></a>
Examples For the Use of a Triangulation Hierarchy</h2>
<p>The following program is an example for the standard use of a triangulation hierarchy to enhance the efficiency of a Delaunay triangulation. The program outputs the number of vertices at the different levels of the hierarchy. <br />
<b>File</b> <a class="el" href="Triangulation_2_2hierarchy_8cpp-example.html">Triangulation_2/hierarchy.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_hierarchy_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/algorithm.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__2.html">CGAL::Triangulation_vertex_base_2&lt;K&gt;</a>             Vbb;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__hierarchy__vertex__base__2.html">CGAL::Triangulation_hierarchy_vertex_base_2&lt;Vbb&gt;</a> Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__face__base__2.html">CGAL::Triangulation_face_base_2&lt;K&gt;</a>               Fb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;</a>      Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K,Tds&gt;</a>            Dt;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__hierarchy__2.html">CGAL::Triangulation_hierarchy_2&lt;Dt&gt;</a>              Triangulation;</div><div class="line"><span class="keyword">typedef</span> Triangulation::Point                             Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">CGAL::Creator_uniform_2&lt;double,Point&gt;</a>            Creator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( )</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"insertion of 1000 random points"</span> &lt;&lt; std::endl;</div><div class="line">  Triangulation t;</div><div class="line">  CGAL::Random_points_in_square_2&lt;Point,Creator&gt; g(1.);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gadba21cc5c30a79519438dfe0f9264255">CGAL::cpp11::copy_n</a>( g, 1000, std::back_inserter(t));</div><div class="line"></div><div class="line">  <span class="comment">//verbose mode of is_valid ; shows the number of vertices at each  level</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The number of vertices at successive levels"</span> &lt;&lt; std::endl;</div><div class="line">  assert(t.is_valid(<span class="keyword">true</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The following program shows how to use a triangulation hierarchy in conjunction with a constrained triangulation with a constaint hierarchy.</p>
<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2constrained_hierarchy_plus_8cpp-example.html">Triangulation_2/constrained_hierarchy_plus.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_hierarchy_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_triangulation_plus_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__2.html">CGAL::Triangulation_vertex_base_2&lt;K&gt;</a>             Vbb;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__hierarchy__vertex__base__2.html">CGAL::Triangulation_hierarchy_vertex_base_2&lt;Vbb&gt;</a> Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Constrained__triangulation__face__base__2.html">CGAL::Constrained_triangulation_face_base_2&lt;K&gt;</a>   Fb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;</a>      TDS;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Exact__predicates__tag.html">CGAL::Exact_predicates_tag</a>                       Itag;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;K,TDS,Itag&gt;</a> CDT;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__hierarchy__2.html">CGAL::Triangulation_hierarchy_2&lt;CDT&gt;</a>             CDTH;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2&lt;CDTH&gt;</a>     Triangulation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Triangulation::Point                             Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main( )</div><div class="line">{</div><div class="line">  Triangulation cdt;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Inserting a grid 5 x 5 of  constraints "</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 6; ++i)</div><div class="line">    cdt.<a class="code" href="classCGAL_1_1Constrained__triangulation__plus__2.html#aa8870c3ead46efaac0c7c7f3916b4ed5">insert_constraint</a>( Point(0,i), Point(6,i));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt; 6; ++j)</div><div class="line">    cdt.insert_constraint( Point(j,0), Point(j,6));</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> count = 0;</div><div class="line">  <span class="keywordflow">for</span> (Triangulation::Subconstraint_iterator scit = cdt.subconstraints_begin();</div><div class="line">       scit != cdt.subconstraints_end();</div><div class="line">       ++scit)  ++count;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The number of resulting constrained edges is  "</span>;</div><div class="line">  std::cout &lt;&lt;  count &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">//verbose mode of is_valid ; shows the number of vertices at each  level</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The number of vertices at successive levels"</span> &lt;&lt; std::endl;</div><div class="line">  assert(cdt.is_valid(<span class="keyword">true</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Section_2D_Triangulations_Flexibility"></a>
Flexibility</h1>
<h2><a class="anchor" id="Triangulation_2UsingCustomizedVerticesand"></a>
Using Customized Vertices and Faces</h2>
<p>To be able to adapt to various needs, a highly flexible design has been selected for 2D triangulations. We have already seen that the triangulation classes have two parameters: a geometric traits class and a triangulation data structure class which the user can instantiate with his own customized classes.</p>
<p>The most useful flexibility however comes from the fact that the triangulation data structure itself has two template parameters to be instantiated by classes for the vertices and faces of the triangulation. Using his own customized classes to instantiate these parameters, the user can easily build up a triangulation with additional information or functionality in the vertices and faces.</p>
<h2><a class="anchor" id="Triangulation_2ACyclicDependency"></a>
A Cyclic Dependency</h2>
<p>To insure flexibility, the triangulation data structure is templated by the vertex and face base classes. Also since incidence and adjacency relations are stored in vertices and faces, the base classes have to know the types of handles on vertices and faces provided by the triangulation data structure. Thus the vertex and face base classes have to be themselves parameterized by the triangulation data structure, and there is a cyclic dependency on template parameter.</p>
<p><a class="anchor" id="fig__Triangulation_2D_Fig_three_levels_2"></a></p><div class="image">
<img src="threelevels2.png" alt="threelevels2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Triangulation_2D_Fig_three_levels_2">Figure 39.11</a> The cyclic dependency in triangulations software design.  </div>  <br />

<p>Previously, this cyclic dependency was avoided by using only <code>void*</code> pointers in the interface of base classes. These <code>void*</code> were converted to appropriate types at the triangulation data structure levels. This solution had some drawbacks : mainly the user could not add in the vertices or faces of the triangulation a functionality related to types defined by the triangulation data structure, for instance a handle to a vertex, and he was lead to use himself <code>void*</code> pointers). The new solution to resolve the template dependency is based on a rebind mechanism similar to the mechanism used in the standard allocator class std::allocator. The rebind mechanism is described in Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/index.html#TDS_2D_default">The Default Triangulation Data Structure</a> of Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/index.html#Chapter_2D_Triangulation_Data_Structure">2D Triangulation Data Structure</a>. For now, we will just notice that the design requires the existence in the vertex and face base classes of a nested template class <code>Rebind_TDS</code> defining a type <code>Other</code> used by the rebinding mechanism.</p>
<p>The two following examples show how the user can put in use the flexibility offered by the base classes parameters.</p>
<h2><a class="anchor" id="Triangulation_2AddingColors"></a>
Adding Colors</h2>
<p>The first example corresponds to a case where the user wishes to add in the vertices or faces of the triangulation an additional information that does not depend on types provided by the triangulation data structure. In that case, predefined classes <code><a class="el" href="classCGAL_1_1Triangulation__vertex__base__with__info__2.html" title="The class Triangulation_vertex_base_with_info_2 is designed to be used as a base vertex class of a tr...">Triangulation_vertex_base_with_info_2</a>&lt;Info,Traits,Vb&gt;</code> or <code><a class="el" href="classCGAL_1_1Triangulation__face__base__with__info__2.html" title="The class Triangulation_face_base_with_info_2 is a model of the concept TriangulationFaceBase_2 to be...">Triangulation_face_base_with_info_2</a>&lt;Info,Traits,Vb&gt;</code> can be used. Those classes have a template parameter <code>Info</code> devoted to handle additional information. The following example shows how to add a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Color.html">Color</a></code> in the triangulation faces.</p>
<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2colored_face_8cpp-example.html">Triangulation_2/colored_face.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Color.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_face_base_with_info_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__2.html">CGAL::Triangulation_vertex_base_2&lt;K&gt;</a> Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__face__base__with__info__2.html">CGAL::Triangulation_face_base_with_info_2&lt;CGAL::Color,K&gt;</a> Fb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;</a> Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2&lt;K,Tds&gt;</a> Triangulation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Triangulation::Face_handle Face_handle;</div><div class="line"><span class="keyword">typedef</span> Triangulation::Finite_faces_iterator Finite_faces_iterator;</div><div class="line"><span class="keyword">typedef</span> Triangulation::Point  Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Triangulation t;</div><div class="line">  t.<a class="code" href="classCGAL_1_1Triangulation__2.html#a1025cd7e7226ccb44d82f0fb1d63ad4e">insert</a>(Point(0,1));</div><div class="line">  t.insert(Point(0,0));</div><div class="line">  t.insert(Point(2,0));</div><div class="line">  t.insert(Point(2,2));</div><div class="line"></div><div class="line">  Finite_faces_iterator fc = t.finite_faces_begin();</div><div class="line">  <span class="keywordflow">for</span>( ; fc != t.finite_faces_end(); ++fc)  fc-&gt;info() = CGAL::BLUE;</div><div class="line"></div><div class="line">  Point p(0.5,0.5);</div><div class="line">  Face_handle fh = t.locate(p);</div><div class="line">  fh-&gt;info() = CGAL::RED;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The second example adds a <code>std::string</code> in the vertices of a terrain.</p>
<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2terrain_with_info_8cpp-example.html">Triangulation_2/terrain_with_info.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_traits_xy_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;K&gt;</a>  Gt;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__with__info__2.html">CGAL::Triangulation_vertex_base_with_info_2&lt;std::string, Gt&gt;</a> Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vb&gt;</a> Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Gt,Tds&gt;</a> Delaunay;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> K::Point_3   Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Delaunay dt;</div><div class="line">  Delaunay::Vertex_handle vh;</div><div class="line"></div><div class="line">  vh  = dt.<a class="code" href="classCGAL_1_1Delaunay__triangulation__2.html#a81efeca7e8a7605aba1d3b4f951a96dc">insert</a>(Point(0,0,0));</div><div class="line">  vh-&gt;info() = <span class="stringliteral">"Paris"</span>;</div><div class="line">  vh = dt.insert(Point(1,0,0.1));</div><div class="line">  vh-&gt;info() = <span class="stringliteral">"London"</span>;</div><div class="line">  vh = dt.insert(Point(0,1,0.2));</div><div class="line">  vh-&gt;info() = <span class="stringliteral">"New York"</span>;</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Triangulation_2AddingHandles"></a>
Adding Handles</h2>
<p>This example shows how the user can still derive and plug in his own vertex or face class when he would like to have additional functionalities depending on types provided by the triangulation data structure.</p>
<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2adding_handles_8cpp-example.html">Triangulation_2/adding_handles.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">/* A vertex class with an additionnal handle */</span></div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> Gt, <span class="keyword">class</span> Vb = CGAL::Triangulation_vertex_base_2&lt;Gt&gt; &gt;</div><div class="line"><span class="keyword">class </span>My_vertex_base</div><div class="line">  : <span class="keyword">public</span>  Vb</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Vb                              Base;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Vb::Vertex_handle      Vertex_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Vb::Face_handle        Face_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Vb::Point              Point;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt; <span class="keyword">typename</span> TDS2 &gt;</div><div class="line">  <span class="keyword">struct </span>Rebind_TDS {</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Vb::template Rebind_TDS&lt;TDS2&gt;::Other    Vb2;</div><div class="line">    <span class="keyword">typedef</span> My_vertex_base&lt;Gt,Vb2&gt;                           Other;</div><div class="line">  };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Vertex_handle  va_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  My_vertex_base() : Base() {}</div><div class="line">  My_vertex_base(<span class="keyword">const</span> Point &amp; p) : Base(p) {}</div><div class="line">  My_vertex_base(<span class="keyword">const</span> Point &amp; p, Face_handle f) : Base(f,p) {}</div><div class="line">  My_vertex_base(Face_handle f) : Base(f) {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_associated_vertex(Vertex_handle va) { va_ = va;}</div><div class="line">  Vertex_handle get_associated_vertex() {<span class="keywordflow">return</span> va_ ; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> My_vertex_base&lt;K&gt; Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vb&gt;</a> Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2&lt;K,Tds&gt;</a> Triangulation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Triangulation::Vertex_handle Vertex_handle;</div><div class="line"><span class="keyword">typedef</span> Triangulation::Finite_faces_iterator Finite_faces_iterator;</div><div class="line"><span class="keyword">typedef</span> Triangulation::Point   Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Triangulation t;</div><div class="line">  Vertex_handle v0 = t.<a class="code" href="classCGAL_1_1Triangulation__2.html#a1025cd7e7226ccb44d82f0fb1d63ad4e">insert</a>(Point(0,1));</div><div class="line">  Vertex_handle v1 = t.insert(Point(0,0));</div><div class="line">  Vertex_handle v2 = t.insert(Point(2,0));</div><div class="line">  Vertex_handle v3 = t.insert(Point(2,2));</div><div class="line"></div><div class="line">  <span class="comment">// associate vertices as you like</span></div><div class="line">  v0-&gt;set_associated_vertex(v1);</div><div class="line">  v1-&gt;set_associated_vertex(v2);</div><div class="line">  v2-&gt;set_associated_vertex(v3);</div><div class="line">  v3-&gt;set_associated_vertex(v0);</div><div class="line">  assert( v0-&gt;get_associated_vertex() == v1);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Triangulation_2SettingInformationWhileInserting"></a>
Setting Information While Inserting a Range of Points</h2>
<p>The most efficient method to insert (weighted) points in a Delaunay (or regular) triangulation is to provide an iterator range over (weighted) points to the insert function. However, an iterator range of (weighted) points does not allow the user to set different information to each vertex. To solve this problem, in the case the vertex type of the triangulation is a model of the concept <code><a class="el" href="classTriangulationVertexBaseWithInfo__2.html" title="A type model of this concept can be used as vertex base by a triangulation and provides an additional...">TriangulationVertexBaseWithInfo_2</a></code> (such as <code><a class="el" href="classCGAL_1_1Triangulation__vertex__base__with__info__2.html" title="The class Triangulation_vertex_base_with_info_2 is designed to be used as a base vertex class of a tr...">Triangulation_vertex_base_with_info_2</a></code>), we provide three examples doing the same operation: set an unsigned integer as the information of each vertex. The value of this unsigned integer is the initial order of the corresponding point given in the range.</p>
<h2><a class="anchor" id="Triangulation_2UsinganIteratorOverPairs"></a>
Using an Iterator Over Pairs</h2>
<p>Each point and its information are gathered into a pair. We provide the <code>insert</code> function of the triangulation with a range of such pairs. <br />
<b>File</b> <a class="el" href="Triangulation_2_2info_insert_with_pair_iterator_2_8cpp-example.html">Triangulation_2/info_insert_with_pair_iterator_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>         K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__with__info__2.html">CGAL::Triangulation_vertex_base_with_info_2&lt;unsigned, K&gt;</a>    Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vb&gt;</a>                    Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</a>                      Delaunay;</div><div class="line"><span class="keyword">typedef</span> Delaunay::Point                                             Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::vector&lt; std::pair&lt;Point,unsigned&gt; &gt; points;</div><div class="line">  points.push_back( std::make_pair(Point(0,0),0)   );</div><div class="line">  points.push_back( std::make_pair(Point(1,0),1)   );</div><div class="line">  points.push_back( std::make_pair(Point(0,1),2)   );</div><div class="line">  points.push_back( std::make_pair(Point(14,4),3)  );</div><div class="line">  points.push_back( std::make_pair(Point(2,2),4)   );</div><div class="line">  points.push_back( std::make_pair(Point(-4,0),5)  );</div><div class="line"></div><div class="line">  </div><div class="line">  Delaunay T;</div><div class="line">  T.insert( points.begin(),points.end() );</div><div class="line"></div><div class="line">  CGAL_assertion( T.number_of_vertices() == 6 );</div><div class="line"></div><div class="line">  <span class="comment">// check that the info was correctly set.</span></div><div class="line">  Delaunay::Finite_vertices_iterator vit;</div><div class="line">  <span class="keywordflow">for</span> (vit = T.finite_vertices_begin(); vit != T.finite_vertices_end(); ++vit)</div><div class="line">    <span class="keywordflow">if</span>( points[ vit-&gt;info() ].first != vit-&gt;point() ){</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Error different info"</span> &lt;&lt; std::endl;</div><div class="line">      exit(EXIT_FAILURE);</div><div class="line">    }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"OK"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Triangulation_2UsingtheBoostZipIterator"></a>
Using the Boost Zip Iterator</h2>
<p>Information and points are in separate containers. We use <a href="http://www.boost.org/libs/iterator/doc/index.html#specialized-adaptors"><code>boost::zip_iterator</code></a> to provide an iterator gathering them.</p>
<p><br />
<b>File</b> <a class="el" href="Triangulation_2_2info_insert_with_zip_iterator_2_8cpp-example.html">Triangulation_2/info_insert_with_zip_iterator_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iterator/zip_iterator.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>         K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__with__info__2.html">CGAL::Triangulation_vertex_base_with_info_2&lt;unsigned, K&gt;</a>    Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vb&gt;</a>                    Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</a>                      Delaunay;</div><div class="line"><span class="keyword">typedef</span> Delaunay::Point                                             Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"></div><div class="line">  std::vector&lt;unsigned&gt; indices;</div><div class="line">  indices.push_back(0);</div><div class="line">  indices.push_back(1);</div><div class="line">  indices.push_back(2);</div><div class="line">  indices.push_back(3);</div><div class="line">  indices.push_back(4);</div><div class="line">  indices.push_back(5);  </div><div class="line">  </div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  points.push_back(Point(0,0));</div><div class="line">  points.push_back(Point(1,0));</div><div class="line">  points.push_back(Point(0,1));</div><div class="line">  points.push_back(Point(1,47));</div><div class="line">  points.push_back(Point(2,2));</div><div class="line">  points.push_back(Point(-1,0));</div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">  Delaunay T;</div><div class="line">  T.insert( boost::make_zip_iterator(boost::make_tuple( points.begin(),indices.begin() )),</div><div class="line">            boost::make_zip_iterator(boost::make_tuple( points.end(),indices.end() ) )  );</div><div class="line"></div><div class="line">  CGAL_assertion( T.number_of_vertices() == 6 );</div><div class="line">  </div><div class="line">  </div><div class="line">  <span class="comment">// check that the info was correctly set.</span></div><div class="line">  Delaunay::Finite_vertices_iterator vit;</div><div class="line">  <span class="keywordflow">for</span> (vit = T.finite_vertices_begin(); vit != T.finite_vertices_end(); ++vit)</div><div class="line">    <span class="keywordflow">if</span>( points[ vit-&gt;info() ] != vit-&gt;point() ){</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Error different info"</span> &lt;&lt; std::endl;</div><div class="line">      exit(EXIT_FAILURE);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Triangulation_2UsingtheBoostTransformIterator"></a>
Using the Boost Transform Iterator</h2>
<p>We define a functor <code>Auto_count</code> used together with <a href="http://www.boost.org/libs/iterator/doc/index.html#specialized-adaptors"><code>boost::transform_iterator</code></a> to set the order of each point in the range. Note that this is correct because the iterator is dereferenced only once per point during the insertion. <br />
<b>File</b> <a class="el" href="Triangulation_2_2info_insert_with_transform_iterator_2_8cpp-example.html">Triangulation_2/info_insert_with_transform_iterator_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/iterator/transform_iterator.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>         K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__with__info__2.html">CGAL::Triangulation_vertex_base_with_info_2&lt;unsigned, K&gt;</a>    Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vb&gt;</a>                    Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</a>                      Delaunay;</div><div class="line"><span class="keyword">typedef</span> Delaunay::Point                                             Point;</div><div class="line"></div><div class="line"><span class="comment">//a functor that returns a std::pair&lt;Point,unsigned&gt;.</span></div><div class="line"><span class="comment">//the unsigned integer is incremented at each call to </span></div><div class="line"><span class="comment">//operator()</span></div><div class="line"><span class="keyword">struct </span>Auto_count : <span class="keyword">public</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1cpp98_1_1unary__function.html">CGAL::cpp98::unary_function</a>&lt;const Point&amp;,std::pair&lt;Point,unsigned&gt; &gt;{</div><div class="line">  <span class="keyword">mutable</span> <span class="keywordtype">unsigned</span> i;</div><div class="line">  Auto_count() : i(0){}</div><div class="line">  std::pair&lt;Point,unsigned&gt; operator()(<span class="keyword">const</span> Point&amp; p)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> std::make_pair(p,i++);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  points.push_back(Point(0,0));</div><div class="line">  points.push_back(Point(1,0));</div><div class="line">  points.push_back(Point(0,1));</div><div class="line">  points.push_back(Point(4,10));</div><div class="line">  points.push_back(Point(2,2));</div><div class="line">  points.push_back(Point(-1,0));</div><div class="line"></div><div class="line">  </div><div class="line">  Delaunay T;</div><div class="line">  T.insert( boost::make_transform_iterator(points.begin(),Auto_count()),</div><div class="line">            boost::make_transform_iterator(points.end(),  Auto_count() )  );</div><div class="line"></div><div class="line">  CGAL_assertion( T.number_of_vertices() == 6 );</div><div class="line">  </div><div class="line">  <span class="comment">// check that the info was correctly set.</span></div><div class="line">  Delaunay::Finite_vertices_iterator vit;</div><div class="line">  <span class="keywordflow">for</span> (vit = T.finite_vertices_begin(); vit != T.finite_vertices_end(); ++vit)</div><div class="line">    <span class="keywordflow">if</span>( points[ vit-&gt;info() ] != vit-&gt;point() ){</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Error different info"</span> &lt;&lt; std::endl;</div><div class="line">      exit(EXIT_FAILURE);</div><div class="line">    }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"OK"</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Triangulation_2Design"></a>
Design and Implementation History</h1>
<p>The code of this package is the result of a long development process. Here follows a tentative list of people who added their stone to this package: Jean-Daniel Boissonnat, Hervé Brönnimann, Olivier Devillers, Andreas Fabri, Frédéric Fichel, Julia Flötotto, Monique Teillaud and Mariette Yvinec. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:51 for CGAL 4.13 - 2D Triangulation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
