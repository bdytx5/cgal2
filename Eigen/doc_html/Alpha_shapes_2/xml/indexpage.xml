<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Alpha_Shapes"/><anchor id="index_1I1ChapterAlphashapes2D"/> <simplesect kind="author"><para>Tran Kai Frank Da</para></simplesect>
<image type="html" name="alphashape.png"></image>
 <image type="latex" name="alphashape.png"></image>
</para><para>Assume we are given a set <formula id="0">$ S$</formula> of points in 2D or 3D and we would like to have something like &quot;the shape formed by these points&quot;. This is quite a vague notion and there are probably many possible interpretations, the <formula id="1">$ \alpha$</formula>-shape being one of them. Alpha shapes can be used for shape reconstruction from a dense unorganized set of data points. Indeed, an <formula id="1">$ \alpha$</formula>-shape is demarcated by a frontier, which is a linear approximation of the original shape <ref refid="citelist_1CITEREF_bb-srmua-97t" kindref="member">[1]</ref>.</para><para>As mentioned in Edelsbrunner&apos;s and M<uumlaut/>cke&apos;s paper <ref refid="citelist_1CITEREF_em-tdas-94" kindref="member">[2]</ref>, one can intuitively think of an <formula id="1">$ \alpha$</formula>-shape as the following. Imagine a huge mass of ice-cream making up the space <formula id="2">$ \mathbb{R}^3$</formula> and containing the points as &quot;hard&quot; chocolate pieces. Using one of these sphere-formed ice-cream spoons, we carve out all parts of the ice-cream block we can reach without bumping into chocolate pieces, thereby even carving out holes in the inside (e.g. parts not reachable by simply moving the spoon from the outside). We will eventually end up with a (not necessarily convex) object bounded by caps, arcs and points. If we now straighten all &quot;round&quot; faces to triangles and line segments, we have an intuitive description of what is called the <formula id="1">$ \alpha$</formula>-shape of <formula id="0">$ S$</formula>. The drawing above provides an example of this process in 2D (where our ice-cream spoon is simply a circle).</para><para>Alpha shapes depend on a parameter <formula id="1">$ \alpha$</formula> after which they are named. In the ice-cream analogy above, <formula id="1">$ \alpha$</formula> is the squared radius of the carving spoon. A very small value will allow us to eat up all of the ice-cream except the chocolate points themselves. Thus we already see that the <formula id="1">$ \alpha$</formula>-shape degenerates to the point-set <formula id="0">$ S$</formula> for <formula id="3">$ \alpha \rightarrow 0$</formula>. On the other hand, a huge value of <formula id="1">$ \alpha$</formula> will prevent us even from moving the spoon between two points since it is too large. So we will never spoon up the ice-cream lying in the inside of the convex hull of <formula id="0">$ S$</formula>. Hence, the alpha shape becomes the convex hull of <formula id="0">$ S$</formula> as <formula id="4">$ \alpha \rightarrow \infty$</formula>.</para><para>CGAL offers 2D and 3D alpha shapes. The GUDHI library offers a <ulink url="http://gudhi.gforge.inria.fr/doc/latest/group__alpha__complex.html">dD Alpha complex</ulink>.</para><sect1 id="index_1Alpha_shapes_2Definitions">
<title>Definitions</title>
<para>We distinguish two versions of alpha shapes. <emphasis>Basic alpha shapes</emphasis> are based on the Delaunay triangulation. <emphasis>Weighted alpha shapes</emphasis> are based on its generalization, the regular triangulation (cf. Section <ref refid="index_1Section_2D_Triangulations_Regular" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Regular Triangulations</ref>), replacing the euclidean distance by the power to weighted points.</para><para>There is a close connection between alpha shapes and the underlying triangulations. More precisely, the <formula id="1">$ \alpha$</formula>-complex of <formula id="0">$ S$</formula> is a subcomplex of this triangulation of <formula id="0">$ S$</formula>, containing the <formula id="1">$ \alpha$</formula>-exposed <formula id="5">$ k$</formula>-simplices, <formula id="6">$ 0 \leq k \leq d$</formula>. A simplex is said to be <formula id="1">$ \alpha$</formula>-exposed, if there is an open disk (resp. ball) of radius <formula id="7">$ \sqrt{\alpha}$</formula> through the vertices of the simplex that does not contain any other point of <formula id="0">$ S$</formula>, for the metric used in the computation of the underlying triangulation. The corresponding <formula id="1">$ \alpha$</formula>-shape is defined as the underlying interior space of the <formula id="1">$ \alpha$</formula>-complex (see <ref refid="citelist_1CITEREF_em-tdas-94" kindref="member">[2]</ref>).</para><para>In general, an <formula id="1">$ \alpha$</formula>-complex is a non-connected and non-pure polytope, meaning that one <formula id="5">$ k$</formula>-simplex, with <formula id="8">$ 0 \leq k \leq d-1$</formula>, is not necessarily adjacent to a <formula id="9">$ (k+1)$</formula>-simplex.</para><para>The <formula id="1">$ \alpha$</formula>-shapes of <formula id="0">$ S$</formula> form a discrete family, even though they are defined for all real numbers <formula id="1">$ \alpha$</formula> with <formula id="10">$ 0 \leq \alpha \leq \infty$</formula>. Thus, we can represent the entire family of <formula id="1">$ \alpha$</formula>-shapes of <formula id="0">$ S$</formula> by the underlying triangulation of <formula id="0">$ S$</formula>. In this representation each <formula id="5">$ k$</formula>-simplex of the underlying triangulation is associated with an interval that specifies for which values of <formula id="1">$ \alpha$</formula> the <formula id="5">$ k$</formula>-simplex belongs to the <formula id="1">$ \alpha$</formula>-shape. Relying on this fact, the family of <formula id="1">$ \alpha$</formula>-shapes can be computed efficiently and relatively easily. Furthermore, we can select an appropriate <formula id="1">$ \alpha$</formula>-shape from a finite number of different <formula id="1">$ \alpha$</formula>-shapes and corresponding <formula id="1">$ \alpha$</formula>-values.</para></sect1>
<sect1 id="index_1I1_SectAlpha_Shape_2">
<title>Functionality</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Alpha__shape__2" kindref="compound">Alpha_shape_2</ref>&lt;Dt&gt;</computeroutput> represents the family of <formula id="1">$ \alpha$</formula>-shapes of points in a plane for <emphasis>all</emphasis> positive <formula id="1">$ \alpha$</formula>. It maintains the underlying triangulation <computeroutput>Dt</computeroutput> which represents connectivity and order among squared radius of its faces. Each <formula id="5">$ k$</formula>-dimensional face of the <computeroutput>Dt</computeroutput> is associated with an interval that specifies for which values of <formula id="1">$ \alpha$</formula> the face belongs to the <formula id="1">$ \alpha$</formula>-shape. There are links between the intervals and the <formula id="5">$ k$</formula>-dimensional faces of the triangulation.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Alpha__shape__2" kindref="compound">Alpha_shape_2</ref>&lt;Dt&gt;</computeroutput> provides functions to set and get the current <formula id="1">$ \alpha$</formula>-value, as well as an iterator that enumerates the <formula id="1">$ \alpha$</formula>-values where the <formula id="1">$ \alpha$</formula>-shape changes.</para><para>It provides iterators to enumerate the vertices and edges that are in the <formula id="1">$ \alpha$</formula>-shape, and functions that allow to classify vertices, edges and faces with respect to the <formula id="1">$ \alpha$</formula>-shape. They can be in the interior of a face that belongs or does not belong to the <formula id="1">$ \alpha$</formula>-shape. They can be singular/regular, that is be on the boundary of the <formula id="1">$ \alpha$</formula>-shape, but not incident/incident to a triangle of the <formula id="1">$ \alpha$</formula>-complex.</para><para>Finally, it provides a function to determine the <formula id="1">$ \alpha$</formula>-value such that the <formula id="1">$ \alpha$</formula>-shape satisfies the following two properties, or at least the second one if there is no such <formula id="1">$ \alpha$</formula> that both are satisfied: <linebreak/>
 <orderedlist>
<listitem>
<para>the number of components equals a number of your choice, and </para></listitem>
<listitem>
<para>all data points are either on the boundary or in the interior of the regularized version of the <formula id="1">$ \alpha$</formula>-shape (no singular edges). </para></listitem>
</orderedlist>
</para><para>The current implementation is static, that is after its construction points cannot be inserted or removed.</para></sect1>
<sect1 id="index_1I1_SectDtClass2D">
<title>Concepts and Models</title>
<para>We currently do not specify concepts for the underlying triangulation type. Models that work for a basic alpha shape are the classes <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Delaunay_triangulation_2</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_2_triangulation_2.tag">Periodic_2_Delaunay_triangulation_2</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Triangulation__hierarchy__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Triangulation_hierarchy_2</ref></computeroutput> templated with a Delaunay triangulation. A model that works for a weighted alpha shape is the class <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Regular_triangulation_2</ref></computeroutput>.</para><sect2 id="index_1AlphaShape2D_ConceptAndModelsAlphaShapes">
<title>Alpha Shapes</title>
<para>The triangulation needs a geometric traits class as argument. The requirements of this class are described in the concepts <computeroutput><ref refid="classAlphaShapeTraits__2" kindref="compound">AlphaShapeTraits_2</ref></computeroutput> in the non-weighted case and <computeroutput><ref refid="classWeightedAlphaShapeTraits__2" kindref="compound">WeightedAlphaShapeTraits_2</ref></computeroutput> in the weighted case. All CGAL kernels are models of both concepts.</para><para>The triangulation data structure of the triangulation has to be a model of the concept <computeroutput>TriangulationDataStructure_2</computeroutput>, and it must be parameterized with vertex and face classes which are models of the concepts <computeroutput><ref refid="classAlphaShapeVertex__2" kindref="compound">AlphaShapeVertex_2</ref></computeroutput> and <computeroutput><ref refid="classAlphaShapeFace__2" kindref="compound">AlphaShapeFace_2</ref></computeroutput>. The classes <computeroutput><ref refid="classCGAL_1_1Alpha__shape__vertex__base__2" kindref="compound">Alpha_shape_vertex_base_2</ref>&lt;Gt, Vb&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Alpha__shape__face__base__2" kindref="compound">Alpha_shape_face_base_2</ref>&lt;Gt, Fb&gt;</computeroutput> are models of these concepts and can be used for all type of alpha shapes, provided that the template parameters <computeroutput>Vb</computeroutput> and <computeroutput>Fb</computeroutput> are appropriately chosen, as we shall see in the following section.</para></sect2>
<sect2 id="index_1AlphaShape2D_ConceptAndModelsTDS">
<title>Triangulation data structure</title>
<para>Additional requirements are put when using weighted or periodic triangulations as underlying triangulation: <itemizedlist>
<listitem>
<para>When using a weighted triangulation (<computeroutput><ref refid="classCGAL_1_1Regular__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Regular_triangulation_2</ref></computeroutput>), the vertex and face classes must respectively be models to both <computeroutput><ref refid="classAlphaShapeVertex__2" kindref="compound">AlphaShapeVertex_2</ref></computeroutput> and <computeroutput><ref refid="classRegularTriangulationVertexBase__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">RegularTriangulationVertexBase_2</ref></computeroutput>, and to both <computeroutput><ref refid="classAlphaShapeFace__2" kindref="compound">AlphaShapeFace_2</ref></computeroutput> and <computeroutput><ref refid="classRegularTriangulationFaceBase__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">RegularTriangulationFaceBase_2</ref></computeroutput> (see example: <ref refid="index_1I1_SectWeightedAS2D" kindref="member">Example for Weighted Alpha Shapes</ref>). </para></listitem>
<listitem>
<para>When using a periodic triangulation (<computeroutput><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_2_triangulation_2.tag">Periodic_2_Delaunay_triangulation_2</ref></computeroutput>), the vertex and face classes must respectively be models to both <computeroutput><ref refid="classAlphaShapeVertex__2" kindref="compound">AlphaShapeVertex_2</ref></computeroutput> and <computeroutput><ref refid="classPeriodic__2TriangulationVertexBase__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_2_triangulation_2.tag">Periodic_2TriangulationVertexBase_2</ref></computeroutput>, and to both <computeroutput><ref refid="classAlphaShapeFace__2" kindref="compound">AlphaShapeFace_2</ref></computeroutput> and <computeroutput><ref refid="classPeriodic__2TriangulationFaceBase__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_2_triangulation_2.tag">Periodic_2TriangulationFaceBase_2</ref></computeroutput> (see example: <ref refid="index_1AlphaShape_2DExampleForPeriodicAlphaShapes" kindref="member">Example for Periodic Alpha Shapes</ref>). </para></listitem>
</itemizedlist>
</para></sect2>
</sect1>
<sect1 id="index_1Alpha_shapes_2Examples">
<title>Examples</title>
<sect2 id="index_1I1_SectClassicAS2D">
<title>Example for Basic Alpha Shapes</title>
<para>The basic alpha shape requires a Delaunay triangulation as underlying triangulation <computeroutput>Dt</computeroutput>. The Delaunay triangulation class is parameterized with a geometric and a triangulation data structure traits.</para><para>For the geometric traits class we can use a CGAL kernel.</para><para>For the triangulation data structure traits, we have to choose the vertex and face classes needed for alpha shapes, namely <computeroutput><ref refid="classCGAL_1_1Alpha__shape__vertex__base__2" kindref="compound">Alpha_shape_vertex_base_2</ref>&lt;Gt, Vb&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Alpha__shape__face__base__2" kindref="compound">Alpha_shape_face_base_2</ref>&lt;Gt,Fb&gt;</computeroutput>. The parameter <computeroutput>Vb</computeroutput> and <computeroutput>Fb</computeroutput> must be filled by classes that are models of the <computeroutput><ref refid="classTriangulationVertexBase__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">TriangulationVertexBase_2</ref></computeroutput> and <computeroutput><ref refid="classTriangulationFaceBase__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">TriangulationFaceBase_2</ref></computeroutput> concepts. The classes <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Triangulation_vertex_base_2</ref>&lt;Gt&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Triangulation__face__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Triangulation_face_base_2</ref>&lt;Gt&gt;</computeroutput> fit these requirements.</para><para>The example below illustrates how to construct a basic alpha shape. Note that <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Triangulation_vertex_base_2</ref>&lt;Gt&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Triangulation__face__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Triangulation_face_base_2</ref>&lt;Gt&gt;</computeroutput> are the default parameters for <computeroutput>Vb</computeroutput> and <computeroutput>Fb</computeroutput> in the classes <computeroutput><ref refid="classCGAL_1_1Alpha__shape__vertex__base__2" kindref="compound">Alpha_shape_vertex_base_2</ref>&lt;Gt, Vb&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Alpha__shape__face__base__2" kindref="compound">Alpha_shape_face_base_2</ref>&lt;Gt,Fb&gt;</computeroutput>. They are thus omitted in the code below. <linebreak/>
<bold>File</bold> <ref refid="Alpha_shapes_2_2ex_alpha_shapes_2_8cpp-example" kindref="compound">Alpha_shapes_2/ex_alpha_shapes_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_vertex_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_face_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/algorithm.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/assertions.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__vertex__base__2" kindref="compound">CGAL::Alpha_shape_vertex_base_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__face__base__2" kindref="compound">CGAL::Alpha_shape_face_base_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::Delaunay_triangulation_2&lt;K,Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__2" kindref="compound">CGAL::Alpha_shape_2&lt;Triangulation_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_shape_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__2_1a652f355cc521b0aa248a874a3fb408cc" kindref="member">Alpha_shape_2::Alpha_shape_edges_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_shape_edges_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>OutputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>alpha_edges(<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Alpha_shape_2&amp;<sp/>A,<sp/><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref><sp/>out)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_edges_iterator<sp/>it<sp/>=<sp/>A.alpha_shape_edges_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end<sp/>=<sp/>A.alpha_shape_edges_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/>;<sp/>it!=end;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out++<sp/>=<sp/>A.segment(*it);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>OutputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>file_input(<ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref><sp/>out)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>is(</highlight><highlight class="stringliteral">&quot;./data/fin&quot;</highlight><highlight class="normal">,<sp/>std::ios::in);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(is.fail())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;unable<sp/>to<sp/>open<sp/>file<sp/>for<sp/>input&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>is<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points<sp/>from<sp/>file&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__STLAlgos_1gadba21cc5c30a79519438dfe0f9264255" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::copy_n</ref>(std::istream_iterator&lt;Point&gt;(is),<sp/>n,<sp/>out);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>list<sp/>of<sp/>points<sp/>and<sp/>returns<sp/>a<sp/>list<sp/>of<sp/>segments</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>corresponding<sp/>to<sp/>the<sp/>Alpha<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!<sp/>file_input(std::back_inserter(points)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_2<sp/>A(points.begin(),<sp/>points.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT(10000),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Alpha__shape__2_1ae1c8fee3b311d5417dd9c58c8a2b97f5a98f773aea96e5662d660bbf59e2d2bcc" kindref="member">Alpha_shape_2::GENERAL</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Segment&gt;<sp/>segments;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>alpha_edges(A,<sp/>std::back_inserter(segments));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Alpha<sp/>Shape<sp/>computed&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>segments.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>alpha<sp/>shape<sp/>edges&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Optimal<sp/>alpha:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*A.find_optimal_alpha(1)&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1I1_SectWeightedAS2D">
<title>Example for Weighted Alpha Shapes</title>
<para>A weighted alpha shape requires a regular triangulation as underlying triangulation <computeroutput>Dt</computeroutput>. Here again, we can use the vertex and face <computeroutput><ref refid="classCGAL_1_1Alpha__shape__vertex__base__2" kindref="compound">Alpha_shape_vertex_base_2</ref>&lt;Gt, Vb&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Alpha__shape__face__base__2" kindref="compound">Alpha_shape_face_base_2</ref>&lt;Gt,Fb&gt;</computeroutput>, but for weighted alpha shapes, <computeroutput>Vb</computeroutput> and <computeroutput>Fb</computeroutput> must be models of the concepts <computeroutput><ref refid="classRegularTriangulationVertexBase__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">RegularTriangulationVertexBase_2</ref></computeroutput> and <computeroutput><ref refid="classRegularTriangulationFaceBase__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">RegularTriangulationFaceBase_2</ref></computeroutput>. The classes <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__vertex__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Regular_triangulation_vertex_base_2</ref>&lt;Gt&gt;</computeroutput> <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__face__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Regular_triangulation_face_base_2</ref>&lt;Gt&gt;</computeroutput> fit these requirements.</para><para>Note that there is no special weighted alpha shape class.</para><para>The example below illustrates how to construct a weighted alpha shape. <linebreak/>
<bold>File</bold> <ref refid="Alpha_shapes_2_2ex_weighted_alpha_shapes_2_8cpp-example" kindref="compound">Alpha_shapes_2/ex_weighted_alpha_shapes_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_face_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_vertex_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Regular_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Weighted_point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Weighted_point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__vertex__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::Regular_triangulation_vertex_base_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rvb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__vertex__base__2" kindref="compound">CGAL::Alpha_shape_vertex_base_2&lt;K,Rvb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__face__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::Regular_triangulation_face_base_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rf;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__face__base__2" kindref="compound">CGAL::Alpha_shape_face_base_2&lt;K,Rf&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::Regular_triangulation_2&lt;K,Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__2" kindref="compound">CGAL::Alpha_shape_2&lt;Triangulation_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_shape_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__2_1a652f355cc521b0aa248a874a3fb408cc" kindref="member">Alpha_shape_2::Alpha_shape_edges_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_shape_edges_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>OutputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>alpha_edges(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Alpha_shape_2&amp;<sp/>A,<sp/><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref><sp/>out)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_edges_iterator<sp/>it<sp/>=<sp/>A.alpha_shape_edges_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end<sp/>=<sp/>A.alpha_shape_edges_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/>;<sp/>it!=end;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out++<sp/>=<sp/>A.segment(*it);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>file_input(std::list&lt;Weighted_point&gt;&amp;<sp/>L)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>is(</highlight><highlight class="stringliteral">&quot;./data/fin_weighted&quot;</highlight><highlight class="normal">,<sp/>std::ios::in);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(is.fail())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;unable<sp/>to<sp/>open<sp/>file<sp/>for<sp/>input&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>is<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/>;<sp/>n&gt;0;<sp/>n--)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Weighted_point<sp/>wp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>is<sp/>&gt;&gt;<sp/>wp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>L.push_back(wp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Reads<sp/>a<sp/>list<sp/>of<sp/>points<sp/>and<sp/>returns<sp/>a<sp/>list<sp/>of<sp/>segments<sp/>corresponding<sp/>to</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>weighted<sp/>Alpha<sp/>Shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Weighted_point&gt;<sp/>wpoints;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!file_input(wpoints))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_2<sp/>A(wpoints.begin(),<sp/>wpoints.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT(10000),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Alpha__shape__2_1ae1c8fee3b311d5417dd9c58c8a2b97f5a98f773aea96e5662d660bbf59e2d2bcc" kindref="member">Alpha_shape_2::GENERAL</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Segment&gt;<sp/>segments;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>alpha_edges(A,<sp/>std::back_inserter(segments));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Alpha<sp/>Shape<sp/>computed&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>segments.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>alpha<sp/>shape<sp/>edges&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Optimal<sp/>alpha:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*A.find_optimal_alpha(1)&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1AlphaShape_2DExampleForPeriodicAlphaShapes">
<title>Example for Periodic Alpha Shapes</title>
<para>The following example shows how to use a periodic Delaunay triangulation as underlying triangulation for the alpha shape computation.</para><para>In order to define the original domain and to benefit from the built-in heuristic optimizations of the periodic triangulation computation, it is recommended to first construct the triangulation and then construct the alpha shape from it. The alpha shape constructor that takes a point range can be used as well but in this case the original domain cannot be specified and the default unit cube will be chosen and no optimizations will be used.</para><para>It is also recommended to switch the triangulation to 1-sheeted covering if possible. Note that a periodic triangulation in 9-sheeted covering space is degenerate. In this case, an exact constructions kernel needs to be used to compute the alpha shapes. Otherwise the results will suffer from round-off problems.</para><para><linebreak/>
<bold>File</bold> <ref refid="Alpha_shapes_2_2ex_periodic_alpha_shapes_2_8cpp-example" kindref="compound">Alpha_shapes_2/ex_periodic_alpha_shapes_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_2_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_face_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_vertex_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Traits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_2_triangulation_2.tag">CGAL::Periodic_2_Delaunay_triangulation_traits_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Vertex<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__triangulation__vertex__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_2_triangulation_2.tag">CGAL::Periodic_2_triangulation_vertex_base_2&lt;Gt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__vertex__base__2" kindref="compound">CGAL::Alpha_shape_vertex_base_2&lt;Gt, Vb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AsVb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Cell<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__triangulation__face__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_2_triangulation_2.tag">CGAL::Periodic_2_triangulation_face_base_2&lt;Gt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__face__base__2" kindref="compound">CGAL::Alpha_shape_face_base_2&lt;Gt, Cb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AsCb;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_2&lt;AsVb,<sp/>AsCb&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__2__Delaunay__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_2_triangulation_2.tag">CGAL::Periodic_2_Delaunay_triangulation_2&lt;Gt, Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>P2DT2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__2" kindref="compound">CGAL::Alpha_shape_2&lt;P2DT2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_shape_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Gt::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Gt::Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__2_1a652f355cc521b0aa248a874a3fb408cc" kindref="member">Alpha_shape_2::Alpha_shape_edges_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_shape_edges_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>OutputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>alpha_edges(<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Alpha_shape_2&amp;<sp/>A,<sp/><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref><sp/>out)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_edges_iterator<sp/>it<sp/>=<sp/>A.alpha_shape_edges_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end<sp/>=<sp/>A.alpha_shape_edges_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/>;<sp/>it!=end;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out++<sp/>=<sp/>A.segment(*it);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>OutputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>file_input(<ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref><sp/>out)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>is(</highlight><highlight class="stringliteral">&quot;./data/fin&quot;</highlight><highlight class="normal">,<sp/>std::ios::in);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(is.fail())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;unable<sp/>to<sp/>open<sp/>file<sp/>for<sp/>input&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>is<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points<sp/>from<sp/>file&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__STLAlgos_1gadba21cc5c30a79519438dfe0f9264255" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::copy_n</ref>(std::istream_iterator&lt;Point&gt;(is),<sp/>n,<sp/>out);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!<sp/>file_input(std::back_inserter(points)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>the<sp/>periodic<sp/>square</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P2DT2<sp/>pdt(Gt::Iso_rectangle_2(-10,-10,<sp/>700,700));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Heuristic<sp/>for<sp/>inserting<sp/>large<sp/>point<sp/>sets<sp/>(if<sp/>pts<sp/>is<sp/>reasonably<sp/>large)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pdt.insert(points.begin(),<sp/>points.end(),<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>As<sp/>pdt<sp/>won&apos;t<sp/>be<sp/>modified<sp/>anymore<sp/>switch<sp/>to<sp/>1-sheeted<sp/>cover<sp/>if<sp/>possible</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pdt.is_triangulation_in_1_sheet())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pdt.convert_to_1_sheeted_covering();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Periodic<sp/>Delaunay<sp/>computed.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>alpha<sp/>shape</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_2<sp/>as(pdt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Alpha<sp/>shape<sp/>computed<sp/>in<sp/>REGULARIZED<sp/>mode<sp/>by<sp/>default.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>find<sp/>optimal<sp/>alpha<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_2::NT<sp/>alpha_solid<sp/>=<sp/>as.find_alpha_solid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Alpha__shape__2_1a06ac11586ec6d90d59e0e76e465d074c" kindref="member">Alpha_shape_2::Alpha_iterator</ref><sp/>opt<sp/>=<sp/>as.find_optimal_alpha(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Smallest<sp/>alpha<sp/>value<sp/>to<sp/>get<sp/>a<sp/>solid<sp/>through<sp/>data<sp/>points<sp/>is<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>alpha_solid<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Optimal<sp/>alpha<sp/>value<sp/>to<sp/>get<sp/>one<sp/>connected<sp/>component<sp/>is<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><sp/>*opt<sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.set_alpha(*opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(as.number_of_solid_components()<sp/>==<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.set_alpha(10000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Segment&gt;<sp/>segments;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>alpha_edges(as,<sp/>std::back_inserter(segments));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>segments.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>alpha<sp/>shape<sp/>edges&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
