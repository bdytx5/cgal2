<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Alpha_shapes_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Alpha Shapes: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Alpha Shapes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Alpha_Shapes"></a><a class="anchor" id="I1ChapterAlphashapes2D"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Tran Kai Frank Da</dd></dl>
<div class="image">
<img src="alphashape.png" alt="alphashape.png" />
</div>
 <p>Assume we are given a set \( S\) of points in 2D or 3D and we would like to have something like "the shape formed by these points". This is quite a vague notion and there are probably many possible interpretations, the \( \alpha\)-shape being one of them. Alpha shapes can be used for shape reconstruction from a dense unorganized set of data points. Indeed, an \( \alpha\)-shape is demarcated by a frontier, which is a linear approximation of the original shape <a class="el" href="citelist.html#CITEREF_bb-srmua-97t">[1]</a>.</p>
<p>As mentioned in Edelsbrunner's and MÃ¼cke's paper <a class="el" href="citelist.html#CITEREF_em-tdas-94">[2]</a>, one can intuitively think of an \( \alpha\)-shape as the following. Imagine a huge mass of ice-cream making up the space \( \mathbb{R}^3\) and containing the points as "hard" chocolate pieces. Using one of these sphere-formed ice-cream spoons, we carve out all parts of the ice-cream block we can reach without bumping into chocolate pieces, thereby even carving out holes in the inside (e.g. parts not reachable by simply moving the spoon from the outside). We will eventually end up with a (not necessarily convex) object bounded by caps, arcs and points. If we now straighten all "round" faces to triangles and line segments, we have an intuitive description of what is called the \( \alpha\)-shape of \( S\). The drawing above provides an example of this process in 2D (where our ice-cream spoon is simply a circle).</p>
<p>Alpha shapes depend on a parameter \( \alpha\) after which they are named. In the ice-cream analogy above, \( \alpha\) is the squared radius of the carving spoon. A very small value will allow us to eat up all of the ice-cream except the chocolate points themselves. Thus we already see that the \( \alpha\)-shape degenerates to the point-set \( S\) for \( \alpha \rightarrow 0\). On the other hand, a huge value of \( \alpha\) will prevent us even from moving the spoon between two points since it is too large. So we will never spoon up the ice-cream lying in the inside of the convex hull of \( S\). Hence, the alpha shape becomes the convex hull of \( S\) as \( \alpha \rightarrow \infty\).</p>
<p><span style="font-variant: small-caps;">CGAL</span> offers 2D and 3D alpha shapes. The GUDHI library offers a <a href="http://gudhi.gforge.inria.fr/doc/latest/group__alpha__complex.html">dD Alpha complex</a>.</p>
<h1><a class="anchor" id="Alpha_shapes_2Definitions"></a>
Definitions</h1>
<p>We distinguish two versions of alpha shapes. <em>Basic alpha shapes</em> are based on the Delaunay triangulation. <em>Weighted alpha shapes</em> are based on its generalization, the regular triangulation (cf. Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/index.html#Section_2D_Triangulations_Regular">Regular Triangulations</a>), replacing the euclidean distance by the power to weighted points.</p>
<p>There is a close connection between alpha shapes and the underlying triangulations. More precisely, the \( \alpha\)-complex of \( S\) is a subcomplex of this triangulation of \( S\), containing the \( \alpha\)-exposed \( k\)-simplices, \( 0 \leq k \leq d\). A simplex is said to be \( \alpha\)-exposed, if there is an open disk (resp. ball) of radius \( \sqrt{\alpha}\) through the vertices of the simplex that does not contain any other point of \( S\), for the metric used in the computation of the underlying triangulation. The corresponding \( \alpha\)-shape is defined as the underlying interior space of the \( \alpha\)-complex (see <a class="el" href="citelist.html#CITEREF_em-tdas-94">[2]</a>).</p>
<p>In general, an \( \alpha\)-complex is a non-connected and non-pure polytope, meaning that one \( k\)-simplex, with \( 0 \leq k \leq d-1\), is not necessarily adjacent to a \( (k+1)\)-simplex.</p>
<p>The \( \alpha\)-shapes of \( S\) form a discrete family, even though they are defined for all real numbers \( \alpha\) with \( 0 \leq \alpha \leq \infty\). Thus, we can represent the entire family of \( \alpha\)-shapes of \( S\) by the underlying triangulation of \( S\). In this representation each \( k\)-simplex of the underlying triangulation is associated with an interval that specifies for which values of \( \alpha\) the \( k\)-simplex belongs to the \( \alpha\)-shape. Relying on this fact, the family of \( \alpha\)-shapes can be computed efficiently and relatively easily. Furthermore, we can select an appropriate \( \alpha\)-shape from a finite number of different \( \alpha\)-shapes and corresponding \( \alpha\)-values.</p>
<h1><a class="anchor" id="I1_SectAlpha_Shape_2"></a>
Functionality</h1>
<p>The class <code><a class="el" href="classCGAL_1_1Alpha__shape__2.html" title="The class Alpha_shape_2 represents the family of -shapes of points in a plane for all positive ...">Alpha_shape_2</a>&lt;Dt&gt;</code> represents the family of \( \alpha\)-shapes of points in a plane for <em>all</em> positive \( \alpha\). It maintains the underlying triangulation <code>Dt</code> which represents connectivity and order among squared radius of its faces. Each \( k\)-dimensional face of the <code>Dt</code> is associated with an interval that specifies for which values of \( \alpha\) the face belongs to the \( \alpha\)-shape. There are links between the intervals and the \( k\)-dimensional faces of the triangulation.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Alpha__shape__2.html" title="The class Alpha_shape_2 represents the family of -shapes of points in a plane for all positive ...">Alpha_shape_2</a>&lt;Dt&gt;</code> provides functions to set and get the current \( \alpha\)-value, as well as an iterator that enumerates the \( \alpha\)-values where the \( \alpha\)-shape changes.</p>
<p>It provides iterators to enumerate the vertices and edges that are in the \( \alpha\)-shape, and functions that allow to classify vertices, edges and faces with respect to the \( \alpha\)-shape. They can be in the interior of a face that belongs or does not belong to the \( \alpha\)-shape. They can be singular/regular, that is be on the boundary of the \( \alpha\)-shape, but not incident/incident to a triangle of the \( \alpha\)-complex.</p>
<p>Finally, it provides a function to determine the \( \alpha\)-value such that the \( \alpha\)-shape satisfies the following two properties, or at least the second one if there is no such \( \alpha\) that both are satisfied: <br />
 </p><ol>
<li>
the number of components equals a number of your choice, and </li>
<li>
all data points are either on the boundary or in the interior of the regularized version of the \( \alpha\)-shape (no singular edges). </li>
</ol>
<p>The current implementation is static, that is after its construction points cannot be inserted or removed.</p>
<h1><a class="anchor" id="I1_SectDtClass2D"></a>
Concepts and Models</h1>
<p>We currently do not specify concepts for the underlying triangulation type. Models that work for a basic alpha shape are the classes <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">Delaunay_triangulation_2</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Periodic_2_triangulation_2.tag:../Periodic_2_triangulation_2/" href="../Periodic_2_triangulation_2/classCGAL_1_1Periodic__2__Delaunay__triangulation__2.html">Periodic_2_Delaunay_triangulation_2</a></code>, and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__hierarchy__2.html">Triangulation_hierarchy_2</a></code> templated with a Delaunay triangulation. A model that works for a weighted alpha shape is the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__2.html">Regular_triangulation_2</a></code>.</p>
<h2><a class="anchor" id="AlphaShape2D_ConceptAndModelsAlphaShapes"></a>
Alpha Shapes</h2>
<p>The triangulation needs a geometric traits class as argument. The requirements of this class are described in the concepts <code><a class="el" href="classAlphaShapeTraits__2.html" title="The concept AlphaShapeTraits_2 describes the requirements for the geometric traits class of the under...">AlphaShapeTraits_2</a></code> in the non-weighted case and <code><a class="el" href="classWeightedAlphaShapeTraits__2.html" title="The concept WeightedAlphaShapeTraits_2 describes the requirements for the geometric traits class of t...">WeightedAlphaShapeTraits_2</a></code> in the weighted case. All <span style="font-variant: small-caps;">CGAL</span> kernels are models of both concepts.</p>
<p>The triangulation data structure of the triangulation has to be a model of the concept <code>TriangulationDataStructure_2</code>, and it must be parameterized with vertex and face classes which are models of the concepts <code><a class="el" href="classAlphaShapeVertex__2.html" title="The concept AlphaShapeVertex_2 describes the requirements for the base vertex of an alpha shape...">AlphaShapeVertex_2</a></code> and <code><a class="el" href="classAlphaShapeFace__2.html" title="The concept AlphaShapeFace_2 describes the requirements for the base face of an alpha shape...">AlphaShapeFace_2</a></code>. The classes <code><a class="el" href="classCGAL_1_1Alpha__shape__vertex__base__2.html" title="The class Alpha_shape_vertex_base_2 is the default model for the concept AlphaShapeVertex_2. ">Alpha_shape_vertex_base_2</a>&lt;Gt, Vb&gt;</code> and <code><a class="el" href="classCGAL_1_1Alpha__shape__face__base__2.html" title="The class Alpha_shape_face_base_2 is the default model for the concept AlphaShapeFace_2. ">Alpha_shape_face_base_2</a>&lt;Gt, Fb&gt;</code> are models of these concepts and can be used for all type of alpha shapes, provided that the template parameters <code>Vb</code> and <code>Fb</code> are appropriately chosen, as we shall see in the following section.</p>
<h2><a class="anchor" id="AlphaShape2D_ConceptAndModelsTDS"></a>
Triangulation data structure</h2>
<p>Additional requirements are put when using weighted or periodic triangulations as underlying triangulation: </p><ul>
<li>
When using a weighted triangulation (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__2.html">Regular_triangulation_2</a></code>), the vertex and face classes must respectively be models to both <code><a class="el" href="classAlphaShapeVertex__2.html" title="The concept AlphaShapeVertex_2 describes the requirements for the base vertex of an alpha shape...">AlphaShapeVertex_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classRegularTriangulationVertexBase__2.html">RegularTriangulationVertexBase_2</a></code>, and to both <code><a class="el" href="classAlphaShapeFace__2.html" title="The concept AlphaShapeFace_2 describes the requirements for the base face of an alpha shape...">AlphaShapeFace_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classRegularTriangulationFaceBase__2.html">RegularTriangulationFaceBase_2</a></code> (see example: <a class="el" href="index.html#I1_SectWeightedAS2D">Example for Weighted Alpha Shapes</a>). </li>
<li>
When using a periodic triangulation (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Periodic_2_triangulation_2.tag:../Periodic_2_triangulation_2/" href="../Periodic_2_triangulation_2/classCGAL_1_1Periodic__2__Delaunay__triangulation__2.html">Periodic_2_Delaunay_triangulation_2</a></code>), the vertex and face classes must respectively be models to both <code><a class="el" href="classAlphaShapeVertex__2.html" title="The concept AlphaShapeVertex_2 describes the requirements for the base vertex of an alpha shape...">AlphaShapeVertex_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Periodic_2_triangulation_2.tag:../Periodic_2_triangulation_2/" href="../Periodic_2_triangulation_2/classPeriodic__2TriangulationVertexBase__2.html">Periodic_2TriangulationVertexBase_2</a></code>, and to both <code><a class="el" href="classAlphaShapeFace__2.html" title="The concept AlphaShapeFace_2 describes the requirements for the base face of an alpha shape...">AlphaShapeFace_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Periodic_2_triangulation_2.tag:../Periodic_2_triangulation_2/" href="../Periodic_2_triangulation_2/classPeriodic__2TriangulationFaceBase__2.html">Periodic_2TriangulationFaceBase_2</a></code> (see example: <a class="el" href="index.html#AlphaShape_2DExampleForPeriodicAlphaShapes">Example for Periodic Alpha Shapes</a>). </li>
</ul>
<h1><a class="anchor" id="Alpha_shapes_2Examples"></a>
Examples</h1>
<h2><a class="anchor" id="I1_SectClassicAS2D"></a>
Example for Basic Alpha Shapes</h2>
<p>The basic alpha shape requires a Delaunay triangulation as underlying triangulation <code>Dt</code>. The Delaunay triangulation class is parameterized with a geometric and a triangulation data structure traits.</p>
<p>For the geometric traits class we can use a <span style="font-variant: small-caps;">CGAL</span> kernel.</p>
<p>For the triangulation data structure traits, we have to choose the vertex and face classes needed for alpha shapes, namely <code><a class="el" href="classCGAL_1_1Alpha__shape__vertex__base__2.html" title="The class Alpha_shape_vertex_base_2 is the default model for the concept AlphaShapeVertex_2. ">Alpha_shape_vertex_base_2</a>&lt;Gt, Vb&gt;</code> and <code><a class="el" href="classCGAL_1_1Alpha__shape__face__base__2.html" title="The class Alpha_shape_face_base_2 is the default model for the concept AlphaShapeFace_2. ">Alpha_shape_face_base_2</a>&lt;Gt,Fb&gt;</code>. The parameter <code>Vb</code> and <code>Fb</code> must be filled by classes that are models of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classTriangulationVertexBase__2.html">TriangulationVertexBase_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classTriangulationFaceBase__2.html">TriangulationFaceBase_2</a></code> concepts. The classes <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__2.html">Triangulation_vertex_base_2</a>&lt;Gt&gt;</code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__2.html">Triangulation_face_base_2</a>&lt;Gt&gt;</code> fit these requirements.</p>
<p>The example below illustrates how to construct a basic alpha shape. Note that <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__2.html">Triangulation_vertex_base_2</a>&lt;Gt&gt;</code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__2.html">Triangulation_face_base_2</a>&lt;Gt&gt;</code> are the default parameters for <code>Vb</code> and <code>Fb</code> in the classes <code><a class="el" href="classCGAL_1_1Alpha__shape__vertex__base__2.html" title="The class Alpha_shape_vertex_base_2 is the default model for the concept AlphaShapeVertex_2. ">Alpha_shape_vertex_base_2</a>&lt;Gt, Vb&gt;</code> and <code><a class="el" href="classCGAL_1_1Alpha__shape__face__base__2.html" title="The class Alpha_shape_face_base_2 is the default model for the concept AlphaShapeFace_2. ">Alpha_shape_face_base_2</a>&lt;Gt,Fb&gt;</code>. They are thus omitted in the code below. <br />
<b>File</b> <a class="el" href="Alpha_shapes_2_2ex_alpha_shapes_2_8cpp-example.html">Alpha_shapes_2/ex_alpha_shapes_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Alpha_shape_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Alpha_shape_vertex_base_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Alpha_shape_face_base_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/algorithm.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/assertions.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> K::FT                                                FT;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                           Point;</div><div class="line"><span class="keyword">typedef</span> K::Segment_2                                         Segment;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__vertex__base__2.html">CGAL::Alpha_shape_vertex_base_2&lt;K&gt;</a>                   Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__face__base__2.html">CGAL::Alpha_shape_face_base_2&lt;K&gt;</a>                     Fb;</div><div class="line"><span class="keyword">typedef</span> CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;          Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K,Tds&gt;</a>                Triangulation_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__2.html">CGAL::Alpha_shape_2&lt;Triangulation_2&gt;</a>                 Alpha_shape_2;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__2.html#a652f355cc521b0aa248a874a3fb408cc">Alpha_shape_2::Alpha_shape_edges_iterator</a>            Alpha_shape_edges_iterator;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;</div><div class="line"><span class="keywordtype">void</span> alpha_edges( <span class="keyword">const</span> Alpha_shape_2&amp; A, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  Alpha_shape_edges_iterator it = A.alpha_shape_edges_begin(),</div><div class="line">                             end = A.alpha_shape_edges_end();</div><div class="line">  <span class="keywordflow">for</span>( ; it!=end; ++it)</div><div class="line">    *out++ = A.segment(*it);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;</div><div class="line"><span class="keywordtype">bool</span> file_input(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  std::ifstream is(<span class="stringliteral">"./data/fin"</span>, std::ios::in);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(is.fail())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"unable to open file for input"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> n;</div><div class="line">  is &gt;&gt; n;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Reading "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" points from file"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gadba21cc5c30a79519438dfe0f9264255">CGAL::cpp11::copy_n</a>(std::istream_iterator&lt;Point&gt;(is), n, out);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Reads a list of points and returns a list of segments</span></div><div class="line"><span class="comment">// corresponding to the Alpha shape.</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::list&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(! file_input(std::back_inserter(points)))</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line"></div><div class="line">  Alpha_shape_2 A(points.begin(), points.end(),</div><div class="line">                  FT(10000),</div><div class="line">                  <a class="code" href="classCGAL_1_1Alpha__shape__2.html#ae1c8fee3b311d5417dd9c58c8a2b97f5a98f773aea96e5662d660bbf59e2d2bcc">Alpha_shape_2::GENERAL</a>);</div><div class="line"></div><div class="line">  std::vector&lt;Segment&gt; segments;</div><div class="line">  alpha_edges(A, std::back_inserter(segments));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Alpha Shape computed"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; segments.size() &lt;&lt; <span class="stringliteral">" alpha shape edges"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Optimal alpha: "</span> &lt;&lt; *A.find_optimal_alpha(1)&lt;&lt;std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="I1_SectWeightedAS2D"></a>
Example for Weighted Alpha Shapes</h2>
<p>A weighted alpha shape requires a regular triangulation as underlying triangulation <code>Dt</code>. Here again, we can use the vertex and face <code><a class="el" href="classCGAL_1_1Alpha__shape__vertex__base__2.html" title="The class Alpha_shape_vertex_base_2 is the default model for the concept AlphaShapeVertex_2. ">Alpha_shape_vertex_base_2</a>&lt;Gt, Vb&gt;</code> and <code><a class="el" href="classCGAL_1_1Alpha__shape__face__base__2.html" title="The class Alpha_shape_face_base_2 is the default model for the concept AlphaShapeFace_2. ">Alpha_shape_face_base_2</a>&lt;Gt,Fb&gt;</code>, but for weighted alpha shapes, <code>Vb</code> and <code>Fb</code> must be models of the concepts <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classRegularTriangulationVertexBase__2.html">RegularTriangulationVertexBase_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classRegularTriangulationFaceBase__2.html">RegularTriangulationFaceBase_2</a></code>. The classes <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__vertex__base__2.html">Regular_triangulation_vertex_base_2</a>&lt;Gt&gt;</code> <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__face__base__2.html">Regular_triangulation_face_base_2</a>&lt;Gt&gt;</code> fit these requirements.</p>
<p>Note that there is no special weighted alpha shape class.</p>
<p>The example below illustrates how to construct a weighted alpha shape. <br />
<b>File</b> <a class="el" href="Alpha_shapes_2_2ex_weighted_alpha_shapes_2_8cpp-example.html">Alpha_shapes_2/ex_weighted_alpha_shapes_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Alpha_shape_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Alpha_shape_face_base_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Alpha_shape_vertex_base_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Regular_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> K::FT                                               FT;</div><div class="line"><span class="keyword">typedef</span> K::Weighted_point_2                                 Weighted_point;</div><div class="line"><span class="keyword">typedef</span> K::Segment_2                                        Segment;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__vertex__base__2.html">CGAL::Regular_triangulation_vertex_base_2&lt;K&gt;</a>        Rvb;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__vertex__base__2.html">CGAL::Alpha_shape_vertex_base_2&lt;K,Rvb&gt;</a>              Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__face__base__2.html">CGAL::Regular_triangulation_face_base_2&lt;K&gt;</a>          Rf;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__face__base__2.html">CGAL::Alpha_shape_face_base_2&lt;K,Rf&gt;</a>                 Fb;</div><div class="line"><span class="keyword">typedef</span> CGAL::Triangulation_data_structure_2&lt;Vb,Fb&gt;         Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__2.html">CGAL::Regular_triangulation_2&lt;K,Tds&gt;</a>                Triangulation_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__2.html">CGAL::Alpha_shape_2&lt;Triangulation_2&gt;</a>                Alpha_shape_2;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__2.html#a652f355cc521b0aa248a874a3fb408cc">Alpha_shape_2::Alpha_shape_edges_iterator</a>           Alpha_shape_edges_iterator;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;</div><div class="line"><span class="keywordtype">void</span> alpha_edges(<span class="keyword">const</span> Alpha_shape_2&amp; A, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  Alpha_shape_edges_iterator it = A.alpha_shape_edges_begin(),</div><div class="line">                             end = A.alpha_shape_edges_end();</div><div class="line">  <span class="keywordflow">for</span>( ; it!=end; ++it)</div><div class="line">    *out++ = A.segment(*it);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> file_input(std::list&lt;Weighted_point&gt;&amp; L)</div><div class="line">{</div><div class="line">  std::ifstream is(<span class="stringliteral">"./data/fin_weighted"</span>, std::ios::in);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(is.fail())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"unable to open file for input"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> n;</div><div class="line">  is &gt;&gt; n;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Reading "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" points"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>( ; n&gt;0; n--)</div><div class="line">  {</div><div class="line">    Weighted_point wp;</div><div class="line">    is &gt;&gt; wp;</div><div class="line">    L.push_back(wp);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Reads a list of points and returns a list of segments corresponding to</span></div><div class="line"><span class="comment">// the weighted Alpha Shape.</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::list&lt;Weighted_point&gt; wpoints;</div><div class="line">  <span class="keywordflow">if</span>(!file_input(wpoints))</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line"></div><div class="line">  Alpha_shape_2 A(wpoints.begin(), wpoints.end(),</div><div class="line">                  FT(10000),</div><div class="line">                  <a class="code" href="classCGAL_1_1Alpha__shape__2.html#ae1c8fee3b311d5417dd9c58c8a2b97f5a98f773aea96e5662d660bbf59e2d2bcc">Alpha_shape_2::GENERAL</a>);</div><div class="line"></div><div class="line">  std::vector&lt;Segment&gt; segments;</div><div class="line">  alpha_edges(A, std::back_inserter(segments));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Alpha Shape computed"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; segments.size() &lt;&lt; <span class="stringliteral">" alpha shape edges"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Optimal alpha: "</span> &lt;&lt; *A.find_optimal_alpha(1)&lt;&lt;std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="AlphaShape_2DExampleForPeriodicAlphaShapes"></a>
Example for Periodic Alpha Shapes</h2>
<p>The following example shows how to use a periodic Delaunay triangulation as underlying triangulation for the alpha shape computation.</p>
<p>In order to define the original domain and to benefit from the built-in heuristic optimizations of the periodic triangulation computation, it is recommended to first construct the triangulation and then construct the alpha shape from it. The alpha shape constructor that takes a point range can be used as well but in this case the original domain cannot be specified and the default unit cube will be chosen and no optimizations will be used.</p>
<p>It is also recommended to switch the triangulation to 1-sheeted covering if possible. Note that a periodic triangulation in 9-sheeted covering space is degenerate. In this case, an exact constructions kernel needs to be used to compute the alpha shapes. Otherwise the results will suffer from round-off problems.</p>
<p><br />
<b>File</b> <a class="el" href="Alpha_shapes_2_2ex_periodic_alpha_shapes_2_8cpp-example.html">Alpha_shapes_2/ex_periodic_alpha_shapes_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Periodic_2_Delaunay_triangulation_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Periodic_2_Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Alpha_shape_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Alpha_shape_face_base_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Alpha_shape_vertex_base_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Traits</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>     K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Periodic_2_triangulation_2.tag:../Periodic_2_triangulation_2/" href="../Periodic_2_triangulation_2/classCGAL_1_1Periodic__2__Delaunay__triangulation__traits__2.html">CGAL::Periodic_2_Delaunay_triangulation_traits_2&lt;K&gt;</a>     Gt;</div><div class="line"></div><div class="line"><span class="comment">// Vertex type</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Periodic_2_triangulation_2.tag:../Periodic_2_triangulation_2/" href="../Periodic_2_triangulation_2/classCGAL_1_1Periodic__2__triangulation__vertex__base__2.html">CGAL::Periodic_2_triangulation_vertex_base_2&lt;Gt&gt;</a>        Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__vertex__base__2.html">CGAL::Alpha_shape_vertex_base_2&lt;Gt, Vb&gt;</a>                 AsVb;</div><div class="line"><span class="comment">// Cell type</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Periodic_2_triangulation_2.tag:../Periodic_2_triangulation_2/" href="../Periodic_2_triangulation_2/classCGAL_1_1Periodic__2__triangulation__face__base__2.html">CGAL::Periodic_2_triangulation_face_base_2&lt;Gt&gt;</a>          Cb;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__face__base__2.html">CGAL::Alpha_shape_face_base_2&lt;Gt, Cb&gt;</a>                   AsCb;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Triangulation_data_structure_2&lt;AsVb, AsCb&gt;        Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Periodic_2_triangulation_2.tag:../Periodic_2_triangulation_2/" href="../Periodic_2_triangulation_2/classCGAL_1_1Periodic__2__Delaunay__triangulation__2.html">CGAL::Periodic_2_Delaunay_triangulation_2&lt;Gt, Tds&gt;</a>      P2DT2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__2.html">CGAL::Alpha_shape_2&lt;P2DT2&gt;</a>                              Alpha_shape_2;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Gt::Point_2                                             Point;</div><div class="line"><span class="keyword">typedef</span> Gt::Segment_2                                           Segment;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Alpha__shape__2.html#a652f355cc521b0aa248a874a3fb408cc">Alpha_shape_2::Alpha_shape_edges_iterator</a>               Alpha_shape_edges_iterator;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;</div><div class="line"><span class="keywordtype">void</span> alpha_edges( <span class="keyword">const</span> Alpha_shape_2&amp; A, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  Alpha_shape_edges_iterator it = A.alpha_shape_edges_begin(),</div><div class="line">                             end = A.alpha_shape_edges_end();</div><div class="line">  <span class="keywordflow">for</span>( ; it!=end; ++it)</div><div class="line">    *out++ = A.segment(*it);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;</div><div class="line"><span class="keywordtype">bool</span> file_input(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  std::ifstream is(<span class="stringliteral">"./data/fin"</span>, std::ios::in);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(is.fail())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"unable to open file for input"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> n;</div><div class="line">  is &gt;&gt; n;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Reading "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" points from file"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gadba21cc5c30a79519438dfe0f9264255">CGAL::cpp11::copy_n</a>(std::istream_iterator&lt;Point&gt;(is), n, out);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::list&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(! file_input(std::back_inserter(points)))</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line"></div><div class="line">  <span class="comment">// Define the periodic square</span></div><div class="line">  P2DT2 pdt(Gt::Iso_rectangle_2(-10,-10, 700,700));</div><div class="line"></div><div class="line">  <span class="comment">// Heuristic for inserting large point sets (if pts is reasonably large)</span></div><div class="line">  pdt.insert(points.begin(), points.end(), <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  <span class="comment">// As pdt won't be modified anymore switch to 1-sheeted cover if possible</span></div><div class="line">  <span class="keywordflow">if</span>(pdt.is_triangulation_in_1_sheet())</div><div class="line">    pdt.convert_to_1_sheeted_covering();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Periodic Delaunay computed."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// compute alpha shape</span></div><div class="line">  Alpha_shape_2 as(pdt);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Alpha shape computed in REGULARIZED mode by default."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">   <span class="comment">// find optimal alpha values</span></div><div class="line">  Alpha_shape_2::NT alpha_solid = as.find_alpha_solid();</div><div class="line">  <a class="code" href="classCGAL_1_1Alpha__shape__2.html#a06ac11586ec6d90d59e0e76e465d074c">Alpha_shape_2::Alpha_iterator</a> opt = as.find_optimal_alpha(1);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Smallest alpha value to get a solid through data points is "</span> &lt;&lt; alpha_solid &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Optimal alpha value to get one connected component is "</span> &lt;&lt;  *opt    &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  as.set_alpha(*opt);</div><div class="line">  assert(as.number_of_solid_components() == 1);</div><div class="line"></div><div class="line">  as.set_alpha(10000);</div><div class="line">  std::vector&lt;Segment&gt; segments;</div><div class="line">  alpha_edges(as, std::back_inserter(segments));</div><div class="line">  std::cout &lt;&lt; segments.size() &lt;&lt; <span class="stringliteral">" alpha shape edges"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:04 for CGAL 4.13 - 2D Alpha Shapes by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
