<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Linear_Cell_Complex"/><anchor id="index_1ChapterLinearCellComplex"/> <simplesect kind="author"><para>Guillaume Damiand </para></simplesect>
</para><sect1 id="index_1Linear_cell_complexIntroduction">
<title>Introduction</title>
<para>A <emphasis>d</emphasis>D linear cell complex allows to represent an orientable subdivided <emphasis>d</emphasis>D object having linear geometry: each vertex of the subdivision is associated with a point. The geometry of each edge is a segment whose end points are associated with the two vertices of the edge, the geometry of each 2-cell is obtained from all the segments associated to the edges describing the boundary of the 2-cell and so on.</para><para>The combinatorial part of a linear cell complex is described either by a <emphasis>d</emphasis>D <ref refid="classCombinatorialMap" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">combinatorial map</ref> or by a <emphasis>d</emphasis>D <ref refid="classGeneralizedMap" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Generalized_map.tag">generalized map</ref> (it is strongly recommended to first read the <ref refid="index_1ChapterCombinatorialMap" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Combinatorial maps user manual</ref> or <ref refid="index_1ChapterGeneralizedMap" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Generalized_map.tag">Generalized maps user manual</ref> for definitions). To add the linear geometrical embedding, a point (a model of <ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag"><computeroutput>Point_2</computeroutput></ref> or <ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag"><computeroutput>Point_3</computeroutput></ref> or <ref refid="classKernel__d_1a0d1e83f4ca55f35b82abe627b0480f3a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_d.tag"><computeroutput>Point_d</computeroutput></ref>) is associated to each vertex of the combinatorial data-structure.</para><para><anchor id="index_1fig__fig_lcc_example_subdivisions"/><image type="html" name="lcc_example_subdivisions.svg"></image>
 <image type="latex" name="lcc_example_subdivisions.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_lcc_example_subdivisions" kindref="member">fig__fig_lcc_example_subdivisions</ref> Examples of objects with linear geometry. <bold>Left</bold>: A 2D object composed of three 2-cells, nine 1-cells and seven points associated to the seven 0-cells . <bold>Right</bold>: A 3D object composed of three 3-cells, twelve 2-cells, sixteen 1-cells and eight points associated to the eight 0-cells.  <linebreak/>
</para><para>If we reconsider the example introduced in the combinatorial map package, recalled in <ref refid="index_1fig__fig_lcc_example_subdivisions" kindref="member">fig__fig_lcc_example_subdivisions</ref> (Right), the combinatorial part of the 3D object is described by a 3D combinatorial map. As illustrated in <ref refid="index_1fig__fig_lcc_examples_zoom" kindref="member">fig__fig_lcc_examples_zoom</ref>, the geometrical part of the object is described by associating a point to each vertex of the map.</para><para><anchor id="index_1fig__fig_lcc_examples_zoom"/><image type="html" name="lcc_examples_zoom.svg"></image>
 <image type="latex" name="lcc_examples_zoom.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_lcc_examples_zoom" kindref="member">fig__fig_lcc_examples_zoom</ref> Example of 3D linear cell complex describing the object given in <ref refid="index_1fig__fig_lcc_example_subdivisions" kindref="member">fig__fig_lcc_example_subdivisions</ref> (Right). <bold>Left</bold>: The 3D linear cell complex which contains 54 darts (18 for each 3-cell) where each vertex is associated with a point, here a <computeroutput><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_3</ref></computeroutput>. Blue segments represent <formula id="8">$ \beta_3$</formula> relations. <bold>Middle</bold>: Zoom around the central edge which details the six darts belonging to the edge and the associations between darts and points. <bold>Right</bold>: Zoom around the facet between light gray and white 3-cells, which details the eight darts belonging to the facet and the associations between darts and points (given by red segments).  <linebreak/>
</para><para>Things are similar for generalized map, as illustrated in <ref refid="index_1fig__fig_lcc_example_gmap" kindref="member">fig__fig_lcc_example_gmap</ref>. In this example, a 2D generalized map is used as underlying data-structure to describe the object given in <ref refid="index_1fig__fig_lcc_example_subdivisions" kindref="member">fig__fig_lcc_example_subdivisions</ref> (Left). The 2D linear cell complex shown in <ref refid="index_1fig__fig_lcc_example_gmap" kindref="member">fig__fig_lcc_example_gmap</ref> (Left) is obtained from this 2D generalized map by associating a point to each vertex of the map. We can compare in <ref refid="index_1fig__fig_lcc_example_subdivisions" kindref="member">fig__fig_lcc_example_subdivisions</ref> (Right) this 2D linear cell complex with the 2D linear cell complex describing the same 2D object but using 2D combinatorial maps (instead of generalized map). The only difference comes from the original definitions of combinatorial and generalized maps. Combinatorial maps have twice less darts than generalized maps, and thus the corresponding 2D linear cell complex has twice less association between darts and points.</para><para><anchor id="index_1fig__fig_lcc_example_gmap"/><image type="html" name="lcc_example_gmap.svg"></image>
 <image type="latex" name="lcc_example_gmap.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_lcc_example_gmap" kindref="member">fig__fig_lcc_example_gmap</ref> Example of 2D linear cell complexes describing the object given in <ref refid="index_1fig__fig_lcc_example_subdivisions" kindref="member">fig__fig_lcc_example_subdivisions</ref> (Left). (Left) Based on a 2D generalized map. (Right) Based on a 2D combinatorial map. In both cases, each vertex of the combinatorial data-structure is associated with a point, here a <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput>. Associations between darts and points is drawn by red segments.  <linebreak/>
</para><para>Note that the dimension of the combinatorial or the generalized map <emphasis>d</emphasis> is not necessarily equal to the dimension of the ambient space <emphasis>d2</emphasis>. Indeed, we can use for example a 2D combinatorial map in a 2D ambient space to describe a planar graph (<emphasis>d</emphasis>=<emphasis>d2</emphasis>=<emphasis>2</emphasis>), or a 2D combinatorial map in a 3D ambient space to describe a surface in 3D space (<emphasis>d</emphasis>=2, <emphasis>d2</emphasis>=3) (case of the <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput> package), or a 3D generalized map in a 3D ambient space (<emphasis>d</emphasis>=<emphasis>d2</emphasis>=3) and so on.</para></sect1>
<sect1 id="index_1Linear_cell_complexSoftware">
<title>Software Design</title>
<para>The diagram in <ref refid="index_1fig__fig_lcc_diagramme_class" kindref="member">fig__fig_lcc_diagramme_class</ref> shows the main classes of the package. <computeroutput><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">Linear_cell_complex_for_combinatorial_map</ref></computeroutput> is the main class if you use combinatorial maps as combinatorial data-structure, and <computeroutput><ref refid="classCGAL_1_1Linear__cell__complex__for__generalized__map" kindref="compound">Linear_cell_complex_for_generalized_map</ref></computeroutput> is the main class if you use generalized maps as combinatorial data-structure (see Section <ref refid="index_1sseclinearcellcomplex" kindref="member">Linear Cell Complex</ref>). <computeroutput><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">Linear_cell_complex_for_combinatorial_map</ref></computeroutput> inherits from the <computeroutput><ref refid="classCGAL_1_1Combinatorial__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Combinatorial_map</ref></computeroutput> class and <computeroutput><ref refid="classCGAL_1_1Linear__cell__complex__for__generalized__map" kindref="compound">Linear_cell_complex_for_generalized_map</ref></computeroutput> inherits from the <computeroutput><ref refid="classCGAL_1_1Generalized__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Generalized_map.tag">Generalized_map</ref></computeroutput> class. Attributes can be associated to some cells of the linear cell complex thanks to an items class (see Section <ref refid="index_1sseclccitem" kindref="member">Linear Cell Complex Items</ref>), which defines the information associated to darts, and the attributes types. These types may be different for different dimensions of cells, and they may also be void. In the class <computeroutput><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">Linear_cell_complex_for_combinatorial_map</ref></computeroutput>, it is required that specific attributes are associated to all vertices of the combinatorial or generalized map. These attributes must contain a point (a model of <ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag"><computeroutput>Point_2</computeroutput></ref> or <ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag"><computeroutput>Point_3</computeroutput></ref> or <ref refid="classKernel__d_1a0d1e83f4ca55f35b82abe627b0480f3a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_d.tag"><computeroutput>Point_d</computeroutput></ref>), and can be represented by instances of class <computeroutput><ref refid="classCGAL_1_1Cell__attribute__with__point" kindref="compound">Cell_attribute_with_point</ref></computeroutput> (see Section <ref refid="index_1ssecattributewp" kindref="member">Cell Attributes</ref>).</para><para><anchor id="index_1fig__fig_lcc_diagramme_class"/><image type="html" name="lcc_diagramme_class.svg"></image>
 <image type="latex" name="lcc_diagramme_class.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_lcc_diagramme_class" kindref="member">fig__fig_lcc_diagramme_class</ref> UML diagram of the main classes of the package. Gray elements come from the <ref refid="index_1ChapterCombinatorialMap" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Combinatorial maps</ref> and <ref refid="index_1ChapterGeneralizedMap" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Generalized_map.tag">Generalized maps</ref> packages.  <linebreak/>
</para></sect1>
<sect1 id="index_1sseclinearcellcomplex">
<title>Linear Cell Complex</title>
<para>The <ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound"><computeroutput>Linear_cell_complex_for_combinatorial_map&lt;d,d2,LCCTraits,Items,Alloc&gt;</computeroutput></ref> class is a model of the <computeroutput><ref refid="classLinearCellComplex" kindref="compound">LinearCellComplex</ref></computeroutput> concept that uses a combinatorial map as underlying combinatorial data-structure. Similarly, the <ref refid="classCGAL_1_1Linear__cell__complex__for__generalized__map" kindref="compound"><computeroutput>Linear_cell_complex_for_generalized_map&lt;d,d2,LCCTraits,Items,Alloc&gt;</computeroutput></ref> class is a model of the <computeroutput><ref refid="classLinearCellComplex" kindref="compound">LinearCellComplex</ref></computeroutput> concept that uses a generalized map as underlying combinatorial data-structure. These two classes guarantee that each vertex is associated with an attribute containing a point. These classes can be used in geometric algorithms (they play the same role as <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput> for <ref refid="index_1chapterHalfedgeDS" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">Halfedge Data Structures</ref>).</para><para>These classes has five template parameters standing for the dimension of the map, the dimension of the ambient space, a traits class (a model of the <computeroutput><ref refid="classLinearCellComplexTraits" kindref="compound">LinearCellComplexTraits</ref></computeroutput> concept, see Section <ref refid="index_1sseclcctraits" kindref="member">Linear Cell Complex Traits</ref>), an items class (a model of the <computeroutput><ref refid="classLinearCellComplexItems" kindref="compound">LinearCellComplexItems</ref></computeroutput> concept, see Section <ref refid="index_1sseclccitem" kindref="member">Linear Cell Complex Items</ref>), and an allocator which must be a model of the allocator concept of STL. Default classes are provided for the traits, items, and for the allocator classes, and by default <computeroutput>d2=d</computeroutput>.</para><para>A linear cell complex is valid, if it is a valid combinatorial or generalized map where each dart is associated with an attribute containing a point (i.e. an instance of a model of the <computeroutput><ref refid="classCellAttributeWithPoint" kindref="compound">CellAttributeWithPoint</ref></computeroutput> concept). Note that there are no validity constraints on the geometry (test on self intersection, planarity of 2-cells...). We can see two examples of <computeroutput><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">Linear_cell_complex_for_combinatorial_map</ref></computeroutput> in <ref refid="index_1fig__fig_lcc_instantiations" kindref="member">fig__fig_lcc_instantiations</ref>.</para><para><anchor id="index_1fig__fig_lcc_instantiations"/><image type="html" name="lcc_instantiations.svg"></image>
 <image type="latex" name="lcc_instantiations.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_lcc_instantiations" kindref="member">fig__fig_lcc_instantiations</ref> Examples of <computeroutput><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">Linear_cell_complex_for_combinatorial_map</ref></computeroutput>. Gray disks show the attributes associated to vertices. Associations between darts and attributes are drawn by small lines between darts and disks. <bold>Left:</bold> Example of <computeroutput><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">Linear_cell_complex_for_combinatorial_map</ref>&lt;2,2&gt;</computeroutput>. <bold>Right:</bold> Example of <computeroutput><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">Linear_cell_complex_for_combinatorial_map</ref>&lt;3,3&gt;</computeroutput>.  <linebreak/>
</para><sect2 id="index_1Linear_cell_complexCellAttributes">
<title>Cell Attributes</title>
<para><anchor id="index_1ssecattributewp"/> The <computeroutput><ref refid="classCGAL_1_1Cell__attribute__with__point" kindref="compound">Cell_attribute_with_point</ref>&lt;LCC,Info_,Tag,OnMerge,OnSplit&gt;</computeroutput> class is a model of the <computeroutput><ref refid="classCellAttributeWithPoint" kindref="compound">CellAttributeWithPoint</ref></computeroutput> concept, which is a refinement of the <computeroutput><ref refid="classCellAttribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">CellAttribute</ref></computeroutput> concept. It represents an attribute associated with a cell, which can contain an information (depending on whether <computeroutput>Info_==void</computeroutput> or not), but which always contains a point, an instance of <ref refid="classLinearCellComplex_1aafe7703196b62bce46a907a289d515f6" kindref="member"><computeroutput>LCC::Point</computeroutput></ref>.</para></sect2>
<sect2 id="index_1Linear_cell_complexLinearCellComplexTraits">
<title>Linear Cell Complex Traits</title>
<para><anchor id="index_1sseclcctraits"/> The <computeroutput><ref refid="classLinearCellComplexTraits" kindref="compound">LinearCellComplexTraits</ref></computeroutput> geometric traits concept defines the required types and functors used in the <computeroutput><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">Linear_cell_complex_for_combinatorial_map</ref></computeroutput> class. For example it defines <ref refid="classLinearCellComplexTraits_1a08aa2768df7731ea33a55103dad927b9" kindref="member"><computeroutput>Point</computeroutput></ref>, the type of points used, and <ref refid="classLinearCellComplexTraits_1a533e357e4050159a6fda9fedfd5d88a1" kindref="member"><computeroutput>Vector</computeroutput></ref>, the corresponding vector type. It also defines all the required functors used for constructions and operations, as for example <ref refid="classLinearCellComplexTraits_1aeede6f32b68ccc7919bd331ec07aa459" kindref="member"><computeroutput>Construct_translated_point</computeroutput></ref> or <ref refid="classLinearCellComplexTraits_1a3fa01a5556247923aae1ef71efff844a" kindref="member"><computeroutput>Construct_sum_of_vectors</computeroutput></ref>.</para><para>The class <computeroutput><ref refid="structCGAL_1_1Linear__cell__complex__traits" kindref="compound">Linear_cell_complex_traits</ref>&lt;d,K&gt;</computeroutput> is a model of <computeroutput><ref refid="classLinearCellComplexTraits" kindref="compound">LinearCellComplexTraits</ref></computeroutput>. It defines the different types which are obtained from <computeroutput>K</computeroutput> that, depending on <computeroutput>d</computeroutput>, is a model of the concept <computeroutput><ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> if <computeroutput>d==2</computeroutput> or <computeroutput>d==3</computeroutput>, and a model of the concept <computeroutput><ref refid="classKernel__d" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_d.tag">Kernel_d</ref></computeroutput> otherwise.</para></sect2>
<sect2 id="index_1Linear_cell_complexLinearCellComplexItems">
<title>Linear Cell Complex Items</title>
<para><anchor id="index_1sseclccitem"/> The <computeroutput><ref refid="classLinearCellComplexItems" kindref="compound">LinearCellComplexItems</ref></computeroutput> concept refines the <computeroutput><ref refid="classGenericMapItems" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">GenericMapItems</ref></computeroutput> concept by adding the requirement that 0-attributes are enabled, and associated with a type of attribute being a model of the <computeroutput><ref refid="classCellAttributeWithPoint" kindref="compound">CellAttributeWithPoint</ref></computeroutput> concept.</para><para>The class <computeroutput><ref refid="structCGAL_1_1Linear__cell__complex__min__items" kindref="compound">Linear_cell_complex_min_items</ref>&lt;d&gt;</computeroutput> is a model of <computeroutput><ref refid="classLinearCellComplexItems" kindref="compound">LinearCellComplexItems</ref></computeroutput>. It defines <computeroutput>void</computeroutput> as information associated to darts, and instances of <computeroutput><ref refid="classCGAL_1_1Cell__attribute__with__point" kindref="compound">Cell_attribute_with_point</ref></computeroutput> (which contain no information) associated to each vertex. All other attributes are <computeroutput>void</computeroutput>.</para></sect2>
</sect1>
<sect1 id="index_1Linear_cell_complexOperations">
<title>Operations</title>
<para>Several operations defined in the combinatorial maps or generalized maps package can be used on a linear cell complex. This is the case for all the iteration operations that do not modify the model (see example in Section <ref refid="index_1ssec3Dlcc" kindref="member">A 3D Linear Cell Complex</ref>). This is also the case for all the operations that do not create new 0-cells: <computeroutput>sew</computeroutput>, <computeroutput>unsew</computeroutput>, <ref refid="classGenericMap_1a389c061e7bd6d6f975ddf35332a86971" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>remove_cell</computeroutput></ref>, <ref refid="classGenericMap_1af052e3f6c70a2d691a2bdbccfa9c3908" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_1_in_cell_2</computeroutput></ref> or <ref refid="classGenericMap_1ae07843054741ac7462b4e90dc945a28b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_2_in_cell_3</computeroutput></ref>. Indeed, all these operations update non <computeroutput>void</computeroutput> attributes, and thus update vertex attributes of a linear cell complex. Note that some existing 0-attributes can be duplicated by the <computeroutput>unsew</computeroutput> method, but these 0-attributes are not new but copies of existing old 0-attributes.</para><para>However, operations that create a new 0-cell can not be directly used since the new 0-cell would not be associated with a vertex attribute. Indeed, it is not possible for these operations to automatically decide which point to create. These operations are: <ref refid="classGenericMap_1a7ca9a5f6c514cdd3c0fdd31e81163774" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_0_in_cell_1</computeroutput></ref>, <ref refid="classGenericMap_1a6e286a26bbb5d897e0b830fff3721a8c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_0_in_cell_2</computeroutput></ref>, <ref refid="classGenericMap_1a1e129b7060aa80feb689ecf51068e4ca" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_dangling_cell_1_in_cell_2</computeroutput></ref>, plus all the creation operations. For these operations, new versions are proposed taking some points as additional parameters. Lastly, some new operations are defined, which use the geometry (see sections <ref refid="index_1ssecconstructionsop" kindref="member">Construction Operations</ref> and <ref refid="index_1ssecmodifop" kindref="member">Modification Operations</ref>).</para><para>All the operations given in this section guarantee that given a valid linear cell complex and a possible operation, the result is a valid linear cell complex. As for a combinatorial or generalized map, it is also possible to use low level operations but additional operations may be needed to restore the validity conditions.</para><sect2 id="index_1sseclcclinkdarts">
<title>Sewing and Unsewing</title>
<para>As explained in the <ref refid="index_1sseclinkdarts" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">combinatorial map</ref> and <ref refid="index_1sseclinkdarts_gmap" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Generalized_map.tag">generalized map</ref> user manuals, it is possible to glue two <emphasis>i</emphasis>-cells along an (<emphasis>i</emphasis>-1)-cell by using the <computeroutput>sew&lt;i&gt;</computeroutput> method. Since this method updates non void attributes, and since points are specific attributes, they are automatically updated during the <computeroutput>sew&lt;i&gt;</computeroutput> method. Thus the sewing of two <emphasis>i</emphasis>-cells could deform the geometry of the concerned objects.</para><para>For example, in <ref refid="index_1fig__fig_lcc_example_3d_sew" kindref="member">fig__fig_lcc_example_3d_sew</ref>, we want to 3-sew the two initial 3-cells. <ref refid="classCombinatorialMap_1a69897b7ed14fa2ed039f43797943496c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>sew&lt;3&gt;(1,5)</computeroutput></ref> links by <formula id="8">$ \beta_3$</formula> the pairs of darts (1,5), (2,8), (3,7) and (4,6). The eight vertex attributes around the facet between the two 3-cells before the sew are merged by pair during the sew operation (and the <ref refid="classCellAttribute_1a31081515f9da08876797a998f7199b27" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>On_merge</computeroutput></ref> functor is called four times). Thus, after the sew, there are only four 0-attributes around the facet. By default, the attributes associated with the first dart of the sew operation are kept (but this can be modified by defining your own functor in the attribute class as explained in the packages combinatorial map and generalized map. Intuitively, the geometry of the second 2-cell is deformed to fit to the first 2-cell.</para><para><anchor id="index_1fig__fig_lcc_example_3d_sew"/><image type="html" name="lcc_example_3d_sew.svg"></image>
 <image type="latex" name="lcc_example_3d_sew.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_lcc_example_3d_sew" kindref="member">fig__fig_lcc_example_3d_sew</ref> Example of 3-sew operation for linear cell complex. <bold>Left</bold>: A 3D linear cell complex containing two 3-cells that are not connected. Vertex attributes are drawn with circles containing point coordinates. Associations between darts and attributes are drawn with small lines between darts and disks. <bold>Right</bold>: The 3D linear cell complex obtained as result of <ref refid="classCombinatorialMap_1a69897b7ed14fa2ed039f43797943496c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>sew&lt;3&gt;(1,5)</computeroutput></ref> (or <ref refid="classCombinatorialMap_1a69897b7ed14fa2ed039f43797943496c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>sew&lt;3&gt;(2,8)</computeroutput></ref>, or <ref refid="classCombinatorialMap_1a69897b7ed14fa2ed039f43797943496c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>sew&lt;3&gt;(3,7)</computeroutput></ref>, or <ref refid="classCombinatorialMap_1a69897b7ed14fa2ed039f43797943496c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>sew&lt;3&gt;(4,6)</computeroutput></ref>). The eight 0-attributes around the facet between the two 3-cells before the sew operation, are merged into four 0-attributes after. The geometry of the pyramid is deformed since its base is fitted on the 2-cell of the cube.  <linebreak/>
</para><para>This is similar for <computeroutput>unsew&lt;i&gt;</computeroutput> operation, which removes <emphasis>i</emphasis>-links of all the darts in a given <emphasis>(i-1)</emphasis>-cell, and updates non void attributes which are no more associated to a same cell due to the unlinks. If we take the linear cell complex given in <ref refid="index_1fig__fig_lcc_example_3d_sew" kindref="member">fig__fig_lcc_example_3d_sew</ref> (Right), and we call <ref refid="classCombinatorialMap_1a3e49b743ce3ddd26b21c7c0463ffe703" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>unsew&lt;3&gt;(2)</computeroutput></ref>, we obtain the linear cell complex in <ref refid="index_1fig__fig_lcc_example_3d_sew" kindref="member">fig__fig_lcc_example_3d_sew</ref> (Left) except for the coordinates of the new four vertices, which by default are copies of original vertices (this behavior can be modified thanks to the functor <ref refid="classCellAttribute_1a3b4b722747fa2e6f52331bf92ea4f92f" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>On_split</computeroutput></ref> in the attribute class). The <ref refid="classCombinatorialMap_1a3e49b743ce3ddd26b21c7c0463ffe703" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>unsew&lt;3&gt;</computeroutput></ref> operation has removed the four <formula id="8">$ \beta_3$</formula> links, and has duplicated the 0-attributes since vertices are split in two after the unsew operation.</para><para></para><para>If <ref refid="classGenericMap_1af7fcbe383d43efece8525654b45741bf" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>set_automatic_attributes_management(false)</computeroutput></ref> is called, all the future sew and unsew operations will not update non void attributes. These attributes will be updated latter by the call to <ref refid="classGenericMap_1af7fcbe383d43efece8525654b45741bf" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>set_automatic_attributes_management(true)</computeroutput></ref>. </para></sect2>
<sect2 id="index_1Linear_cell_complexConstructionOperations">
<title>Construction Operations</title>
<para><anchor id="index_1ssecconstructionsop"/> There are several member functions allowing to insert specific configurations of darts into a linear cell complex. These functions return a <computeroutput>Dart_handle</computeroutput> to the new object. Note that the dimension of the linear cell complex must be large enough: darts must contain all the applications ( <formula id="9">$ \alpha$</formula> or <formula id="10">$ \beta$</formula>) used by the operation. All these methods add new darts in the current linear cell complex, existing darts are not modified. These functions are <ref refid="classLinearCellComplex_1a2929f7df1f0a0d00e1a59d9c9f264439" kindref="member"><computeroutput>make_segment</computeroutput></ref>, <ref refid="classLinearCellComplex_1ad46eb3f0dea8580207efdfb9d72714a0" kindref="member"><computeroutput>make_triangle</computeroutput></ref>, <ref refid="classLinearCellComplex_1a7586f6bb50e1b7f8259374a8bcaa5ba0" kindref="member"><computeroutput>make_tetrahedron</computeroutput></ref> and <ref refid="classLinearCellComplex_1a8786996ef191013fcee5a90a4ceb22ae" kindref="member"><computeroutput>make_hexahedron</computeroutput></ref>.</para><para>There are two functions allowing to build a linear cell complex from two other CGAL data types: <itemizedlist>
<listitem>
<para><ref refid="group__PkgLinearCellComplexConstructions_1ga7e8cde514b93c3441a4df2bc09c24068" kindref="member"><computeroutput>import_from_triangulation_3(lcc,atr)</computeroutput></ref>: adds in <computeroutput>lcc</computeroutput> all the tetrahedra present in <computeroutput>atr</computeroutput>, a <ref refid="classCGAL_1_1Triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag"><computeroutput>Triangulation_3</computeroutput></ref>; </para></listitem>
<listitem>
<para><ref refid="group__PkgLinearCellComplexConstructions_1ga9239e988c6d5e674d64438d47b95a548" kindref="member"><computeroutput>import_from_polyhedron_3(lcc,ap)</computeroutput></ref>: adds in <computeroutput>lcc</computeroutput> all the cells present in <computeroutput>ap</computeroutput>, a <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput>. </para></listitem>
</itemizedlist>
</para><para>Lastly, the function <ref refid="group__PkgLinearCellComplexConstructions_1gaa356d78601f8844476fc2e039f0df83e" kindref="member"><computeroutput>import_from_plane_graph(lcc,ais)</computeroutput></ref> adds in <computeroutput>lcc</computeroutput> all the cells reconstructed from the planar graph read in <computeroutput>ais</computeroutput>, a <computeroutput>std::istream</computeroutput> (see the <ref refid="group__PkgLinearCellComplexConstructions_1gaa356d78601f8844476fc2e039f0df83e" kindref="member"><computeroutput>reference manual</computeroutput></ref> for the file format).</para></sect2>
<sect2 id="index_1Linear_cell_complexModificationOperations">
<title>Modification Operations</title>
<para><anchor id="index_1ssecmodifop"/> Some methods are defined in <computeroutput><ref refid="classLinearCellComplex" kindref="compound">LinearCellComplex</ref></computeroutput> to modify a linear cell complex and update the vertex attributes. In the following, we denote by <computeroutput>dh0</computeroutput>, <computeroutput>dh1</computeroutput>, <computeroutput>dh2</computeroutput> the dart handles for the darts <computeroutput>d0</computeroutput>, <computeroutput>d1</computeroutput>, <computeroutput>d2</computeroutput>, respectively. That is <computeroutput>d0 == *dh0</computeroutput>.</para><para><anchor id="index_1fig__fig_lcc_insert_vertex"/><image type="html" name="lcc_insert_vertex.svg"></image>
 <image type="latex" name="lcc_insert_vertex.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_lcc_insert_vertex" kindref="member">fig__fig_lcc_insert_vertex</ref> Example of <ref refid="classLinearCellComplex_1aad0f09b94013ed62b09959b05a0a2212" kindref="member"><computeroutput>insert_barycenter_in_cell&lt;1&gt;</computeroutput></ref> and <computeroutput>remove_cell&lt;0&gt;</computeroutput> operations. <bold>Left</bold>: Initial linear cell complex. <bold>Right</bold>: After the insertion of a point in the barycenter of the 1-cell containing dart <emphasis>d1</emphasis>. Now if we remove the 0-cell containing dart <emphasis>d2</emphasis>, we obtain a linear cell complex isomorphic to the initial one.  <linebreak/>
</para><para><ref refid="classLinearCellComplex_1aad0f09b94013ed62b09959b05a0a2212" kindref="member"><computeroutput>lcc.insert_barycenter_in_cell&lt;unsigned int i&gt;(dh0)</computeroutput></ref> adds the barycenter of the <emphasis>i</emphasis>-cell containing dart <computeroutput>d0</computeroutput>. This operation is possible if <computeroutput>d0</computeroutput> <formula id="11">$ \in$</formula><ref refid="classGenericMap_1aebcaaf5b48b571d26a77c74c5583bc1c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>lcc.darts()</computeroutput></ref> (see examples on <ref refid="index_1fig__fig_lcc_insert_vertex" kindref="member">fig__fig_lcc_insert_vertex</ref> and <ref refid="index_1fig__fig_lcc_triangulation" kindref="member">fig__fig_lcc_triangulation</ref>).</para><para><ref refid="classLinearCellComplex_1ae02818ec1d44a28dc3265df1b76a967e" kindref="member"><computeroutput>lcc.insert_point_in_cell&lt;unsigned int i&gt;(dh0,p)</computeroutput></ref> is an operation similar to the previous operation, the only difference being that the coordinates of the new point are here given by <computeroutput>p</computeroutput> instead of being computed as the barycenter of the <emphasis>i</emphasis>-cell. Currently, these two operations are only defined for <computeroutput>i=1</computeroutput> to insert a point in an edge, or <computeroutput>i=2</computeroutput> to insert a point in a facet.</para><para><anchor id="index_1fig__fig_lcc_triangulation"/><image type="html" name="lcc_triangulation.svg"></image>
 <image type="latex" name="lcc_triangulation.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_lcc_triangulation" kindref="member">fig__fig_lcc_triangulation</ref> Examples of <ref refid="classLinearCellComplex_1aad0f09b94013ed62b09959b05a0a2212" kindref="member"><computeroutput>insert_barycenter_in_cell&lt;2&gt;</computeroutput></ref> operation.  <linebreak/>
</para><para><ref refid="classLinearCellComplex_1a27af7fff974fcaaecca706d8ad736f84" kindref="member"><computeroutput>lcc.insert_dangling_cell_1_in_cell_2(dh0,p)</computeroutput></ref> adds a 1-cell in the 2-cell containing dart <computeroutput>d0</computeroutput>, the 1-cell being attached by only one of its vertex to the 0-cell containing dart <computeroutput>d0</computeroutput>. The second vertex of the new edge is associated with a new 0-attribute containing a copy of <computeroutput>p</computeroutput> as point. This operation is possible if <computeroutput>d0</computeroutput> <formula id="11">$ \in$</formula><ref refid="classGenericMap_1aebcaaf5b48b571d26a77c74c5583bc1c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>lcc.darts()</computeroutput></ref> (see example on <ref refid="index_1fig__fig_lcc_insert_edge" kindref="member">fig__fig_lcc_insert_edge</ref>).</para><para><anchor id="index_1fig__fig_lcc_insert_edge"/><image type="html" name="lcc_insert_edge.svg"></image>
 <image type="latex" name="lcc_insert_edge.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_lcc_insert_edge" kindref="member">fig__fig_lcc_insert_edge</ref> Example of <ref refid="classLinearCellComplex_1a27af7fff974fcaaecca706d8ad736f84" kindref="member"><computeroutput>insert_dangling_cell_1_in_cell_2</computeroutput></ref>, <computeroutput>insert_cell_1_in_cell_2</computeroutput> and <computeroutput>remove_cell&lt;1&gt;</computeroutput> operations. <bold>Left</bold>: Initial linear cell complex. <bold>Right</bold>: After the insertion of a dangling 1-cell in the 2-cell containing dart <emphasis>d1</emphasis>, and of a 1-cell in the 2-cell containing dart <emphasis>d2</emphasis>. Now if we remove the 1-cells containing dart <emphasis>d4</emphasis> and <emphasis>d5</emphasis>, we obtain a linear cell complex isomorphic to the initial one.  <linebreak/>
</para><para>Some examples of use of these operations are given in Section <ref refid="index_1ssec5dexample" kindref="member">A 4D Linear Cell Complex</ref>.</para><para></para><para>If <ref refid="classGenericMap_1af7fcbe383d43efece8525654b45741bf" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>set_automatic_attributes_management(false)</computeroutput></ref> is called, all the future insertion or removal operations will not update non void attributes. These attributes will be updated latter by the call to <ref refid="classGenericMap_1af7fcbe383d43efece8525654b45741bf" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>set_automatic_attributes_management(true)</computeroutput></ref>. This can be useful to speed up an algorithm which uses several successive insertion and removal operations. See example <ref refid="index_1ssecAttributesManagement" kindref="member">Automatic attributes management</ref>. </para></sect2>
</sect1>
<sect1 id="index_1Linear_cell_complexExamples">
<title>Examples</title>
<sect2 id="index_1Linear_cell_complexA3DLinearCellComplex">
<title>A 3D Linear Cell Complex</title>
<para><anchor id="index_1ssec3Dlcc"/> This example uses a 3-dimensional linear cell complex based on combinatorial maps. It creates two tetrahedra and displays all the points of the linear cell complex thanks to a <ref refid="classLinearCellComplex_1a311dc07c9279922957257415d45237df" kindref="member"><computeroutput>Vertex_attribute_const_range</computeroutput></ref>. Then, the two tetrahedra are <ref refid="classCombinatorialMap_1a69897b7ed14fa2ed039f43797943496c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>3-sewn</computeroutput></ref> and we translate all the points of the second tetrahedron along vector <computeroutput>v(3,1,1)</computeroutput>. Since the two tetrahedra are 3-sewn, this translation moves also the 2-cell of the first tetrahedron shared with the second one. This is illustrated by displaying all the points of each 3-cell. For that we use a <computeroutput>std::for_each</computeroutput> and the <computeroutput>Display_vol_vertices</computeroutput> functor.</para><para><linebreak/>
<bold>File</bold> <ref refid="Linear_cell_complex_2linear_cell_complex_3_8cpp-example" kindref="compound">Linear_cell_complex/linear_cell_complex_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">CGAL::Linear_cell_complex_for_combinatorial_map&lt;3&gt;</ref><sp/>LCC_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_3::Dart_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dart_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_3::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Functor<sp/>used<sp/>to<sp/>display<sp/>all<sp/>the<sp/>vertices<sp/>of<sp/>a<sp/>given<sp/>volume.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>LCC&gt;<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Display_vol_vertices<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1cpp98_1_1unary__function" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp98::unary_function</ref>&lt;LCC,<sp/>void&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Display_vol_vertices(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>LCC&amp;<sp/>alcc)<sp/>:<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lcc(alcc),<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nb_volume(0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>LCC::Dart&amp;<sp/>d)<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Volume<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;++nb_volume&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>LCC::template<sp/>One_dart_per_incident_cell_range&lt;0,3&gt;::</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>it=lcc.template<sp/>one_dart_per_incident_cell&lt;0,3&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(lcc.dart_handle(d)).begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend=lcc.template<sp/>one_dart_per_incident_cell&lt;0,3&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(lcc.dart_handle(d)).end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>lcc.point(it)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>LCC&amp;<sp/>lcc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb_volume;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC_3<sp/>lcc;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>two<sp/>tetrahedra.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d1<sp/>=<sp/>lcc.make_tetrahedron(Point(-1,<sp/>0,<sp/>0),<sp/>Point(0,<sp/>2,<sp/>0),<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(1,<sp/>0,<sp/>0),<sp/>Point(1,<sp/>1,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d2<sp/>=<sp/>lcc.make_tetrahedron(Point(0,<sp/>2,<sp/>-1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(-1,<sp/>0,<sp/>-1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(1,<sp/>0,<sp/>-1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(1,<sp/>1,<sp/>-3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Display<sp/>all<sp/>the<sp/>vertices<sp/>of<sp/>the<sp/>lcc<sp/>by<sp/>iterating<sp/>on<sp/>the<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Vertex_attribute<sp/>container.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga62462cf829e614f6f2cd2cbec9a093d2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_ascii_mode</ref>(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Vertices:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(LCC_3::Vertex_attribute_const_range::iterator<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v=lcc.vertex_attributes().begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vend=lcc.vertex_attributes().end();<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v!=vend;<sp/>++v)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>lcc.point_of_vertex_attribute(v)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Display<sp/>the<sp/>vertices<sp/>of<sp/>each<sp/>volume<sp/>by<sp/>iterating<sp/>on<sp/>darts.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::for_each(lcc.one_dart_per_cell&lt;3&gt;().begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lcc.one_dart_per_cell&lt;3&gt;().end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Display_vol_vertices&lt;LCC_3&gt;(lcc));<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>3-Sew<sp/>the<sp/>2<sp/>tetrahedra<sp/>along<sp/>one<sp/>facet</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.sew&lt;3&gt;(d1,<sp/>d2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Display<sp/>the<sp/>vertices<sp/>of<sp/>each<sp/>volume<sp/>by<sp/>iterating<sp/>on<sp/>darts.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::for_each(lcc.one_dart_per_cell&lt;3&gt;().begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lcc.one_dart_per_cell&lt;3&gt;().end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Display_vol_vertices&lt;LCC_3&gt;(lcc));<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Translate<sp/>the<sp/>second<sp/>tetrahedra<sp/>by<sp/>a<sp/>given<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC_3::Vector<sp/>v(3,1,1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(LCC_3::One_dart_per_incident_cell_range&lt;0,3&gt;::iterator<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it=lcc.one_dart_per_incident_cell&lt;0,3&gt;(d2).begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend=lcc.one_dart_per_incident_cell&lt;0,3&gt;(d2).end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lcc.point(it)=LCC_3::Traits::Construct_translated_point_3()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(lcc.point(it),v);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Display<sp/>the<sp/>vertices<sp/>of<sp/>each<sp/>volume<sp/>by<sp/>iterating<sp/>on<sp/>darts.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::for_each(lcc.one_dart_per_cell&lt;3&gt;().begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lcc.one_dart_per_cell&lt;3&gt;().end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Display_vol_vertices&lt;LCC_3&gt;(lcc));<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>display<sp/>the<sp/>lcc<sp/>characteristics.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;LCC<sp/>characteristics:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.display_characteristics(std::cout)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>lcc.is_valid()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para><para>The output is: <verbatim>Vertices: 1 1 2; 1 0 0; 0 2 0; -1 0 0; 1 1 -3; 1 0 -1; -1 0 -1; 0 2 -1;
Volume 1 : -1 0 0; 0 2 0; 1 0 0; 1 1 2;
Volume 2 : 0 2 -1; -1 0 -1; 1 0 -1; 1 1 -3;
Volume 1 : -1 0 0; 0 2 0; 1 0 0; 1 1 2;
Volume 2 : 0 2 0; -1 0 0; 1 0 0; 1 1 -3;
Volume 1 : 2 1 1; 3 3 1; 4 1 1; 1 1 2;
Volume 2 : 3 3 1; 2 1 1; 4 1 1; 4 2 -2;
LCC characteristics: #Darts=24, #0-cells=5, #1-cells=9, #2-cells=7, #3-cells=2, #ccs=1, valid=1
</verbatim></para><para>The first line gives the points of the linear cell complex before the <ref refid="classCombinatorialMap_1a69897b7ed14fa2ed039f43797943496c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>sew&lt;3&gt;</computeroutput></ref>. There are eight points, four for each tetrahedron. After the sew, six vertices are merged two by two, thus there are five vertices. We can see the points of each 3-cell (lines Volume 1 and Volume 2) before the sew, after the sew and after the translation of the second volume. We can see that this translation has also modified the three common points between the two 3-cells. The last line shows the number of cells of the linear cell complex, the number of connected components, and finally a Boolean to show the validity of the linear cell complex.</para></sect2>
<sect2 id="index_1Linear_cell_complexA4DLinearCellComplex">
<title>A 4D Linear Cell Complex</title>
<para><anchor id="index_1ssec5dexample"/> This example uses a 4-dimensional linear cell complex embedded in a 5-dimensional ambient space and based on generalized maps. It creates two tetrahedra having 5D points and sews the two tetrahedra by <formula id="12">$ \beta_4$</formula>. Then we use some high level operations, display the number of cells of the linear cell complex, and check its validity. Last we use the reverse operations to get back to the initial configuration.</para><para><linebreak/>
<bold>File</bold> <ref refid="Linear_cell_complex_2linear_cell_complex_4_8cpp-example" kindref="compound">Linear_cell_complex/linear_cell_complex_4.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_for_generalized_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Linear__cell__complex__for__generalized__map" kindref="compound">CGAL::Linear_cell_complex_for_generalized_map&lt;4,5&gt;</ref><sp/>LCC_4;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_4::Dart_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dart_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_4::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_4::Vector<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_4::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC_4<sp/>lcc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>two<sp/>tetrahedra.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>p1[5]={<sp/>0,<sp/>0,<sp/>0,<sp/>0,<sp/>0};<sp/>std::vector&lt;FT&gt;<sp/>v1(p1,p1+5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>p2[5]={<sp/>0,<sp/>2,<sp/>0,<sp/>0,<sp/>0};<sp/>std::vector&lt;FT&gt;<sp/>v2(p2,p2+5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>p3[5]={<sp/>0,<sp/>1,<sp/>2,<sp/>0,<sp/>0};<sp/>std::vector&lt;FT&gt;<sp/>v3(p3,p3+5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>p4[5]={<sp/>2,<sp/>1,<sp/>0,<sp/>0,<sp/>0};<sp/>std::vector&lt;FT&gt;<sp/>v4(p4,p4+5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>p5[5]={-1,<sp/>0,<sp/>0,<sp/>0,<sp/>0};<sp/>std::vector&lt;FT&gt;<sp/>v5(p5,p5+5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>p6[5]={-1,<sp/>2,<sp/>0,<sp/>0,<sp/>0};<sp/>std::vector&lt;FT&gt;<sp/>v6(p6,p6+5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>p7[5]={-1,<sp/>1,<sp/>2,<sp/>0,<sp/>0};<sp/>std::vector&lt;FT&gt;<sp/>v7(p7,p7+5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>p8[5]={-3,<sp/>1,<sp/>2,<sp/>0,<sp/>0};<sp/>std::vector&lt;FT&gt;<sp/>v8(p8,p8+5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d1<sp/>=<sp/>lcc.make_tetrahedron(Point(5,<sp/>v1.begin(),<sp/>v1.end()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(5,<sp/>v2.begin(),<sp/>v2.end()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(5,<sp/>v3.begin(),<sp/>v3.end()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(5,<sp/>v4.begin(),<sp/>v4.end()));<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d2<sp/>=<sp/>lcc.make_tetrahedron(Point(5,<sp/>v5.begin(),<sp/>v5.end()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(5,<sp/>v6.begin(),<sp/>v6.end()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(5,<sp/>v7.begin(),<sp/>v7.end()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(5,<sp/>v8.begin(),<sp/>v8.end()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.display_characteristics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal">&lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.sew&lt;4&gt;(d1,d2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.display_characteristics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal">&lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>one<sp/>vertex<sp/>on<sp/>the<sp/>middle<sp/>of<sp/>the<sp/>edge<sp/>containing<sp/>dart<sp/>d1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d3<sp/>=<sp/>lcc.insert_barycenter_in_cell&lt;1&gt;(d1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>lcc.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.display_characteristics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal">&lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>one<sp/>edge<sp/>to<sp/>cut<sp/>the<sp/>face<sp/>containing<sp/>dart<sp/>d3<sp/>in<sp/>two.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d4<sp/>=<sp/>lcc.insert_cell_1_in_cell_2(d3,<sp/>lcc.alpha(d1,<sp/>1,<sp/>0,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>lcc.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.display_characteristics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal">&lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>removal<sp/>operations<sp/>to<sp/>get<sp/>back<sp/>to<sp/>the<sp/>initial<sp/>configuration.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.remove_cell&lt;1&gt;(d4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>lcc.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.remove_cell&lt;0&gt;(d3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>lcc.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.unsew&lt;4&gt;(d1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.display_characteristics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal">&lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para><para>The output is: <verbatim>#Darts=48, #0-cells=8, #1-cells=12, #2-cells=8, #3-cells=2, #4-cells=2, #ccs=2, orientable=true, valid=1
#Darts=48, #0-cells=4, #1-cells=6, #2-cells=4, #3-cells=1, #4-cells=2, #ccs=1, orientable=true, valid=1
#Darts=56, #0-cells=5, #1-cells=7, #2-cells=4, #3-cells=1, #4-cells=2, #ccs=1, orientable=true, valid=1
#Darts=64, #0-cells=5, #1-cells=8, #2-cells=5, #3-cells=1, #4-cells=2, #ccs=1, orientable=true, valid=1
#Darts=48, #0-cells=8, #1-cells=12, #2-cells=8, #3-cells=2, #4-cells=2, #ccs=2, orientable=true, valid=1
</verbatim></para></sect2>
<sect2 id="index_1Linear_cell_complexA3DLinearCellComplexwith">
<title>A 3D Linear Cell Complex with Colored Vertices</title>
<para><anchor id="index_1ssecexemplecolorvertices"/> This example illustrates the way to use a 3D linear cell complex by adding another information to vertices. For that, we need to define our own items class. The difference with the <computeroutput><ref refid="structCGAL_1_1Linear__cell__complex__min__items" kindref="compound">Linear_cell_complex_min_items</ref></computeroutput> class is about the definition of the vertex attribute where we use a <computeroutput><ref refid="classCGAL_1_1Cell__attribute__with__point" kindref="compound">Cell_attribute_with_point</ref></computeroutput> with a non <computeroutput>void</computeroutput> info. In this example, the <emphasis>vertex color</emphasis> is just given by an <computeroutput>int</computeroutput> (the second template parameter of the <computeroutput><ref refid="classCGAL_1_1Cell__attribute__with__point" kindref="compound">Cell_attribute_with_point</ref></computeroutput>). Lastly, we define the <computeroutput>Average_functor</computeroutput> class in order to set the color of a vertex resulting of the merging of two vertices to the average of the two initial values. This functor is associated with the vertex attribute by passing it as template parameter. Using this items class instead of the default one is done during the instantiation of template parameters of the <computeroutput><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">Linear_cell_complex_for_combinatorial_map</ref></computeroutput> class.</para><para>Now we can use <computeroutput>LCC_3</computeroutput> in which each vertex is associated with an attribute containing both a point and an information. In the following example, we create two cubes, and set the color of the vertices of the first cube to 1 and of the second cube to 19 (by iterating through two <ref refid="classGenericMap_1a6d6212f4fc539c0054a2cfc3387ca096" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>One_dart_per_incident_cell_range&lt;0, 3&gt;</computeroutput></ref> ranges). Then we <ref refid="classCombinatorialMap_1a69897b7ed14fa2ed039f43797943496c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>3-sew</computeroutput></ref> the two cubes along one facet. This operation merges some vertices (as in the example of <ref refid="index_1fig__fig_lcc_example_3d_sew" kindref="member">fig__fig_lcc_example_3d_sew</ref>). We insert a vertex in the common 2-cell between the two cubes, and set the information of the new 0-attribute to 5. In the last loop, we display the point and the information of each vertex of the linear cell complex.</para><para><linebreak/>
<bold>File</bold> <ref refid="Linear_cell_complex_2linear_cell_complex_3_with_colored_vertices_8cpp-example" kindref="compound">Linear_cell_complex/linear_cell_complex_3_with_colored_vertices.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Average_functor</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>CellAttribute&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(<ref refid="classCellAttribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">CellAttribute</ref>&amp;<sp/>ca1,<sp/><ref refid="classCellAttribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">CellAttribute</ref>&amp;<sp/>ca2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>ca1.<ref refid="classCellAttribute_1a90ff12e6036acb7a684809b131eb7d99" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">info</ref>()=(ca1.<ref refid="classCellAttribute_1a90ff12e6036acb7a684809b131eb7d99" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">info</ref>()+<sp/>ca2.<ref refid="classCellAttribute_1a90ff12e6036acb7a684809b131eb7d99" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">info</ref>())/2;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Myitem</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Refs&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Dart_wrapper</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Cell__attribute__with__point" kindref="compound">CGAL::Cell_attribute_with_point</ref>&lt;<sp/>Refs,<sp/>int,<sp/><ref refid="group__PkgStlExtensionUtilities_1gab3e2296107b5d26c32c8183028a217f1" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Tag_true</ref>,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Average_functor<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vertex_attribute;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1cpp11_1_1tuple" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::tuple&lt;Vertex_attribute&gt;</ref><sp/>Attributes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Linear_cell_complex_traits</highlight></codeline>
<codeline><highlight class="normal">&lt;3,<sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref>&gt;<sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">CGAL::Linear_cell_complex_for_combinatorial_map&lt;3,3,Traits,Myitem&gt;</ref><sp/>LCC_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_3::Dart_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dart_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_3::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_3::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Dart_handle<sp/>make_iso_cuboid(LCC_3&amp;<sp/>lcc,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>basepoint,<sp/>FT<sp/>lg)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>lcc.make_hexahedron(basepoint,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits::Construct_translated_point()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(basepoint,Traits::Vector(lg,0,0)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits::Construct_translated_point()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(basepoint,Traits::Vector(lg,lg,0)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits::Construct_translated_point()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(basepoint,Traits::Vector(0,lg,0)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits::Construct_translated_point()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(basepoint,Traits::Vector(0,lg,lg)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits::Construct_translated_point()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(basepoint,Traits::Vector(0,0,lg)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits::Construct_translated_point()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(basepoint,Traits::Vector(lg,0,lg)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits::Construct_translated_point()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(basepoint,Traits::Vector(lg,lg,lg)));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC_3<sp/>lcc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>two<sp/>iso_cuboids.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d1<sp/>=<sp/>make_iso_cuboid(lcc,<sp/>Point(-2,<sp/>0,<sp/>0),<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d2<sp/>=<sp/>make_iso_cuboid(lcc,<sp/>Point(0,<sp/>0,<sp/>0),<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>the<sp/>&quot;color&quot;<sp/>of<sp/>all<sp/>vertices<sp/>of<sp/>the<sp/>first<sp/>cube<sp/>to<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(LCC_3::One_dart_per_incident_cell_range&lt;0,<sp/>3&gt;::iterator<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it=lcc.one_dart_per_incident_cell&lt;0,3&gt;(d1).begin(),<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend=lcc.one_dart_per_incident_cell&lt;0,3&gt;(d1).end();<sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>lcc.info&lt;0&gt;(it)=1;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>the<sp/>&quot;color&quot;<sp/>of<sp/>all<sp/>vertices<sp/>of<sp/>the<sp/>second<sp/>cube<sp/>to<sp/>19.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(LCC_3::One_dart_per_incident_cell_range&lt;0,<sp/>3&gt;::iterator<sp/>it=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lcc.one_dart_per_incident_cell&lt;0,3&gt;(d2).begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend=lcc.one_dart_per_incident_cell&lt;0,3&gt;(d2).end();<sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>lcc.info&lt;0&gt;(it)=19;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>3-Sew<sp/>the<sp/>two<sp/>cubes<sp/>along<sp/>one<sp/>facet.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.sew&lt;3&gt;(lcc.beta(d1,<sp/>1,<sp/>1,<sp/>2),<sp/>lcc.beta(d2,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Barycentric<sp/>triangulation<sp/>of<sp/>the<sp/>facet<sp/>between<sp/>the<sp/>two<sp/>cubes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d3=lcc.insert_barycenter_in_cell&lt;2&gt;(lcc.beta(d2,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>the<sp/>color<sp/>of<sp/>the<sp/>new<sp/>vertex<sp/>to<sp/>5.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.info&lt;0&gt;(d3)=5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Display<sp/>all<sp/>the<sp/>vertices<sp/>of<sp/>the<sp/>map.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(LCC_3::Vertex_attribute_range::iterator<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it=lcc.vertex_attributes().begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend=lcc.vertex_attributes().end();<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;point:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;lcc.point_of_vertex_attribute(it)&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;</highlight><highlight class="stringliteral">&quot;color:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;lcc.info_of_attribute&lt;0&gt;(it)&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The output is: <verbatim>point: -1 1 1, color: 10
point: -1 0 1, color: 10
point: -2 0 1, color: 1
point: -2 1 1, color: 1
point: -2 1 0, color: 1
point: -1 1 0, color: 10
point: -1 0 0, color: 10
point: -2 0 0, color: 1
point: 1 1 1, color: 19
point: 1 0 1, color: 19
point: -1 0.5 0.5, color: 5
point: 1 1 0, color: 19
point: 1 0 0, color: 19
</verbatim></para><para>Before applying the sew operation, the eight vertices of the first cube are colored by <computeroutput>1</computeroutput>, and the eight vertices of the second cube by <computeroutput>19</computeroutput>. After the sew operation, there are eight vertices which are merged two by two, and due to the average functor, the color of the four resulting vertices is now 10. Then we insert a vertex in the center of the common 2-cell between the two cubes. The coordinates of this vertex are initialized with the barycenter of the 2-cell (-1,0.5,0.5), and its color is not initialized by the method, thus we set its color manually by using the result of <ref refid="classLinearCellComplex_1aad0f09b94013ed62b09959b05a0a2212" kindref="member"><computeroutput>insert_barycenter_in_cell&lt;2&gt;</computeroutput></ref> which is a dart incident to the new vertex.</para></sect2>
<sect2 id="index_1Linear_cell_complexAutomaticAttributesManagement">
<title>Automatic Attribute Management</title>
<para><anchor id="index_1ssecAttributesManagement"/> The following example illustrates the use of the automatic attributes management for a linear cell complex. An off file is loaded into a 2D linear cell complex embedded in 3D. Then, a certain percentage of edges is removed from the linear cell complex. The same method is applied twice: the first time by using the automatic attributes management (which is the default behaviour) and the second time by calling first <ref refid="classGenericMap_1af7fcbe383d43efece8525654b45741bf" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>set_automatic_attributes_management(false)</computeroutput></ref> to disable the automatic updating of attributes.</para><para>We can observe that the second run is faster than the first one. Indeed, updating attribute for each edge removal give a bigger complexity. Moreover, the gain increases when the percentage of removed edges increases.</para><para><linebreak/>
<bold>File</bold> <ref refid="Linear_cell_complex_2linear_cell_complex_3_attributes_management_8cpp-example" kindref="compound">Linear_cell_complex/linear_cell_complex_3_attributes_management.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_constructors.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">CGAL::Linear_cell_complex_for_combinatorial_map&lt;2,3&gt;</ref><sp/>LCC_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_3::Dart_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dart_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_3::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC_3::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>load_and_simplify_off(LCC_3&amp;<sp/>lcc,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>filename,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>updateattribs,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>percent)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>ifile(filename.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ifile)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::load_off(lcc,<sp/>ifile);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::Timer<sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Dart_handle<sp/>dh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::size_t<sp/>nb=(lcc.number_of_darts()*percent)/200;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>timer.start();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!updateattribs)<sp/>lcc.set_automatic_attributes_management(</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(LCC_3::Dart_range::iterator<sp/>it=lcc.darts().begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend=lcc.darts().end();<sp/>it!=itend<sp/>&amp;&amp;<sp/>nb&gt;0;<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dh=it++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>it!=itend<sp/>&amp;&amp;<sp/>it==lcc.beta&lt;2&gt;(dh)<sp/>)<sp/>++it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>lcc.remove_cell&lt;1&gt;(dh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>--nb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!updateattribs<sp/>)<sp/>lcc.set_automatic_attributes_management(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>timer.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lcc.display_characteristics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>lcc.is_valid()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>time:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;timer.time()&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>seconds.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>narg,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(narg&gt;1<sp/>&amp;&amp;<sp/>(!strcmp(argv[1],</highlight><highlight class="stringliteral">&quot;-h&quot;</highlight><highlight class="normal">)<sp/>||<sp/>!strcmp(argv[1],</highlight><highlight class="stringliteral">&quot;-?&quot;</highlight><highlight class="normal">))<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Usage:<sp/>a.out<sp/>file.off<sp/>[percentage]&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>narg==1<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>filename=std::string(</highlight><highlight class="stringliteral">&quot;data/armadillo.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;No<sp/>filename<sp/>given:<sp/>use<sp/>data/armadillo.off<sp/>by<sp/>default.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>filename=std::string(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>percent<sp/>=<sp/>30;<sp/></highlight><highlight class="comment">//<sp/>remove<sp/>30<sp/>percent<sp/>of<sp/>edges</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>narg&gt;2<sp/>)<sp/>{<sp/>percent<sp/>=<sp/>atoi(argv[2]);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;percent&lt;&lt;</highlight><highlight class="stringliteral">&quot;%<sp/>edges<sp/>to<sp/>remove.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC_3<sp/>lcc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Update<sp/>attribute<sp/>DURING<sp/>operations:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>load_and_simplify_off(lcc,<sp/>filename,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>percent);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC_3<sp/>lcc2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Update<sp/>attribute<sp/>AFTER<sp/>operations:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>load_and_simplify_off(lcc2,<sp/>filename,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/>percent);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Linear_cell_complexDraw">
<title>Draw a Linear Cell Complex</title>
<para><anchor id="index_1ssecDrawLCC"/> A linear cell complex can be visualized by calling the <computeroutput><ref refid="group__PkgDrawPolyhedron_1ga3ca458ed11c9fb052476b00227d93584" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">CGAL::draw()</ref></computeroutput> function as shown in the following example. This function opens a new window showing the given linear cell complex. The function is blocking, that is the program continues as soon as the user closes the window.</para><para><linebreak/>
<bold>File</bold> <ref refid="Linear_cell_complex_2draw_linear_cell_complex_8cpp-example" kindref="compound">Linear_cell_complex/draw_linear_cell_complex.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_linear_cell_complex.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound">CGAL::Linear_cell_complex_for_combinatorial_map&lt;3&gt;</ref><sp/>LCC;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC::Dart_handle<sp/>Dart_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LCC::Point<sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC<sp/>lcc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>dh1=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lcc.make_hexahedron(Point(0,0,0),<sp/>Point(5,0,0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(5,5,0),<sp/>Point(0,5,0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(0,5,4),<sp/>Point(0,0,4),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(5,0,4),<sp/>Point(5,5,4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>dh2=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lcc.make_hexahedron(Point(5,0,0),<sp/>Point(10,0,0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(10,5,0),<sp/>Point(5,5,0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(5,5,4),<sp/>Point(5,0,4),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(10,0,4),<sp/>Point(10,5,4));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.sew&lt;3&gt;(lcc.beta(dh1,<sp/>1,<sp/>1,<sp/>2),<sp/>lcc.beta(dh2,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcc.display_characteristics(std::cout)&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgDrawPolyhedron_1ga3ca458ed11c9fb052476b00227d93584" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">CGAL::draw</ref>(lcc);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This function requires CGAL_Qt5, and is only available if the flag CGAL_USE_BASIC_VIEWER is defined at compile time.</para><para><anchor id="index_1fig__fig_draw_lcc"/><image type="html" name="draw_lcc.png"></image>
 <image type="latex" name="draw_lcc.png" width="15cm"></image>
  <ref refid="index_1fig__fig_draw_lcc" kindref="member">fig__fig_draw_lcc</ref> Result of the run of the draw_linear_cell_complex program. A window shows two 3D cubes and allows to navigate through the 3D scene.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1Linear_cell_complexDesign">
<title>Design and Implementation History</title>
<para>This package was developed by Guillaume Damiand, with the help of Andreas Fabri, S<eacute/>bastien Loriot and Laurent Rineau. Monique Teillaud and Bernd G<aumlaut/>rtner contributed to the manual. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
