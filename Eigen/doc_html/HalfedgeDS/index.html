<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/HalfedgeDS/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Halfedge Data Structures: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Halfedge Data Structures
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Halfedge_Data_Structures"></a><a class="anchor" id="chapterHalfedgeDS"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Lutz Kettner</dd></dl>
<h1><a class="anchor" id="HalfedgeDSIntroduction"></a>
Introduction</h1>
<p>A halfedge data structure (abbreviated as <code><a class="el" href="classHalfedgeDS.html" title="The concept of a halfedge data structure (abbreviated as HalfedgeDS, or HDS for template parameters) ...">HalfedgeDS</a></code>, or <code>HDS</code> for template parameters) is an edge-centered data structure capable of maintaining incidence information of vertices, edges and faces, for example for planar maps, polyhedra, or other orientable, two-dimensional surfaces embedded in arbitrary dimension. Each edge is decomposed into two halfedges with opposite orientations. One incident face and one incident vertex are stored in each halfedge. For each face and each vertex, one incident halfedge is stored. Reduced variants of the halfedge data structure can omit some of these information, for example the halfedge pointers in faces or the storage of faces at all.</p>
<div class="image">
<img src="halfedge_small.png" alt="halfedge_small.png" />
</div>
 <p>The halfedge data structure is a combinatorial data structure, geometric interpretation is added by classes built on top of the halfedge data structure. These classes might be more convenient to use than the halfedge data structure directly, since the halfedge data structure is meant as an implementation layer. See for example the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> class in Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/index.html#chapterPolyhedron">Polyhedral Surface</a>.</p>
<p>The data structure provided here is also known as the FE-structure <a class="el" href="citelist.html#CITEREF_w-ebdss-85">[9]</a>, as halfedges <a class="el" href="citelist.html#CITEREF_m-ism-88">[6]</a>, <a class="el" href="citelist.html#CITEREF_cgal:bfh-mgedm-95">[2]</a> or as the doubly connected edge list (DCEL) <a class="el" href="citelist.html#CITEREF_bkos-cgaa-97">[3]</a>, although the original reference for the DCEL <a class="el" href="citelist.html#CITEREF_mp-fitcp-78">[7]</a> describes a different data structure. The halfedge data structure can also be seen as one of the variants of the quad-edge data structure <a class="el" href="citelist.html#CITEREF_gs-pmgsc-85">[4]</a>. In general, the quad-edge data can represent non-orientable 2-manifolds, but the variant here is restricted to orientable 2-manifolds only. An overview and comparison of these different data structures together with a thorough description of the design implemented here can be found in <a class="el" href="citelist.html#CITEREF_k-ugpdd-99">[5]</a>.</p>
<h1><a class="anchor" id="HalfedgeDSSoftware"></a>
Software Design</h1>
<p><a class="anchor" id="fig__figureHalfedgeDSDesign"></a></p><div class="image">
<img src="hds_design_col.png" alt="hds_design_col.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figureHalfedgeDSDesign">Figure 26.1</a> Responsibilities of the different layers in the halfedge data-structure design.  </div>  <br />

<p><a class="el" href="index.html#fig__figureHalfedgeDSDesign">Figure 26.1</a> illustrates the responsibilities of the three layers of the software design, with the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> as an example for the top layer. The items provide the space for the information that is actually stored, i.e., with member variables and access member functions in <code>Vertex</code>, <code>Halfedge</code>, and <code>Face</code> respectively. Halfedges are required to provide a reference to the next halfedge and to the opposite halfedge. Optionally they may provide a reference to the previous halfedge, to the incident vertex, and to the incident face. Vertices and faces may be empty. Optionally they may provide a reference to the incident halfedge. The options mentioned are supported in the halfedge data structure and the polyhedron, for example, Euler operations update the optional references if they are present. Furthermore, the item classes can be extended with arbitrary attributes and member functions, which will be promoted by inheritance to the actual classes used for the polyhedron.</p>
<p>Vertices, halfedges, and faces are passed as local types of the <code>Items</code> class to the halfedge data structure and polyhedron. Implementations for vertices, halfedges and faces are provided that fulfill the mandatory part of the requirements. They can be used as base classes for extensions by the user. Richer implementations are also provided to serve as defaults; for polyhedra they provide all optional incidences, a three-dimensional point in the vertex type and a plane equation in the face type.</p>
<p>The Halfedge data structure concept <code><a class="el" href="classHalfedgeDS.html" title="The concept of a halfedge data structure (abbreviated as HalfedgeDS, or HDS for template parameters) ...">HalfedgeDS</a></code>, is responsible for the storage organization of the items. Currently, implementations using internally a bidirectional list or a vector are provided. The <code><a class="el" href="classHalfedgeDS.html" title="The concept of a halfedge data structure (abbreviated as HalfedgeDS, or HDS for template parameters) ...">HalfedgeDS</a></code> defines the handles and iterators belonging to the items. These types are promoted to the declaration of the items themselves and are used there to provide the references to the incident items. This promotion of types is done with a template parameter <code>Refs</code> of the item types. The halfedge data structure provides member functions to insert and delete items, to traverse all items, and it gives access to the items.</p>
<p>There are two different models for the <code><a class="el" href="classHalfedgeDS.html" title="The concept of a halfedge data structure (abbreviated as HalfedgeDS, or HDS for template parameters) ...">HalfedgeDS</a></code> concept available, <code><a class="el" href="classCGAL_1_1HalfedgeDS__list.html" title="The class HalfedgeDS_list is a model for the HalfedgeDS concept. ">HalfedgeDS_list</a></code> and <code><a class="el" href="classCGAL_1_1HalfedgeDS__vector.html" title="The class HalfedgeDS_vector is a model for the HalfedgeDS concept. ">HalfedgeDS_vector</a></code>, and more might come. Therefore we have kept their interface small and factored out common functionality into separate helper classes, <code><a class="el" href="classCGAL_1_1HalfedgeDS__decorator.html" title="The class CGAL::HalfedgeDS_items_decorator&lt;HDS&gt; provides additional functions for vertices...">HalfedgeDS_decorator</a></code>, <code><a class="el" href="classCGAL_1_1HalfedgeDS__const__decorator.html" title="The class CGAL::HalfedgeDS_items_decorator&lt;HDS&gt; provides additional functions for vertices...">HalfedgeDS_const_decorator</a></code>, and <code><a class="el" href="classCGAL_1_1HalfedgeDS__items__decorator.html" title="The class CGAL::HalfedgeDS_items_decorator&lt;HDS&gt; provides additional functions for vertices...">HalfedgeDS_items_decorator</a></code>, which are not shown in <a class="el" href="index.html#fig__figureHalfedgeDSDesign">Figure 26.1</a>, but would be placed at the side of the <code><a class="el" href="classHalfedgeDS.html" title="The concept of a halfedge data structure (abbreviated as HalfedgeDS, or HDS for template parameters) ...">HalfedgeDS</a></code> since they broaden that interface but do not hide it. These helper classes contain operations that are useful to implement the operations in the next layer, for example, the polyhedron. They add, for example, the Euler operations and partial operations from which further Euler operations can be built, such as inserting an edge into the ring of edges at a vertex. Furthermore, the helper classes contain adaptive functionality. For example, if the <code><a class="el" href="classHalfedgeDSHalfedge.html#a573e835d92f393029fd6e5b8f9023a27">HalfedgeDSHalfedge::prev()</a></code> member function is not provided for halfedges, the <code><a class="el" href="classCGAL_1_1HalfedgeDS__items__decorator.html#a0a7ded78b72adb3cd3611e4ebdb6af4c" title="returns the previous halfedge of h. ">HalfedgeDS_items_decorator::find_prev()</a></code> member function of a helper class searches in the positive direction along the face for the previous halfedge. But if the <code><a class="el" href="classHalfedgeDSHalfedge.html#a573e835d92f393029fd6e5b8f9023a27">HalfedgeDSHalfedge::prev()</a></code> member function is provided, the <code><a class="el" href="classCGAL_1_1HalfedgeDS__items__decorator.html#a0a7ded78b72adb3cd3611e4ebdb6af4c" title="returns the previous halfedge of h. ">HalfedgeDS_items_decorator::find_prev()</a></code> member function simply calls it. This distinction is resolved at compile time with a technique called <em>compile-time tags</em>, similar to iterator tags in <a class="el" href="citelist.html#CITEREF_cgal:sl-stl-95">[8]</a>.</p>
<p>The <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> as an example for the third layer adds the geometric interpretation, provides an easy-to-use interface of high-level functions, and unifies the access to the flexibility provided underneath. It renames face to facet, which is more common for three-dimensional surfaces. The interface is designed to protect the integrity of the internal representation, the handles stored in the items can no longer directly be written by the user. The polyhedron adds the convenient and efficient circulators, see <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/classCirculator.html">Circulator</a></code>, for accessing the circular sequence of edges around a vertex or around a facet. To achieve this, the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> derives new vertices, halfedges and facets from those provided in <code>Items</code>. These new items are those actually used in the <code><a class="el" href="classHalfedgeDS.html" title="The concept of a halfedge data structure (abbreviated as HalfedgeDS, or HDS for template parameters) ...">HalfedgeDS</a></code>, which gives us the coherent type structure in this design, especially if compared to our previous design.</p>
<h1><a class="anchor" id="HalfedgeDSExample"></a>
Example Programs</h1>
<p><a class="anchor" id="sectionHdsExamples"></a> </p>
<h2><a class="anchor" id="HalfedgeDSTheDefaultHalfedgeDataStructure"></a>
The Default Halfedge Data Structure</h2>
<p>The following example program uses the default halfedge data structure and the decorator class. The default halfedge data structure uses a list-based representation. All incidences of the items and a point type for vertices are defined. The trivial traits class provides the type used for the point. The program creates a loop, consisting of two halfedges, one vertex and two faces, and checks its validity.</p>
<div class="image">
<img src="loop.png" alt="loop.png" />
</div>
 <p><br />
<b>File</b> <a class="el" href="HalfedgeDS_2hds_prog_default_8cpp-example.html">HalfedgeDS/hds_prog_default.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_default.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_decorator.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Traits { <span class="keyword">typedef</span> <span class="keywordtype">int</span> Point_2; };</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__default.html">CGAL::HalfedgeDS_default&lt;Traits&gt;</a> HDS;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__decorator.html">CGAL::HalfedgeDS_decorator&lt;HDS&gt;</a> Decorator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    HDS hds;</div><div class="line">    Decorator decorator(hds);</div><div class="line">    decorator.create_loop();</div><div class="line">    CGAL_assertion( decorator.is_valid());</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="HalfedgeDSAMinimalHalfedgeDataStructure"></a>
A Minimal Halfedge Data Structure</h2>
<p>The following program defines a minimal halfedge data structure using the minimal items class <code><a class="el" href="classCGAL_1_1HalfedgeDS__min__items.html" title="The class HalfedgeDS_min_items is a model of the HalfedgeDSItems concept. ">HalfedgeDS_min_items</a></code> and a list-based halfedge data structure. The result is a data structure maintaining only halfedges with next and opposite pointers. No vertices or faces are stored. The data structure represents an <em>undirected graph</em>.</p>
<p><br />
<b>File</b> <a class="el" href="HalfedgeDS_2hds_prog_graph_8cpp-example.html">HalfedgeDS/hds_prog_graph.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_min_items.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_default.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_decorator.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// no traits needed, argument can be arbitrary dummy.</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__default.html">CGAL::HalfedgeDS_default&lt;int, CGAL::HalfedgeDS_min_items&gt;</a> HDS;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__decorator.html">CGAL::HalfedgeDS_decorator&lt;HDS&gt;</a>  Decorator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    HDS hds;</div><div class="line">    Decorator decorator(hds);</div><div class="line">    decorator.create_loop();</div><div class="line">    CGAL_assertion( decorator.is_valid());</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="HalfedgeDSTheDefaultwithaVectorInsteadof"></a>
The Default with a Vector Instead of a List</h2>
<p>The default halfedge data structure uses a list internally and the maximal base classes. We change the list to a vector representation here. Again, a trivial traits class provides the type used for the point. Note that for the vector storage the size of the halfedge data structure should be reserved beforehand, either with the constructor as shown in the example or with the <code>reserve()</code> member function. One can later resize the data structure with further calls to the <code>reserve()</code> member function, but only if the data structure is in a consistent, i.e., <em>valid</em>, state.</p>
<p><br />
<b>File</b> <a class="el" href="HalfedgeDS_2hds_prog_vector_8cpp-example.html">HalfedgeDS/hds_prog_vector.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_items_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_decorator.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Traits { <span class="keyword">typedef</span> <span class="keywordtype">int</span> Point_2; };</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__vector.html">CGAL::HalfedgeDS_vector&lt; Traits, CGAL::HalfedgeDS_items_2&gt;</a> HDS;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__decorator.html">CGAL::HalfedgeDS_decorator&lt;HDS&gt;</a>  Decorator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    HDS hds(1,2,2);</div><div class="line">    Decorator decorator(hds);</div><div class="line">    decorator.create_loop();</div><div class="line">    CGAL_assertion( decorator.is_valid());</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="HalfedgeDSExampleAddingColortoFaces"></a>
Example Adding Color to Faces</h2>
<p>This example re-uses the base class available for faces and adds a member variable <code>color</code>.</p>
<p><br />
<b>File</b> <a class="el" href="HalfedgeDS_2hds_prog_color_8cpp-example.html">HalfedgeDS/hds_prog_color.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_items_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_default.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Color.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// A face type with a color member variable.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Refs&gt;</div><div class="line"><span class="keyword">struct </span>My_face : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1HalfedgeDS__face__base.html">CGAL::HalfedgeDS_face_base</a>&lt;Refs&gt; {</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Color.html">CGAL::Color</a> color;</div><div class="line">    My_face() {}</div><div class="line">    My_face( <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Color.html">CGAL::Color</a> c) : color(c) {}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// An items type using my face.</span></div><div class="line"><span class="keyword">struct </span>My_items : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1HalfedgeDS__items__2.html">CGAL::HalfedgeDS_items_2</a> {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Refs, <span class="keyword">class</span> Traits&gt;</div><div class="line">    <span class="keyword">struct </span>Face_wrapper {</div><div class="line">        <span class="keyword">typedef</span> My_face&lt;Refs&gt; Face;</div><div class="line">    };</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>My_traits { <span class="comment">// arbitrary point type, not used here.</span></div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">int</span>  Point_2;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__default.html">CGAL::HalfedgeDS_default&lt;My_traits, My_items&gt;</a> HDS;</div><div class="line"><span class="keyword">typedef</span> HDS::Face                                     Face;</div><div class="line"><span class="keyword">typedef</span> HDS::Face_handle                              Face_handle;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    HDS hds;</div><div class="line">    Face_handle f = hds.faces_push_back( Face( CGAL::RED));</div><div class="line">    f-&gt;color = CGAL::BLUE;</div><div class="line">    CGAL_assertion( f-&gt;color == CGAL::BLUE);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="HalfedgeDSExampleDefiningaMoreCompactHalfedge"></a>
Example Defining a More Compact Halfedge</h2>
<p>The halfedge data structure as presented here is slightly less space efficient as, for example, the winged-edge data structure <a class="el" href="citelist.html#CITEREF_b-prcv-75">[1]</a>, the DCEL <a class="el" href="citelist.html#CITEREF_mp-fitcp-78">[7]</a> or variants of the quad-edge data structure <a class="el" href="citelist.html#CITEREF_gs-pmgsc-85">[4]</a>. On the other hand, it does not require any search operations during traversals. A comparison can be found in <a class="el" href="citelist.html#CITEREF_k-ugpdd-99">[5]</a>.</p>
<p>The following example trades traversal time for a compact storage representation using traditional C techniques (i.e., type casting and the assumption that pointers, especially those from <code>malloc</code> or <code>new</code>, point to even addresses). The idea goes as follows: The halfedge data structure allocates halfedges pairwise. Concerning the vector-based data structure this implies that the absolute value of the difference between a halfedge and its opposite halfedge is always one with respect to C pointer arithmetic. We can replace the opposite pointer by a single bit encoding the sign of this difference. We will store this bit as the least significant bit in the next halfedge handle. Furthermore, we do not implement a pointer to the previous halfedge. What remains are three pointers per halfedge.</p>
<p>We use the static member function <code><a class="el" href="classHalfedgeDS.html#a962b391c741016fa5d8aa7d0168c6b56">HalfedgeDS::halfedge_handle()</a></code> to convert from pointers to halfedge handles. The same solution can be applied to the list-based halfedge data structure <code><a class="el" href="classCGAL_1_1HalfedgeDS__list.html" title="The class HalfedgeDS_list is a model for the HalfedgeDS concept. ">HalfedgeDS_list</a></code>, see <code>examples/HalfedgeDS/hds_prog_compact2.cpp</code>. Here is the example for the vector-based data structure.</p>
<p><br />
<b>File</b> <a class="el" href="HalfedgeDS_2hds_prog_compact_8cpp-example.html">HalfedgeDS/hds_prog_compact.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_items_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_decorator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstddef&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a new halfedge class. We assume that the Halfedge_handle can</span></div><div class="line"><span class="comment">// be created from a pointer (e.g. the HalfedgeDS is based here on the</span></div><div class="line"><span class="comment">// In_place_list or a std::vector with such property) and that halfedges</span></div><div class="line"><span class="comment">// are allocated in pairs. We encode the opposite pointer in a single bit,</span></div><div class="line"><span class="comment">// which is stored in the lower bit of the next-pointer. We use the</span></div><div class="line"><span class="comment">// static member function HDS::halfedge_handle to translate pointer to</span></div><div class="line"><span class="comment">// handles.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Refs&gt;</div><div class="line"><span class="keyword">class </span>My_halfedge {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> Refs                                 HDS;</div><div class="line">    <span class="keyword">typedef</span> My_halfedge&lt;Refs&gt;                    Base_base;</div><div class="line">    <span class="keyword">typedef</span> My_halfedge&lt;Refs&gt;                    Base;</div><div class="line">    <span class="keyword">typedef</span> My_halfedge&lt;Refs&gt;                    Self;</div><div class="line">    <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Boolean__tag.html">CGAL::Tag_false</a>                      Supports_halfedge_prev;</div><div class="line">    <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Boolean__tag.html">CGAL::Tag_true</a>                       Supports_halfedge_vertex;</div><div class="line">    <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Boolean__tag.html">CGAL::Tag_true</a>                       Supports_halfedge_face;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Refs::Vertex_handle         Vertex_handle;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Refs::Vertex_const_handle   Vertex_const_handle;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Refs::Halfedge              Halfedge;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Refs::Halfedge_handle       Halfedge_handle;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Refs::Halfedge_const_handle Halfedge_const_handle;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Refs::Face_handle           Face_handle;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Refs::Face_const_handle     Face_const_handle;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::ptrdiff_t  nxt;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    My_halfedge() : nxt(0), f( Face_handle()) {}</div><div class="line"></div><div class="line">    Halfedge_handle <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>() {</div><div class="line">        <span class="comment">// Halfedge could be different from My_halfedge (e.g. pointer for</span></div><div class="line">        <span class="comment">// linked list). Get proper handle from 'this' pointer first, do</span></div><div class="line">        <span class="comment">// pointer arithmetic, then convert pointer back to handle again.</span></div><div class="line">        Halfedge_handle h = HDS::halfedge_handle(<span class="keyword">this</span>); <span class="comment">// proper handle</span></div><div class="line">        <span class="keywordflow">if</span> ( nxt &amp; 1)</div><div class="line">            <span class="keywordflow">return</span> HDS::halfedge_handle( &amp;* h + 1);</div><div class="line">        <span class="keywordflow">return</span> HDS::halfedge_handle( &amp;* h - 1);</div><div class="line">    }</div><div class="line">    Halfedge_const_handle <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>()<span class="keyword"> const </span>{ <span class="comment">// same as above</span></div><div class="line">        Halfedge_const_handle h = HDS::halfedge_handle(<span class="keyword">this</span>); <span class="comment">// proper handle</span></div><div class="line">        <span class="keywordflow">if</span> ( nxt &amp; 1)</div><div class="line">            <span class="keywordflow">return</span> HDS::halfedge_handle( &amp;* h + 1);</div><div class="line">        <span class="keywordflow">return</span> HDS::halfedge_handle( &amp;* h - 1);</div><div class="line">    }</div><div class="line">    Halfedge_handle <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">next</a>() {</div><div class="line">        <span class="keywordflow">return</span> HDS::halfedge_handle((Halfedge*)(nxt &amp; (~ std::ptrdiff_t(1))));</div><div class="line">    }</div><div class="line">    Halfedge_const_handle <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">next</a>()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> HDS::halfedge_handle((<span class="keyword">const</span> Halfedge*)</div><div class="line">                                    (nxt &amp; (~ std::ptrdiff_t(1))));</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span>  set_opposite( Halfedge_handle h) {</div><div class="line">        CGAL_precondition(( &amp;* h - 1 == &amp;* HDS::halfedge_handle(<span class="keyword">this</span>)) ||</div><div class="line">                          ( &amp;* h + 1 == &amp;* HDS::halfedge_handle(<span class="keyword">this</span>)));</div><div class="line">        <span class="keywordflow">if</span> ( &amp;* h - 1 == &amp;* HDS::halfedge_handle(<span class="keyword">this</span>))</div><div class="line">            nxt |= 1;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            nxt &amp;= (~ std::ptrdiff_t(1));</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span>  set_next( Halfedge_handle h) {</div><div class="line">        CGAL_precondition( ((std::ptrdiff_t)(&amp;*h) &amp; 1) == 0);</div><div class="line">        nxt = ((std::ptrdiff_t)(&amp;*h)) | (nxt &amp; 1);</div><div class="line">    }</div><div class="line"><span class="keyword">private</span>:    <span class="comment">// Support for the Vertex_handle.</span></div><div class="line">    Vertex_handle    v;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// the incident vertex.</span></div><div class="line">    Vertex_handle         vertex()                     { <span class="keywordflow">return</span> v; }</div><div class="line">    Vertex_const_handle   vertex()<span class="keyword"> const               </span>{ <span class="keywordflow">return</span> v; }</div><div class="line">    <span class="keywordtype">void</span>                  set_vertex( Vertex_handle w) { v = w; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Face_handle      f;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Face_handle           face()                       { <span class="keywordflow">return</span> f; }</div><div class="line">    Face_const_handle     face()<span class="keyword"> const                 </span>{ <span class="keywordflow">return</span> f; }</div><div class="line">    <span class="keywordtype">void</span>                  set_face( Face_handle g)     { f = g; }</div><div class="line">    <span class="keywordtype">bool</span>                  is_border()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> f == Face_handle(); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Replace halfedge in the default items type.</span></div><div class="line"><span class="keyword">struct </span>My_items : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1HalfedgeDS__items__2.html">CGAL::HalfedgeDS_items_2</a> {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Refs, <span class="keyword">class</span> Traits&gt;</div><div class="line">    <span class="keyword">struct </span>Halfedge_wrapper {</div><div class="line">        <span class="keyword">typedef</span> My_halfedge&lt;Refs&gt; Halfedge;</div><div class="line">    };</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Traits { <span class="keyword">typedef</span> <span class="keywordtype">int</span> Point_2; };</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__vector.html">CGAL::HalfedgeDS_vector&lt;Traits, My_items&gt;</a> HDS;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__decorator.html">CGAL::HalfedgeDS_decorator&lt;HDS&gt;</a>  Decorator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    HDS hds(1,2,2);</div><div class="line">    Decorator decorator(hds);</div><div class="line">    decorator.create_loop();</div><div class="line">    CGAL_assertion( decorator.is_valid());</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="HalfedgeDSExampleUsingtheHalfedgeIterator"></a>
Example Using the Halfedge Iterator</h2>
<p>Two edges are created in the default halfedge data structure. The halfedge iterator is used to count the halfedges.</p>
<p><br />
<b>File</b> <a class="el" href="HalfedgeDS_2hds_prog_halfedge_iterator_8cpp-example.html">HalfedgeDS/hds_prog_halfedge_iterator.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_default.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_decorator.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Traits { <span class="keyword">typedef</span> <span class="keywordtype">int</span> Point_2; };</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__default.html">CGAL::HalfedgeDS_default&lt;Traits&gt;</a> HDS;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__decorator.html">CGAL::HalfedgeDS_decorator&lt;HDS&gt;</a>  Decorator;</div><div class="line"><span class="keyword">typedef</span> HDS::Halfedge_iterator           <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classIterator.html">Iterator</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    HDS hds;</div><div class="line">    Decorator decorator(hds);</div><div class="line">    decorator.create_loop();</div><div class="line">    decorator.create_segment();</div><div class="line">    CGAL_assertion( decorator.is_valid());</div><div class="line">    <span class="keywordtype">int</span> n = 0;</div><div class="line">    <span class="keywordflow">for</span> ( Iterator i = hds.halfedges_begin(); i != hds.halfedges_end(); ++i )</div><div class="line">        ++n;</div><div class="line">    CGAL_assertion( n == 4);  <span class="comment">// == 2 edges</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="HalfedgeDSExampleforanAdaptertoBuildanEdge"></a>
Example for an Adapter to Build an Edge Iterator</h2>
<p>Three edges are created in the default halfedge data structure. The adapter <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1N__step__adaptor.html">N_step_adaptor</a></code> is used to declare the edge iterator used in counting the edges.</p>
<p><br />
<b>File</b> <a class="el" href="HalfedgeDS_2hds_prog_edge_iterator_8cpp-example.html">HalfedgeDS/hds_prog_edge_iterator.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_default.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_decorator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/N_step_adaptor.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Traits { <span class="keyword">typedef</span> <span class="keywordtype">int</span> Point_2; };</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__default.html">CGAL::HalfedgeDS_default&lt;Traits&gt;</a>            HDS;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1HalfedgeDS__decorator.html">CGAL::HalfedgeDS_decorator&lt;HDS&gt;</a>             Decorator;</div><div class="line"><span class="keyword">typedef</span> HDS::Halfedge_iterator                      Halfedge_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1N__step__adaptor.html">CGAL::N_step_adaptor&lt; Halfedge_iterator, 2&gt;</a> Iterator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    HDS hds;</div><div class="line">    Decorator decorator(hds);</div><div class="line">    decorator.create_loop();</div><div class="line">    decorator.create_segment();</div><div class="line">    CGAL_assertion( decorator.is_valid());</div><div class="line">    <span class="keywordtype">int</span> n = 0;</div><div class="line">    <span class="keywordflow">for</span> ( Iterator e = hds.halfedges_begin(); e != hds.halfedges_end(); ++e)</div><div class="line">        ++n;</div><div class="line">    CGAL_assertion( n == 2);  <span class="comment">// == 2 edges</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:58 for CGAL 4.13 - Halfedge Data Structures by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
