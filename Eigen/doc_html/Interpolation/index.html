<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Interpolation/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D and Surface Function Interpolation: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D and Surface Function Interpolation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_and_Surface_Function_Interpolation"></a><a class="anchor" id="chapinterpolation"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Julia Fl√∂totto</dd></dl>
<p>This package implements various neighbor coordinate computation functions as well as different methods for scattered data interpolation. Computation of natural and regular neighbor coordinates in 2D Euclidean space is described in Section <a class="el" href="index.html#seccoordinates">Natural Neighbor Coordinates</a>. Coordinate and neighbor computations on surfaces are discussed in Section <a class="el" href="index.html#secsurface">Surface Natural Neighbor Coordinates and Surface Neighbors</a>. Finally, we describe the different interpolation methods offered by this package in Section <a class="el" href="index.html#secinterpolation">Interpolation Methods</a>.</p>
<p>Scattered data interpolation solves the following problem: given measures of a function on a set of discrete data points, how to interpolate this function at an arbitrary query point. More formally, let \( \mathcal{P}=\{\mathbf{p_1},\ldots ,\mathbf{p_n}\}\) be a set of \( n\) points in \( \mathbb{R}^2\) or \( \mathbb{R}^3\) and \( \Phi\) be a scalar function defined on the convex hull of \( \mathcal{P}\). We assume that the function values are known at the points of \( \mathcal{P}\), i.e. to each \( \mathbf{p_i} \in \mathcal{P}\), we associate \( z_i = \Phi(\mathbf{p_i})\). Knowledge of the gradient of \( \Phi\) at \( \mathbf{p_i}\) is also sometimes required. It is then denoted \( \mathbf{g_i}= \nabla \Phi(\mathbf{p_i})\). The interpolation is carried out at an arbitrary query point \( \mathbf{x}\) on the convex hull of \( \mathcal{P}\).</p>
<h1><a class="anchor" id="seccoordinates"></a>
Natural Neighbor Coordinates</h1>
<p>Most interpolation methods offered by this package rely on 2D natural and regular neighbor coordinates, which we describe in this section.</p>
<h2><a class="anchor" id="InterpolationIntroduction"></a>
Introduction</h2>
<p>Natural neighbor interpolation was introduced by Sibson <a class="el" href="citelist.html#CITEREF_s-bdnni-81">[9]</a> to interpolate multivariate scattered data. Given a set of data points \( \mathcal{P}\), the natural neighbor coordinates associated to \( \mathcal{P}\) are defined from the Voronoi diagram of \( \mathcal{P}\). When simulating the insertion of a query point \( \mathbf{x}\) into the Voronoi diagram of \( \mathcal{P}\), the potential Voronoi cell of \( \mathbf{x}\) "steals" some parts from neighboring existing cells.</p>
<p><a class="anchor" id="fig__fignn_coords"></a></p><div class="image">
<object type="image/svg+xml" data="nn_coords.svg">nn_coords.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fignn_coords">Figure 87.1</a> 2D example: \( \mathbf{x}\) has five natural neighbors \( \mathbf{p_1},\ldots, \mathbf{p_5}\). The natural neighbor coordinate \( \lambda_3(\mathbf{x})\) is the ratio of the area of the purple polygon, \( \pi_3(\mathbf{x})\), over the area of the total highlighted zone.  </div>  <br />

<p>Let \( \pi(\mathbf{x})\) denote the volume of the potential Voronoi cell of \( \mathbf{x}\) and \( \pi_i(\mathbf{x})\) denote the volume of the sub-cell that would be stolen from the cell of \( \mathbf{p_i}\) by the cell of \( \mathbf{x}\). The natural neighbor coordinate of \( \mathbf{x}\) with respect to the data point \( \mathbf{p_i}\in \mathcal{P}\) is defined by </p><p class="formulaDsp">
\[ \lambda_i(\mathbf{x}) = \frac{\pi_i(\mathbf{x})}{\pi(\mathbf{x})}. \]
</p>
<p> A two-dimensional example is depicted in <a class="el" href="index.html#fig__fignn_coords">Figure 87.1</a>.</p>
<p>Various papers (<a class="el" href="citelist.html#CITEREF_b-scaps-97">[3]</a>, <a class="el" href="citelist.html#CITEREF_f-sodt-90">[4]</a>, <a class="el" href="citelist.html#CITEREF_hs-vbihc-00">[6]</a>, <a class="el" href="citelist.html#CITEREF_cgal:p-plcbd-93">[7]</a>, <a class="el" href="citelist.html#CITEREF_s-vidt-80">[8]</a>) show that the natural neighbor coordinates exhibit the following properties:</p><ul>
<li>\( \mathbf{x} = \sum_{i=1}^n \lambda_i(\mathbf{x}) \mathbf{p_i}\) (barycentric coordinate property).</li>
<li>For any \( i,j \leq n, \lambda_i(\mathbf{p_j}) = \delta_{ij}\), where \( \delta_{ij}\) is the Kronecker symbol.</li>
<li>\( \sum_{i=1}^n \lambda_i(\mathbf{x}) = 1\) (partition of unity property).</li>
</ul>
<p>When the query point x is located on the envelope of the convex hull of \( \mathcal{P}\), the potential Voronoi cell of x becomes infinite and:</p><ul>
<li>\( \pi(\mathbf{x}) = \infty\)</li>
<li>\( \lambda_i(\mathbf{x}) = 0 \), for all data point \( \mathbf{p_i}\) of \( \mathcal{P}\) except for the two endpoints ‚Äì say \( \mathbf{p}\) and \( \mathbf{q}\) ‚Äì of the edge where \( x\) lies.</li>
</ul>
<p>The natural neighbor coordinate of \( \mathbf{x}\) with respect to these endpoints \( \mathbf{p}\) and \( \mathbf{q}\) will be:</p><ul>
<li>\( \lambda_p(\mathbf{x}) = \frac{\|\mathbf{x} - \mathbf{q}\| }{ \|\mathbf{q} - \mathbf{p}\|} \)</li>
<li>\( \lambda_q(\mathbf{x}) = \frac{\|\mathbf{x} - \mathbf{p}\| }{ \|\mathbf{q} - \mathbf{p}\|} \)</li>
</ul>
<p>Furthermore, Piper <a class="el" href="citelist.html#CITEREF_cgal:p-plcbd-93">[7]</a> shows that the coordinate functions are continuous in the convex hull of \( \mathcal{P}\) and continuously differentiable except on the data points \( \mathcal{P}\).<br />
</p>
<h2><a class="anchor" id="InterpolationIntroductionRegular"></a>
Regular Neighbor Coordinates</h2>
<p>The previous definition naturally extends to weighted Voronoi diagrams. These diagrams, also known as <em>power diagrams</em>, are obtained by considering weighted points (the weight being a scalar) and considering a weighted distance, the <em>power distance</em>, defined between two weighted points \( (p, \omega_p) \) and \( (q, \omega_q) \) by \( \Pi( (p, \omega_p), (q, \omega_q) ) = pq^2 - \omega_p - \omega_q \). See <a class="el" href="index.html#Subsection_2D_Triangulations_Regular_Description">this section </a> of the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgTriangulation2Summary">2D Triangulation</a> for an in-depth description of power diagrams.</p>
<p><a class="anchor" id="fig__figrn_coords"></a></p><div class="image">
<object type="image/svg+xml" data="rn_coords.svg">rn_coords.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figrn_coords">Figure 87.2</a> Illustration of regular neighbor coordinates. The point set is the same as in <a class="el" href="index.html#fig__fignn_coords">Figure 87.1</a> but weights have been added. These weights are shown using circles, with the radius of each circle being equal to the square root of the weight of the point.  </div>  <br />

<dl class="section warning"><dt>Warning</dt><dd>Contrary to Voronoi diagrams, a weighted point \( p_i\) does not necessarily possess a non-empty cell in the power diagram of \( \mathcal{P}\) (with \( p_i\in\mathcal{P}\)). When this is the case, that point is then said to be <em>hidden</em> and all of its regular neighbor coordinates are null.</dd></dl>
<h2><a class="anchor" id="InterpolationImplementation"></a>
Implementation</h2>
<p>The interpolation package of <span style="font-variant: small-caps;">CGAL</span> provides functions to compute natural and regular neighbor coordinates for \( 2D\) points. Refer to the reference pages <code><a class="el" href="group__PkgInterpolationNaturalNeighborCoordinates2.html#ga7bff652e1106089e701ebc64b371a966" title="Computes the natural neighbor coordinates for p with respect to the points in the two-dimensional Del...">natural_neighbor_coordinates_2()</a></code> and <code><a class="el" href="group__PkgInterpolationRegularNeighborCoordinates2.html#ga1ab1d7be7cb0aa417e07ae9df0cab2fb" title="Computes the regular neighbor coordinates for p with respect to the weighted points in the two-dimens...">regular_neighbor_coordinates_2()</a></code>. In addition, the package provides functions to compute natural neighbor coordinates on well sampled point set surfaces. See Section <a class="el" href="index.html#secsurface">Surface Natural Neighbor Coordinates and Surface Neighbors</a> and the reference page <code><a class="el" href="group__PkgInterpolationSurfaceNeighborCoordinates3.html#ga07c7f1c1efbbbe293fcb2835ca39ed0f" title="The sample points  are provided in the range [first, beyond). ">surface_neighbor_coordinates_3()</a></code> for further information.</p>
<h3><a class="anchor" id="InterpolationCoordinateComputationApproach"></a>
Computation of the Coordinates</h3>
<p>Given a Delaunay triangulation or a regular triangulation, our implementation computes natural and regular neighbor coordinates in two steps. Firstly, the vertices in conflict with the query point (that is, the vertices from which the query point will "steal") are determined. Then, the areas \( \pi_i(\mathbf{x})\) are computed by triangulating the Voronoi sub-cells. The output is threefold:</p><ul>
<li>points (or vertices) with a non-null coordinate along with these coordinates \( \pi_i(\mathbf{x})\),</li>
<li>the normalization factor \( \pi(\mathbf{x})\),</li>
<li>a Boolean indicator on whether the coordinate computation was successful (which is equivalent to a Boolean indicating whether the query point lies in the convex hull or not).</li>
</ul>
<p>Note that if the query point has already been located in the triangulation (for example using functions such as <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__2.html#a940567120751e7864c7b345eaf756642">locate()</a>) and/or the boundary edges of the conflict zone are already determined, alternative functions allow to avoid the re-computation (see <a class="el" href="group__PkgInterpolationNaturalNeighborCoordinates2.html">CGAL::natural_neighbor_coordinates_2()</a> and <a class="el" href="group__PkgInterpolationRegularNeighborCoordinates2.html">CGAL::regular_neighbor_coordinates_2()</a>).</p>
<h2><a class="anchor" id="InterpolationExampleforCoordinates"></a>
Examples</h2>
<p>This section presents some examples of utilization of the natural and regular neighbor coordinates computation methods. Sections <a class="el" href="index.html#InterpolationExampleforNaturalNeighborCoordinates">Example for Natural Neighbor Coordinates</a> and <a class="el" href="index.html#InterpolationExampleforRegularNeighborCoordinates">Example for Regular Neighbor Coordinates</a> show basic examples of the computation of natural and regular neighbor coordinates. Section <a class="el" href="index.html#InterpolationExampleforRegularNeighborCoordinates">Example for Regular Neighbor Coordinates</a> shows a more advanced use case of the API, where a functor is passed to change the output.</p>
<h3><a class="anchor" id="InterpolationExampleforNaturalNeighborCoordinates"></a>
Example for Natural Neighbor Coordinates</h3>
<p>The signature of all coordinate computation functions is about the same. <br />
<b>File</b> <a class="el" href="Interpolation_2nn_coordinates_2_8cpp-example.html">Interpolation/nn_coordinates_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/natural_neighbor_coordinates_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> K::FT                                               Coord_type;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                          Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K&gt;</a>                   Delaunay_triangulation;</div><div class="line"></div><div class="line"><span class="comment">// Resulting points-coordinates pairs will be stored in an object of this type</span></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::pair&lt;Point, Coord_type&gt; &gt;          Point_coordinate_vector;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Delaunay_triangulation dt;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;3; ++y)</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;3; ++x)</div><div class="line">      dt.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html#a81efeca7e8a7605aba1d3b4f951a96dc">insert</a>(K::Point_2(x, y));</div><div class="line"></div><div class="line">  <span class="comment">// coordinates computation</span></div><div class="line">  K::Point_2 p(1.2, 0.7); <span class="comment">// query point</span></div><div class="line">  Point_coordinate_vector coords;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Triple.html">CGAL::Triple&lt;std::back_insert_iterator&lt;Point_coordinate_vector&gt;</a>, K::FT, <span class="keywordtype">bool</span>&gt; result =</div><div class="line">      <a class="code" href="group__PkgInterpolationNaturalNeighborCoordinates2.html#ga7bff652e1106089e701ebc64b371a966">CGAL::natural_neighbor_coordinates_2</a>(dt, p, std::back_inserter(coords));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!result.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Triple.html#a259acf3abe5295dedc2f575236646339">third</a>)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The coordinate computation was not successful."</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The point ("</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">") lies outside the convex hull."</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  K::FT norm = result.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Triple.html#a6421bcd4889c6e4035ff5ac0ef330f09">second</a>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Coordinate computation successful."</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Normalization factor: "</span> &lt;&lt; norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Coordinates for point: ("</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">") are the following: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(std::size_t i=0; i&lt;coords.size(); ++i)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"  Point: ("</span> &lt;&lt; coords[i].first &lt;&lt; <span class="stringliteral">") coeff: "</span> &lt;&lt; coords[i].second &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="InterpolationExampleforRegularNeighborCoordinates"></a>
Example for Regular Neighbor Coordinates</h3>
<p>For regular neighbor coordinates, it is sufficient to replace the name of the function and the type of triangulation passed as parameter, as shown in the example below:</p>
<p><br />
<b>File</b> <a class="el" href="Interpolation_2rn_coordinates_2_8cpp-example.html">Interpolation/rn_coordinates_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Regular_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/regular_neighbor_coordinates_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> K::FT                                               FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__2.html">CGAL::Regular_triangulation_2&lt;K&gt;</a>                    Regular_triangulation;</div><div class="line"><span class="keyword">typedef</span> Regular_triangulation::Bare_point                   Bare_point;</div><div class="line"><span class="keyword">typedef</span> Regular_triangulation::Weighted_point               Weighted_point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::pair&lt;Weighted_point, FT&gt; &gt;         Point_coordinate_vector;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Regular_triangulation rt;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;3; ++y)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;3; ++x)</div><div class="line">      rt.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__2.html#af7c85fa190b96836fb6c6a8704a0171c">insert</a>(Weighted_point(Bare_point(x, y), 0. <span class="comment">/*weight*/</span>));</div><div class="line"></div><div class="line">  <span class="comment">// coordinate computation</span></div><div class="line">  Weighted_point wp(Bare_point(1.2, 0.7), 2.);</div><div class="line">  Point_coordinate_vector coords;</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Triple.html">CGAL::Triple&lt;std::back_insert_iterator&lt;Point_coordinate_vector&gt;</a>, K::FT, <span class="keywordtype">bool</span>&gt; result =</div><div class="line">      <a class="code" href="group__PkgInterpolationRegularNeighborCoordinates2.html#ga1ab1d7be7cb0aa417e07ae9df0cab2fb">CGAL::regular_neighbor_coordinates_2</a>(rt, wp, std::back_inserter(coords));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!result.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Triple.html#a259acf3abe5295dedc2f575236646339">third</a>)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The coordinate computation was not successful."</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The point ("</span> &lt;&lt;wp.point() &lt;&lt; <span class="stringliteral">") lies outside the convex hull."</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  K::FT norm = result.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Triple.html#a6421bcd4889c6e4035ff5ac0ef330f09">second</a>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Coordinate computation successful."</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Normalization factor: "</span> &lt;&lt; norm &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Coordinates for point: ("</span> &lt;&lt; wp &lt;&lt; <span class="stringliteral">") are the following: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(std::size_t i=0; i&lt;coords.size(); ++i)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"  Point: ("</span> &lt;&lt; coords[i].first &lt;&lt; <span class="stringliteral">") coeff: "</span> &lt;&lt; coords[i].second &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="InterpolationExampleforOutputFunctor"></a>
Formatting the Output Coordinates</h3>
<p>Internally, natural or regular neighbor coordinates are associated to the vertices of the triangulation via objects of type <code>std::pair&lt;Vertex_handle, Coord_type&gt;</code>, where <code>Coord_type</code> is the number type of the coordinates. By default and for backward compatibility reasons, this output is converted into objects of type <code>std::pair&lt;Point, Coord_type&gt;</code>, where <code>Point</code> is a bare (weightless) point.</p>
<p>It is however possible to collect the output as objects of any desired type, for example the simple <code>Point</code> type, by passing a functor as extra parameter of the coordinates computation function. The argument type of this functor must be <code>std::pair&lt;Vertex_handle, Coord_type&gt;</code> and the result type is chosen by the user, but must be consistent with the output iterator. Usage of this parameter is demonstrated in the example below, where the output is kept as objects of type <code>std::pair&lt;Vertex_handle, Coord_type&gt;</code>, which allows us to then store the coordinate in the vertex, using the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__with__info__2.html">CGAL::Triangulation_vertex_base_with_info_2</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Interpolation_2nn_coordinates_with_info_2_8cpp-example.html">Interpolation/nn_coordinates_with_info_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/natural_neighbor_coordinates_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>          K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> K::FT                                                        Coord_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__with__info__2.html">CGAL::Triangulation_vertex_base_with_info_2&lt;Coord_type, K&gt;</a>   Vb;</div><div class="line"><span class="keyword">typedef</span> CGAL::Triangulation_data_structure_2&lt;Vb&gt;                     Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</a>                       Delaunay_triangulation;</div><div class="line"></div><div class="line"><span class="comment">// The functor 'Identity' matches anything to itself</span></div><div class="line"><span class="keyword">typedef</span> Delaunay_triangulation::Vertex_handle                        Vertex_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Identity.html">CGAL::Identity&lt;std::pair&lt;Vertex_handle, Coord_type&gt;</a> &gt;        Identity;</div><div class="line"></div><div class="line"><span class="comment">// Resulting points-coordinates pairs are here stored in an object of this type:</span></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::pair&lt;Vertex_handle, Coord_type&gt; &gt;           Point_coordinate_vector;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Delaunay_triangulation dt;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;3; ++y)</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;3; ++x)</div><div class="line">      dt.insert(K::Point_2(x, y));</div><div class="line"></div><div class="line">  <span class="comment">// coordinates computation</span></div><div class="line">  K::Point_2 p(1.2, 0.7); <span class="comment">// query point</span></div><div class="line">  Point_coordinate_vector coords;</div><div class="line"></div><div class="line">  <span class="comment">// The functor Identity is passed to the method</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Triple.html">CGAL::Triple&lt;std::back_insert_iterator&lt;Point_coordinate_vector&gt;</a>, K::FT, <span class="keywordtype">bool</span>&gt; result =</div><div class="line">      <a class="code" href="group__PkgInterpolationNaturalNeighborCoordinates2.html#ga7bff652e1106089e701ebc64b371a966">CGAL::natural_neighbor_coordinates_2</a>(dt, p, std::back_inserter(coords), Identity());</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!result.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Triple.html#a259acf3abe5295dedc2f575236646339">third</a>)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The coordinate computation was not successful."</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The point ("</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">") lies outside the convex hull."</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Assign the coordinates to the vertices</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Coordinates for point: ("</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">") are the following: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(std::size_t i=0; i&lt;coords.size(); ++i)</div><div class="line">  {</div><div class="line">    Vertex_handle vh = coords[i].first;</div><div class="line">    vh-&gt;info() = coords[i].second;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"  Vertex: ("</span> &lt;&lt; vh-&gt;point() &lt;&lt; <span class="stringliteral">") coeff: "</span> &lt;&lt; vh-&gt;info() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="secsurface"></a>
Surface Natural Neighbor Coordinates and Surface Neighbors</h1>
<p>This section introduces functions to compute natural neighbor coordinates and surface neighbors associated to a set of sample points issued from a surface \( \mathcal{S}\) and given a query point \( \mathbf{x}\) on \( \mathcal{S}\). We assume that \( \mathcal{S}\) is a closed and compact surface of \( \mathbb{R}^3\), and let \( \mathcal{P}= \{\mathbf{p_1}, \ldots,\mathbf{p_n}\}\) be an \( \epsilon\)-sample of \( \mathcal{S}\) (refer to Amenta and Bern <a class="el" href="citelist.html#CITEREF_ab-srvf-99">[1]</a>). The concepts are based on the definition of Boissonnat and Fl√∂totto <a class="el" href="citelist.html#CITEREF_bf-lcss-02">[2]</a>, <a class="el" href="citelist.html#CITEREF_cgal:f-csapc-03">[5]</a>. Both references contain a thorough description of the requirements and the mathematical properties.</p>
<h2><a class="anchor" id="InterpolationIntroduction_1"></a>
Introduction</h2>
<p>Two observations lead to the definition of surface neighbors and surface neighbor coordinates: First, it is clear that the tangent plane \( \mathcal{T}_x\) of the surface \( \mathcal{S}\) at the point \( \mathbf{x} \in \mathcal{S}\) approximates \( \mathcal{S}\) in the neighborhood of \( \mathbf{x}\). It has been shown in <a class="el" href="citelist.html#CITEREF_bf-lcss-02">[2]</a> that, if the surface \( \mathcal{S}\) is well sampled with respect to the curvature and the local thickness of \( \mathcal{S}\), i.e. it is an \( \epsilon\)-sample, then the intersection of the tangent plane \( \mathcal{T}_x\) with the Voronoi cell of \( \mathbf{x}\) in the Voronoi diagram of \( \mathcal{P} \cup \{\mathbf{x}\}\) has a small diameter. Consequently, inside this Voronoi cell, the tangent plane \( \mathcal{T}_x\) is a reasonable approximation of \( \mathcal{S}\). Furthermore, the second observation allows to compute this intersection diagram easily: one can show using Pythagoras' Theorem that the intersection of a three-dimensional Voronoi diagram with a plane \( \mathcal{H}\) is a two-dimensional power diagram. The points defining the power diagram are the projections of the points in \( \mathcal{P}\) onto \( \mathcal{H}\), each point weighted with its negative square distance to \( \mathcal{H}\). Algorithms for the computation of power diagrams via the dual regular triangulation are well known and for example provided by <span style="font-variant: small-caps;">CGAL</span> in the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__2.html">Regular_triangulation_2</a>&lt;Gt, Tds&gt;</code>.</p>
<h2><a class="anchor" id="InterpolationImplementation_1"></a>
Implementation</h2>
<h3><a class="anchor" id="InterpolationVoronoiIntersectionDiagrams"></a>
Voronoi Intersection Diagrams</h3>
<p>In <span style="font-variant: small-caps;">CGAL</span>, the regular triangulation dual to the intersection of a \( 3D\) Voronoi diagram with a plane \( \mathcal{H}\) can be computed by instantiating the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__2.html">Regular_triangulation_2</a>&lt;Gt, Tds&gt;</code> class with the traits class <code><a class="el" href="classCGAL_1_1Voronoi__intersection__2__traits__3.html" title="Voronoi_intersection_2_traits_3 is a model for the concept RegularTriangulationTraits_2. ">Voronoi_intersection_2_traits_3</a>&lt;K&gt;</code>. This traits class contains a point and a vector as class member which define the plane \( \mathcal{H}\). All predicates and constructions used by <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__2.html">Regular_triangulation_2</a>&lt;Gt, Tds&gt;</code> are replaced by the corresponding operators on three-dimensional points. For example, the power test predicate (which takes three weighted \( 2D\) points \( p'\), \( q'\), \( r'\) of the regular triangulation and tests the power distance of a fourth point \( t'\) with respect to the power circle orthogonal to \( p\), \( q\), \( r\)) is replaced by a <code>Side_of_plane_centered_sphere_2_3</code> predicate that tests the position of a \( 3D\) point \( t\) with respect to the sphere centered on the plane \( \mathcal{H}\) passing through the \( 3D\) points \( p\), \( q\), \( r\). This approach allows to avoid the explicit construction of the projected points and the weights, operations which are very prone to rounding errors.</p>
<h3><a class="anchor" id="InterpolationNaturalNeighborCoordinateson"></a>
Natural Neighbor Coordinates on Surfaces</h3>
<p>The computation of natural neighbor coordinates on surfaces is based upon the computation of regular neighbor coordinates with respect to the regular triangulation that is dual to \( {\rm Vor}(\mathcal{P}) \cap \mathcal{T}_x\), the intersection of \( \mathcal{T}_x\) and the Voronoi diagram of \( \mathcal{P}\), via the function <code><a class="el" href="group__PkgInterpolationRegularNeighborCoordinates2.html#ga1ab1d7be7cb0aa417e07ae9df0cab2fb" title="Computes the regular neighbor coordinates for p with respect to the weighted points in the two-dimens...">regular_neighbor_coordinates_2()</a></code>.</p>
<p>Of course, we might introduce all data points \( \mathcal{P}\) into this regular triangulation. However, this is not necessary because we are only interested in the cell of \( \mathbf{x}\). It is sufficient to guarantee that all surface neighbors of the query point \( \mathbf{x}\) are among the input points that are passed as argument to the function. The sample points \( \mathcal{P}\) can be filtered for example by distance, e.g. using range search or \( k\)-nearest neighbor queries, or with the help of the \( 3D\) Delaunay triangulation since the surface neighbors are necessarily a subset of the natural neighbors of the query point in this triangulation. <span style="font-variant: small-caps;">CGAL</span> provides a function that encapsulates the filtering based on the \( 3D\) Delaunay triangulation. For input points filtered by distance, functions are provided that indicate whether or not points that lie outside the input range (i.e.\ points that are further from \( \mathbf{x}\) than the furthest input point) can still influence the result. This allows to iteratively enlarge the set of input points until the range is sufficient to certify the result.</p>
<h3><a class="anchor" id="InterpolationSurfaceNeighbors"></a>
Surface Neighbors</h3>
<p>The surface neighbors of the query point are its neighbors in the regular triangulation that is dual to \( {\rm Vor}(\mathcal{P}) \cap \mathcal{T}_x\), the intersection of \( \mathcal{T}_x\) and the Voronoi diagram of \( \mathcal{P}\). As for surface neighbor coordinates, this regular triangulation is computed and the same kind of filtering of the data points as well as the certification described above is provided.</p>
<h2><a class="anchor" id="InterpolationExampleforSurfaceNeighborCoordinates"></a>
Example for Surface Neighbor Coordinates</h2>
<p>The example below describes the usage of the function <code><a class="el" href="group__PkgInterpolationSurfaceNeighborCoordinates3.html#ga07c7f1c1efbbbe293fcb2835ca39ed0f" title="The sample points  are provided in the range [first, beyond). ">CGAL::surface_neighbor_coordinates_3()</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Interpolation_2surface_neighbor_coordinates_3_8cpp-example.html">Interpolation/surface_neighbor_coordinates_3.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// example with random points on a sphere</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/algorithm.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Origin.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/surface_neighbor_coordinates_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  K;</div><div class="line"><span class="keyword">typedef</span> K::FT                                                Coord_type;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                           Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3                                          Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt; std::pair&lt; Point_3, K::FT &gt; &gt;           Point_coordinate_vector;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> n = 100;</div><div class="line">  std::vector&lt; Point_3&gt; points;</div><div class="line">  points.reserve(n);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Generate "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" random points on a sphere."</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Random_points_on_sphere_3&lt;Point_3&gt; g(1);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gadba21cc5c30a79519438dfe0f9264255">CGAL::cpp11::copy_n</a>(g, n, std::back_inserter(points));</div><div class="line"></div><div class="line">  Point_3 p(1, 0, 0);</div><div class="line">  Vector_3 <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">normal</a>(p - <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Compute surface neighbor coordinates for "</span> &lt;&lt; p &lt;&lt; std::endl;</div><div class="line">  Point_coordinate_vector coords;</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Triple.html">CGAL::Triple&lt;std::back_insert_iterator&lt;Point_coordinate_vector&gt;</a>, K::FT, <span class="keywordtype">bool</span>&gt; result =</div><div class="line">    <a class="code" href="group__PkgInterpolationSurfaceNeighborCoordinates3.html#ga07c7f1c1efbbbe293fcb2835ca39ed0f">CGAL::surface_neighbor_coordinates_3</a>(points.begin(), points.end(),</div><div class="line">                                         p, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">normal</a>,</div><div class="line">                                         std::back_inserter(coords),</div><div class="line">                                         K());</div><div class="line">  <span class="keywordflow">if</span>(!result.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Triple.html#a259acf3abe5295dedc2f575236646339">third</a>)</div><div class="line">  {</div><div class="line">    <span class="comment">//Undersampling:</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The coordinate computation was not successful."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  K::FT norm = result.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Triple.html#a6421bcd4889c6e4035ff5ac0ef330f09">second</a>;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Testing the barycentric property "</span> &lt;&lt; std::endl;</div><div class="line">  Point_3 b(0, 0, 0);</div><div class="line">  <span class="keywordflow">for</span>(std::vector&lt; std::pair&lt; Point_3, Coord_type &gt; &gt;::const_iterator</div><div class="line">      it = coords.begin(); it!=coords.end(); ++it)</div><div class="line">    b = b + (it-&gt;second/norm) * (it-&gt;first - <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"    weighted barycenter: "</span> &lt;&lt; b &lt;&lt;std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"    squared distance: "</span> &lt;&lt; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a>(p,b) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="secinterpolation"></a>
Interpolation Methods</h1>
<p>We describe in this section the different interpolation methods offered by this package. These can be regrouped into two large classes: values and gradient interpolation methods.</p>
<h2><a class="anchor" id="InterpolationIntroduction_2"></a>
Interpolation of Function Values</h2>
<p>The interpolation functions presented below are used to interpolate function values.</p>
<h3><a class="anchor" id="InterpolationLinearPrecisionInterpolation"></a>
Linear Precision Interpolation</h3>
<p>Sibson <a class="el" href="citelist.html#CITEREF_s-bdnni-81">[9]</a> defines a very simple interpolant that re-produces linear functions exactly. The interpolation of \( \Phi(\mathbf{x})\) is given as the linear combination of the neighbors' function values weighted by the coordinates: </p><p class="formulaDsp">
\[ Z^0(\mathbf{x}) = \ccSum{i}{}{ \lambda_i(\mathbf{x}) z_i}. \]
</p>
<p> Indeed, if \( z_i=a + \mathbf{b}^t \mathbf{p_i}\) for all natural neighbors of \( \mathbf{x}\), we have </p><p class="formulaDsp">
\[ Z^0(\mathbf{x}) = \ccSum{i}{}{ \lambda_i(\mathbf{x}) (a + \mathbf{b}^t\mathbf{p_i})} = a+\mathbf{b}^t \mathbf{x} \]
</p>
<p> by the barycentric coordinate property.</p>
<p>This interpolation is implemented through the function <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga2f8a2f88b5b91b9f3db2d5e40bfa1df7" title="The function linear_interpolation() computes the weighted sum of the function values which must be pr...">CGAL::linear_interpolation()</a></code>. The first example in Subsection <a class="el" href="index.html#subsecinterpol_examples">Example for Linear Interpolation</a> shows how the function is called.</p>
<h3><a class="anchor" id="InterpolationSibson"></a>
Sibson's C^1 Continuous Interpolant</h3>
<p>In <a class="el" href="citelist.html#CITEREF_s-bdnni-81">[9]</a>, Sibson describes a second interpolation method that relies also on the function gradient \( \mathbf{g_i}\) for all \( \mathbf{p_i} \in \mathcal{P}\). It is \( C^1\) continuous with gradient \( \mathbf{g_i}\) at \( \mathbf{p_i}\). Spherical quadrics of the form \( \Phi(\mathbf{x}) =a + \mathbf{b}^t \mathbf{x} +\gamma\ \mathbf{x}^t\mathbf{x}\) are reproduced exactly. The proof relies on the barycentric coordinate property of the natural neighbor coordinates and assumes that the gradient of \( \Phi\) at the data points is known or approximated from the function values as described in <a class="el" href="citelist.html#CITEREF_s-bdnni-81">[9]</a> (see Section <a class="el" href="index.html#sgradient_fitting">Gradient Fitting</a>).</p>
<p>Sibson's \( Z^1\) interpolant is a combination of the linear interpolant \( Z^0\) and an interpolant \( \xi\) which is the weighted sum of the first degree functions </p><p class="formulaDsp">
\[ \xi_i(\mathbf{x}) = z_i +\mathbf{g_i}^t(\mathbf{x}-\mathbf{p_i}),\qquad \xi(\mathbf{x})= \frac{\ccSum{i}{}{ \frac{\lambda_i(\mathbf{x})} {\|\mathbf{x}-\mathbf{p_i}\|}\xi_i(\mathbf{x}) } }{\ccSum{i}{}{ \frac{\lambda_i(\mathbf{x})}{\|\mathbf{x}-\mathbf{p_i}\|}}}. \]
</p>
<p> Sibson observed that the combination of \( Z^0\) and \( \xi\) reconstructs exactly a spherical quadric if they are mixed as follows: </p><p class="formulaDsp">
\[ Z^1(\mathbf{x}) = \frac{\alpha(\mathbf{x}) Z^0(\mathbf{x}) + \beta(\mathbf{x}) \xi(\mathbf{x})}{\alpha(\mathbf{x}) + \beta(\mathbf{x})} \mbox{ where } \alpha(\mathbf{x}) = \frac{\ccSum{i}{}{ \lambda_i(\mathbf{x}) \frac{\|\mathbf{x} - \mathbf{p_i}\|^2}{f(\|\mathbf{x} - \mathbf{p_i}\|)}}}{\ccSum{i}{}{ \frac{\lambda_i(\mathbf{x})} {f(\|\mathbf{x} - \mathbf{p_i}\|)}}} \mbox{ and } \beta(\mathbf{x})= \ccSum{i}{}{ \lambda_i(\mathbf{x}) \|\mathbf{x} - \mathbf{p_i}\|^2}, \]
</p>
<p> where in Sibson's original work, \( f(\|\mathbf{x} - \mathbf{p_i}\|) = \|\mathbf{x} - \mathbf{p_i}\|\).</p>
<p>This interpolation method can be used by calling <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga2f6df3dd458c7638a526a41f1bee55b3" title="The function sibson_c1_interpolation() generates the interpolated function value at the point p...">CGAL::sibson_c1_interpolation()</a></code>.</p>
<p><span style="font-variant: small-caps;">CGAL</span> contains a second implementation using \( f(\|\mathbf{x} - \mathbf{p_i}\|) = \|\mathbf{x} - \mathbf{p_i}\|^2\), <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga1f84e03a02a6602d45c26f600a6d225b" title="Same as sibson_c1_interpolation(), except that no square root operation is required for the number ty...">CGAL::sibson_c1_interpolation_square()</a></code>, which is less demanding on the number type because it avoids the square-root computation needed to compute the distance \( \|\mathbf{x} - \mathbf{p_i}\|\). The theoretical guarantees are the same (see <a class="el" href="citelist.html#CITEREF_cgal:f-csapc-03">[5]</a>). Simply, the smaller the slope of \( f\) around \( f(0)\), the faster the interpolant approaches \( \xi_i\) as \( \mathbf{x} \) goes to \( \mathbf{p_i}\).</p>
<h3><a class="anchor" id="InterpolationFarin"></a>
Farin's C^1 Continuous Interpolant</h3>
<p>Farin <a class="el" href="citelist.html#CITEREF_f-sodt-90">[4]</a> extended Sibson's work and realizes a \( C^1\) continuous interpolant by embedding natural neighbor coordinates in the Bernstein-B√©zier representation of a cubic simplex. If the gradient of \( \Phi\) at the data points is known, this interpolant reproduces quadratic functions exactly. The function gradient can be approximated from the function values by Sibson's method <a class="el" href="citelist.html#CITEREF_s-bdnni-81">[9]</a> (see Section <a class="el" href="index.html#sgradient_fitting">Gradient Fitting</a>) which is exact only for spherical quadrics.</p>
<p>The Farin \( C^1\)-continuous interpolant is implemented in the function <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga40856de51734ae1b1882cb46e8195c93" title="Generates the interpolated function value computed by Farin's interpolant. ">CGAL::farin_c1_interpolation()</a></code>.</p>
<h3><a class="anchor" id="InterpolationQuadraticPrecisionInterpolants"></a>
Quadratic Precision Interpolants</h3>
<p>Knowing the gradient \( \mathbf{g_i}\) for all \( \mathbf{p_i} \in \mathcal{P}\), we formulate a very simple interpolant that reproduces exactly quadratic functions. This interpolant is not \( C^1\) continuous in general. It is defined as follows: </p><p class="formulaDsp">
\[ I^1(\mathbf{x}) = \ccSum{i}{}{ \lambda_i(\mathbf{x}) (z_i + \frac{1}{2} \mathbf{g_i}^t (\mathbf{x} - \mathbf{p_i}))} \]
</p>
<p>This interpolation can be used with the method <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga50aa68e988b099a99533f26872c639f5" title="The function quadratic_interpolation() generates the interpolated function value as the weighted sum ...">CGAL::quadratic_interpolation()</a></code>.</p>
<h2><a class="anchor" id="sgradient_fitting"></a>
Gradient Fitting</h2>
<p>Sibson describes a method to approximate the gradient of the function \( f\) from the function values on the data sites. For the data point \( \mathbf{p_i}\), we determine </p><p class="formulaDsp">
\[ \mathbf{g_i} = \min_{\mathbf{g}} \ccSum{j}{}{ \frac{\lambda_j(\mathbf{p_i})}{\|\mathbf{p_i} - \mathbf{p_j}\|^2} \left( z_j - (z_i + \mathbf{g}^t (\mathbf{p_j} -\mathbf{p_i})) \right)}, \]
</p>
<p> where \( \lambda_j(\mathbf{p_i})\) is the natural neighbor coordinate of \( \mathbf{p_i}\) with respect to \( \mathbf{p_i}\) associated to \( \mathcal{P} \setminus \{\mathbf{p_i}\}\). For spherical quadrics, the result is exact.</p>
<p><span style="font-variant: small-caps;">CGAL</span> provides functions to approximate the gradients of all data points that are inside the convex hull. There is one function for each type of neighbor coordinates:</p><ul>
<li><code><a class="el" href="group__PkgInterpolationNaturalNeighborCoordinates2.html#ga7bff652e1106089e701ebc64b371a966" title="Computes the natural neighbor coordinates for p with respect to the points in the two-dimensional Del...">natural_neighbor_coordinates_2()</a></code>: <code><a class="el" href="group__PkgInterpolationSibsonGradientFitting.html#ga2063ef2d118d601f4d0789ffcf2c191f" title="Estimates the function gradients at all vertices of the Delaunay triangulation dt that lie inside the...">CGAL::sibson_gradient_fitting_nn_2()</a></code></li>
<li><code><a class="el" href="group__PkgInterpolationRegularNeighborCoordinates2.html#ga1ab1d7be7cb0aa417e07ae9df0cab2fb" title="Computes the regular neighbor coordinates for p with respect to the weighted points in the two-dimens...">regular_neighbor_coordinates_2()</a></code>: <code><a class="el" href="group__PkgInterpolationSibsonGradientFitting.html#gadd232ce2ff777c055c039aa9bcff7e90" title="Estimates the function gradients at all vertices of rt that lie inside the convex hull using the coor...">CGAL::sibson_gradient_fitting_rn_2()</a></code>.</li>
</ul>
<h2><a class="anchor" id="subsecinterpol_examples"></a>
Example for Linear Interpolation</h2>
<p>The example below shows a typical example of the usage of <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga2f8a2f88b5b91b9f3db2d5e40bfa1df7" title="The function linear_interpolation() computes the weighted sum of the function values which must be pr...">CGAL::linear_interpolation()</a></code>. Note the use of <code><a class="el" href="structCGAL_1_1Data__access.html" title="The struct Data_access implements a functor that allows to retrieve data from an associative containe...">CGAL::Data_access</a></code> to transform the <code>std::map</code> in a functor compatible with the function.</p>
<p><br />
<b>File</b> <a class="el" href="Interpolation_2linear_interpolation_2_8cpp-example.html">Interpolation/linear_interpolation_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Interpolation_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/natural_neighbor_coordinates_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/interpolation_functions.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K&gt;</a>                   Delaunay_triangulation;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Interpolation__traits__2.html">CGAL::Interpolation_traits_2&lt;K&gt;</a>                     Traits;</div><div class="line"><span class="keyword">typedef</span> K::FT                                               Coord_type;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                          Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Delaunay_triangulation T;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> std::map&lt;Point, Coord_type, K::Less_xy_2&gt;         Coord_map;</div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Data__access.html">CGAL::Data_access&lt;Coord_map&gt;</a>                      Value_access;</div><div class="line"></div><div class="line">  Coord_map value_function;</div><div class="line">  Coord_type a(0.25), bx(1.3), by(-0.7);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0 ; y&lt;3 ; y++){</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0 ; x&lt;3 ; x++){</div><div class="line">      K::Point_2 p(x,y);</div><div class="line">      T.insert(p);</div><div class="line">      value_function.insert(std::make_pair(p, a + bx*x + by*y));</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//coordinate computation</span></div><div class="line">  K::Point_2 p(1.3, 0.34);</div><div class="line">  std::vector&lt;std::pair&lt;Point, Coord_type&gt; &gt; coords;</div><div class="line"></div><div class="line">  Coord_type norm = <a class="code" href="group__PkgInterpolationNaturalNeighborCoordinates2.html#ga7bff652e1106089e701ebc64b371a966">CGAL::natural_neighbor_coordinates_2</a>(T, p, std::back_inserter(coords)).second;</div><div class="line">  Coord_type res =  <a class="code" href="group__PkgInterpolation2Interpolation.html#ga2f8a2f88b5b91b9f3db2d5e40bfa1df7">CGAL::linear_interpolation</a>(coords.begin(), coords.end(), norm,</div><div class="line">                                               Value_access(value_function));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Tested interpolation on "</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">" interpolation: "</span></div><div class="line">            &lt;&lt; res &lt;&lt; <span class="stringliteral">" exact: "</span> &lt;&lt; a + bx*p.x() + by*p.y() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="InterpolationExampleSibson"></a>
Example for Sibson's C^1 Interpolation Scheme with Gradient Estimation</h2>
<p><br />
<b>File</b> <a class="el" href="Interpolation_2sibson_interpolation_2_8cpp-example.html">Interpolation/sibson_interpolation_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/natural_neighbor_coordinates_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Interpolation_gradient_fitting_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/sibson_gradient_fitting.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/interpolation_functions.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K&gt;</a>                   Delaunay_triangulation;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Interpolation__gradient__fitting__traits__2.html">CGAL::Interpolation_gradient_fitting_traits_2&lt;K&gt;</a>    Traits;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> K::FT                                               Coord_type;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                          Point;</div><div class="line"><span class="keyword">typedef</span> std::map&lt;Point, Coord_type, K::Less_xy_2&gt;           Point_value_map ;</div><div class="line"><span class="keyword">typedef</span> std::map&lt;Point, K::Vector_2 , K::Less_xy_2&gt;         Point_vector_map;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Delaunay_triangulation T;</div><div class="line"></div><div class="line">  Point_value_map value_function;</div><div class="line">  Point_vector_map gradient_function;</div><div class="line"></div><div class="line">  <span class="comment">//parameters for spherical function:</span></div><div class="line">  Coord_type a(0.25), bx(1.3), by(-0.7), c(0.2);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;4; y++) {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;4; x++) {</div><div class="line">      K::Point_2 p(x,y);</div><div class="line">      T.insert(p);</div><div class="line">      value_function.insert(std::make_pair(p,a + bx* x+ by*y + c*(x*x+y*y)));</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgInterpolationSibsonGradientFitting.html#ga2063ef2d118d601f4d0789ffcf2c191f">sibson_gradient_fitting_nn_2</a>(T, std::inserter(gradient_function,</div><div class="line">                                                gradient_function.begin()),</div><div class="line">                               <a class="code" href="structCGAL_1_1Data__access.html">CGAL:: Data_access&lt;Point_value_map&gt;</a>(value_function),</div><div class="line">                               Traits());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(Point_vector_map::iterator it = gradient_function.begin(); it != gradient_function.end(); ++it)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">"  "</span>  &lt;&lt; it-&gt;second &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="comment">// coordinate computation</span></div><div class="line">  K::Point_2 p(1.6, 1.4);</div><div class="line">  std::vector&lt; std::pair&lt; Point, Coord_type &gt; &gt; coords;</div><div class="line">  Coord_type norm = <a class="code" href="group__PkgInterpolationNaturalNeighborCoordinates2.html#ga7bff652e1106089e701ebc64b371a966">CGAL::natural_neighbor_coordinates_2</a>(T, p, std::back_inserter(coords)).second;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">//Sibson interpolant: version without sqrt:</span></div><div class="line">  std::pair&lt;Coord_type, bool&gt; res =</div><div class="line">    <a class="code" href="group__PkgInterpolation2Interpolation.html#ga1f84e03a02a6602d45c26f600a6d225b">CGAL::sibson_c1_interpolation_square</a>(coords.begin(),</div><div class="line">                                         coords.end(), norm, p,</div><div class="line">                                         <a class="code" href="structCGAL_1_1Data__access.html">CGAL::Data_access&lt;Point_value_map&gt;</a>(value_function),</div><div class="line">                                         <a class="code" href="structCGAL_1_1Data__access.html">CGAL::Data_access&lt;Point_vector_map&gt;</a>(gradient_function),</div><div class="line">                                         Traits());</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(res.second)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Tested interpolation on "</span> &lt;&lt; p</div><div class="line">              &lt;&lt; <span class="stringliteral">" interpolation: "</span> &lt;&lt; res.first &lt;&lt; <span class="stringliteral">" exact: "</span></div><div class="line">              &lt;&lt; a + bx*p.x() + by*p.y() + c*(p.x()*p.x()+p.y()*p.y())</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"C^1 Interpolation not successful."</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">" not all gradients are provided."</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">" You may resort to linear interpolation."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>The example <a class="el" href="Interpolation_2interpolation_2_8cpp-example.html">interpolation_2.cpp </a> compares numerically the errors of the different interpolation functions with respect to a known function.</p>
<h2><a class="anchor" id="InterpolationExampleVertices"></a>
Example for Storing Values and Gradients in Vertices</h2>
<p>In the previous examples, we have stored the values and gradients in a <code>std::map</code> and wrapped them in a <code><a class="el" href="structCGAL_1_1Data__access.html" title="The struct Data_access implements a functor that allows to retrieve data from an associative containe...">CGAL::Data_access</a></code> object. We can avoid this "external" storage by using the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__with__info__2.html">Triangulation_vertex_base_with_info_2</a></code> provided by the triangulation package: values and gradients can be stored directly in the vertices of the triangulation. Functors and output iterators requested by the gradient fitting and interpolation functions are then simply wrappers providing read/write accesses to the <code>info</code> member of the vertices. This approach is shown in the example below.</p>
<p><br />
<b>File</b> <a class="el" href="Interpolation_2sibson_interpolation_vertex_with_info_2_8cpp-example.html">Interpolation/sibson_interpolation_vertex_with_info_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_data_structure_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/natural_neighbor_coordinates_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Interpolation_gradient_fitting_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/sibson_gradient_fitting.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/interpolation_functions.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Interpolation__gradient__fitting__traits__2.html">CGAL::Interpolation_gradient_fitting_traits_2&lt;K&gt;</a>    Traits;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> K::FT                                               Coord_type;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                          Point;</div><div class="line"><span class="keyword">typedef</span> K::Vector_2                                         Vector;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> G&gt;</div><div class="line"><span class="keyword">struct </span>Value_and_gradient</div><div class="line">{</div><div class="line">  Value_and_gradient() : value(), gradient(<a class="code" href="namespaceCGAL.html">CGAL</a>::<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">NULL_VECTOR</a>) {}</div><div class="line"></div><div class="line">  V value;</div><div class="line">  G gradient;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__with__info__2.html">CGAL::Triangulation_vertex_base_with_info_2</a>&lt;</div><div class="line">                Value_and_gradient&lt;Coord_type, Vector&gt;, K&gt;  Vb;</div><div class="line"><span class="keyword">typedef</span> CGAL::Triangulation_data_structure_2&lt;Vb&gt;            Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K,Tds&gt;</a>               Delaunay_triangulation;</div><div class="line"><span class="keyword">typedef</span> Delaunay_triangulation::Vertex_handle               Vertex_handle;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>Value_function</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> V                                                 argument_type;</div><div class="line">  <span class="keyword">typedef</span> std::pair&lt;T, bool&gt;                                result_type;</div><div class="line"></div><div class="line">  <span class="comment">// read operation</span></div><div class="line">  result_type operator()(<span class="keyword">const</span> argument_type&amp; a)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> result_type(a-&gt;info().value, <span class="keyword">true</span>);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> G&gt;</div><div class="line"><span class="keyword">struct </span>Gradient_function</div><div class="line">  : <span class="keyword">public</span> std::iterator&lt;std::output_iterator_tag, void, void, void, void&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> V                                                argument_type;</div><div class="line">  <span class="keyword">typedef</span> std::pair&lt;G, bool&gt;                               result_type;</div><div class="line"></div><div class="line">  <span class="comment">// read operation</span></div><div class="line">  result_type operator()(<span class="keyword">const</span> argument_type&amp; a)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> std::make_pair(a-&gt;info().gradient, a-&gt;info().gradient != <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// write operation</span></div><div class="line">  <span class="keyword">const</span> Gradient_function&amp; operator=(<span class="keyword">const</span> std::pair&lt;V, G&gt;&amp; p)<span class="keyword"> const </span>{</div><div class="line">    p.first-&gt;info().gradient = p.second;</div><div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Gradient_function&amp; operator++(<span class="keywordtype">int</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div><div class="line">  <span class="keyword">const</span> Gradient_function&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__Kernel__operator__prod.html#ga8427cff04588dc338b8acf3e1b116dce">operator*</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Delaunay_triangulation dt;</div><div class="line"></div><div class="line">  <span class="comment">// Note that a supported alternative to creating the functors below is to use lambdas</span></div><div class="line">  Value_function&lt;Vertex_handle, Coord_type&gt; value_function;</div><div class="line">  Gradient_function&lt;Vertex_handle, Vector&gt; gradient_function;</div><div class="line"></div><div class="line">  <span class="comment">// parameters for spherical function:</span></div><div class="line">  Coord_type a(0.25), bx(1.3), by(-0.7), c(0.2);</div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0 ; y&lt;4 ; ++y) {</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0 ; x&lt;4 ; ++x) {</div><div class="line">      K::Point_2 p(x,y);</div><div class="line">      Vertex_handle vh = dt.insert(p);</div><div class="line">      Coord_type value = a + bx* x+ by*y + c*(x*x+y*y);</div><div class="line">      vh-&gt;info().value = value; <span class="comment">// store the value directly in the vertex</span></div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgInterpolationSibsonGradientFitting.html#ga2063ef2d118d601f4d0789ffcf2c191f">CGAL::sibson_gradient_fitting_nn_2</a>(dt,</div><div class="line">                                     gradient_function,</div><div class="line">                                     <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Identity.html">CGAL::Identity</a>&lt;std::pair&lt;Vertex_handle, Vector&gt; &gt;(),</div><div class="line">                                     value_function,</div><div class="line">                                     Traits());</div><div class="line"></div><div class="line">  <span class="comment">// coordinate computation</span></div><div class="line">  K::Point_2 p(1.6, 1.4);</div><div class="line">  std::vector&lt;std::pair&lt;Vertex_handle, Coord_type&gt; &gt; coords;</div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Identity.html">CGAL::Identity&lt;std::pair&lt;Vertex_handle, Coord_type&gt;</a> &gt; Identity;</div><div class="line">  Coord_type norm = <a class="code" href="group__PkgInterpolationNaturalNeighborCoordinates2.html#ga7bff652e1106089e701ebc64b371a966">CGAL::natural_neighbor_coordinates_2</a>(dt,</div><div class="line">                                                         p,</div><div class="line">                                                         std::back_inserter(coords),</div><div class="line">                                                         Identity()).second;</div><div class="line"></div><div class="line">  <span class="comment">// Sibson interpolant: version without sqrt:</span></div><div class="line">  std::pair&lt;Coord_type, bool&gt; res = <a class="code" href="group__PkgInterpolation2Interpolation.html#ga1f84e03a02a6602d45c26f600a6d225b">CGAL::sibson_c1_interpolation_square</a>(coords.begin(),</div><div class="line">                                                                         coords.end(),</div><div class="line">                                                                         norm,</div><div class="line">                                                                         p,</div><div class="line">                                                                         value_function,</div><div class="line">                                                                         gradient_function,</div><div class="line">                                                                         Traits());</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(res.second)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Tested interpolation on "</span> &lt;&lt; p</div><div class="line">              &lt;&lt; <span class="stringliteral">" interpolation: "</span> &lt;&lt; res.first &lt;&lt; <span class="stringliteral">" exact: "</span></div><div class="line">              &lt;&lt; a + bx*p.x() + by*p.y() + c*(p.x()*p.x() + p.y()*p.y())</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"C^1 Interpolation not successful."</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">" not all function_gradients are provided."</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">" You may resort to linear interpolation."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Interpolation"></a>
Design and Implementation History</h1>
<p>The original version was written by Julia Fl√∂totto, while working towards her PhD thesis at Inria. The possibility to use values and gradients in a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__with__info__2.html">Triangulation_vertex_base_with_info_2</a></code> was introduced by Andreas Fabri and Mael Rouxel-Labb√© working at GeometryFactory. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:43 for CGAL 4.13 - 2D and Surface Function Interpolation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
