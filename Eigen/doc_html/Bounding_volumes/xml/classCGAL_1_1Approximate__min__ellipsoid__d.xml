<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classCGAL_1_1Approximate__min__ellipsoid__d" kind="class" language="C++" prot="public">
    <compoundname>CGAL::Approximate_min_ellipsoid_d</compoundname>
    <includes local="no">CGAL/Approximate_min_ellipsoid_d.h</includes>
    <templateparamlist>
      <param>
        <type>typename Traits</type>
      </param>
    </templateparamlist>
      <sectiondef kind="user-defined">
      <header>Types</header>
      <memberdef kind="typedef" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a700b439e58f13a26cdc86ca4d156a88c" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::FT</definition>
        <argsstring></argsstring>
        <name>FT</name>
        <briefdescription>
<para><computeroutput>typedef Traits::FT FT</computeroutput> (which is always a typedef to <computeroutput>double</computeroutput>). </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="154" column="1" bodyfile="CGAL/Approximate_min_ellipsoid_d.h" bodystart="154" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Approximate__min__ellipsoid__d_1ae80e0c15bae383fdbb2e72d8643fafc3" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::ET</definition>
        <argsstring></argsstring>
        <name>ET</name>
        <briefdescription>
<para><computeroutput>typedef Traits::ET ET</computeroutput> (which is an exact number type used for exact computation like for example in <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a9f9fad4c126ae57c4cd3727d9283229f" kindref="member">achieved_epsilon()</ref></computeroutput>). </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="159" column="1" bodyfile="CGAL/Approximate_min_ellipsoid_d.h" bodystart="159" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a4a9ec257e6b8cb639810f3805316e68e" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::Point</definition>
        <argsstring></argsstring>
        <name>Point</name>
        <briefdescription>
<para><computeroutput>typedef Traits::Point Point</computeroutput> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="164" column="1" bodyfile="CGAL/Approximate_min_ellipsoid_d.h" bodystart="164" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Approximate__min__ellipsoid__d_1adf47ed5aabdb6ad61f6efac038e2fb41" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::Cartesian_const_iterator</definition>
        <argsstring></argsstring>
        <name>Cartesian_const_iterator</name>
        <briefdescription>
<para><computeroutput>typedef Traits::Cartesian_const_iterator Cartesian_const_iterator</computeroutput> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="169" column="1" bodyfile="CGAL/Approximate_min_ellipsoid_d.h" bodystart="169" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Approximate__min__ellipsoid__d_1aff46f1085c9c9ccb446a8e57221ae157" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::Center_coordinate_iterator</definition>
        <argsstring></argsstring>
        <name>Center_coordinate_iterator</name>
        <briefdescription>
<para>A model of STL concept <computeroutput><ref refid="classRandomAccessIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref></computeroutput> with value type <computeroutput>double</computeroutput> that is used to iterate over the <ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref> center coordinates of the computed ellipsoid, see <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aa687dcedc9b78b06f4c0e2aba9edb592" kindref="member">center_cartesian_begin()</ref></computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="177" column="1" bodyfile="CGAL/Approximate_min_ellipsoid_d.h" bodystart="177" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a72cb50febc6d4c7c24c68a8016bde351" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::Axes_lengths_iterator</definition>
        <argsstring></argsstring>
        <name>Axes_lengths_iterator</name>
        <briefdescription>
<para>A model of STL concept <computeroutput><ref refid="classRandomAccessIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref></computeroutput> with value type <computeroutput>double</computeroutput> that is used to iterate over the lengths of the semiaxes of the computed ellipsoid, see <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aeb6940806e45031a391baf58c735ec13" kindref="member">axes_lengths_begin()</ref></computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="185" column="1" bodyfile="CGAL/Approximate_min_ellipsoid_d.h" bodystart="185" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a6b628b719e381d78e16d8535f7cbc6d0" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::Axis_direction_iterator</definition>
        <argsstring></argsstring>
        <name>Axis_direction_iterator</name>
        <briefdescription>
<para>A model of STL concept <computeroutput><ref refid="classRandomAccessIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref></computeroutput> with value type <computeroutput>double</computeroutput> that is used to iterate over the Cartesian coordinates of the direction of a fixed axis of the computed ellipsoid, see <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ac04a27480671bd6e5a2eb4cc01fa47e2" kindref="member">axis_direction_cartesian_begin()</ref></computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="194" column="1" bodyfile="CGAL/Approximate_min_ellipsoid_d.h" bodystart="194" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Creation</header>
      <description><para>An object of type <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d" kindref="compound">Approximate_min_ellipsoid_d</ref></computeroutput> can be created from an arbitrary point set <formula id="9">$ P$</formula> and some nonnegative <computeroutput>double</computeroutput> value <computeroutput>eps</computeroutput>. </para></description>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a5fc0bc1c66b59556c903bfbc844f15fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Iterator</ref></type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::Approximate_min_ellipsoid_d</definition>
        <argsstring>(double eps, Iterator first, Iterator last, const Traits &amp;traits=Traits())</argsstring>
        <name>Approximate_min_ellipsoid_d</name>
        <param>
          <type>double</type>
          <declname>eps</declname>
        </param>
        <param>
          <type><ref refid="classIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Iterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Iterator</ref></type>
          <declname>last</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
          <defval>Traits()</defval>
        </param>
        <briefdescription>
<para>initializes <computeroutput>ame</computeroutput> to an <formula id="14">$ (1+\epsilon)$</formula>-approximation of <formula id="10">$ \mel(P)$</formula> with <formula id="9">$ P$</formula> being the set of points in the range [<computeroutput>first</computeroutput>,<computeroutput>last</computeroutput>). </para>        </briefdescription>
        <detaileddescription>
<para>The number <formula id="21">$ \epsilon$</formula> in this will be at most <computeroutput>eps</computeroutput>, if possible. However, due to the limited precision in the algorithm&apos;s underlying arithmetic, it can happen that the computed approximation ellipsoid has a worse approximation ratio (and <formula id="21">$ \epsilon$</formula> can thus be larger than <computeroutput>eps</computeroutput> in general). In any case, the number <formula id="21">$ \epsilon$</formula> (and with this, the achived approximation <formula id="17">$ 1+\epsilon$</formula>) can be queried by calling the routine <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a9f9fad4c126ae57c4cd3727d9283229f" kindref="member">achieved_epsilon()</ref></computeroutput> discussed below.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername><ref refid="classIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Iterator</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></computeroutput> with <computeroutput>Point</computeroutput> as value type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="pre"><para>The dimension <formula id="0">$ d$</formula> of the input points must be at least <formula id="38">$ 2$</formula>, and <formula id="19">$ \epsilon&gt;0$</formula>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="223" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Access Functions</header>
      <description><para>The following methods can be used to query the achieved approximation ratio <formula id="29">$ 1+\epsilon&apos;$</formula> and the computed ellipsoid <formula id="44">$ {\cal E} = \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq 0 \}$</formula>.</para><para>The methods <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a32b71cb636acb2f6b34e96465c5379e0" kindref="member">defining_matrix()</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a4aa3e857cdd79771f39aad531157b5f0" kindref="member">defining_vector()</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ad54fb77e5183d93d86840ba89ea95478" kindref="member">defining_scalar()</ref></computeroutput> do not return <formula id="4">$ E$</formula>, <formula id="6">$ e$</formula>, and <formula id="45">$ \eta$</formula> directly but yield multiples of these quantities that are exactly representable using the <computeroutput>double</computeroutput> type. (This is necessary because the parameters <formula id="4">$ E$</formula>, <formula id="6">$ e$</formula>, and <formula id="45">$ \eta$</formula> of the computed approximation ellipsoid <formula id="26">$ {\cal E}$</formula> might not be exactly representable as <computeroutput>double</computeroutput> numbers.) In order to access the center and semiaxes of the computed approximation ellipsoid, the functions <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aa687dcedc9b78b06f4c0e2aba9edb592" kindref="member">center_cartesian_begin()</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aeb6940806e45031a391baf58c735ec13" kindref="member">axes_lengths_begin()</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ac04a27480671bd6e5a2eb4cc01fa47e2" kindref="member">axis_direction_cartesian_begin()</ref></computeroutput> can be used. In constrast to the above access functions <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a9f9fad4c126ae57c4cd3727d9283229f" kindref="member">achieved_epsilon()</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a32b71cb636acb2f6b34e96465c5379e0" kindref="member">defining_matrix()</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a4aa3e857cdd79771f39aad531157b5f0" kindref="member">defining_vector()</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ad54fb77e5183d93d86840ba89ea95478" kindref="member">defining_scalar()</ref></computeroutput>, which return the described quantities exactly, the routines below return <emphasis>numerical approximations</emphasis> to the real center and real semiaxes of the computed ellipsoid; the comprised relative error may be larger than zero, and there are no guarantees for the returned quantities. </para></description>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a747a40738dc64031ddf3bb09144c7984" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned int</type>
        <definition>unsigned int CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::number_of_points</definition>
        <argsstring>() const</argsstring>
        <name>number_of_points</name>
        <briefdescription>
<para>returns the number of points of <computeroutput>ame</computeroutput>, i.e., <formula id="46">$ |P|$</formula>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="257" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a9f9fad4c126ae57c4cd3727d9283229f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::achieved_epsilon</definition>
        <argsstring>() const</argsstring>
        <name>achieved_epsilon</name>
        <briefdescription>
<para>returns a number <formula id="30">$ \epsilon&apos;$</formula> such that the computed approximation is (under exact arithmetic) guaranteed to be an <formula id="47">$ (1+\epsilon&apos;)$</formula>-approximation to <formula id="10">$ \mel(P)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><computeroutput>ame.is_full_dimensional() == true</computeroutput>. </para></simplesect>
<simplesect kind="post"><para><formula id="48">$ \epsilon&apos;&gt;0$</formula>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="267" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a32b71cb636acb2f6b34e96465c5379e0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::defining_matrix</definition>
        <argsstring>(int i, int j) const</argsstring>
        <name>defining_matrix</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>j</declname>
        </param>
        <briefdescription>
<para>gives access to the <formula id="49">$ (i,j)$</formula>th entry of the matrix <formula id="4">$ E$</formula> in the representation <formula id="50">$ \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq0 \}$</formula> of the computed approximation ellipsoid <formula id="26">$ {\cal E}$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>The number returned by this routine is <formula id="51">$ (1+\epsilon&apos;)(d+1)\,E_{ij}$</formula>, where <formula id="30">$ \epsilon&apos;$</formula> is the number returned by <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a9f9fad4c126ae57c4cd3727d9283229f" kindref="member">achieved_epsilon()</ref></computeroutput>. <simplesect kind="pre"><para><formula id="52">$ 0\leq i,j\leq d$</formula>, where <formula id="0">$ d$</formula> is the dimension of the points <formula id="9">$ P$</formula>, and <computeroutput>ame.is_full_dimensional() == true</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="278" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a4aa3e857cdd79771f39aad531157b5f0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::defining_vector</definition>
        <argsstring>(int i) const</argsstring>
        <name>defining_vector</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>gives access to the <formula id="53">$ i$</formula>th entry of the vector <formula id="6">$ e$</formula> in the representation <formula id="50">$ \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq0 \}$</formula> of the computed approximation ellipsoid <formula id="26">$ {\cal E}$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>The number returned by this routine is <formula id="54">$ (1+\epsilon&apos;)(d+1)\,e_{i}$</formula>, where <formula id="30">$ \epsilon&apos;$</formula> is the number returned by <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a9f9fad4c126ae57c4cd3727d9283229f" kindref="member">achieved_epsilon()</ref></computeroutput>. <simplesect kind="pre"><para><formula id="55">$ 0\leq i\leq d$</formula>, where <formula id="0">$ d$</formula> is the dimension of the points <formula id="9">$ P$</formula>, and <computeroutput>ame.is_full_dimensional() == true</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="289" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1ad54fb77e5183d93d86840ba89ea95478" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::defining_scalar</definition>
        <argsstring>() const</argsstring>
        <name>defining_scalar</name>
        <briefdescription>
<para>gives access to the scalar <formula id="45">$ \eta$</formula> from the representation <formula id="50">$ \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq0 \}$</formula> of the computed approximation ellipsoid <formula id="26">$ {\cal E}$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>The number returned by this routine is <formula id="56">$ (1+\epsilon&apos;)(d+1)\,(\eta+1)$</formula>, where <formula id="30">$ \epsilon&apos;$</formula> is the number returned by <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a9f9fad4c126ae57c4cd3727d9283229f" kindref="member">achieved_epsilon()</ref></computeroutput>. <simplesect kind="pre"><para><computeroutput>ame.is_full_dimensional() == true</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="300" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1ac5ae03954e671b379a3879563ef023db" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const Traits &amp;</type>
        <definition>const Traits&amp; CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::traits</definition>
        <argsstring>() const</argsstring>
        <name>traits</name>
        <briefdescription>
<para>returns a const reference to the traits class object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="306" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a6642c2338f25f191e95232126bf9e729" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::dimension</definition>
        <argsstring>() const</argsstring>
        <name>dimension</name>
        <briefdescription>
<para>returns the dimension of the ambient space, i.e., the dimension of the points <formula id="9">$ P$</formula>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="312" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1aa687dcedc9b78b06f4c0e2aba9edb592" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aff46f1085c9c9ccb446a8e57221ae157" kindref="member">Center_coordinate_iterator</ref></type>
        <definition>Center_coordinate_iterator CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::center_cartesian_begin</definition>
        <argsstring>()</argsstring>
        <name>center_cartesian_begin</name>
        <briefdescription>
<para>returns an iterator pointing to the first of the <formula id="0">$ d$</formula> <ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref> coordinates of the computed ellipsoid&apos;s center. </para>        </briefdescription>
        <detaileddescription>
<para>The returned point is a floating-point approximation to the ellipsoid&apos;s exact center; no guarantee is given w.r.t. the involved relative error. <simplesect kind="pre"><para><computeroutput>ame.is_full_dimensional() == true</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="323" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1adb4dccfd4a16fe59e095c57d94498582" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aff46f1085c9c9ccb446a8e57221ae157" kindref="member">Center_coordinate_iterator</ref></type>
        <definition>Center_coordinate_iterator CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::center_cartesian_end</definition>
        <argsstring>()</argsstring>
        <name>center_cartesian_end</name>
        <briefdescription>
<para>returns the past-the-end iterator corresponding to <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aa687dcedc9b78b06f4c0e2aba9edb592" kindref="member">center_cartesian_begin()</ref></computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><computeroutput>ame.is_full_dimensional() == true</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="331" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1aeb6940806e45031a391baf58c735ec13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a72cb50febc6d4c7c24c68a8016bde351" kindref="member">Axes_lengths_iterator</ref></type>
        <definition>Axes_lengths_iterator CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::axes_lengths_begin</definition>
        <argsstring>()</argsstring>
        <name>axes_lengths_begin</name>
        <briefdescription>
<para>returns an iterator pointing to the first of the <formula id="0">$ d$</formula> descendantly sorted lengths of the computed ellipsoid&apos;s axes. </para>        </briefdescription>
        <detaileddescription>
<para>The <formula id="0">$ d$</formula> returned numbers are floating-point approximations to the exact axes-lengths of the computed ellipsoid; no guarantee is given w.r.t. the involved relative error. (See also method <computeroutput>axes_direction_cartesian_begin()</computeroutput>.) <simplesect kind="pre"><para><computeroutput>ame.is_full_dimensional() == true</computeroutput>, and <formula id="57">$ d\in\{2,3\}$</formula>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="342" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a25d9a8946ab4c81f8dbfb45dddb7f701" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a72cb50febc6d4c7c24c68a8016bde351" kindref="member">Axes_lengths_iterator</ref></type>
        <definition>Axes_lengths_iterator CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::axes_lengths_end</definition>
        <argsstring>()</argsstring>
        <name>axes_lengths_end</name>
        <briefdescription>
<para>returns the past-the-end iterator corresponding to <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aeb6940806e45031a391baf58c735ec13" kindref="member">axes_lengths_begin()</ref></computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><computeroutput>ame.is_full_dimensional() == true</computeroutput>, and <formula id="57">$ d\in\{2,3\}$</formula>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="349" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1ac04a27480671bd6e5a2eb4cc01fa47e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Axes_direction_coordinate_iterator</type>
        <definition>Axes_direction_coordinate_iterator CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::axis_direction_cartesian_begin</definition>
        <argsstring>(int i)</argsstring>
        <name>axis_direction_cartesian_begin</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>returns an iterator pointing to the first of the <formula id="0">$ d$</formula> Cartesian coordinates of the computed ellipsoid&apos;s <formula id="53">$ i$</formula>th axis direction (i.e., unit vector in direction of the ellipsoid&apos;s <formula id="53">$ i$</formula>th axis). </para>        </briefdescription>
        <detaileddescription>
<para>The direction described by this iterator is a floating-point approximation to the exact axis direction of the computed ellipsoid; no guarantee is given w.r.t. the involved relative error. An approximation to the length of axis <formula id="53">$ i$</formula> is given by the <formula id="53">$ i$</formula>th entry of <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aeb6940806e45031a391baf58c735ec13" kindref="member">axes_lengths_begin()</ref></computeroutput>. <simplesect kind="pre"><para><computeroutput>ame.is_full_dimensional() == true</computeroutput>, and <formula id="57">$ d\in\{2,3\}$</formula>, and <formula id="58">$ 0\leq i &lt; d$</formula>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="364" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a7e8f229884c9903afa2aa39155c08f29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Axes_direction_coordinate_iterator</type>
        <definition>Axes_direction_coordinate_iterator CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::axis_direction_cartesian_end</definition>
        <argsstring>(int i)</argsstring>
        <name>axis_direction_cartesian_end</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>returns the past-the-end iterator corresponding to <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ac04a27480671bd6e5a2eb4cc01fa47e2" kindref="member">axis_direction_cartesian_begin()</ref></computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><computeroutput>ame.is_full_dimensional() == true</computeroutput>, and <formula id="57">$ d\in\{2,3\}$</formula>, and <formula id="58">$ 0\leq i &lt; d$</formula>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="372" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Predicates</header>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a636b12855568f4471e0dadc3d6fefb3f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::is_full_dimensional</definition>
        <argsstring>() const</argsstring>
        <name>is_full_dimensional</name>
        <briefdescription>
<para>returns whether <formula id="9">$ P$</formula> is full-dimensional or not, i.e., returns <computeroutput>true</computeroutput> if and only if <formula id="9">$ P$</formula> is full-dimensional. </para>        </briefdescription>
        <detaileddescription>
<para><emphasis>Note:</emphasis> due to the limited precision in the algorithm&apos;s underlying arithmetic, the result of this method is not always correct. Rather, a return value of <computeroutput>false</computeroutput> means that the points <formula id="9">$ P$</formula> are contained in a &quot;very thin&quot; linear subspace of <formula id="1">$ \E^d$</formula>, and as a consequence, the algorithm cannot compute an approximation. More precisely, a return value of <computeroutput>false</computeroutput> means that the points <formula id="9">$ P$</formula> are contained between two parallel hyperplanes in <formula id="1">$ \E^d$</formula> that are very close to each other (possibly at distance zero) - so close, that the algorithm could not compute an approximation ellipsoid. Similarly, a return value of <computeroutput>true</computeroutput> does not guarantee <formula id="9">$ P$</formula> to be full-dimensional; but there exists an input pointset <formula id="59">$ P&apos;$</formula> such that the points <formula id="59">$ P&apos;$</formula> and <formula id="9">$ P$</formula> have almost identical coordinates and <formula id="59">$ P&apos;$</formula> is full-dimensional. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="399" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Validity Check</header>
      <description><para>An object <computeroutput>ame</computeroutput> is valid iff</para><para><itemizedlist>
<listitem>
<para><computeroutput>ame</computeroutput> contains all points of its defining set <formula id="9">$ P$</formula>, </para></listitem>
<listitem>
<para><computeroutput>ame</computeroutput> is an <formula id="47">$ (1+\epsilon&apos;)$</formula>-approximation to the smallest ellipsoid <formula id="10">$ \mel(P)$</formula> of <formula id="9">$ P$</formula>, </para></listitem>
<listitem>
<para>The ellipsoid represented by <computeroutput>ame</computeroutput> fulfills the inclusion ( <ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1eqapproximate_min_ellipsoid_incl" kindref="member">eqapproximate_min_ellipsoid_incl</ref> ). </para></listitem>
</itemizedlist>
</para></description>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a2449d677fe6d12a445d5a090723d9349" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::is_valid</definition>
        <argsstring>(bool verbose=false) const</argsstring>
        <name>is_valid</name>
        <param>
          <type>bool</type>
          <declname>verbose</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>ame</computeroutput> is valid according to the above definition. </para>        </briefdescription>
        <detaileddescription>
<para>If <computeroutput>verbose</computeroutput> is <computeroutput>true</computeroutput>, some messages concerning the performed checks are written to the standard error stream. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="419" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Miscellaneous</header>
      <memberdef kind="function" id="classCGAL_1_1Approximate__min__ellipsoid__d_1a1cd41640f8cf8b562772399a0fb00b13" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;::write_eps</definition>
        <argsstring>(const std::string &amp;name) const</argsstring>
        <name>write_eps</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Writes the points <formula id="9">$ P$</formula> and the computed approximation to <formula id="10">$ \mel(P)$</formula> as an EPS-file under pathname <computeroutput>name</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para>The dimension of points <formula id="9">$ P$</formula> must be <formula id="38">$ 2$</formula>. <emphasis>Note:</emphasis> this routine is provided as a debugging routine; future version of CGAL might not provide it anymore. </para></simplesect>
<simplesect kind="pre"><para><computeroutput>ame.is_full_dimensional() == true</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Approximate_min_ellipsoid_d.h" line="435" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>An object of class <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d" kindref="compound">Approximate_min_ellipsoid_d</ref></computeroutput> is an approximation to the ellipsoid of smallest volume enclosing a finite multiset of points in <formula id="0">$ d$</formula>-dimensional Euclidean space <formula id="1">$ \E^d$</formula>, <formula id="2">$ d\ge 2$</formula>. </para>    </briefdescription>
    <detaileddescription>
<para>An <emphasis>ellipsoid</emphasis> in <formula id="1">$ \E^d$</formula> is a <ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref> pointset of the form <formula id="3">$ \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq 0 \}$</formula>, where <formula id="4">$ E$</formula> is some positive definite matrix from the set <formula id="5">$ \mathbb{R}^{d\times d}$</formula>, <formula id="6">$ e$</formula> is some real <formula id="0">$ d$</formula>-vector, and <formula id="7">$ \eta\in\mathbb{R}$</formula>. A pointset <formula id="8">$ P\subseteq \E^d$</formula> is called <emphasis>full-dimensional</emphasis> if its affine hull has dimension <formula id="0">$ d$</formula>. For a finite, full-dimensional pointset <formula id="9">$ P$</formula> we denote by <formula id="10">$ \mel(P)$</formula> the smallest ellipsoid that contains all points of <formula id="9">$ P$</formula>; this ellipsoid exists and is unique.</para><para>For a given finite and full-dimensional pointset <formula id="11">$ P\subset \E^d$</formula> and a real number <formula id="12">$ \epsilon\ge 0$</formula>, we say that an ellipsoid <formula id="13">$ {\cal E}\subset\E^d$</formula> is an <emphasis> <formula id="14">$ (1+\epsilon)$</formula>-appoximation</emphasis> to <formula id="10">$ \mel(P)$</formula> if <formula id="15">$ P\subset {\cal E}$</formula> and <formula id="16">$ \vol({\cal E}) \leq (1+\epsilon) \vol(\mel(P))$</formula>. In other words, an <formula id="14">$ (1+\epsilon)$</formula>-approximation to <formula id="10">$ \mel(P)$</formula> is an enclosing ellipsoid whose volume is by at most a factor of <formula id="17">$ 1+\epsilon$</formula> larger than the volume of the smallest enclosing ellipsoid of <formula id="9">$ P$</formula>.</para><para>Given this notation, an object of class <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d" kindref="compound">Approximate_min_ellipsoid_d</ref></computeroutput> represents an <formula id="14">$ (1+\epsilon)$</formula>-approximation to <formula id="10">$ \mel(P)$</formula> for a given finite and full-dimensional multiset of points <formula id="18">$ P\subset\E^d$</formula> and a real constant <formula id="19">$ \epsilon&gt;0$</formula>.A <emphasis>multiset</emphasis> is a set where elements may have multiplicity greater than <formula id="20">$ 1$</formula>. When an <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d" kindref="compound">Approximate_min_ellipsoid_d</ref>&lt;Traits&gt;</computeroutput> object is constructed, an iterator over the points <formula id="9">$ P$</formula> and the number <formula id="21">$ \epsilon$</formula> have to be specified; the number <formula id="21">$ \epsilon$</formula> defines the <emphasis>desired approximation ratio</emphasis> <formula id="17">$ 1+\epsilon$</formula>. The underlying algorithm will then try to compute an <formula id="14">$ (1+\epsilon)$</formula>-approximation to <formula id="10">$ \mel(P)$</formula>, and one of the following two cases takes place. <itemizedlist>
<listitem>
<para>The algorithm determines that <formula id="9">$ P$</formula> is not full-dimensional (see <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a636b12855568f4471e0dadc3d6fefb3f" kindref="member">is_full_dimensional()</ref></computeroutput> below).</para><para><emphasis>Important note:</emphasis> due to rounding errors, the algorithm cannot in all cases decide correctly whether <formula id="9">$ P$</formula> is full-dimensional or not. If <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a636b12855568f4471e0dadc3d6fefb3f" kindref="member">is_full_dimensional()</ref></computeroutput> returns <computeroutput>false</computeroutput>, the points lie in such a &quot;thin&quot; subspace of <formula id="1">$ \E^d$</formula> that the algorithm is incapable of computing an approximation to <formula id="10">$ \mel(P)$</formula>. More precisely, if <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a636b12855568f4471e0dadc3d6fefb3f" kindref="member">is_full_dimensional()</ref></computeroutput> returns <computeroutput>false</computeroutput>, there exist two parallel hyperplanes in <formula id="1">$ \E^d$</formula> with the points <formula id="9">$ P$</formula> in between so that the distance <formula id="22">$ \delta$</formula> between the hyperplanes is very small, possible zero. (If <formula id="23">$ \delta=0$</formula> then <formula id="9">$ P$</formula> is not full-dimensional.)</para><para>If <formula id="9">$ P$</formula> is not full-dimensional, linear algebra techniques should be used to determine an affine subspace <formula id="24">$ S$</formula> of <formula id="1">$ \E^d$</formula> that contains the points <formula id="9">$ P$</formula> as a (w.r.t. <formula id="24">$ S$</formula>) full-dimensional pointset; once <formula id="24">$ S$</formula> is determined, the algorithm can be invoked again to compute an approximation to (the lower-dimensional) <formula id="10">$ \mel(P)$</formula> in <formula id="24">$ S$</formula>. Since <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a636b12855568f4471e0dadc3d6fefb3f" kindref="member">is_full_dimensional()</ref></computeroutput> might (due to rounding errors, see above) return <computeroutput>false</computeroutput> even though <formula id="9">$ P$</formula> is full-dimensional, the lower-dimensional subspace <formula id="24">$ S$</formula> containing <formula id="9">$ P$</formula> need not exist. Therefore, it might be more advisable to fit a hyperplane <formula id="25">$ H$</formula> through the pointset <formula id="9">$ P$</formula>, project <formula id="9">$ P$</formula> onto this affine subspace <formula id="25">$ H$</formula>, and compute an approximation to the minimum-volume enclosing ellipsoid of the projected points within <formula id="25">$ H$</formula>; the fitting can be done for instance using the <computeroutput>linear_least_squares_fitting()</computeroutput> function from the CGAL package <computeroutput>Principal_component_analysis</computeroutput>. </para></listitem>
<listitem>
<para>The algorithm determines that <formula id="9">$ P$</formula> is full-dimensional. In this case, it provides an approximation <formula id="26">$ {\cal E}$</formula> to <formula id="10">$ \mel(P)$</formula>, but depending on the input problem (i.e., on the pair <formula id="27">$ (P,\epsilon)$</formula>), it may not have achieved the desired approximation ratio but merely some <emphasis>worse</emphasis> approximation ratio <formula id="28">$ 1+\epsilon&apos;&gt;1+\epsilon$</formula>. The achieved approximation ratio <formula id="29">$ 1+\epsilon&apos;$</formula> can be queried using <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a9f9fad4c126ae57c4cd3727d9283229f" kindref="member">achieved_epsilon()</ref></computeroutput>, which returns <formula id="30">$ \epsilon&apos;$</formula>. The ellipsoid <formula id="26">$ {\cal E}$</formula> itself can be queried via the methods <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a32b71cb636acb2f6b34e96465c5379e0" kindref="member">defining_matrix()</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a4aa3e857cdd79771f39aad531157b5f0" kindref="member">defining_vector()</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ad54fb77e5183d93d86840ba89ea95478" kindref="member">defining_scalar()</ref></computeroutput>. </para></listitem>
</itemizedlist>
</para><para>The ellipsoid <formula id="26">$ {\cal E}$</formula> computed by the algorithm satisfies the inclusions <anchor id="classCGAL_1_1Approximate__min__ellipsoid__d_1eqapproximate_min_ellipsoid_incl"/> <formula id="31">\[ \frac{1}{(1+\epsilon&apos;)d} {\cal E} \subseteq \mathop{\rm conv}\nolimits(P) \subseteq {\cal E} \]</formula> where <formula id="32">$ f {\cal E}$</formula> denotes the ellipsoid <formula id="26">$ {\cal E}$</formula> scaled by the factor <formula id="33">$ f\in\mathbb{R}^+$</formula> with respect to its center, and where <formula id="34">$ \mathop{\rm conv}\nolimits(A)$</formula> denotes the <emphasis>convex hull</emphasis> of a pointset <formula id="35">$ A\subset \E^d$</formula>.</para><para>The underlying algorithm can cope with all kinds of inputs (multisets <formula id="9">$ P$</formula>, <formula id="36">$ \epsilon\in[0,\infty)$</formula>) and terminates in all cases. There is, however, no guarantee that any desired approximation ratio is actually achieved; the performance of the algorithm in this respect highly depends on the input pointset. Values of at least <formula id="37">$ 0.01$</formula> for <formula id="21">$ \epsilon$</formula> are usually handled without problems.</para><para>Internally, the algorithm represents the input points&apos; <ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref> coordinates as <computeroutput>double</computeroutput>&apos;s. For this conversion to work, the input point coordinates must be convertible to <computeroutput>double</computeroutput>. Also, in order to compute the achieved epsilon <formula id="30">$ \epsilon&apos;$</formula> mentioned above, the algorithm requires a number type <computeroutput>ET</computeroutput> that provides <emphasis>exact</emphasis> arithmetic. (Both these aspects are discussed in the documentation of the concept <computeroutput><ref refid="classApproximateMinEllipsoid__d__Traits__d" kindref="compound">ApproximateMinEllipsoid_d_Traits_d</ref></computeroutput>.)</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Traits</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model for <computeroutput><ref refid="classApproximateMinEllipsoid__d__Traits__d" kindref="compound">ApproximateMinEllipsoid_d_Traits_d</ref></computeroutput>.</para></parameterdescription>
</parameteritem>
</parameterlist>
We provide the model <computeroutput><ref refid="structCGAL_1_1Approximate__min__ellipsoid__d__traits__d" kindref="compound">CGAL::Approximate_min_ellipsoid_d_traits_d</ref>&lt;K&gt;</computeroutput> using the <formula id="0">$ d$</formula>-dimensional CGAL kernel; the models <computeroutput><ref refid="structCGAL_1_1Approximate__min__ellipsoid__d__traits__2" kindref="compound">CGAL::Approximate_min_ellipsoid_d_traits_2</ref>&lt;K&gt;</computeroutput> and <computeroutput><ref refid="structCGAL_1_1Approximate__min__ellipsoid__d__traits__3" kindref="compound">CGAL::Approximate_min_ellipsoid_d_traits_3</ref>&lt;K&gt;</computeroutput> are for use with the <formula id="38">$ 2$</formula>- and <formula id="39">$ 3$</formula>-dimensional CGAL kernel, respectively.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Min__ellipse__2" kindref="compound">CGAL::Min_ellipse_2</ref>&lt;Traits&gt;</computeroutput></para></simplesect>
<bold>Implementation</bold><linebreak/>
</para><para>We implement Khachyian&apos;s algorithm for rounding polytopes <ref refid="citelist_1CITEREF_cgal:k-rprnm-96" kindref="member">[10]</ref>. Internally, we use <computeroutput>double</computeroutput>-arithmetic and (initially a single) Cholesky-decomposition. The algorithm&apos;s running time is <formula id="40">$ {\cal O}(nd^2(\epsilon^{-1}+\ln d + \ln\ln(n)))$</formula>, where <formula id="41">$ n=|P|$</formula> and <formula id="17">$ 1+\epsilon$</formula> is the desired approximation ratio.</para><para><bold>Example</bold><linebreak/>
</para><para>To illustrate the usage of <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d" kindref="compound">Approximate_min_ellipsoid_d</ref></computeroutput> we give two examples in 2D. The first program generates a random set <formula id="42">$ P\subset\E^2$</formula> and outputs the points and a <formula id="43">$ 1.01$</formula>-approximation of <formula id="10">$ \mel(P)$</formula> as an EPS-file, which you can view using <computeroutput>gv</computeroutput>, for instance. (In both examples you can change the variables <computeroutput>n</computeroutput> and <computeroutput>d</computeroutput> to experiment with the code.)</para><para><linebreak/>
<bold>File</bold> <ref refid="Approximate_min_ellipsoid_d_2ellipsoid_8cpp-example" kindref="compound">Approximate_min_ellipsoid_d/ellipsoid.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/MP_Float.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Approximate_min_ellipsoid_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Approximate_min_ellipsoid_d_traits_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Cartesian_d&lt;double&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::MP_Float<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ae80e0c15bae383fdbb2e72d8643fafc3" kindref="member">ET</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Approximate__min__ellipsoid__d__traits__d" kindref="compound">CGAL::Approximate_min_ellipsoid_d_traits_d&lt;Kernel, ET&gt;</ref><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a4a9ec257e6b8cb639810f3805316e68e" kindref="member">Point</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_list;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d" kindref="compound">CGAL::Approximate_min_ellipsoid_d&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AME;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>1000;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>number<sp/>of<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>d<sp/>=<sp/>2;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>dimension</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>eps<sp/>=<sp/>0.01;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>approximation<sp/>ratio<sp/>is<sp/>(1+eps)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>set<sp/>of<sp/>random<sp/>points:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_list<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_cube_d&lt;Point&gt;<sp/>rpg(d,100.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.push_back(*rpg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++rpg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>approximation:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ac5ae03954e671b379a3879563ef023db" kindref="member">traits</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AME<sp/>ame(eps,<sp/>P.begin(),<sp/>P.end(),<sp/><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ac5ae03954e671b379a3879563ef023db" kindref="member">traits</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>write<sp/>EPS<sp/>file:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ame.is_full_dimensional()<sp/>&amp;&amp;<sp/>d<sp/>==<sp/>2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ame.write_eps(</highlight><highlight class="stringliteral">&quot;example.eps&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>output<sp/>center<sp/>coordinates:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Cartesian<sp/>center<sp/>coordinates:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(AME::Center_coordinate_iterator<sp/>c_it<sp/>=<sp/>ame.center_cartesian_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c_it<sp/>!=<sp/>ame.center_cartesian_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++c_it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>*c_it<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(d<sp/>==<sp/>2<sp/>||<sp/>d<sp/>==<sp/>3)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>output<sp/><sp/>axes:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>AME::Axes_lengths_iterator<sp/>axes<sp/>=<sp/>ame.axes_lengths_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>d;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Semiaxis<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>has<sp/>length<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*axes++<sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;and<sp/>Cartesian<sp/>coordinates<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(AME::Axes_direction_coordinate_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>d_it<sp/>=<sp/>ame.axis_direction_cartesian_begin(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>d_it<sp/>!=<sp/>ame.axis_direction_cartesian_end(i);<sp/>++d_it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>*d_it<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The second program outputs the approximation in a format suitable for display in Maplesoft&apos;s Maple.</para><para><linebreak/>
<bold>File</bold> <ref refid="Approximate_min_ellipsoid_d_2ellipsoid_for_maple_8cpp-example" kindref="compound">Approximate_min_ellipsoid_d/ellipsoid_for_maple.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Usage:<sp/>./maple_example<sp/>&gt;<sp/>maple.text</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Then<sp/>enter<sp/>in<sp/>Maple<sp/>&apos;read<sp/>&quot;maple.text&quot;;&apos;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/MP_Float.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Approximate_min_ellipsoid_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Approximate_min_ellipsoid_d_traits_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iomanip&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Cartesian_d&lt;double&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::MP_Float<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ae80e0c15bae383fdbb2e72d8643fafc3" kindref="member">ET</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Approximate__min__ellipsoid__d__traits__d" kindref="compound">CGAL::Approximate_min_ellipsoid_d_traits_d&lt;Kernel, ET&gt;</ref><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a4a9ec257e6b8cb639810f3805316e68e" kindref="member">Point</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_list;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d" kindref="compound">CGAL::Approximate_min_ellipsoid_d&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AME;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>100;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>number<sp/>of<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>d<sp/>=<sp/>2;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>dimension</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>eps<sp/>=<sp/>0.01;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>approximation<sp/>ratio<sp/>is<sp/>(1+eps)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>set<sp/>of<sp/>random<sp/>points:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_list<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_cube_d&lt;Point&gt;<sp/>rpg(d,1.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.push_back(*rpg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++rpg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>approximation:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ac5ae03954e671b379a3879563ef023db" kindref="member">traits</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AME<sp/>mel(eps,<sp/>P.begin(),<sp/>P.end(),<sp/><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ac5ae03954e671b379a3879563ef023db" kindref="member">traits</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>output<sp/>for<sp/>Maple:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mel.is_full_dimensional()<sp/>&amp;&amp;<sp/>d<sp/>==<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>alpha<sp/>=<sp/>(1+mel.achieved_epsilon())*(d+1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>output<sp/>points:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>std::cout;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;restart;\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;with(LinearAlgebra):\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;with(plottools):\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;n:=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;P:=<sp/>Matrix(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>d<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;):\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;n;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j=0;<sp/>j&lt;d;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;P[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>j+1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i+1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/>:=<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::setiosflags(std::ios::scientific)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::setprecision(20)<sp/>&lt;&lt;<sp/>P[i][j]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>output<sp/>defining<sp/>equation:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Mp:=<sp/>Matrix([\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;d;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>[&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j=0;<sp/>j&lt;d;<sp/>++j)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>mel.defining_matrix(i,j)/alpha;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j&lt;d-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(i&lt;d-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]);\n&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;mp:=<sp/>Vector([&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;d;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>mel.defining_vector(i)/alpha;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(i&lt;d-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]);\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;eta:=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(mel.defining_scalar()/alpha-1.0)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;;\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;v:=<sp/>Vector([x,y]):\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;e:=<sp/>Transpose(v).Mp.v+Transpose(v).mp+eta;\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;plots[display]({seq(point([P[1,i],P[2,i]]),i=1..n),\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>plots[implicitplot](e,x=-5..5,y=-5..5,numpoints=10000)},\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>scaling=CONSTRAINED);\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><simplesect kind="note"><para>This class requires the <ref refid="installation_1thirdpartyEigen" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Eigen</ref> library. </para></simplesect>
</para>    </detaileddescription>
    <location file="CGAL/Approximate_min_ellipsoid_d.h" line="144" column="1" bodyfile="CGAL/Approximate_min_ellipsoid_d.h" bodystart="144" bodyend="439"/>
    <listofallmembers>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a9f9fad4c126ae57c4cd3727d9283229f" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>achieved_epsilon</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a5fc0bc1c66b59556c903bfbc844f15fa" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>Approximate_min_ellipsoid_d</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aeb6940806e45031a391baf58c735ec13" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>axes_lengths_begin</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a25d9a8946ab4c81f8dbfb45dddb7f701" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>axes_lengths_end</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a72cb50febc6d4c7c24c68a8016bde351" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>Axes_lengths_iterator</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ac04a27480671bd6e5a2eb4cc01fa47e2" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>axis_direction_cartesian_begin</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a7e8f229884c9903afa2aa39155c08f29" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>axis_direction_cartesian_end</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a6b628b719e381d78e16d8535f7cbc6d0" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>Axis_direction_iterator</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1adf47ed5aabdb6ad61f6efac038e2fb41" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>Cartesian_const_iterator</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aa687dcedc9b78b06f4c0e2aba9edb592" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>center_cartesian_begin</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1adb4dccfd4a16fe59e095c57d94498582" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>center_cartesian_end</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1aff46f1085c9c9ccb446a8e57221ae157" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>Center_coordinate_iterator</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a32b71cb636acb2f6b34e96465c5379e0" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>defining_matrix</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ad54fb77e5183d93d86840ba89ea95478" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>defining_scalar</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a4aa3e857cdd79771f39aad531157b5f0" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>defining_vector</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a6642c2338f25f191e95232126bf9e729" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>dimension</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ae80e0c15bae383fdbb2e72d8643fafc3" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>ET</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a700b439e58f13a26cdc86ca4d156a88c" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>FT</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a636b12855568f4471e0dadc3d6fefb3f" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>is_full_dimensional</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a2449d677fe6d12a445d5a090723d9349" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>is_valid</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a747a40738dc64031ddf3bb09144c7984" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>number_of_points</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a4a9ec257e6b8cb639810f3805316e68e" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>Point</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1ac5ae03954e671b379a3879563ef023db" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>traits</name></member>
      <member refid="classCGAL_1_1Approximate__min__ellipsoid__d_1a1cd41640f8cf8b562772399a0fb00b13" prot="public" virt="non-virtual"><scope>CGAL::Approximate_min_ellipsoid_d</scope><name>write_eps</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
