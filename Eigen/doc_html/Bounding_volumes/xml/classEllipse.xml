<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classEllipse" kind="class" language="C++" prot="public">
    <compoundname>Ellipse</compoundname>
    <includes local="no">Concepts/Ellipse.h</includes>
      <sectiondef kind="user-defined">
      <header>Types</header>
      <memberdef kind="typedef" id="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type Ellipse::Point</definition>
        <argsstring></argsstring>
        <name>Point</name>
        <briefdescription>
<para>Point type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="19" column="1" bodyfile="Concepts/Ellipse.h" bodystart="19" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Creation</header>
      <memberdef kind="function" id="classEllipse_1a6cca249806320e212249694db9000bcb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Ellipse::set</definition>
        <argsstring>()</argsstring>
        <name>set</name>
        <briefdescription>
<para>sets <computeroutput>ellipse</computeroutput> to the empty ellipse. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="29" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classEllipse_1a38f33c44e378813877ed62d3cfc7a2de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Ellipse::set</definition>
        <argsstring>(const Point &amp;p)</argsstring>
        <name>set</name>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>sets <computeroutput>ellipse</computeroutput> to the ellipse containing exactly <computeroutput>p</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="35" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classEllipse_1aceb0a1e7165a69ddafbc7762ca9a724b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Ellipse::set</definition>
        <argsstring>(const Point &amp;p, const Point &amp;q)</argsstring>
        <name>set</name>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>q</declname>
        </param>
        <briefdescription>
<para>sets <computeroutput>ellipse</computeroutput> to the ellipse containing exactly the segment connecting <computeroutput>p</computeroutput> and <computeroutput>q</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The algorithm guarantees that <computeroutput>set</computeroutput> is never called with two equal points. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="45" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classEllipse_1af029aee110f81fd71b52c5537b4c9423" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Ellipse::set</definition>
        <argsstring>(const Point &amp;p, const Point &amp;q, const Point &amp;r)</argsstring>
        <name>set</name>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>q</declname>
        </param>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>sets <computeroutput>ellipse</computeroutput> to the smallest ellipse through <computeroutput>p</computeroutput>,<computeroutput>q</computeroutput>,<computeroutput>r</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The algorithm guarantees that <computeroutput>set</computeroutput> is never called with three collinear points. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="55" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classEllipse_1a71688e14279bca4ccf2719ef1fed78eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Ellipse::set</definition>
        <argsstring>(const Point &amp;p, const Point &amp;q, const Point &amp;r, const Point &amp;s)</argsstring>
        <name>set</name>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>q</declname>
        </param>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>sets <computeroutput>ellipse</computeroutput> to the smallest ellipse through <computeroutput>p</computeroutput>,<computeroutput>q</computeroutput>,<computeroutput>r</computeroutput>,<computeroutput>s</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The algorithm guarantees that this ellipse exists. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="66" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classEllipse_1a058fd5c7a8a2d66cfa89d03b096424bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Ellipse::set</definition>
        <argsstring>(const Point &amp;p, const Point &amp;q, const Point &amp;r, const Point &amp;s, const Point &amp;t)</argsstring>
        <name>set</name>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>q</declname>
        </param>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>sets <computeroutput>ellipse</computeroutput> to the unique conic through <computeroutput>p</computeroutput>,<computeroutput>q</computeroutput>,<computeroutput>r</computeroutput>,<computeroutput>s</computeroutput>,<computeroutput>t</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The algorithm guarantees that this conic is an ellipse. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="78" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Predicates</header>
      <memberdef kind="function" id="classEllipse_1afe96371aaafb0a2eb8acd7f70171f032" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Ellipse::has_on_unbounded_side</definition>
        <argsstring>(const Point &amp;p) const</argsstring>
        <name>has_on_unbounded_side</name>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, iff <computeroutput>p</computeroutput> lies properly outside of <computeroutput>ellipse</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="94" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classEllipse_1a5ee5eee3892eb14757802b91ec7076cf" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__kernel__enums_1gaf6030e89dadcc1f45369b0cdc5d9e111" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Bounded_side</ref></type>
        <definition>CGAL::Bounded_side Ellipse::bounded_side</definition>
        <argsstring>(const Point &amp;p) const</argsstring>
        <name>bounded_side</name>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput><ref refid="group__kernel__enums_1ggaf6030e89dadcc1f45369b0cdc5d9e111ad8333d35d4801c08b3a5ae9e94d7cabe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ON_BOUNDED_SIDE</ref></computeroutput>, <computeroutput><ref refid="group__kernel__enums_1ggaf6030e89dadcc1f45369b0cdc5d9e111a060193157c0875fb2e6445a648f3ac1f" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ON_BOUNDARY</ref></computeroutput>, or <computeroutput><ref refid="group__kernel__enums_1ggaf6030e89dadcc1f45369b0cdc5d9e111a3a96e6da84164cc8300c9e130be23f71" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ON_UNBOUNDED_SIDE</ref></computeroutput> iff <computeroutput>p</computeroutput> lies properly inside, on the boundary, or properly outside of <computeroutput>ellipse</computeroutput>, resp. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the corresponding predicate of <computeroutput><ref refid="classCGAL_1_1Min__ellipse__2" kindref="compound">CGAL::Min_ellipse_2</ref></computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="108" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classEllipse_1a68f78449847687a1cc86f5bc40b2e841" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Ellipse::has_on_bounded_side</definition>
        <argsstring>(const Point &amp;p) const</argsstring>
        <name>has_on_bounded_side</name>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, iff <computeroutput>p</computeroutput> lies properly inside <computeroutput>ellipse</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the corresponding predicate of <computeroutput><ref refid="classCGAL_1_1Min__ellipse__2" kindref="compound">CGAL::Min_ellipse_2</ref></computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="117" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classEllipse_1a293326223e982e686678e742f8dc0c0e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Ellipse::has_on_boundary</definition>
        <argsstring>(const Point &amp;p) const</argsstring>
        <name>has_on_boundary</name>
        <param>
          <type>const <ref refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, iff <computeroutput>p</computeroutput> lies on the boundary of <computeroutput>ellipse</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the corresponding predicate of <computeroutput><ref refid="classCGAL_1_1Min__ellipse__2" kindref="compound">CGAL::Min_ellipse_2</ref></computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="127" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classEllipse_1a49a639866c6fd473077299850f698338" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Ellipse::is_empty</definition>
        <argsstring>() const</argsstring>
        <name>is_empty</name>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, iff <computeroutput>ellipse</computeroutput> is empty (this implies degeneracy). </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the corresponding predicate of <computeroutput><ref refid="classCGAL_1_1Min__ellipse__2" kindref="compound">CGAL::Min_ellipse_2</ref></computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="137" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classEllipse_1ace95f07f7a84eca48e1abbacdef83c22" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Ellipse::is_degenerate</definition>
        <argsstring>() const</argsstring>
        <name>is_degenerate</name>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, iff <computeroutput>ellipse</computeroutput> is degenerate, i.e. if <computeroutput>ellipse</computeroutput> is empty or equal to a single point. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the corresponding predicate of <computeroutput><ref refid="classCGAL_1_1Min__ellipse__2" kindref="compound">CGAL::Min_ellipse_2</ref></computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="146" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>I/O</header>
      <description><para>The following I/O operator is only needed, if the corresponding I/O operator of <computeroutput><ref refid="classCGAL_1_1Min__ellipse__2" kindref="compound">CGAL::Min_ellipse_2</ref></computeroutput> is used. </para></description>
      <memberdef kind="function" id="classEllipse_1aed980902a8f2eb12857f56693f549e75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ostream &amp;</type>
        <definition>ostream&amp; Ellipse::operator&lt;&lt;</definition>
        <argsstring>(ostream &amp;os, const Ellipse &amp;ellipse)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classEllipse" kindref="compound">Ellipse</ref> &amp;</type>
          <declname>ellipse</declname>
        </param>
        <briefdescription>
<para>writes <computeroutput>ellipse</computeroutput> to output stream <computeroutput>os</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the corresponding I/O operator of <computeroutput><ref refid="classCGAL_1_1Min__ellipse__2" kindref="compound">CGAL::Min_ellipse_2</ref></computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Ellipse.h" line="161" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>An object <computeroutput>ellipse</computeroutput> of the class <computeroutput><ref refid="classEllipse" kindref="compound">Ellipse</ref></computeroutput> is an ellipse in two-dimensional Euclidean plane <formula id="75">$ \E^2$</formula>. Its boundary splits the plane into a bounded and an unbounded side. By definition, an empty <computeroutput>ellipse</computeroutput> has no boundary and no bounded side, i.e. its unbounded side equals the whole plane <formula id="75">$ \E^2$</formula>. </para>    </briefdescription>
    <detaileddescription>
<para> </para>    </detaileddescription>
    <location file="Concepts/Ellipse.h" line="11" column="1" bodyfile="Concepts/Ellipse.h" bodystart="11" bodyend="165"/>
    <listofallmembers>
      <member refid="classEllipse_1a5ee5eee3892eb14757802b91ec7076cf" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>bounded_side</name></member>
      <member refid="classEllipse_1a293326223e982e686678e742f8dc0c0e" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>has_on_boundary</name></member>
      <member refid="classEllipse_1a68f78449847687a1cc86f5bc40b2e841" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>has_on_bounded_side</name></member>
      <member refid="classEllipse_1afe96371aaafb0a2eb8acd7f70171f032" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>has_on_unbounded_side</name></member>
      <member refid="classEllipse_1ace95f07f7a84eca48e1abbacdef83c22" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>is_degenerate</name></member>
      <member refid="classEllipse_1a49a639866c6fd473077299850f698338" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>is_empty</name></member>
      <member refid="classEllipse_1aed980902a8f2eb12857f56693f549e75" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>operator&lt;&lt;</name></member>
      <member refid="classEllipse_1acc6e9dc33bc1560d201b4bb568896696" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>Point</name></member>
      <member refid="classEllipse_1a6cca249806320e212249694db9000bcb" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>set</name></member>
      <member refid="classEllipse_1a38f33c44e378813877ed62d3cfc7a2de" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>set</name></member>
      <member refid="classEllipse_1aceb0a1e7165a69ddafbc7762ca9a724b" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>set</name></member>
      <member refid="classEllipse_1af029aee110f81fd71b52c5537b4c9423" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>set</name></member>
      <member refid="classEllipse_1a71688e14279bca4ccf2719ef1fed78eb" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>set</name></member>
      <member refid="classEllipse_1a058fd5c7a8a2d66cfa89d03b096424bb" prot="public" virt="non-virtual"><scope>Ellipse</scope><name>set</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
