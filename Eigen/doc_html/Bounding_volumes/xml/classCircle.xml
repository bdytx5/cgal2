<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classCircle" kind="class" language="C++" prot="public">
    <compoundname>Circle</compoundname>
    <includes local="no">Concepts/Circle.h</includes>
      <sectiondef kind="user-defined">
      <header>Types</header>
      <memberdef kind="typedef" id="classCircle_1a0e553987eb312b8327e119b29f48b92f" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type Circle::Point</definition>
        <argsstring></argsstring>
        <name>Point</name>
        <briefdescription>
<para>Point type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="22" column="1" bodyfile="Concepts/Circle.h" bodystart="22" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCircle_1a9886fc7553222e08f4dac75f68d12f9b" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type Circle::Distance</definition>
        <argsstring></argsstring>
        <name>Distance</name>
        <briefdescription>
<para>Distance type. </para>        </briefdescription>
        <detaileddescription>
<para>The function <computeroutput><ref refid="classCircle_1a9fd448ad85d0a27b5bd236828d35e3e8" kindref="member">squared_radius()</ref></computeroutput> (see below) returns an object of this type.</para><para><simplesect kind="note"><para>Only needed, if the member function <computeroutput>is_valid()</computeroutput> of <computeroutput>Min_circle_2</computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="32" column="1" bodyfile="Concepts/Circle.h" bodystart="32" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Creation</header>
      <memberdef kind="function" id="classCircle_1ab5834e52fe70734ce18d774aca79498b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Circle::set</definition>
        <argsstring>()</argsstring>
        <name>set</name>
        <briefdescription>
<para>sets <computeroutput>circle</computeroutput> to the empty circle. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="42" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCircle_1ae09f69c3aea3f399021eae51e39c8681" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Circle::set</definition>
        <argsstring>(const Point &amp;p)</argsstring>
        <name>set</name>
        <param>
          <type>const <ref refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>sets <computeroutput>circle</computeroutput> to the circle containing exactly <formula id="161">$ \{\mbox{`p` }\}$</formula>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="47" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCircle_1af4dcd22d36be185c01b8ac3006c77de9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Circle::set</definition>
        <argsstring>(const Point &amp;p, const Point &amp;q)</argsstring>
        <name>set</name>
        <param>
          <type>const <ref refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const <ref refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" kindref="member">Point</ref> &amp;</type>
          <declname>q</declname>
        </param>
        <briefdescription>
<para>sets <computeroutput>circle</computeroutput> to the circle with diameter equal to the segment connecting <computeroutput>p</computeroutput> and <computeroutput>q</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The algorithm guarantees that <computeroutput>set</computeroutput> is never called with two equal points. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="55" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCircle_1aa733eeedcb205199d371dda7daa3ccdf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Circle::set</definition>
        <argsstring>(const Point &amp;p, const Point &amp;q, const Point &amp;r)</argsstring>
        <name>set</name>
        <param>
          <type>const <ref refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const <ref refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" kindref="member">Point</ref> &amp;</type>
          <declname>q</declname>
        </param>
        <param>
          <type>const <ref refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" kindref="member">Point</ref> &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>sets <computeroutput>circle</computeroutput> to the circle through <computeroutput>p</computeroutput>,<computeroutput>q</computeroutput>,<computeroutput>r</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The algorithm guarantees that <computeroutput>set</computeroutput> is never called with three collinear points. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="61" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Predicates</header>
      <memberdef kind="function" id="classCircle_1aa56123018ce24b84600196b1494b9c32" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Circle::has_on_unbounded_side</definition>
        <argsstring>(const Point &amp;p) const</argsstring>
        <name>has_on_unbounded_side</name>
        <param>
          <type>const <ref refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, iff <computeroutput>p</computeroutput> lies properly outside of <computeroutput>circle</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="71" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCircle_1a9676ae83ab9109bcdedba573f277383f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__kernel__enums_1gaf6030e89dadcc1f45369b0cdc5d9e111" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Bounded_side</ref></type>
        <definition>CGAL::Bounded_side Circle::bounded_side</definition>
        <argsstring>(const Point &amp;p) const</argsstring>
        <name>bounded_side</name>
        <param>
          <type>const <ref refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput><ref refid="group__kernel__enums_1ggaf6030e89dadcc1f45369b0cdc5d9e111ad8333d35d4801c08b3a5ae9e94d7cabe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ON_BOUNDED_SIDE</ref></computeroutput>, <computeroutput><ref refid="group__kernel__enums_1ggaf6030e89dadcc1f45369b0cdc5d9e111a060193157c0875fb2e6445a648f3ac1f" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ON_BOUNDARY</ref></computeroutput>, or <computeroutput><ref refid="group__kernel__enums_1ggaf6030e89dadcc1f45369b0cdc5d9e111a3a96e6da84164cc8300c9e130be23f71" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ON_UNBOUNDED_SIDE</ref></computeroutput> iff <computeroutput>p</computeroutput> lies properly inside, on the boundary, or properly outside of <computeroutput>circle</computeroutput>, resp. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the corresponding predicate of <computeroutput>Min_circle_2</computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="82" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCircle_1ad1a22f284c7585f62df1b1786c81df97" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Circle::has_on_bounded_side</definition>
        <argsstring>(const Point &amp;p) const</argsstring>
        <name>has_on_bounded_side</name>
        <param>
          <type>const <ref refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, iff <computeroutput>p</computeroutput> lies properly inside <computeroutput>circle</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the corresponding predicate of <computeroutput>Min_circle_2</computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="90" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCircle_1a445547b021952fb0d4c004a7aece094b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Circle::has_on_boundary</definition>
        <argsstring>(const Point &amp;p) const</argsstring>
        <name>has_on_boundary</name>
        <param>
          <type>const <ref refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, iff <computeroutput>p</computeroutput> lies on the boundary of <computeroutput>circle</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the corresponding predicate of <computeroutput>Min_circle_2</computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="99" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCircle_1ae94cffb81b773f723a3ca1faf8b26e4d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Circle::is_empty</definition>
        <argsstring>() const</argsstring>
        <name>is_empty</name>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, iff <computeroutput>circle</computeroutput> is empty (this implies degeneracy). </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the corresponding predicate of <computeroutput>Min_circle_2</computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="108" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCircle_1a9163172a89405de9ed45220de43d376d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Circle::is_degenerate</definition>
        <argsstring>() const</argsstring>
        <name>is_degenerate</name>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, iff <computeroutput>circle</computeroutput> is degenerate, i.e. if <computeroutput>circle</computeroutput> is empty or equal to a single point. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the corresponding predicate of <computeroutput>Min_circle_2</computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="118" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Additional Operations for Checking</header>
      <memberdef kind="function" id="classCircle_1ad15e7f586a20d957ce3a3ac0026df3f6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Circle::operator==</definition>
        <argsstring>(const Circle &amp;circle2) const</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classCircle" kindref="compound">Circle</ref> &amp;</type>
          <declname>circle2</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, iff <computeroutput>circle</computeroutput> and <computeroutput>circle2</computeroutput> are equal. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the member function <computeroutput>is_valid()</computeroutput> of <computeroutput>Min_circle_2</computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="133" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCircle_1a0c31a5799d5c116388c65106b81fec34" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" kindref="member">Point</ref></type>
        <definition>Point Circle::center</definition>
        <argsstring>() const</argsstring>
        <name>center</name>
        <briefdescription>
<para>returns the center of <computeroutput>circle</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the member function <computeroutput>is_valid()</computeroutput> of <computeroutput>Min_circle_2</computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="141" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCircle_1a9fd448ad85d0a27b5bd236828d35e3e8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCircle_1a9886fc7553222e08f4dac75f68d12f9b" kindref="member">Distance</ref></type>
        <definition>Distance Circle::squared_radius</definition>
        <argsstring>() const</argsstring>
        <name>squared_radius</name>
        <briefdescription>
<para>returns the squared radius of <computeroutput>circle</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only needed, if the member function <computeroutput>is_valid()</computeroutput> of <computeroutput>Min_circle_2</computeroutput> is used. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="150" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>I/O</header>
      <memberdef kind="function" id="classCircle_1ae551aa6f67496b5ee01caf186afecd60" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; Circle::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Circle &amp;circle)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classCircle" kindref="compound">Circle</ref> &amp;</type>
          <declname>circle</declname>
        </param>
        <briefdescription>
<para>writes <computeroutput>circle</computeroutput> to output stream <computeroutput>os</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Circle.h" line="159" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>An object of the class <computeroutput><ref refid="classCircle" kindref="compound">Circle</ref></computeroutput> is a circle in two-dimensional Euclidean plane <formula id="75">$ \E^2$</formula>. Its boundary splits the plane into a bounded and an unbounded side. By definition, an empty <computeroutput><ref refid="classCircle" kindref="compound">Circle</ref></computeroutput> has no boundary and no bounded side, i.e. its unbounded side equals the whole plane <formula id="75">$ \E^2$</formula>. A <computeroutput><ref refid="classCircle" kindref="compound">Circle</ref></computeroutput> containing exactly one point <formula id="122">$ p$</formula> has no bounded side, its boundary is <formula id="82">$ \{p\}$</formula>, and its unbounded side equals <formula id="160">$ \E^2 \setminus \{p\}$</formula>. </para>    </briefdescription>
    <detaileddescription>
<para> </para>    </detaileddescription>
    <location file="Concepts/Circle.h" line="15" column="1" bodyfile="Concepts/Circle.h" bodystart="14" bodyend="163"/>
    <listofallmembers>
      <member refid="classCircle_1a9676ae83ab9109bcdedba573f277383f" prot="public" virt="non-virtual"><scope>Circle</scope><name>bounded_side</name></member>
      <member refid="classCircle_1a0c31a5799d5c116388c65106b81fec34" prot="public" virt="non-virtual"><scope>Circle</scope><name>center</name></member>
      <member refid="classCircle_1a9886fc7553222e08f4dac75f68d12f9b" prot="public" virt="non-virtual"><scope>Circle</scope><name>Distance</name></member>
      <member refid="classCircle_1a445547b021952fb0d4c004a7aece094b" prot="public" virt="non-virtual"><scope>Circle</scope><name>has_on_boundary</name></member>
      <member refid="classCircle_1ad1a22f284c7585f62df1b1786c81df97" prot="public" virt="non-virtual"><scope>Circle</scope><name>has_on_bounded_side</name></member>
      <member refid="classCircle_1aa56123018ce24b84600196b1494b9c32" prot="public" virt="non-virtual"><scope>Circle</scope><name>has_on_unbounded_side</name></member>
      <member refid="classCircle_1a9163172a89405de9ed45220de43d376d" prot="public" virt="non-virtual"><scope>Circle</scope><name>is_degenerate</name></member>
      <member refid="classCircle_1ae94cffb81b773f723a3ca1faf8b26e4d" prot="public" virt="non-virtual"><scope>Circle</scope><name>is_empty</name></member>
      <member refid="classCircle_1ae551aa6f67496b5ee01caf186afecd60" prot="public" virt="non-virtual"><scope>Circle</scope><name>operator&lt;&lt;</name></member>
      <member refid="classCircle_1ad15e7f586a20d957ce3a3ac0026df3f6" prot="public" virt="non-virtual"><scope>Circle</scope><name>operator==</name></member>
      <member refid="classCircle_1a0e553987eb312b8327e119b29f48b92f" prot="public" virt="non-virtual"><scope>Circle</scope><name>Point</name></member>
      <member refid="classCircle_1ab5834e52fe70734ce18d774aca79498b" prot="public" virt="non-virtual"><scope>Circle</scope><name>set</name></member>
      <member refid="classCircle_1ae09f69c3aea3f399021eae51e39c8681" prot="public" virt="non-virtual"><scope>Circle</scope><name>set</name></member>
      <member refid="classCircle_1af4dcd22d36be185c01b8ac3006c77de9" prot="public" virt="non-virtual"><scope>Circle</scope><name>set</name></member>
      <member refid="classCircle_1aa733eeedcb205199d371dda7daa3ccdf" prot="public" virt="non-virtual"><scope>Circle</scope><name>set</name></member>
      <member refid="classCircle_1a9fd448ad85d0a27b5bd236828d35e3e8" prot="public" virt="non-virtual"><scope>Circle</scope><name>squared_radius</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
