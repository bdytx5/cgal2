<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Bounding_Volumes"/><anchor id="index_1chapBoundingVolumes"/> <simplesect kind="authors"><para>Kaspar Fischer, Bernd G<aumlaut/>rtner, Thomas Herrmann, Michael Hoffmann, and Sven Sch<oumlaut/>nherr</para></simplesect>
<image type="html" name="ball.png"></image>
 <image type="latex" name="ball.png"></image>
</para><para>This chapter describes algorithms which for a given point set compute the <emphasis>best</emphasis> circumscribing object from a specific class. If the class consists of all spheres in <formula id="0">$ d$</formula>-dimensional Euclidean space and <emphasis>best</emphasis> is defined as having smallest radius, then we obtain the smallest enclosing sphere problem already mentioned above.</para><para>In the following example a smallest enclosing circle (<computeroutput><ref refid="classCGAL_1_1Min__circle__2" kindref="compound">Min_circle_2</ref>&lt;Traits&gt;</computeroutput>) is constructed from points on a line and written to standard output. The example shows that it is advisable to switch on random shuffling in order to deal with a <emphasis>bad</emphasis> order of the input points.</para><para><linebreak/>
<bold>File</bold> <ref refid="Min_circle_2_2min_circle_2_8cpp-example" kindref="compound">Min_circle_2/min_circle_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Min_circle_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Min_circle_2_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Min__circle__2__traits__2" kindref="compound">CGAL::Min_circle_2_traits_2&lt;K&gt;</ref><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Min__circle__2" kindref="compound">CGAL::Min_circle_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Min_circle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">main(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point<sp/>P[n];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P[<sp/>i]<sp/>=<sp/>Point(<sp/>(i%2<sp/>==<sp/>0<sp/>?<sp/>i<sp/>:<sp/>-i),<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(0,0),<sp/>(-1,0),<sp/>(2,0),<sp/>(-3,0),<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Min_circle<sp/><sp/>mc1(<sp/>P,<sp/>P+n,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>very<sp/>slow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Min_circle<sp/><sp/>mc2(<sp/>P,<sp/>P+n,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>fast</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(<sp/>std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>mc2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Other classes for which we provide solutions are ellipses (<computeroutput><ref refid="classCGAL_1_1Min__ellipse__2" kindref="compound">Min_ellipse_2</ref>&lt;Traits&gt;</computeroutput>), rectangles (<computeroutput><ref refid="group__PkgBoundingVolumes_1gadcf412afbf5ae512fc88d25d286fa3fa" kindref="member">min_rectangle_2()</ref></computeroutput>), parallelograms (<computeroutput><ref refid="group__PkgBoundingVolumes_1ga15d5706ceec6fc6fcae0b1625b6da2ac" kindref="member">min_parallelogram_2()</ref></computeroutput>) and strips (<computeroutput><ref refid="group__PkgBoundingVolumes_1gafc685ec39e42e18195ca101631c61cd0" kindref="member">min_strip_2()</ref></computeroutput>) in the plane, with appropriate optimality criteria. For arbitrary dimensions we provide smallest enclosing spheres for points (<computeroutput><ref refid="classCGAL_1_1Min__sphere__d" kindref="compound">Min_sphere_d</ref>&lt;Traits&gt;</computeroutput>) and spheres for spheres (<computeroutput><ref refid="classCGAL_1_1Min__sphere__of__spheres__d" kindref="compound">Min_sphere_of_spheres_d</ref>&lt;Traits&gt;</computeroutput>), smallest enclosing annuli (<computeroutput><ref refid="classCGAL_1_1Min__annulus__d" kindref="compound">Min_annulus_d</ref>&lt;Traits&gt;</computeroutput>), and approximate minimum-volume enclosing ellipsoid with user-specified approximation ratio (<computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d" kindref="compound">Approximate_min_ellipsoid_d</ref>&lt;Traits&gt;</computeroutput>).</para><para><image type="html" name="annulus.png"></image>
 <image type="latex" name="annulus.png"></image>
</para><para>Bounding volumes can be used to obtain simple approximations of complicated objects. For example, consider the problem of deciding whether two moving polygons currently intersect. An obvious solution is to discretize time and perform a full intersection test for any time step. If the polygons are far apart most of the time, this is unnecessary. Instead, simple bounding volumes (for examples, circles) are computed for both polygons at their initial positions. At subsequent time steps, an intersection test between the moving bounding circles replaces the actual intersection test; only if the circles do intersect, the expensive intersection test between the polygons is performed. In practice, bounding volume hierarchies are often used on top of simple bounding volumes to approximate complicated objects more accurately.</para><para>Bounding volumes are also frequently applied to extract geometric properties of objects. For example, the smallest enclosing annulus of a point set can be used to test whether a set of points is approximately cospherical. Here, the width of the annulus (or its area, or still another criterion that we use) is a good measure for this property. The largest area triangle is for example used in heuristics for matching archaeological aerial photographs. Largest perimeter triangles are used in scoring cross country soaring flights, where the goal is basically to fly as far as possible, but still return to the departure airfield. To score simply based on the total distance flown is not a good measure, since circling in thermals allows to increase it easily.</para><para>Bounding volumes also define geometric &quot;center points&quot; of objects. For example, if two objects are to be matched (approximately), one approch is to first apply the translation that maps the centers of their smallest enclosing spheres onto each other. Simpler centers are possible, of course (center of gravity, center of bounding box), but more advanced bounding volumes might give better results in some cases. It can also make sense to consider several center points instead of just one. For example, we provide algorithms to cover a planar point set with between two and four minimal boxes (<computeroutput><ref refid="group__PkgBoundingVolumes_1ga37fae6bf8313f85322987d3f230eca53" kindref="member">rectangular_p_center_2()</ref></computeroutput>). Below is an example covering with three boxes; the center points are shown in red.</para><para><image type="html" name="pcenter.png"></image>
 <image type="latex" name="pcenter.png"></image>
 </para>    </detaileddescription>
  </compounddef>
</doxygen>
