<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Bounding_volumes/classCGAL_1_1Approximate__min__ellipsoid__d.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Bounding Volumes: CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Bounding Volumes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classCGAL_1_1Approximate__min__ellipsoid__d.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Approximate__min__ellipsoid__d-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgBoundingVolumes.html">Bounding Volumes Reference</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Approximate_min_ellipsoid_d.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"> 

<p>An object of class <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html" title="An object of class Approximate_min_ellipsoid_d is an approximation to the ellipsoid of smallest volum...">Approximate_min_ellipsoid_d</a></code> is an approximation to the ellipsoid of smallest volume enclosing a finite multiset of points in \( d\)-dimensional Euclidean space \( \E^d\), \( d\ge 2\). </p>
<p>An <em>ellipsoid</em> in \( \E^d\) is a <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a> pointset of the form \( \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq 0 \}\), where \( E\) is some positive definite matrix from the set \( \mathbb{R}^{d\times d}\), \( e\) is some real \( d\)-vector, and \( \eta\in\mathbb{R}\). A pointset \( P\subseteq \E^d\) is called <em>full-dimensional</em> if its affine hull has dimension \( d\). For a finite, full-dimensional pointset \( P\) we denote by \( \mel(P)\) the smallest ellipsoid that contains all points of \( P\); this ellipsoid exists and is unique.</p>
<p>For a given finite and full-dimensional pointset \( P\subset \E^d\) and a real number \( \epsilon\ge 0\), we say that an ellipsoid \( {\cal E}\subset\E^d\) is an <em> \( (1+\epsilon)\)-appoximation</em> to \( \mel(P)\) if \( P\subset {\cal E}\) and \( \vol({\cal E}) \leq (1+\epsilon) \vol(\mel(P))\). In other words, an \( (1+\epsilon)\)-approximation to \( \mel(P)\) is an enclosing ellipsoid whose volume is by at most a factor of \( 1+\epsilon\) larger than the volume of the smallest enclosing ellipsoid of \( P\).</p>
<p>Given this notation, an object of class <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html" title="An object of class Approximate_min_ellipsoid_d is an approximation to the ellipsoid of smallest volum...">Approximate_min_ellipsoid_d</a></code> represents an \( (1+\epsilon)\)-approximation to \( \mel(P)\) for a given finite and full-dimensional multiset of points \( P\subset\E^d\) and a real constant \( \epsilon&gt;0\).<span class="footnote">A <em>multiset</em> is a set where elements may have multiplicity greater than \( 1\).</span> When an <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html" title="An object of class Approximate_min_ellipsoid_d is an approximation to the ellipsoid of smallest volum...">Approximate_min_ellipsoid_d</a>&lt;Traits&gt;</code> object is constructed, an iterator over the points \( P\) and the number \( \epsilon\) have to be specified; the number \( \epsilon\) defines the <em>desired approximation ratio</em> \( 1+\epsilon\). The underlying algorithm will then try to compute an \( (1+\epsilon)\)-approximation to \( \mel(P)\), and one of the following two cases takes place. </p><ul>
<li>
<p class="startli">The algorithm determines that \( P\) is not full-dimensional (see <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a636b12855568f4471e0dadc3d6fefb3f" title="returns whether  is full-dimensional or not, i.e., returns true if and only if  is full-dimensional...">is_full_dimensional()</a></code> below).</p>
<p><em>Important note:</em> due to rounding errors, the algorithm cannot in all cases decide correctly whether \( P\) is full-dimensional or not. If <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a636b12855568f4471e0dadc3d6fefb3f" title="returns whether  is full-dimensional or not, i.e., returns true if and only if  is full-dimensional...">is_full_dimensional()</a></code> returns <code>false</code>, the points lie in such a "thin" subspace of \( \E^d\) that the algorithm is incapable of computing an approximation to \( \mel(P)\). More precisely, if <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a636b12855568f4471e0dadc3d6fefb3f" title="returns whether  is full-dimensional or not, i.e., returns true if and only if  is full-dimensional...">is_full_dimensional()</a></code> returns <code>false</code>, there exist two parallel hyperplanes in \( \E^d\) with the points \( P\) in between so that the distance \( \delta\) between the hyperplanes is very small, possible zero. (If \( \delta=0\) then \( P\) is not full-dimensional.)</p>
<p class="endli">If \( P\) is not full-dimensional, linear algebra techniques should be used to determine an affine subspace \( S\) of \( \E^d\) that contains the points \( P\) as a (w.r.t. \( S\)) full-dimensional pointset; once \( S\) is determined, the algorithm can be invoked again to compute an approximation to (the lower-dimensional) \( \mel(P)\) in \( S\). Since <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a636b12855568f4471e0dadc3d6fefb3f" title="returns whether  is full-dimensional or not, i.e., returns true if and only if  is full-dimensional...">is_full_dimensional()</a></code> might (due to rounding errors, see above) return <code>false</code> even though \( P\) is full-dimensional, the lower-dimensional subspace \( S\) containing \( P\) need not exist. Therefore, it might be more advisable to fit a hyperplane \( H\) through the pointset \( P\), project \( P\) onto this affine subspace \( H\), and compute an approximation to the minimum-volume enclosing ellipsoid of the projected points within \( H\); the fitting can be done for instance using the <code>linear_least_squares_fitting()</code> function from the <span style="font-variant: small-caps;">CGAL</span> package <code>Principal_component_analysis</code>. </p>
</li>
<li>
The algorithm determines that \( P\) is full-dimensional. In this case, it provides an approximation \( {\cal E}\) to \( \mel(P)\), but depending on the input problem (i.e., on the pair \( (P,\epsilon)\)), it may not have achieved the desired approximation ratio but merely some <em>worse</em> approximation ratio \( 1+\epsilon'&gt;1+\epsilon\). The achieved approximation ratio \( 1+\epsilon'\) can be queried using <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a9f9fad4c126ae57c4cd3727d9283229f" title="returns a number  such that the computed approximation is (under exact arithmetic) guaranteed to be a...">achieved_epsilon()</a></code>, which returns \( \epsilon'\). The ellipsoid \( {\cal E}\) itself can be queried via the methods <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a32b71cb636acb2f6b34e96465c5379e0" title="gives access to the th entry of the matrix  in the representation  of the computed approximation elli...">defining_matrix()</a></code>, <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a4aa3e857cdd79771f39aad531157b5f0" title="gives access to the th entry of the vector  in the representation  of the computed approximation elli...">defining_vector()</a></code>, and <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ad54fb77e5183d93d86840ba89ea95478" title="gives access to the scalar  from the representation  of the computed approximation ellipsoid ...">defining_scalar()</a></code>. </li>
</ul>
<p>The ellipsoid \( {\cal E}\) computed by the algorithm satisfies the inclusions <a class="anchor" id="eqapproximate_min_ellipsoid_incl"></a> </p><p class="formulaDsp">
\[ \frac{1}{(1+\epsilon')d} {\cal E} \subseteq \mathop{\rm conv}\nolimits(P) \subseteq {\cal E} \]
</p>
<p> where \( f {\cal E}\) denotes the ellipsoid \( {\cal E}\) scaled by the factor \( f\in\mathbb{R}^+\) with respect to its center, and where \( \mathop{\rm conv}\nolimits(A)\) denotes the <em>convex hull</em> of a pointset \( A\subset \E^d\).</p>
<p>The underlying algorithm can cope with all kinds of inputs (multisets \( P\), \( \epsilon\in[0,\infty)\)) and terminates in all cases. There is, however, no guarantee that any desired approximation ratio is actually achieved; the performance of the algorithm in this respect highly depends on the input pointset. Values of at least \( 0.01\) for \( \epsilon\) are usually handled without problems.</p>
<p>Internally, the algorithm represents the input points' <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a> coordinates as <code>double</code>'s. For this conversion to work, the input point coordinates must be convertible to <code>double</code>. Also, in order to compute the achieved epsilon \( \epsilon'\) mentioned above, the algorithm requires a number type <code>ET</code> that provides <em>exact</em> arithmetic. (Both these aspects are discussed in the documentation of the concept <code><a class="el" href="classApproximateMinEllipsoid__d__Traits__d.html" title="This concept defines the requirements for traits classes of CGAL::Approximate_min_ellipsoid_d&lt;Traits&gt;...">ApproximateMinEllipsoid_d_Traits_d</a></code>.)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>must be a model for <code><a class="el" href="classApproximateMinEllipsoid__d__Traits__d.html" title="This concept defines the requirements for traits classes of CGAL::Approximate_min_ellipsoid_d&lt;Traits&gt;...">ApproximateMinEllipsoid_d_Traits_d</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>We provide the model <code><a class="el" href="structCGAL_1_1Approximate__min__ellipsoid__d__traits__d.html" title="The class Approximate_min_ellipsoid_d_traits_d is a traits class for CGAL::Approximate_min_ellipsoid_...">CGAL::Approximate_min_ellipsoid_d_traits_d</a>&lt;K&gt;</code> using the \( d\)-dimensional <span style="font-variant: small-caps;">CGAL</span> kernel; the models <code><a class="el" href="structCGAL_1_1Approximate__min__ellipsoid__d__traits__2.html" title="The class Approximate_min_ellipsoid_d_traits_2 is a traits class for CGAL::Approximate_min_ellipsoid_...">CGAL::Approximate_min_ellipsoid_d_traits_2</a>&lt;K&gt;</code> and <code><a class="el" href="structCGAL_1_1Approximate__min__ellipsoid__d__traits__3.html" title="The class Approximate_min_ellipsoid_d_traits_3 is a traits class for CGAL::Approximate_min_ellipsoid_...">CGAL::Approximate_min_ellipsoid_d_traits_3</a>&lt;K&gt;</code> are for use with the \( 2\)- and \( 3\)-dimensional <span style="font-variant: small-caps;">CGAL</span> kernel, respectively.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCGAL_1_1Min__ellipse__2.html" title="An object of the class Min_ellipse_2 is the unique ellipse of smallest area enclosing a finite (multi...">CGAL::Min_ellipse_2</a>&lt;Traits&gt;</code></dd></dl>
<p><b>Implementation</b><br />
</p>
<p>We implement Khachyian's algorithm for rounding polytopes <a class="el" href="citelist.html#CITEREF_cgal:k-rprnm-96">[10]</a>. Internally, we use <code>double</code>-arithmetic and (initially a single) Cholesky-decomposition. The algorithm's running time is \( {\cal O}(nd^2(\epsilon^{-1}+\ln d + \ln\ln(n)))\), where \( n=|P|\) and \( 1+\epsilon\) is the desired approximation ratio.</p>
<p><b>Example</b><br />
</p>
<p>To illustrate the usage of <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html" title="An object of class Approximate_min_ellipsoid_d is an approximation to the ellipsoid of smallest volum...">Approximate_min_ellipsoid_d</a></code> we give two examples in 2D. The first program generates a random set \( P\subset\E^2\) and outputs the points and a \( 1.01\)-approximation of \( \mel(P)\) as an EPS-file, which you can view using <code>gv</code>, for instance. (In both examples you can change the variables <code>n</code> and <code>d</code> to experiment with the code.)</p>
<p><br />
<b>File</b> <a class="el" href="Approximate_min_ellipsoid_d_2ellipsoid_8cpp-example.html">Approximate_min_ellipsoid_d/ellipsoid.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/MP_Float.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Approximate_min_ellipsoid_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Approximate_min_ellipsoid_d_traits_d.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Cartesian_d&lt;double&gt;                              Kernel;</div><div class="line"><span class="keyword">typedef</span> CGAL::MP_Float                                         <a class="code" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ae80e0c15bae383fdbb2e72d8643fafc3">ET</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Approximate__min__ellipsoid__d__traits__d.html">CGAL::Approximate_min_ellipsoid_d_traits_d&lt;Kernel, ET&gt;</a> Traits;</div><div class="line"><span class="keyword">typedef</span> Traits::Point                                          <a class="code" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a4a9ec257e6b8cb639810f3805316e68e">Point</a>;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt;                                     Point_list;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d&lt;Traits&gt;</a>              AME;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span>      n = 1000;                <span class="comment">// number of points</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span>      d = 2;                   <span class="comment">// dimension</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> eps = 0.01;                <span class="comment">// approximation ratio is (1+eps)</span></div><div class="line"></div><div class="line">  <span class="comment">// create a set of random points:</span></div><div class="line">  Point_list P;</div><div class="line">  CGAL::Random_points_in_cube_d&lt;Point&gt; rpg(d,100.0);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {</div><div class="line">    P.push_back(*rpg);</div><div class="line">    ++rpg;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// compute approximation:</span></div><div class="line">  Traits <a class="code" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ac5ae03954e671b379a3879563ef023db">traits</a>;</div><div class="line">  AME ame(eps, P.begin(), P.end(), <a class="code" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ac5ae03954e671b379a3879563ef023db">traits</a>);</div><div class="line"></div><div class="line">  <span class="comment">// write EPS file:</span></div><div class="line">  <span class="keywordflow">if</span> (ame.is_full_dimensional() &amp;&amp; d == 2)</div><div class="line">    ame.write_eps(<span class="stringliteral">"example.eps"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// output center coordinates:</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Cartesian center coordinates: "</span>;</div><div class="line">  <span class="keywordflow">for</span> (AME::Center_coordinate_iterator c_it = ame.center_cartesian_begin();</div><div class="line">       c_it != ame.center_cartesian_end();</div><div class="line">       ++c_it)</div><div class="line">    std::cout &lt;&lt; *c_it &lt;&lt; <span class="charliteral">' '</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">".\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (d == 2 || d == 3) {</div><div class="line">    <span class="comment">// output  axes:</span></div><div class="line">    AME::Axes_lengths_iterator axes = ame.axes_lengths_begin();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; ++i) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"Semiaxis "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" has length "</span> &lt;&lt; *axes++  &lt;&lt; <span class="stringliteral">"\n"</span></div><div class="line">                &lt;&lt; <span class="stringliteral">"and Cartesian coordinates "</span>;</div><div class="line">      <span class="keywordflow">for</span> (AME::Axes_direction_coordinate_iterator</div><div class="line">             d_it = ame.axis_direction_cartesian_begin(i);</div><div class="line">           d_it != ame.axis_direction_cartesian_end(i); ++d_it)</div><div class="line">        std::cout &lt;&lt; *d_it &lt;&lt; <span class="charliteral">' '</span>;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">".\n"</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The second program outputs the approximation in a format suitable for display in Maplesoft's Maple.</p>
<p><br />
<b>File</b> <a class="el" href="Approximate_min_ellipsoid_d_2ellipsoid_for_maple_8cpp-example.html">Approximate_min_ellipsoid_d/ellipsoid_for_maple.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Usage: ./maple_example &gt; maple.text</span></div><div class="line"><span class="comment">// Then enter in Maple 'read "maple.text";'.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/MP_Float.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Approximate_min_ellipsoid_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Approximate_min_ellipsoid_d_traits_d.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Cartesian_d&lt;double&gt;                              Kernel;</div><div class="line"><span class="keyword">typedef</span> CGAL::MP_Float                                         <a class="code" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ae80e0c15bae383fdbb2e72d8643fafc3">ET</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Approximate__min__ellipsoid__d__traits__d.html">CGAL::Approximate_min_ellipsoid_d_traits_d&lt;Kernel, ET&gt;</a> Traits;</div><div class="line"><span class="keyword">typedef</span> Traits::Point                                          <a class="code" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a4a9ec257e6b8cb639810f3805316e68e">Point</a>;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt;                                     Point_list;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d&lt;Traits&gt;</a>              AME;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span>      n = 100;                 <span class="comment">// number of points</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span>      d = 2;                   <span class="comment">// dimension</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> eps = 0.01;                <span class="comment">// approximation ratio is (1+eps)</span></div><div class="line"></div><div class="line">  <span class="comment">// create a set of random points:</span></div><div class="line">  Point_list P;</div><div class="line">  CGAL::Random_points_in_cube_d&lt;Point&gt; rpg(d,1.0);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {</div><div class="line">    P.push_back(*rpg);</div><div class="line">    ++rpg;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// compute approximation:</span></div><div class="line">  Traits <a class="code" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ac5ae03954e671b379a3879563ef023db">traits</a>;</div><div class="line">  AME mel(eps, P.begin(), P.end(), <a class="code" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ac5ae03954e671b379a3879563ef023db">traits</a>);</div><div class="line"></div><div class="line">  <span class="comment">// output for Maple:</span></div><div class="line">  <span class="keywordflow">if</span> (mel.is_full_dimensional() &amp;&amp; d == 2) {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = (1+mel.achieved_epsilon())*(d+1);</div><div class="line"></div><div class="line">    <span class="comment">// output points:</span></div><div class="line">    <span class="keyword">using</span> std::cout;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">"restart;\n"</span></div><div class="line">         &lt;&lt; <span class="stringliteral">"with(LinearAlgebra):\n"</span></div><div class="line">         &lt;&lt; <span class="stringliteral">"with(plottools):\n"</span></div><div class="line">         &lt;&lt; <span class="stringliteral">"n:= "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">":\n"</span></div><div class="line">         &lt;&lt; <span class="stringliteral">"P:= Matrix("</span> &lt;&lt; d &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">"):\n"</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;d; ++j)</div><div class="line">        cout &lt;&lt; <span class="stringliteral">"P["</span> &lt;&lt; j+1 &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">"] := "</span></div><div class="line">             &lt;&lt; std::setiosflags(std::ios::scientific)</div><div class="line">             &lt;&lt; std::setprecision(20) &lt;&lt; P[i][j] &lt;&lt; <span class="stringliteral">":\n"</span>;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// output defining equation:</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">"Mp:= Matrix([\n"</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) {</div><div class="line">      cout &lt;&lt; <span class="stringliteral">"  ["</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;d; ++j) {</div><div class="line">        cout &lt;&lt; mel.defining_matrix(i,j)/alpha;</div><div class="line">        <span class="keywordflow">if</span> (j&lt;d-1)</div><div class="line">          cout &lt;&lt; <span class="stringliteral">","</span>;</div><div class="line">      }</div><div class="line">      cout &lt;&lt; <span class="stringliteral">"]"</span>;</div><div class="line">      <span class="keywordflow">if</span> (i&lt;d-1)</div><div class="line">        cout &lt;&lt; <span class="stringliteral">","</span>;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; <span class="stringliteral">"]);\n"</span> &lt;&lt; <span class="stringliteral">"mp:= Vector(["</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) {</div><div class="line">      cout &lt;&lt; mel.defining_vector(i)/alpha;</div><div class="line">      <span class="keywordflow">if</span> (i&lt;d-1)</div><div class="line">        cout &lt;&lt; <span class="stringliteral">","</span>;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; <span class="stringliteral">"]);\n"</span></div><div class="line">         &lt;&lt; <span class="stringliteral">"eta:= "</span> &lt;&lt; (mel.defining_scalar()/alpha-1.0) &lt;&lt; <span class="stringliteral">";\n"</span></div><div class="line">         &lt;&lt; <span class="stringliteral">"v:= Vector([x,y]):\n"</span></div><div class="line">         &lt;&lt; <span class="stringliteral">"e:= Transpose(v).Mp.v+Transpose(v).mp+eta;\n"</span></div><div class="line">         &lt;&lt; <span class="stringliteral">"plots[display]({seq(point([P[1,i],P[2,i]]),i=1..n),\n"</span></div><div class="line">         &lt;&lt; <span class="stringliteral">" plots[implicitplot](e,x=-5..5,y=-5..5,numpoints=10000)},\n"</span></div><div class="line">         &lt;&lt; <span class="stringliteral">" scaling=CONSTRAINED);\n"</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This class requires the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/installation.html#thirdpartyEigen">Eigen</a> library. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Approximate_min_ellipsoid_d_2ellipsoid_8cpp-example.html#_a1">Approximate_min_ellipsoid_d/ellipsoid.cpp</a>, and <a class="el" href="Approximate_min_ellipsoid_d_2ellipsoid_for_maple_8cpp-example.html#_a1">Approximate_min_ellipsoid_d/ellipsoid_for_maple.cpp</a>.</dd>
</dl></div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Types</h2></td></tr>
<tr class="memitem:a700b439e58f13a26cdc86ca4d156a88c"><td class="memItemLeft" align="right" valign="top"><a id="a700b439e58f13a26cdc86ca4d156a88c"></a>
typedef <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a700b439e58f13a26cdc86ca4d156a88c">FT</a></td></tr>
<tr class="memdesc:a700b439e58f13a26cdc86ca4d156a88c"><td class="mdescLeft"> </td><td class="mdescRight"><code>typedef Traits::FT FT</code> (which is always a typedef to <code>double</code>). <br /></td></tr>
<tr class="separator:a700b439e58f13a26cdc86ca4d156a88c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae80e0c15bae383fdbb2e72d8643fafc3"><td class="memItemLeft" align="right" valign="top"><a id="ae80e0c15bae383fdbb2e72d8643fafc3"></a>
typedef <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ae80e0c15bae383fdbb2e72d8643fafc3">ET</a></td></tr>
<tr class="memdesc:ae80e0c15bae383fdbb2e72d8643fafc3"><td class="mdescLeft"> </td><td class="mdescRight"><code>typedef Traits::ET ET</code> (which is an exact number type used for exact computation like for example in <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a9f9fad4c126ae57c4cd3727d9283229f" title="returns a number  such that the computed approximation is (under exact arithmetic) guaranteed to be a...">achieved_epsilon()</a></code>). <br /></td></tr>
<tr class="separator:ae80e0c15bae383fdbb2e72d8643fafc3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4a9ec257e6b8cb639810f3805316e68e"><td class="memItemLeft" align="right" valign="top"><a id="a4a9ec257e6b8cb639810f3805316e68e"></a>
typedef <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a4a9ec257e6b8cb639810f3805316e68e">Point</a></td></tr>
<tr class="memdesc:a4a9ec257e6b8cb639810f3805316e68e"><td class="mdescLeft"> </td><td class="mdescRight"><code>typedef Traits::Point Point</code> <br /></td></tr>
<tr class="separator:a4a9ec257e6b8cb639810f3805316e68e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adf47ed5aabdb6ad61f6efac038e2fb41"><td class="memItemLeft" align="right" valign="top"><a id="adf47ed5aabdb6ad61f6efac038e2fb41"></a>
typedef <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#adf47ed5aabdb6ad61f6efac038e2fb41">Cartesian_const_iterator</a></td></tr>
<tr class="memdesc:adf47ed5aabdb6ad61f6efac038e2fb41"><td class="mdescLeft"> </td><td class="mdescRight"><code>typedef Traits::Cartesian_const_iterator Cartesian_const_iterator</code> <br /></td></tr>
<tr class="separator:adf47ed5aabdb6ad61f6efac038e2fb41"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aff46f1085c9c9ccb446a8e57221ae157"><td class="memItemLeft" align="right" valign="top"><a id="aff46f1085c9c9ccb446a8e57221ae157"></a>
typedef <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aff46f1085c9c9ccb446a8e57221ae157">Center_coordinate_iterator</a></td></tr>
<tr class="memdesc:aff46f1085c9c9ccb446a8e57221ae157"><td class="mdescLeft"> </td><td class="mdescRight">A model of STL concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a></code> with value type <code>double</code> that is used to iterate over the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a> center coordinates of the computed ellipsoid, see <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aa687dcedc9b78b06f4c0e2aba9edb592" title="returns an iterator pointing to the first of the  Cartesian coordinates of the computed ellipsoid's c...">center_cartesian_begin()</a></code>. <br /></td></tr>
<tr class="separator:aff46f1085c9c9ccb446a8e57221ae157"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a72cb50febc6d4c7c24c68a8016bde351"><td class="memItemLeft" align="right" valign="top"><a id="a72cb50febc6d4c7c24c68a8016bde351"></a>
typedef <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a72cb50febc6d4c7c24c68a8016bde351">Axes_lengths_iterator</a></td></tr>
<tr class="memdesc:a72cb50febc6d4c7c24c68a8016bde351"><td class="mdescLeft"> </td><td class="mdescRight">A model of STL concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a></code> with value type <code>double</code> that is used to iterate over the lengths of the semiaxes of the computed ellipsoid, see <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aeb6940806e45031a391baf58c735ec13" title="returns an iterator pointing to the first of the  descendantly sorted lengths of the computed ellipso...">axes_lengths_begin()</a></code>. <br /></td></tr>
<tr class="separator:a72cb50febc6d4c7c24c68a8016bde351"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b628b719e381d78e16d8535f7cbc6d0"><td class="memItemLeft" align="right" valign="top"><a id="a6b628b719e381d78e16d8535f7cbc6d0"></a>
typedef <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a6b628b719e381d78e16d8535f7cbc6d0">Axis_direction_iterator</a></td></tr>
<tr class="memdesc:a6b628b719e381d78e16d8535f7cbc6d0"><td class="mdescLeft"> </td><td class="mdescRight">A model of STL concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a></code> with value type <code>double</code> that is used to iterate over the Cartesian coordinates of the direction of a fixed axis of the computed ellipsoid, see <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ac04a27480671bd6e5a2eb4cc01fa47e2" title="returns an iterator pointing to the first of the  Cartesian coordinates of the computed ellipsoid's t...">axis_direction_cartesian_begin()</a></code>. <br /></td></tr>
<tr class="separator:a6b628b719e381d78e16d8535f7cbc6d0"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Creation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp67d5168b4f2b5424a3d118ea9ef99372"></a>An object of type <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html" title="An object of class Approximate_min_ellipsoid_d is an approximation to the ellipsoid of smallest volum...">Approximate_min_ellipsoid_d</a></code> can be created from an arbitrary point set \( P\) and some nonnegative <code>double</code> value <code>eps</code>. </p>
</td></tr>
<tr class="memitem:a5fc0bc1c66b59556c903bfbc844f15fa"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a5fc0bc1c66b59556c903bfbc844f15fa"><td class="memTemplItemLeft" align="right" valign="top"> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a5fc0bc1c66b59556c903bfbc844f15fa">Approximate_min_ellipsoid_d</a> (double eps, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classIterator.html">Iterator</a> first, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classIterator.html">Iterator</a> last, const Traits &amp;<a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ac5ae03954e671b379a3879563ef023db">traits</a>=Traits())</td></tr>
<tr class="memdesc:a5fc0bc1c66b59556c903bfbc844f15fa"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>ame</code> to an \( (1+\epsilon)\)-approximation of \( \mel(P)\) with \( P\) being the set of points in the range [<code>first</code>,<code>last</code>).  <a href="#a5fc0bc1c66b59556c903bfbc844f15fa">More...</a><br /></td></tr>
<tr class="separator:a5fc0bc1c66b59556c903bfbc844f15fa"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Access Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpdd247f83f6875f73de7cb46b8497a926"></a>The following methods can be used to query the achieved approximation ratio \( 1+\epsilon'\) and the computed ellipsoid \( {\cal E} = \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq 0 \}\).</p>
<p>The methods <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a32b71cb636acb2f6b34e96465c5379e0" title="gives access to the th entry of the matrix  in the representation  of the computed approximation elli...">defining_matrix()</a></code>, <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a4aa3e857cdd79771f39aad531157b5f0" title="gives access to the th entry of the vector  in the representation  of the computed approximation elli...">defining_vector()</a></code>, and <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ad54fb77e5183d93d86840ba89ea95478" title="gives access to the scalar  from the representation  of the computed approximation ellipsoid ...">defining_scalar()</a></code> do not return \( E\), \( e\), and \( \eta\) directly but yield multiples of these quantities that are exactly representable using the <code>double</code> type. (This is necessary because the parameters \( E\), \( e\), and \( \eta\) of the computed approximation ellipsoid \( {\cal E}\) might not be exactly representable as <code>double</code> numbers.) In order to access the center and semiaxes of the computed approximation ellipsoid, the functions <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aa687dcedc9b78b06f4c0e2aba9edb592" title="returns an iterator pointing to the first of the  Cartesian coordinates of the computed ellipsoid's c...">center_cartesian_begin()</a></code>, <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aeb6940806e45031a391baf58c735ec13" title="returns an iterator pointing to the first of the  descendantly sorted lengths of the computed ellipso...">axes_lengths_begin()</a></code>, and <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ac04a27480671bd6e5a2eb4cc01fa47e2" title="returns an iterator pointing to the first of the  Cartesian coordinates of the computed ellipsoid's t...">axis_direction_cartesian_begin()</a></code> can be used. In constrast to the above access functions <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a9f9fad4c126ae57c4cd3727d9283229f" title="returns a number  such that the computed approximation is (under exact arithmetic) guaranteed to be a...">achieved_epsilon()</a></code>, <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a32b71cb636acb2f6b34e96465c5379e0" title="gives access to the th entry of the matrix  in the representation  of the computed approximation elli...">defining_matrix()</a></code>, <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a4aa3e857cdd79771f39aad531157b5f0" title="gives access to the th entry of the vector  in the representation  of the computed approximation elli...">defining_vector()</a></code>, and <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ad54fb77e5183d93d86840ba89ea95478" title="gives access to the scalar  from the representation  of the computed approximation ellipsoid ...">defining_scalar()</a></code>, which return the described quantities exactly, the routines below return <em>numerical approximations</em> to the real center and real semiaxes of the computed ellipsoid; the comprised relative error may be larger than zero, and there are no guarantees for the returned quantities. </p>
</td></tr>
<tr class="memitem:a747a40738dc64031ddf3bb09144c7984"><td class="memItemLeft" align="right" valign="top"><a id="a747a40738dc64031ddf3bb09144c7984"></a>
unsigned int </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a747a40738dc64031ddf3bb09144c7984">number_of_points</a> () const</td></tr>
<tr class="memdesc:a747a40738dc64031ddf3bb09144c7984"><td class="mdescLeft"> </td><td class="mdescRight">returns the number of points of <code>ame</code>, i.e., \( |P|\). <br /></td></tr>
<tr class="separator:a747a40738dc64031ddf3bb09144c7984"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9f9fad4c126ae57c4cd3727d9283229f"><td class="memItemLeft" align="right" valign="top">double </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a9f9fad4c126ae57c4cd3727d9283229f">achieved_epsilon</a> () const</td></tr>
<tr class="memdesc:a9f9fad4c126ae57c4cd3727d9283229f"><td class="mdescLeft"> </td><td class="mdescRight">returns a number \( \epsilon'\) such that the computed approximation is (under exact arithmetic) guaranteed to be an \( (1+\epsilon')\)-approximation to \( \mel(P)\).  <a href="#a9f9fad4c126ae57c4cd3727d9283229f">More...</a><br /></td></tr>
<tr class="separator:a9f9fad4c126ae57c4cd3727d9283229f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a32b71cb636acb2f6b34e96465c5379e0"><td class="memItemLeft" align="right" valign="top">double </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a32b71cb636acb2f6b34e96465c5379e0">defining_matrix</a> (int i, int j) const</td></tr>
<tr class="memdesc:a32b71cb636acb2f6b34e96465c5379e0"><td class="mdescLeft"> </td><td class="mdescRight">gives access to the \( (i,j)\)th entry of the matrix \( E\) in the representation \( \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq0 \}\) of the computed approximation ellipsoid \( {\cal E}\).  <a href="#a32b71cb636acb2f6b34e96465c5379e0">More...</a><br /></td></tr>
<tr class="separator:a32b71cb636acb2f6b34e96465c5379e0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4aa3e857cdd79771f39aad531157b5f0"><td class="memItemLeft" align="right" valign="top">double </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a4aa3e857cdd79771f39aad531157b5f0">defining_vector</a> (int i) const</td></tr>
<tr class="memdesc:a4aa3e857cdd79771f39aad531157b5f0"><td class="mdescLeft"> </td><td class="mdescRight">gives access to the \( i\)th entry of the vector \( e\) in the representation \( \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq0 \}\) of the computed approximation ellipsoid \( {\cal E}\).  <a href="#a4aa3e857cdd79771f39aad531157b5f0">More...</a><br /></td></tr>
<tr class="separator:a4aa3e857cdd79771f39aad531157b5f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad54fb77e5183d93d86840ba89ea95478"><td class="memItemLeft" align="right" valign="top">double </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ad54fb77e5183d93d86840ba89ea95478">defining_scalar</a> () const</td></tr>
<tr class="memdesc:ad54fb77e5183d93d86840ba89ea95478"><td class="mdescLeft"> </td><td class="mdescRight">gives access to the scalar \( \eta\) from the representation \( \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq0 \}\) of the computed approximation ellipsoid \( {\cal E}\).  <a href="#ad54fb77e5183d93d86840ba89ea95478">More...</a><br /></td></tr>
<tr class="separator:ad54fb77e5183d93d86840ba89ea95478"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac5ae03954e671b379a3879563ef023db"><td class="memItemLeft" align="right" valign="top"><a id="ac5ae03954e671b379a3879563ef023db"></a>
const Traits &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ac5ae03954e671b379a3879563ef023db">traits</a> () const</td></tr>
<tr class="memdesc:ac5ae03954e671b379a3879563ef023db"><td class="mdescLeft"> </td><td class="mdescRight">returns a const reference to the traits class object. <br /></td></tr>
<tr class="separator:ac5ae03954e671b379a3879563ef023db"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6642c2338f25f191e95232126bf9e729"><td class="memItemLeft" align="right" valign="top"><a id="a6642c2338f25f191e95232126bf9e729"></a>
int </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a6642c2338f25f191e95232126bf9e729">dimension</a> () const</td></tr>
<tr class="memdesc:a6642c2338f25f191e95232126bf9e729"><td class="mdescLeft"> </td><td class="mdescRight">returns the dimension of the ambient space, i.e., the dimension of the points \( P\). <br /></td></tr>
<tr class="separator:a6642c2338f25f191e95232126bf9e729"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa687dcedc9b78b06f4c0e2aba9edb592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aff46f1085c9c9ccb446a8e57221ae157">Center_coordinate_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aa687dcedc9b78b06f4c0e2aba9edb592">center_cartesian_begin</a> ()</td></tr>
<tr class="memdesc:aa687dcedc9b78b06f4c0e2aba9edb592"><td class="mdescLeft"> </td><td class="mdescRight">returns an iterator pointing to the first of the \( d\) <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a> coordinates of the computed ellipsoid's center.  <a href="#aa687dcedc9b78b06f4c0e2aba9edb592">More...</a><br /></td></tr>
<tr class="separator:aa687dcedc9b78b06f4c0e2aba9edb592"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adb4dccfd4a16fe59e095c57d94498582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aff46f1085c9c9ccb446a8e57221ae157">Center_coordinate_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#adb4dccfd4a16fe59e095c57d94498582">center_cartesian_end</a> ()</td></tr>
<tr class="memdesc:adb4dccfd4a16fe59e095c57d94498582"><td class="mdescLeft"> </td><td class="mdescRight">returns the past-the-end iterator corresponding to <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aa687dcedc9b78b06f4c0e2aba9edb592" title="returns an iterator pointing to the first of the  Cartesian coordinates of the computed ellipsoid's c...">center_cartesian_begin()</a></code>.  <a href="#adb4dccfd4a16fe59e095c57d94498582">More...</a><br /></td></tr>
<tr class="separator:adb4dccfd4a16fe59e095c57d94498582"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeb6940806e45031a391baf58c735ec13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a72cb50febc6d4c7c24c68a8016bde351">Axes_lengths_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aeb6940806e45031a391baf58c735ec13">axes_lengths_begin</a> ()</td></tr>
<tr class="memdesc:aeb6940806e45031a391baf58c735ec13"><td class="mdescLeft"> </td><td class="mdescRight">returns an iterator pointing to the first of the \( d\) descendantly sorted lengths of the computed ellipsoid's axes.  <a href="#aeb6940806e45031a391baf58c735ec13">More...</a><br /></td></tr>
<tr class="separator:aeb6940806e45031a391baf58c735ec13"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a25d9a8946ab4c81f8dbfb45dddb7f701"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a72cb50febc6d4c7c24c68a8016bde351">Axes_lengths_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a25d9a8946ab4c81f8dbfb45dddb7f701">axes_lengths_end</a> ()</td></tr>
<tr class="memdesc:a25d9a8946ab4c81f8dbfb45dddb7f701"><td class="mdescLeft"> </td><td class="mdescRight">returns the past-the-end iterator corresponding to <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aeb6940806e45031a391baf58c735ec13" title="returns an iterator pointing to the first of the  descendantly sorted lengths of the computed ellipso...">axes_lengths_begin()</a></code>.  <a href="#a25d9a8946ab4c81f8dbfb45dddb7f701">More...</a><br /></td></tr>
<tr class="separator:a25d9a8946ab4c81f8dbfb45dddb7f701"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac04a27480671bd6e5a2eb4cc01fa47e2"><td class="memItemLeft" align="right" valign="top">Axes_direction_coordinate_iterator </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ac04a27480671bd6e5a2eb4cc01fa47e2">axis_direction_cartesian_begin</a> (int i)</td></tr>
<tr class="memdesc:ac04a27480671bd6e5a2eb4cc01fa47e2"><td class="mdescLeft"> </td><td class="mdescRight">returns an iterator pointing to the first of the \( d\) Cartesian coordinates of the computed ellipsoid's \( i\)th axis direction (i.e., unit vector in direction of the ellipsoid's \( i\)th axis).  <a href="#ac04a27480671bd6e5a2eb4cc01fa47e2">More...</a><br /></td></tr>
<tr class="separator:ac04a27480671bd6e5a2eb4cc01fa47e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7e8f229884c9903afa2aa39155c08f29"><td class="memItemLeft" align="right" valign="top">Axes_direction_coordinate_iterator </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a7e8f229884c9903afa2aa39155c08f29">axis_direction_cartesian_end</a> (int i)</td></tr>
<tr class="memdesc:a7e8f229884c9903afa2aa39155c08f29"><td class="mdescLeft"> </td><td class="mdescRight">returns the past-the-end iterator corresponding to <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ac04a27480671bd6e5a2eb4cc01fa47e2" title="returns an iterator pointing to the first of the  Cartesian coordinates of the computed ellipsoid's t...">axis_direction_cartesian_begin()</a></code>.  <a href="#a7e8f229884c9903afa2aa39155c08f29">More...</a><br /></td></tr>
<tr class="separator:a7e8f229884c9903afa2aa39155c08f29"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Predicates</h2></td></tr>
<tr class="memitem:a636b12855568f4471e0dadc3d6fefb3f"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a636b12855568f4471e0dadc3d6fefb3f">is_full_dimensional</a> () const</td></tr>
<tr class="memdesc:a636b12855568f4471e0dadc3d6fefb3f"><td class="mdescLeft"> </td><td class="mdescRight">returns whether \( P\) is full-dimensional or not, i.e., returns <code>true</code> if and only if \( P\) is full-dimensional.  <a href="#a636b12855568f4471e0dadc3d6fefb3f">More...</a><br /></td></tr>
<tr class="separator:a636b12855568f4471e0dadc3d6fefb3f"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Validity Check</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp631258ad6e3d5f0d54bd2f2c73d1a296"></a>An object <code>ame</code> is valid iff</p>
<ul>
<li>
<code>ame</code> contains all points of its defining set \( P\), </li>
<li>
<code>ame</code> is an \( (1+\epsilon')\)-approximation to the smallest ellipsoid \( \mel(P)\) of \( P\), </li>
<li>
The ellipsoid represented by <code>ame</code> fulfills the inclusion ( <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#eqapproximate_min_ellipsoid_incl">eqapproximate_min_ellipsoid_incl</a> ). </li>
</ul>
</td></tr>
<tr class="memitem:a2449d677fe6d12a445d5a090723d9349"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a2449d677fe6d12a445d5a090723d9349">is_valid</a> (bool verbose=false) const</td></tr>
<tr class="memdesc:a2449d677fe6d12a445d5a090723d9349"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code> iff <code>ame</code> is valid according to the above definition.  <a href="#a2449d677fe6d12a445d5a090723d9349">More...</a><br /></td></tr>
<tr class="separator:a2449d677fe6d12a445d5a090723d9349"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Miscellaneous</h2></td></tr>
<tr class="memitem:a1cd41640f8cf8b562772399a0fb00b13"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a1cd41640f8cf8b562772399a0fb00b13">write_eps</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a1cd41640f8cf8b562772399a0fb00b13"><td class="mdescLeft"> </td><td class="mdescRight">Writes the points \( P\) and the computed approximation to \( \mel(P)\) as an EPS-file under pathname <code>name</code>.  <a href="#a1cd41640f8cf8b562772399a0fb00b13">More...</a><br /></td></tr>
<tr class="separator:a1cd41640f8cf8b562772399a0fb00b13"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5fc0bc1c66b59556c903bfbc844f15fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc0bc1c66b59556c903bfbc844f15fa">◆ </a></span>Approximate_min_ellipsoid_d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::<a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">Approximate_min_ellipsoid_d</a> </td>
          <td>(</td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classIterator.html">Iterator</a> </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classIterator.html">Iterator</a> </td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> = <code>Traits()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes <code>ame</code> to an \( (1+\epsilon)\)-approximation of \( \mel(P)\) with \( P\) being the set of points in the range [<code>first</code>,<code>last</code>). </p>
<p>The number \( \epsilon\) in this will be at most <code>eps</code>, if possible. However, due to the limited precision in the algorithm's underlying arithmetic, it can happen that the computed approximation ellipsoid has a worse approximation ratio (and \( \epsilon\) can thus be larger than <code>eps</code> in general). In any case, the number \( \epsilon\) (and with this, the achived approximation \( 1+\epsilon\)) can be queried by calling the routine <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a9f9fad4c126ae57c4cd3727d9283229f" title="returns a number  such that the computed approximation is (under exact arithmetic) guaranteed to be a...">achieved_epsilon()</a></code> discussed below.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classIterator.html">Iterator</a></td><td>must be a model of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classInputIterator.html">InputIterator</a></code> with <code>Point</code> as value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The dimension \( d\) of the input points must be at least \( 2\), and \( \epsilon&gt;0\). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9f9fad4c126ae57c4cd3727d9283229f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9fad4c126ae57c4cd3727d9283229f">◆ </a></span>achieved_epsilon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::achieved_epsilon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a number \( \epsilon'\) such that the computed approximation is (under exact arithmetic) guaranteed to be an \( (1+\epsilon')\)-approximation to \( \mel(P)\). </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>ame.is_full_dimensional() == true</code>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>\( \epsilon'&gt;0\). </dd></dl>

</div>
</div>
<a id="aeb6940806e45031a391baf58c735ec13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6940806e45031a391baf58c735ec13">◆ </a></span>axes_lengths_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a72cb50febc6d4c7c24c68a8016bde351">Axes_lengths_iterator</a> <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::axes_lengths_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns an iterator pointing to the first of the \( d\) descendantly sorted lengths of the computed ellipsoid's axes. </p>
<p>The \( d\) returned numbers are floating-point approximations to the exact axes-lengths of the computed ellipsoid; no guarantee is given w.r.t. the involved relative error. (See also method <code>axes_direction_cartesian_begin()</code>.) </p><dl class="section pre"><dt>Precondition</dt><dd><code>ame.is_full_dimensional() == true</code>, and \( d\in\{2,3\}\). </dd></dl>

</div>
</div>
<a id="a25d9a8946ab4c81f8dbfb45dddb7f701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d9a8946ab4c81f8dbfb45dddb7f701">◆ </a></span>axes_lengths_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a72cb50febc6d4c7c24c68a8016bde351">Axes_lengths_iterator</a> <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::axes_lengths_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the past-the-end iterator corresponding to <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aeb6940806e45031a391baf58c735ec13" title="returns an iterator pointing to the first of the  descendantly sorted lengths of the computed ellipso...">axes_lengths_begin()</a></code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>ame.is_full_dimensional() == true</code>, and \( d\in\{2,3\}\). </dd></dl>

</div>
</div>
<a id="ac04a27480671bd6e5a2eb4cc01fa47e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04a27480671bd6e5a2eb4cc01fa47e2">◆ </a></span>axis_direction_cartesian_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Axes_direction_coordinate_iterator <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::axis_direction_cartesian_begin </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns an iterator pointing to the first of the \( d\) Cartesian coordinates of the computed ellipsoid's \( i\)th axis direction (i.e., unit vector in direction of the ellipsoid's \( i\)th axis). </p>
<p>The direction described by this iterator is a floating-point approximation to the exact axis direction of the computed ellipsoid; no guarantee is given w.r.t. the involved relative error. An approximation to the length of axis \( i\) is given by the \( i\)th entry of <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aeb6940806e45031a391baf58c735ec13" title="returns an iterator pointing to the first of the  descendantly sorted lengths of the computed ellipso...">axes_lengths_begin()</a></code>. </p><dl class="section pre"><dt>Precondition</dt><dd><code>ame.is_full_dimensional() == true</code>, and \( d\in\{2,3\}\), and \( 0\leq i &lt; d\). </dd></dl>

</div>
</div>
<a id="a7e8f229884c9903afa2aa39155c08f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8f229884c9903afa2aa39155c08f29">◆ </a></span>axis_direction_cartesian_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Axes_direction_coordinate_iterator <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::axis_direction_cartesian_end </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the past-the-end iterator corresponding to <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#ac04a27480671bd6e5a2eb4cc01fa47e2" title="returns an iterator pointing to the first of the  Cartesian coordinates of the computed ellipsoid's t...">axis_direction_cartesian_begin()</a></code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>ame.is_full_dimensional() == true</code>, and \( d\in\{2,3\}\), and \( 0\leq i &lt; d\). </dd></dl>

</div>
</div>
<a id="aa687dcedc9b78b06f4c0e2aba9edb592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa687dcedc9b78b06f4c0e2aba9edb592">◆ </a></span>center_cartesian_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aff46f1085c9c9ccb446a8e57221ae157">Center_coordinate_iterator</a> <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::center_cartesian_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns an iterator pointing to the first of the \( d\) <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a> coordinates of the computed ellipsoid's center. </p>
<p>The returned point is a floating-point approximation to the ellipsoid's exact center; no guarantee is given w.r.t. the involved relative error. </p><dl class="section pre"><dt>Precondition</dt><dd><code>ame.is_full_dimensional() == true</code>. </dd></dl>

</div>
</div>
<a id="adb4dccfd4a16fe59e095c57d94498582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4dccfd4a16fe59e095c57d94498582">◆ </a></span>center_cartesian_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aff46f1085c9c9ccb446a8e57221ae157">Center_coordinate_iterator</a> <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::center_cartesian_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the past-the-end iterator corresponding to <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#aa687dcedc9b78b06f4c0e2aba9edb592" title="returns an iterator pointing to the first of the  Cartesian coordinates of the computed ellipsoid's c...">center_cartesian_begin()</a></code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>ame.is_full_dimensional() == true</code>. </dd></dl>

</div>
</div>
<a id="a32b71cb636acb2f6b34e96465c5379e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b71cb636acb2f6b34e96465c5379e0">◆ </a></span>defining_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::defining_matrix </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>j</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gives access to the \( (i,j)\)th entry of the matrix \( E\) in the representation \( \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq0 \}\) of the computed approximation ellipsoid \( {\cal E}\). </p>
<p>The number returned by this routine is \( (1+\epsilon')(d+1)\,E_{ij}\), where \( \epsilon'\) is the number returned by <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a9f9fad4c126ae57c4cd3727d9283229f" title="returns a number  such that the computed approximation is (under exact arithmetic) guaranteed to be a...">achieved_epsilon()</a></code>. </p><dl class="section pre"><dt>Precondition</dt><dd>\( 0\leq i,j\leq d\), where \( d\) is the dimension of the points \( P\), and <code>ame.is_full_dimensional() == true</code>. </dd></dl>

</div>
</div>
<a id="ad54fb77e5183d93d86840ba89ea95478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54fb77e5183d93d86840ba89ea95478">◆ </a></span>defining_scalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::defining_scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gives access to the scalar \( \eta\) from the representation \( \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq0 \}\) of the computed approximation ellipsoid \( {\cal E}\). </p>
<p>The number returned by this routine is \( (1+\epsilon')(d+1)\,(\eta+1)\), where \( \epsilon'\) is the number returned by <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a9f9fad4c126ae57c4cd3727d9283229f" title="returns a number  such that the computed approximation is (under exact arithmetic) guaranteed to be a...">achieved_epsilon()</a></code>. </p><dl class="section pre"><dt>Precondition</dt><dd><code>ame.is_full_dimensional() == true</code>. </dd></dl>

</div>
</div>
<a id="a4aa3e857cdd79771f39aad531157b5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa3e857cdd79771f39aad531157b5f0">◆ </a></span>defining_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::defining_vector </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gives access to the \( i\)th entry of the vector \( e\) in the representation \( \{ x\in\E^d \mid x^T E x + x^T e + \eta\leq0 \}\) of the computed approximation ellipsoid \( {\cal E}\). </p>
<p>The number returned by this routine is \( (1+\epsilon')(d+1)\,e_{i}\), where \( \epsilon'\) is the number returned by <code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html#a9f9fad4c126ae57c4cd3727d9283229f" title="returns a number  such that the computed approximation is (under exact arithmetic) guaranteed to be a...">achieved_epsilon()</a></code>. </p><dl class="section pre"><dt>Precondition</dt><dd>\( 0\leq i\leq d\), where \( d\) is the dimension of the points \( P\), and <code>ame.is_full_dimensional() == true</code>. </dd></dl>

</div>
</div>
<a id="a636b12855568f4471e0dadc3d6fefb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636b12855568f4471e0dadc3d6fefb3f">◆ </a></span>is_full_dimensional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::is_full_dimensional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether \( P\) is full-dimensional or not, i.e., returns <code>true</code> if and only if \( P\) is full-dimensional. </p>
<p><em>Note:</em> due to the limited precision in the algorithm's underlying arithmetic, the result of this method is not always correct. Rather, a return value of <code>false</code> means that the points \( P\) are contained in a "very thin" linear subspace of \( \E^d\), and as a consequence, the algorithm cannot compute an approximation. More precisely, a return value of <code>false</code> means that the points \( P\) are contained between two parallel hyperplanes in \( \E^d\) that are very close to each other (possibly at distance zero) - so close, that the algorithm could not compute an approximation ellipsoid. Similarly, a return value of <code>true</code> does not guarantee \( P\) to be full-dimensional; but there exists an input pointset \( P'\) such that the points \( P'\) and \( P\) have almost identical coordinates and \( P'\) is full-dimensional. </p>

</div>
</div>
<a id="a2449d677fe6d12a445d5a090723d9349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2449d677fe6d12a445d5a090723d9349">◆ </a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::is_valid </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns <code>true</code> iff <code>ame</code> is valid according to the above definition. </p>
<p>If <code>verbose</code> is <code>true</code>, some messages concerning the performed checks are written to the standard error stream. </p>

</div>
</div>
<a id="a1cd41640f8cf8b562772399a0fb00b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd41640f8cf8b562772399a0fb00b13">◆ </a></span>write_eps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt; Traits &gt;::write_eps </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp; </td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the points \( P\) and the computed approximation to \( \mel(P)\) as an EPS-file under pathname <code>name</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The dimension of points \( P\) must be \( 2\). <em>Note:</em> this routine is provided as a debugging routine; future version of <span style="font-variant: small-caps;">CGAL</span> might not provide it anymore. </dd>
<dd>
<code>ame.is_full_dimensional() == true</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../Manual/namespaceCGAL.html">CGAL</a></li><li class="navelem"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">Approximate_min_ellipsoid_d</a></li>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:55 for CGAL 4.13 - Bounding Volumes by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>



</html>
