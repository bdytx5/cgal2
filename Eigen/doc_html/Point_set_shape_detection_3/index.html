<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Point_set_shape_detection_3/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Point Set Shape Detection: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Point Set Shape Detection
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Point_Set_Shape_Detection"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Sven Oesau, Yannick Verdie, Cl√©ment Jamin, Pierre Alliez, Florent Lafarge, Simon Giraudot</dd></dl>
<h1><a class="anchor" id="Point_set_shape_detection_3Introduction"></a>
Introduction</h1>
<p>This <span style="font-variant: small-caps;">CGAL</span> component implements two algorithms for shape detection:</p>
<ul>
<li>the efficient RANSAC method for shape detection, contributed by Schnabel et al. <a class="el" href="citelist.html#CITEREF_schnabel2007efficient">[2]</a>;</li>
<li>the region growing method, contributed by Lafarge and Mallet <a class="el" href="citelist.html#CITEREF_cgal:lm-clscm-12">[1]</a>.</li>
</ul>
<p>From an unstructured point set with unoriented normals, these algorithms detect a set of shapes (see <a class="el" href="index.html#fig__Point_set_shape_detection_3_overview">Figure 73.1</a>). Five types of primitive shapes are provided by this package: plane, sphere, cylinder, cone and torus. Other types of primitive shapes can also be added by the user.</p>
<p>Note that at the moment, region growing only detects planes.</p>
<p><a class="anchor" id="fig__Point_set_shape_detection_3_overview"></a></p><div class="image">
<img src="overview2.png" alt="overview2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_shape_detection_3_overview">Figure 73.1</a> (a) Input point set. (b) Point set depicted with one color per detected shape.  </div>  <br />

<h1><a class="anchor" id="Point_set_shape_detection_3Method"></a>
Methods</h1>
<p>Both methods take as input a point set with unoriented normals and provide as output a set of detected shapes with associated input points. The output of the shape detection algorithms is a set of detected shapes with assigned points and all remaining points not covered by these shapes. Each input point can be assigned to at most one detected shape.</p>
<h2><a class="anchor" id="Point_set_shape_detection_3Method_RANSAC"></a>
Efficient RANSAC</h2>
<p>The shapes are detected via a RANSAC-type approach, i.e., a random sample consensus. The basic RANSAC approach repeats the following steps: (1) Randomly select samples from the input points. (2) Fit a shape to the selected samples. (3) Count the number of inliers to the shape, inliers being within a user-specified error tolerance to the shape. Steps 1-3 are repeated for a prescribed number of iterations and the shape with highest number of inliers, referred to as largest shape, is kept.</p>
<p>In our context, the error between a point and a shape is defined by its distance and normal deviation to the shape. A random subset corresponds to the minimal number of points (with normals) required to uniquely define a primitive.</p>
<p>For very large point sets the basic RANSAC method is not practical when testing all possible shape candidates against the input data in order to find the largest shape. The main idea behind the efficient RANSAC method consists in testing shape candidates against <em>subsets</em> of the input data. Shape candidates are constructed until the probability to miss the largest candidate is lower than a user-specified parameter. The largest shape is repeatedly extracted until no more shapes, restricted to cover a minimum number of points, can be extracted. An additional gain in efficiency is achieved through exploiting the normal attributes during initial shape construction and enumeration of inliers.</p>
<p>The <em>support</em> of a shape refers to the footprint of the points covered by the primitive. To avoid generating shapes with fragmented support we enforce a connectivity constraint by considering only one connected component, referred to as cluster, selected as the one covering the largest number of inliers. See Section <a class="el" href="index.html#Point_set_shape_detection_3Parameters">Parameters</a> for more details.</p>
<h2><a class="anchor" id="Point_set_shape_detection_3Method_region_growing"></a>
Region Growing</h2>
<p>Planes are detected by growing planar regions from estimated planar seeds. First, points are sorted by a local planarity measure (the fitting quality returned by <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Principal_component_analysis.tag:../Principal_component_analysis/" href="../Principal_component_analysis/group__PkgPrincipalComponentAnalysisDLLSF3.html#gadcf556c115c6bac30a54bf7fdd0d32e3">linear_least_squares_fitting_3()</a></code>), such that points whose local neighborhood is the most planar are treated first.</p>
<p>The following steps are repeated: (1) Pick the next available point in the sorted list. (2) Initialize a plane tangent to this point and perpendicular to the normal vector of this point. (3) Compute the local neighborhood of the point with a user-specified radius. (4) Find inliers among these points, i.e. points that are within a user-specified error tolerance to the plane (and with a normal deviation within a user-specified tolerance to the normal of the plane). Steps 3-4 are repeated until no other inlier can be added. The plane is periodically reestimated by principal component analysis using all the inliers. If, after the growing, the plane has less inliers than a user-specified minimum number of points, it is discarded and the points are made available for other shapes to take once again.</p>
<h2><a class="anchor" id="Point_set_shape_detection_3Method_comparison"></a>
Comparisons</h2>
<p>The efficient RANSAC is a very quick method. Because it is based on randomness, it is not deterministic and some small shapes might be missed in the detection process.</p>
<p>Region growing usually takes longer than the efficient RANSAC but may provide better quality output in the presence of large scenes with numerous small details: as it iterates throughout all points of the scene, there are less chances of missing a shape. In addition, it is deterministic (for a given input and a given set of parameters, it always returns the same output, whereas as RANSAC uses randomness to detect shapes, the output of a RANSAC algorithm may vary). See figure <a class="el" href="index.html#fig__Point_set_shape_detection_3Method_comparison_figure">Figure 73.2</a>.</p>
<p><a class="anchor" id="fig__Point_set_shape_detection_3Method_comparison_figure"></a></p><div class="image">
<img src="comparison.png" alt="comparison.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_shape_detection_3Method_comparison_figure">Figure 73.2</a> Comparison of efficient RANSAC and region growing. Top: input point set. Bottom left: output of efficient RANSAC, \(78\%\) of the shapes correctly detected in 8 seconds. Bottom right: output of region growing, \(100\%\) of the shapes detected in 15 seconds. Unassigned points are in black in both output images.  </div>  <br />

<h1><a class="anchor" id="Point_set_shape_detection_3Parameters"></a>
Parameters</h1>
<p>The algorithms have four parameters that are common. They have the same effects on the output for both RANSAC and region growing.</p>
<ul>
<li><code>epsilon</code> and <code>normal_threshold</code>: The error between a point-with-normal \(p\) and a shape \(S\) is defined by its Euclidean distance and normal deviation to \(S\). The normal deviation is computed between the normal at \(p\) and the normal of \(S\) at the closest projection of \(p\) onto \(S\). Parameter <code>epsilon</code> defines the absolute maximum tolerance Euclidean distance between a point and a shape. A high value for <code>epsilon</code> leads to the detection of fewer large shapes and hence a less detailed detection. A low value for <code>epsilon</code> yields a more detailed detection, but may lead to either lower coverage or over-segmentation. Over-segmentation translates into detection of fragmented shapes when <code>epsilon</code> is within or below the noise level. When the input point set is made of free-form parts, a higher tolerance <code>epsilon</code> allows for detecting more primitive shapes that approximate some of the free-form surfaces. The impact of this parameter is depicted by Figure <a class="el" href="index.html#fig__Point_set_shape_detection_3_parameter_epsilon_variation">Figure 73.3</a>. Its impact on performance is evaluated in Section <a class="el" href="index.html#Point_set_shape_detection_3Performance">Performances</a>. <a class="anchor" id="fig__Point_set_shape_detection_3_parameter_epsilon_variation"></a><div class="image">
<img src="epsilon_variation2.png" alt="epsilon_variation2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_shape_detection_3_parameter_epsilon_variation">Figure 73.3</a> Impact of epsilon over level of details of the detection. (a) Input point set. (b) Detection of planar shapes with epsilon set to 2.0 (one color per detected shape). Most details such as chimneys on the roof are not distinguished. (c) Detection with epsilon set to 0.5. The facades are correctly detected and some details of the roof are detected. (d) Setting epsilon to 0.25 yields a more detailed but slightly over-segmented detection.  </div>  <br />
</li>
<li><code>cluster_epsilon</code>: The region growing algorithm uses <code>cluster_epsilon</code> to compute the neighborhood around points when growing the regions while the efficient RANSAC uses this parameter to cluster the points into connected components covered by a detected shape. For developable shapes that admit a trivial planar parameterization (plane, cylinder, cone) the points covered by a shape are mapped to a 2D parameter space chosen to minimize distortion and best preserve arc-length distances. This 2D parameter space is discretized using a regular grid, and a connected component search is performed to identify the largest cluster. Parameter <code>cluster_epsilon</code> defines the spacing between two cells of the regular grid, so that two points separated by a distance of at most \(2\sqrt{2}\), <code>cluster_epsilon</code> are considered adjacent. For non-developable shapes the connected components are identified by computing a neighboring graph in 3D and walking in the graph. The impact of parameter cluster_epsilon is depicted by Figure <a class="el" href="index.html#fig__Point_set_shape_detection_3_parameter_connectivity">Figure 73.4</a>.</li>
</ul>
<p><a class="anchor" id="fig__Point_set_shape_detection_3_parameter_connectivity"></a></p><div class="image">
<img src="varying_connectivity.png" alt="varying_connectivity.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_shape_detection_3_parameter_connectivity">Figure 73.4</a> For efficient RANSAC, parameter cluster_epsilon controls the connectivity of the points covered by a detected shape. The input point set is sampled on four coplanar squares. (a) A large value for cluster_epsilon leads to detecting a single planar shape. (b) A moderate value for cluster_epsilon yields the detection of four squares. Notice that few points within the squares are not detected as not connected. (c) A small value for cluster_epsilon leads to over-segmentation.  </div>  <br />

<ul>
<li><code>min_points</code>: This minimum number of points controls the termination of the algorithm. The shape search is iterated until no further shapes can be found with a higher support. Note that for efficient RANSAC, this parameter is not strict: depending on the chosen probability, shapes may be extracted with a number of points lower than the specified parameter.</li>
</ul>
<p>In addition, the efficient RANSAC has a fifth parameter:</p>
<ul>
<li><code>probability</code>: This parameter defines the probability to miss the largest candidate shape. A lower probability provides a higher reliability and determinism at the cost of longer running times due to higher search endurance.</li>
</ul>
<h1><a class="anchor" id="Point_set_shape_detection_3Usage"></a>
Examples</h1>
<p>The main classes <code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Efficient__RANSAC.html" title="A shape detection algorithm using a RANSAC method. ">Shape_detection_3::Efficient_RANSAC</a></code> and <code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Region__growing.html" title="A shape detection algorithm using a region growing method. ">Shape_detection_3::Region_growing</a></code> take a template parameter <code><a class="el" href="structCGAL_1_1Shape__detection__3_1_1Shape__detection__traits.html" title="Default traits class to use the shape detection class Efficient_RANSAC. ">Shape_detection_3::Shape_detection_traits</a></code> that defines the geometric types and input format. Property maps provide a means to interface with user-specific data structures. The first parameter of the <code><a class="el" href="structCGAL_1_1Shape__detection__3_1_1Shape__detection__traits.html" title="Default traits class to use the shape detection class Efficient_RANSAC. ">Shape_detection_3::Shape_detection_traits</a></code> class is the common <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>. In order to match the constraints of property maps, an iterator type and two maps that map an iterator to a point and a normal are specified in the <code><a class="el" href="structCGAL_1_1Shape__detection__3_1_1Shape__detection__traits.html" title="Default traits class to use the shape detection class Efficient_RANSAC. ">Shape_detection_3::Shape_detection_traits</a></code> class. The concept behind property maps is detailed in <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/index.html#chapterProperty_map">CGAL and Propery Maps</a>.</p>
<p>Typical usage consists of five steps:</p>
<ol type="1">
<li>Provide input data via a range iterator</li>
<li>Register shape factories</li>
<li>Choose parameters</li>
<li>Detect</li>
<li>Retrieve detected shapes</li>
</ol>
<h2><a class="anchor" id="Point_set_shape_detection_3Usage_minimal"></a>
Basic Planar Shape Detection</h2>
<p>The following minimal example reads a point set from a file and detects only planar shapes. The default parameters are used for detection.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_shape_detection_3_2shape_detection_basic_8cpp-example.html">Point_set_shape_detection_3/shape_detection_basic.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_xyz_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_with_normal_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__detection__3_8h.html">CGAL/Shape_detection_3.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="comment">// In Shape_detection_traits the basic types, i.e., Point and Vector types</span></div><div class="line"><span class="comment">// as well as iterator type and property maps, are defined.</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Shape__detection__3_1_1Shape__detection__traits.html">CGAL::Shape_detection_3::Shape_detection_traits</a></div><div class="line">  &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>, Pwn_vector, Point_map, Normal_map&gt;                Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Efficient__RANSAC.html">CGAL::Shape_detection_3::Efficient_RANSAC&lt;Traits&gt;</a>    Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Region__growing.html">CGAL::Shape_detection_3::Region_growing&lt;Traits&gt;</a>      Region_growing;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Plane.html">CGAL::Shape_detection_3::Plane&lt;Traits&gt;</a>               Plane;</div><div class="line"></div><div class="line"><span class="comment">// This program both works for RANSAC and Region Growing</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ShapeDetection&gt;</div><div class="line"><span class="keywordtype">int</span> run(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename)</div><div class="line">{</div><div class="line">  <span class="comment">// Points with normals.</span></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Loads point set from a file. </span></div><div class="line">  <span class="comment">// read_xyz_points_and_normals takes an OutputIterator for storing the points</span></div><div class="line">  <span class="comment">// and a property map to store the normal vector with each point.</span></div><div class="line">  std::ifstream stream(filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!stream || </div><div class="line">    !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessingIO.html#ga2e8d677def85c5582ba1f01eda030628">CGAL::read_xyz_points</a>(stream,</div><div class="line">      std::back_inserter(points),</div><div class="line">      CGAL::parameters::point_map(Point_map()).</div><div class="line">      normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn"</span> &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Instantiates shape detection engine.</span></div><div class="line">  ShapeDetection shape_detection;</div><div class="line"></div><div class="line">  <span class="comment">// Provides the input data.</span></div><div class="line">  shape_detection.set_input(points);</div><div class="line"></div><div class="line">  <span class="comment">// Registers planar shapes via template method.</span></div><div class="line">  shape_detection.template add_shape_factory&lt;Plane&gt;();</div><div class="line"></div><div class="line">  <span class="comment">// Detects registered shapes with default parameters.</span></div><div class="line">  shape_detection.detect();</div><div class="line"></div><div class="line">  <span class="comment">// Prints number of detected shapes.</span></div><div class="line">  std::cout &lt;&lt; shape_detection.shapes().end() - shape_detection.shapes().begin() &lt;&lt; <span class="stringliteral">" shapes detected."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1 &amp;&amp; std::string(argv[1]) == <span class="stringliteral">"-r"</span>)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Efficient RANSAC"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> run&lt;Efficient_ransac&gt; ((argc &gt; 2) ? argv[2] : <span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Region Growing"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> run&lt;Region_growing&gt; ((argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_shape_detection_3Usage_callback"></a>
Planar Shape Detection with Callback</h2>
<p>Both Region Growing and Efficient RANSAC provide a callback mechanism that enables the user to track the progress of the algorithms. It can be used, for example, to terminate the algorithm based on a timeout. In the following example, the algorithm stops if it takes more than half a second and prints out the progress made:</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_shape_detection_3_2shape_detection_with_callback_8cpp-example.html">Point_set_shape_detection_3/shape_detection_with_callback.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_xyz_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_with_normal_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__detection__3_8h.html">CGAL/Shape_detection_3.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="comment">// In Shape_detection_traits the basic types, i.e., Point and Vector types</span></div><div class="line"><span class="comment">// as well as iterator type and property maps, are defined.</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Shape__detection__3_1_1Shape__detection__traits.html">CGAL::Shape_detection_3::Shape_detection_traits</a></div><div class="line">  &lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;                Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Efficient__RANSAC.html">CGAL::Shape_detection_3::Efficient_RANSAC&lt;Traits&gt;</a>    Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Region__growing.html">CGAL::Shape_detection_3::Region_growing&lt;Traits&gt;</a>      Region_growing;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Plane.html">CGAL::Shape_detection_3::Plane&lt;Traits&gt;</a>               Plane;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Timeout_callback</div><div class="line">{</div><div class="line">  <span class="keyword">mutable</span> <span class="keywordtype">int</span> nb;</div><div class="line">  <span class="keyword">mutable</span> CGAL::Timer timer;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> limit;</div><div class="line">  </div><div class="line">  Timeout_callback(<span class="keywordtype">double</span> limit) : nb(0), limit(limit)</div><div class="line">  {</div><div class="line">    timer.start();</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keywordtype">double</span> advancement)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="comment">// Avoid calling time() at every single iteration, which could</span></div><div class="line">    <span class="comment">// impact performances very badly</span></div><div class="line">    ++ nb;</div><div class="line">    <span class="keywordflow">if</span> (nb % 1000 != 0)</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">// If the limit is reach, interrupt the algorithm</span></div><div class="line">    <span class="keywordflow">if</span> (timer.time() &gt; limit)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Algorithm takes too long, exiting ("</span></div><div class="line">                &lt;&lt; 100. * advancement &lt;&lt; <span class="stringliteral">"% done)"</span> &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// This program both works for RANSAC and Region Growing</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ShapeDetection&gt;</div><div class="line"><span class="keywordtype">int</span> run(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename)</div><div class="line">{</div><div class="line">  Pwn_vector points;</div><div class="line">  std::ifstream stream(filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!stream || </div><div class="line">    !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessingIO.html#ga2e8d677def85c5582ba1f01eda030628">CGAL::read_xyz_points</a>(stream,</div><div class="line">      std::back_inserter(points),</div><div class="line">      CGAL::parameters::point_map(Point_map()).</div><div class="line">      normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn"</span> &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  ShapeDetection shape_detection;</div><div class="line">  shape_detection.set_input(points);</div><div class="line">  shape_detection.template add_shape_factory&lt;Plane&gt;();</div><div class="line"></div><div class="line">  <span class="comment">// Create callback that interrupts the algorithm if it takes more than half a second</span></div><div class="line">  Timeout_callback timeout_callback(0.5);</div><div class="line">  </div><div class="line">  <span class="comment">// Detects registered shapes with default parameters.</span></div><div class="line">  shape_detection.detect(<span class="keyword">typename</span> ShapeDetection::Parameters(),</div><div class="line">                         timeout_callback);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1 &amp;&amp; std::string(argv[1]) == <span class="stringliteral">"-r"</span>)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Efficient RANSAC"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> run&lt;Efficient_ransac&gt; ((argc &gt; 2) ? argv[2] : <span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Region Growing"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> run&lt;Region_growing&gt; ((argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_shape_detection_3Usage_parameters"></a>
Setting Parameters and Using Different Types of Shape</h2>
<p>This example illustrates the user selection of parameters using the <code><a class="el" href="structCGAL_1_1Shape__detection__3_1_1Efficient__RANSAC_1_1Parameters.html" title="Parameters for the shape detection algorithm. ">Shape_detection_3::Efficient_RANSAC::Parameters</a></code> class. Shape detection is performed on five types of shapes (plane, cylinder, sphere, cone, torus). The input point set is sampled on a surface mostly composed of piece-wise planar and cylindrical parts, in addition to free-form parts.</p>
<p>Basic information of the detected shapes is written to the standard output: if the plane is either a plane or a cylinder, specific parameters are recovered, otherwise the general method <code>info()</code> is used to get the shape parameters in a string object. Note that specific parameters can be recovered for any of the provided shape.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_shape_detection_3_2efficient_RANSAC_parameters_8cpp-example.html">Point_set_shape_detection_3/efficient_RANSAC_parameters.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_xyz_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_with_normal_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__detection__3_8h.html">CGAL/Shape_detection_3.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Type declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                           FT;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="comment">// In Shape_detection_traits the basic types, i.e., Point and Vector types</span></div><div class="line"><span class="comment">// as well as iterator type and property maps, are defined.</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Shape__detection__3_1_1Shape__detection__traits.html">CGAL::Shape_detection_3::Shape_detection_traits</a>&lt;Kernel,</div><div class="line">  Pwn_vector, Point_map, Normal_map&gt;            Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Efficient__RANSAC.html">CGAL::Shape_detection_3::Efficient_RANSAC&lt;Traits&gt;</a> Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Cone.html">CGAL::Shape_detection_3::Cone&lt;Traits&gt;</a>             Cone;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Cylinder.html">CGAL::Shape_detection_3::Cylinder&lt;Traits&gt;</a>         Cylinder;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Plane.html">CGAL::Shape_detection_3::Plane&lt;Traits&gt;</a>            Plane;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Sphere.html">CGAL::Shape_detection_3::Sphere&lt;Traits&gt;</a>           Sphere;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Torus.html">CGAL::Shape_detection_3::Torus&lt;Traits&gt;</a>            Torus;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() </div><div class="line">{</div><div class="line">  <span class="comment">// Points with normals.</span></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Loads point set from a file. </span></div><div class="line">  <span class="comment">// read_xyz_points_and_normals takes an OutputIterator for storing the points</span></div><div class="line">  <span class="comment">// and a property map to store the normal vector with each point.</span></div><div class="line">  std::ifstream stream(<span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!stream ||</div><div class="line">    !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessingIO.html#ga2e8d677def85c5582ba1f01eda030628">CGAL::read_xyz_points</a>(stream,</div><div class="line">      std::back_inserter(points),</div><div class="line">      CGAL::parameters::point_map(Point_map()).</div><div class="line">      normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Instantiates shape detection engine.</span></div><div class="line">  Efficient_ransac ransac;</div><div class="line"></div><div class="line">  <span class="comment">// Provides the input data.</span></div><div class="line">  ransac.set_input(points);</div><div class="line">    </div><div class="line">  <span class="comment">// Register shapes for detection</span></div><div class="line">  ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line">  ransac.add_shape_factory&lt;Sphere&gt;();</div><div class="line">  ransac.add_shape_factory&lt;Cylinder&gt;();</div><div class="line">  ransac.add_shape_factory&lt;Cone&gt;();</div><div class="line">  ransac.add_shape_factory&lt;Torus&gt;();</div><div class="line"></div><div class="line">  <span class="comment">// Sets parameters for shape detection.</span></div><div class="line">  Efficient_ransac::Parameters parameters;</div><div class="line"></div><div class="line">  <span class="comment">// Sets probability to miss the largest primitive at each iteration.</span></div><div class="line">  parameters.probability = 0.05;</div><div class="line"> </div><div class="line">  <span class="comment">// Detect shapes with at least 500 points.</span></div><div class="line">  parameters.min_points = 200;</div><div class="line"></div><div class="line">  <span class="comment">// Sets maximum Euclidean distance between a point and a shape.</span></div><div class="line">  parameters.epsilon = 0.002;</div><div class="line"> </div><div class="line">  <span class="comment">// Sets maximum Euclidean distance between points to be clustered.</span></div><div class="line">  parameters.cluster_epsilon = 0.01;</div><div class="line"> </div><div class="line">  <span class="comment">// Sets maximum normal deviation.</span></div><div class="line">  <span class="comment">// 0.9 &lt; dot(surface_normal, point_normal); </span></div><div class="line">  parameters.normal_threshold = 0.9;   </div><div class="line">  </div><div class="line">  <span class="comment">// Detects shapes</span></div><div class="line">  ransac.detect(parameters);</div><div class="line"></div><div class="line">  <span class="comment">// Prints number of detected shapes and unassigned points.</span></div><div class="line">   std::cout &lt;&lt; ransac.shapes().end() - ransac.shapes().begin() &lt;&lt; <span class="stringliteral">" detected shapes, "</span></div><div class="line">     &lt;&lt; ransac.number_of_unassigned_points()</div><div class="line">     &lt;&lt; <span class="stringliteral">" unassigned points."</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  <span class="comment">// Efficient_ransac::shapes() provides</span></div><div class="line">  <span class="comment">// an iterator range to the detected shapes.</span></div><div class="line">  Efficient_ransac::Shape_range shapes = ransac.shapes();</div><div class="line">  Efficient_ransac::Shape_range::iterator it = shapes.begin();</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> (it != shapes.end()) {</div><div class="line">    </div><div class="line">    <span class="comment">// Get specific parameters depending on detected shape.</span></div><div class="line">    <span class="keywordflow">if</span> (Plane* plane = dynamic_cast&lt;Plane*&gt;(it-&gt;get()))</div><div class="line">      {</div><div class="line">        <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">normal</a> = plane-&gt;plane_normal();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Plane with normal "</span> &lt;&lt; normal</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">        </div><div class="line">        <span class="comment">// Plane shape can also be converted to Kernel::Plane_3</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Kernel::Plane_3: "</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Plane__3.html">Kernel::Plane_3</a><span class="keyword">&gt;</span>(*plane) &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Cylinder* cyl = dynamic_cast&lt;Cylinder*&gt;(it-&gt;get()))</div><div class="line">      {</div><div class="line">        <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Line__3.html">Kernel::Line_3</a> axis = cyl-&gt;axis();</div><div class="line">        FT radius = cyl-&gt;radius();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Cylinder with axis "</span> &lt;&lt; axis</div><div class="line">                  &lt;&lt; <span class="stringliteral">" and radius "</span> &lt;&lt; radius</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="comment">// Prints the parameters of the detected shape.</span></div><div class="line">        <span class="comment">// This function is available for any type of shape.</span></div><div class="line">        std::cout &lt;&lt; (*it)-&gt;info() &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    </div><div class="line">    <span class="comment">// Proceeds with next detected shape.</span></div><div class="line">    it++;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_shape_detection_3Usage_point_access"></a>
Retrieving Points Assigned to Shapes</h2>
<p>This example illustrates how to access the points assigned to each shape and compute the mean error. A timer measures the running performance.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_shape_detection_3_2efficient_RANSAC_point_access_8cpp-example.html">Point_set_shape_detection_3/efficient_RANSAC_point_access.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_xyz_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_with_normal_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/number_utils.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__detection__3_8h.html">CGAL/Shape_detection_3.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                           FT;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="comment">// In Shape_detection_traits the basic types, i.e., Point and Vector types</span></div><div class="line"><span class="comment">// as well as iterator type and property maps, are defined.</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Shape__detection__3_1_1Shape__detection__traits.html">CGAL::Shape_detection_3::Shape_detection_traits</a>&lt;Kernel,</div><div class="line">  Pwn_vector, Point_map, Normal_map&gt;            Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Efficient__RANSAC.html">CGAL::Shape_detection_3::Efficient_RANSAC&lt;Traits&gt;</a>   Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Plane.html">CGAL::Shape_detection_3::Plane&lt;Traits&gt;</a>              Plane;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Points with normals.</span></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Loads point set from a file. </span></div><div class="line">  <span class="comment">// read_xyz_points_and_normals takes an OutputIterator for storing the points</span></div><div class="line">  <span class="comment">// and a property map to store the normal vector with each point.</span></div><div class="line">  std::ifstream stream(<span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!stream ||</div><div class="line">    !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessingIO.html#ga2e8d677def85c5582ba1f01eda030628">CGAL::read_xyz_points</a>(stream,</div><div class="line">      std::back_inserter(points),</div><div class="line">      CGAL::parameters::point_map(Point_map()).</div><div class="line">      normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn"</span> &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Instantiates shape detection engine.</span></div><div class="line">  Efficient_ransac ransac;</div><div class="line"></div><div class="line">  <span class="comment">// Provides the input data.</span></div><div class="line">  ransac.set_input(points);</div><div class="line"></div><div class="line">  <span class="comment">// Registers detection of planes</span></div><div class="line">  ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line"></div><div class="line">  <span class="comment">// Measures time before setting up the shape detection.</span></div><div class="line">  CGAL::Timer time;</div><div class="line">  time.start();</div><div class="line"></div><div class="line">  <span class="comment">// Build internal data structures.</span></div><div class="line">  ransac.preprocess();</div><div class="line"></div><div class="line">  <span class="comment">// Measures time after preprocessing.</span></div><div class="line">  time.stop();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"preprocessing took: "</span> &lt;&lt; time.time() * 1000 &lt;&lt; <span class="stringliteral">"ms"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Perform detection several times and choose result with highest coverage.</span></div><div class="line">  Efficient_ransac::Shape_range shapes = ransac.shapes();</div><div class="line">  FT best_coverage = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0;i&lt;3;i++) {</div><div class="line">    <span class="comment">// Reset timer.</span></div><div class="line">    time.reset();</div><div class="line">    time.start();</div><div class="line"></div><div class="line">    <span class="comment">// Detects shapes.</span></div><div class="line">    ransac.detect();</div><div class="line"></div><div class="line">    <span class="comment">// Measures time after detection.</span></div><div class="line">    time.stop();</div><div class="line"></div><div class="line">    <span class="comment">// Compute coverage, i.e. ratio of the points assigned to a shape.</span></div><div class="line">    FT coverage = FT(points.size() - ransac.number_of_unassigned_points())</div><div class="line">                  / FT(points.size());</div><div class="line"></div><div class="line">    <span class="comment">// Prints number of assigned shapes and unsassigned points.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"time: "</span> &lt;&lt; time.time() * 1000 &lt;&lt; <span class="stringliteral">"ms"</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; ransac.shapes().end() - ransac.shapes().begin() &lt;&lt; <span class="stringliteral">" primitives, "</span></div><div class="line">      &lt;&lt; coverage &lt;&lt; <span class="stringliteral">" coverage"</span> &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    <span class="comment">// Choose result with highest coverage.</span></div><div class="line">    <span class="keywordflow">if</span> (coverage &gt; best_coverage) {</div><div class="line">      best_coverage = coverage;</div><div class="line">      <span class="comment">// Efficient_ransac::shapes() provides</span></div><div class="line">      <span class="comment">// an iterator range to the detected shapes. </span></div><div class="line">      shapes = ransac.shapes();</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  Efficient_ransac::Shape_range::iterator it = shapes.begin();</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> (it != shapes.end()) {</div><div class="line">    boost::shared_ptr&lt;Efficient_ransac::Shape&gt; shape = *it;</div><div class="line">    <span class="comment">// Using Shape_base::info() for printing </span></div><div class="line">    <span class="comment">// the parameters of the detected shape.</span></div><div class="line">    std::cout &lt;&lt; (*it)-&gt;info();</div><div class="line"></div><div class="line">    <span class="comment">// Sums distances of points to detected shapes.</span></div><div class="line">    FT sum_distances = 0;</div><div class="line"></div><div class="line">    <span class="comment">// Iterates through point indices assigned to each detected shape.</span></div><div class="line">    std::vector&lt;std::size_t&gt;::const_iterator</div><div class="line">      index_it = (*it)-&gt;indices_of_assigned_points().begin();</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (index_it != (*it)-&gt;indices_of_assigned_points().end()) {</div><div class="line">      </div><div class="line">      <span class="comment">// Retrieves point</span></div><div class="line">      <span class="keyword">const</span> Point_with_normal &amp;p = *(points.begin() + (*index_it));</div><div class="line"></div><div class="line">      <span class="comment">// Adds Euclidean distance between point and shape.</span></div><div class="line">      sum_distances += CGAL::sqrt((*it)-&gt;squared_distance(p.first));</div><div class="line"></div><div class="line">      <span class="comment">// Proceeds with next point.</span></div><div class="line">      index_it++;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Computes and prints average distance.</span></div><div class="line">    FT average_distance = sum_distances / shape-&gt;indices_of_assigned_points().size();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" average distance: "</span> &lt;&lt; average_distance &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Proceeds with next detected shape.</span></div><div class="line">    it++;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_shape_detection_3Arbitrary_shapes"></a>
Adding More Shapes to RANSAC</h1>
<p>Other types of shapes can be detected by implementing a shape class derived from the class <code>Shape_base</code> and registering it to the shape detection factory of the efficient RANSAC object. This class must provide the following functions: construct a shape from a small set of given points, compute the squared distance from a query point and the shape and compute the normal deviation between a query point with normal and the normal to the shape at the closest point from the query. The used shape parameters are added as members to the derived class.</p>
<p>Note that the RANSAC approach is efficient for shapes that are uniquely defined by a small number of points, denoted by the number of required samples. The algorithm aims at detected the largest shape via many random samples, and the combinatorial complexity of possible samples increases rapidly with the number of required samples.</p>
<p>More specifically, the functions to be implemented are defined in the base class <code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html" title="Base class for shape types defining an interface to construct a shape from a set of points and to com...">Shape_detection_3::Shape_base</a></code>:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html#ae466b029cfe3f4100c9b428ad1002fd4" title="Returns minimal number of sample points required for construction. ">Shape_detection_3::Shape_base::minimum_sample_size()</a></code> const: Returns the minimal number of required samples.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html#ad0e66e63238d4351392cd4e74d994b61" title="Constructs the shape based on a minimal set of samples from the input data. ">Shape_detection_3::Shape_base::create_shape</a>(const std::vector&lt;size_t&gt; &amp;indices)</code>: The randomly generated samples are provided via a vector of indices. <code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html#ac5899089794266f7ffae93b17e1068fe" title="Retrieves the point location from its index. ">Shape_detection_3::Shape_base::point</a></code><code>(size_t i)</code> and <code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html#af9fb14bacb0764bb33666b466b56b739" title="Retrieves the normal vector from its index. ">Shape_detection_3::Shape_base::normal</a></code><code>(size_t i)</code> are used to retrieve the actual points and normals (see example below). The provided number of samples might actually be larger than the set minimal number of required samples, depending on the other types of shape types. If the provided samples are not sufficient to define a unique shape, e.g., in a degenerated case the shape is considered invalid.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html#a948956b8efb69599c6001f27a6a7bb78" title="Computes the squared Euclidean distance from the query point p to the shape. ">Shape_detection_3::Shape_base::squared_distance</a></code><code>(const Point &amp;p)</code> const: This function computes the squared distance from a query point to the shape. It is used for traversing the hierarchical spatial data structure.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html#a948956b8efb69599c6001f27a6a7bb78" title="Computes the squared Euclidean distance from the query point p to the shape. ">Shape_detection_3::Shape_base::squared_distance</a>(std::vector&lt;FT&gt; &amp;dists, const std::vector&lt;size_t&gt; &amp;indices)</code></li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html#a94d7c14a713335f4aa00e0b809570d23" title="Computes the deviation of the point normal from the surface normal at the projected point in form of ...">Shape_detection_3::Shape_base::cos_to_normal</a></code><code>(const std::vector&lt;size_t&gt; &amp;indice, sstd::vector&lt;FT&gt; &amp;angles)</code> const: These functions are used to determine the number of inlier points to the shape. They compute respectively the squared distance from a set of points to the shape, and the dot product between the point's normals and the normals at the shape for the closest points on the shape. The access to the actual point and normal data is carried out via <code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html#ac5899089794266f7ffae93b17e1068fe" title="Retrieves the point location from its index. ">Shape_detection_3::Shape_base::point</a></code><code>(size_t i)</code> and <code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html#af9fb14bacb0764bb33666b466b56b739" title="Retrieves the normal vector from its index. ">Shape_detection_3::Shape_base::normal</a></code><code>(size_t i)</code> (see example below). The resulting squared distance/dot product is stored in the vector provided as the first argument.</li>
</ul>
<p>By default the connected component is detected via the neighbor graph as mentioned above. However, for shapes that admit a faster approach to detect a connected component, the user can provide his/her own implementation to extract the connected component via:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html#afdf3b49e7cfe369543e59c70e931443e" title="Determines the largest cluster of inlier points. ">Shape_detection_3::Shape_base::connected_component</a></code><code>(std::vector&lt;std::size_t&gt;&amp; indices, FT cluster_epsilon)</code>: The indices of all supporting points are stored in the vector <code>indices</code>. All points not belonging to the largest cluster of points are removed from the vector <code>indices</code>.</li>
</ul>
<p>Another optional method can be implemented to provide a helper function providing the shape parameters written to a string:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html#a0fe9112a2d594b1e36ce1116b03b58c1" title="returns a string containing the shape type and the numerical parameters. ">Shape_detection_3::Shape_base::info</a></code><code>()</code>: This function returns a string suitable for printing the shape parameters into a log/console. The default solution provides an empty string.</li>
</ul>
<p>The property maps are used to map the indices to the corresponding points and normals. The following example shows an implementation of a planar shape primitive, which is used by the example <a class="el" href="Point_set_shape_detection_3_2efficient_RANSAC_custom_shape_8cpp-example.html">Point_set_shape_detection_3/efficient_RANSAC_custom_shape.cpp</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_shape_detection_3_2efficient_RANSAC_custom_shape_8h-example.html">Point_set_shape_detection_3/efficient_RANSAC_custom_shape.h</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef MY_PLANE_SHAPE_H</span></div><div class="line"><span class="preprocessor">#define MY_PLANE_SHAPE_H</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__detection__3_8h.html">CGAL/Shape_detection_3.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/number_utils.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">My_Plane derives from Shape_base. The plane is represented by</span></div><div class="line"><span class="comment">its normal vector and distance to the origin.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits&gt;</div><div class="line"><span class="keyword">class </span>My_Plane : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Shape__base.html">CGAL::Shape_detection_3::Shape_base</a>&lt;Traits&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::FT FT;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::Point_3 Point;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::Vector_3 Vector;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  My_Plane()</div><div class="line">    : <a class="code" href="namespaceCGAL.html">CGAL</a>::Shape_detection_3::Shape_base&lt;Traits&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="comment">//  Computes squared Euclidean distance from query point to the shape.</span></div><div class="line">  <span class="keyword">virtual</span> FT <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(<span class="keyword">const</span> Point &amp;p)<span class="keyword"> const </span>{</div><div class="line">    <span class="keyword">const</span> FT sd = (this-&gt;constr_vec(m_point_on_primitive, p)) * m_normal;</div><div class="line">    <span class="keywordflow">return</span> sd * sd;</div><div class="line">  }</div><div class="line"></div><div class="line">  Vector plane_normal()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> m_normal;</div><div class="line">  }</div><div class="line"></div><div class="line">  FT d()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> m_d;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Returns a string with shape parameters.</span></div><div class="line">  <span class="keyword">virtual</span> std::string info()<span class="keyword"> const </span>{</div><div class="line">    std::stringstream sstr;</div><div class="line">    sstr &lt;&lt; <span class="stringliteral">"Type: plane ("</span> &lt;&lt; this-&gt;get_x(m_normal) &lt;&lt; <span class="stringliteral">", "</span> </div><div class="line">      &lt;&lt; this-&gt;get_y(m_normal) &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; this-&gt;get_z(m_normal) &lt;&lt; <span class="stringliteral">")x - "</span> &lt;&lt;</div><div class="line">      m_d &lt;&lt; <span class="stringliteral">" = 0"</span> &lt;&lt; <span class="stringliteral">" #Pts: "</span> &lt;&lt; this-&gt;m_indices.size();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> sstr.str();</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="comment">// Constructs shape based on minimal set of samples from the input data.    </span></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> create_shape(<span class="keyword">const</span> std::vector&lt;std::size_t&gt; &amp;indices) {</div><div class="line">    <span class="keyword">const</span> Point p1 = this-&gt;point(indices[0]);</div><div class="line">    <span class="keyword">const</span> Point p2 = this-&gt;point(indices[1]);</div><div class="line">    <span class="keyword">const</span> Point p3 = this-&gt;point(indices[2]);</div><div class="line"></div><div class="line">    m_normal = this-&gt;cross_pdct(p1 - p2, p1 - p3);</div><div class="line"></div><div class="line">    m_normal = m_normal * (1.0 / sqrt(this-&gt;sqlen(m_normal)));</div><div class="line">    m_d = -(p1[0] * m_normal[0] + p1[1] * m_normal[1] + p1[2] * m_normal[2]);</div><div class="line"></div><div class="line">    m_point_on_primitive = p1;</div><div class="line"></div><div class="line">    this-&gt;m_is_valid = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Computes squared Euclidean distance from a set of points.</span></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(<span class="keyword">const</span> std::vector&lt;std::size_t&gt; &amp;indices,</div><div class="line">                                std::vector&lt;FT&gt; &amp;dists)<span class="keyword"> const </span>{</div><div class="line">      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; indices.size(); i++) {</div><div class="line">        <span class="keyword">const</span> FT sd = (this-&gt;point(indices[i])</div><div class="line">          - m_point_on_primitive) * m_normal;</div><div class="line">        dists[i] = sd * sd;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">  Computes the normal deviation between shape and</span></div><div class="line"><span class="comment">  a set of points with normals.</span></div><div class="line"><span class="comment">  */</span></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> cos_to_normal(<span class="keyword">const</span> std::vector&lt;std::size_t&gt; &amp;indices,</div><div class="line">                             std::vector&lt;FT&gt; &amp;angles)<span class="keyword"> const </span>{</div><div class="line">      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; indices.size(); i++)</div><div class="line">        angles[i] = CGAL::abs(this-&gt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">normal</a>(indices[i]) * m_normal);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Returns the number of required samples for construction.</span></div><div class="line">  <span class="keyword">virtual</span> std::size_t minimum_sample_size()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> 3;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Point m_point_on_primitive;</div><div class="line">  Vector m_normal;</div><div class="line">  FT m_d;</div><div class="line">};</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_shape_detection_3Plane_regularization"></a>
Plane Regularization</h1>
<p>Shape detection applies to man-made scenes or objects such as urban scenes or scans of mechanical parts. Such scenes often contain a wide range of geometric regularities such as parallelism, orthogonality, or symmetry. This package offers a function to reinforce four types of regularities for planar shapes: <code><a class="el" href="group__PkgPointSetShapeDetection3.html#ga57cdb2c265967f4a6a04b5db3e0828d2" title="Given a set of detected planes with their respective inlier sets, this function enables to regularize...">CGAL::regularize_planes()</a></code>:</p>
<ul>
<li>Planes that are near <b>parallel</b> are made parallel: normal vectors of planes that form angles smaller than a user-defined threshold are made equal.</li>
<li>Parallel planes that are near <b>coplanar</b> are made coplanar.</li>
<li>Planes that are near <b>orthogonal</b> are made exactly orthogonal.</li>
<li>Planes that are near <b>symmetrical</b> with respect to a user-defined axis are made symmetrical.</li>
</ul>
<p>The user can choose to only regularize one or several of these 4 properties (see <a class="el" href="group__PkgPointSetShapeDetection3.html#ga57cdb2c265967f4a6a04b5db3e0828d2">reference manual</a>)). The process is greedy and based on a hierarchical decomposition (coplanar clusters are subgroups of parallel clusters which are subgroups of axis-symmetric and orthogonal clusters) as described by Verdie et al. <a class="el" href="citelist.html#CITEREF_cgal:vla-lod-15">[3]</a></p>
<p><br />
<b>File</b> <a class="el" href="Point_set_shape_detection_3_2plane_regularization_8cpp-example.html">Point_set_shape_detection_3/plane_regularization.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_xyz_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_with_normal_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__detection__3_8h.html">CGAL/Shape_detection_3.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__planes_8h.html">CGAL/regularize_planes.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Shape__detection__3_1_1Shape__detection__traits.html">CGAL::Shape_detection_3::Shape_detection_traits</a></div><div class="line">  &lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;                Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Region__growing.html">CGAL::Shape_detection_3::Region_growing&lt;Traits&gt;</a>      Region_growing;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Plane.html">CGAL::Shape_detection_3::Plane&lt;Traits&gt;</a>               Plane;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) </div><div class="line">{</div><div class="line">  Pwn_vector points;</div><div class="line">  std::ifstream stream(argc &gt; 1 ? argv[1] : <span class="stringliteral">"data/cube.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!stream || </div><div class="line">    !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessingIO.html#ga2e8d677def85c5582ba1f01eda030628">CGAL::read_xyz_points</a>(stream,</div><div class="line">      std::back_inserter(points),</div><div class="line">      CGAL::parameters::point_map(Point_map()).</div><div class="line">      normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn"</span> &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Call RANSAC shape detection with planes</span></div><div class="line">  Region_growing region_growing;</div><div class="line">  region_growing.set_input(points);</div><div class="line">  region_growing.add_shape_factory&lt;Plane&gt;();</div><div class="line">  region_growing.detect();</div><div class="line"></div><div class="line">  Region_growing::Plane_range planes = region_growing.planes();</div><div class="line">  <span class="comment">// Regularize detected planes</span></div><div class="line">  <a class="code" href="group__PkgPointSetShapeDetection3.html#ga57cdb2c265967f4a6a04b5db3e0828d2">CGAL::regularize_planes</a> (points,</div><div class="line">                           Point_map(),</div><div class="line">                           planes,</div><div class="line">                           <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Plane__map.html">CGAL::Shape_detection_3::Plane_map&lt;Traits&gt;</a>(),</div><div class="line">                           <a class="code" href="classCGAL_1_1Shape__detection__3_1_1Point__to__shape__index__map.html">CGAL::Shape_detection_3::Point_to_shape_index_map&lt;Traits&gt;</a>(points, planes),</div><div class="line">                           <span class="keyword">true</span>, <span class="comment">// Regularize parallelism</span></div><div class="line">                           <span class="keyword">true</span>, <span class="comment">// Regularize orthogonality</span></div><div class="line">                           <span class="keyword">false</span>, <span class="comment">// Do not regularize coplanarity</span></div><div class="line">                           <span class="keyword">true</span>, <span class="comment">// Regularize Z-symmetry (default)</span></div><div class="line">                           10); <span class="comment">// 10 degrees of tolerance for parallelism/orthogonality</span></div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_shape_detection_3Performance"></a>
Performances</h1>
<h2><a class="anchor" id="Point_set_shape_detection_3PerformanceRANSAC"></a>
Efficient RANSAC</h2>
<p>The running time and detection performance of the efficient RANSAC depend on the chosen parameters. A selective error tolerance parameter leads to higher running times and smaller shapes, as many shape candidates are generated to find the largest shape. We plot the detection performance against the epsilon error tolerance parameter for detecting planes in a complex scene with 5M points, see <a class="el" href="index.html#fig__Point_set_shape_detection_3_performace_epsilon">Figure 73.5</a>. The probability parameter controls the endurance when searching for the largest candidate at each iteration. It barely impacts the number of detected shapes, has a moderate impact on the size of the detected shapes and increases the running times. We plot the performance against the probability parameter, see <a class="el" href="index.html#fig__Point_set_shape_detection_3_performace_probability">Figure 73.6</a>.</p>
<p><a class="anchor" id="fig__Point_set_shape_detection_3_performace_epsilon"></a></p><div class="image">
<img src="epsilon_graph.png" alt="epsilon_graph.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_shape_detection_3_performace_epsilon">Figure 73.5</a> The graph depicts the number of detected shapes (purple) and the coverage (green), i.e., the ratio assignedPoints / totalPoints, against the epsilon tolerance parameter. A higher value for epsilon, i.e., a more tolerant error, leads to fewer but larger shapes and shorter running times.  </div>  <br />

<p><a class="anchor" id="fig__Point_set_shape_detection_3_performace_probability"></a></p><div class="image">
<img src="prob_graph.png" alt="prob_graph.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_shape_detection_3_performace_probability">Figure 73.6</a> The graph depicts the time, coverage and number of detected primitives against the search endurance parameter, i.e., the probability to miss the largest shape at each iteration. The number of shapes is stable and the coverage increases when the probability is lowered. The running times increase significantly as many more candidates are generated during each iteration of the algorithm.  </div>  <br />

<h2><a class="anchor" id="Point_set_shape_detection_3PerformanceRegionGrowing"></a>
Region Growing</h2>
<p>Region growing iterates through every single point in the input, which makes it usually slower (although more robust). The main parameter that has an effect on running times is the epsilon used for clustering: internally, range queries are perform using spheres with radius cluster_epsilon. Using larger values means using larger spheres which are more computationally demanding.</p>
<p>We plot again the detection performance against the epsilon parameter for detecting planes, this time in a scene of 500k points, see figure <a class="el" href="index.html#fig__Point_set_shape_detection_3_performace_epsilon_rg">Figure 73.7</a>.</p>
<p><a class="anchor" id="fig__Point_set_shape_detection_3_performace_epsilon_rg"></a></p><div class="image">
<img src="epsilon_graph_2.png" alt="epsilon_graph_2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_shape_detection_3_performace_epsilon_rg">Figure 73.7</a> The graph depicts the number of detected shapes (purple) and the coverage (green), i.e., the ratio assignedPoints / totalPoints, against the epsilon parameter (for simplicity, we use the same value for epsilon and cluster_epsilon). A higher value for cluster_epsilon, i.e., larger neighborhood spheres, leads to longer computation and to larger shapes.  </div>  <br />

<h1><a class="anchor" id="Point_set_shape_detection_3History"></a>
History</h1>
<p>The efficient RANSAC implementation was developed by Sven Oesau based on a prototype version by Yannick Verdie, with the help of Cl√©ment Jamin and under the supervision of Pierre Alliez. Plane regularization and region growing were added by Simon Giraudot based on prototype versions developed by Florent Lafarge. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:56 for CGAL 4.13 - Point Set Shape Detection by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
