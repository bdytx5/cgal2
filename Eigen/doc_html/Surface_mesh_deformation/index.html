<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Surface_mesh_deformation/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Triangulated Surface Mesh Deformation: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Triangulated Surface Mesh Deformation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_SurfaceMeshDeformation"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>SÃ©bastien Loriot, Olga Sorkine-Hornung, Yin Xu and Ilker O. Yaz</dd></dl>
 <div class="image">
<img src="main_image_suggestion_4_resized.png" alt="main_image_suggestion_4_resized.png" />
</div>
<h1><a class="anchor" id="SMD_Intro"></a>
Introduction</h1>
<p>This package offers surface mesh deformation algorithms which compute new vertex positions of a surface mesh under positional constraints of some of its vertices, without requiring any additional structure other than the surface mesh itself</p>
<p>This package implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Sorkine2007AsRigidAs">[6]</a> together with an alternative energy function <a class="el" href="citelist.html#CITEREF_Chao2010SimpleGeomModel">[3]</a>. The algorithm minimizes a nonlinear deformation energy under positional constraints to preserve rigidity as much as possible. The minimization of the energy relies on solving sparse linear systems and finding closest rotation matrices.</p>
<h1><a class="anchor" id="SMD_Def"></a>
Definitions</h1>
<p>A <em>surface mesh deformation system</em> consists of:</p><ul>
<li>a triangulated surface mesh (<em>surface mesh</em> in the following),</li>
<li>a set of vertices defining the region to deform (referred to as the <em>region-of-interest</em> and abbreviated <em>ROI</em>),</li>
<li>a subset of vertices from the ROI that the user wants to move (referred to as the <em>control vertices</em>),</li>
<li>a target position for each control vertex (defining the <em>deformation constraints</em>).</li>
</ul>
<p>A vertex from the ROI that is not a control vertex is called an <em>unconstrained vertex</em>. These definitions are depicted in <a class="el" href="index.html#fig__Simple_roi">Figure 65.1</a>.</p>
<p><a class="anchor" id="fig__Simple_roi"></a></p><div class="image">
<img src="roi_example.png" alt="roi_example.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Simple_roi">Figure 65.1</a> The ROI features the green vertices (the unconstrained vertices) and the red vertices (the control vertices). (Left) The initial surface mesh; (Right) A target position is defined for each control vertex, the coordinates of the unconstrained vertices being updated by the deformation algorithm.  </div>  <br />

<p>In this package, three algorithms are implemented:</p><ul>
<li>The <em>As-Rigid-As-Possible</em> (<em>ARAP</em>) method <a class="el" href="citelist.html#CITEREF_Sorkine2007AsRigidAs">[6]</a>;</li>
<li>The <em>Spokes and Rims</em> method <a class="el" href="citelist.html#CITEREF_Chao2010SimpleGeomModel">[3]</a>;</li>
<li>The <em>Smoothed Rotation Enhanced As-Rigid-As-Possible</em> method <a class="el" href="citelist.html#CITEREF_levismooth">[4]</a></li>
</ul>
<p>Given an edge weighting scheme, both methods iteratively minimize an energy function and produce a different surface mesh at each step until convergence is reached.</p>
<p><em>Spokes and Rims</em> is the default method proposed by the package. It provides an unconditional convergence while the <em>ARAP</em> method requires the edge weights to be positive. However, the results obtained using the <em>Spokes and Rims</em> method are more dependent on the discretization of the deformed surface (See <a class="el" href="index.html#fig__Arap_spokes_comparison">Figure 65.2</a>).</p>
<p>The <em>Smoothed Rotation Enhanced As-Rigid-As-Possible</em> method adds a bending term to the ARAP energy that penalizes rotation difference between neighboring elements. In the current implementation a 1-ring type element is used while in general it is possible to use a triangle type element.</p>
<p>More details on these algorithms are provided in section <a class="el" href="index.html#SMD_Overview">Deformation Techniques, Energies and Weighting Schemes</a>.</p>
<p><a class="anchor" id="fig__Arap_spokes_comparison"></a></p><div class="image">
<img src="arap_spokes_comparison.png" alt="arap_spokes_comparison.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Arap_spokes_comparison">Figure 65.2</a> A comparison between the As-Rigid-As-Possible and the Spokes and Rims deformation methods. On the surface mesh of a square with spikes depicted on the left, the ROI consists of the green vertices. The control vertices are the red ones. We translate the control vertices along the normal to the plane and observe the result produced by the As-Rigid-As-Possible (center) and the Spokes and Rims (right) methods from the same view point. The latter method provides unconditional convergence does not produce a symmetric result.  </div>  <br />

<p><a class="anchor" id="fig__sr_arap_comparison"></a></p><div class="image">
<img src="sr_arap_comparison.png" alt="sr_arap_comparison.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__sr_arap_comparison">Figure 65.3</a> A comparison on a 5261 vertices cactus model (left) between the As-Rigid-As-Possible (middle) and the Smoothed Rotation Enhanced As-Rigid-As-Possible (right).  </div>  <br />

<h1><a class="anchor" id="SMD_API"></a>
User Interface Description</h1>
<p>The deformation methods implemented rely on solving a sparse linear system. The sparse matrix definition depends on the weighting scheme and on the unconstrained and control vertices. The right term depends only on the target positions of the control vertices.</p>
<p>The deformation process is handled by the class <code><a class="el" href="classCGAL_1_1Surface__mesh__deformation.html" title="Class providing the functionalities for deforming a triangulated surface mesh. ">Surface_mesh_deformation</a></code> and the surface mesh is represented as a halfedge data structure that must be a model of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classHalfedgeGraph.html">HalfedgeGraph</a></code> concept.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Surface__mesh__deformation.html" title="Class providing the functionalities for deforming a triangulated surface mesh. ">Surface_mesh_deformation</a></code> provides two groups of functions for the preprocessing (sparse matrix definition) and the deformation (right hand term definition).</p>
<h2><a class="anchor" id="Preprocess_section"></a>
Preprocessing</h2>
<p>The preprocessing consists in computing a factorization of the aforementioned sparse matrix to speed up the linear system resolution. It requires the ROI to be defined. The following conventions are used for the definition of the ROI:</p><ul>
<li>A vertex inserted in the set of control vertices is inserted in the ROI;</li>
<li>A control vertex erased from the ROI is no longer considered as a control vertex;</li>
<li>A control vertex that is erased is not erased from the ROI.</li>
</ul>
<p>Each time the ROI is modified, the preprocessing function <code>preprocess()</code> must be called. Note that if it is not done, the first deformation step calls this function automatically and has a longer runtime compared to subsequent deformation steps.</p>
<p>The function <code><a class="el" href="classCGAL_1_1Surface__mesh__deformation.html#a2a5d0a54eaa217bc5bb19d96c30abb30" title="Preprocessing function that need to be called each time the region-of-interest or the set of control ...">Surface_mesh_deformation::preprocess()</a></code> returns <code>true</code> if the factorization is successful, and <code>false</code> otherwise.</p>
<p>Rank deficiency is the main reason for failure. Typical failure cases are:</p><ul>
<li>All the vertices are in the ROI and no control vertices are set</li>
<li>The weighting scheme used to fill the sparse matrix (model of <code><a class="el" href="classSurfaceMeshDeformationWeights.html" title="Concept describing the set of requirements for calculating weights for halfedges. ...">SurfaceMeshDeformationWeights</a></code>) features too many zeros and breaks the connectivity information</li>
</ul>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>The choice of the weighting scheme provides a mean to adjust the way the control vertices influences the unconstrained vertices. The defaults provides satisfactory results in general but other weighting schemes may be selected or designed to experiment or improve the results in specific cases.  </p></div> 
<dl class="section note"><dt>Note</dt><dd>The ROI does not have to be a connected component of the graph of the surface mesh. However, for better performances it is better to use an individual instance of the deformation object for each connected component.</dd></dl>
<h2><a class="anchor" id="Deform_section"></a>
Deformation</h2>
<p>The deformation of the surface mesh is triggered by the displacement of the control vertices. This is achieved through setting the target positions of the control vertices (directly or by using an affine transformation to be applied to a control vertex or a range of control vertices).</p>
<p>Note that a rotation or a translation of a control vertex is always applied on its last target position set: they are cumulative.</p>
<p>The deformation of the surface mesh happens when calling the function <code><a class="el" href="classCGAL_1_1Surface__mesh__deformation.html#a07d253510d806605b15740c7d7844bea" title="Deforms the region-of-interest according to the deformation algorithm, using the target positions of ...">Surface_mesh_deformation::deform()</a></code>. The number of optimization iterations varies depending on whether the user chooses a fixed number of iterations or a stopping criterion based on the energy variation.</p>
<p>After the call to the deformation function, the input surface mesh is updated and the control vertices are at their target positions and the unconstrained vertices are moved accordingly. The function <code><a class="el" href="classCGAL_1_1Surface__mesh__deformation.html#a07d253510d806605b15740c7d7844bea" title="Deforms the region-of-interest according to the deformation algorithm, using the target positions of ...">Surface_mesh_deformation::deform()</a></code> can be called several times consecutively, in particular if the convergence has not been reached yet (otherwise it has no effect).</p>
<dl class="section warning"><dt>Warning</dt><dd>Vertices can be inserted into or erased from the ROI and the set of control vertices at any time. In particular, any vertex that is no longer inside the ROI will be assigned to its original position when <code><a class="el" href="classCGAL_1_1Surface__mesh__deformation.html#a2a5d0a54eaa217bc5bb19d96c30abb30" title="Preprocessing function that need to be called each time the region-of-interest or the set of control ...">Surface_mesh_deformation::preprocess()</a></code> is first called. The original positions can be updated by calling <code><a class="el" href="classCGAL_1_1Surface__mesh__deformation.html#a3c16fed59b7cf7c65acd4eaa371046f6" title="Sets the initial positions of the vertices from the region-of-interest to the current positions...">Surface_mesh_deformation::overwrite_initial_geometry()</a></code> ( which will also require a new preprocessing step). This behavior is illustrated in <a class="el" href="index.html#SModelingVideo_1">Video 1</a>.</dd></dl>
<h2><a class="anchor" id="Surface_mesh_deformation_arap_or_spokes_and_rims"></a>
As-Rigid-As-Possible and Spokes-and-Rims Deformation Techniques</h2>
<p>Three deformation techniques are provided by this package. This section summarizes from the user point of view what is explained in details in the section <a class="el" href="index.html#SMD_Overview">Deformation Techniques, Energies and Weighting Schemes</a>.</p>
<p>The As-Rigid-As-Possible deformation techniques require the use of a positive weighting scheme to guarantee the correct minimization of the energy. When using the default cotangent weighting scheme, this means that the input surface mesh must be <em>clean</em>. That is, that for all edges in the surface mesh the sum of the angles opposite to the edge in the incident triangles is less that \( \pi \). If this is not the case and the targeted application allows the modification of the surface mesh connectivity, a solution (amongst other) is to bissect (possibly recursively) the problematic edges. See <a class="el" href="index.html#fig__Cotangent_bisect_fig">Figure 65.4</a>.</p>
<p><a class="anchor" id="fig__Cotangent_bisect_fig"></a></p><div class="image">
<img src="cotangent_bisect.png" alt="cotangent_bisect.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Cotangent_bisect_fig">Figure 65.4</a> Cotangent weight of edges. (Left) The sum of the opposite angles to the edge \( e \), \( \alpha + \beta \) is greater than \( \pi \). The cotangent weight of \( e \) is negative. (Right) The edge \( e \) was split so that the sum of the angles opposite to each sub-edge \( e_1 \) and \( e_2 \) is less than \( \pi \). The corresponding cotangent weights are positive.  </div>  <br />

<p>If the mesh connectivity must be preserved, the Spokes and Rims deformation technique is guaranteed to always correctly minimize the energy even if the weights are negative. However, this technique is more dependent on the discretization of the deformed surface (See <a class="el" href="index.html#fig__Arap_spokes_comparison">Figure 65.2</a>).</p>
<h2><a class="anchor" id="Surface_mesh_deformation_examples"></a>
Examples</h2>
<h3><a class="anchor" id="SModelingExample_1"></a>
Using the Whole Surface Mesh as Region-of-Interest</h3>
<p>In this example, the whole surface mesh is used as ROI and a few vertices are added as control vertices. <code><a class="el" href="classCGAL_1_1Surface__mesh__deformation.html#a609eb0e351b2c2d971df1875d7bc67ae" title="Sets the target position of a control vertex. ">Surface_mesh_deformation::set_target_position()</a></code> is used for setting the target positions of the control vertices.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_deformation_2all_roi_assign_example_8cpp-example.html">Surface_mesh_deformation/all_roi_assign_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_deformation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                                   <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel, CGAL::Polyhedron_items_with_id_3&gt;</a> Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor    vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator        vertex_iterator;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh__deformation.html">CGAL::Surface_mesh_deformation&lt;Polyhedron&gt;</a> Surface_mesh_deformation;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Polyhedron mesh;</div><div class="line">  std::ifstream input(<span class="stringliteral">"data/plane.off"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; mesh) || mesh.empty() ) {</div><div class="line">    std::cerr&lt;&lt; <span class="stringliteral">"Cannot open  data/plane.off"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Init the indices of the halfedges and the vertices.</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelper.html#ga0660924a1aa87e8be5cccbc261e931c7">set_halfedgeds_items_id</a>(mesh);</div><div class="line"></div><div class="line">  <span class="comment">// Create a deformation object</span></div><div class="line">  Surface_mesh_deformation deform_mesh(mesh);</div><div class="line"></div><div class="line">  <span class="comment">// Definition of the region of interest (use the whole mesh)</span></div><div class="line">  vertex_iterator vb,ve;</div><div class="line">  boost::tie(vb, ve) = vertices(mesh);</div><div class="line">  deform_mesh.insert_roi_vertices(vb, ve);</div><div class="line"></div><div class="line">  <span class="comment">// Select two control vertices ...</span></div><div class="line">  vertex_descriptor control_1 = *<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">CGAL::cpp11::next</a>(vb, 213);</div><div class="line">  vertex_descriptor control_2 = *<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">CGAL::cpp11::next</a>(vb, 157);</div><div class="line"></div><div class="line">  <span class="comment">// ... and insert them</span></div><div class="line">  deform_mesh.insert_control_vertex(control_1);</div><div class="line">  deform_mesh.insert_control_vertex(control_2);</div><div class="line"></div><div class="line">  <span class="comment">// The definition of the ROI and the control vertices is done, call preprocess</span></div><div class="line">  <span class="keywordtype">bool</span> is_matrix_factorization_OK = deform_mesh.preprocess();</div><div class="line">  <span class="keywordflow">if</span>(!is_matrix_factorization_OK){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error in preprocessing, check documentation of preprocess()"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Use set_target_position() to set the constained position</span></div><div class="line">  <span class="comment">// of control_1. control_2 remains at the last assigned positions</span></div><div class="line">  <a class="code" href="classCGAL_1_1Surface__mesh__deformation.html#ae675335193892552fa7924289bd1496f">Surface_mesh_deformation::Point</a> constrained_pos_1(-0.35, 0.40, 0.60);</div><div class="line">  deform_mesh.set_target_position(control_1, constrained_pos_1);</div><div class="line"></div><div class="line">  <span class="comment">// Deform the mesh, the positions of vertices of 'mesh' are updated</span></div><div class="line">  deform_mesh.deform();</div><div class="line">  <span class="comment">// The function deform() can be called several times if the convergence has not been reached yet</span></div><div class="line">  deform_mesh.deform();</div><div class="line"></div><div class="line">  <span class="comment">// Set the constained position of control_2</span></div><div class="line">  <a class="code" href="classCGAL_1_1Surface__mesh__deformation.html#ae675335193892552fa7924289bd1496f">Surface_mesh_deformation::Point</a> constrained_pos_2(0.55, -0.30, 0.70);</div><div class="line">  deform_mesh.set_target_position(control_2, constrained_pos_2);</div><div class="line"></div><div class="line">  <span class="comment">// Call the function deform() with one-time parameters:</span></div><div class="line">  <span class="comment">// iterate 10 times and do not use energy based termination criterion</span></div><div class="line">  deform_mesh.deform(10, 0.0);</div><div class="line"></div><div class="line">  <span class="comment">// Save the deformed mesh into a file</span></div><div class="line">  std::ofstream output(<span class="stringliteral">"deform_1.off"</span>);</div><div class="line">  output &lt;&lt; mesh;</div><div class="line">  output.close();</div><div class="line"></div><div class="line">  <span class="comment">// Add another control vertex which requires another call to preprocess</span></div><div class="line">  vertex_descriptor control_3 = *<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">CGAL::cpp11::next</a>(vb, 92);</div><div class="line">  deform_mesh.insert_control_vertex(control_3);</div><div class="line"></div><div class="line">  <span class="comment">// The prepocessing step is again needed</span></div><div class="line">  <span class="keywordflow">if</span>(!deform_mesh.preprocess()){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error in preprocessing, check documentation of preprocess()"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Deform the mesh</span></div><div class="line">  <a class="code" href="classCGAL_1_1Surface__mesh__deformation.html#ae675335193892552fa7924289bd1496f">Surface_mesh_deformation::Point</a> constrained_pos_3(0.55, 0.30, -0.70);</div><div class="line">  deform_mesh.set_target_position(control_3, constrained_pos_3);</div><div class="line"></div><div class="line">  deform_mesh.deform(15, 0.0);</div><div class="line"></div><div class="line">  output.open(<span class="stringliteral">"deform_2.off"</span>);</div><div class="line">  output &lt;&lt; mesh;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__SModelingExample_1_results"></a></p><div class="image">
<img src="example_1_results.png" alt="example_1_results.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__SModelingExample_1_results">Figure 65.5</a> Deformation results when running example <a class="el" href="index.html#SModelingExample_1">Using the Whole Surface Mesh as Region-of-Interest</a> : <code>deform_1.off</code> and <code>deform_2.off</code>.  </div>  <br />

<h3><a class="anchor" id="SModelingExample_2"></a>
Using an Affine Transformation on a Range of Vertices</h3>
<p>In this example, we use the functions <code>translate()</code> and <code>rotate()</code> on a range of control vertices. Note that the translations and the rotations are defined using a 3D vector type and a quaternion type from the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/installation.html#thirdpartyEigen">Eigen library</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_deformation_2k_ring_roi_translate_rotate_example_8cpp-example.html">Surface_mesh_deformation/k_ring_roi_translate_rotate_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_deformation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                                   <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel,CGAL::Polyhedron_items_with_id_3&gt;</a>  Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor    vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator        vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::halfedge_descriptor halfedge_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::out_edge_iterator    out_edge_iterator;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Eigen::Vector3d                                                Vector3d;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh__deformation.html">CGAL::Surface_mesh_deformation&lt;Polyhedron&gt;</a>     Surface_mesh_deformation;</div><div class="line"></div><div class="line"><span class="comment">// Collect the vertices which are at distance less or equal to k</span></div><div class="line"><span class="comment">// from the vertex v in the graph of vertices connected by the edges of P</span></div><div class="line">std::vector&lt;vertex_descriptor&gt; extract_k_ring(<span class="keyword">const</span> Polyhedron &amp;P, vertex_descriptor v, <span class="keywordtype">int</span> k)</div><div class="line">{</div><div class="line">  std::map&lt;vertex_descriptor, int&gt;  D;</div><div class="line">  std::vector&lt;vertex_descriptor&gt;    Q;</div><div class="line">  Q.push_back(v); D[v] = 0;</div><div class="line">  std::size_t current_index = 0;</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> dist_v;</div><div class="line">  <span class="keywordflow">while</span>( current_index &lt; Q.size() &amp;&amp; (dist_v = D[ Q[current_index] ]) &lt; k ) {</div><div class="line">    v = Q[current_index++];</div><div class="line"></div><div class="line">    out_edge_iterator e, e_end;</div><div class="line">    <span class="keywordflow">for</span>(boost::tie(e, e_end) = out_edges(v, P); e != e_end; e++)</div><div class="line">    {</div><div class="line">      halfedge_descriptor he = halfedge(*e, P);</div><div class="line">      vertex_descriptor new_v = target(he, P);</div><div class="line">      <span class="keywordflow">if</span>(D.insert(std::make_pair(new_v, dist_v + 1)).second) {</div><div class="line">        Q.push_back(new_v);</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> Q;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Polyhedron mesh;</div><div class="line">  std::ifstream input(<span class="stringliteral">"data/plane.off"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; mesh) || mesh.empty() ) {</div><div class="line">    std::cerr&lt;&lt; <span class="stringliteral">"Cannot open data/plane.off"</span>;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Init the indices of the halfedges and the vertices.</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelper.html#ga0660924a1aa87e8be5cccbc261e931c7">set_halfedgeds_items_id</a>(mesh);</div><div class="line"></div><div class="line">  <span class="comment">// Create the deformation object</span></div><div class="line">  Surface_mesh_deformation deform_mesh(mesh);</div><div class="line"></div><div class="line">  <span class="comment">// Select and insert the vertices of the region of interest</span></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  boost::tie(vb,ve) = vertices(mesh);</div><div class="line">  std::vector&lt;vertex_descriptor&gt; roi = extract_k_ring(mesh, *<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">CGAL::cpp11::next</a>(vb, 47), 9);</div><div class="line">  deform_mesh.insert_roi_vertices(roi.begin(), roi.end());</div><div class="line"></div><div class="line">  <span class="comment">// Select and insert the control vertices</span></div><div class="line">  std::vector&lt;vertex_descriptor&gt; cvertices_1 = extract_k_ring(mesh, *<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">CGAL::cpp11::next</a>(vb, 39), 1);</div><div class="line">  std::vector&lt;vertex_descriptor&gt; cvertices_2 = extract_k_ring(mesh, *<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">CGAL::cpp11::next</a>(vb, 97), 1);</div><div class="line">  deform_mesh.insert_control_vertices(cvertices_1.begin(), cvertices_1.end());</div><div class="line">  deform_mesh.insert_control_vertices(cvertices_2.begin(), cvertices_2.end());</div><div class="line"></div><div class="line">  <span class="comment">// Apply a rotation to the control vertices</span></div><div class="line">  Eigen::Quaternion&lt;double&gt; quad(0.92, 0, 0, -0.38);</div><div class="line">  deform_mesh.rotate(cvertices_1.begin(), cvertices_1.end(), Vector3d(0,0,0), quad);</div><div class="line">  deform_mesh.rotate(cvertices_2.begin(), cvertices_2.end(), Vector3d(0,0,0), quad);</div><div class="line"></div><div class="line">  deform_mesh.deform();</div><div class="line"></div><div class="line">  <span class="comment">// Save the deformed mesh</span></div><div class="line">  std::ofstream output(<span class="stringliteral">"deform_1.off"</span>);</div><div class="line">  output &lt;&lt; mesh;</div><div class="line">  output.close();</div><div class="line"></div><div class="line">  <span class="comment">// Restore the positions of the vertices</span></div><div class="line">  deform_mesh.reset();</div><div class="line"></div><div class="line">  <span class="comment">// Apply a translation on the original positions of the vertices (reset() was called before)</span></div><div class="line">  deform_mesh.translate(cvertices_1.begin(), cvertices_1.end(), Vector3d(0,0.3,0));</div><div class="line">  deform_mesh.translate(cvertices_2.begin(), cvertices_2.end(), Vector3d(0,0.3,0));</div><div class="line"></div><div class="line">  <span class="comment">// Call the function deform() with one-time parameters:</span></div><div class="line">  <span class="comment">// iterate 10 times and do not use energy based termination criterion</span></div><div class="line">  deform_mesh.set_iterations(10);</div><div class="line">  deform_mesh.set_tolerance(0.0);</div><div class="line">  deform_mesh.deform();</div><div class="line"></div><div class="line">  <span class="comment">// Save the deformed mesh</span></div><div class="line">  output.open(<span class="stringliteral">"deform_2.off"</span>);</div><div class="line">  output &lt;&lt; mesh;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p><a class="anchor" id="fig__SModelingExample_2_results"></a></p><div class="image">
<img src="example_2_results.png" alt="example_2_results.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__SModelingExample_2_results">Figure 65.6</a> Deformation results when running example <a class="el" href="index.html#SModelingExample_2">Using an Affine Transformation on a Range of Vertices</a> : <code>deform_1.off</code> and <code>deform_2.off</code>.  </div>  <br />

<h3><a class="anchor" id="SModelingExample_3"></a>
Using Polyhedron without Ids</h3>
<p>In the previous examples, we used an <em>enriched</em> polyhedron storing an ID in its halfedges and vertices together with the default property maps in the deformation object to access them. In the following example, we show how we can use alternative property maps.</p>
<p>For practical performance however we recommend relying upon the former examples instead, as using a <code>std::map</code> to access indices increases the complexity from constant to logarithmic. <br />
<b>File</b> <a class="el" href="Surface_mesh_deformation_2deform_polyhedron_with_custom_pmap_example_8cpp-example.html">Surface_mesh_deformation/deform_polyhedron_with_custom_pmap_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_deformation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                                   Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>                                   Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor    vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator        vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::halfedge_descriptor halfedge_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::halfedge_iterator    halfedge_iterator;</div><div class="line"></div><div class="line"><span class="comment">// Define the maps</span></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor, std::size_t&gt;                  Vertex_id_map;</div><div class="line"><span class="keyword">typedef</span> std::map&lt;halfedge_descriptor, std::size_t&gt;                 Hedge_id_map;</div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Vertex_id_map&gt;           Vertex_id_pmap;</div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Hedge_id_map&gt;             Hedge_id_pmap;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh__deformation.html">CGAL::Surface_mesh_deformation&lt;Polyhedron, Vertex_id_pmap, Hedge_id_pmap&gt;</a> Surface_mesh_deformation;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Polyhedron mesh;</div><div class="line">  std::ifstream input(<span class="stringliteral">"data/plane.off"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; mesh) || mesh.empty() ) {</div><div class="line">    std::cerr&lt;&lt; <span class="stringliteral">"Cannot open  data/plane.off"</span>;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Init the indices of the vertices from 0 to num_vertices(mesh)-1</span></div><div class="line">  Vertex_id_map vertex_index_map;</div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  std::size_t counter = 0;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb, ve) = vertices(mesh); vb != ve; ++vb, ++counter)</div><div class="line">    vertex_index_map[*vb]=counter;</div><div class="line"></div><div class="line">  <span class="comment">// Init the indices of the halfedges from 0 to 2*num_edges(mesh)-1</span></div><div class="line">  Hedge_id_map hedge_index_map;</div><div class="line">  counter = 0;</div><div class="line">  halfedge_iterator eb, ee;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(eb, ee) = halfedges(mesh); eb != ee; ++eb, ++counter)</div><div class="line">    hedge_index_map[*eb]=counter;</div><div class="line"></div><div class="line">  Surface_mesh_deformation deform_mesh( mesh,</div><div class="line">                                        Vertex_id_pmap(vertex_index_map),</div><div class="line">                                        Hedge_id_pmap(hedge_index_map) );</div><div class="line"></div><div class="line">  <span class="comment">// Now deform mesh as desired</span></div><div class="line">  <span class="comment">// .....</span></div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="SModelingExample_4"></a>
Using a Custom Edge Weighting Scheme</h3>
<p>Using a custom weighting scheme for edges is also possible if one provides a model of <code><a class="el" href="classSurfaceMeshDeformationWeights.html" title="Concept describing the set of requirements for calculating weights for halfedges. ...">SurfaceMeshDeformationWeights</a></code>. In this example, the weight of each edge is pre-computed and an internal map is used for storing and accessing them.</p>
<p>Another example is given in the manual page of the concept <code><a class="el" href="classSurfaceMeshDeformationWeights.html" title="Concept describing the set of requirements for calculating weights for halfedges. ...">SurfaceMeshDeformationWeights</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_deformation_2custom_weight_for_edges_example_8cpp-example.html">Surface_mesh_deformation/custom_weight_for_edges_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_deformation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>   Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>       Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor    vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator      vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::halfedge_descriptor halfedge_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::halfedge_iterator    halfedge_iterator;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor, std::size_t&gt;   Internal_vertex_map;</div><div class="line"><span class="keyword">typedef</span> std::map&lt;halfedge_descriptor, std::size_t&gt;     Internal_hedge_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Internal_vertex_map&gt;   Vertex_index_map;</div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Internal_hedge_map&gt;     Hedge_index_map;</div><div class="line"></div><div class="line"><span class="comment">// A model of SurfaceMeshDeformationWeights using a map of pre-computed weights</span></div><div class="line"><span class="keyword">struct </span>Weights_from_map</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Polyhedron Halfedge_graph;</div><div class="line">  Weights_from_map(std::map&lt;halfedge_descriptor, double&gt;* weight_map) : weight_map(weight_map)</div><div class="line">  { }</div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> VertexPo<span class="keywordtype">int</span>Map&gt;</div><div class="line">  <span class="keywordtype">double</span> operator()(halfedge_descriptor e, Polyhedron&amp; <span class="comment">/*P*/</span>, VertexPointMap <span class="comment">/*vpm*/</span>) {</div><div class="line">    <span class="keywordflow">return</span> (*weight_map)[e];</div><div class="line">  }</div><div class="line">  std::map&lt;halfedge_descriptor, double&gt;* weight_map;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh__deformation.html">CGAL::Surface_mesh_deformation&lt;Polyhedron, Vertex_index_map, Hedge_index_map, CGAL::ORIGINAL_ARAP, Weights_from_map&gt;</a> Surface_mesh_deformation;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Polyhedron mesh;</div><div class="line">  std::ifstream input(<span class="stringliteral">"data/plane.off"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; mesh) || mesh.empty() ) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Cannot open  data/plane.off"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::map&lt;halfedge_descriptor, double&gt; weight_map;</div><div class="line">  <span class="comment">// Store all the weights</span></div><div class="line">  halfedge_iterator eb, ee;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(eb, ee) = halfedges(mesh); eb != ee; ++eb)</div><div class="line">  {</div><div class="line">    weight_map[*eb] = 1.0; <span class="comment">// store some precomputed weights</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Create and initialize the vertex index map</span></div><div class="line">  Internal_vertex_map internal_vertex_index_map;</div><div class="line">  Vertex_index_map vertex_index_map(internal_vertex_index_map);</div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  std::size_t counter = 0;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb, ve) = vertices(mesh); vb != ve; ++vb, ++counter) {</div><div class="line">    put(vertex_index_map, *vb, counter);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Create and initialize the halfedge index map</span></div><div class="line">  Internal_hedge_map internal_hedge_index_map;</div><div class="line">  Hedge_index_map hedge_index_map(internal_hedge_index_map);</div><div class="line">  counter = 0;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(eb, ee) = halfedges(mesh); eb != ee; ++eb, ++counter) {</div><div class="line">    put(hedge_index_map, *eb, counter);</div><div class="line">  }</div><div class="line">  Surface_mesh_deformation deform_mesh(mesh,</div><div class="line">                                       vertex_index_map,</div><div class="line">                                       hedge_index_map,</div><div class="line">                                       <span class="keyword">get</span>(CGAL::vertex_point, mesh),</div><div class="line">                                       Weights_from_map(&amp;weight_map));</div><div class="line"></div><div class="line">  <span class="comment">// Deform mesh as desired</span></div><div class="line">  <span class="comment">// .....</span></div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="SModelingExample_5"></a>
Using the Smoothed Rotation Enhanced As-Rigid-As-Possible</h3>
<p>In this example, a survey <a class="el" href="citelist.html#CITEREF_Botsch2008OnLinearVariational">[1]</a> model is loaded, alpha that determines the influence of the bending term is set, and the deformation method is set to <code>SRE_ARAP</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_deformation_2deform_mesh_for_botsch08_format_sre_arap_8cpp-example.html">Surface_mesh_deformation/deform_mesh_for_botsch08_format_sre_arap.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_deformation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                                   Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel, CGAL::Polyhedron_items_with_id_3&gt;</a> Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor    vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator        vertex_iterator;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh__deformation.html">CGAL::Surface_mesh_deformation&lt;Polyhedron,CGAL::Default, CGAL::Default, CGAL::SRE_ARAP&gt;</a> Surface_mesh_deformation;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span>  ( argc!=4){</div><div class="line">    std::cerr &lt;&lt;<span class="stringliteral">"Usage "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" input.off input.sel input.def\n"</span>;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  Polyhedron mesh;</div><div class="line">  std::ifstream input(argv[1]);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; mesh) || mesh.empty() ) {</div><div class="line">    std::cerr&lt;&lt; argv[1] &lt;&lt; <span class="stringliteral">" is not a valid off file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  input.close();</div><div class="line"></div><div class="line">  <span class="comment">// Init the indices of the halfedges and the vertices.</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelper.html#ga0660924a1aa87e8be5cccbc261e931c7">set_halfedgeds_items_id</a>(mesh);</div><div class="line"></div><div class="line">  <span class="comment">// Create a deformation object</span></div><div class="line">  Surface_mesh_deformation deform_mesh(mesh);</div><div class="line"></div><div class="line">  <span class="comment">// Changing alpha value</span></div><div class="line">  deform_mesh.set_sre_arap_alpha(0.02);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Definition of the region of interest (use the whole mesh)</span></div><div class="line">  vertex_iterator vb,ve;</div><div class="line">  boost::tie(vb, ve) = vertices(mesh);</div><div class="line"></div><div class="line">  <span class="comment">//the selection is set by a file</span></div><div class="line">  input.open(argv[2]);</div><div class="line">  std::string line;</div><div class="line">  std::vector&lt;vertex_descriptor&gt; control_vertices;</div><div class="line">  <span class="keywordflow">while</span>(getline(input, line))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (line[0]==<span class="charliteral">'#'</span>) <span class="keywordflow">continue</span>;</div><div class="line">    <span class="keywordflow">if</span> (line[0]==<span class="charliteral">'1'</span>) deform_mesh.insert_roi_vertex(*vb);</div><div class="line">    <span class="keywordflow">if</span> (line[0]==<span class="charliteral">'2'</span>) {</div><div class="line">      deform_mesh.insert_control_vertex(*vb);</div><div class="line">      control_vertices.push_back(*vb);</div><div class="line">    }</div><div class="line">    ++vb;</div><div class="line">    <span class="keywordflow">if</span> (vb==ve) <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">  input.close();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Using "</span> &lt;&lt; control_vertices.size() &lt;&lt; <span class="stringliteral">" control vertices\n"</span>;</div><div class="line">  <span class="comment">// The definition of the ROI and the control vertices is done, call preprocess</span></div><div class="line">  <span class="keywordtype">bool</span> is_matrix_factorization_OK = deform_mesh.preprocess();</div><div class="line">  <span class="keywordflow">if</span>(!is_matrix_factorization_OK){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error in preprocessing, check documentation of preprocess()"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//define the transformation</span></div><div class="line">  input.open(argv[3]);</div><div class="line">  <span class="keywordtype">double</span> m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, hw, sink;</div><div class="line">  getline(input, line); <span class="comment">// skip first comment line</span></div><div class="line">  input &gt;&gt; m00 &gt;&gt; m01 &gt;&gt; m02 &gt;&gt; m03;</div><div class="line">  input &gt;&gt; m10 &gt;&gt; m11 &gt;&gt; m12 &gt;&gt; m13;</div><div class="line">  input &gt;&gt; m20 &gt;&gt; m21 &gt;&gt; m22 &gt;&gt; m23;</div><div class="line">  input &gt;&gt; sink &gt;&gt; sink &gt;&gt; sink &gt;&gt; hw;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Setting target positions\n"</span>;</div><div class="line">  Kernel::Aff_transformation_3 aff(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23);</div><div class="line">  BOOST_FOREACH(vertex_descriptor vd, control_vertices)</div><div class="line">  {</div><div class="line">    <a class="code" href="classCGAL_1_1Surface__mesh__deformation.html#ae675335193892552fa7924289bd1496f">Surface_mesh_deformation::Point</a> pos = vd-&gt;point().transform(aff);</div><div class="line">    deform_mesh.set_target_position(vd, pos);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Call the function deform() with one-time parameters:</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Deforming the mesh\n"</span>;</div><div class="line">  deform_mesh.deform(1000, 1e-4);</div><div class="line"></div><div class="line">  <span class="comment">// Save the deformed mesh into a file</span></div><div class="line">  std::ofstream output(<span class="stringliteral">"deform_res.off"</span>);</div><div class="line">  output &lt;&lt; mesh;</div><div class="line">  output.close();</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="SMD_Demo"></a>
How to Use the Demo</h1>
<p>A plugin for the polyhedron demo is available to test the algorithm. The following video tutorials explain how to use it. When the deformation dock window is open, the picking of control vertices and of the ROI is done by pressing <em>Shift</em> and clicking with the left button of the mouse. The displacement of the vertices is triggered when the <em>Ctrl</em> button is pressed.</p>
<p><a class="anchor" id="SModelingVideo_1"></a> 
</p><center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/akpYaDLuaUI?rel=0" frameborder="0" allowfullscreen=""></iframe>
</center>
<div class="cgal_video_caption"> <a class="el" href="index.html#SModelingVideo_1">Video 1</a> Grouping of control vertices.</div>

<p><a class="anchor" id="SModelingVideo_2"></a> 
</p><center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/1cpnkx_YG5E?rel=0" frameborder="0" allowfullscreen=""></iframe>
</center>
<div class="cgal_video_caption"> <a class="el" href="index.html#SModelingVideo_2">Video 2</a>
Convergence: this video shows that upon fast changes of the positions of the control vertices,
more iteration steps are needed to reach the convergence.</div>

<p><a class="anchor" id="SModelingVideo_3"></a> 
</p><center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/-1rO-RdbudM?rel=0" frameborder="0" allowfullscreen=""></iframe>
</center>
<div class="cgal_video_caption"> <a class="el" href="index.html#SModelingVideo_3">Video 3</a> A complete example: changing the pose of a dinausor.</div>

<h1><a class="anchor" id="SMD_Overview"></a>
Deformation Techniques, Energies and Weighting Schemes</h1>
<p>This section gives the theoretical background to make the user manual self-contained and at the same time explains where the weights comes in. This allows advanced users of this package to tune the weighting scheme by developing a model of the concept <code><a class="el" href="classSurfaceMeshDeformationWeights.html" title="Concept describing the set of requirements for calculating weights for halfedges. ...">SurfaceMeshDeformationWeights</a></code> used in the class <code><a class="el" href="classCGAL_1_1Surface__mesh__deformation.html" title="Class providing the functionalities for deforming a triangulated surface mesh. ">Surface_mesh_deformation</a></code>.</p>
<h2><a class="anchor" id="SMD_Overview_Preliminaries"></a>
Preliminaries</h2>
<h3><a class="anchor" id="SMD_Overview_Laplacian"></a>
Laplacian Representation</h3>
<p>The <em>Laplacian representation</em> (referred to as <em>Laplace coordinates</em> in <a class="el" href="citelist.html#CITEREF_botsch2010polygon">[2]</a>) of a vertex in a surface mesh is one way to <em>encode</em> the local neighborhood of a vertex in the surface mesh. In this representation, a vertex \( \mathbf{v}_i \) is associated a 3D vector defined as:</p>
<p class="formulaDsp">
\[ \begin{equation} L(\mathbf{v}_i) = \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij}(\mathbf{v}_i - \mathbf{v}_j), \label{eq:lap_open} \end{equation} \]
</p>
<p>where:</p><ul>
<li>\(N(\mathbf{v}_i)\) denotes the set of vertices adjacent to \(\mathbf{v}_i\);</li>
<li>\(w_{ij}\) denotes a weight for the directed edge \(\mathbf{v}_i\ \mathbf{v}_j\).</li>
</ul>
<p>The simplest choice for the weights is the uniform scheme where \( w_{ij}=1/|N(\mathbf{v}_i)| \) for each adjacent vertex \(\mathbf{v}_j\). In this case, the Laplacian representation of a vertex is the vector between this vertex and the centroid of its adjacent vertices (<a class="el" href="index.html#fig__Simple_laplacian">Figure 65.7</a>).</p>
<p>In the surface mesh deformation context, a popular choice is the cotangent weight scheme that derives from the discretization of the Laplace operator <a class="el" href="citelist.html#CITEREF_Pinkall1993Cotangent">[5]</a> : Given an edge of the surface mesh, its corresponding cotangent weight is the mean of the cotangents of the angles opposite to the edge. It was shown to produce results that are not biased by the surface mesh of the approximated surface <a class="el" href="citelist.html#CITEREF_Sorkine2007AsRigidAs">[6]</a>.</p>
<p><a class="anchor" id="fig__Simple_laplacian"></a></p><div class="image">
<img src="simple_mesh_with_laplacian.png" alt="simple_mesh_with_laplacian.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Simple_laplacian">Figure 65.7</a> Laplacian representation of \( v_i \) with uniform weights: the red square vertex is the centroid of the vertices adjacent to \( v_i \). The Laplacian representation \( L(v_i) \) is represented as a blue vector.  </div>  <br />

<p>Considering a surface mesh with \(n\) vertices, it is possible to define its <em>Laplacian representation</em> \(\Delta\) as a \(n \times 3\) matrix:</p>
<p class="formulaDsp">
\[ \begin{equation} \mathbf{L}\mathbf{V} = \Delta, \label{eq:lap_system} \end{equation} \]
</p>
<p>where:</p><ul>
<li>\(\mathbf{L}\) is a \(n \times n\) sparse matrix, referred to as the <em>Laplacian matrix</em>. Its elements \( m_{ij} \), \(i,j \in \{1 \dots n\} \) are defined as follows:<ul>
<li>\( m_{ii} \) = \( \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)}w_{ij} \),</li>
<li>\( m_{ij} = -w_{ij} \) if \( \mathbf{v}_j \in N(\mathbf{v_i}) \),</li>
<li>\( 0 \) otherwise.</li>
</ul>
</li>
<li>\(\mathbf{V}\) is a \(n \times 3\) matrix made of the Cartesian coordinates of the vertices.</li>
</ul>
<h3><a class="anchor" id="SMD_Overview_Laplacian_Deformation"></a>
Laplacian Deformation</h3>
<p>This section is an introduction to provide the background for the next two sub-sections describing the algorithms implemented in this package. A system relying only on the approach described below results in non-smooth transitions in the neighborhood of the control vertices. For a survey on different Laplacian-based editing techniques we refer to <a class="el" href="citelist.html#CITEREF_Botsch2008OnLinearVariational">[1]</a>.</p>
<p>The main idea behind Laplacian-based deformation techniques is to preserve the Laplacian representation under deformation constraints. The Laplacian representation of a surface mesh is treated as a representative form of the discretized surface, and the deformation process must follow the deformation constraints while preserving the Laplacian representation as much as possible.</p>
<p>There are different ways to incorporate deformation constraints into the deformation system <a class="el" href="citelist.html#CITEREF_Botsch2008OnLinearVariational">[1]</a>. This package supports hard constraints, that is, target positions of control vertices are preserved after the deformation.</p>
<p>Given a surface mesh deformation system with a ROI made of \( n \) vertices and \( k \) control vertices, we consider the following linear system:</p>
<p class="formulaDsp">
\[ \begin{equation} \left[ \begin{array}{ccc} \mathbf{L}_f\\ 0 \; \mathbf{I}_c \end{array} \right] \mathbf{V} = \left[ \begin{array}{ccc} {\Delta}_f \\ \mathbf{V}_c \end{array} \right], \label{eq:lap_energy_system} \end{equation} \]
</p>
<p>where:</p><ul>
<li>\(\mathbf{V}\) is a \(n \times 3\) matrix denoting the unknowns of the system that represent the vertex coordinates after deformation. The system is built so that the \( k \) last rows correspond to the control vertices.</li>
<li>\(\mathbf{L}_f\) denotes the Laplacian matrix of the unconstrained vertices. It is a \( (n-k) \times n \) matrix as defined in Eq. \(\eqref{eq:lap_system}\) but removing the rows corresponding to the control vertices.</li>
<li>\(\mathbf{I}_c\) is the \(k \times k\) identity matrix.</li>
<li>\({\Delta}_f\) denotes the Laplacian representation of the unconstrained vertices as defined in Eq. \(\eqref{eq:lap_system}\) but removing the rows corresponding to the control vertices.</li>
<li>\(\mathbf{V}_c\) is a \(k \times 3\) matrix containing the Cartesian coordinates of the target positions of the control vertices.</li>
</ul>
<p>The left-hand side matrix of the system of Eq. \(\eqref{eq:lap_energy_system}\) is a square non-symmetric sparse matrix. To solve the aforementioned system, an appropriate solver (e.g. LU solver) needs to be used. Note that solving this system preserves the Laplacian representation of the surface mesh restricted to the unconstrained vertices while satisfying the deformation constraints.</p>
<h2><a class="anchor" id="SMD_Overview_ARAP"></a>
As-Rigid-As Possible Deformation</h2>
<p>Given a surface mesh \(M\) with \( n \) vertices \( \{\mathbf{v}_i\} i \in \{1 \dots n \} \) and some deformation constraints, we consider the following energy function:</p>
<p class="formulaDsp">
\[ \begin{equation} \sum_{\mathbf{v}_i \in M} \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij} \left\| (\mathbf{v}'_i - \mathbf{v}'_j) - \mathbf{R}_i(\mathbf{v}_i - \mathbf{v}_j) \right\|^2, \label{eq:arap_energy} \end{equation} \]
</p>
<p>where:</p><ul>
<li>\(\mathbf{R}_i\) is a \( 3 \times 3 \) rotation matrix</li>
<li>\(w_{ij}\) denotes a weight</li>
<li>\(N(\mathbf{v}_i)\) denotes the set of vertices adjacent to \(\mathbf{v}_i\) in \(M\)</li>
<li>\(N(\mathbf{v}'_i)\) denotes a new position of the vertex \(N(\mathbf{v}_i)\) after a given deformation</li>
</ul>
<p>An as-rigid-as possible surface mesh deformation <a class="el" href="citelist.html#CITEREF_Sorkine2007AsRigidAs">[6]</a> is defined by minimizing this energy function under the deformation constraints, i.e. the assigned position \( {v}'_i\) for each vertex \( \mathbf{v}_i\) in the set of control vertices. Defining the <em>one-ring neighborhood</em> of a vertex as its set of adjacent vertices, the intuitive idea behind this energy function is to allow each one-ring neighborhood of vertices to have an individual rotation, and at the same time to prevent shearing by taking advantage of the overlapping of one-ring neighborhoods of adjacent vertices (see <a class="el" href="index.html#fig__Overlapping_cells">Figure 65.8</a>).</p>
<p><a class="anchor" id="fig__Overlapping_cells"></a></p><div class="image">
<img src="overlapping_cells.png" alt="overlapping_cells.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Overlapping_cells">Figure 65.8</a> Overlaps of one-ring neighborhoods of vertices. The one-ring neighborhoods of four vertices are drawn with different colors, the corresponding vertex is colored accordingly.  </div>  <br />

<p>There are two unknowns per vertex in Eq. \(\eqref{eq:arap_energy}\): the new positions ( \(\mathbf{v}'_k\)) of the unconstrained vertices and the rotation matrices ( \(\mathbf{R}_i\)). If the energy contribution of each vertex is positive, this boils down to minimizing the energy contribution of each vertex \(\mathbf{v}_i\).</p>
<p>Each such term of the energy is minimized by using a two-step optimization approach (also called local-global approach).</p>
<p>In the first step, the positions of the vertices are considered as fixed so that the rotation matrices are the only unknowns.</p>
<p>For the vertex \(\mathbf{v}_i\), we consider the covariance matrix \(\mathbf{S}_i\): </p><p class="formulaDsp">
\[ \begin{equation} \mathbf{S}_i = \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij} (\mathbf{v}_i - \mathbf{v}_j)(\mathbf{v}'_i - \mathbf{v}'_j)^T, \label{eq:cov_matrix} \end{equation} \]
</p>
<p>It was shown <a class="el" href="citelist.html#CITEREF_Sorkine2009LeastSquaresRigid">[7]</a> that minimizing the energy contribution of \(\mathbf{v}_i\) in Eq. \(\eqref{eq:arap_energy}\) is equivalent to maximizing the trace of the matrix \(\mathbf{R}_i \mathbf{S}_i\). \(\mathbf{R}_i \) is the transpose of the unitary matrix in the polar decomposition of \(\mathbf{S}_i\).</p>
<p>In the second step, the rotation matrices are substituted into the partial derivative of Eq. \(\eqref{eq:arap_energy}\) with respect to \(\mathbf{v}'_i\). Assuming the weights are symmetric, setting the derivative to zero results in the following equation:</p>
<p class="formulaDsp">
\[ \begin{equation} \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij}(\mathbf{v}'_i - \mathbf{v}'_j) = \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij} \frac{(\mathbf{R}_i + \mathbf{R}_j)}{2} (\mathbf{v}_i - \mathbf{v}_j). \label{eq:lap_ber} \end{equation} \]
</p>
<p>The left-hand side of this equation corresponds to the one of Eq. \(\eqref{eq:lap_open}\), and we can set \(\Delta\) to be the right-hand side. Solving the linear system in Eq. \(\eqref{eq:lap_energy_system}\) gives the new positions of the unconstrained vertices.</p>
<p>This two-step optimization can be applied several times iteratively to obtain a better result.</p>
<dl class="section note"><dt>Note</dt><dd>The matrix built with the Laplacian matrix of the unconstrained vertices in the left-hand side of Eq. \(\eqref{eq:lap_energy_system}\) depends only on the initial surface mesh structure and on which vertices are control vertices. Once the control vertices are set, we can use a direct solver to factorize the sparse matrix in Eq. \(\eqref{eq:lap_energy_system}\), and reuse this factorization during each iteration of the optimization procedure.</dd></dl>
<p>The original algorithm <a class="el" href="citelist.html#CITEREF_Sorkine2007AsRigidAs">[6]</a> we described assumes that:</p>
<ul>
<li>the weight between two vertices is symmetric. In order to support asymmetric weights in our implementation, we slightly change Eq. \(\eqref{eq:lap_ber}\) to: <p class="formulaDsp">
\[ \begin{equation} \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} (w_{ij} + w_{ji})(\mathbf{v}'_i - \mathbf{v}'_j) = \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} (w_{ij}\mathbf{R}_i + w_{ji}\mathbf{R}_j)(\mathbf{v}_i - \mathbf{v}_j). \label{eq:lap_ber_asym} \end{equation} \]
</p>
</li>
<li>The energy contribution of each vertex is positive. If the weight between two vertices is always positive, this is always the case. However, when using the cotangent weighting scheme (the default in our implementation), if the sum of the angles opposite to an edge is greater than \( \pi \), its cotangent weight is negative. As a workaround for bad quality meshes, we eliminate those negative weights by setting them to zero.</li>
</ul>
<p>A method minimizing another energy function is described next to avoid the latter issue.</p>
<h2><a class="anchor" id="SMD_Overview_ARAP_Rims"></a>
Spokes and Rims Version</h2>
<p>The elastic energy function proposed by <a class="el" href="citelist.html#CITEREF_Chao2010SimpleGeomModel">[3]</a> additionally takes into account all the opposite edges in the facets incident to a vertex. The energy function to minimize becomes:</p>
<p class="formulaDsp">
\[ \begin{equation} \sum_{\mathbf{v}_i \in M} \sum_{(\mathbf{v}_j, \mathbf{v}_k) \in E(\mathbf{v}_i)} w_{jk} \left\| (\mathbf{v}'_j - \mathbf{v}'_k) - \mathbf{R}_i(\mathbf{v}_j - \mathbf{v}_k) \right\|^2, \label{eq:arap_energy_rims} \end{equation} \]
</p>
<p>where \(E(\mathbf{v}_i)\) consists of the set of edges incident to \(\mathbf{v}_i\) (the <em>spokes</em>) and the set of edges in the link (the <em>rims</em>) of \(\mathbf{v}_i\) in the surface mesh \(M\) (see <a class="el" href="index.html#fig__Spoke_and_rim_edges">Figure 65.9</a>).</p>
<p><a class="anchor" id="fig__Spoke_and_rim_edges"></a></p><div class="image">
<img src="spoke_and_rim_edges_2.png" alt="spoke_and_rim_edges_2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Spoke_and_rim_edges">Figure 65.9</a> The vertices \( \mathbf{v}_n\) and \( \mathbf{v}_m\) are the opposite vertices to the edge \( \mathbf{v}_i \mathbf{v}_j\).  </div>  <br />

<p>The method to get the new positions of the unconstrained vertices is similar to the two-step optimization method explained in <a class="el" href="index.html#SMD_Overview_ARAP">As-Rigid-As Possible Deformation</a>. For the first step, the Eq. \(\eqref{eq:cov_matrix}\) is modified to take into account the edges in \(E(\mathbf{v}_i)\):</p>
<p class="formulaDsp">
\[ \begin{equation} \mathbf{S}_i = \sum_{(\mathbf{v}_j, \mathbf{v}_k) \in E(\mathbf{v}_i)} w_{jk} (\mathbf{v}_j - \mathbf{v}_k)(\mathbf{v}'_j - \mathbf{v}'_k)^T, \label{eq:cov_matrix_sr} \end{equation} \]
</p>
<p>For the second step, setting partial derivative of Eq. \(\eqref{eq:arap_energy_rims}\) to zero with respect to \(\mathbf{v}_i\) gives the following equation:</p>
<p class="formulaDsp">
\[ \begin{equation} \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} (w_{ij} + w_{ji})(\mathbf{v}'_i - \mathbf{v}'_j) = \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} \frac{w_{ij}(\mathbf{R}_i + \mathbf{R}_j + \mathbf{R}_m) + w_{ji}(\mathbf{R}_i + \mathbf{R}_j + \mathbf{R}_n)}{3} (\mathbf{v}_i - \mathbf{v}_j). \label{eq:lap_ber_rims} \end{equation} \]
</p>
<p>where \(\mathbf{R}_m\) and \(\mathbf{R}_n\) are the rotation matrices of the vertices \(\mathbf{v}_m\), \(\mathbf{v}_n\) which are the opposite vertices of the edge \(\mathbf{v}_i \mathbf{v}_j\) (see <a class="el" href="index.html#fig__Spoke_and_rim_edges">Figure 65.9</a>). Note that if the edge \( \mathbf{v}_i \mathbf{v}_j \) is on the boundary of the surface mesh, then \( w_{ij} \) must be 0 and \( \mathbf{v}_m \) does not exist.</p>
<p>An important property of this approach compared to <a class="el" href="index.html#SMD_Overview_ARAP">As-Rigid-As Possible Deformation</a> is that the contribution to the global energy of each vertex is guaranteed to be non-negative when using the cotangent weights <a class="el" href="citelist.html#CITEREF_Chao2010SimpleGeomModel">[3]</a>. Thus even with negative weights, the minimization of the energy with the iterative method presented is always guaranteed. However, this method is more dependent on the discretization of the deformed surface (See <a class="el" href="index.html#fig__Arap_spokes_comparison">Figure 65.2</a>).</p>
<p>The implementation in this package uses the cotangent weights by default (negative values included) as proposed in <a class="el" href="citelist.html#CITEREF_Chao2010SimpleGeomModel">[3]</a>.</p>
<h2><a class="anchor" id="SMD_Overview_SRE_ARAP"></a>
Smoothed Rotation Enhanced As-Rigid-As Possible (SR_ARAP) Deformation</h2>
<p>Using 1-ring elements, SR-ARAP adds a bending element to Eq. \(\eqref{eq:arap_energy}\):</p>
<p class="formulaDsp">
\[ \begin{equation} \sum_{\mathbf{v}_i \in M} \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij} \left\| (\mathbf{v}'_i - \mathbf{v}'_j) - \mathbf{R}_i(\mathbf{v}_i - \mathbf{v}_j) \right\|^2 + \alpha A \left\| \mathbf{R}_i - \mathbf{R}_j \right\|^2_F \label{eq:sre_arap_energy} \end{equation} \]
</p>
<p>where</p><ul>
<li>\(\alpha=0.02\) is a weighting coefficient.</li>
<li>\(A\) is the surface area for scaling invariance.</li>
</ul>
<p>Only the local step is influenced by the added term, and the optimal rotation now takes into account the rotation of neighbors.</p>
<h1><a class="anchor" id="SMD_History"></a>
Design and Implementation History</h1>
<p>An initial version of this package has been implemented during the 2011 Google Summer of Code by Yin Xu under the guidance of Olga Sorkine and Andreas Fabri. Ilker O. Yaz took over the finalization of the package with the help of SÃ©bastien Loriot for the documentation and the API. In 2016, Zohar Levi and SÃ©bastien Loriot extended the package to support Smoothed <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Rotation.html">Rotation</a> Enhanced ARAP. The authors are grateful to GaÃ«l Guennebaud for his great help on using the Eigen library and for providing the code to compute the closest rotation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:52 for CGAL 4.13 - Triangulated Surface Mesh Deformation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
