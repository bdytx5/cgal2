<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classCGAL_1_1Quadratic__program__solution" kind="class" language="C++" prot="public">
    <compoundname>CGAL::Quadratic_program_solution</compoundname>
    <includes local="no">CGAL/QP_solution.h</includes>
    <templateparamlist>
      <param>
        <type>typename</type>
        <declname>ET</declname>
        <defname>ET</defname>
      </param>
    </templateparamlist>
      <sectiondef kind="user-defined">
      <header>Types</header>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::ET</definition>
        <argsstring></argsstring>
        <name>ET</name>
        <briefdescription>
<para>The exact number type that was used to solve the program. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="90" column="1" bodyfile="CGAL/QP_solution.h" bodystart="90" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ac068efd477e3899cc81f7b465b4cd6f4" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Variable_value_iterator</definition>
        <argsstring></argsstring>
        <name>Variable_value_iterator</name>
        <briefdescription>
<para>An iterator type with value type <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;ET&gt;</computeroutput> to go over the values of the variables in the solution. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="96" column="1" bodyfile="CGAL/QP_solution.h" bodystart="96" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ac2731f1622211a110847f7537788478e" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Variable_numerator_iterator</definition>
        <argsstring></argsstring>
        <name>Variable_numerator_iterator</name>
        <briefdescription>
<para>An iterator type with value type <computeroutput>ET</computeroutput> to go over the numerators of the variable values with respect to a common denominator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="103" column="1" bodyfile="CGAL/QP_solution.h" bodystart="103" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Index_iterator</definition>
        <argsstring></argsstring>
        <name>Index_iterator</name>
        <briefdescription>
<para>An iterator type with value type <computeroutput>int</computeroutput> to go over the indices of the basic variables and the basic constraints. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="109" column="1" bodyfile="CGAL/QP_solution.h" bodystart="109" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ace8c70b2cc7dc3457aed8cb72e2ba8b8" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Optimality_certificate_iterator</definition>
        <argsstring></argsstring>
        <name>Optimality_certificate_iterator</name>
        <briefdescription>
<para>An iterator type with value type <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;ET&gt;</computeroutput> to go over an <formula id="9">$ m$</formula>-vector <formula id="47">$ \qplambda$</formula> that proves optimality of the solution. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="116" column="1" bodyfile="CGAL/QP_solution.h" bodystart="116" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1acb96b76c78f9db3cd75d4a209723592b" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Optimality_certificate_numerator_iterator</definition>
        <argsstring></argsstring>
        <name>Optimality_certificate_numerator_iterator</name>
        <briefdescription>
<para>An iterator type with value type <computeroutput>ET</computeroutput> to go over the numerators of the vector <formula id="47">$ \qplambda$</formula> with respect to a common denominator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="123" column="1" bodyfile="CGAL/QP_solution.h" bodystart="123" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ab68ab70cab7cc778611f144d8127028e" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Infeasibility_certificate_iterator</definition>
        <argsstring></argsstring>
        <name>Infeasibility_certificate_iterator</name>
        <briefdescription>
<para>An iterator type with value type <computeroutput>ET</computeroutput> to go over an <formula id="9">$ m$</formula>-vector <formula id="47">$ \qplambda$</formula> that proves infeasibility of the solution. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="130" column="1" bodyfile="CGAL/QP_solution.h" bodystart="130" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ae853fea0d020ada3e7bd4ee51f671f89" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Unboundedness_certificate_iterator</definition>
        <argsstring></argsstring>
        <name>Unboundedness_certificate_iterator</name>
        <briefdescription>
<para>An iterator type with value type <computeroutput>ET</computeroutput> to go over an <formula id="4">$ n$</formula>-vector <formula id="48">$ \qpw$</formula> that proves unboundedness of the solution. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="137" column="1" bodyfile="CGAL/QP_solution.h" bodystart="137" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Creation</header>
      <description><para>Objects of type <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> can be copied and assigned.</para><para>Objects of type <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> that are associated to an actual program are returned by any of the four functions <computeroutput>solve_quadratic_program</computeroutput>, <computeroutput>solve_linear_program</computeroutput>, <computeroutput>solve_nonnegative_quadratic_program</computeroutput>, and <computeroutput>solve_nonnegative_linear_program</computeroutput>. <bold>Example:</bold> <ref refid="QP_solver_2first_qp_8cpp-example" kindref="compound">QP_solver/first_qp.cpp</ref> </para></description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a49488f93f767d506f98975b85ace7b75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Quadratic_program_solution&lt; ET &gt;::Quadratic_program_solution</definition>
        <argsstring>()</argsstring>
        <name>Quadratic_program_solution</name>
        <briefdescription>
<para>constructs a void instance of <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> that is associated to no program. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="155" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Operations</header>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1adc7dd0ec763d1231621d69863fd2cacd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::is_void</definition>
        <argsstring>() const</argsstring>
        <name>is_void</name>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> is not associated to a program. </para>        </briefdescription>
        <detaileddescription>
<para>The condition !<computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1adc7dd0ec763d1231621d69863fd2cacd" kindref="member">is_void()</ref></computeroutput> is a precondition for all access methods below. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="167" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Solution status</header>
      <description><para>Here are the access methods for the status of the solution. </para></description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a46e9204eb8ad6bcc917733ac46affd86" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::is_optimal</definition>
        <argsstring>() const</argsstring>
        <name>is_optimal</name>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> is an optimal solution of the associated program. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="178" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ad0c8cf7f23b0b8b934f38c38f9e51f64" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::is_infeasible</definition>
        <argsstring>() const</argsstring>
        <name>is_infeasible</name>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff the associated program is infeasible. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="184" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a9910d81e17dc950f289d168f1b5f7b2f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::is_unbounded</definition>
        <argsstring>() const</argsstring>
        <name>is_unbounded</name>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff the associated program is unbounded. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="190" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a70e43bc256ef17d80fae117005dd6d15" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PkgQPSolverClasses_1gad1152456fa1f4b03083fea7a83772d63" kindref="member">Quadratic_program_status</ref></type>
        <definition>Quadratic_program_status CGAL::Quadratic_program_solution&lt; ET &gt;::status</definition>
        <argsstring>() const</argsstring>
        <name>status</name>
        <briefdescription>
<para>returns the status of the solution; this is one of the values <computeroutput>QP_OPTIMAL</computeroutput>, <computeroutput>QP_INFEASIBLE</computeroutput>, and <computeroutput>QP_UNBOUNDED</computeroutput>, depending on whether the program asociated to <computeroutput>sol</computeroutput> has an optimal solution, is infeasible, or is unbounded. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="198" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ac75add50cfbfd9e7ec466c67691ad5c4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int CGAL::Quadratic_program_solution&lt; ET &gt;::number_of_iterations</definition>
        <argsstring>() const</argsstring>
        <name>number_of_iterations</name>
        <briefdescription>
<para>returns the number of iterations that it took to solve the program asociated to <computeroutput>sol</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="204" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Solution values</header>
      <description><para>The actual solution (variable and objective function values) can be accessed as follows. </para></description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a096eed419289ff127c4ae5c8c01d5a3a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt; <ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref> &gt;</type>
        <definition>Quotient&lt;ET&gt; CGAL::Quadratic_program_solution&lt; ET &gt;::objective_value</definition>
        <argsstring>() const</argsstring>
        <name>objective_value</name>
        <briefdescription>
<para>returns the objective function value of <computeroutput>sol</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="216" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a060d7132f675cfe385ab2d0b67e390c0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref></type>
        <definition>ET CGAL::Quadratic_program_solution&lt; ET &gt;::objective_value_numerator</definition>
        <argsstring>() const</argsstring>
        <name>objective_value_numerator</name>
        <briefdescription>
<para>returns the numerator of the objective function value of <computeroutput>sol</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="222" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ae333593bdda03cd6a8f40a65861d547d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref></type>
        <definition>ET CGAL::Quadratic_program_solution&lt; ET &gt;::objective_value_denominator</definition>
        <argsstring>() const</argsstring>
        <name>objective_value_denominator</name>
        <briefdescription>
<para>returns the denominator of the objective function value of <computeroutput>sol</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="228" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ab27775fe308a64a52707a4c31d8eaa2f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ac068efd477e3899cc81f7b465b4cd6f4" kindref="member">Variable_value_iterator</ref></type>
        <definition>Variable_value_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::variable_values_begin</definition>
        <argsstring>() const</argsstring>
        <name>variable_values_begin</name>
        <briefdescription>
<para>returns a random-access iterator over the values of the variables in <computeroutput>sol</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;ET&gt;</computeroutput>, and the valid iterator range has length <formula id="4">$ n$</formula>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="236" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a518306002d12894e5cbb9c0902d7ddac" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ac068efd477e3899cc81f7b465b4cd6f4" kindref="member">Variable_value_iterator</ref></type>
        <definition>Variable_value_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::variable_values_end</definition>
        <argsstring>() const</argsstring>
        <name>variable_values_end</name>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="242" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a473ee87dd5712a854d1883cd10c1b6a3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ac2731f1622211a110847f7537788478e" kindref="member">Variable_numerator_iterator</ref></type>
        <definition>Variable_numerator_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::variable_numerators_begin</definition>
        <argsstring>() const</argsstring>
        <name>variable_numerators_begin</name>
        <briefdescription>
<para>returns a random-access iterator <computeroutput>it</computeroutput> over the values of the variables in <computeroutput>sol</computeroutput>, with respect to a common denominator of all variables. </para>        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput>ET</computeroutput>, and the valid iterator range has length <formula id="4">$ n$</formula>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="250" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1aa1e01c3b73d96fcadd8cd02f608aa396" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ac2731f1622211a110847f7537788478e" kindref="member">Variable_numerator_iterator</ref></type>
        <definition>Variable_numerator_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::variable_numerators_end</definition>
        <argsstring>() const</argsstring>
        <name>variable_numerators_end</name>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="255" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a4a2a74d91a373adc21b99c77abb7743f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref> &amp;</type>
        <definition>const ET&amp; CGAL::Quadratic_program_solution&lt; ET &gt;::variables_common_denominator</definition>
        <argsstring>() const</argsstring>
        <name>variables_common_denominator</name>
        <briefdescription>
<para>returns the common denominator of the variable values as referred to by the previous two methods. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="261" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Basic variables and constraints</header>
      <description><para>The solution of a linear or quadratic program distinguishes &apos;important&apos; variables (the ones not attaining one of their bounds), and &apos;important&apos; constraints (the ones being satisfied with equality).</para><para>The following methods grant access to them. <ref refid="QP_solver_2important_variables_8cpp-example" kindref="compound">QP_solver/important_variables.cpp</ref> <ref refid="QP_solver_2first_qp_basic_constraints_8cpp-example" kindref="compound">QP_solver/first_qp_basic_constraints.cpp</ref> </para></description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a8c32bda4450f86d163e0dc2569d36c4a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" kindref="member">Index_iterator</ref></type>
        <definition>Index_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::basic_variable_indices_begin</definition>
        <argsstring>() const</argsstring>
        <name>basic_variable_indices_begin</name>
        <briefdescription>
<para>returns a random access iterator over the indices of the basic variables. </para>        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput>int</computeroutput>. It is guaranteed that any variable that is not basic in <computeroutput>sol</computeroutput> attains one of its bounds. In particular, if the bounds are of type <formula id="49">$ \qpx\geq0$</formula>, all non-basic variables have value <formula id="42">$ 0$</formula>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="280" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a3f5b9b569163384c48d0797ecc34f842" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" kindref="member">Index_iterator</ref></type>
        <definition>Index_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::basic_variable_indices_end</definition>
        <argsstring>() const</argsstring>
        <name>basic_variable_indices_end</name>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="285" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a2809357e44c9b5b1a6b7272edfef80da" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int CGAL::Quadratic_program_solution&lt; ET &gt;::number_of_basic_variables</definition>
        <argsstring>() const</argsstring>
        <name>number_of_basic_variables</name>
        <briefdescription>
<para>returns the number of basic variables, equivalently the length of the range determined by the previous two iterators. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="291" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a12bfffa787c05c37bc6d74c30d858e85" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" kindref="member">Index_iterator</ref></type>
        <definition>Index_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::basic_constraint_indices_begin</definition>
        <argsstring>() const</argsstring>
        <name>basic_constraint_indices_begin</name>
        <briefdescription>
<para>returns a random access iterator over the indices of the basic constraints in the system <formula id="50">$ A\qpx\qprel\qpb$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput>int</computeroutput>. It is guaranteed that any basic constraint is satisfied with equality. In particular, if the system is of type <formula id="51">$ A\qpx=\qpb$</formula>, all constraints are basic. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="300" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a5e4afea24148899eb269522aee688e27" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" kindref="member">Index_iterator</ref></type>
        <definition>Index_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::basic_constraint_indices_end</definition>
        <argsstring>() const</argsstring>
        <name>basic_constraint_indices_end</name>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="305" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1aaa6f7440000b4c9346e60e2cbd24fb09" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int CGAL::Quadratic_program_solution&lt; ET &gt;::number_of_basic_constraints</definition>
        <argsstring>() const</argsstring>
        <name>number_of_basic_constraints</name>
        <briefdescription>
<para>returns the number of basic constraint, equivalently the length of the range determined by the previous two iterators. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="311" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a9e9c3b7fb4d868d7001371f902cbec74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename <ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref></type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const Quadratic_program_solution&lt; ET &gt; &amp;sol)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref>&lt; <ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref> &gt; &amp;</type>
          <declname>sol</declname>
        </param>
        <briefdescription>
<para>writes the status of <computeroutput>sol</computeroutput> to the stream <computeroutput>out</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>In case the status is <computeroutput>QP_OPTIMAL</computeroutput>, the optimal objective value and the values of the variables at the optimal solution are output as well. For more detailed information about the solution (like basic variables/constraints) please use the dedicated methods of <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref>&lt;ET&gt;</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="322" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Validity</header>
      <description><para>The following four methods allow you to check whether <computeroutput>sol</computeroutput> indeed solves the program that you intended to solve.</para><para>The methods use the certificates described in the advanced section below and thus save you from validating the certificates yourself (if you believe in the correctness of these methods; otherwise, you can look at their implementation to convince yourself). By passing a suitable option to the solution function, you can make sure that this check is done automatically after the solution of the program, see <computeroutput><ref refid="classCGAL_1_1Quadratic__program__options" kindref="compound">Quadratic_program_options</ref></computeroutput>. If the check fails, a logfile is generated that contains the details, and an error message is written to <computeroutput>std::cerr</computeroutput> (see <ref refid="QP_solver_2cycling_8cpp-example" kindref="compound">QP_solver/cycling.cpp</ref> for an example that uses this option). <ref refid="QP_solver_2first_qp_8cpp-example" kindref="compound">QP_solver/first_qp.cpp</ref> <ref refid="QP_solver_2first_lp_8cpp-example" kindref="compound">QP_solver/first_lp.cpp</ref> <ref refid="QP_solver_2first_nonnegative_qp_8cpp-example" kindref="compound">QP_solver/first_nonnegative_qp.cpp</ref> <ref refid="QP_solver_2first_nonnegative_lp_8cpp-example" kindref="compound">QP_solver/first_nonnegative_lp.cpp</ref> </para></description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a4beeb40be1247a5e5a17b0cfbe96ad06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref></type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::solves_quadratic_program</definition>
        <argsstring>(const QuadraticProgram &amp;qp)</argsstring>
        <name>solves_quadratic_program</name>
        <param>
          <type>const <ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref> &amp;</type>
          <declname>qp</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> solves the quadratic program <computeroutput>qp</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>If the result is <computeroutput>false</computeroutput>, you can get a message that describes the problem, through the method <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ae2feb2cd3dcd74534c55d7911262a09b" kindref="member">get_error()</ref></computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="348" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a226f5715d84737e8a21902b376e627df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classLinearProgram" kindref="compound">LinearProgram</ref></type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::solves_linear_program</definition>
        <argsstring>(const LinearProgram &amp;lp)</argsstring>
        <name>solves_linear_program</name>
        <param>
          <type>const <ref refid="classLinearProgram" kindref="compound">LinearProgram</ref> &amp;</type>
          <declname>lp</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> solves the linear program <computeroutput>lp</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>If the result is <computeroutput>false</computeroutput>, you can get a message that describes the problem, through the method <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ae2feb2cd3dcd74534c55d7911262a09b" kindref="member">get_error()</ref></computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="357" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ab2dcda8127ae7a937e7caa60818e2d66" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref></type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::solves_nonnegative_quadratic_program</definition>
        <argsstring>(const NonnegativeQuadraticProgram &amp;qp)</argsstring>
        <name>solves_nonnegative_quadratic_program</name>
        <param>
          <type>const <ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref> &amp;</type>
          <declname>qp</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> solves the nonnegative quadratic program <computeroutput>qp</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>If the result is <computeroutput>false</computeroutput>, you can get a message that describes the problem, through the method <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ae2feb2cd3dcd74534c55d7911262a09b" kindref="member">get_error()</ref></computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="367" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ac32fcbecc6865df856d7b5ca312fc51e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref></type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::solves_nonnegative_linear_program</definition>
        <argsstring>(const NonnegativeLinearProgram &amp;lp)</argsstring>
        <name>solves_nonnegative_linear_program</name>
        <param>
          <type>const <ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref> &amp;</type>
          <declname>lp</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> solves the nonnegative linear program <computeroutput>lp</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>If the result is <computeroutput>false</computeroutput>, you can get a message that describes the problem, through the method <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ae2feb2cd3dcd74534c55d7911262a09b" kindref="member">get_error()</ref></computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="376" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1aec7c82223eb4722b352ca34a512b0345" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::is_valid</definition>
        <argsstring>() const</argsstring>
        <name>is_valid</name>
        <briefdescription>
<para>returns <computeroutput>false</computeroutput> iff the validation through one of the previous four functions has failed. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="383" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ae2feb2cd3dcd74534c55d7911262a09b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const std::string &amp;</type>
        <definition>const std::string&amp; CGAL::Quadratic_program_solution&lt; ET &gt;::get_error</definition>
        <argsstring>() const</argsstring>
        <name>get_error</name>
        <briefdescription>
<para>returns an error message in case any of the previous four validation functions has returned <computeroutput>false</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="389" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Certificates</header>
      <description><para>A certificate is a vector that admits a simple proof for the correctness of the solution.</para><para>Any non-void object of <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> comes with such a certificate. </para></description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ad31c503dd7001857de9b1ec1ecd6403d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ace8c70b2cc7dc3457aed8cb72e2ba8b8" kindref="member">Optimality_certificate_iterator</ref></type>
        <definition>Optimality_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::optimality_certifcate_begin</definition>
        <argsstring>() const</argsstring>
        <name>optimality_certifcate_begin</name>
        <briefdescription>
<para>returns a random access iterator over the optimality certificate <formula id="47">$ \qplambda$</formula> as given in Lemma 1, with respect to the solution <formula id="46">$ \qpx^*$</formula> obtained from <computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1ab27775fe308a64a52707a4c31d8eaa2f" kindref="member">variable_values_begin()</ref></computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;ET&gt;</computeroutput>, and the valid iterator range has length <formula id="9">$ m$</formula>. <simplesect kind="pre"><para><computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1a46e9204eb8ad6bcc917733ac46affd86" kindref="member">is_optimal()</ref></computeroutput>.</para></simplesect>
<bold>Lemma 1(optimality certificate):</bold> A feasible <formula id="4">$ n$</formula>-vector <formula id="52">$\qpx^*$</formula> is an optimal solution of (QP) if an <formula id="9">$ m$</formula>-vector <formula id="47">$ \qplambda$</formula> with the following properties exist. <orderedlist>
<listitem>
<para>if the <formula id="30">$ i$</formula>-th constraint is of type <formula id="53">$ \leq$</formula> ( <formula id="54">$ \geq$</formula>, respectively), then <formula id="55">$\lambda_i\geq 0$</formula> ( <formula id="56">$\lambda_i\leq 0$</formula>, respectively). </para></listitem>
<listitem>
<para><formula id="57">$\qplambda^T(A\qpx^*-\qpb) = 0$</formula> </para></listitem>
<listitem>
<para><formula id="58">\[ \begin{array}{llll} &amp;&amp;\geq 0, &amp; \mbox{if $x^*_j = l_j &lt; u_j$} \\ (\qpc^T + \qplambda^T A + 2{\qpx^*}^TD)_j&amp; \quad &amp;= 0, &amp; \mbox{if $l_j &lt; x^*_j &lt; u_j$} \\ &amp;&amp;\leq 0, &amp; \mbox{if $l_j &lt; u_j = x^*_j$.} \end{array} \]</formula> </para></listitem>
</orderedlist>
</para><para><bold>Proof:</bold> Let <formula id="59">$\qpx$</formula> be any feasible solution. We need to prove that <formula id="60">\[\qpc^T\qpx + \qpx^TD\qpx \geq \qpc^T\qpx^* + {\qpx^*}^TD\qpx^*.\]</formula></para><para>For this, we argue as follows. <formula id="61">\[ \begin{array}{lcll} \qpc^T\qpx + 2{\qpx^*}^TD\qpx &amp;\geq&amp; \qpc^T\qpx + 2{\qpx^*}^TD\qpx + \qplambda^T(A\qpx-\qpb) &amp; \mbox{(by $A\qpx\qprel \qpb$ and 1.)} \\ &amp;=&amp; (\qpc^T + \qplambda^T A + 2{\qpx^*}^TD)\qpx - \qplambda^Tb \\ &amp;\geq&amp; (\qpc^T + \qplambda^T A + 2{\qpx^*}^TD)\qpx^* - \qplambda^Tb &amp; \mbox{(by $\qpl\leq \qpx \leq \qpu$ and 3.)} \\ &amp;=&amp; \qpc^T\qpx^* + 2{\qpx^*}^TD\qpx^* &amp; \mbox{(by 2.)} \end{array} \]</formula></para><para>After adding <formula id="62">$\qpx^TD\qpx - \qpx^TD\qpx - {\qpx^*}^TD\qpx^* = -{\qpx^*}^TD\qpx^*$</formula> to both sides of this inequality, we get <formula id="63">\[ \qpc^T\qpx + \qpx^TD\qpx - (\qpx-\qpx^*)^TD(\qpx-\qpx^*) \geq \qpc^T\qpx^* + {\qpx^*}^TD\qpx^*, \]</formula> and since <formula id="64">$D$</formula> is positive semidefinite, we have <formula id="65">$(\qpx-\qpx^*)^TD(\qpx-\qpx^*)\geq 0$</formula> and the lemma follows.</para><para><simplesect kind="see"><para><ref refid="QP_solver_2optimality_certificate_8cpp-example" kindref="compound">QP_solver/optimality_certificate.cpp</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="452" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a8211aaa107030deaa8b31595df42073f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ace8c70b2cc7dc3457aed8cb72e2ba8b8" kindref="member">Optimality_certificate_iterator</ref></type>
        <definition>Optimality_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::optimality_certificate_end</definition>
        <argsstring>() const</argsstring>
        <name>optimality_certificate_end</name>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ad31c503dd7001857de9b1ec1ecd6403d" kindref="member">optimality_certifcate_begin()</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="460" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ab2289b43805b57bbb103ec2ad790e74a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1acb96b76c78f9db3cd75d4a209723592b" kindref="member">Optimality_certificate_numerator_iterator</ref></type>
        <definition>Optimality_certificate_numerator_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::optimality_certifcate_numerators_begin</definition>
        <argsstring>() const</argsstring>
        <name>optimality_certifcate_numerators_begin</name>
        <briefdescription>
<para>returns a random access iterator over the numerator values of the optimality certificate <formula id="47">$ \qplambda$</formula>, with respect to the common denominator returned by <computeroutput>sol</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1a4a2a74d91a373adc21b99c77abb7743f" kindref="member">variables_common_denominator()</ref></computeroutput>. The value type is <computeroutput>ET</computeroutput>, and the valid iterator range has length <formula id="9">$ m$</formula>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ad31c503dd7001857de9b1ec1ecd6403d" kindref="member">optimality_certifcate_begin()</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="471" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ab07a09054cfc94c21da5243416497fb0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1acb96b76c78f9db3cd75d4a209723592b" kindref="member">Optimality_certificate_numerator_iterator</ref></type>
        <definition>Optimality_certificate_numerator_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::optimality_certificate_numerators_end</definition>
        <argsstring>() const</argsstring>
        <name>optimality_certificate_numerators_end</name>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ad31c503dd7001857de9b1ec1ecd6403d" kindref="member">optimality_certifcate_begin()</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="479" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ac8d0a811a809ce9f9ebae4931bc2de92" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ab68ab70cab7cc778611f144d8127028e" kindref="member">Infeasibility_certificate_iterator</ref></type>
        <definition>Infeasibility_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::infeasibility_certificate_begin</definition>
        <argsstring>() const</argsstring>
        <name>infeasibility_certificate_begin</name>
        <briefdescription>
<para>returns a random access iterator over the infeasibility certificate <formula id="47">$ \qplambda$</formula> as given in Lemma 2. </para>        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput>ET</computeroutput>, and the valid iterator range has length <formula id="9">$ m$</formula>. <simplesect kind="pre"><para><computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1ad0c8cf7f23b0b8b934f38c38f9e51f64" kindref="member">is_infeasible()</ref></computeroutput>.</para></simplesect>
<bold>Lemma 2 (infeasibility certificate):</bold> The program (QP) is infeasible if an <formula id="66">$m$</formula>-vector <formula id="67">$\qplambda$</formula> with the following properties exist.</para><para><orderedlist>
<listitem>
<para>if the <formula id="68">$i$</formula>-th constraint is of type <formula id="69">$\leq$</formula> ( <formula id="70">$\geq$</formula>, respectively), then <formula id="55">$\lambda_i\geq 0$</formula> ( <formula id="56">$\lambda_i\leq 0$</formula>, respectively). </para></listitem>
<listitem>
<para><formula id="71">\[ \begin{array}{llll} &amp;&amp;\geq 0 &amp; \mbox{if \f$u_j=\infty\f$} \\ \qplambda^T A_j &amp;\quad \\ &amp;&amp;\leq 0 &amp; \mbox{if \f$l_j=-\infty\f$.} \end{array} \]</formula> </para></listitem>
<listitem>
<para><formula id="72">\[\qplambda^T\qpb \quad&lt;\quad \ccSum{j: \qplambda^TA_j &lt;0}{}{ \qplambda^TA_j u_j } \quad+\quad \ccSum{j: \qplambda^TA_j &gt;0}{}{ \qplambda^TA_j l_j}.\]</formula> </para></listitem>
</orderedlist>
</para><para><bold>Proof:</bold> Let us assume for the purpose of obtaining a contradiction that there is a feasible solution <formula id="59">$\qpx$</formula>. Then we get <formula id="73">\[ \begin{array}{lcll} 0 &amp;\geq&amp; \qplambda^T(A\qpx -\qpb) &amp; \mbox{(by \f$A\qpx\qprel \qpb\f$ and 1.)} \\ &amp;=&amp; \ccSum{j: \qplambda^TA_j &lt;0}{}{ \qplambda^TA_j x_j } \quad+\quad \ccSum{j: \qplambda^TA_j &gt;0}{}{ \qplambda^TA_j x_j} - \qplambda^T \qpb \\ &amp;\geq&amp; \ccSum{j: \qplambda^TA_j &lt;0}{}{ \qplambda^TA_j u_j } \quad+\quad \ccSum{j: \qplambda^TA_j &gt;0}{}{ \qplambda^TA_j l_j} - \qplambda^T \qpb &amp; \mbox{(by \f$\qpl\leq \qpx \leq \qpu\f$ and 2.)} \\ &amp;&gt;&amp; 0 &amp; \mbox{(by 3.)}, \end{array} \]</formula> and this is the desired contradiction <formula id="74">$0&gt;0$</formula>.</para><para><simplesect kind="see"><para><ref refid="QP_solver_2infeasibility_certificate_8cpp-example" kindref="compound">QP_solver/infeasibility_certificate.cpp</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="525" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ae33cb591de6b236373954db46660b3c2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ab68ab70cab7cc778611f144d8127028e" kindref="member">Infeasibility_certificate_iterator</ref></type>
        <definition>Infeasibility_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::infeasibility_certificate_end</definition>
        <argsstring>() const</argsstring>
        <name>infeasibility_certificate_end</name>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ac8d0a811a809ce9f9ebae4931bc2de92" kindref="member">infeasibility_certificate_begin()</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="533" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1aa1e81c88d8023a974b5a1d17a8749a2f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ae853fea0d020ada3e7bd4ee51f671f89" kindref="member">Unboundedness_certificate_iterator</ref></type>
        <definition>Unboundedness_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::unboundedness_certificate_begin</definition>
        <argsstring>() const</argsstring>
        <name>unboundedness_certificate_begin</name>
        <briefdescription>
<para>returns a random acess iterator over the unbounded direction <formula id="48">$ \qpw$</formula> as given in Lemma 3,with respect to the solution <formula id="46">$ \qpx^*$</formula> obtained from <computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1ab27775fe308a64a52707a4c31d8eaa2f" kindref="member">variable_values_begin()</ref></computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput>ET</computeroutput>, and the valid iterator range has length <formula id="4">$ n$</formula>. <simplesect kind="pre"><para><computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1a9910d81e17dc950f289d168f1b5f7b2f" kindref="member">is_unbounded()</ref></computeroutput>.</para></simplesect>
<bold>Lemma 3 (unboundedness certificate:)</bold> Let <formula id="52">$\qpx^*$</formula> be a feasible solution of (QP). The program (QP) is unbounded if an <formula id="75">$n$</formula>-vector <formula id="76">$\qpw$</formula> with the following properties exist. <orderedlist>
<listitem>
<para>if the <formula id="68">$i$</formula>-th constraint is of type <formula id="69">$\leq$</formula> ( <formula id="77">$\geq, =$</formula>, respectively), then <formula id="78">$(A\qpw)_i\leq 0$</formula> ( <formula id="79">$(A\qpw)_i\geq 0, (A\qpw)_i=0$</formula>, respectively). </para></listitem>
<listitem>
<para><formula id="80">\[ \begin{array}{llll} &amp;&amp;\geq 0 &amp; \mbox{if \f$l_j\f$ is finite} \\ w_j &amp;\quad \\ &amp;&amp;\leq 0 &amp; \mbox{if \f$u_j\f$ is finite.} \end{array} \]</formula> </para></listitem>
<listitem>
<para><formula id="81">$\qpw^TD\qpw=0$</formula> and <formula id="82">$(\qpc^T+2{\qpx^*}^TD)\qpw&lt;0$</formula>. </para></listitem>
</orderedlist>
</para><para>The vector <formula id="76">$\qpw$</formula> is called an <emphasis>unbounded direction</emphasis>.</para><para><bold>Proof:</bold> For a real number <formula id="83">$t$</formula>, consider the vector <formula id="84">$\qpx(t):=\qpx^*+t\qpw$</formula>. By 1. and 2., <formula id="85">$\qpx(t)$</formula> is feasible for all <formula id="86">$t\geq 0$</formula>. The objective function value of <formula id="85">$\qpx(t)$</formula> is <formula id="87">\begin{eqnarray*} \qpc^T \qpx(t) + \qpx(t)^TD \qpx(t) &amp;=&amp; \qpc^T\qpx^* + t\qpc^T\qpw + {\qpx^*}^TD\qpx^* + 2t{\qpx^*}^TD\qpw + t^2 \qpw^TD\qpw \\ &amp;=&amp; \qpc^T\qpx^* + {\qpx^*}^TD\qpx^* + t(\qpc^T + 2{\qpx^*}^TD)\qpw + t^2\qpw^TD\qpw. \end{eqnarray*}</formula> By condition 3., this tends to <formula id="88">$-\infty$</formula> for <formula id="89">$t\rightarrow\infty$</formula>, so the problem is indeed unbounded. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="572" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a589566d104eb97133f0b243d34d4f010" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ae853fea0d020ada3e7bd4ee51f671f89" kindref="member">Unboundedness_certificate_iterator</ref></type>
        <definition>Unboundedness_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::unboundedness_certificate_end</definition>
        <argsstring>()</argsstring>
        <name>unboundedness_certificate_end</name>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1aa1e81c88d8023a974b5a1d17a8749a2f" kindref="member">unboundedness_certificate_begin()</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="580" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>An object of class <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> represents the solution of a linear or convex quadratic program of the general form. </para>    </briefdescription>
    <detaileddescription>
<para><formula id="2">$ \newcommand{\qprel}{\gtreqless} \newcommand{\qpx}{\mathbf{x}} \newcommand{\qpl}{\mathbf{l}} \newcommand{\qpu}{\mathbf{u}} \newcommand{\qpc}{\mathbf{c}} \newcommand{\qpb}{\mathbf{b}} \newcommand{\qpy}{\mathbf{y}} \newcommand{\qpw}{\mathbf{w}} \newcommand{\qplambda}{\mathbf{\lambda}} $</formula></para><para><formula id="26">\begin{eqnarray*} \mbox{(QP)}&amp; \mbox{minimize} &amp; \qpx^{T}D\qpx+\qpc^{T}\qpx+c_0 \\ &amp;\mbox{subject to} &amp; A\qpx\qprel \qpb, \\ &amp; &amp; \qpl \leq \qpx \leq \qpu \end{eqnarray*}</formula> in <formula id="4">$ n$</formula> real variables <formula id="5">$ \qpx=(x_0,\ldots,x_{n-1})$</formula>.</para><para>If <formula id="27">$ D=0$</formula>, the program is a linear program; if the variable bounds are <formula id="45">$ \qpx\geq 0$</formula>, we have a nonnegative program. Objects of type <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> are returned by any of the four functions <computeroutput>solve_quadratic_program</computeroutput>, <computeroutput>solve_linear_program</computeroutput>, <computeroutput>solve_nonnegative_quadratic_program</computeroutput>, and <computeroutput>solve_nonnegative_linear_program</computeroutput>.</para><para><heading level="2">Example </heading>
</para><para><ref refid="QP_solver_2first_qp_8cpp-example" kindref="compound">QP_solver/first_qp.cpp</ref></para><para><heading level="2">Terminology </heading>
</para><para>If there is no <formula id="13">$ \qpx$</formula> that satisfies all the (in)equalities, the program is called <emphasis>infeasible</emphasis>, otherwise, it is <emphasis>feasible</emphasis>, and any <formula id="13">$ \qpx$</formula> that satisfies all (in)equalities is called a <emphasis>feasible solution</emphasis>.</para><para>If the objective function value becomes arbitrarily small over the <emphasis>feasible region</emphasis> (the set of feasible solutions), the program is called <emphasis>unbounded</emphasis>, and <emphasis>bounded</emphasis> otherwise.</para><para>Any program that is both feasible and bounded has at least one feasible solution <formula id="46">$ \qpx^*$</formula> whose objective function value is not larger than that of any other feasible solution. This is called an <emphasis>optimal solution</emphasis>.</para><para>Every convex quadratic program (even if it is infeasible or unbounded) has a &apos;solution&apos; in form of an object of the class <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput>.</para><para>The program concepts <simplesect kind="see"><para><computeroutput><ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classLinearProgram" kindref="compound">LinearProgram</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref></computeroutput></para></simplesect>
and the functions that compute objects of class <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> from models of these concepts:</para><para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1gac769fb5f56983e35bec295b26501df7f" kindref="member">solve_quadratic_program</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga1fefbd0436aca0e281f88e8e6cd8eb74" kindref="member">solve_linear_program</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga3322921afa601ff6691a70658c8cecc7" kindref="member">solve_nonnegative_quadratic_program</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1gafb60a136bc34bebcf9387266d3e36742" kindref="member">solve_nonnegative_linear_program</ref></computeroutput> </para></simplesect>
</para>    </detaileddescription>
    <location file="CGAL/QP_solution.h" line="80" column="1" bodyfile="CGAL/QP_solution.h" bodystart="80" bodyend="584"/>
    <listofallmembers>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a12bfffa787c05c37bc6d74c30d858e85" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>basic_constraint_indices_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a5e4afea24148899eb269522aee688e27" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>basic_constraint_indices_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a8c32bda4450f86d163e0dc2569d36c4a" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>basic_variable_indices_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a3f5b9b569163384c48d0797ecc34f842" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>basic_variable_indices_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>ET</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ae2feb2cd3dcd74534c55d7911262a09b" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>get_error</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Index_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ac8d0a811a809ce9f9ebae4931bc2de92" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>infeasibility_certificate_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ae33cb591de6b236373954db46660b3c2" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>infeasibility_certificate_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ab68ab70cab7cc778611f144d8127028e" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Infeasibility_certificate_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ad0c8cf7f23b0b8b934f38c38f9e51f64" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>is_infeasible</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a46e9204eb8ad6bcc917733ac46affd86" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>is_optimal</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a9910d81e17dc950f289d168f1b5f7b2f" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>is_unbounded</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1aec7c82223eb4722b352ca34a512b0345" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>is_valid</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1adc7dd0ec763d1231621d69863fd2cacd" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>is_void</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1aaa6f7440000b4c9346e60e2cbd24fb09" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>number_of_basic_constraints</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a2809357e44c9b5b1a6b7272edfef80da" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>number_of_basic_variables</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ac75add50cfbfd9e7ec466c67691ad5c4" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>number_of_iterations</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a096eed419289ff127c4ae5c8c01d5a3a" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>objective_value</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ae333593bdda03cd6a8f40a65861d547d" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>objective_value_denominator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a060d7132f675cfe385ab2d0b67e390c0" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>objective_value_numerator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a9e9c3b7fb4d868d7001371f902cbec74" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>operator&lt;&lt;</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ad31c503dd7001857de9b1ec1ecd6403d" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>optimality_certifcate_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ab2289b43805b57bbb103ec2ad790e74a" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>optimality_certifcate_numerators_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a8211aaa107030deaa8b31595df42073f" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>optimality_certificate_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ace8c70b2cc7dc3457aed8cb72e2ba8b8" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Optimality_certificate_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1acb96b76c78f9db3cd75d4a209723592b" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Optimality_certificate_numerator_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ab07a09054cfc94c21da5243416497fb0" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>optimality_certificate_numerators_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a49488f93f767d506f98975b85ace7b75" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Quadratic_program_solution</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a226f5715d84737e8a21902b376e627df" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>solves_linear_program</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ac32fcbecc6865df856d7b5ca312fc51e" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>solves_nonnegative_linear_program</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ab2dcda8127ae7a937e7caa60818e2d66" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>solves_nonnegative_quadratic_program</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a4beeb40be1247a5e5a17b0cfbe96ad06" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>solves_quadratic_program</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a70e43bc256ef17d80fae117005dd6d15" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>status</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1aa1e81c88d8023a974b5a1d17a8749a2f" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>unboundedness_certificate_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a589566d104eb97133f0b243d34d4f010" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>unboundedness_certificate_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ae853fea0d020ada3e7bd4ee51f671f89" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Unboundedness_certificate_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ac2731f1622211a110847f7537788478e" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Variable_numerator_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a473ee87dd5712a854d1883cd10c1b6a3" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>variable_numerators_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1aa1e01c3b73d96fcadd8cd02f608aa396" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>variable_numerators_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ac068efd477e3899cc81f7b465b4cd6f4" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Variable_value_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ab27775fe308a64a52707a4c31d8eaa2f" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>variable_values_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a518306002d12894e5cbb9c0902d7ddac" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>variable_values_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a4a2a74d91a373adc21b99c77abb7743f" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>variables_common_denominator</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
