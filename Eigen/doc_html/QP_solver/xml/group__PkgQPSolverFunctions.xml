<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="group__PkgQPSolverFunctions" kind="group">
    <compoundname>PkgQPSolverFunctions</compoundname>
    <title>Functions</title>
    <innerclass refid="classCGAL_1_1Quadratic__program__options" prot="public">CGAL::Quadratic_program_options</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__PkgQPSolverFunctions_1ga5e4c5717fab328c4e94c3d58e1bd4517" prot="public" static="no">
        <name>Quadratic_program_pricing_strategy</name>
        <enumvalue id="group__PkgQPSolverFunctions_1gga5e4c5717fab328c4e94c3d58e1bd4517a3921451b2d9930928eaf4e64b1028161" prot="public">
          <name>QP_CHOOSE_DEFAULT</name>
          <briefdescription>
<para>This is the default value of the pricing strategy in <computeroutput><ref refid="classCGAL_1_1Quadratic__program__options" kindref="compound">Quadratic_program_options</ref></computeroutput>, and it lets the solver choose the strategy that it thinks is most appropriate for the problem at hand. </para>          </briefdescription>
          <detaileddescription>
<para>There are only few reasons to deviate from this default, but you are free to experiment, of course. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PkgQPSolverFunctions_1gga5e4c5717fab328c4e94c3d58e1bd4517a2bde547a8669c3de04f36c35737c95b0" prot="public">
          <name>QP_PARTIAL_DANTZIG</name>
          <briefdescription>
<para>If the input type is <bold>not</bold> <computeroutput>double</computeroutput>, this is usually the best choice for linear and quadratic programs of medium size. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PkgQPSolverFunctions_1gga5e4c5717fab328c4e94c3d58e1bd4517acfdcc3c905ef34e4daf8dbe6320a098e" prot="public">
          <name>QP_DANTZIG</name>
          <briefdescription>
<para>If the input type is <bold>not</bold> <computeroutput>double</computeroutput>, this can sometimes make a difference (be faster or slowe) than <computeroutput>QP_PARTIAL_DANTZIG</computeroutput> for problems with a high variable/constraint or constraint/variable ratio. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PkgQPSolverFunctions_1gga5e4c5717fab328c4e94c3d58e1bd4517a85c10fcd1aa2edd600b04fc85d37574e" prot="public">
          <name>QP_PARTIAL_FILTERED_DANTZIG</name>
          <briefdescription>
<para>If the input type <bold>is</bold> <computeroutput>double</computeroutput>, this is usually the best choice for linear and quadratic programs of medium size. </para>          </briefdescription>
          <detaileddescription>
<para>If the input type is not <computeroutput>double</computeroutput>, this choice is equivalent to <computeroutput>QP_PARTIAL_DANTZIG</computeroutput>.</para><para><bold>Note:</bold> filtered strategies may in rare cases fail due to double exponent overflows, see Section <ref refid="index_1secQPcustomizationfiltering" kindref="member">Exponent Overflow in Double Using Floating-Point Filters</ref>. In this case, the slower fallback option is the non-filtered variant <computeroutput>QP_PARTIAL_DANTZIG</computeroutput> of this strategy. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PkgQPSolverFunctions_1gga5e4c5717fab328c4e94c3d58e1bd4517a47f81fc4506c7af2cf76d608d154f998" prot="public">
          <name>QP_FILTERED_DANTZIG</name>
          <briefdescription>
<para>If the input type <bold>is</bold> <computeroutput>double</computeroutput>, this can sometimes make a difference (be faster or slowe) than <computeroutput>QP_PARTIAL_FILTERED_DANTZIG</computeroutput> for problems with a high variable/constraint or constraint/variable ratio. </para>          </briefdescription>
          <detaileddescription>
<para>If the input type is not <computeroutput>double</computeroutput>, this choice is equivalent to <computeroutput>QP_DANTZIG</computeroutput>.</para><para><simplesect kind="note"><para>Filtered strategies may in rare cases fail due to double exponent overflows, see Section <ref refid="index_1secQPcustomizationfiltering" kindref="member">Exponent Overflow in Double Using Floating-Point Filters</ref>. In this case, the slower fallback option is the non-filtered variant <computeroutput>QP_DANTZIG</computeroutput> of this strategy. </para></simplesect>
</para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PkgQPSolverFunctions_1gga5e4c5717fab328c4e94c3d58e1bd4517a1f12b7a8fb6bdc5391069b0aaac81d31" prot="public">
          <name>QP_BLAND</name>
          <briefdescription>
<para>This is hardly ever the most efficient choice, but it is guaranteed to avoid internal cycling of the solution algorithm, see Section <ref refid="index_1secQPcustomizationcycling" kindref="member">The Solver Internally Cycles</ref>. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>This is an enumeration type containing the values <computeroutput>QP_CHOOSE_DEFAULT</computeroutput>, <computeroutput>QP_DANTZIG</computeroutput>, <computeroutput>QP_PARTIAL_DANTZIG</computeroutput>, <computeroutput>QP_FILTERED_DANTZIG</computeroutput>, <computeroutput>QP_PARTIAL_FILTERED_DANTZIG</computeroutput>, and<computeroutput>QP_BLAND</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>It indicates the pricing strategy to be used in solving a linear or quadratic program. This strategy determines how the solver gets from one intermediate solution to the next during any of its iterations.</para><para>Here we briefly describe when to choose which strategy.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__options" kindref="compound">Quadratic_program_options</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_options.h" line="125" column="1" bodyfile="CGAL/QP_options.h" bodystart="125" bodyend="182"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1ga137d2f521e0128ac6779daf72633eb46" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="classLinearProgram" kindref="compound">LinearProgram</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::print_linear_program</definition>
        <argsstring>(std::ostream &amp;out, const LinearProgram &amp;lp, const std::string &amp;problem_name=std::string(&quot;MY_MPS&quot;))</argsstring>
        <name>print_linear_program</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classLinearProgram" kindref="compound">LinearProgram</ref> &amp;</type>
          <declname>lp</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>problem_name</declname>
          <defval>std::string(&quot;MY_MPS&quot;)</defval>
        </param>
        <briefdescription>
<para>This function writes a linear program to an output stream (in <computeroutput><ref refid="classMPSFormat" kindref="compound">MPSFormat</ref></computeroutput>). </para>        </briefdescription>
        <detaileddescription>
<para>The time complexity is <formula id="0">$ \Theta (mn)$</formula>, even if the program is very sparse.</para><para>It writes the linear program <computeroutput>lp</computeroutput> to <computeroutput>out</computeroutput> in <computeroutput><ref refid="classMPSFormat" kindref="compound">MPSFormat</ref></computeroutput>. The name of the program will be the one provided by <computeroutput>problem_name</computeroutput>.</para><para><heading level="2">Requirements </heading>
</para><para>Output operators are defined for all entry types of <computeroutput>lp</computeroutput>.</para><para><heading level="2">Example </heading>
</para><para><ref refid="QP_solver_2print_first_lp_8cpp-example" kindref="compound">QP_solver/print_first_lp.cpp</ref></para><para><simplesect kind="see"><para>The concept <computeroutput><ref refid="classLinearProgram" kindref="compound">LinearProgram</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_functions.h" line="29" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1ga396252d27710f62ea28b6d7d82537f21" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::print_nonnegative_linear_program</definition>
        <argsstring>(std::ostream &amp;out, const NonnegativeLinearProgram &amp;lp, const std::string &amp;problem_name=std::string(&quot;MY_MPS&quot;))</argsstring>
        <name>print_nonnegative_linear_program</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref> &amp;</type>
          <declname>lp</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>problem_name</declname>
          <defval>std::string(&quot;MY_MPS&quot;)</defval>
        </param>
        <briefdescription>
<para>This function writes a nonnegative linear program to an output stream (in <computeroutput><ref refid="classMPSFormat" kindref="compound">MPSFormat</ref></computeroutput>). </para>        </briefdescription>
        <detaileddescription>
<para>The time complexity is <formula id="0">$ \Theta (mn)$</formula>, even if the program is very sparse.</para><para>Writes the nonnegative linear program <computeroutput>lp</computeroutput> to <computeroutput>out</computeroutput> in <computeroutput><ref refid="classMPSFormat" kindref="compound">MPSFormat</ref></computeroutput>. The name of the program will be the one provided by <computeroutput>problem_name</computeroutput>.</para><para><heading level="2">Requirements </heading>
</para><para>Output operators are defined for all entry types of <computeroutput>lp</computeroutput>.</para><para><heading level="2">Example </heading>
</para><para><ref refid="QP_solver_2print_first_nonnegative_lp_8cpp-example" kindref="compound">QP_solver/print_first_nonnegative_lp.cpp</ref></para><para><simplesect kind="see"><para>The concept <computeroutput><ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_functions.h" line="57" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1ga3d7b5e9b1a6ec6f77ab7e4e9e9d2ed87" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::print_nonnegative_quadratic_program</definition>
        <argsstring>(std::ostream &amp;out, const NonnegativeQuadraticProgram &amp;qp, const std::string &amp;problem_name=std::string(&quot;MY_MPS&quot;))</argsstring>
        <name>print_nonnegative_quadratic_program</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref> &amp;</type>
          <declname>qp</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>problem_name</declname>
          <defval>std::string(&quot;MY_MPS&quot;)</defval>
        </param>
        <briefdescription>
<para>This function writes a nonnegative quadratic program to an output stream (in <computeroutput><ref refid="classMPSFormat" kindref="compound">MPSFormat</ref></computeroutput>). </para>        </briefdescription>
        <detaileddescription>
<para>The time complexity is <formula id="1">$ \Theta (n^2 + mn)$</formula>, even if the program is very sparse.</para><para>Writes the nonnegative quadratic program <computeroutput>qp</computeroutput> to <computeroutput>out</computeroutput> in <computeroutput><ref refid="classMPSFormat" kindref="compound">MPSFormat</ref></computeroutput>. The name of the program will be the one provided by <computeroutput>problem_name</computeroutput>.</para><para><heading level="2">Requirements </heading>
</para><para>Output operators are defined for all entry types of <computeroutput>qp</computeroutput>.</para><para><heading level="2">Example </heading>
</para><para><ref refid="QP_solver_2print_first_nonnegative_qp_8cpp-example" kindref="compound">QP_solver/print_first_nonnegative_qp.cpp</ref></para><para><simplesect kind="see"><para>The concept <computeroutput><ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_functions.h" line="85" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1ga8619efc4112be3685e5017f31576cd39" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::print_quadratic_program</definition>
        <argsstring>(std::ostream &amp;out, const QuadraticProgram &amp;qp, const std::string &amp;problem_name=std::string(&quot;MY_MPS&quot;))</argsstring>
        <name>print_quadratic_program</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref> &amp;</type>
          <declname>qp</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>problem_name</declname>
          <defval>std::string(&quot;MY_MPS&quot;)</defval>
        </param>
        <briefdescription>
<para>This function writes a quadratic program to an output stream (in <computeroutput><ref refid="classMPSFormat" kindref="compound">MPSFormat</ref></computeroutput>). </para>        </briefdescription>
        <detaileddescription>
<para>The time complexity is <formula id="1">$ \Theta (n^2 + mn)$</formula>, even if the program is very sparse.</para><para>Writes the quadratic program <computeroutput>qp</computeroutput> to <computeroutput>out</computeroutput> in <computeroutput><ref refid="classMPSFormat" kindref="compound">MPSFormat</ref></computeroutput>. The name of the program will be the one provided by <computeroutput>problem_name</computeroutput>.</para><para><heading level="2">Requirements </heading>
</para><para>Output operators are defined for all entry types of <computeroutput>qp</computeroutput>.</para><para><heading level="2">Example </heading>
</para><para><ref refid="QP_solver_2print_first_qp_8cpp-example" kindref="compound">QP_solver/print_first_qp.cpp</ref></para><para><simplesect kind="see"><para>The concept <computeroutput><ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_functions.h" line="111" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1ga1fefbd0436aca0e281f88e8e6cd8eb74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="classLinearProgram" kindref="compound">LinearProgram</ref></type>
          </param>
          <param>
            <type>ET</type>
          </param>
        </templateparamlist>
        <type>Quadratic_program_solution&lt; ET &gt;</type>
        <definition>Quadratic_program_solution&lt;ET&gt; CGAL::solve_linear_program</definition>
        <argsstring>(const LinearProgram &amp;lp, const ET &amp;, const Quadratic_program_options &amp;options=Quadratic_program_options())</argsstring>
        <name>solve_linear_program</name>
        <param>
          <type>const <ref refid="classLinearProgram" kindref="compound">LinearProgram</ref> &amp;</type>
          <declname>lp</declname>
        </param>
        <param>
          <type>const ET &amp;</type>
        </param>
        <param>
          <type>const Quadratic_program_options &amp;</type>
          <declname>options</declname>
          <defval>Quadratic_program_options()</defval>
        </param>
        <briefdescription>
<para>This function solves a linear program, using some exact Integral Domain <computeroutput>ET</computeroutput> for its computations. </para>        </briefdescription>
        <detaileddescription>
<para>Various options may be provided, see <computeroutput><ref refid="classCGAL_1_1Quadratic__program__options" kindref="compound">Quadratic_program_options</ref></computeroutput>.</para><para><heading level="2">Requirements </heading>
</para><para><computeroutput>ET</computeroutput> is a model of the concepts <computeroutput><ref refid="classIntegralDomain" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomain</ref></computeroutput> and <computeroutput><ref refid="classRealEmbeddable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">RealEmbeddable</ref></computeroutput>; it must be an exact type, and all entries of <computeroutput>qp</computeroutput> are convertible to <computeroutput>ET</computeroutput>.</para><para>Here are some recommended combinations of input type (the type of the <computeroutput>qp</computeroutput> entries) and <computeroutput>ET</computeroutput>.</para><para><table rows="4" cols="2"><row>
<entry thead="yes"><para>input type </para></entry><entry thead="yes"><para>ET  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>double</computeroutput> </para></entry><entry thead="no"><para><computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Gmpzf" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpzf</ref></computeroutput>, or <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>int</computeroutput> </para></entry><entry thead="no"><para><computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref></computeroutput>, or <computeroutput><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpz</ref></computeroutput> </para></entry></row>
<row>
<entry thead="no"><para>any exact type <computeroutput>NT</computeroutput> </para></entry><entry thead="no"><para><computeroutput>NT</computeroutput> </para></entry></row>
</table>
<simplesect kind="note"><para>By default, this function performs a large number of runtime-checks to ensure consistency during the solution process. However, these checks slow down the computations by a considerable factor. For maximum efficiency, it is advisable to define the macros <computeroutput>CGAL_QP_NO_ASSERTIONS</computeroutput> or <computeroutput>NDEBUG</computeroutput>.</para></simplesect>
<simplesect kind="return"><para>the solution of the linear program <computeroutput>lp</computeroutput>, solved with exact number type <computeroutput>ET</computeroutput>.</para></simplesect>
<heading level="2">Example </heading>
</para><para><ref refid="QP_solver_2first_lp_8cpp-example" kindref="compound">QP_solver/first_lp.cpp</ref></para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program" kindref="compound">Quadratic_program</ref>&lt;NT&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__from__mps" kindref="compound">Quadratic_program_from_mps</ref>&lt;NT&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Linear__program__from__iterators" kindref="compound">Linear_program_from_iterators</ref>&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it&gt;</computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_functions.h" line="158" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1gafb60a136bc34bebcf9387266d3e36742" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref></type>
          </param>
          <param>
            <type>ET</type>
          </param>
        </templateparamlist>
        <type>Quadratic_program_solution&lt; ET &gt;</type>
        <definition>Quadratic_program_solution&lt;ET&gt; CGAL::solve_nonnegative_linear_program</definition>
        <argsstring>(const NonnegativeLinearProgram &amp;lp, const ET &amp;, const Quadratic_program_options &amp;options=Quadratic_program_options())</argsstring>
        <name>solve_nonnegative_linear_program</name>
        <param>
          <type>const <ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref> &amp;</type>
          <declname>lp</declname>
        </param>
        <param>
          <type>const ET &amp;</type>
        </param>
        <param>
          <type>const Quadratic_program_options &amp;</type>
          <declname>options</declname>
          <defval>Quadratic_program_options()</defval>
        </param>
        <briefdescription>
<para>This function solves a nonnegative linear program, using some exact Integral Domain <computeroutput>ET</computeroutput> for its computations. </para>        </briefdescription>
        <detaileddescription>
<para>Various options may be provided, see <computeroutput><ref refid="classCGAL_1_1Quadratic__program__options" kindref="compound">Quadratic_program_options</ref></computeroutput>.</para><para><heading level="2">Requirements </heading>
</para><para><computeroutput>ET</computeroutput> is a model of the concepts <computeroutput><ref refid="classIntegralDomain" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomain</ref></computeroutput> and <computeroutput><ref refid="classRealEmbeddable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">RealEmbeddable</ref></computeroutput>; it must be an exact type, and all entries of <computeroutput>qp</computeroutput> are convertible to <computeroutput>ET</computeroutput>.</para><para>Here are some recommended combinations of input type (the type of the <computeroutput>qp</computeroutput> entries) and <computeroutput>ET</computeroutput>.</para><para><table rows="4" cols="2"><row>
<entry thead="yes"><para>input type </para></entry><entry thead="yes"><para>ET  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>double</computeroutput> </para></entry><entry thead="no"><para><computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Gmpzf" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpzf</ref></computeroutput>, or <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>int</computeroutput> </para></entry><entry thead="no"><para><computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref></computeroutput>, or <computeroutput><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpz</ref></computeroutput> </para></entry></row>
<row>
<entry thead="no"><para>any exact type <computeroutput>NT</computeroutput> </para></entry><entry thead="no"><para><computeroutput>NT</computeroutput> </para></entry></row>
</table>
<simplesect kind="note"><para>By default, this function performs a large number of runtime-checks to ensure consistency during the solution process. However, these checks slow down the computations by a considerable factor. For maximum efficiency, it is advisable to define the macros <computeroutput>CGAL_QP_NO_ASSERTIONS</computeroutput> or <computeroutput>NDEBUG</computeroutput>.</para></simplesect>
<simplesect kind="return"><para>the solution of the nonnegative linear program <computeroutput>lp</computeroutput>, solved with exact number type <computeroutput>ET</computeroutput>.</para></simplesect>
<heading level="2">Example </heading>
</para><para><ref refid="QP_solver_2first_nonnegative_lp_8cpp-example" kindref="compound">QP_solver/first_nonnegative_lp.cpp</ref></para><para>The models of <ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref>\: <simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program" kindref="compound">Quadratic_program</ref>&lt;NT&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__from__mps" kindref="compound">Quadratic_program_from_mps</ref>&lt;NT&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Nonnegative__linear__program__from__iterators" kindref="compound">Nonnegative_linear_program_from_iterators</ref>&lt;A_it, B_it, R_it, C_it&gt;</computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_functions.h" line="206" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1ga3322921afa601ff6691a70658c8cecc7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref></type>
          </param>
          <param>
            <type>ET</type>
          </param>
        </templateparamlist>
        <type>Quadratic_program_solution&lt; ET &gt;</type>
        <definition>Quadratic_program_solution&lt;ET&gt; CGAL::solve_nonnegative_quadratic_program</definition>
        <argsstring>(const NonnegativeQuadraticProgram &amp;qp, const ET &amp;, const Quadratic_program_options &amp;options=Quadratic_program_options())</argsstring>
        <name>solve_nonnegative_quadratic_program</name>
        <param>
          <type>const <ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref> &amp;</type>
          <declname>qp</declname>
        </param>
        <param>
          <type>const ET &amp;</type>
        </param>
        <param>
          <type>const Quadratic_program_options &amp;</type>
          <declname>options</declname>
          <defval>Quadratic_program_options()</defval>
        </param>
        <briefdescription>
<para>This function solves a nonnegative quadratic program, using some exact Integral Domain <computeroutput>ET</computeroutput> for its computations. </para>        </briefdescription>
        <detaileddescription>
<para>Various options may be provided, see <computeroutput><ref refid="classCGAL_1_1Quadratic__program__options" kindref="compound">Quadratic_program_options</ref></computeroutput>.</para><para><heading level="2">Requirements </heading>
</para><para><computeroutput>ET</computeroutput> is a model of the concepts <computeroutput><ref refid="classIntegralDomain" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomain</ref></computeroutput> and <computeroutput><ref refid="classRealEmbeddable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">RealEmbeddable</ref></computeroutput>; it must be an exact type, and all entries of <computeroutput>qp</computeroutput> are convertible to <computeroutput>ET</computeroutput>.</para><para>Here are some recommended combinations of input type (the type of the <computeroutput>qp</computeroutput> entries) and <computeroutput>ET</computeroutput>.</para><para><table rows="4" cols="2"><row>
<entry thead="yes"><para>input type </para></entry><entry thead="yes"><para>ET  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>double</computeroutput> </para></entry><entry thead="no"><para><computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Gmpzf" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpzf</ref></computeroutput>, or <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>int</computeroutput> </para></entry><entry thead="no"><para><computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref></computeroutput>, or <computeroutput><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpz</ref></computeroutput> </para></entry></row>
<row>
<entry thead="no"><para>any exact type <computeroutput>NT</computeroutput> </para></entry><entry thead="no"><para><computeroutput>NT</computeroutput> </para></entry></row>
</table>
<simplesect kind="note"><para>By default, this function performs a large number of runtime-checks to ensure consistency during the solution process. However, these checks slow down the computations by a considerable factor. For maximum efficiency, it is advisable to define the macros <computeroutput>CGAL_QP_NO_ASSERTIONS</computeroutput> or <computeroutput>NDEBUG</computeroutput>.</para></simplesect>
<simplesect kind="return"><para>the solution of the nonnegative quadratic program <computeroutput>qp</computeroutput>, solved with exact number type <computeroutput>ET</computeroutput>.</para></simplesect>
<heading level="2">Example </heading>
</para><para><ref refid="QP_solver_2first_nonnegative_qp_8cpp-example" kindref="compound">QP_solver/first_nonnegative_qp.cpp</ref></para><para>The models of <ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref>\: <simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program" kindref="compound">Quadratic_program</ref>&lt;NT&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__from__mps" kindref="compound">Quadratic_program_from_mps</ref>&lt;NT&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Nonnegative__quadratic__program__from__iterators" kindref="compound">Nonnegative_quadratic_program_from_iterators</ref>&lt;A_it, B_it, R_it, D_it, C_it&gt;</computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_functions.h" line="253" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1gac769fb5f56983e35bec295b26501df7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type><ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref></type>
          </param>
          <param>
            <type>ET</type>
          </param>
        </templateparamlist>
        <type>Quadratic_program_solution&lt; ET &gt;</type>
        <definition>Quadratic_program_solution&lt;ET&gt; CGAL::solve_quadratic_program</definition>
        <argsstring>(const QuadraticProgram &amp;qp, const ET &amp;, const Quadratic_program_options &amp;options=Quadratic_program_options())</argsstring>
        <name>solve_quadratic_program</name>
        <param>
          <type>const <ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref> &amp;</type>
          <declname>qp</declname>
        </param>
        <param>
          <type>const ET &amp;</type>
        </param>
        <param>
          <type>const Quadratic_program_options &amp;</type>
          <declname>options</declname>
          <defval>Quadratic_program_options()</defval>
        </param>
        <briefdescription>
<para>This function solves a quadratic program, using some exact Integral Domain <computeroutput>ET</computeroutput> for its computations. </para>        </briefdescription>
        <detaileddescription>
<para>Various options may be provided, see <computeroutput><ref refid="classCGAL_1_1Quadratic__program__options" kindref="compound">Quadratic_program_options</ref></computeroutput>.</para><para><heading level="2">Requirements </heading>
</para><para><computeroutput>ET</computeroutput> is a model of the concepts <computeroutput><ref refid="classIntegralDomain" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomain</ref></computeroutput> and <computeroutput><ref refid="classRealEmbeddable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">RealEmbeddable</ref></computeroutput>; it must be an exact type, and all entries of <computeroutput>qp</computeroutput> are convertible to <computeroutput>ET</computeroutput>.</para><para>Here are some recommended combinations of input type (the type of the <computeroutput>qp</computeroutput> entries) and <computeroutput>ET</computeroutput>.</para><para><table rows="4" cols="2"><row>
<entry thead="yes"><para>input type </para></entry><entry thead="yes"><para>ET  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>double</computeroutput> </para></entry><entry thead="no"><para><computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Gmpzf" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpzf</ref></computeroutput>, or <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput> </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>int</computeroutput> </para></entry><entry thead="no"><para><computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref></computeroutput>, or <computeroutput><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpz</ref></computeroutput> </para></entry></row>
<row>
<entry thead="no"><para>any exact type <computeroutput>NT</computeroutput> </para></entry><entry thead="no"><para><computeroutput>NT</computeroutput> </para></entry></row>
</table>
<simplesect kind="note"><para>By default, this function performs a large number of runtime-checks to ensure consistency during the solution process. However, these checks slow down the computations by a considerable factor. For maximum efficiency, it is advisable to define the macros <computeroutput>CGAL_QP_NO_ASSERTIONS</computeroutput> or <computeroutput>NDEBUG</computeroutput>.</para></simplesect>
<simplesect kind="return"><para>the solution of the quadratic program <computeroutput>qp</computeroutput>, solved with exact number type <computeroutput>ET</computeroutput>.</para></simplesect>
<heading level="2">Example </heading>
</para><para><ref refid="QP_solver_2first_qp_8cpp-example" kindref="compound">QP_solver/first_qp.cpp</ref></para><para>The models of <ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref>\: <simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program" kindref="compound">Quadratic_program</ref>&lt;NT&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__from__mps" kindref="compound">Quadratic_program_from_mps</ref>&lt;NT&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__from__iterators" kindref="compound">Quadratic_program_from_iterators</ref>&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, D_it, C_it&gt;</computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_functions.h" line="301" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1ga95d3fc8234fcda24022dffd96cdd8d02" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename A_it</type>
          </param>
          <param>
            <type>typename B_it</type>
          </param>
          <param>
            <type>typename R_it</type>
          </param>
          <param>
            <type>typename FL_it</type>
          </param>
          <param>
            <type>typename L_it</type>
          </param>
          <param>
            <type>typename FU_it</type>
          </param>
          <param>
            <type>typename U_it</type>
          </param>
          <param>
            <type>typename C_it</type>
          </param>
        </templateparamlist>
        <type>Linear_program_from_iterators&lt; A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it &gt;</type>
        <definition>Linear_program_from_iterators&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it&gt; CGAL::make_linear_program_from_iterators</definition>
        <argsstring>(int n, int m, const A_it &amp;a, const B_it &amp;b, const R_it &amp;r, const FL_it &amp;fl, const L_it &amp;l, const FU_it &amp;fu, const U_it &amp;u, const C_it &amp;c, std::iterator_traits&lt; C_it &gt;::value_type c0=std::iterator_traits&lt; C_it &gt;::value_type(0))</argsstring>
        <name>make_linear_program_from_iterators</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const A_it &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const B_it &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const R_it &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const FL_it &amp;</type>
          <declname>fl</declname>
        </param>
        <param>
          <type>const L_it &amp;</type>
          <declname>l</declname>
        </param>
        <param>
          <type>const FU_it &amp;</type>
          <declname>fu</declname>
        </param>
        <param>
          <type>const U_it &amp;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>const C_it &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>std::iterator_traits&lt; C_it &gt;::value_type</type>
          <declname>c0</declname>
          <defval>std::iterator_traits&lt; C_it &gt;::value_type(0)</defval>
        </param>
        <briefdescription>
<para>This template function creates an instance of <computeroutput><ref refid="classCGAL_1_1Linear__program__from__iterators" kindref="compound">Linear_program_from_iterators</ref>&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it&gt;</computeroutput> from given iterators. </para>        </briefdescription>
        <detaileddescription>
<para>This function can be useful if the types of these iterators are too complicated (or of too little interest for you) to write them down explicitly.</para><para><simplesect kind="return"><para>an instance of <computeroutput><ref refid="classCGAL_1_1Linear__program__from__iterators" kindref="compound">Linear_program_from_iterators</ref>&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it&gt;</computeroutput>, constructed from the given iterators.</para></simplesect>
<heading level="2">Example </heading>
</para><para>The following example demonstrates the typical usage of makers with the simpler function <computeroutput><ref refid="group__PkgQPSolverFunctions_1ga8d885b3a94f653869d58ea9ed03a66fa" kindref="member">make_nonnegative_linear_program_from_iterators()</ref></computeroutput>.</para><para><computeroutput>QP_solver/solve_convex_hull_containment_lp2.h</computeroutput></para><para><ref refid="QP_solver_2convex_hull_containment2_8cpp-example" kindref="compound">QP_solver/convex_hull_containment2.cpp</ref></para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Linear__program__from__iterators" kindref="compound">Linear_program_from_iterators</ref>&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it&gt;</computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_models.h" line="138" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1ga8d885b3a94f653869d58ea9ed03a66fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>A_it</type>
          </param>
          <param>
            <type>B_it</type>
          </param>
          <param>
            <type>R_it</type>
          </param>
          <param>
            <type>C_it</type>
          </param>
        </templateparamlist>
        <type>Nonnegative_linear_program_from_iterators&lt; A_it, B_it, R_it, C_it &gt;</type>
        <definition>Nonnegative_linear_program_from_iterators&lt;A_it, B_it, R_it, C_it&gt; CGAL::make_nonnegative_linear_program_from_iterators</definition>
        <argsstring>(int n, int m, const A_it &amp;a, const B_it &amp;b, const R_it &amp;r, const C_it &amp;c, std::iterator_traits&lt; C_it &gt;::value_type c0=std::iterator_traits&lt; C_it &gt;::value_type(0))</argsstring>
        <name>make_nonnegative_linear_program_from_iterators</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const A_it &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const B_it &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const R_it &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const C_it &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>std::iterator_traits&lt; C_it &gt;::value_type</type>
          <declname>c0</declname>
          <defval>std::iterator_traits&lt; C_it &gt;::value_type(0)</defval>
        </param>
        <briefdescription>
<para>This template function creates an instance of <computeroutput><ref refid="classCGAL_1_1Nonnegative__linear__program__from__iterators" kindref="compound">Nonnegative_linear_program_from_iterators</ref>&lt;A_it, B_it, R_it, C_it&gt;</computeroutput> from given iterators. </para>        </briefdescription>
        <detaileddescription>
<para>This function can be useful if the types of these iterators are too complicated (or of too little interest for you) to write them down explicitly.</para><para><simplesect kind="return"><para>an instance of <computeroutput><ref refid="classCGAL_1_1Nonnegative__linear__program__from__iterators" kindref="compound">Nonnegative_linear_program_from_iterators</ref>&lt;A_it, B_it, R_it, C_it&gt;</computeroutput>, constructed from the given iterators.</para></simplesect>
<heading level="2">Example </heading>
</para><para><computeroutput>QP_solver/solve_convex_hull_containment_lp2.h</computeroutput></para><para><ref refid="QP_solver_2convex_hull_containment2_8cpp-example" kindref="compound">QP_solver/convex_hull_containment2.cpp</ref></para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Nonnegative__linear__program__from__iterators" kindref="compound">Nonnegative_linear_program_from_iterators</ref>&lt;A_it, B_it, R_it, C_it&gt;</computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_models.h" line="179" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1ga832bed341ea49379f829fec7b5700032" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>A_it</type>
          </param>
          <param>
            <type>B_it</type>
          </param>
          <param>
            <type>R_it</type>
          </param>
          <param>
            <type>D_it</type>
          </param>
          <param>
            <type>C_it</type>
          </param>
        </templateparamlist>
        <type>Nonnegative_quadratic_program_from_iterators&lt; A_it, B_it, R_it, D_it, C_it &gt;</type>
        <definition>Nonnegative_quadratic_program_from_iterators&lt;A_it, B_it, R_it, D_it, C_it&gt; CGAL::make_nonnegative_quadratic_program_from_iterators</definition>
        <argsstring>(int n, int m, const A_it &amp;a, const B_it &amp;b, const R_it &amp;r, const D_it &amp;d, const C_it &amp;c, std::iterator_traits&lt; C_it &gt;::value_type c0=std::iterator_traits&lt; C_it &gt;::value_type(0))</argsstring>
        <name>make_nonnegative_quadratic_program_from_iterators</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const A_it &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const B_it &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const R_it &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const D_it &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type>const C_it &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>std::iterator_traits&lt; C_it &gt;::value_type</type>
          <declname>c0</declname>
          <defval>std::iterator_traits&lt; C_it &gt;::value_type(0)</defval>
        </param>
        <briefdescription>
<para>This template function creates an instance of <computeroutput><ref refid="classCGAL_1_1Nonnegative__quadratic__program__from__iterators" kindref="compound">Nonnegative_quadratic_program_from_iterators</ref>&lt;A_it, B_it, R_it, D_it, C_it&gt;</computeroutput> from given iterators. </para>        </briefdescription>
        <detaileddescription>
<para>This function can be useful if the types of these iterators are too complicated (or of too little interest for you) to write them down explicitly.</para><para><simplesect kind="return"><para>an instance of <computeroutput><ref refid="classCGAL_1_1Nonnegative__quadratic__program__from__iterators" kindref="compound">Nonnegative_quadratic_program_from_iterators</ref>&lt;A_it, B_it, R_it, D_it,C_it&gt;</computeroutput>, constructed from the given iterators.</para></simplesect>
<heading level="2">Example </heading>
</para><para>The following example demonstrates the typical usage of makers with the simpler function <computeroutput><ref refid="group__PkgQPSolverFunctions_1ga8d885b3a94f653869d58ea9ed03a66fa" kindref="member">make_nonnegative_linear_program_from_iterators()</ref></computeroutput>.</para><para><computeroutput>QP_solver/solve_convex_hull_containment_lp2.h</computeroutput></para><para><ref refid="QP_solver_2convex_hull_containment2_8cpp-example" kindref="compound">QP_solver/convex_hull_containment2.cpp</ref></para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Nonnegative__quadratic__program__from__iterators" kindref="compound">Nonnegative_quadratic_program_from_iterators</ref>&lt;A_it, B_it, R_it, D_it, C_it&gt;</computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_models.h" line="223" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgQPSolverFunctions_1ga922187a3a67c1cc2ed9837c419c6fa60" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename A_it</type>
          </param>
          <param>
            <type>typename B_it</type>
          </param>
          <param>
            <type>typename R_it</type>
          </param>
          <param>
            <type>typename FL_it</type>
          </param>
          <param>
            <type>typename L_it</type>
          </param>
          <param>
            <type>typename FU_it</type>
          </param>
          <param>
            <type>typename U_it</type>
          </param>
          <param>
            <type>typename D_it</type>
          </param>
          <param>
            <type>typename C_it</type>
          </param>
        </templateparamlist>
        <type>Quadratic_program_from_iterators&lt; A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, D_it, C_it &gt;</type>
        <definition>Quadratic_program_from_iterators&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, D_it, C_it&gt; CGAL::make_quadratic_program_from_iterators</definition>
        <argsstring>(int n, int m, const A_it &amp;a, const B_it &amp;b, const R_it &amp;r, const FL_it &amp;fl, const L_it &amp;l, const FU_it &amp;fu, const U_it &amp;u, const D_it &amp;d, const C_it &amp;c, std::iterator_traits&lt; C_it &gt;::value_type c0=std::iterator_traits&lt; C_it &gt;::value_type(0))</argsstring>
        <name>make_quadratic_program_from_iterators</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>m</declname>
        </param>
        <param>
          <type>const A_it &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const B_it &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const R_it &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const FL_it &amp;</type>
          <declname>fl</declname>
        </param>
        <param>
          <type>const L_it &amp;</type>
          <declname>l</declname>
        </param>
        <param>
          <type>const FU_it &amp;</type>
          <declname>fu</declname>
        </param>
        <param>
          <type>const U_it &amp;</type>
          <declname>u</declname>
        </param>
        <param>
          <type>const D_it &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type>const C_it &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>std::iterator_traits&lt; C_it &gt;::value_type</type>
          <declname>c0</declname>
          <defval>std::iterator_traits&lt; C_it &gt;::value_type(0)</defval>
        </param>
        <briefdescription>
<para>This template function creates an instance of <computeroutput><ref refid="classCGAL_1_1Quadratic__program__from__iterators" kindref="compound">Quadratic_program_from_iterators</ref>&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, D_it, C_it&gt;</computeroutput> from given iterators. </para>        </briefdescription>
        <detaileddescription>
<para>This function can be useful if the types of these iterators are too complicated (or of too little interest for you) to write them down explicitly.</para><para><simplesect kind="return"><para>an instance of <computeroutput><ref refid="classCGAL_1_1Quadratic__program__from__iterators" kindref="compound">Quadratic_program_from_iterators</ref>&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, D_it, C_it&gt;</computeroutput>, constructed from the given iterators.</para></simplesect>
<heading level="2">Example </heading>
</para><para>The following example demonstrates the typical usage of makers with the simpler function <computeroutput><ref refid="group__PkgQPSolverFunctions_1ga8d885b3a94f653869d58ea9ed03a66fa" kindref="member">make_nonnegative_linear_program_from_iterators()</ref></computeroutput>.</para><para><computeroutput>QP_solver/solve_convex_hull_containment_lp2.h</computeroutput></para><para><ref refid="QP_solver_2convex_hull_containment2_8cpp-example" kindref="compound">QP_solver/convex_hull_containment2.cpp</ref></para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__from__iterators" kindref="compound">Quadratic_program_from_iterators</ref>&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, D_it, C_it&gt;</computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_models.h" line="266" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>This module provides makers to construct a program, as well as functions to solve and print programs. </para>    </briefdescription>
    <detaileddescription>
<para>In case you want to construct a program from complicated iterators (whose types you don&apos;t know, or simply don&apos;t want to bother with), we provide four makers.</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga922187a3a67c1cc2ed9837c419c6fa60" kindref="member">CGAL::make_quadratic_program_from_iterators()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga95d3fc8234fcda24022dffd96cdd8d02" kindref="member">CGAL::make_linear_program_from_iterators()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga832bed341ea49379f829fec7b5700032" kindref="member">CGAL::make_nonnegative_quadratic_program_from_iterators()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga8d885b3a94f653869d58ea9ed03a66fa" kindref="member">CGAL::make_nonnegative_linear_program_from_iterators()</ref></computeroutput></para></listitem></itemizedlist>
</para><para>There are four functions to solve a program, one for each program concept.</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1gac769fb5f56983e35bec295b26501df7f" kindref="member">CGAL::solve_quadratic_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga1fefbd0436aca0e281f88e8e6cd8eb74" kindref="member">CGAL::solve_linear_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga3322921afa601ff6691a70658c8cecc7" kindref="member">CGAL::solve_nonnegative_quadratic_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1gafb60a136bc34bebcf9387266d3e36742" kindref="member">CGAL::solve_nonnegative_linear_program()</ref></computeroutput></para></listitem></itemizedlist>
</para><para>The solution process can customized by passing an object of the class</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__options" kindref="compound">CGAL::Quadratic_program_options</ref></computeroutput></para></listitem></itemizedlist>
</para><para>Programs can be written to an output stream in <ref refid="classMPSFormat" kindref="compound">MPSFormat</ref>, using one of the following four functions.</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga8619efc4112be3685e5017f31576cd39" kindref="member">CGAL::print_quadratic_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga137d2f521e0128ac6779daf72633eb46" kindref="member">CGAL::print_linear_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga3d7b5e9b1a6ec6f77ab7e4e9e9d2ed87" kindref="member">CGAL::print_nonnegative_quadratic_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga396252d27710f62ea28b6d7d82537f21" kindref="member">CGAL::print_nonnegative_linear_program()</ref></computeroutput> </para></listitem></itemizedlist>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
