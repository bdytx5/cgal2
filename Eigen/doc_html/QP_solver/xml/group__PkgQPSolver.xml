<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="group__PkgQPSolver" kind="group">
    <compoundname>PkgQPSolver</compoundname>
    <title>Linear and Quadratic Programming Solver Reference</title>
    <innergroup refid="group__PkgQPSolverConcepts">Concepts</innergroup>
    <innergroup refid="group__PkgQPSolverClasses">Classes</innergroup>
    <innergroup refid="group__PkgQPSolverFunctions">Functions</innergroup>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para> <image type="html" name="qp.png"></image>
   Kaspar Fischer, Bernd Gärtner, Sven Schönherr, and Frans Wessendorp This package contains algorithms for minimizing linear and convex quadratic functions over polyhedral domains, described by linear equations and inequalities. The algorithms are exact, i.e. the solution is computed in terms of multiprecision rational numbers. The resulting solution is certified: along with the claims that the problem under consideration has an optimal solution, is infeasible, or is unbounded, the algorithms also deliver proofs for these facts. These proofs can easily (and independently from the algorithms) be checked for correctness. The solution algorithms are based on a generalization of the simplex method to quadratic objective functions.  <linebreak/>
   <bold>Introduced in:</bold> CGAL 3.3<linebreak/>
 <bold>BibTeX:</bold> <ulink url="../Manual/how_to_cite_cgal.html#cgal:fgsw-lqps-18b">cgal:fgsw-lqps-18b</ulink><linebreak/>
 <bold>License:</bold> <ref refid="preliminaries_1licensesGPL" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">GPL</ref> <linebreak/>
 </para><para></para><para><heading level="2">Concepts</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref></computeroutput> (for quadratic programs with variable bounds l &lt;= x &lt;= u)</para></listitem><listitem><para><computeroutput><ref refid="classLinearProgram" kindref="compound">LinearProgram</ref></computeroutput> (for linear programs with variable bounds l &lt;= x &lt;= u)</para></listitem><listitem><para><computeroutput><ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref></computeroutput> (for quadratic programs with variable bounds x &gt;= 0)</para></listitem><listitem><para><computeroutput><ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref></computeroutput> (for linear programs with variable bounds x &gt;= 0)</para></listitem><listitem><para><computeroutput><ref refid="classMPSFormat" kindref="compound">MPSFormat</ref></computeroutput> (the format used for reading and writing linear and quadratic programs)</para></listitem></itemizedlist>
</para><para><heading level="2">Classes</heading>
</para><para>There is a class that represents the solution of a linear or quadratic program. An instance of this class is returned by any of the solution functions below.</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">CGAL::Quadratic_program_solution</ref>&lt;ET&gt;</computeroutput></para></listitem></itemizedlist>
</para><para>We offer a number of predefined models for the above program concepts. The following two are simultaneously models for all four concepts and are probably the most convenient models; they allow you to construct linear or quadratic programs entry by entry, or from streams in <computeroutput><ref refid="classMPSFormat" kindref="compound">MPSFormat</ref></computeroutput>. At any time, you can query these programs for linearity and nonnegativity and thus select the appropriate solution function.</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program" kindref="compound">CGAL::Quadratic_program</ref>&lt;NT&gt;</computeroutput> (for linear and quadratic programs that own their data and are built entry-wise)</para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__from__mps" kindref="compound">CGAL::Quadratic_program_from_mps</ref>&lt;NT&gt;</computeroutput> (for linear and quadratic programs read from an input stream in <ref refid="classMPSFormat" kindref="compound">MPSFormat</ref>; the constructed program can also be manipulate entry-wise)</para></listitem></itemizedlist>
</para><para>Then there are specific models for any of the four program concepts above; these are useful if you want to maintain the program data yourself, since they simply wrap random access iterators over the program data and involve no further copying of data.</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__from__iterators" kindref="compound">CGAL::Quadratic_program_from_iterators</ref>&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, D_it, C_it&gt;</computeroutput> (for quadratic programs that wrap given iterators, without copying data)</para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Linear__program__from__iterators" kindref="compound">CGAL::Linear_program_from_iterators</ref>&lt;A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it&gt;</computeroutput> (for linear programs wrapping given iterators)</para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Nonnegative__quadratic__program__from__iterators" kindref="compound">CGAL::Nonnegative_quadratic_program_from_iterators</ref>&lt;A_it, B_it, R_it, D_it, C_it&gt;</computeroutput> (for nonnegative quadratic programs, wrapping given iterators)</para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Nonnegative__linear__program__from__iterators" kindref="compound">CGAL::Nonnegative_linear_program_from_iterators</ref>&lt;A_it, B_it, R_it, C_it&gt;</computeroutput> (for nonnegative linear programs, wrapping given iterators)</para></listitem></itemizedlist>
</para><para><heading level="2">Functions</heading>
</para><para>In case you want to construct a program from complicated iterators (whose types you don&apos;t know, or simply don&apos;t want to bother with), we provide four makers.</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga922187a3a67c1cc2ed9837c419c6fa60" kindref="member">CGAL::make_quadratic_program_from_iterators()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga95d3fc8234fcda24022dffd96cdd8d02" kindref="member">CGAL::make_linear_program_from_iterators()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga832bed341ea49379f829fec7b5700032" kindref="member">CGAL::make_nonnegative_quadratic_program_from_iterators()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga8d885b3a94f653869d58ea9ed03a66fa" kindref="member">CGAL::make_nonnegative_linear_program_from_iterators()</ref></computeroutput></para></listitem></itemizedlist>
</para><para>There are four functions to solve a program, one for each program concept:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1gac769fb5f56983e35bec295b26501df7f" kindref="member">CGAL::solve_quadratic_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga1fefbd0436aca0e281f88e8e6cd8eb74" kindref="member">CGAL::solve_linear_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga3322921afa601ff6691a70658c8cecc7" kindref="member">CGAL::solve_nonnegative_quadratic_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1gafb60a136bc34bebcf9387266d3e36742" kindref="member">CGAL::solve_nonnegative_linear_program()</ref></computeroutput></para></listitem></itemizedlist>
</para><para>The solution process can customized by passing an object of the class</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__options" kindref="compound">CGAL::Quadratic_program_options</ref></computeroutput></para></listitem></itemizedlist>
</para><para>Programs can be written to an output stream in <ref refid="classMPSFormat" kindref="compound">MPSFormat</ref>, using one of the following four functions:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga8619efc4112be3685e5017f31576cd39" kindref="member">CGAL::print_quadratic_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga137d2f521e0128ac6779daf72633eb46" kindref="member">CGAL::print_linear_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga3d7b5e9b1a6ec6f77ab7e4e9e9d2ed87" kindref="member">CGAL::print_nonnegative_quadratic_program()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga396252d27710f62ea28b6d7d82537f21" kindref="member">CGAL::print_nonnegative_linear_program()</ref></computeroutput> </para></listitem></itemizedlist>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
