<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/QP_solver/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Linear and Quadratic Programming Solver: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Linear and Quadratic Programming Solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Linear_and_Quadratic_Programming_Solver"></a><a class="anchor" id="QPsolver"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Kaspar Fischer, Bernd Gärtner, Sven Schönherr, and Frans Wessendorp</dd></dl>
<p>\( \newcommand{\qprel}{\gtreqless} \newcommand{\qpx}{\mathbf{x}} \newcommand{\qpl}{\mathbf{l}} \newcommand{\qpu}{\mathbf{u}} \newcommand{\qpc}{\mathbf{c}} \newcommand{\qpb}{\mathbf{b}} \newcommand{\qpy}{\mathbf{y}} \newcommand{\qpw}{\mathbf{w}} \newcommand{\qplambda}{\mathbf{\lambda}} \)</p>
<h1><a class="anchor" id="secQPdef"></a>
Which Programs can be Solved?</h1>
<p>This package lets you solve <em>convex quadratic programs</em> of the general form </p><p class="formulaDsp">
\begin{eqnarray*} \mbox{(QP)}&amp; \mbox{minimize} &amp; \qpx^{T}D\qpx+\qpc^{T}\qpx+c_0 \\ &amp;\mbox{subject to} &amp; A\qpx\qprel \qpb, \\ &amp; &amp; \qpl \leq \qpx \leq \qpu \end{eqnarray*}
</p>
<p> in \( n\) real variables \( \qpx=(x_0,\ldots,x_{n-1})\).</p>
<p>Here, </p><ul>
<li>
\( A\) is an \( m\times n\) matrix (the constraint matrix), </li>
<li>
\( \qpb\) is an \( m\)-dimensional vector (the right-hand side), </li>
<li>
<p class="startli">\( \qprel\) is an \( m\)-dimensional vector of relations from \( \{\leq, =, \geq\}\),</p>
<p class="endli"></p>
</li>
<li>
\( \qpl\) is an \( n\)-dimensional vector of lower bounds for \( \qpx\), where \( l_j\in\mathbb{R}\cup\{-\infty\}\) for all \( j\) </li>
<li>
<p class="startli">\( \qpu\) is an \( n\)-dimensional vector of upper bounds for \( \qpx\), where \( u_j\in\mathbb{R}\cup\{\infty\}\) for all \( j\)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">\( D\) is a symmetric positive-semidefinite \( n\times n\) matrix (the quadratic objective function),</p>
<p class="endli"></p>
</li>
<li>
\( \qpc\) is an \( n\)-dimensional vector (the linear objective function), and </li>
<li>
<p class="startli">\( c_0\) is a constant.</p>
<p class="endli"></p>
</li>
</ul>
<p>If \( D=0\), the program (QP) is actually a <em>linear program</em>. Section <a class="el" href="index.html#secQProbustness">Robustness</a> on robustness briefly discusses the case of \( D\) not being positive-semidefinite and therefore not defining a convex program.</p>
<p><em>Solving</em> the program means to find an \( n\)-vector \( \qpx^*\) such that \( A\qpx^*\qprel \qpb, \qpl\leq \qpx^*\leq \qpu\) (a <em>feasible solution</em>), and with the smallest objective function value \( {\qpx^*}^TD\qpx^*+\qpc^T\qpx^*+c_0\) among all feasible solutions.</p>
<p>There might be no feasible solution at all, in which case the quadratic program is <em>infeasible</em>, or there might be feasible solutions of arbitrarily small objective function value, in which case the program is <em>unbounded</em>.</p>
<h1><a class="anchor" id="QP_solverDesign"></a>
Design, Efficiency, and Robustness</h1>
<p>The design of the package is quite simple. The linear or quadratic program to be solved is supplied in form of an object of a class that is a model of the concept <code><a class="el" href="classQuadraticProgram.html" title="A model of QuadraticProgram describes a convex quadratic program of the form. ">QuadraticProgram</a></code> (or some specialized other concepts, e.g. for linear programs). <span style="font-variant: small-caps;">CGAL</span> provides a number of easy-to-use and flexible models, see Section <a class="el" href="index.html#secQPfirst">How to Enter and Solve a Program</a> below. The input data may be of any given number type, such as <code>double</code>, <code>int</code>, or any exact type.</p>
<p>Then the program is solved using the function <code><a class="el" href="group__PkgQPSolverFunctions.html#gac769fb5f56983e35bec295b26501df7f" title="This function solves a quadratic program, using some exact Integral Domain ET for its computations...">solve_quadratic_program()</a></code> (or some specialized other functions, e.g. for linear programs). For this, you also have to provide a suitable <em>exact</em> number type <code>ET</code> used in the solution process. In case of input type <code>double</code>, solution methods that use floating-point-filtering are chosen by default for certain programs (in some cases, this is not appropriate, and the default should be changed; see Section <a class="el" href="index.html#secQPcustomization">Customizing the Solver</a> for details).</p>
<p>The output of this is an object of <code><a class="el" href="classCGAL_1_1Quadratic__program__solution.html" title="An object of class Quadratic_program_solution represents the solution of a linear or convex quadratic...">Quadratic_program_solution</a>&lt;ET&gt;</code> which you can in turn query for various things: what is the status of the program (optimally solved, infeasible, or unbounded?), what are the values of the optimal solution \( \qpx^*\), what is the associated objective function value, etc.</p>
<p>You can in particular get <em>certificates</em> for the solution. In short, these are proofs that the output is correct. Thus, if you don't believe in the solution (whether it says "optimally solved", "infeasible", or "unbounded"), you can verify it yourself by using the certificates. Section <a class="el" href="index.html#secQPcertificates">Solution Certificates</a> says more about this.</p>
<h2><a class="anchor" id="QP_solverEfficiency"></a>
Efficiency</h2>
<p>The concept <code><a class="el" href="classQuadraticProgram.html" title="A model of QuadraticProgram describes a convex quadratic program of the form. ">QuadraticProgram</a></code> (as well as the other specialized ones) require a <em>dense interface</em> of the program, in terms of <em>random-access iterators</em> over the matrices and vectors of (QP). Zero entries therefore play no special role and are treated like all other entries by the interface.</p>
<p>This has mainly historical reasons: the original motivation behind this package was low-dimensional geometric optimization where a dense representation is appropriate and efficient. In fact, the <span style="font-variant: small-caps;">CGAL</span> packages <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Bounding_volumes.tag:../Bounding_volumes/" href="../Bounding_volumes/classCGAL_1_1Min__annulus__d.html">Min_annulus_d</a>&lt;Traits&gt;</code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polytope_distance_d.tag:../Polytope_distance_d/" href="../Polytope_distance_d/classCGAL_1_1Polytope__distance__d.html">Polytope_distance_d</a>&lt;Traits&gt;</code> internally use the linear and quadratic programming solver.</p>
<p>As a user, however, you don't necessarily have to provide a dense <em>representation</em> of your program. You do not pass vectors or matrices to the solution functions, but rather specify the vectors and matrices through iterators. The iterator abstraction easily allows to build models that convert a sparse representation into a dense interface. The predefined models <code><a class="el" href="classCGAL_1_1Quadratic__program.html" title=" ">Quadratic_program</a>&lt;NT&gt;</code> and <code><a class="el" href="classCGAL_1_1Quadratic__program__from__mps.html" title="An object of class Quadratic_program_from_mps describes a convex quadratic program of the general for...">Quadratic_program_from_mps</a>&lt;NT&gt;</code> do exactly this; in using them, you can forget about the dense interface.</p>
<p>Nevertheless, if you care about efficiency, you cannot completely ignore the issue. If you think about a quadratic program in \( n\) variables and \( m\) constraints, its dense interface has \( \Theta(n^2 + mn)\) entries, even if actually very few of them are nonzero. This has consequences for the complexity of the internal computations. In fact, a single iteration of the solution process has complexity at least \( \Omega(mn)\), since usually, all entries of the matrix \( A\) are accessed. This implies that problems where \( \min(n,m)\) is large cannot be solved efficiently, even if the number of nonzero entries in the problem description is very small.</p>
<p>We can actually be quite precise about performance, in terms of the following parameters.</p>
<dl>
<dt>\(n\)</dt>
<dd>the number of variables (or columns of \(A\)), </dd>
<dt>\(m\)</dt>
<dd>the number of constraints (or rows of \(A\)) </dd>
<dt>\(e\)</dt>
<dd>the number of equality constraints, </dd>
<dt>\(r\)</dt>
<dd>the rank of the quadratic objective function matrix \(D\). </dd>
</dl>
<p>The time required to solve the problems is in most cases linear in \( \max(n,m)\), but with a factor heavily depending on \( \min(n,e)+r\). Therefore, the solver will be efficient only if \( \min(n,e)+r\) is small.</p>
<p>Here are the scenarios in which this applies: </p><ul>
<li>
Quadratic programs with a small number of variables, but possibly a large number of inequality constraints, </li>
<li>
Linear programs with a small number of equality constraints but possibly a large number of variables, </li>
<li>
Quadratic programs with a small number of equality constraints and \( D\) of small rank, but possibly with a large number of variables. </li>
</ul>
<p>How small is small? If \( \min(n,e)+r\) is up to \( 10\), the solver will probably be very fast, even if \( \max(n,m)\) goes into the millions. If \( \min(n,m)+r\) is up to a few hundreds, you may still get a solution within reasonable time, depending on the problem characteristics.</p>
<p>If you have a problem where both \( n\) and \( e\) are well above \( 1,000\), say, then chances are high that <span style="font-variant: small-caps;">CGAL</span> cannot solve it within reasonable time.</p>
<h2><a class="anchor" id="secQProbustness"></a>
Robustness</h2>
<p>Given that you use an <em>exact number type</em> in the function <code>solve_quadratic_program</code> (or in the other, specialized solution functions), the solver will give you <em>exact rational output</em>, for <em>every</em> convex quadratic program. It may fail to compute a solution only if </p><ol>
<li>
The quadratic program is too large (see the previous subsection on efficiency). </li>
<li>
The quadratic objective function matrix \( D\) is not positive-semidefinite (see the discussion below). </li>
<li>
The floating-point filter used by default for certain programs and input type <code>double</code> fails due to a <em>double</em> exponent overflow. This happens in rare cases only, and it does not pay off to sacrifice the efficiency of the filtered approach in order to cope with these rare cases. There are means, however, to avoid such problems by switching to a slower non-filtered variant, see Section <a class="el" href="index.html#secQPcustomizationfiltering">Exponent Overflow in Double Using Floating-Point Filters</a>. </li>
<li>
The solver internally cycles. This also happens in rare cases only. However, if you have a hunch that the solver cycles on your problem, there are means to switch to a slower variant that is guaranteed not to cycle, see Section <a class="el" href="index.html#secQPcustomizationcycling">The Solver Internally Cycles</a>. </li>
</ol>
<p>The second item merits special attention. First, you may ask why the solver does not check that \( D\) is positive semidefinite. But recall that \( D\) is given by a dense interface, and it would therefore cost \( \Omega(n^2)\) time already to access all entries of the matrix \( D\). The solver itself gets away with accessing much less entries of \( D\) in the relevant case where \( r\), the rank of \( D\), is small.</p>
<p>Nevertheless, the solver contains some runtime checks that may detect that the matrix \( D\) is not positive-semidefinite. But you may as well get an "optimal solution" in this case, even with valid certificates. The validity of these certificates, however, depends on \( D\) being positive-semidefinite; if this is not the case, the certificates only prove that the solver has found a "critical point" of your (nonconvex) program, but there are no guarantees whatsoever that this is a global optimum, or even a local optimum.</p>
<h1><a class="anchor" id="secQPfirst"></a>
How to Enter and Solve a Program</h1>
<p>In this section, we describe how you can supply and solve your problem, using the <span style="font-variant: small-caps;">CGAL</span> program models and solution functions. There are two essentially different ways to proceed, and we will discuss them in turn. In short, </p><ul>
<li>
you can let the model take care of your program data; you start from an empty program and then simply insert the non-zero entries, or read them from a file (more generally, any input stream) in <code><a class="el" href="classMPSFormat.html" title="MPS is a commonly used file format for storing linear and quadratic programs according to the concept...">MPSFormat</a></code>. You can also change program entries at any time. This is usually the most convenient way if you don't want to care about representation issues; </li>
<li>
you can maintain the data yourself and only supply suitable random-access iterators over the matrices and vectors. This is advantageous if you already have the data (explicitly, or implicitly encoded, for example through iterators) and want to avoid copying of data. Typically, this happens if you write generic iterator-based code. </li>
</ul>
<p>Our running example is the following quadratic program in two variables: </p><p class="formulaDsp">
\[ \begin{array}{lrcl} \mbox{minimize} &amp; x^2 + 4(y-4)^2 &amp;(=&amp; x^2 + 4y^2 - 32y + 64) \\ \mbox{subject to} &amp; x + y &amp;\leq&amp; 7 \\ &amp; -x + 2y &amp;\leq&amp; 4 \\ &amp; x &amp;\geq&amp; 0 \\ &amp; y &amp;\geq&amp; 0 \\ &amp; y &amp;\leq&amp; 4 \end{array} \]
</p>
<p><a class="el" href="index.html#fig__figQPfirst_qp">Figure 7.1</a> shows a picture. It depicts the five inequalities of the program, along with the <em>feasible region</em> (green), the set of points that satisfy all the five constraints. The dashed elliptic curves represent <em>contour lines</em> of the objective function, i.e., along each dashed curve, the objective function value is constant.</p>
<p>The global minimum of the objective function is attained at the point \( (0,4)\), and the minimum within the feasible region appears at the point \( (2,3)\) marked with a black dot. The value of the objective function at this optimal solution is \( 2^2 + 4(3-4)^2 = 8\).</p>
<p><a class="anchor" id="fig__figQPfirst_qp"></a></p><div class="image">
<img src="first_qp.png" alt="first_qp.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figQPfirst_qp">Figure 7.1</a> A quadratic program in two variables  </div>  <br />

<h2><a class="anchor" id="QP_solverConstructingaProgramfromData"></a>
Constructing a Program from Data</h2>
<p>Here is how this quadratic program can be solved in <span style="font-variant: small-caps;">CGAL</span> according to the first way (letting the model take care of the data). We use <code>int</code> as the input type, and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">MP_Float</a></code> or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">Gmpz</a></code> (which is faster and preferable if <code>GMP</code> is installed) as the exact type for the internal computations. In larger examples, it pays off to use <code>double</code> as input type in order to profit from the automatic floating-point filtering that takes place then.</p>
<p>For examples how to work with the input type <code>double</code>, we refer to Sections <a class="el" href="index.html#secQPiterators">Working from Iterators</a> and <a class="el" href="index.html#secQPcustomization">Customizing the Solver</a>.</p>
<p><b>Note:</b> For the quadratic objective function, the entries of the matrix \( 2D\) have to be provided, rather than \( D\). Although this is common to almost all quadratic programming solvers, it can easily be overlooked by a novice.</p>
<p><br />
<b>File</b> <a class="el" href="QP_solver_2first_qp_8cpp-example.html">QP_solver/first_qp.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// example: construct a quadratic program from data</span></div><div class="line"><span class="comment">// the QP below is the first quadratic program example in the user manual</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_models.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_functions.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// choose exact integral type</span></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_GMP</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpz_8h.html">CGAL/Gmpz.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">CGAL::Gmpz</a> ET;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">CGAL::MP_Float</a> ET;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">// program and solution types</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Quadratic__program.html">CGAL::Quadratic_program&lt;int&gt;</a> Program;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Quadratic__program__solution.html">CGAL::Quadratic_program_solution&lt;ET&gt;</a> Solution;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// by default, we have a nonnegative QP with Ax &lt;= b</span></div><div class="line">  Program qp (<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b">CGAL::SMALLER</a>, <span class="keyword">true</span>, 0, <span class="keyword">false</span>, 0); </div><div class="line">  </div><div class="line">  <span class="comment">// now set the non-default entries: </span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> X = 0; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> Y = 1;</div><div class="line">  qp.set_a(X, 0,  1); qp.set_a(Y, 0, 1); qp.set_b(0, 7);  <span class="comment">//  x + y  &lt;= 7</span></div><div class="line">  qp.set_a(X, 1, -1); qp.set_a(Y, 1, 2); qp.set_b(1, 4);  <span class="comment">// -x + 2y &lt;= 4</span></div><div class="line">  qp.set_u(Y, <span class="keyword">true</span>, 4);                                   <span class="comment">//       y &lt;= 4</span></div><div class="line">  qp.set_d(X, X, 2); qp.set_d (Y, Y, 8); <span class="comment">// !!specify 2D!!    x^2 + 4 y^2</span></div><div class="line">  qp.set_c(Y, -32);                                       <span class="comment">// -32y</span></div><div class="line">  qp.set_c0(64);                                          <span class="comment">// +64</span></div><div class="line"></div><div class="line">  <span class="comment">// solve the program, using ET as the exact type</span></div><div class="line">  Solution s = <a class="code" href="group__PkgQPSolverFunctions.html#gac769fb5f56983e35bec295b26501df7f">CGAL::solve_quadratic_program</a>(qp, ET());</div><div class="line">  assert (s.solves_quadratic_program(qp));</div><div class="line"></div><div class="line">  <span class="comment">// output solution</span></div><div class="line">  std::cout &lt;&lt; s; </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Asuming that <code>GMP</code> is installed, the output of the of the above program is: </p><pre class="fragment">status: OPTIMAL
objective value: 8/1
variable values:
0: 2/1
1: 3/1
</pre><p> If <code>GMP</code> is not installed, the values are of course the same, but numerator and denominator might have a common divisor that is not factored out.</p>
<h2><a class="anchor" id="QP_solverConstructingaProgramfromaStream"></a>
Constructing a Program from a Stream</h2>
<p>Here, the program data must be available in <code><a class="el" href="classMPSFormat.html" title="MPS is a commonly used file format for storing linear and quadratic programs according to the concept...">MPSFormat</a></code> (the <code><a class="el" href="classMPSFormat.html" title="MPS is a commonly used file format for storing linear and quadratic programs according to the concept...">MPSFormat</a></code> page shows how our running example looks like in this format, and it briefly explains the format). Assuming that your working directory contains the file <code>first_qp.mps</code>, the following program will read and solve it, with the same output as before.</p>
<p><br />
<b>File</b> <a class="el" href="QP_solver_2first_qp_from_mps_8cpp-example.html">QP_solver/first_qp_from_mps.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// example: read quadratic program in MPS format from file </span></div><div class="line"><span class="comment">// the QP below is the first quadratic program example in the user manual</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_models.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_functions.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// choose exact integral type</span></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_GMP</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpz_8h.html">CGAL/Gmpz.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">CGAL::Gmpz</a> ET;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">CGAL::MP_Float</a> ET;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">// program and solution types</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Quadratic__program__from__mps.html">CGAL::Quadratic_program_from_mps&lt;int&gt;</a> Program;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Quadratic__program__solution.html">CGAL::Quadratic_program_solution&lt;ET&gt;</a> Solution;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::ifstream in (<span class="stringliteral">"first_qp.mps"</span>);</div><div class="line">  Program qp(in);         <span class="comment">// read program from file</span></div><div class="line">  assert (qp.is_valid()); <span class="comment">// we should have a valid mps file</span></div><div class="line"></div><div class="line">  <span class="comment">// solve the program, using ET as the exact type</span></div><div class="line">  Solution s = <a class="code" href="group__PkgQPSolverFunctions.html#gac769fb5f56983e35bec295b26501df7f">CGAL::solve_quadratic_program</a>(qp, ET());</div><div class="line"></div><div class="line">  <span class="comment">// output solution</span></div><div class="line">  std::cout &lt;&lt; s; </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_solverConstructingaProgramfromIterators"></a>
Constructing a Program from Iterators</h2>
<p>The following program again solves our running example from above, with the same output, but this time with iterators over data stored in suitable containers. You can see that we also store zero entries here (in \( D\)). For this toy problem, the previous two approaches (program from data/stream) are clearly preferable, but Section <a class="el" href="index.html#secQPiterators">Working from Iterators</a> shows an example where it makes sense to use the iterator-based approach.</p>
<p><br />
<b>File</b> <a class="el" href="QP_solver_2first_qp_from_iterators_8cpp-example.html">QP_solver/first_qp_from_iterators.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// example: construct a quadratic program from given iterators</span></div><div class="line"><span class="comment">// the QP below is the first quadratic program example in the user manual</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_models.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_functions.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// choose exact integral type</span></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_GMP</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpz_8h.html">CGAL/Gmpz.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">CGAL::Gmpz</a> ET;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">CGAL::MP_Float</a> ET;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">// program and solution types</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Quadratic__program__from__iterators.html">CGAL::Quadratic_program_from_iterators</a></div><div class="line">&lt;<span class="keywordtype">int</span>**,                                                <span class="comment">// for A</span></div><div class="line"> <span class="keywordtype">int</span>*,                                                 <span class="comment">// for b</span></div><div class="line"> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Const__oneset__iterator.html">CGAL::Const_oneset_iterator&lt;CGAL::Comparison_result&gt;</a>, <span class="comment">// for r</span></div><div class="line"> <span class="keywordtype">bool</span>*,                                                <span class="comment">// for fl</span></div><div class="line"> <span class="keywordtype">int</span>*,                                                 <span class="comment">// for l</span></div><div class="line"> <span class="keywordtype">bool</span>*,                                                <span class="comment">// for fu</span></div><div class="line"> <span class="keywordtype">int</span>*,                                                 <span class="comment">// for u</span></div><div class="line"> <span class="keywordtype">int</span>**,                                                <span class="comment">// for D</span></div><div class="line"> <span class="keywordtype">int</span>*&gt;                                                 <span class="comment">// for c </span></div><div class="line">Program;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Quadratic__program__solution.html">CGAL::Quadratic_program_solution&lt;ET&gt;</a> Solution;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="keywordtype">int</span>  Ax[] = {1, -1};                        <span class="comment">// column for x</span></div><div class="line">  <span class="keywordtype">int</span>  Ay[] = {1,  2};                        <span class="comment">// column for y</span></div><div class="line">  <span class="keywordtype">int</span>*  A[] = {Ax, Ay};                       <span class="comment">// A comes columnwise</span></div><div class="line">  <span class="keywordtype">int</span>   b[] = {7, 4};                         <span class="comment">// right-hand side</span></div><div class="line">  CGAL::Const_oneset_iterator&lt;CGAL::Comparison_result&gt; </div><div class="line">        r(    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b">CGAL::SMALLER</a>);                 <span class="comment">// constraints are "&lt;="</span></div><div class="line">  <span class="keywordtype">bool</span> fl[] = {<span class="keyword">true</span>, <span class="keyword">true</span>};                   <span class="comment">// both x, y are lower-bounded</span></div><div class="line">  <span class="keywordtype">int</span>   l[] = {0, 0};</div><div class="line">  <span class="keywordtype">bool</span> fu[] = {<span class="keyword">false</span>, <span class="keyword">true</span>};                  <span class="comment">// only y is upper-bounded</span></div><div class="line">  <span class="keywordtype">int</span>   u[] = {0, 4};                         <span class="comment">// x's u-entry is ignored</span></div><div class="line">  <span class="keywordtype">int</span>  D1[] = {2};                            <span class="comment">// 2D_{1,1}</span></div><div class="line">  <span class="keywordtype">int</span>  D2[] = {0, 8};                         <span class="comment">// 2D_{2,1}, 2D_{2,2}</span></div><div class="line">  <span class="keywordtype">int</span>*  D[] = {D1, D2};                       <span class="comment">// D-entries on/below diagonal</span></div><div class="line">  <span class="keywordtype">int</span>   c[] = {0, -32};</div><div class="line">  <span class="keywordtype">int</span>  c0   = 64;                             <span class="comment">// constant term</span></div><div class="line"></div><div class="line">  <span class="comment">// now construct the quadratic program; the first two parameters are</span></div><div class="line">  <span class="comment">// the number of variables and the number of constraints (rows of A)</span></div><div class="line">  Program qp (2, 2, A, b, r, fl, l, fu, u, D, c, c0);</div><div class="line"></div><div class="line">  <span class="comment">// solve the program, using ET as the exact type</span></div><div class="line">  Solution s = <a class="code" href="group__PkgQPSolverFunctions.html#gac769fb5f56983e35bec295b26501df7f">CGAL::solve_quadratic_program</a>(qp, ET());</div><div class="line"></div><div class="line">  <span class="comment">// output solution</span></div><div class="line">  std::cout &lt;&lt; s;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><b>Note 1:</b> The example shows an interesting feature of this approach: not all data need to come from containers. Here, the iterator over the vector of relations can be provided through the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Const__oneset__iterator.html">Const_oneset_iterator</a>&lt;T&gt;</code>, since all entries of this vector are equal to <code>SMALLER</code>. The same could have been done with the vector <code>fl</code> for the finiteness of the lower bounds.</p>
<p><b>Note 2:</b> The program type looks a bit scary, with its total of 9 template arguments, one for each iterator type. In Section <a class="el" href="index.html#secQPmakers">Using Makers</a> we show how the explicit construction of this type can be circumvented.</p>
<h1><a class="anchor" id="secQPlp"></a>
Solving Linear and Nonnegative Programs</h1>
<p>Let us reconsider the general form of (QP) from Section <a class="el" href="index.html#secQPdef">Which Programs can be Solved?</a> above. If \( D=0\), the quadratic program is in fact a <em>linear program</em>, and in the case that the bound vectors \( l\) is the zero vector and all entries of \( u\) are \( \infty\), the program is said to be <em>nonnegative</em>. The package offers dedicated models and solution methods for these special cases.</p>
<p>From an interface perspective, this is just syntactic sugar: in the model <code><a class="el" href="classCGAL_1_1Quadratic__program.html" title=" ">Quadratic_program</a>&lt;NT&gt;</code>, we can easily set the default bounds so that a nonnegative program results, and a linear program is obtained by simply not inserting any \( D\)-entries. Even in the iterator-based approach (see <a class="el" href="QP_solver_2first_qp_from_iterators_8cpp-example.html">QP_solver/first_qp_from_iterators.cpp</a>), linear and nonnegative programs can easily be defined through suitable <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Const__oneset__iterator.html">Const_oneset_iterator</a>&lt;T&gt;</code>-style iterators.</p>
<p>The main reason for having dedicated solution methods for linear and nonnegative programs is efficiency: if the solver knows that the program is linear, it can save some computations compared to the general solver that unknowingly has to fiddle around with a zero \( D\)-matrix. As in Section <a class="el" href="index.html#secQProbustness">Robustness</a> above, we can argue that checking in advance whether \( D=0\) is not an option in general, since this may require \( \Omega(n^2)\) time on the dense interface.</p>
<p>Similarly, if the solver knows that the program is nonnegative, it will be more efficient than under the general bounds \( \qpl\leq \qpx \leq \qpu\). You can argue that nonnegativity <em>is</em> something that could easily be checked in time \( O(n)\) beforehand, but then again nonnegative programs are so frequent that the syntactic sugar aspect becomes somewhat important. After all, we can save four iterators in specifying a nonnegative linear program in terms of the concept <code><a class="el" href="classNonnegativeLinearProgram.html" title="A model of NonnegativeLinearProgram describes a linear program of the form. ">NonnegativeLinearProgram</a></code> rather than <code><a class="el" href="classLinearProgram.html" title="A model of LinearProgram describes a linear program of the form. ">LinearProgram</a></code>.</p>
<p>Often, there are no bounds at all for the variables, i.e., all entries of \( \qpl\) are \( -\infty\), and all entries of \( \qpu\) are \( \infty\) (this is called a <em>free</em> program). There is no dedicated solution method for this case (a free quadratic or linear program is treated like a general quadratic or linear program), but all predefined models make it easy to specify all sorts of default bounds, covering the free case.</p>
<h2><a class="anchor" id="QP_solverTheLinearProgrammingSolver"></a>
The Linear Programming Solver</h2>
<p>Let's go back to our first quadratic program from above and change it into a linear program by simply removing the quadratic part of the objective function:</p>
<p class="formulaDsp">
\[ \begin{array}{lrcl} \mbox{minimize} &amp; - 32y + 64 \\ \mbox{subject to} &amp; x + y &amp;\leq&amp; 7 \\ &amp; -x + 2y &amp;\leq&amp; 4 \\ &amp; x &amp;\geq&amp; 0 \\ &amp; y &amp;\geq&amp; 0 \\ &amp; y &amp;\leq&amp; 4 \end{array} \]
</p>
<p><a class="el" href="index.html#fig__figQPfirst_lp">Figure 7.2</a> shows how this looks like. We will not visualize a linear objective function with contour lines but with arrows instead. The arrow represents the (direction) of the vector \( -c\), and we are looking for a feasible solution that is "extreme" in the direction of the arrow. In our small example, this is the unique point "on" the two constraints \( x_1+x_2\leq 7\) and \( -x_1+x_2\leq 4\), the point \( (10/3,11/3)\) marked with a black dot. The optimal objective function value is \( -32(11/3)+64=-160/3\).</p>
<p><a class="anchor" id="fig__figQPfirst_lp"></a></p><div class="image">
<img src="first_lp.png" alt="first_lp.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figQPfirst_lp">Figure 7.2</a> A linear program in two variables  </div>  <br />

<p>Here is <span style="font-variant: small-caps;">CGAL</span> code for solving it, using the dedicated LP solver, and according to the three ways for constructing a program that we have already discussed in Section <a class="el" href="index.html#secQPfirst">How to Enter and Solve a Program</a>.</p>
<p><a class="el" href="QP_solver_2first_lp_8cpp-example.html">QP_solver/first_lp.cpp</a></p>
<p><a class="el" href="QP_solver_2first_lp_from_mps_8cpp-example.html">QP_solver/first_lp_from_mps.cpp</a></p>
<p><a class="el" href="QP_solver_2first_lp_from_iterators_8cpp-example.html">QP_solver/first_lp_from_iterators.cpp</a></p>
<p>In all cases, the output is </p><pre class="fragment">status: OPTIMAL
objective value: -160/3
variable values:
0: 10/3
1: 11/3
</pre><h2><a class="anchor" id="QP_solverTheNonnegativeQuadraticProgramming"></a>
The Nonnegative Quadratic Programming Solver</h2>
<p>If we go back to our first quadratic program and remove the constraint \( y\leq 4\), we arrive at a nonnegative quadratic program:</p>
<p class="formulaDsp">
\[ \begin{array}{lrcl} \mbox{minimize} &amp; x^2 + 4(y-4)^2 &amp;(=&amp; x^2 + 4y^2 - 32y + 64) \\ \mbox{subject to} &amp; x + y &amp;\leq&amp; 7 \\ &amp; -x + 2y &amp;\leq&amp; 4 \\ &amp; x,y &amp;\geq&amp; 0 \end{array} \]
</p>
<p><a class="el" href="index.html#fig__figQPfirst_nonnegative_qp">Figure 7.3</a> contains the illustration; since the constraint \( y\leq 4\) was redundant, the feasible region and the optimal solution do not change.</p>
<p><a class="anchor" id="fig__figQPfirst_nonnegative_qp"></a></p><div class="image">
<img src="first_nonnegative_qp.png" alt="first_nonnegative_qp.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figQPfirst_nonnegative_qp">Figure 7.3</a> A nonnegative quadratic program in two variables  </div>  <br />

<p>The following programs (using the dedicated solver for nonnegative quadratic programs) will therefore again output </p><pre class="fragment">status: OPTIMAL
objective value: 8/1
variable values:
0: 2/1
1: 3/1
</pre><p><a class="el" href="QP_solver_2first_nonnegative_qp_8cpp-example.html">QP_solver/first_nonnegative_qp.cpp</a></p>
<p><a class="el" href="QP_solver_2first_nonnegative_qp_from_mps_8cpp-example.html">QP_solver/first_nonnegative_qp_from_mps.cpp</a></p>
<p><a class="el" href="QP_solver_2first_nonnegative_qp_from_iterators_8cpp-example.html">QP_solver/first_nonnegative_qp_from_iterators.cpp</a></p>
<h2><a class="anchor" id="QP_solverTheNonnegativeLinearProgramming"></a>
The Nonnegative Linear Programming Solver</h2>
<p>Finally, a dedicated model and function is available for nonnnegative linear programs as well. Let's take our linear program from above and remove the constraint \( y\leq 4\) to obtain a nonnegative linear program. At the same time we remove the constant objective function term to get a "minimal" input and a "shortest" program; the optimal value is \( -32(11/3)=-352/3\).</p>
<p class="formulaDsp">
\[ \begin{array}{lrcl} \mbox{minimize} &amp; - 32y \\ \mbox{subject to} &amp; x + y &amp;\leq&amp; 7 \\ &amp; -x + 2y &amp;\leq&amp; 4 \\ &amp; x,y &amp;\geq&amp; 0 \\ \end{array} \]
</p>
<p>This can be solved by any of the following three programs</p>
<p><a class="el" href="QP_solver_2first_nonnegative_lp_8cpp-example.html">QP_solver/first_nonnegative_lp.cpp</a></p>
<p><a class="el" href="QP_solver_2first_nonnegative_lp_from_mps_8cpp-example.html">QP_solver/first_nonnegative_lp_from_mps.cpp</a></p>
<p><a class="el" href="QP_solver_2first_nonnegative_lp_from_iterators_8cpp-example.html">QP_solver/first_nonnegative_lp_from_iterators.cpp</a></p>
<p>The output will always be </p><pre class="fragment">status: OPTIMAL
objective value: -352/3
variable values:
0: 10/3
1: 11/3
</pre><h1><a class="anchor" id="secQPiterators"></a>
Working from Iterators</h1>
<p>Here we present a somewhat more advanced example that emphasizes the usefulness of solving linear and quadratic programs from iterators. Let's look at a situation in which a linear program is given implicitly, and access to it is gained through properly constructed iterators.</p>
<p>The problem we are going to solve is the following: given points \( p_1,\ldots p_{n}\) in \( d\)-dimensional space and another point \( p\): is \( p\) in the convex hull of \( \{p_1,\ldots,p_{n}\}\)? In formulas, this is the case if and only if there are real coefficients \( \lambda_1,\ldots,\lambda_n\) such that \( p\) is a convex combination of \( p_1,\ldots,p_n\): \( p = \ccSum{j=1}{n}{~\lambda_j~p_j}, \quad \ccSum{j=1}{n}{~\lambda_j} = 1, \quad \lambda_j \geq 0 \mbox{~for all $j$.} \)</p>
<p>The problem of testing the existence of such \( \lambda_j\) can be expressed as a linear program. It becomes particularly easy when we use the homogeneous representations of the points: if \( q_1,\ldots,q_n,q\in\mathbb{R}^{d+1}\) are homogeneous coordinates for \( p_1,\ldots,p_n,p\) with positive homogenizing coordinates \( h_1,\ldots,h_n,h\), we have </p><p class="formulaDsp">
\[$q_j = h_j \cdot (p_j \mid 1) \mbox{~for all $j$, and~} q = h \cdot (p\mid 1).\]
</p>
<p> Now, nonnegative \(\lambda_1,\ldots,\lambda_n\) are suitable coefficients for a convex combination if and only if </p><p class="formulaDsp">
\[\ccSum{j=1}{n}{~ \lambda_j(p_j \mid 1)} = (p\mid 1), \]
</p>
<p> equivalently, if there are \(\mu_1,\ldots,\mu_n\) (with \(\mu_j = \lambda_j \cdot h/{h_j}\) for all \(j\)) such that </p><p class="formulaDsp">
\[\ccSum{j=1}{n}{~\mu_j~q_j} = q, \quad \mu_j \geq 0\mbox{~for all $j$}.\]
</p>
<p>The linear program now tests for the existence of nonnegative \( \mu_j\) that satisfy the latter equation. Below is the code; it defines a function that solves the linear program, given \( p\) and \( p_1,\ldots,p_n\) (through an iterator range). The only (mild) trickery involved is the construction of the nested iterator through a fixed column of the constraint matrix \( A\). We get this from transforming the iterator through the points using a functor that maps a point to an iterator through its homogeneous coordinates.</p>
<p><br />
<b>File</b> <a class="el" href="QP_solver_2solve_convex_hull_containment_lp_8h-example.html">QP_solver/solve_convex_hull_containment_lp.h</a> </p><div class="fragment"><div class="line"><span class="comment">// example: function to check whether a point is in the convex </span></div><div class="line"><span class="comment">// hull of other points</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_models.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_functions.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// unary function to get homogeneous begin-iterator of point</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Po<span class="keywordtype">int</span>_d&gt;</div><div class="line"><span class="keyword">struct </span>Homogeneous_begin  {</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Point_d::Homogeneous_const_iterator result_type;</div><div class="line">  result_type operator() (<span class="keyword">const</span> Point_d&amp; p)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> p.homogeneous_begin();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// function to solve the LP that tests whether a point is in the</span></div><div class="line"><span class="comment">// convex hull of other points; the type ET is an exact type used</span></div><div class="line"><span class="comment">// for the internal computations</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Po<span class="keywordtype">int</span>_d, <span class="keyword">class</span> RandomAccessIterator, <span class="keyword">class</span> ET&gt;</div><div class="line"><a class="code" href="classCGAL_1_1Quadratic__program__solution.html">CGAL::Quadratic_program_solution&lt;ET&gt;</a></div><div class="line">solve_convex_hull_containment_lp (<span class="keyword">const</span> Point_d&amp; p,</div><div class="line">                  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a> begin,</div><div class="line">                  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a> end, <span class="keyword">const</span> ET&amp; dummy)</div><div class="line">{</div><div class="line">  <span class="comment">// Constraint matrix type: A[j][i] is the i-th homogeneous coordinate of p_j</span></div><div class="line">  <span class="keyword">typedef</span> boost::transform_iterator</div><div class="line">    &lt;Homogeneous_begin&lt;Point_d&gt;, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a>&gt; A_it;</div><div class="line">  <span class="comment">// Right-hand side type: b[i] is the i-th homogeneous coordinate of p</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Point_d::Homogeneous_const_iterator B_it;</div><div class="line">  <span class="comment">// Relation type ("=")</span></div><div class="line">  <span class="keyword">typedef</span> CGAL::Const_oneset_iterator&lt;CGAL::Comparison_result&gt; R_it;</div><div class="line">  <span class="comment">// input number type</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits&lt;Point_d&gt;::Kernel::RT</a> RT;</div><div class="line">  <span class="comment">// Linear objective function type (c=0: we only test feasibility)</span></div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Const__oneset__iterator.html">CGAL::Const_oneset_iterator&lt;RT&gt;</a> C_it;</div><div class="line">  <span class="comment">// the nonnegative linear program type</span></div><div class="line">  <span class="keyword">typedef</span></div><div class="line">    <a class="code" href="classCGAL_1_1Nonnegative__linear__program__from__iterators.html">CGAL::Nonnegative_linear_program_from_iterators&lt;A_it, B_it, R_it, C_it&gt;</a></div><div class="line">    Program;</div><div class="line"></div><div class="line">  <span class="comment">// ok, we are prepared now: construct program and solve it</span></div><div class="line">  Program lp (static_cast&lt;int&gt;(end-begin), <span class="comment">// number of variables</span></div><div class="line">          p.dimension()+1,             <span class="comment">// number of constraints</span></div><div class="line">          A_it (begin), B_it (p.homogeneous_begin()),</div><div class="line">          R_it (<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078">CGAL::EQUAL</a>), C_it (0));</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__PkgQPSolverFunctions.html#gafb60a136bc34bebcf9387266d3e36742">CGAL::solve_nonnegative_linear_program</a> (lp, dummy);</div><div class="line">}</div></div><!-- fragment --><p>To see this in action, let us call it with \( p_1=(0,0), p_2=(10,0), p_3=(0,10)\) fixed (they define a triangle) and all integral points \( p\) in \( [0,10]^2\). We know that \( p\) is in the convex hull of \( \{p_1,p_2,p_3\}\) if and only if its two coordinates sum up to \( 10\) at most. As the exact type, we use <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">MP_Float</a></code> or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpzf.html">Gmpzf</a></code> (which is faster and preferable if <code>GMP</code> is installed).</p>
<p><br />
<b>File</b> <a class="el" href="QP_solver_2convex_hull_containment_8cpp-example.html">QP_solver/convex_hull_containment.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Example: check whether a point is in the convex hull of other points</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include "solve_convex_hull_containment_lp.h"</span></div><div class="line"></div><div class="line"><span class="comment">// choose exact floating-point type</span></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_GMP</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpzf_8h.html">CGAL/Gmpzf.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpzf.html">CGAL::Gmpzf</a> ET;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">CGAL::MP_Float</a> ET;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Cartesian_d&lt;double&gt; Kernel_d;</div><div class="line"><span class="keyword">typedef</span> Kernel_d::Point_d Point_d;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> is_in_convex_hull (<span class="keyword">const</span> Point_d&amp; p,</div><div class="line">            std::vector&lt;Point_d&gt;::const_iterator begin,</div><div class="line">            std::vector&lt;Point_d&gt;::const_iterator end)</div><div class="line">{</div><div class="line">  <a class="code" href="classCGAL_1_1Quadratic__program__solution.html">CGAL::Quadratic_program_solution&lt;ET&gt;</a> s =</div><div class="line">    solve_convex_hull_containment_lp (p, begin, end, ET(0));</div><div class="line">  <span class="keywordflow">return</span> !s.<a class="code" href="classCGAL_1_1Quadratic__program__solution.html#ad0c8cf7f23b0b8b934f38c38f9e51f64">is_infeasible</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::vector&lt;Point_d&gt; points;</div><div class="line">  <span class="comment">// convex hull: simplex spanned by {(0,0), (10,0), (0,10)}</span></div><div class="line">  points.push_back (Point_d ( 0.0,  0.0));</div><div class="line">  points.push_back (Point_d (10.0,  0.0));</div><div class="line">  points.push_back (Point_d ( 0.0, 10.0));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;=10; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;=10; ++j) {</div><div class="line">      <span class="comment">// (i,j) is in the simplex iff i+j &lt;= 10</span></div><div class="line">      <span class="keywordtype">bool</span> contained = is_in_convex_hull</div><div class="line">    (Point_d (i, j), points.begin(), points.end());</div><div class="line">      assert (contained == (i+j&lt;=10));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="secQPmakers"></a>
Using Makers</h2>
<p>You already noticed in the previous example that the actual template arguments for <code><a class="el" href="classCGAL_1_1Nonnegative__linear__program__from__iterators.html" title="An object of class Nonnegative_linear_program_from_iterators describes a linear program of the form...">Nonnegative_linear_program_from_iterators</a>&lt;A_it, B_it, R_it, C_it&gt;</code> can be quite elaborate, and this only gets worse if you plug more iterators into each other. In general, you want to construct a program from given expressions for the iterators, but the types of these expressions are probably very complicated and difficult to look up.</p>
<p>You can avoid the explicit construction of the type <code><a class="el" href="classCGAL_1_1Nonnegative__linear__program__from__iterators.html" title="An object of class Nonnegative_linear_program_from_iterators describes a linear program of the form...">Nonnegative_linear_program_from_iterators</a>&lt;A_it, B_it, R_it, C_it&gt;</code> if you only need an expression of it, e.g. to pass it directly as an argument to the solving function. Here is an alternative version of <code>QP_solver/solve_convex_hull_containment_lp.h</code> that shows how this works. In effect, you get shorter and more readable code.</p>
<p><br />
<b>File</b> <a class="el" href="QP_solver_2solve_convex_hull_containment_lp2_8h-example.html">QP_solver/solve_convex_hull_containment_lp2.h</a> </p><div class="fragment"><div class="line"><span class="comment">// example: function to check whether a point is in the convex </span></div><div class="line"><span class="comment">// hull of other points; this version uses a maker</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/iterator/transform_iterator.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Kernel_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_models.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_functions.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// unary function to get homogeneous begin-iterator of point</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Po<span class="keywordtype">int</span>_d&gt;</div><div class="line"><span class="keyword">struct </span>Homogeneous_begin  {</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Point_d::Homogeneous_const_iterator result_type;</div><div class="line">  result_type operator() (<span class="keyword">const</span> Point_d&amp; p)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> p.homogeneous_begin();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// function to test whether point is in the convex hull of other points;</span></div><div class="line"><span class="comment">// the type ET is an exact type used for the computations</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Po<span class="keywordtype">int</span>_d, <span class="keyword">class</span> RandomAccessIterator, <span class="keyword">class</span> ET&gt;</div><div class="line"><a class="code" href="classCGAL_1_1Quadratic__program__solution.html">CGAL::Quadratic_program_solution&lt;ET&gt;</a></div><div class="line">solve_convex_hull_containment_lp (<span class="keyword">const</span> Point_d&amp; p,</div><div class="line">                  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a> begin,</div><div class="line">                  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a> end, <span class="keyword">const</span> ET&amp; dummy)</div><div class="line">{</div><div class="line">  <span class="comment">// construct program and solve it</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__PkgQPSolverFunctions.html#gafb60a136bc34bebcf9387266d3e36742">CGAL::solve_nonnegative_linear_program</a></div><div class="line">    (<a class="code" href="group__PkgQPSolverFunctions.html#ga8d885b3a94f653869d58ea9ed03a66fa">CGAL::make_nonnegative_linear_program_from_iterators</a></div><div class="line">     (static_cast&lt;int&gt;(end-begin),                                         <span class="comment">// n</span></div><div class="line">      p.dimension()+1,                                                     <span class="comment">// m</span></div><div class="line">      boost::transform_iterator</div><div class="line">      &lt;Homogeneous_begin&lt;Point_d&gt;, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a>&gt;(begin),           <span class="comment">// A</span></div><div class="line">      <span class="keyword">typename</span> Point_d::Homogeneous_const_iterator (p.homogeneous_begin()),<span class="comment">// b</span></div><div class="line">      CGAL::Const_oneset_iterator&lt;CGAL::Comparison_result&gt;(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078">CGAL::EQUAL</a>),   <span class="comment">// ~</span></div><div class="line">      <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Const__oneset__iterator.html">CGAL::Const_oneset_iterator</a></div><div class="line">      &lt;<span class="keyword">typename</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits&lt;Point_d&gt;::Kernel::RT</a>&gt; (0)), dummy);    <span class="comment">// c</span></div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="QP_solverImportant"></a>
Important Variables and Constraints</h1>
<p>If you have a solution \( \qpx^*\) of a linear or quadratic program, the "important" variables are typically the ones that are not on their bounds. In case of a nonnegative program, these are the nonzero variables. Going back to the example of the previous Section <a class="el" href="index.html#secQPiterators">Working from Iterators</a>, we can easily interpret their importance: the nonzero variables correspond to points \( p_j\) that actually contribute to the convex combination that yields \( p\).</p>
<p>The following example shows how we can access the important variables, using the iterators <code>basic_variable_indices_begin()</code> and <code>basic_variable_indices_end()</code>.</p>
<p>We generate a set of points that form a 4-gon in \( [0,4]^2\), and then find the ones that contribute to the convex combinations of all 25 lattice points in \( [0,4]^2\). If the lattice point in question is not in the 4-gon, we simply output this fact.</p>
<p><br />
<b>File</b> <a class="el" href="QP_solver_2important_variables_8cpp-example.html">QP_solver/important_variables.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Example: find the points that contribute to a convex combination</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include "solve_convex_hull_containment_lp2.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Cartesian_d&lt;double&gt; Kernel_d;</div><div class="line"><span class="keyword">typedef</span> Kernel_d::Point_d Point_d;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Quadratic__program__solution.html">CGAL::Quadratic_program_solution&lt;CGAL::MP_Float&gt;</a> Solution;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::vector&lt;Point_d&gt; points;</div><div class="line">  <span class="comment">// convex hull: 4-gon spanned by {(1,0), (4,1), (4,4), (2,3)}</span></div><div class="line">  points.push_back (Point_d (1, 0)); <span class="comment">// point 0</span></div><div class="line">  points.push_back (Point_d (4, 1)); <span class="comment">// point 1</span></div><div class="line">  points.push_back (Point_d (4, 4)); <span class="comment">// point 2</span></div><div class="line">  points.push_back (Point_d (2, 3)); <span class="comment">// point 3</span></div><div class="line"> </div><div class="line">  <span class="comment">// test all 25 integer points in [0,4]^2</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;=4; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;=4; ++j) {</div><div class="line">      Point_d p (i, j);</div><div class="line">      Solution s = solve_convex_hull_containment_lp</div><div class="line">    (p, points.begin(), points.end(), <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">CGAL::MP_Float</a>());</div><div class="line">      std::cout &lt;&lt; p;</div><div class="line">      <span class="keywordflow">if</span> (s.is_infeasible())</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" is not in the convex hull\n"</span>;</div><div class="line">      <span class="keywordflow">else</span> {</div><div class="line">    assert (s.is_optimal());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" is a convex combination of the points "</span>;</div><div class="line">    Solution::Index_iterator it = s.<a class="code" href="classCGAL_1_1Quadratic__program__solution.html#a8c32bda4450f86d163e0dc2569d36c4a">basic_variable_indices_begin</a>();</div><div class="line">    Solution::Index_iterator end = s.basic_variable_indices_end();</div><div class="line">    <span class="keywordflow">for</span> (; it != end; ++it) std::cout &lt;&lt; *it &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>It turns out that exactly three of the four points contribute to any convex combination, even through there are lattice points that lie in the convex hull of less than three of the points. This shows that the set of basic variables that we access in the example does not necessarily coincide with the set of important variables as defined above. In fact, it is only guaranteed that a non-basic variable attains one of its bounds, but there might be basic variables that also have this property. In linear and quadratic programming terms, such a situation is called a <em>degeneracy</em>.</p>
<p>There is also the concept of an important constraint: this is typically a constraint in the system \( A\qpx\qprel\qpb\) that is satisfied with equality at \( \qpx^*\). Program <a class="el" href="QP_solver_2first_qp_basic_constraints_8cpp-example.html">QP_solver/first_qp_basic_constraints.cpp</a> shows how these can be accessed, using the iterators <code>basic_constraint_indices_begin()</code> and <code>basic_constraint_indices_end()</code>.</p>
<p>Again, we have a disagreement between "basic" and "important": it is guaranteed that all basic constraints are satisfied with equality at \( \qpx^*\), but there might be non-basic constraints that are satisfied with equality as well.</p>
<h1><a class="anchor" id="secQPcertificates"></a>
Solution Certificates</h1>
<p>Suppose the solver tells you that the problem you have entered is infeasible. Why should you believe this? Similarly, you can quite easily verify that a claimed optimal solution is feasible, but why is there no better one?</p>
<p>Certificates are proofs that the solver can give you in order to convince you that what it claims is indeed true. The archetype of such a proof is <em>Farkas Lemma</em> <a class="el" href="citelist.html#CITEREF_cgal:mg-uulp-06">[1]</a>.</p>
<p><b>Farkas Lemma:</b> <em>Either</em> the inequality system </p><p class="formulaDsp">
\[ \begin{array}{rcl} A \qpx &amp; \leq &amp; \qpb \\ \qpx &amp; \geq &amp; 0 \end{array} \]
</p>
<p> has a solution \( \qpx^*\), <em>or</em> there exists a vector \( \qpy\) such that </p><p class="formulaDsp">
\[ \begin{array}{rcl} \qpy &amp;\geq&amp; 0\\ \qpy^TA &amp;\geq&amp; 0\\ \qpy^T\qpb &amp; &lt; &amp; 0, \end{array} \]
</p>
<p> but not both.</p>
<p>Thus, if someone wants to convince you that the first system in the Farkas Lemma is infeasible, that person can simply give you a vector \( \qpy\) that solves the second system. Since you can easily verify yourself that the \( \qpy\) you got satisfies this second system, you now have a certificate for the infeasibility of the first system, assuming that you believe in Farkas Lemma.</p>
<p>Here we show how the solver can convince you. We first set up an infeasible linear program with constraints of the type \( A\qpx\leq \qpb, \qpx\geq 0\); then we solve it and ask for a certificate. Finally, we verify the certificate by simply checking the inequalities of the second system in Farkas Lemma.</p>
<p><br />
<b>File</b> <a class="el" href="QP_solver_2infeasibility_certificate_8cpp-example.html">QP_solver/infeasibility_certificate.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// example: extracting and verifying a proof of infeasibility from the solution</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_models.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_functions.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// choose exact integral type</span></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_GMP</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpz_8h.html">CGAL/Gmpz.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">CGAL::Gmpz</a> ET;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">CGAL::MP_Float</a> ET;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">// program and solution types</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nonnegative__linear__program__from__iterators.html">CGAL::Nonnegative_linear_program_from_iterators</a></div><div class="line">&lt;<span class="keywordtype">int</span>**,                                                <span class="comment">// for A</span></div><div class="line"> <span class="keywordtype">int</span>*,                                                 <span class="comment">// for b</span></div><div class="line"> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga84351c7e66be00efccd4ab1a61070469">CGAL::Comparison_result</a>*,                             <span class="comment">// for r</span></div><div class="line"> <span class="keywordtype">int</span>*&gt;                                                 <span class="comment">// for c </span></div><div class="line">Program;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Quadratic__program__solution.html">CGAL::Quadratic_program_solution&lt;ET&gt;</a> Solution;</div><div class="line"></div><div class="line"><span class="comment">// we demonstrate Farkas Lemma: either the system </span></div><div class="line"><span class="comment">//     A x &lt;= b</span></div><div class="line"><span class="comment">//       x &gt;= 0</span></div><div class="line"><span class="comment">// has a solution, or there exists y such that</span></div><div class="line"><span class="comment">//       y &gt;= 0 </span></div><div class="line"><span class="comment">//    y^TA &gt;= 0 </span></div><div class="line"><span class="comment">//    y^Tb &lt;  0</span></div><div class="line"><span class="comment">// In the following instance, the first system has no solution,</span></div><div class="line"><span class="comment">// since adding up the two inequalities gives x_2 &lt;= -1:</span></div><div class="line"><span class="comment">//     x_1 - 2x_2  &lt;=  1</span></div><div class="line"><span class="comment">//    -x_1 + 3x_2  &lt;= -2</span></div><div class="line"><span class="comment">//     x_1,   x_2  &gt;=  0</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="keywordtype">int</span>  Ax1[] = { 1, -1};                        <span class="comment">// column for x1</span></div><div class="line">  <span class="keywordtype">int</span>  Ax2[] = {-2,  3};                        <span class="comment">// column for x2</span></div><div class="line">  <span class="keywordtype">int</span>*   A[] = {Ax1, Ax2};                      <span class="comment">// A comes columnwise</span></div><div class="line">  <span class="keywordtype">int</span>    b[] = {1, -2};                         <span class="comment">// right-hand side</span></div><div class="line">  CGAL::Comparison_result </div><div class="line">    r[] = {<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b">CGAL::SMALLER</a>, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b">CGAL::SMALLER</a>};      <span class="comment">// constraints are "&lt;="</span></div><div class="line">  <span class="keywordtype">int</span>    c[] = {0, 0};                         <span class="comment">// zero objective function</span></div><div class="line"></div><div class="line">  <span class="comment">// now construct the linear program; the first two parameters are</span></div><div class="line">  <span class="comment">// the number of variables and the number of constraints (rows of A)</span></div><div class="line">  Program lp (2, 2, A, b, r, c);</div><div class="line"></div><div class="line">  <span class="comment">// solve the program, using ET as the exact type</span></div><div class="line">  Solution s = <a class="code" href="group__PkgQPSolverFunctions.html#gafb60a136bc34bebcf9387266d3e36742">CGAL::solve_nonnegative_linear_program</a>(lp, ET());</div><div class="line"></div><div class="line">  <span class="comment">// get certificate for infeasibility</span></div><div class="line">  assert (s.is_infeasible());</div><div class="line">  Solution::Infeasibility_certificate_iterator y = </div><div class="line">    s.infeasibility_certificate_begin();</div><div class="line">  <span class="comment">// check y &gt;= 0</span></div><div class="line">  assert (ET(y[0]) &gt;= 0);</div><div class="line">  assert (ET(y[1]) &gt;= 0);</div><div class="line">  <span class="comment">// check y^T A &gt;= 0</span></div><div class="line">  assert (ET(y[0]) * A[0][0] + ET(y[1]) * A[0][1] &gt;= 0);</div><div class="line">  assert (ET(y[0]) * A[1][0] + ET(y[1]) * A[1][1] &gt;= 0);</div><div class="line">  <span class="comment">// check y^T b &lt; 0</span></div><div class="line">  assert (ET(y[0]) * b[0] + ET(y[1]) * b[1] &lt; 0);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>There are similar certificates for optimality and unboundedness that you can see in action in the programs <a class="el" href="QP_solver_2optimality_certificate_8cpp-example.html">QP_solver/optimality_certificate.cpp</a> and <a class="el" href="QP_solver_2unboundedness_certificate_8cpp-example.html">QP_solver/unboundedness_certificate.cpp</a>. The underlying variants of Farkas Lemma are somewhat more complicated, due to the mixed relations in \( \qprel\) and the general bounds. The certificate section of <code><a class="el" href="classCGAL_1_1Quadratic__program__solution.html" title="An object of class Quadratic_program_solution represents the solution of a linear or convex quadratic...">Quadratic_program_solution</a>&lt;ET&gt;</code> gives the full picture and mathematically proves the correctness of the certificates.</p>
<h1><a class="anchor" id="secQPcustomization"></a>
Customizing the Solver</h1>
<p>Sometimes it is necessary to alter the default behavior of the solver. This can be done by passing a suitably prepared object of the class <code><a class="el" href="classCGAL_1_1Quadratic__program__options.html" title="This is a class used for passing options to the linear and quadratic programming solvers. ">Quadratic_program_options</a></code> to the solution functions. Most options concern "soft" issues like verbosity, but there are two notable case where it is of critical importance to be able to change the defaults.</p>
<h2><a class="anchor" id="secQPcustomizationfiltering"></a>
Exponent Overflow in Double Using Floating-Point Filters</h2>
<p>The filtered version of the solver that is used for some problems by default on input type <code>double</code> internally constructs double-approximations of exact multiprecision values. If these exact values are extremely large, this may lead to <em>infinite</em> <code>double</code> values and incorrect results. In debug mode, the solver will notice this through a certificate cross-check in the end (or even earlier). In this case, it is advisable to explicitly switch to a non-filtered <em>pricing strategy</em>, see <a class="el" href="group__PkgQPSolverFunctions.html#ga5e4c5717fab328c4e94c3d58e1bd4517"><code>Quadratic_program_pricing_strategy</code></a>.</p>
<p><b>Hint:</b> If you have a program where the number of variables \( n\) and the number of constraints \( m\) have the same order of magnitude, the filtering will usually have no dramatic effect on the performance, so in that case you might as well switch to <code>QP_PARTIAL_DANTZIG</code> to be safe from the issue described here (see <a class="el" href="QP_solver_2cycling_8cpp-example.html">QP_solver/cycling.cpp</a> for an example that shows how to change the pricing strategy).</p>
<h2><a class="anchor" id="secQPcustomizationcycling"></a>
The Solver Internally Cycles</h2>
<p>Consider the following program. It reads a nonnegative linear program from the file <code>cycling.mps</code> (which is in the example directory as well), and then solves it in verbose mode, using <em>Bland's rule</em>, see <a class="el" href="group__PkgQPSolverFunctions.html#ga5e4c5717fab328c4e94c3d58e1bd4517"><code>Quadratic_program_pricing_strategy</code></a>. <br />
<b>File</b> <a class="el" href="QP_solver_2cycling_8cpp-example.html">QP_solver/cycling.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// example: solve a linear program that by default leads to cycling,</span></div><div class="line"><span class="comment">// using Bland pricing</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_models.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_functions.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// choose exact floating-point type</span></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_GMP</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpzf_8h.html">CGAL/Gmpzf.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpzf.html">CGAL::Gmpzf</a> ET;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">CGAL::MP_Float</a> ET;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">// program and solution types</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Quadratic__program__from__mps.html">CGAL::Quadratic_program_from_mps&lt;double&gt;</a> Program;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Quadratic__program__solution.html">CGAL::Quadratic_program_solution&lt;ET&gt;</a> Solution;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::ifstream in (<span class="stringliteral">"cycling.mps"</span>);</div><div class="line">  Program lp(in);         <span class="comment">// read program from file</span></div><div class="line">  assert (lp.is_valid()); <span class="comment">// we should have a valid mps file...</span></div><div class="line">  assert (lp.is_linear());      <span class="comment">// ... and it should be linear...</span></div><div class="line">  assert (lp.is_nonnegative()); <span class="comment">// as well as nonnegative</span></div><div class="line"></div><div class="line">  <span class="comment">// solve the program, using ET as the exact type</span></div><div class="line">  <span class="comment">// choose verbose mode and Bland pricing</span></div><div class="line">  <a class="code" href="classCGAL_1_1Quadratic__program__options.html">CGAL::Quadratic_program_options</a> options;</div><div class="line">  options.<a class="code" href="classCGAL_1_1Quadratic__program__options.html#a0a0ecc2ed94545489855edf860e2aa66">set_verbosity</a>(1);                         <span class="comment">// verbose mode </span></div><div class="line">  options.set_pricing_strategy(<a class="code" href="group__PkgQPSolverFunctions.html#gga5e4c5717fab328c4e94c3d58e1bd4517a1f12b7a8fb6bdc5391069b0aaac81d31">CGAL::QP_BLAND</a>);     <span class="comment">// Bland's rule</span></div><div class="line">  options.set_auto_validation(<span class="keyword">true</span>);                <span class="comment">// automatic self-check</span></div><div class="line">  Solution s = <a class="code" href="group__PkgQPSolverFunctions.html#gafb60a136bc34bebcf9387266d3e36742">CGAL::solve_nonnegative_linear_program</a>(lp, ET(), options);</div><div class="line">  assert (s.is_valid());                     <span class="comment">// did the self-check succeed?</span></div><div class="line"></div><div class="line">  <span class="comment">// output solution</span></div><div class="line">  std::cout &lt;&lt; s;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>If you comment the line</p>
<pre class="fragment">options.set_pricing_strategy(CGAL::QP_BLAND); // Bland's rule
</pre><p>you will see that the solver cycles: the verbose mode outputs the same sequence of six iterations over and over again. By switching to <code>QP_BLAND</code>, the solution process typically slows down a bit (it may also speed up in some cases), but now it is guaranteed that no cycling occurs.</p>
<p>In general, the verbose mode can be of use when you are not sure whether the solver "has died", or whether it simply takes very long to solve your problem. We refer to the class <code><a class="el" href="classCGAL_1_1Quadratic__program__options.html" title="This is a class used for passing options to the linear and quadratic programming solvers. ">Quadratic_program_options</a></code> for further details.</p>
<h1><a class="anchor" id="secQPbenchmark"></a>
Some Benchmarks for Convex Hull Containment</h1>
<p>Here we want to show what you can expect from the solver's performance in a specific application; we don't know whether this application is typical in your case, and we make no claims whatsoever about the performance in other applications.</p>
<p>Still, the example shows that the performance can be dramatically affected by switching between pricing strategies, and we give some hints on how to achieve good performance in general.</p>
<p>The application is the one already discussed in Section <a class="el" href="index.html#secQPiterators">Working from Iterators</a> above: testing whether a point is in the convex hull of other points. To be able to switch between pricing strategies, we add another parameter of type <code><a class="el" href="classCGAL_1_1Quadratic__program__options.html" title="This is a class used for passing options to the linear and quadratic programming solvers. ">Quadratic_program_options</a></code> to the function <code>solve_convex_hull_containment_lp</code> that we pass on to the solution function:</p>
<p><br />
<b>File</b> <a class="el" href="QP_solver_2solve_convex_hull_containment_lp3_8h-example.html">QP_solver/solve_convex_hull_containment_lp3.h</a> </p><div class="fragment"><div class="line"><span class="comment">// example: function to check whether a point is in the convex </span></div><div class="line"><span class="comment">// hull of other points; this version uses a maker</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/iterator/transform_iterator.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Kernel_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_options.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_models.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/QP_functions.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// unary function to get homogeneous begin-iterator of point</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Po<span class="keywordtype">int</span>_d&gt;</div><div class="line"><span class="keyword">struct </span>Homogeneous_begin  {</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Point_d::Homogeneous_const_iterator result_type;</div><div class="line">  result_type operator() (<span class="keyword">const</span> Point_d&amp; p)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> p.homogeneous_begin();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// function to test whether point is in the convex hull of other points;</span></div><div class="line"><span class="comment">// the type ET is an exact type used for the computations</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Po<span class="keywordtype">int</span>_d, <span class="keyword">class</span> RandomAccessIterator, <span class="keyword">class</span> ET&gt;</div><div class="line"><a class="code" href="classCGAL_1_1Quadratic__program__solution.html">CGAL::Quadratic_program_solution&lt;ET&gt;</a></div><div class="line">solve_convex_hull_containment_lp (<span class="keyword">const</span> Point_d&amp; p,</div><div class="line">                  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a> begin,</div><div class="line">                  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a> end, <span class="keyword">const</span> ET&amp; dummy,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classCGAL_1_1Quadratic__program__options.html">CGAL::Quadratic_program_options</a>&amp; o)</div><div class="line">{</div><div class="line">  <span class="comment">// construct program and solve it</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__PkgQPSolverFunctions.html#gafb60a136bc34bebcf9387266d3e36742">CGAL::solve_nonnegative_linear_program</a></div><div class="line">    (<a class="code" href="group__PkgQPSolverFunctions.html#ga8d885b3a94f653869d58ea9ed03a66fa">CGAL::make_nonnegative_linear_program_from_iterators</a></div><div class="line">     (static_cast&lt;int&gt;(end-begin),                                         <span class="comment">// n</span></div><div class="line">      p.dimension()+1,                                                     <span class="comment">// m</span></div><div class="line">      boost::transform_iterator</div><div class="line">      &lt;Homogeneous_begin&lt;Point_d&gt;, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a>&gt;(begin),           <span class="comment">// A</span></div><div class="line">      <span class="keyword">typename</span> Point_d::Homogeneous_const_iterator (p.homogeneous_begin()),<span class="comment">// b</span></div><div class="line">      CGAL::Const_oneset_iterator&lt;CGAL::Comparison_result&gt;(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078">CGAL::EQUAL</a>),   <span class="comment">// ~</span></div><div class="line">      <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Const__oneset__iterator.html">CGAL::Const_oneset_iterator</a></div><div class="line">      &lt;<span class="keyword">typename</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits&lt;Point_d&gt;::Kernel::RT</a>&gt; (0)),            <span class="comment">// c</span></div><div class="line">      dummy, o);   </div><div class="line">}</div></div><!-- fragment --><p>Now let us test containment of the origin in the convex hull of \( n\) random points in \( [0,1]^d\) (it will most likely not be contained, and it turns out that this is the most expensive case). In the program below, we use \( d=10\) and \( n=100,000\), and we comment on some other combinations of \( n\) and \( d\) below (feel free to experiment with still other values).</p>
<p><br />
<b>File</b> <a class="el" href="QP_solver_2convex_hull_containment_benchmarks_8cpp-example.html">QP_solver/convex_hull_containment_benchmarks.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Example: assess the solver performance under any of the available </span></div><div class="line"><span class="comment">// pricing strategies, in the convex-hull-containment problem</span></div><div class="line"><span class="comment">// NOTE: in order to see meaningful results, compile with -DNDEBUG</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include "solve_convex_hull_containment_lp3.h"</span></div><div class="line"></div><div class="line"><span class="comment">// choose exact floating-point type</span></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_GMP</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpzf_8h.html">CGAL/Gmpzf.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpzf.html">CGAL::Gmpzf</a> ET;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">CGAL::MP_Float</a> ET;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Cartesian_d&lt;double&gt; Kernel_d;</div><div class="line"><span class="keyword">typedef</span> Kernel_d::Point_d Point_d;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> d = 10;       <span class="comment">// change this in order to experiment</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> n = 100000;   <span class="comment">// change this in order to experiment</span></div><div class="line"></div><div class="line">  <span class="comment">// generate n random d-dimensional points in [0,1]^d</span></div><div class="line">  CGAL::Random rd;</div><div class="line">  std::vector&lt;Point_d&gt; points;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j =0; j&lt;n; ++j) {</div><div class="line">    std::vector&lt;double&gt; coords;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) </div><div class="line">      coords.push_back(rd.get_double());</div><div class="line">    points.push_back (Point_d (d, coords.begin(), coords.end()));</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="comment">// benchmark all pricing strategies in turn</span></div><div class="line">  <a class="code" href="group__PkgQPSolverFunctions.html#ga5e4c5717fab328c4e94c3d58e1bd4517">CGAL::Quadratic_program_pricing_strategy</a> strategy[] = {</div><div class="line">    <a class="code" href="group__PkgQPSolverFunctions.html#gga5e4c5717fab328c4e94c3d58e1bd4517a3921451b2d9930928eaf4e64b1028161">CGAL::QP_CHOOSE_DEFAULT</a>,              <span class="comment">// QP_PARTIAL_FILTERED_DANTZIG</span></div><div class="line">    <a class="code" href="group__PkgQPSolverFunctions.html#gga5e4c5717fab328c4e94c3d58e1bd4517acfdcc3c905ef34e4daf8dbe6320a098e">CGAL::QP_DANTZIG</a>,                     <span class="comment">// Dantzig's pivot rule...</span></div><div class="line">    <a class="code" href="group__PkgQPSolverFunctions.html#gga5e4c5717fab328c4e94c3d58e1bd4517a2bde547a8669c3de04f36c35737c95b0">CGAL::QP_PARTIAL_DANTZIG</a>,             <span class="comment">// ... with partial pricing</span></div><div class="line">    <a class="code" href="group__PkgQPSolverFunctions.html#gga5e4c5717fab328c4e94c3d58e1bd4517a1f12b7a8fb6bdc5391069b0aaac81d31">CGAL::QP_BLAND</a>,                       <span class="comment">// Bland's pivot rule</span></div><div class="line">    <a class="code" href="group__PkgQPSolverFunctions.html#gga5e4c5717fab328c4e94c3d58e1bd4517a47f81fc4506c7af2cf76d608d154f998">CGAL::QP_FILTERED_DANTZIG</a>,            <span class="comment">// Dantzig's filtered pivot rule...</span></div><div class="line">    <a class="code" href="group__PkgQPSolverFunctions.html#gga5e4c5717fab328c4e94c3d58e1bd4517a85c10fcd1aa2edd600b04fc85d37574e">CGAL::QP_PARTIAL_FILTERED_DANTZIG</a>     <span class="comment">// ... with partial pricing</span></div><div class="line">  };</div><div class="line">  </div><div class="line">  CGAL::Timer t;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;6; ++i) {</div><div class="line">    <span class="comment">// test strategy i</span></div><div class="line">    <a class="code" href="classCGAL_1_1Quadratic__program__options.html">CGAL::Quadratic_program_options</a> options;</div><div class="line">    options.<a class="code" href="classCGAL_1_1Quadratic__program__options.html#a61bf72e4bd2fb752b4ca7547b1b18fcf">set_pricing_strategy</a> (strategy[i]);</div><div class="line">    t.reset(); t.start();</div><div class="line">    <span class="comment">// is origin in convex hull of the points? (most likely, not)</span></div><div class="line">    solve_convex_hull_containment_lp </div><div class="line">      (Point_d (d, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>), points.begin(), points.end(), </div><div class="line">       ET(0), options);</div><div class="line">    t.stop();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Time (s) = "</span> &lt;&lt; t.time() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>If you compile with the macros <code>NDEBUG</code> or <code>CGAL_QP_NO_ASSERTIONS</code> set (this is essential for good performance!!), you will see runtimes that qualitatively look as follows (on your machine, the actual runtimes will roughly be some fixed multiples of the numbers in the table below, and they might vary with the random choices). The default choice of the pricing strategy in that case is <code>QP_PARTIAL_FILTERED_DANTZIG</code>.</p>
<table class="doxtable">
<tr>
<th>Strategy </th><th>Runtime in seconds  </th></tr>
<tr>
<td><code>QP_CHOOSE_DEFAULT</code> </td><td>0.32 </td></tr>
<tr>
<td><code>QP_DANTZIG</code> </td><td>10.7 </td></tr>
<tr>
<td><code>QP_PARTIAL_DANTZIG</code> </td><td>3.72 </td></tr>
<tr>
<td><code>QP_BLAND</code> </td><td>3.65 </td></tr>
<tr>
<td><code>QP_FILTERED_DANTZIG</code> </td><td>0.43 </td></tr>
<tr>
<td><code>QP_PARTIAL_FILTERED_DANTZIG</code> </td><td>0.32 </td></tr>
</table>
<p>We clearly see the effect of filtering: we gain a factor of ten, roughly, compared to the next best non-filtered variant.</p>
<h2><a class="anchor" id="QP_solverBenchd3"></a>
d=3, n=1,000,000</h2>
<p>The filtering effect is amplified if the points/dimension ratio becomes larger. This is what you might see in dimension three, with one million points.</p>
<table class="doxtable">
<tr>
<th>Strategy </th><th>Runtime in seconds  </th></tr>
<tr>
<td><code>QP_CHOOSE_DEFAULT</code> </td><td>1.34 </td></tr>
<tr>
<td><code>QP_DANTZIG</code> </td><td>47.6 </td></tr>
<tr>
<td><code>QP_PARTIAL_DANTZIG</code> </td><td>15.6 </td></tr>
<tr>
<td><code>QP_BLAND</code> </td><td>16.02 </td></tr>
<tr>
<td><code>QP_FILTERED_DANTZIG</code> </td><td>1.89 </td></tr>
<tr>
<td><code>QP_PARTIAL_FILTERED_DANTZIG</code> </td><td>1.34 </td></tr>
</table>
<p>In general, if your problem has a high variable/constraint or constraint/variable ratio, then filtering will typically pay off. In such cases, it might be beneficial to encode your problem using input type <code>double</code> in order to profit from the filtering (but see the issue discussed in Section <a class="el" href="index.html#secQPcustomizationfiltering">Exponent Overflow in Double Using Floating-Point Filters</a>).</p>
<h2><a class="anchor" id="QP_solverBenchd100"></a>
d=100, n=100,000</h2>
<p>Conversely, the filtering effect deteriorates if the points/dimension ratio becomes smaller.</p>
<table class="doxtable">
<tr>
<th>Strategy </th><th>Runtime in seconds  </th></tr>
<tr>
<td><code>QP_CHOOSE_DEFAULT</code> </td><td>3.05 </td></tr>
<tr>
<td><code>QP_DANTZIG</code> </td><td>78.4 </td></tr>
<tr>
<td><code>QP_PARTIAL_DANTZIG</code> </td><td>45.9 </td></tr>
<tr>
<td><code>QP_BLAND</code> </td><td>33.2 </td></tr>
<tr>
<td><code>QP_FILTERED_DANTZIG</code> </td><td>3.36 </td></tr>
<tr>
<td><code>QP_PARTIAL_FILTERED_DANTZIG</code> </td><td>3.06 </td></tr>
</table>
<h2><a class="anchor" id="QP_solverBenchd500"></a>
d=500, n=1,000</h2>
<p>If the points/dimension ratio tends to a constant, filtering is no longer a clear winner. The reason is that in this case, the necessary exact calculations with multiprecision numbers dominate the overall runtime.</p>
<table class="doxtable">
<tr>
<th>Strategy </th><th>Runtime in seconds  </th></tr>
<tr>
<td><code>QP_CHOOSE_DEFAULT</code> </td><td>2.65 </td></tr>
<tr>
<td><code>QP_DANTZIG</code> </td><td>5.55 </td></tr>
<tr>
<td><code>QP_PARTIAL_DANTZIG</code> </td><td>5.6 </td></tr>
<tr>
<td><code>QP_BLAND</code> </td><td>4.46 </td></tr>
<tr>
<td><code>QP_FILTERED_DANTZIG</code> </td><td>2.65 </td></tr>
<tr>
<td><code>QP_PARTIAL_FILTERED_DANTZIG</code> </td><td>2.61 </td></tr>
</table>
<p>In general, if you have a program where the number of variables and the number of constraints have the same order of magnitude, then the saving gained from using the filtered approach is typically small. In such a situation, you should consider switching to a non-filtered variant in order to avoid the rare issue discussed in Section <a class="el" href="index.html#secQPcustomizationfiltering">Exponent Overflow in Double Using Floating-Point Filters</a> altogether. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:47 for CGAL 4.13 - Linear and Quadratic Programming Solver by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
