<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_3D_Surface_Subdivision_Methods"/><anchor id="index_1chapterSubdivision"/></para><para><simplesect kind="author"><para>Le-Jeng Andy Shiue</para></simplesect>
<image type="html" name="subdivision-teaser.jpg"></image>
</para><sect1 id="index_1sectionSubIntro">
<title>Introduction</title>
<para>Subdivision methods are simple yet powerful ways to generate smooth surfaces from arbitrary polygonal meshes. Unlike spline-based surfaces (e.g NURBS) or other numeric-based modeling techniques, users of subdivision methods do not need the mathematical knowledge of the subdivision methods. The natural intuition of the geometry suffices to control the subdivision methods.</para><para><computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> works for the classes <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput>, as they are models of the concept <computeroutput><ref refid="classMutableFaceGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">MutableFaceGraph</ref></computeroutput>, and it aims to be easy to use and to extend. <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> is not a class, but a namespace which contains four popular subdivision methods and their refinement functions. These include Catmull-Clark, Loop, Doo-Sabin and <formula id="0">$ \sqrt{3}$</formula> subdivisions. Variations of these methods can be easily extended by substituting the geometry computation of the refinement host.</para></sect1>
<sect1 id="index_1secSubAlgo">
<title>Subdivision Method</title>
<para>In this chapter, we explain some fundamentals of subdivision methods. We focus only on the topics that help you understand the design of the package. Details on subdivision methods can be found in <ref refid="citelist_1CITEREF_cgal:ww-smgd-02" kindref="member">[6]</ref>. Some terminology introduced in this section will be used again in later sections. If you are only interested in using a specific subdivision method, Section <ref refid="index_1secFirstSub" kindref="member">A Quick Example: Catmull-Clark Subdivision</ref> gives a quick tutorial on using a Catmull-Clark subdivision.</para><para>A subdivision method recursively refines a coarse mesh and generates an ever closer approximation to a smooth surface. The coarse mesh can have arbitrary shape, but it has to be a 2-manifold. In a 2-manifold, every interior point has a neighborhood homeomorphic to a 2D disk. Subdivision methods on non-manifolds have been developed, but are not considered in <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput>. The chapter teaser shows the steps of Catmull-Clark subdivision on a CAD model. The coarse mesh is repeatedly refined by a quadrisection pattern, and new points are generated to approximate a smooth surface.</para><para>Many refinement patterns are used in practice. <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> supports the four most popular patterns, and each of them is used by Catmull-Clark<ref refid="citelist_1CITEREF_cgal:cc-rgbss-78" kindref="member">[1]</ref>, Loop<ref refid="citelist_1CITEREF_cloop:mthesis" kindref="member">[4]</ref>, Doo-Sabin<ref refid="citelist_1CITEREF_doo1978behaviour" kindref="member">[2]</ref> and <formula id="0">$ \sqrt{3}$</formula> subdivision<ref refid="citelist_1CITEREF_cgal:k-s-00" kindref="member">[3]</ref> (left to right in the figure below). We name these patterns by their topological characteristics instead of the associated subdivision methods. PQQ indicates the <emphasis>P</emphasis>rimal <emphasis>Q</emphasis>uadtrateral <emphasis>Q</emphasis>uadrisection. PTQ indicates the <emphasis>P</emphasis>rimal <emphasis>T</emphasis>riangle <emphasis>Q</emphasis>uadrisection. DQQ indicates the <emphasis>D</emphasis>ual <emphasis>Q</emphasis>uadtrateral <emphasis>Q</emphasis>uadrisection. <formula id="0">$ \sqrt{3}$</formula> indicates the converging speed of the triangulation toward the subdivision surface.</para><para><image type="html" name="RefSchemes.svg"></image>
</para><para>The figure demonstrates these four refinement patterns on the 1-disk of a valence-5 vertex/face. Refined meshes are shown below the source meshes. Points on the refined mesh are generated by averaging neighbor points on the source mesh. A graph, called <emphasis>stencil</emphasis>, determines the source neighborhood whose points contribute to the position of a refined point. A refinement pattern usually defines more than one stencil. For example, the PQQ refinement has a vertex-node stencil, which defines the 1-ring of an input vertex; an edge-node stencil, which defines the 1-ring of an input edge; and a face-node stencil, which defines an input face. The stencils of the PQQ refinement are shown in the following figure. The blue neighborhoods in the top row indicate the corresponding stencils of the refined nodes in red.</para><para><image type="html" name="PQQStencil.svg"></image>
</para><para>Stencils with weights are called <emphasis>geometry masks</emphasis>. A subdivision method defines a geometry mask for each stencil, and generates new points by averaging source points weighted by the mask. Geometry masks are carefully chosen to meet requirements of certain surface smoothness and shape quality. The geometry masks of Catmull-Clark subdivision are shown below.</para><para><image type="html" name="cc_mask.svg"></image>
</para><para>The weights shown here are unnormalized, and <formula id="1">$ n$</formula> is the valence of the vertex. The generated point, in red, is computed by a summation of the weighted points. For example, a Catmull-Clark face-node is computed by the summation of <formula id="2">$ 1/4$</formula> of each point on its stencil.</para><para>A stencil can have an unlimited number of geometry masks. For example, a face-node of PQQ refinement may be computed by the summation of <formula id="3">$ 1/5$</formula> of each stencil node instead of <formula id="2">$ 1/4$</formula>. Although it is legal in <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> to have any kind of geometry mask, the result surfaces may be odd, not smooth, or not even exist. <ref refid="citelist_1CITEREF_cgal:ww-smgd-02" kindref="member">[6]</ref> explains the details on designing masks for a quality subdivision surface.</para></sect1>
<sect1 id="index_1secFirstSub">
<title>A Quick Example: Catmull-Clark Subdivision</title>
<para>Assuming that you are familiar with <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput>, you can integrate <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> into your program without much effort.</para><para><linebreak/>
<bold>File</bold> <ref refid="Subdivision_method_3_2CatmullClark_subdivision_8cpp-example" kindref="compound">Subdivision_method_3/CatmullClark_subdivision.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/graph_traits_Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="subdivision__method__3_8h" kindref="compound">CGAL/subdivision_method_3.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/lexical_cast.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</ref><sp/><sp/><sp/><sp/>PolygonMesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespacestd" kindref="compound">std</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL" kindref="compound">CGAL</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">params<sp/>=<sp/>CGAL::parameters;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Usage:<sp/>CatmullClark_subdivision<sp/>[d]<sp/>[filename_in]<sp/>[filename_out]<sp/>\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>d<sp/>--<sp/>the<sp/>depth<sp/>of<sp/>the<sp/>subdivision<sp/>(default:<sp/>1)<sp/>\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>filename_in<sp/>--<sp/>the<sp/>input<sp/>mesh<sp/>(.off)<sp/>(default:<sp/>data/quint_tris.off)<sp/>\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>filename_out<sp/>--<sp/>the<sp/>output<sp/>mesh<sp/>(.off)<sp/>(default:<sp/>result.off)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>d<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>boost::lexical_cast&lt;int&gt;(argv[1])<sp/>:<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>in_file<sp/>=<sp/>(argc<sp/>&gt;<sp/>2)<sp/>?<sp/>argv[2]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/quint_tris.off&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>out_file<sp/>=<sp/>(argc<sp/>&gt;<sp/>3)<sp/>?<sp/>argv[3]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;result.off&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PolygonMesh<sp/>pmesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(in_file);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(in.fail())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Could<sp/>not<sp/>open<sp/>input<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>in_file<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>pmesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga04873e1be8efdf47ebb62b57d4d747af" kindref="member">Subdivision_method_3::CatmullClark_subdivision</ref>(pmesh,<sp/>params::number_of_iterations(d));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out(out_file);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out<sp/>&lt;&lt;<sp/>pmesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This example demonstrates the use of the Catmull-Clark subdivision method on a <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput>. There is only one line deserving a detailed explanation:</para><para><programlisting><codeline><highlight class="normal"><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga04873e1be8efdf47ebb62b57d4d747af" kindref="member">Subdivision_method_3::CatmullClark_subdivision</ref>(pmesh,<sp/>params::number_of_iterations(d));</highlight></codeline>
</programlisting></para><para><computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> specifies the namespace of the subdivision functions. <computeroutput>CatmullClark_subdivision(P, params::number_of_iterations(d))</computeroutput> computes the Catmull-Clark subdivision surface of the polygon mesh <computeroutput>pmesh</computeroutput> after <computeroutput>d</computeroutput> iterations of the refinements. The polygon mesh <computeroutput>pmesh</computeroutput> is passed by reference, and is modified (i.e. subdivided) by the subdivision function.</para><para>This example shows how to subdivide a <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput> with <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput>. An application-defined polygon mesh might use a specialized kernel and/or a specialized internal container. There is one major restriction on the application-defined polygon mesh to work with <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput>: The primitives (such as vertices, halfedges and faces) in the internal container are sequentially ordered (e.g. <computeroutput>std::vector</computeroutput> and <computeroutput>std::list</computeroutput>). This implies that the iterators traverse the primitives in the order of their creations/insertions.</para><para>Section <ref refid="index_1secRefHost" kindref="member">Refinement Host</ref> gives detailed explanations on this two restrictions.</para></sect1>
<sect1 id="index_1secCC">
<title>Catmull-Clark Subdivision</title>
<para><computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> is designed to allow customization of the subdivision methods. This section explains the implementation of the Catmull-Clark subdivision function in <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput>. The implementation demonstrates the customization of the PQQ refinement to Catmull-Clark subdivision.</para><para>When a subdivision method is developed, a refinement pattern is chosen, and then a set of geometry masks is developed to position the new points. There are three key components to implement a subdivision method: <itemizedlist>
<listitem>
<para>a mesh data structure that can represent arbitrary 2-manifolds, </para></listitem>
<listitem>
<para>a process that refines the mesh data structure, </para></listitem>
<listitem>
<para>and the geometry masks that compute the new points. </para></listitem>
</itemizedlist>
</para><para>E. Catmull and J. Clark chose the PQQ refinement for their subdivision method, and developed a set of geometry masks to generate (or more precisely, to approximate) the B-spline surface from the control mesh. <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> provides a function that glues all three components of the Catmull-Clark subdivision method.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Mask,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>NamedParameters&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga55aee95359d4cf956b62704cc9783fc1" kindref="member">PQQ</ref>(PolygonMesh&amp;<sp/>p,<sp/>Mask<sp/>mask,<sp/>NamedParameters<sp/>np)</highlight></codeline>
</programlisting></para><para><computeroutput>PolygonMesh</computeroutput> must be an instantiation of <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput>, or any other model of the concept <computeroutput><ref refid="classMutableFaceGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">MutableFaceGraph</ref></computeroutput>. It is a generic mesh data structure for arbitrary 2-manifolds. <computeroutput><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga55aee95359d4cf956b62704cc9783fc1" kindref="member">PQQ()</ref></computeroutput>, which refines the control mesh <computeroutput>p</computeroutput>, is a <emphasis>refinement host</emphasis> that uses a policy class <computeroutput>Mask&lt;PolygonMesh&gt;</computeroutput> as part of it geometry computation. During the refinement, <computeroutput><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga55aee95359d4cf956b62704cc9783fc1" kindref="member">PQQ()</ref></computeroutput> computes and assigns new points by cooperating with the <computeroutput>mask</computeroutput>. To implement Catmull-Clark subdivision, <computeroutput>Mask</computeroutput>, the <emphasis>geometry policy</emphasis>, has to realize the geometry masks of Catmull-Clark subdivision. The number of iterations as well as the vertex point map can be specified using the named parameter <computeroutput>np</computeroutput>.</para><para>To implement the geometry masks, we need to know how a refinement host communicates with its geometry masks. The PQQ refinement defines three stencils, and hence three geometry masks are required for Catmull-Clark subdivision. The following class defines the interfaces of the stencils for the PQQ refinement.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classPQQMask__3" kindref="compound">PQQMask_3</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>face_node(boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor<sp/>face,<sp/>Point_3&amp;<sp/>pt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>edge_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor<sp/>edge,<sp/>Point_3&amp;<sp/>pt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>vertex_node(boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor<sp/>vertex,<sp/>Point_3&amp;<sp/>pt);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>Each class function in <computeroutput><ref refid="classPQQMask__3" kindref="compound">PQQMask_3</ref></computeroutput> computes a new point based on the neighborhood of the primitive descriptor, and assigns the new point to <computeroutput><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_3</ref>&amp; pt</computeroutput>.</para><para>We realize each class function with the geometry masks of Catmull-Clark subdivision.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">CatmullClark_mask_3<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor<sp/>face_descriptor;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::property_traits&lt;VertexPointMap&gt;::value_type<sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygonmesh<sp/>pmesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>VertexPointMap<sp/>vpm;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1CatmullClark__mask__3_1abb8d07bc2396bd96f81aa72cdf918872" kindref="member">CatmullClark_mask_3</ref>(PolygonMesh<sp/>&amp;pmesh,<sp/>VertexPointMap<sp/>vpm)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>:<sp/>pmesh(pmesh,<sp/>vpm(vpm)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>face_node(face_descriptor<sp/>face,<sp/>Point_3&amp;<sp/>pt)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>p(0,0,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(halfedge_descriptor<sp/>hd<sp/>:<sp/><ref refid="group__PkgBGLIterators_1ga37229df31508a78eb4acdaf907e637e5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">halfedges_around_face</ref>(face,pmesh)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>p<sp/>+<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>(target(hd,pmesh))<sp/>-<sp/><ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">ORIGIN</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pt<sp/>=<sp/><ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">ORIGIN</ref><sp/>+<sp/>(p<sp/>-<sp/><ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">ORIGIN</ref>)/FT(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1CatmullClark__mask__3_1ac2943dc47c89e903c29fabfc986811f4" kindref="member">edge_node</ref>(halfedge_descriptor<sp/>edge,<sp/>Point_3&amp;<sp/>pt)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>p1<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,target(edge,<sp/>pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>p2<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,source(edge,<sp/>pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>f1,<sp/>f2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>face_node(face(edge,pmesh),<sp/>f1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>face_node(face(<ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(edge,pmesh),pmesh),<sp/>f2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pt<sp/>=<sp/>Point_3((p1[0]+p2[0]+f1[0]+f2[0])/4,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(p1[1]+p2[1]+f1[1]+f2[1])/4,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(p1[2]+p2[2]+f1[2]+f2[2])/4<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1CatmullClark__mask__3_1aadbd6b806981786099c2baed35565cb3" kindref="member">vertex_node</ref>(vertex_descriptor<sp/>vertex,<sp/>Point_3&amp;<sp/>pt)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Halfedge_around_target_circulator&lt;PolygonMesh&gt;<sp/>vcir(vertex,pmesh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;PolygonMesh&gt;::degree_size_type<sp/>n<sp/>=<sp/>degree(vertex,pmesh);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>Q[]<sp/>=<sp/>{0.0,<sp/>0.0,<sp/>0.0},<sp/>R[]<sp/>=<sp/>{0.0,<sp/>0.0,<sp/>0.0};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>S<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,vertex);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>q;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>i++,<sp/>++vcir)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Point_3<sp/>p2<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(<ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(*vcir,pmesh),pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>R[0]<sp/>+=<sp/>(S[0]+p2[0])/2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>R[1]<sp/>+=<sp/>(S[1]+p2[1])/2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>R[2]<sp/>+=<sp/>(S[2]+p2[2])/2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>face_node(face(*vcir,pmesh),<sp/>q);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Q[0]<sp/>+=<sp/>q[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Q[1]<sp/>+=<sp/>q[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Q[2]<sp/>+=<sp/>q[2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>R[0]<sp/>/=<sp/>n;<sp/><sp/><sp/><sp/>R[1]<sp/>/=<sp/>n;<sp/><sp/><sp/><sp/>R[2]<sp/>/=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Q[0]<sp/>/=<sp/>n;<sp/><sp/><sp/><sp/>Q[1]<sp/>/=<sp/>n;<sp/><sp/><sp/><sp/>Q[2]<sp/>/=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pt<sp/>=<sp/>Point_3((Q[0]<sp/>+<sp/>2*R[0]<sp/>+<sp/>S[0]*(n-3))/n,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(Q[1]<sp/>+<sp/>2*R[1]<sp/>+<sp/>S[1]*(n-3))/n,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(Q[2]<sp/>+<sp/>2*R[2]<sp/>+<sp/>S[2]*(n-3))/n<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>To invoke the Catmull-Clark subdivision method, we call <computeroutput><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga55aee95359d4cf956b62704cc9783fc1" kindref="member">PQQ()</ref></computeroutput> with the Catmull-Clark masks that we have just defined.</para><para><programlisting><codeline><highlight class="normal"><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga55aee95359d4cf956b62704cc9783fc1" kindref="member">PQQ</ref>(pmesh,<sp/>CatmullClark_mask_3(pmesh),<sp/>params::number_of_iterations(depth));</highlight></codeline>
</programlisting></para><para>Loop, Doo-Sabin and <formula id="0">$ \sqrt{3}$</formula> subdivisions are implemented using a similar process: pick a refinement host and implement the geometry policy. The key of developing your own subdivision method is implementing the right combination of the refinement host and the geometry policy. It is explained in the next two sections.</para></sect1>
<sect1 id="index_1secRefHost">
<title>Refinement Host</title>
<para>A refinement host is a template function of a polygon mesh class and a geometry mask class. It refines the input polygon mesh, and computes new points through the geometry masks. <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> supports four refinement hosts: primal quadrilateral quadrisection (PQQ), primal triangle quadrisection (PTQ), dual quadrilateral quadrisection (DQQ) and <formula id="0">$ \sqrt{3}$</formula> triangulation. Respectively, they are used by Catmull-Clark, Loop, Doo-Sabin and <formula id="0">$ \sqrt{3}$</formula> subdivision.</para><para><image type="html" name="RefSchemes.svg"></image>
</para><para><programlisting><codeline><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">Subdivision_method_3<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Mask,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>NamedParameters&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga55aee95359d4cf956b62704cc9783fc1" kindref="member">PQQ</ref>(PolygonMesh&amp;<sp/>pmesh,<sp/>Mask<sp/>mask,<sp/>NamedParameters<sp/>np);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Mask,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>NamedParameters&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga03f5ebc46849e95dc27eb012b4c9e837" kindref="member">PTQ</ref>(PolygonMesh&amp;<sp/>pmesh,<sp/>Mask<sp/>mask,<sp/>NamedParameters<sp/>np);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh,<sp/><sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Mask,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>NamedParameters&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga5bc093e3cb186ca9eb88a457209da517" kindref="member">DQQ</ref>(PolygonMesh&amp;<sp/>pmesh,<sp/>Mask<sp/>mask,<sp/>NamedParameters<sp/>np)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh,<sp/><sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Mask,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>NamedParameters&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga7b0187875bad4b47bf5b72a7577110ba" kindref="member">Sqrt3</ref>(PolygonMesh&amp;<sp/>pmesh,<sp/>Mask<sp/>mask,<sp/>NamedParameters<sp/>np)</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The mesh class must be a model of <computeroutput><ref refid="classMutableFaceGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">MutableFaceGraph</ref></computeroutput> and it must be a triangle mesh or a polygon mesh, and the mask is a policy class realizing the geometry masks of the subdivision method.</para><para>A refinement host refines the input polygon mesh, maintains the stencils (i.e., the mapping between the control mesh and the refined mesh), and calls the geometry masks to compute the new points. In <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput>, refinements are implemented as a sequence of connectivity operations (mainly Euler operations). The order of the connectivity operations plays a key role when maintaining stencils. By matching the order of the source submeshes to the refined vertices, no flag in the primitives is required to register the stencils. It avoids the data dependency of the refinement host on the polygon mesh class. To make the ordering trick work, the polygon mesh class must have a sequential container, such as a vector or a linked-list, as the internal storage. A sequential container guarantees that the iterators of the polygon mesh always traverse the primitives in the order of their insertions. Non-sequential structures such as trees or maps do not provide the required ordering, and hence cannot be used with <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput>.</para><para>Although <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> does not require flags to support the refinements and the stencils, it still needs to know how to compute and store the geometry data (i.e. the points). The classes of <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> have as optional template argument a vertex property map that provides a mapping between vertices and points.</para><para>Refinement hosts <computeroutput>PQQ</computeroutput> and <computeroutput>DQQ</computeroutput> work on a general polygon mesh, and <computeroutput>PTQ</computeroutput> and <computeroutput>Sqrt3</computeroutput> work on a triangulated polygon mesh. The result of <computeroutput>PTQ</computeroutput> and <computeroutput>Sqrt3</computeroutput> on a non-triangulated polygon mesh is undefined. <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> does not verify the precondition of the mesh characteristics before the refinement.</para><para>For details of the refinement implementation, interested users should refer to <ref refid="citelist_1CITEREF_cgal:sp-mrbee-05" kindref="member">[5]</ref>.</para></sect1>
<sect1 id="index_1Subdivision_method_3Geometry">
<title>Geometry Policy</title>
<para>A geometry policy defines a set of geometry masks. Each geometry mask is realized as a member function that computes new points of the subdivision surface.</para><para>Each geometry mask receives a primitive descriptor (e.g. <computeroutput>halfedge_descriptor</computeroutput>) of the control mesh, and returns a <computeroutput><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_3</ref></computeroutput> to the subdivided vertex. The function collects the vertex neighbors of the primitive descriptor (i.e. nodes on the stencil), and computes the new point based on the neighbors and the mask (i.e. the stencil weights).</para><para><image type="html" name="cc_mask.svg"></image>
</para><para>This figure shows the geometry masks of Catmull-Clark subdivision. The weights shown here are unnormalized, and <formula id="1">$ n$</formula> is the valence of the vertex. The new points are computed by the summation of the weighted points on their stencils. Following codes show an implementation of the geometry mask of the face-node. The complete listing of a Catmull-Clark geometry policy is in the Section <ref refid="index_1secCC" kindref="member">Catmull-Clark Subdivision</ref>.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VertexPo</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">Map&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">CatmullClark_mask_3<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor<sp/>face_descriptor;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::property_traits&lt;VertexPointMap&gt;::value_type<sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1CatmullClark__mask__3_1abb8d07bc2396bd96f81aa72cdf918872" kindref="member">CatmullClark_mask_3</ref>(PolygonMesh<sp/>&amp;pmesh,<sp/>VertexPointMap<sp/>vpm);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>face_node(face_descriptor<sp/>face,<sp/>Point_3&amp;<sp/>pt)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>p(0,0,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(halfedge_descriptor<sp/>hd<sp/>:<sp/><ref refid="group__PkgBGLIterators_1ga37229df31508a78eb4acdaf907e637e5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">halfedges_around_face</ref>(face,pmesh)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>p<sp/>+<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>(target(hd,pmesh))<sp/>-<sp/><ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">ORIGIN</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pt<sp/>=<sp/><ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">ORIGIN</ref><sp/>+<sp/>(p<sp/>-<sp/><ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">ORIGIN</ref>)/FT(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>In this example, the computation is based on the assumption that the <computeroutput><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_3</ref></computeroutput> is the <computeroutput><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Point_3</ref></computeroutput>. It is an assumption, but not a restriction. You are allowed to use any point class as long as it is defined as the <computeroutput><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_3</ref></computeroutput> in your polygon mesh. You may need to modify the geometry policy to support the computation and the assignment of the specialized point. This extension is not unusual in graphics applications. For example, you might want to subdivide the texture coordinates for your subdivision surface.</para><para>The refinement host of Catmull-Clark subdivision requires three geometry masks for polygon meshes without open boundaries: a vertex-node mask, an edge-node mask, and a face-node mask. To support polygon meshes with boundaries, a border-node mask is also required. The border-node mask for Catmull-Clark subdivision is listed below, where <computeroutput>ept</computeroutput> returns the new point splitting <computeroutput>edge</computeroutput> and <computeroutput>vpt</computeroutput> returns the new point on the vertex pointed by <computeroutput>edge</computeroutput>.</para><para><programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>border_node(halfedge_descriptor<sp/>edge,<sp/>Point_3&amp;<sp/>ept,<sp/>Point_3&amp;<sp/>vpt)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_3<sp/>ep1<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(edge,<sp/>pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_3<sp/>ep2<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(<ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(edge,<sp/>pmesh),<sp/>pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ept<sp/>=<sp/>Point_3((ep1[0]+ep2[0])/2,<sp/>(ep1[1]+ep2[1])/2,<sp/>(ep1[2]+ep2[2])/2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_around_target_circulator&lt;Poly&gt;<sp/>vcir(edge,<sp/>pmesh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_3<sp/>vp1<sp/><sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,target(<ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(*vcir,<sp/>pmesh<sp/>),<sp/>pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_3<sp/>vp0<sp/><sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(*vcir,<sp/>pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>--vcir;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_3<sp/>vp_1<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(<ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(*vcir,<sp/>pmesh),<sp/>pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vpt<sp/>=<sp/>Point_3((vp_1[0]<sp/>+<sp/>6*vp0[0]<sp/>+<sp/>vp1[0])/8,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(vp_1[1]<sp/>+<sp/>6*vp0[1]<sp/>+<sp/>vp1[1])/8,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(vp_1[2]<sp/>+<sp/>6*vp0[2]<sp/>+<sp/>vp1[2])/8<sp/>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The mask interfaces of all four refinement hosts are listed below. <computeroutput><ref refid="classDQQMask__3" kindref="compound">DQQMask_3</ref></computeroutput> does not have the border-node stencil because the refinement host of the DQQ refinement does not support global boundaries in the current release. This might change in future releases.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classPQQMask__3" kindref="compound">PQQMask_3</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>face_node(boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor,<sp/>Point_3&amp;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>edge_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor,<sp/>Point_3&amp;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>vertex_node(boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor,<sp/>Point_3&amp;);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>border_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor,<sp/>Point_3&amp;,<sp/>Point_3&amp;);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classPTQMask__3" kindref="compound">PTQMask_3</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>edge_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor,<sp/>Point_3&amp;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>vertex_node(boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor,<sp/>Point_3&amp;);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>border_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor,<sp/>Point_3&amp;,<sp/>Point_3_&amp;);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classDQQMask__3" kindref="compound">DQQMask_3</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>corner_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor<sp/>edge,<sp/>Point_3&amp;<sp/>pt);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classSqrt3Mask__3" kindref="compound">Sqrt3Mask_3</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>vertex_node(boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor<sp/>vertex,<sp/>Point_3&amp;<sp/>pt);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>The source codes of <computeroutput><ref refid="classCGAL_1_1CatmullClark__mask__3" kindref="compound">CatmullClark_mask_3</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Loop__mask__3" kindref="compound">Loop_mask_3</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1DooSabin__mask__3" kindref="compound">DooSabin_mask_3</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Sqrt3__mask__3" kindref="compound">Sqrt3_mask_3</ref></computeroutput> are the best sources of learning these stencil interfaces.</para></sect1>
<sect1 id="index_1Subdivision_method_3The">
<title>The Four Subdivision Methods</title>
<para><computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> supports Catmull-Clark, Loop, Doo-Sabin and <formula id="0">$ \sqrt{3}$</formula> subdivisions by specializing their respective refinement hosts. They are designed to work on any model of a <computeroutput><ref refid="classMutableFaceGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">MutableFaceGraph</ref></computeroutput> such as <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput>. If your application uses a polygon mesh with a specialized geometry kernel, you need to specialize the refinement host with a geometry policy based on that kernel.</para><para><programlisting><codeline><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">Subdivision_method_3<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>NamedParameters&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga04873e1be8efdf47ebb62b57d4d747af" kindref="member">CatmullClark_subdivision</ref>(PolygonMesh&amp;<sp/>pmesh,<sp/>NamedParameters<sp/>np)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga55aee95359d4cf956b62704cc9783fc1" kindref="member">PQQ</ref>(pmesh,<sp/>CatmullClark_mask_3&lt;PolygonMesh&gt;(pmesh),<sp/>np);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>NamedParameters&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga7189d985dceac1b5952d938e0c7c8088" kindref="member">Loop_subdivision</ref>(PolygonMesh&amp;<sp/>pmesh,<sp/>NamedParameters<sp/>np)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga03f5ebc46849e95dc27eb012b4c9e837" kindref="member">PTQ</ref>(pmesh,<sp/>Loop_mask_3&lt;PolygonMesh&gt;(pmesh)<sp/>,<sp/>np);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>NamedParameters&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga58b8240103ea42aee039066173ec9a71" kindref="member">DooSabin_subdivision</ref>(PolygonMesh&amp;<sp/>pmesh,<sp/>NamedParameters<sp/>np)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga5bc093e3cb186ca9eb88a457209da517" kindref="member">DQQ</ref>(pmesh,<sp/>DooSabin_mask_3&lt;PolygonMesh&gt;(pmesh),<sp/>np);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolygonMesh,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>NamedParameters&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga8c6eac3a8877da7311bfaaea7a7d3446" kindref="member">Sqrt3_subdivision</ref>(PolygonMesh&amp;<sp/>pmesh,<sp/>NamedParameters<sp/>np)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga7b0187875bad4b47bf5b72a7577110ba" kindref="member">Sqrt3</ref>(pmesh,<sp/>Sqrt3_mask_3&lt;PolygonMesh&gt;(pmesh),<sp/>np);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1Subdivision_method_3Other">
<title>Example: Customizing a Subdivision Method</title>
<para><computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> supports four practical subdivision methods on a <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput> with points with Cartesian coordinates. More subdivision methods can be supported through the specialization of refinement hosts with custom geometry masks. The following example develops a subdivision method generating an improved Loop subdivision surface.</para><para><linebreak/>
<bold>File</bold> <ref refid="Subdivision_method_3_2Customized_subdivision_8cpp-example" kindref="compound">Subdivision_method_3/Customized_subdivision.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/graph_traits_Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="subdivision__method__3_8h" kindref="compound">CGAL/subdivision_method_3.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/foreach.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/lexical_cast.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</ref><sp/>PolygonMesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespacestd" kindref="compound">std</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL" kindref="compound">CGAL</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">params<sp/>=<sp/>CGAL::parameters;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>======================================================================</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Poly&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">WLoop_mask_3<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Poly<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PolygonMesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor<sp/><sp/><sp/>vertex_descriptor;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor<sp/>halfedge_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>boost::property_map&lt;PolygonMesh,<sp/>vertex_point_t&gt;::type<sp/>Vertex_pmap;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>boost::property_traits&lt;Vertex_pmap&gt;::value_type<sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>boost::property_traits&lt;Vertex_pmap&gt;::reference<sp/>Point_ref;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PolygonMesh&amp;<sp/>pmesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_pmap<sp/>vpm;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WLoop_mask_3(PolygonMesh&amp;<sp/>pmesh)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>pmesh(pmesh),<sp/>vpm(get(<ref refid="namespaceCGAL" kindref="compound">CGAL</ref>::vertex_point,<sp/>pmesh))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>edge_node(halfedge_descriptor<sp/>hd,<sp/>Point&amp;<sp/>pt)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_ref<sp/>p1<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(hd,pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_ref<sp/>p2<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(<ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(hd,pmesh),pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_ref<sp/>f1<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(<ref refid="group__STLAlgos_1gad4dbc8daf3c0e2201f4972eb9eea404d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">next</ref>(hd,pmesh),pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_ref<sp/>f2<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(<ref refid="group__STLAlgos_1gad4dbc8daf3c0e2201f4972eb9eea404d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">next</ref>(<ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(hd,pmesh),pmesh),pmesh));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pt<sp/>=<sp/>Point((3*(p1[0]+p2[0])+f1[0]+f2[0])/8,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(3*(p1[1]+p2[1])+f1[1]+f2[1])/8,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(3*(p1[2]+p2[2])+f1[2]+f2[2])/8<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>vertex_node(vertex_descriptor<sp/>vd,<sp/>Point&amp;<sp/>pt)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>R[]<sp/>=<sp/>{0.0,<sp/>0.0,<sp/>0.0};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_ref<sp/>S<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,vd);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::size_t<sp/>n<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>BOOST_FOREACH(halfedge_descriptor<sp/>hd,<sp/><ref refid="group__PkgBGLIterators_1ga2be4fd4d24b1e48e00a92f90f0f2923c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">halfedges_around_target</ref>(vd,<sp/>pmesh)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Point_ref<sp/>p<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(<ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(hd,pmesh),pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>R[0]<sp/>+=<sp/>p[0];<sp/><sp/><sp/><sp/><sp/>R[1]<sp/>+=<sp/>p[1];<sp/><sp/><sp/>R[2]<sp/>+=<sp/>p[2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(n<sp/>==<sp/>6)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pt<sp/>=<sp/>Point((10*S[0]+R[0])/16,<sp/>(10*S[1]+R[1])/16,<sp/>(10*S[2]+R[2])/16);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(n<sp/>==<sp/>3)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>B<sp/>=<sp/>(5.0/8.0<sp/>-<sp/><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">std::sqrt</ref>(3+2*std::cos(6.283/n))/64.0)/n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>A<sp/>=<sp/>1-n*B;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pt<sp/>=<sp/>Point((A*S[0]+B*R[0]),<sp/>(A*S[1]+B*R[1]),<sp/>(A*S[2]+B*R[2]));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>B<sp/>=<sp/>3.0/8.0/n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>A<sp/>=<sp/>1-n*B;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pt<sp/>=<sp/>Point((A*S[0]+B*R[0]),<sp/>(A*S[1]+B*R[1]),<sp/>(A*S[2]+B*R[2]));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>border_node(halfedge_descriptor<sp/>hd,<sp/>Point&amp;<sp/>ept,<sp/>Point&amp;<sp/>vpt)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_ref<sp/>ep1<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(hd,pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_ref<sp/>ep2<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(<ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(hd,pmesh),pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ept<sp/>=<sp/>Point((ep1[0]+ep2[0])/2,<sp/>(ep1[1]+ep2[1])/2,<sp/>(ep1[2]+ep2[2])/2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Halfedge__around__target__circulator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">Halfedge_around_target_circulator&lt;Poly&gt;</ref><sp/>vcir(hd,pmesh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_ref<sp/>vp1<sp/><sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(<ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(*vcir,pmesh),pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_ref<sp/>vp0<sp/><sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,<sp/>target(*vcir,pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>--vcir;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_ref<sp/>vp_1<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vpm,target(<ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(*vcir,pmesh),pmesh));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vpt<sp/>=<sp/>Point((vp_1[0]<sp/>+<sp/>6*vp0[0]<sp/>+<sp/>vp1[0])/8,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(vp_1[1]<sp/>+<sp/>6*vp0[1]<sp/>+<sp/>vp1[1])/8,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(vp_1[2]<sp/>+<sp/>6*vp0[2]<sp/>+<sp/>vp1[2])/8<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>**argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Usage:<sp/>Customized_subdivision<sp/>[d]<sp/>[filename_in]<sp/>[filename_out]<sp/>\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>d<sp/>--<sp/>the<sp/>depth<sp/>of<sp/>the<sp/>subdivision<sp/>(default:<sp/>1)<sp/>\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>filename_in<sp/>--<sp/>the<sp/>input<sp/>mesh<sp/>(.off)<sp/>(default:<sp/>data/quint_tris.off)<sp/>\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>filename_out<sp/>--<sp/>the<sp/>output<sp/>mesh<sp/>(.off)<sp/>(default:<sp/>result.off)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>d<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>boost::lexical_cast&lt;int&gt;(argv[1])<sp/>:<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>in_file<sp/>=<sp/>(argc<sp/>&gt;<sp/>2)<sp/>?<sp/>argv[2]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/quint_tris.off&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>out_file<sp/>=<sp/>(argc<sp/>&gt;<sp/>3)<sp/>?<sp/>argv[3]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;result.off&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PolygonMesh<sp/>pmesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(in_file);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(in.fail())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Could<sp/>not<sp/>open<sp/>input<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>in_file<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>pmesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgSurfaceSubdivisionMethods3Functions_1ga03f5ebc46849e95dc27eb012b4c9e837" kindref="member">Subdivision_method_3::PTQ</ref>(pmesh,<sp/>WLoop_mask_3&lt;PolygonMesh&gt;(pmesh),<sp/>params::number_of_iterations(d));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out(out_file);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out<sp/>&lt;&lt;<sp/>pmesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The points generated by the geometry mask are semantically required to converge to a smooth surface. This is the requirement imposed by the theory of the subdivision surface. <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> does not enforce this requirement, nor will it verify the smoothness of the subdivided mesh. <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> guarantees the topological properties of the subdivided mesh. A genus- <formula id="1">$ n$</formula> 2-manifold is assured to be subdivided into a genus- <formula id="1">$ n$</formula> 2-manifold. But when specialized with ill-designed geometry masks, <computeroutput><ref refid="namespaceCGAL_1_1Subdivision__method__3" kindref="compound">Subdivision_method_3</ref></computeroutput> may generate a surface that is odd, not smooth, or that does not even exist.</para></sect1>
<sect1 id="index_1Subdivision_method_3History">
<title>Implementation History</title>
<para>This package was initially developed by Le-Jeng Andy Shiue. For CGAL 4.11 it was generalized to work on any model of a <computeroutput><ref refid="classMutableFaceGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">MutableFaceGraph</ref></computeroutput> by Andreas Fabri and Mael Rouxel-Labb. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
