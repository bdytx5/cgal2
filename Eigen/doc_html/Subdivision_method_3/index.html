<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Subdivision_method_3/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 3D Surface Subdivision Methods: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 3D Surface Subdivision Methods
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_3D_Surface_Subdivision_Methods"></a><a class="anchor" id="chapterSubdivision"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Author</dt><dd>Le-Jeng Andy Shiue</dd></dl>
<div class="image">
<img src="subdivision-teaser.jpg" alt="subdivision-teaser.jpg" />
</div>
<h1><a class="anchor" id="sectionSubIntro"></a>
Introduction</h1>
<p>Subdivision methods are simple yet powerful ways to generate smooth surfaces from arbitrary polygonal meshes. Unlike spline-based surfaces (e.g NURBS) or other numeric-based modeling techniques, users of subdivision methods do not need the mathematical knowledge of the subdivision methods. The natural intuition of the geometry suffices to control the subdivision methods.</p>
<p><code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> works for the classes <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code>, as they are models of the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>, and it aims to be easy to use and to extend. <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> is not a class, but a namespace which contains four popular subdivision methods and their refinement functions. These include Catmull-Clark, Loop, Doo-Sabin and \( \sqrt{3}\) subdivisions. Variations of these methods can be easily extended by substituting the geometry computation of the refinement host.</p>
<h1><a class="anchor" id="secSubAlgo"></a>
Subdivision Method</h1>
<p>In this chapter, we explain some fundamentals of subdivision methods. We focus only on the topics that help you understand the design of the package. Details on subdivision methods can be found in <a class="el" href="citelist.html#CITEREF_cgal:ww-smgd-02">[6]</a>. Some terminology introduced in this section will be used again in later sections. If you are only interested in using a specific subdivision method, Section <a class="el" href="index.html#secFirstSub">A Quick Example: Catmull-Clark Subdivision</a> gives a quick tutorial on using a Catmull-Clark subdivision.</p>
<p>A subdivision method recursively refines a coarse mesh and generates an ever closer approximation to a smooth surface. The coarse mesh can have arbitrary shape, but it has to be a 2-manifold. In a 2-manifold, every interior point has a neighborhood homeomorphic to a 2D disk. Subdivision methods on non-manifolds have been developed, but are not considered in <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code>. The chapter teaser shows the steps of Catmull-Clark subdivision on a CAD model. The coarse mesh is repeatedly refined by a quadrisection pattern, and new points are generated to approximate a smooth surface.</p>
<p>Many refinement patterns are used in practice. <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> supports the four most popular patterns, and each of them is used by Catmull-Clark<a class="el" href="citelist.html#CITEREF_cgal:cc-rgbss-78">[1]</a>, Loop<a class="el" href="citelist.html#CITEREF_cloop:mthesis">[4]</a>, Doo-Sabin<a class="el" href="citelist.html#CITEREF_doo1978behaviour">[2]</a> and \( \sqrt{3}\) subdivision<a class="el" href="citelist.html#CITEREF_cgal:k-s-00">[3]</a> (left to right in the figure below). We name these patterns by their topological characteristics instead of the associated subdivision methods. PQQ indicates the <em>P</em>rimal <em>Q</em>uadtrateral <em>Q</em>uadrisection. PTQ indicates the <em>P</em>rimal <em>T</em>riangle <em>Q</em>uadrisection. DQQ indicates the <em>D</em>ual <em>Q</em>uadtrateral <em>Q</em>uadrisection. \( \sqrt{3}\) indicates the converging speed of the triangulation toward the subdivision surface.</p>
<div class="image">
<object type="image/svg+xml" data="RefSchemes.svg">RefSchemes.svg</object>
</div>
<p>The figure demonstrates these four refinement patterns on the 1-disk of a valence-5 vertex/face. Refined meshes are shown below the source meshes. Points on the refined mesh are generated by averaging neighbor points on the source mesh. A graph, called <em>stencil</em>, determines the source neighborhood whose points contribute to the position of a refined point. A refinement pattern usually defines more than one stencil. For example, the PQQ refinement has a vertex-node stencil, which defines the 1-ring of an input vertex; an edge-node stencil, which defines the 1-ring of an input edge; and a face-node stencil, which defines an input face. The stencils of the PQQ refinement are shown in the following figure. The blue neighborhoods in the top row indicate the corresponding stencils of the refined nodes in red.</p>
<div class="image">
<object type="image/svg+xml" data="PQQStencil.svg">PQQStencil.svg</object>
</div>
<p>Stencils with weights are called <em>geometry masks</em>. A subdivision method defines a geometry mask for each stencil, and generates new points by averaging source points weighted by the mask. Geometry masks are carefully chosen to meet requirements of certain surface smoothness and shape quality. The geometry masks of Catmull-Clark subdivision are shown below.</p>
<div class="image">
<object type="image/svg+xml" data="cc_mask.svg">cc_mask.svg</object>
</div>
<p>The weights shown here are unnormalized, and \( n\) is the valence of the vertex. The generated point, in red, is computed by a summation of the weighted points. For example, a Catmull-Clark face-node is computed by the summation of \( 1/4\) of each point on its stencil.</p>
<p>A stencil can have an unlimited number of geometry masks. For example, a face-node of PQQ refinement may be computed by the summation of \( 1/5\) of each stencil node instead of \( 1/4\). Although it is legal in <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> to have any kind of geometry mask, the result surfaces may be odd, not smooth, or not even exist. <a class="el" href="citelist.html#CITEREF_cgal:ww-smgd-02">[6]</a> explains the details on designing masks for a quality subdivision surface.</p>
<h1><a class="anchor" id="secFirstSub"></a>
A Quick Example: Catmull-Clark Subdivision</h1>
<p>Assuming that you are familiar with <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code>, you can integrate <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> into your program without much effort.</p>
<p><br />
<b>File</b> <a class="el" href="Subdivision_method_3_2CatmullClark_subdivision_8cpp-example.html">Subdivision_method_3/CatmullClark_subdivision.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="subdivision__method__3_8h.html">CGAL/subdivision_method_3.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a>    PolygonMesh;</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a>;</div><div class="line"><span class="keyword">namespace </span>params = CGAL::parameters;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 4) {</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">"Usage: CatmullClark_subdivision [d] [filename_in] [filename_out] \n"</span>;</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">"         d -- the depth of the subdivision (default: 1) \n"</span>;</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">"         filename_in -- the input mesh (.off) (default: data/quint_tris.off) \n"</span>;</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">"         filename_out -- the output mesh (.off) (default: result.off)"</span> &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> d = (argc &gt; 1) ? boost::lexical_cast&lt;int&gt;(argv[1]) : 1;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* in_file = (argc &gt; 2) ? argv[2] : <span class="stringliteral">"data/quint_tris.off"</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* out_file = (argc &gt; 3) ? argv[3] : <span class="stringliteral">"result.off"</span>;</div><div class="line"></div><div class="line">  PolygonMesh pmesh;</div><div class="line">  std::ifstream in(in_file);</div><div class="line">  <span class="keywordflow">if</span>(in.fail()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Could not open input file "</span> &lt;&lt; in_file &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  in &gt;&gt; pmesh;</div><div class="line"></div><div class="line">  Timer t;</div><div class="line">  t.start();</div><div class="line">  <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga04873e1be8efdf47ebb62b57d4d747af">Subdivision_method_3::CatmullClark_subdivision</a>(pmesh, params::number_of_iterations(d));</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done ("</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::ofstream out(out_file);</div><div class="line">  out &lt;&lt; pmesh;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This example demonstrates the use of the Catmull-Clark subdivision method on a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code>. There is only one line deserving a detailed explanation:</p>
<div class="fragment"><div class="line"><a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga04873e1be8efdf47ebb62b57d4d747af">Subdivision_method_3::CatmullClark_subdivision</a>(pmesh, params::number_of_iterations(d));</div></div><!-- fragment --><p><code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> specifies the namespace of the subdivision functions. <code>CatmullClark_subdivision(P, params::number_of_iterations(d))</code> computes the Catmull-Clark subdivision surface of the polygon mesh <code>pmesh</code> after <code>d</code> iterations of the refinements. The polygon mesh <code>pmesh</code> is passed by reference, and is modified (i.e. subdivided) by the subdivision function.</p>
<p>This example shows how to subdivide a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> with <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code>. An application-defined polygon mesh might use a specialized kernel and/or a specialized internal container. There is one major restriction on the application-defined polygon mesh to work with <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code>: The primitives (such as vertices, halfedges and faces) in the internal container are sequentially ordered (e.g. <code>std::vector</code> and <code>std::list</code>). This implies that the iterators traverse the primitives in the order of their creations/insertions.</p>
<p>Section <a class="el" href="index.html#secRefHost">Refinement Host</a> gives detailed explanations on this two restrictions.</p>
<h1><a class="anchor" id="secCC"></a>
Catmull-Clark Subdivision</h1>
<p><code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> is designed to allow customization of the subdivision methods. This section explains the implementation of the Catmull-Clark subdivision function in <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code>. The implementation demonstrates the customization of the PQQ refinement to Catmull-Clark subdivision.</p>
<p>When a subdivision method is developed, a refinement pattern is chosen, and then a set of geometry masks is developed to position the new points. There are three key components to implement a subdivision method: </p><ul>
<li>
a mesh data structure that can represent arbitrary 2-manifolds, </li>
<li>
a process that refines the mesh data structure, </li>
<li>
and the geometry masks that compute the new points. </li>
</ul>
<p>E. Catmull and J. Clark chose the PQQ refinement for their subdivision method, and developed a set of geometry masks to generate (or more precisely, to approximate) the B-spline surface from the control mesh. <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> provides a function that glues all three components of the Catmull-Clark subdivision method.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh, <span class="keyword">class</span> Mask, <span class="keyword">class</span> NamedParameters&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga55aee95359d4cf956b62704cc9783fc1">PQQ</a>(PolygonMesh&amp; p, Mask mask, NamedParameters np)</div></div><!-- fragment --><p><code>PolygonMesh</code> must be an instantiation of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code>, or any other model of the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>. It is a generic mesh data structure for arbitrary 2-manifolds. <code><a class="el" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga55aee95359d4cf956b62704cc9783fc1" title="applies the PQQ refinement several times on the control mesh pmesh. ">PQQ()</a></code>, which refines the control mesh <code>p</code>, is a <em>refinement host</em> that uses a policy class <code>Mask&lt;PolygonMesh&gt;</code> as part of it geometry computation. During the refinement, <code><a class="el" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga55aee95359d4cf956b62704cc9783fc1" title="applies the PQQ refinement several times on the control mesh pmesh. ">PQQ()</a></code> computes and assigns new points by cooperating with the <code>mask</code>. To implement Catmull-Clark subdivision, <code>Mask</code>, the <em>geometry policy</em>, has to realize the geometry masks of Catmull-Clark subdivision. The number of iterations as well as the vertex point map can be specified using the named parameter <code>np</code>.</p>
<p>To implement the geometry masks, we need to know how a refinement host communicates with its geometry masks. The PQQ refinement defines three stencils, and hence three geometry masks are required for Catmull-Clark subdivision. The following class defines the interfaces of the stencils for the PQQ refinement.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classPQQMask__3.html">PQQMask_3</a> {</div><div class="line">  <span class="keywordtype">void</span> face_node(boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor face, Point_3&amp; pt);</div><div class="line">  <span class="keywordtype">void</span> edge_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor edge, Point_3&amp; pt);</div><div class="line">  <span class="keywordtype">void</span> vertex_node(boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor vertex, Point_3&amp; pt);</div><div class="line">};</div></div><!-- fragment --><p>Each class function in <code><a class="el" href="classPQQMask__3.html" title="Required member functions for the PQQMask_3 concept. This policy concept of geometric computations is...">PQQMask_3</a></code> computes a new point based on the neighborhood of the primitive descriptor, and assigns the new point to <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&amp; pt</code>.</p>
<p>We realize each class function with the geometry masks of Catmull-Clark subdivision.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh&gt;</div><div class="line"><span class="keyword">class </span>CatmullClark_mask_3 {</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor face_descriptor;</div><div class="line">  <span class="keyword">typedef</span> boost::property_traits&lt;VertexPointMap&gt;::value_type Point_3;</div><div class="line"></div><div class="line">  Polygonmesh pmesh;</div><div class="line">  VertexPointMap vpm;</div><div class="line"></div><div class="line">  <a class="code" href="classCGAL_1_1CatmullClark__mask__3.html#abb8d07bc2396bd96f81aa72cdf918872">CatmullClark_mask_3</a>(PolygonMesh &amp;pmesh, VertexPointMap vpm)</div><div class="line">  : pmesh(pmesh, vpm(vpm)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> face_node(face_descriptor face, Point_3&amp; pt) {</div><div class="line">    <span class="keywordtype">int</span> n = 0;</div><div class="line">    Point_3 p(0,0,0);</div><div class="line">    <span class="keywordflow">for</span>(halfedge_descriptor hd : <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">halfedges_around_face</a>(face,pmesh)){</div><div class="line">      p = p + <span class="keyword">get</span>(vpm, (target(hd,pmesh)) - <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a>);</div><div class="line">      ++n;</div><div class="line">    }</div><div class="line">    pt = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a> + (p - <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a>)/FT(n);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classCGAL_1_1CatmullClark__mask__3.html#ac2943dc47c89e903c29fabfc986811f4">edge_node</a>(halfedge_descriptor edge, Point_3&amp; pt) {</div><div class="line">    Point_3 p1 = <span class="keyword">get</span>(vpm,target(edge, pmesh));</div><div class="line">    Point_3 p2 = <span class="keyword">get</span>(vpm,source(edge, pmesh));</div><div class="line">    Point_3 f1, f2;</div><div class="line">    face_node(face(edge,pmesh), f1);</div><div class="line">    face_node(face(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(edge,pmesh),pmesh), f2);</div><div class="line">    pt = Point_3((p1[0]+p2[0]+f1[0]+f2[0])/4,</div><div class="line">                 (p1[1]+p2[1]+f1[1]+f2[1])/4,</div><div class="line">                 (p1[2]+p2[2]+f1[2]+f2[2])/4 );</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classCGAL_1_1CatmullClark__mask__3.html#aadbd6b806981786099c2baed35565cb3">vertex_node</a>(vertex_descriptor vertex, Point_3&amp; pt) {</div><div class="line">    Halfedge_around_target_circulator&lt;PolygonMesh&gt; vcir(vertex,pmesh);</div><div class="line">    <span class="keyword">typename</span> boost::graph_traits&lt;PolygonMesh&gt;::degree_size_type n = degree(vertex,pmesh);</div><div class="line"></div><div class="line">    FT Q[] = {0.0, 0.0, 0.0}, R[] = {0.0, 0.0, 0.0};</div><div class="line">    Point_3 S = <span class="keyword">get</span>(vpm,vertex);</div><div class="line"></div><div class="line">    Point_3 q;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++, ++vcir) {</div><div class="line">      Point_3 p2 = <span class="keyword">get</span>(vpm, target(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(*vcir,pmesh),pmesh));</div><div class="line">      R[0] += (S[0]+p2[0])/2;</div><div class="line">      R[1] += (S[1]+p2[1])/2;</div><div class="line">      R[2] += (S[2]+p2[2])/2;</div><div class="line">      face_node(face(*vcir,pmesh), q);</div><div class="line">      Q[0] += q[0];</div><div class="line">      Q[1] += q[1];</div><div class="line">      Q[2] += q[2];</div><div class="line">    }</div><div class="line">    R[0] /= n;    R[1] /= n;    R[2] /= n;</div><div class="line">    Q[0] /= n;    Q[1] /= n;    Q[2] /= n;</div><div class="line"></div><div class="line">    pt = Point_3((Q[0] + 2*R[0] + S[0]*(n-3))/n,</div><div class="line">                 (Q[1] + 2*R[1] + S[1]*(n-3))/n,</div><div class="line">                 (Q[2] + 2*R[2] + S[2]*(n-3))/n );</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>To invoke the Catmull-Clark subdivision method, we call <code><a class="el" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga55aee95359d4cf956b62704cc9783fc1" title="applies the PQQ refinement several times on the control mesh pmesh. ">PQQ()</a></code> with the Catmull-Clark masks that we have just defined.</p>
<div class="fragment"><div class="line"><a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga55aee95359d4cf956b62704cc9783fc1">PQQ</a>(pmesh, CatmullClark_mask_3(pmesh), params::number_of_iterations(depth));</div></div><!-- fragment --><p>Loop, Doo-Sabin and \( \sqrt{3}\) subdivisions are implemented using a similar process: pick a refinement host and implement the geometry policy. The key of developing your own subdivision method is implementing the right combination of the refinement host and the geometry policy. It is explained in the next two sections.</p>
<h1><a class="anchor" id="secRefHost"></a>
Refinement Host</h1>
<p>A refinement host is a template function of a polygon mesh class and a geometry mask class. It refines the input polygon mesh, and computes new points through the geometry masks. <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> supports four refinement hosts: primal quadrilateral quadrisection (PQQ), primal triangle quadrisection (PTQ), dual quadrilateral quadrisection (DQQ) and \( \sqrt{3}\) triangulation. Respectively, they are used by Catmull-Clark, Loop, Doo-Sabin and \( \sqrt{3}\) subdivision.</p>
<div class="image">
<object type="image/svg+xml" data="RefSchemes.svg">RefSchemes.svg</object>
</div>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Subdivision_method_3 {</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh, <span class="keyword">class</span> Mask, <span class="keyword">class</span> NamedParameters&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga55aee95359d4cf956b62704cc9783fc1">PQQ</a>(PolygonMesh&amp; pmesh, Mask mask, NamedParameters np);</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh, <span class="keyword">class</span> Mask, <span class="keyword">class</span> NamedParameters&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga03f5ebc46849e95dc27eb012b4c9e837">PTQ</a>(PolygonMesh&amp; pmesh, Mask mask, NamedParameters np);</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh,  <span class="keyword">class</span> Mask, <span class="keyword">class</span> NamedParameters&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga5bc093e3cb186ca9eb88a457209da517">DQQ</a>(PolygonMesh&amp; pmesh, Mask mask, NamedParameters np)</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh,  <span class="keyword">class</span> Mask, <span class="keyword">class</span> NamedParameters&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga7b0187875bad4b47bf5b72a7577110ba">Sqrt3</a>(PolygonMesh&amp; pmesh, Mask mask, NamedParameters np)</div><div class="line">}</div></div><!-- fragment --><p>The mesh class must be a model of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> and it must be a triangle mesh or a polygon mesh, and the mask is a policy class realizing the geometry masks of the subdivision method.</p>
<p>A refinement host refines the input polygon mesh, maintains the stencils (i.e., the mapping between the control mesh and the refined mesh), and calls the geometry masks to compute the new points. In <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code>, refinements are implemented as a sequence of connectivity operations (mainly Euler operations). The order of the connectivity operations plays a key role when maintaining stencils. By matching the order of the source submeshes to the refined vertices, no flag in the primitives is required to register the stencils. It avoids the data dependency of the refinement host on the polygon mesh class. To make the ordering trick work, the polygon mesh class must have a sequential container, such as a vector or a linked-list, as the internal storage. A sequential container guarantees that the iterators of the polygon mesh always traverse the primitives in the order of their insertions. Non-sequential structures such as trees or maps do not provide the required ordering, and hence cannot be used with <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code>.</p>
<p>Although <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> does not require flags to support the refinements and the stencils, it still needs to know how to compute and store the geometry data (i.e. the points). The classes of <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> have as optional template argument a vertex property map that provides a mapping between vertices and points.</p>
<p>Refinement hosts <code>PQQ</code> and <code>DQQ</code> work on a general polygon mesh, and <code>PTQ</code> and <code>Sqrt3</code> work on a triangulated polygon mesh. The result of <code>PTQ</code> and <code>Sqrt3</code> on a non-triangulated polygon mesh is undefined. <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> does not verify the precondition of the mesh characteristics before the refinement.</p>
<p>For details of the refinement implementation, interested users should refer to <a class="el" href="citelist.html#CITEREF_cgal:sp-mrbee-05">[5]</a>.</p>
<h1><a class="anchor" id="Subdivision_method_3Geometry"></a>
Geometry Policy</h1>
<p>A geometry policy defines a set of geometry masks. Each geometry mask is realized as a member function that computes new points of the subdivision surface.</p>
<p>Each geometry mask receives a primitive descriptor (e.g. <code>halfedge_descriptor</code>) of the control mesh, and returns a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> to the subdivided vertex. The function collects the vertex neighbors of the primitive descriptor (i.e. nodes on the stencil), and computes the new point based on the neighbors and the mask (i.e. the stencil weights).</p>
<div class="image">
<object type="image/svg+xml" data="cc_mask.svg">cc_mask.svg</object>
</div>
<p>This figure shows the geometry masks of Catmull-Clark subdivision. The weights shown here are unnormalized, and \( n\) is the valence of the vertex. The new points are computed by the summation of the weighted points on their stencils. Following codes show an implementation of the geometry mask of the face-node. The complete listing of a Catmull-Clark geometry policy is in the Section <a class="el" href="index.html#secCC">Catmull-Clark Subdivision</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh, <span class="keyword">class</span> VertexPo<span class="keywordtype">int</span>Map&gt;</div><div class="line"><span class="keyword">class </span>CatmullClark_mask_3 {</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor face_descriptor;</div><div class="line">  <span class="keyword">typedef</span> boost::property_traits&lt;VertexPointMap&gt;::value_type Point_3;</div><div class="line"></div><div class="line">  <a class="code" href="classCGAL_1_1CatmullClark__mask__3.html#abb8d07bc2396bd96f81aa72cdf918872">CatmullClark_mask_3</a>(PolygonMesh &amp;pmesh, VertexPointMap vpm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> face_node(face_descriptor face, Point_3&amp; pt) {</div><div class="line">    <span class="keywordtype">int</span> n = 0;</div><div class="line">    Point_3 p(0,0,0);</div><div class="line">    <span class="keywordflow">for</span>(halfedge_descriptor hd : <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">halfedges_around_face</a>(face,pmesh)){</div><div class="line">      p = p + <span class="keyword">get</span>(vpm, (target(hd,pmesh)) - <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a>);</div><div class="line">      ++n;</div><div class="line">    }</div><div class="line">    pt = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a> + (p - <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a>)/FT(n);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>In this example, the computation is based on the assumption that the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> is the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">CGAL::Point_3</a></code>. It is an assumption, but not a restriction. You are allowed to use any point class as long as it is defined as the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> in your polygon mesh. You may need to modify the geometry policy to support the computation and the assignment of the specialized point. This extension is not unusual in graphics applications. For example, you might want to subdivide the texture coordinates for your subdivision surface.</p>
<p>The refinement host of Catmull-Clark subdivision requires three geometry masks for polygon meshes without open boundaries: a vertex-node mask, an edge-node mask, and a face-node mask. To support polygon meshes with boundaries, a border-node mask is also required. The border-node mask for Catmull-Clark subdivision is listed below, where <code>ept</code> returns the new point splitting <code>edge</code> and <code>vpt</code> returns the new point on the vertex pointed by <code>edge</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> border_node(halfedge_descriptor edge, Point_3&amp; ept, Point_3&amp; vpt) {</div><div class="line">  Point_3 ep1 = <span class="keyword">get</span>(vpm, target(edge, pmesh));</div><div class="line">  Point_3 ep2 = <span class="keyword">get</span>(vpm, target(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(edge, pmesh), pmesh));</div><div class="line">  ept = Point_3((ep1[0]+ep2[0])/2, (ep1[1]+ep2[1])/2, (ep1[2]+ep2[2])/2);</div><div class="line"></div><div class="line">  Halfedge_around_target_circulator&lt;Poly&gt; vcir(edge, pmesh);</div><div class="line">  Point_3 vp1  = <span class="keyword">get</span>(vpm,target(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(*vcir, pmesh ), pmesh));</div><div class="line">  Point_3 vp0  = <span class="keyword">get</span>(vpm, target(*vcir, pmesh));</div><div class="line">  --vcir;</div><div class="line">  Point_3 vp_1 = <span class="keyword">get</span>(vpm, target(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(*vcir, pmesh), pmesh));</div><div class="line">  vpt = Point_3((vp_1[0] + 6*vp0[0] + vp1[0])/8,</div><div class="line">                (vp_1[1] + 6*vp0[1] + vp1[1])/8,</div><div class="line">                (vp_1[2] + 6*vp0[2] + vp1[2])/8 );</div><div class="line">}</div></div><!-- fragment --><p>The mask interfaces of all four refinement hosts are listed below. <code><a class="el" href="classDQQMask__3.html" title="Required member functions for the DQQMask_3 concept. This policy concept of geometric computations is...">DQQMask_3</a></code> does not have the border-node stencil because the refinement host of the DQQ refinement does not support global boundaries in the current release. This might change in future releases.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classPQQMask__3.html">PQQMask_3</a> {</div><div class="line">  <span class="keywordtype">void</span> face_node(boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor, Point_3&amp;);</div><div class="line">  <span class="keywordtype">void</span> edge_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor, Point_3&amp;);</div><div class="line">  <span class="keywordtype">void</span> vertex_node(boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor, Point_3&amp;);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> border_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor, Point_3&amp;, Point_3&amp;);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classPTQMask__3.html">PTQMask_3</a> {</div><div class="line">  <span class="keywordtype">void</span> edge_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor, Point_3&amp;);</div><div class="line">  <span class="keywordtype">void</span> vertex_node(boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor, Point_3&amp;);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> border_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor, Point_3&amp;, Point_3_&amp;);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classDQQMask__3.html">DQQMask_3</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> corner_node(boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor edge, Point_3&amp; pt);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classSqrt3Mask__3.html">Sqrt3Mask_3</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> vertex_node(boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor vertex, Point_3&amp; pt);</div><div class="line">};</div></div><!-- fragment --><p>The source codes of <code><a class="el" href="classCGAL_1_1CatmullClark__mask__3.html" title="The geometry mask of Catmull-Clark subdivision. ">CatmullClark_mask_3</a></code>, <code><a class="el" href="classCGAL_1_1Loop__mask__3.html" title="The geometry mask of Loop subdivision. ">Loop_mask_3</a></code>, <code><a class="el" href="classCGAL_1_1DooSabin__mask__3.html" title="The geometry mask of Doo-Sabin subdivision. ">DooSabin_mask_3</a></code>, and <code><a class="el" href="classCGAL_1_1Sqrt3__mask__3.html" title="The geometry mask of Sqrt(3) subdivision. ">Sqrt3_mask_3</a></code> are the best sources of learning these stencil interfaces.</p>
<h1><a class="anchor" id="Subdivision_method_3The"></a>
The Four Subdivision Methods</h1>
<p><code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> supports Catmull-Clark, Loop, Doo-Sabin and \( \sqrt{3}\) subdivisions by specializing their respective refinement hosts. They are designed to work on any model of a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> such as <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code>. If your application uses a polygon mesh with a specialized geometry kernel, you need to specialize the refinement host with a geometry policy based on that kernel.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Subdivision_method_3 {</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh, <span class="keyword">class</span> NamedParameters&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga04873e1be8efdf47ebb62b57d4d747af">CatmullClark_subdivision</a>(PolygonMesh&amp; pmesh, NamedParameters np) {</div><div class="line">    <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga55aee95359d4cf956b62704cc9783fc1">PQQ</a>(pmesh, CatmullClark_mask_3&lt;PolygonMesh&gt;(pmesh), np);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh, <span class="keyword">class</span> NamedParameters&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga7189d985dceac1b5952d938e0c7c8088">Loop_subdivision</a>(PolygonMesh&amp; pmesh, NamedParameters np) {</div><div class="line">    <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga03f5ebc46849e95dc27eb012b4c9e837">PTQ</a>(pmesh, Loop_mask_3&lt;PolygonMesh&gt;(pmesh) , np);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh, <span class="keyword">class</span> NamedParameters&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga58b8240103ea42aee039066173ec9a71">DooSabin_subdivision</a>(PolygonMesh&amp; pmesh, NamedParameters np) {</div><div class="line">    <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga5bc093e3cb186ca9eb88a457209da517">DQQ</a>(pmesh, DooSabin_mask_3&lt;PolygonMesh&gt;(pmesh), np);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PolygonMesh, <span class="keyword">class</span> NamedParameters&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga8c6eac3a8877da7311bfaaea7a7d3446">Sqrt3_subdivision</a>(PolygonMesh&amp; pmesh, NamedParameters np) {</div><div class="line">    <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga7b0187875bad4b47bf5b72a7577110ba">Sqrt3</a>(pmesh, Sqrt3_mask_3&lt;PolygonMesh&gt;(pmesh), np);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Subdivision_method_3Other"></a>
Example: Customizing a Subdivision Method</h1>
<p><code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> supports four practical subdivision methods on a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> with points with Cartesian coordinates. More subdivision methods can be supported through the specialization of refinement hosts with custom geometry masks. The following example develops a subdivision method generating an improved Loop subdivision surface.</p>
<p><br />
<b>File</b> <a class="el" href="Subdivision_method_3_2Customized_subdivision_8cpp-example.html">Subdivision_method_3/Customized_subdivision.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="subdivision__method__3_8h.html">CGAL/subdivision_method_3.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>      Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a> PolygonMesh;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a>;</div><div class="line"><span class="keyword">namespace </span>params = CGAL::parameters;</div><div class="line"></div><div class="line"><span class="comment">// ======================================================================</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Poly&gt;</div><div class="line"><span class="keyword">class </span>WLoop_mask_3 {</div><div class="line">  <span class="keyword">typedef</span> Poly                                         PolygonMesh;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor halfedge_descriptor;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::property_map&lt;PolygonMesh, vertex_point_t&gt;::type Vertex_pmap;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::property_traits&lt;Vertex_pmap&gt;::value_type Point;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::property_traits&lt;Vertex_pmap&gt;::reference Point_ref;</div><div class="line"></div><div class="line">  PolygonMesh&amp; pmesh;</div><div class="line">  Vertex_pmap vpm;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  WLoop_mask_3(PolygonMesh&amp; pmesh)</div><div class="line">    : pmesh(pmesh), vpm(get(<a class="code" href="namespaceCGAL.html">CGAL</a>::vertex_point, pmesh))</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> edge_node(halfedge_descriptor hd, Point&amp; pt) {</div><div class="line">    Point_ref p1 = <span class="keyword">get</span>(vpm, target(hd,pmesh));</div><div class="line">    Point_ref p2 = <span class="keyword">get</span>(vpm, target(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(hd,pmesh),pmesh));</div><div class="line">    Point_ref f1 = <span class="keyword">get</span>(vpm, target(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">next</a>(hd,pmesh),pmesh));</div><div class="line">    Point_ref f2 = <span class="keyword">get</span>(vpm, target(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">next</a>(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(hd,pmesh),pmesh),pmesh));</div><div class="line"></div><div class="line">    pt = Point((3*(p1[0]+p2[0])+f1[0]+f2[0])/8,</div><div class="line">               (3*(p1[1]+p2[1])+f1[1]+f2[1])/8,</div><div class="line">               (3*(p1[2]+p2[2])+f1[2]+f2[2])/8 );</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> vertex_node(vertex_descriptor vd, Point&amp; pt) {</div><div class="line">    <span class="keywordtype">double</span> R[] = {0.0, 0.0, 0.0};</div><div class="line">    Point_ref S = <span class="keyword">get</span>(vpm,vd);</div><div class="line"></div><div class="line">    std::size_t n = 0;</div><div class="line">    BOOST_FOREACH(halfedge_descriptor hd, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c">halfedges_around_target</a>(vd, pmesh)){</div><div class="line">      ++n;</div><div class="line">      Point_ref p = <span class="keyword">get</span>(vpm, target(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(hd,pmesh),pmesh));</div><div class="line">      R[0] += p[0];     R[1] += p[1];   R[2] += p[2];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (n == 6) {</div><div class="line">      pt = Point((10*S[0]+R[0])/16, (10*S[1]+R[1])/16, (10*S[2]+R[2])/16);</div><div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n == 3) {</div><div class="line">      <span class="keywordtype">double</span> B = (5.0/8.0 - <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(3+2*std::cos(6.283/n))/64.0)/n;</div><div class="line">      <span class="keywordtype">double</span> A = 1-n*B;</div><div class="line">      pt = Point((A*S[0]+B*R[0]), (A*S[1]+B*R[1]), (A*S[2]+B*R[2]));</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      <span class="keywordtype">double</span> B = 3.0/8.0/n;</div><div class="line">      <span class="keywordtype">double</span> A = 1-n*B;</div><div class="line">      pt = Point((A*S[0]+B*R[0]), (A*S[1]+B*R[1]), (A*S[2]+B*R[2]));</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> border_node(halfedge_descriptor hd, Point&amp; ept, Point&amp; vpt) {</div><div class="line">    Point_ref ep1 = <span class="keyword">get</span>(vpm, target(hd,pmesh));</div><div class="line">    Point_ref ep2 = <span class="keyword">get</span>(vpm, target(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(hd,pmesh),pmesh));</div><div class="line">    ept = Point((ep1[0]+ep2[0])/2, (ep1[1]+ep2[1])/2, (ep1[2]+ep2[2])/2);</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Halfedge__around__target__circulator.html">Halfedge_around_target_circulator&lt;Poly&gt;</a> vcir(hd,pmesh);</div><div class="line">    Point_ref vp1  = <span class="keyword">get</span>(vpm, target(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(*vcir,pmesh),pmesh));</div><div class="line">    Point_ref vp0  = <span class="keyword">get</span>(vpm, target(*vcir,pmesh));</div><div class="line">    --vcir;</div><div class="line">    Point_ref vp_1 = <span class="keyword">get</span>(vpm,target(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(*vcir,pmesh),pmesh));</div><div class="line">    vpt = Point((vp_1[0] + 6*vp0[0] + vp1[0])/8,</div><div class="line">                (vp_1[1] + 6*vp0[1] + vp1[1])/8,</div><div class="line">                (vp_1[2] + 6*vp0[2] + vp1[2])/8 );</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 4) {</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">"Usage: Customized_subdivision [d] [filename_in] [filename_out] \n"</span>;</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">"         d -- the depth of the subdivision (default: 1) \n"</span>;</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">"         filename_in -- the input mesh (.off) (default: data/quint_tris.off) \n"</span>;</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">"         filename_out -- the output mesh (.off) (default: result.off)"</span> &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> d = (argc &gt; 1) ? boost::lexical_cast&lt;int&gt;(argv[1]) : 1;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* in_file = (argc &gt; 2) ? argv[2] : <span class="stringliteral">"data/quint_tris.off"</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* out_file = (argc &gt; 3) ? argv[3] : <span class="stringliteral">"result.off"</span>;</div><div class="line"></div><div class="line">  PolygonMesh pmesh;</div><div class="line">  std::ifstream in(in_file);</div><div class="line">  <span class="keywordflow">if</span>(in.fail()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Could not open input file "</span> &lt;&lt; in_file &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  in &gt;&gt; pmesh;</div><div class="line"></div><div class="line">  Timer t;</div><div class="line">  t.start();</div><div class="line">  <a class="code" href="group__PkgSurfaceSubdivisionMethods3Functions.html#ga03f5ebc46849e95dc27eb012b4c9e837">Subdivision_method_3::PTQ</a>(pmesh, WLoop_mask_3&lt;PolygonMesh&gt;(pmesh), params::number_of_iterations(d));</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done ("</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::ofstream out(out_file);</div><div class="line">  out &lt;&lt; pmesh;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The points generated by the geometry mask are semantically required to converge to a smooth surface. This is the requirement imposed by the theory of the subdivision surface. <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> does not enforce this requirement, nor will it verify the smoothness of the subdivided mesh. <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> guarantees the topological properties of the subdivided mesh. A genus- \( n\) 2-manifold is assured to be subdivided into a genus- \( n\) 2-manifold. But when specialized with ill-designed geometry masks, <code><a class="el" href="namespaceCGAL_1_1Subdivision__method__3.html" title="The namespace containing the subdivision methods. ">Subdivision_method_3</a></code> may generate a surface that is odd, not smooth, or that does not even exist.</p>
<h1><a class="anchor" id="Subdivision_method_3History"></a>
Implementation History</h1>
<p>This package was initially developed by Le-Jeng Andy Shiue. For <span style="font-variant: small-caps;">CGAL</span> 4.11 it was generalized to work on any model of a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> by Andreas Fabri and Mael Rouxel-Labb. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:11 for CGAL 4.13 - 3D Surface Subdivision Methods by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
