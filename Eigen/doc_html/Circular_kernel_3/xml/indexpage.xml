<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_3D_Spherical_Geometry_Kernel"/><anchor id="index_1chaptersphericalkernel"/> <simplesect kind="authors"><para>Pedro Machado Manh<atilde/>es de Castro, Fr<eacute/>d<eacute/>ric Cazals, S<eacute/>bastien Loriot, and Monique Teillaud</para></simplesect>
</para><sect1 id="index_1Circular_kernel_3Introduction">
<title>Introduction</title>
<para>The goal of the 3D spherical kernel is to offer to the user a large set of functionalities on spheres, circles and circular arcs, in the 3D space or restricted on a given sphere. These functionalities require computing on algebraic numbers, which motivates the creation of a new kernel concept extending the CGAL <computeroutput><ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> concept, that is restricted to objects and functionality in a <computeroutput>FieldNumberType</computeroutput>.</para><para>All the choices (interface, robustness, representation, and so on) made here are consistent with the choices made in the CGAL kernel, for which we refer the user to the <ref refid="index_1chapterkernel23" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">2D and 3D Linear Kernel</ref>).</para></sect1>
<sect1 id="index_1sectionSKobjects">
<title>Spherical Kernel Objects</title>
<para>New main geometric objects are introduced by <computeroutput><ref refid="structCGAL_1_1Spherical__kernel__3" kindref="compound">Spherical_kernel_3</ref></computeroutput>: circular arcs ((model of <computeroutput><ref refid="classSphericalKernel_1_1CircularArc__3" kindref="compound">SphericalKernel::CircularArc_3</ref></computeroutput>), points of circular arcs (model of <computeroutput><ref refid="classSphericalKernel_1_1CircularArcPoint__3" kindref="compound">SphericalKernel::CircularArcPoint_3</ref></computeroutput>), and line segments (model of <computeroutput><ref refid="classSphericalKernel_1_1LineArc__3" kindref="compound">SphericalKernel::LineArc_3</ref></computeroutput>) whose endpoints are points of this new type.</para><para><computeroutput><ref refid="classSphericalKernel_1_1CircularArcPoint__3" kindref="compound">SphericalKernel::CircularArcPoint_3</ref></computeroutput> is used in particular for endpoints of arcs and intersection points between spheres, circles or arcs. The coordinates of these points are algebraic numbers of degree two. Therefore, general predicates offered by the <computeroutput><ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> on <computeroutput><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_3</ref></computeroutput>, which have coordinates in a <computeroutput>FieldNumberType</computeroutput>, would require heavy algebraic computations in algebraic extensions of higher degrees and thus are not provided on them, which explains the need for a new point type.</para><para>A consistent set of predicates and constructions is offered on these new types.</para><para><bold>General Functionalities</bold></para><para>The spherical kernel currently implements a set of fundamental functionalities like intersection, comparisons, inclusion, etc. More might be provided in the future, as long as only algebraic numbers of degree two are used.</para><para><bold>Functionalities Relative to a Sphere</bold></para><para>The interface of the underlying objects is extended by providing additional operations that make sense only if the objects are considered on the same sphere. For example, the result of the comparison of the cylindrical or spherical coordinates of two points is well-defined only when looking at them on a given common sphere. The presentation of these operations requires the following definitions:</para><para><emphasis>Coordinate system.</emphasis> Let consider a sphere with center <computeroutput>c</computeroutput> and radius <computeroutput>r</computeroutput>. Using the Cartesian frame centered at <computeroutput>c</computeroutput>, we define a cylindrical coordinate system <formula id="10">$ (\theta,z)$</formula> on that sphere, with <formula id="11">$ \theta \in \left[ 0,2\pi \right)$</formula> and <formula id="12">$ z \in \left[ -r,r \right]$</formula>. <formula id="7">$ \theta$</formula> is given in radian and measured in the <formula id="13">$ xy$</formula>-plane around the <formula id="6">$ z$</formula>-axis, starting from <formula id="14">$ x&gt;0$</formula>, <formula id="15">$ y=0$</formula>. The <formula id="6">$ z$</formula>-extremal points of a sphere are its North and South poles defined as <formula id="16">$ (\theta,r)$</formula> and <formula id="17">$ (\theta,-r)$</formula> respectively, for any value of <formula id="7">$ \theta$</formula>. Observe that each point on the sphere different from a pole corresponds to a unique pair <formula id="10">$ (\theta,z)$</formula>.</para><para><emphasis>Definition of a meridian.</emphasis> Given a sphere and its associated cylindrical coordinate system, a meridian of that sphere is a circular arc consisting of the points having the same theta-coordinate (the poles are the end points). A plane containing the two poles of that sphere defines two meridians, one on each side of the line passing through the poles. A vector <formula id="18">$ M$</formula> whose direction is different from that of the latter line defines a unique meridian on that sphere. The plane of that meridian is defined by the direction of <formula id="18">$ M$</formula> and the two poles. The sense of <formula id="18">$ M$</formula> disambiguates the choice among the pair of meridians thus defined. On <ref refid="index_1fig__figdefmeridian" kindref="member">fig__figdefmeridian</ref>, the normal vectors <formula id="19">$ n_0$</formula> and <formula id="20">$ n_1$</formula> define two meridians of <formula id="21">$ S$</formula>: the circular arcs <formula id="22">$ A_0$</formula> and <formula id="23">$ A_1$</formula> respectively.</para><para><anchor id="index_1fig__figdefmeridian"/><image type="html" name="def_meridian.png"></image>
 <image type="latex" name="def_meridian.png" width="15cm"></image>
  <ref refid="index_1fig__figdefmeridian" kindref="member">fig__figdefmeridian</ref> Definition of two meridians on <formula id="21">$ S$</formula>, a sphere of center <formula id="24">$ c$</formula>. The intersection of the plane <formula id="25">$ P$</formula> (passing through the two poles of <formula id="21">$ S$</formula>) and the sphere <formula id="21">$ S$</formula> is a circle. The two poles of <formula id="21">$ S$</formula> split that circle into two circular arcs <formula id="22">$ A_0$</formula> and <formula id="23">$ A_1$</formula>, each being a meridian of <formula id="21">$ S$</formula>. The <formula id="7">$ \theta$</formula>-coordinates of meridians <formula id="22">$ A_0$</formula> and <formula id="23">$ A_1$</formula> are <formula id="26">$ \theta_0$</formula> and <formula id="27">$ \theta_1= \theta_0 + \pi$</formula> respectively.  <linebreak/>
</para><para><emphasis>Types of circles on a sphere.</emphasis> Given a sphere, a circle on that sphere is termed <emphasis>polar</emphasis> if it goes through only one pole, <emphasis>bipolar</emphasis> if it goes through the two poles of that sphere and <emphasis>threaded</emphasis> if it separates the sphere into two connected components, each containing one pole. Any other circle is termed <emphasis>normal</emphasis>. These definitions are illustrated on <ref refid="index_1fig__figdefcircles" kindref="member">fig__figdefcircles</ref>.</para><para><anchor id="index_1fig__figdefcircles"/><image type="html" name="def_circles_extreme_pt.png"></image>
 <image type="latex" name="def_circles_extreme_pt.png" width="15cm"></image>
  <ref refid="index_1fig__figdefcircles" kindref="member">fig__figdefcircles</ref> The four types of circles on a sphere. Black dots are the <formula id="7">$ \theta$</formula>-extremal points.  <linebreak/>
</para><para><emphasis> <formula id="7">$ \theta$</formula>-extremal points.</emphasis> Given a sphere one has: a <emphasis> <formula id="7">$ \theta$</formula>-extremal point</emphasis> of a normal circle is a point of tangency between the circle and a meridian anchored at the poles of that sphere. Each normal circle defines two such points; the <formula id="7">$ \theta$</formula>-extremal point of a polar circle is the pole the circle goes through. No such point is defined on a bipolar or a threaded circle. These definitions are illustrated on <ref refid="index_1fig__figdefcircles" kindref="member">fig__figdefcircles</ref>. Notice that the <formula id="7">$ \theta$</formula>-extremal points should not be confused with the endpoints of an arbitrary arc on a sphere.</para><para>The <formula id="7">$ \theta$</formula>-coordinate of a <formula id="7">$ \theta$</formula>-extremal point of a normal circle on a sphere is well defined. For a polar circle on a sphere, the plane containing the two poles and which is tangent to that circle contains two different meridians. The <formula id="7">$ \theta$</formula>-values of these meridians are the two <formula id="7">$ \theta$</formula>-coordinates associated to the same <formula id="7">$ \theta$</formula>-extremal point of a polar circle.</para><para><emphasis> <formula id="7">$ \theta$</formula>-monotone circular arcs.</emphasis> An arc on a sphere is said to be <emphasis> <formula id="7">$ \theta$</formula>-monotone</emphasis> if any meridian on that sphere intersects that arc in at most one point. With this definition, a circular arc on a threaded circle is always <formula id="7">$ \theta$</formula>-monotone, and an arc on a polar or normal circle is <formula id="7">$ \theta$</formula>-monotone if it does not contain a <formula id="7">$ \theta$</formula>-extremal point, unless it is an endpoint. No such arc is defined on a bipolar circle.</para></sect1>
<sect1 id="index_1Circular_kernel_3Software">
<title>Software Design</title>
<para>The design of <computeroutput><ref refid="structCGAL_1_1Spherical__kernel__3" kindref="compound">Spherical_kernel_3</ref></computeroutput> is similar to the design of <computeroutput><ref refid="structCGAL_1_1Circular__kernel__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circular_kernel_2.tag">Circular_kernel_2</ref></computeroutput> (see Chapter <ref refid="index_1Chapter_2D_Circular_Geometry_Kernel" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circular_kernel_2.tag">2D Circular Geometry Kernel</ref>).</para><para>It has two template parameters: <itemizedlist>
<listitem>
<para>the first parameter must model the CGAL three dimensional <computeroutput><ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> concept. The spherical kernel derives from it, and it provides all elementary geometric objects like points, lines, spheres, circles and elementary functionality on them. </para></listitem>
<listitem>
<para>the second parameter is the algebraic kernel, which is responsible for computations on polynomials and algebraic numbers. It must model the concept <computeroutput><ref refid="classAlgebraicKernelForSpheres" kindref="compound">AlgebraicKernelForSpheres</ref></computeroutput>. The robustness of the package relies on the fact that the algebraic kernel provides exact computations on algebraic objects. </para></listitem>
</itemizedlist>
</para><para>The 3D spherical kernel uses the extensibility scheme presented in the kernel manual (see Section <ref refid="index_1sectionextensiblekernel" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Extensible Kernel</ref>). The types of <computeroutput><ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> are inherited by the 3D spherical kernel and some types are taken from the <computeroutput><ref refid="classAlgebraicKernelForSpheres" kindref="compound">AlgebraicKernelForSpheres</ref></computeroutput> parameter. <computeroutput><ref refid="structCGAL_1_1Spherical__kernel__3" kindref="compound">Spherical_kernel_3</ref></computeroutput> introduces new geometric objects as mentioned in Section <ref refid="index_1sectionSKobjects" kindref="member">Spherical Kernel Objects</ref>.</para><para>In fact, the spherical kernel is documented as a concept, <computeroutput><ref refid="classSphericalKernel" kindref="compound">SphericalKernel</ref></computeroutput> and two models are provided: <itemizedlist>
<listitem>
<para><computeroutput><ref refid="structCGAL_1_1Spherical__kernel__3" kindref="compound">Spherical_kernel_3</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>,<ref refid="classAlgebraicKernelForSpheres" kindref="compound">AlgebraicKernelForSpheres</ref>&gt;</computeroutput>, the basic kernel, </para></listitem>
<listitem>
<para>and a predefined kernel <computeroutput><ref refid="classCGAL_1_1Exact__spherical__kernel__3" kindref="compound">Exact_spherical_kernel_3</ref></computeroutput>. </para></listitem>
</itemizedlist>
</para></sect1>
<sect1 id="index_1Circular_kernel_3Examples">
<title>Examples</title>
<para>The first example shows how to construct spheres and compute intersections on them using the global function.</para><para><linebreak/>
<bold>File</bold> <ref refid="Circular_kernel_3_2intersecting_spheres_8cpp-example" kindref="compound">Circular_kernel_3/intersecting_spheres.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_spherical_kernel_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Random.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__spherical__kernel__3" kindref="compound">CGAL::Exact_spherical_kernel_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Spherical_k;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Point_3&lt;Spherical_k&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Sphere__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Sphere_3&lt;Spherical_k&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Sphere_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random<sp/>generatorOfgenerator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>random_seed<sp/>=<sp/>generatorOfgenerator.get_int(0,<sp/>123456);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random<sp/>theRandom(random_seed);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;We<sp/>will<sp/>compute<sp/>the<sp/>approximate<sp/>probability<sp/>that<sp/>3<sp/>spheres<sp/>wit&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;h<sp/>radius<sp/>1<sp/>intersect<sp/>on<sp/>a<sp/>5x5x5<sp/>box,<sp/>it<sp/>might<sp/>take<sp/>some<sp/>time.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;10000;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x1<sp/>=<sp/>theRandom.get_double(0.0,5.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y1<sp/>=<sp/>theRandom.get_double(0.0,5.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>z1<sp/>=<sp/>theRandom.get_double(0.0,5.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x2<sp/>=<sp/>theRandom.get_double(0.0,5.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y2<sp/>=<sp/>theRandom.get_double(0.0,5.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>z2<sp/>=<sp/>theRandom.get_double(0.0,5.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x3<sp/>=<sp/>theRandom.get_double(0.0,5.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y3<sp/>=<sp/>theRandom.get_double(0.0,5.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>z3<sp/>=<sp/>theRandom.get_double(0.0,5.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Sphere_3<sp/>s1<sp/>=<sp/>Sphere_3(Point_3(x1,y1,z1),<sp/>r);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Sphere_3<sp/>s2<sp/>=<sp/>Sphere_3(Point_3(x2,y2,z2),<sp/>r);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Sphere_3<sp/>s3<sp/>=<sp/>Sphere_3(Point_3(x3,y3,z3),<sp/>r);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;<sp/>CGAL::Object<sp/>&gt;<sp/>intersecs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__intersection__linear__grp_1gab77f3cd98c4c4ff7acff59c98ab88ff0" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::intersection</ref>(s1,<sp/>s2,<sp/>s3,<sp/>std::back_inserter(intersecs));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(intersecs.size()<sp/>&gt;<sp/>0)<sp/>count++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>approximate<sp/>probability<sp/>that<sp/>3<sp/>spheres<sp/>with<sp/>radius<sp/>1&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;choosen<sp/>(uniformly)<sp/>randomly<sp/>on<sp/>a<sp/>5x5x5<sp/>box<sp/>intersect<sp/>is:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>((double)count)/((double)(10000))<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The second example illustrates the use of a functor.</para><para><linebreak/>
<bold>File</bold> <ref refid="Circular_kernel_3_2functor_has_on_3_8cpp-example" kindref="compound">Circular_kernel_3/functor_has_on_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_spherical_kernel_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Random.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__spherical__kernel__3" kindref="compound">CGAL::Exact_spherical_kernel_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Spherical_k;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Point_3&lt;Spherical_k&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Circular__arc__3" kindref="compound">CGAL::Circular_arc_3&lt;Spherical_k&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Circular_arc_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Circular_arc_3<sp/>c<sp/>=<sp/>Circular_arc_3(Point_3(10,10,0),<sp/>Point_3(5,5,5),<sp/>Point_3(0,<sp/>0,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;=<sp/>10;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;=<sp/>10;<sp/>j++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;=<sp/>10;<sp/>k++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>p<sp/>=<sp/>Point_3(i,<sp/>j,<sp/>k);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(Spherical_k().has_on_3_object()(c,p))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>j<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;There<sp/>are<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points<sp/>in<sp/>the<sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[0,..,10]x[0,..,10]x[0,...,10]<sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;grid<sp/>on<sp/>the<sp/>circular&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>arc<sp/>defined<sp/>by<sp/>the<sp/>points<sp/>(10,10,0),<sp/>(5,5,5),<sp/>(0,0,0)&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;See<sp/>the<sp/>points<sp/>above.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The third example illustrates the use of a functor on objects on the same sphere. The intersection points of two circles on the same sphere are computed and their cylindrical coordinates are then compared.</para><para><linebreak/>
<bold>File</bold> <ref refid="Circular_kernel_3_2functor_compare_theta_3_8cpp-example" kindref="compound">Circular_kernel_3/functor_compare_theta_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_spherical_kernel_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__spherical__kernel__3" kindref="compound">CGAL::Exact_spherical_kernel_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SK;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//construction<sp/>of<sp/>3<sp/>spheres<sp/>from<sp/>their<sp/>centers<sp/>and<sp/>squared<sp/>radii</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SK::Sphere_3<sp/>s1(SK::Point_3(0,0,0),2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SK::Sphere_3<sp/>s2(SK::Point_3(0,1,0),1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SK::Sphere_3<sp/>s3(SK::Point_3(1,0,0),3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//construct<sp/>two<sp/>circles<sp/>lying<sp/>on<sp/>sphere<sp/>s1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SK::Circle_3<sp/>C1(s1,s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SK::Circle_3<sp/>C2(s1,s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SK::Intersect_3<sp/>inter;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//create<sp/>a<sp/>functor<sp/>to<sp/>compare<sp/>theta-coordinates<sp/>on<sp/>sphere<sp/>s1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SK::Compare_theta_z_3<sp/>cmp(s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;<sp/>CGAL::Object<sp/>&gt;<sp/>intersections;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>inter(C1,C2,std::back_inserter(intersections));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>integer<sp/>indicates<sp/>multiplicity<sp/>of<sp/>intersection<sp/>point<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::pair&lt;SK::Circular_arc_point_3,unsigned&gt;<sp/>p1=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::object_cast&lt;<sp/>std::pair&lt;SK::Circular_arc_point_3,unsigned&gt;<sp/>&gt;(intersections[0]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::pair&lt;SK::Circular_arc_point_3,unsigned&gt;<sp/>p2=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::object_cast&lt;<sp/>std::pair&lt;SK::Circular_arc_point_3,unsigned&gt;<sp/>&gt;(intersections[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SK::Circular_arc_point_3<sp/>t_extreme[2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Compute<sp/>theta<sp/>extremal<sp/>points<sp/>of<sp/>circle<sp/>C1<sp/>on<sp/>sphere<sp/>s1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgSphericalKernel3GeometricFunctions_1gafd5abb1f2ccbe293a18bf5f777fc6b70" kindref="member">CGAL::theta_extremal_points</ref>(C1,s1,t_extreme);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//The<sp/>theta<sp/>coordinates<sp/>of<sp/>theta<sp/>extremal<sp/>points<sp/>of<sp/>C1<sp/>enclose<sp/>that<sp/>of<sp/>each<sp/>intersection<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(cmp(t_extreme[0],p1.first)==<ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::SMALLER</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(cmp(t_extreme[0],p2.first)==<ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::SMALLER</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(cmp(t_extreme[1],p1.first)==<ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab25bdbfd193e9ea35187a4f46e7d6fcd" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::LARGER</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(cmp(t_extreme[1],p2.first)==<ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab25bdbfd193e9ea35187a4f46e7d6fcd" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::LARGER</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1Circular_kernel_3Design">
<title>Design and Implementation History</title>
<para>This package follows the design of the package <ref refid="index_1Chapter_2D_Circular_Geometry_Kernel" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circular_kernel_2.tag">2D Circular Geometry Kernel</ref>).</para><para>Julien Hazebrouck and Damien Leroy participated in a first prototype.</para><para>The first version of the package was co-authored by Pedro Machado Manh<atilde/>es de Castro and Monique Teillaud, and integrated in <ref refid="namespaceCGAL" kindref="compound">CGAL</ref> 3.4. Fr<eacute/>d<eacute/>ric Cazals and S<eacute/>bastien Loriot extended the package by providing functionalities restricted on a given sphere <ref refid="citelist_1CITEREF_cclt-dc3sk-08" kindref="member">[1]</ref>.</para><para>Sylvain Pion is acknowledged for helpful discussions.</para><para>This work was partially supported by the IST Programme of the 6th Framework Programme of the EU as a STREP (FET Open Scheme) Project under Contract No IST-006413 (ACS - Algorithms for Complex Shapes). </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
