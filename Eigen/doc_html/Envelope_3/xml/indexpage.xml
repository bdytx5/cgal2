<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Envelopes_of_Surfaces_in_3D"/> <anchor id="index_1chapterEnvelope3"/>  <simplesect kind="authors"><para>Dan Halperin, Michal Meyerovitch, Ron Wein, and Baruch Zukerman</para></simplesect>
</para><sect1 id="index_1Envelope_3Introduction">
<title>Introduction</title>
<para>A continuous surface <formula id="21">$ S$</formula> in <formula id="22">$ {\mathbb R}^3$</formula> is called <emphasis> <formula id="4">$ xy$</formula>-monotone</emphasis>, if every line parallel to the <formula id="10">$ z$</formula>-axis intersects it at a single point at most. For example, the sphere <formula id="23">$ x^2 + y^2 + z^2 = 1$</formula> is <emphasis>not</emphasis> <formula id="4">$ xy$</formula>-monotone as the <formula id="10">$ z$</formula>-axis intersects it at <formula id="24">$ (0, 0, -1)$</formula> and at <formula id="25">$ (0, 0, 1)$</formula>; however, if we use the <formula id="4">$ xy$</formula>-plane to split it to an upper hemisphere and a lower hemisphere, these two hemispheres are <formula id="4">$ xy$</formula>-monotone.</para><para>An <formula id="4">$ xy$</formula>-monotone surface can therefore be represented as a bivariate function <formula id="26">$ z = S(x,y)$</formula>, defined over some continuous range <formula id="27">$ R_S \subseteq {\mathbb R}^2$</formula>. Given a set <formula id="28">$ {\cal S} = \{ S_1, S_2, \ldots, S_n \}$</formula> of <formula id="4">$ xy$</formula>-monotone surfaces, their <emphasis>lower envelope</emphasis> is defined as the point-wise minimum of all surfaces. Namely, the lower envelope of the set <formula id="29">$ {\cal S}$</formula> can be defined as the following function: <formula id="30">\begin{eqnarray*} {\cal L}_{{\cal S}} (x,y) = \min_{1 \leq k \leq n}{\overline{S}_k (x,y)} \ , \end{eqnarray*}</formula> where we define <formula id="31">$\overline{S}_k(x,y) = S_k(x,y)$</formula> for <formula id="32">$(x,y) \in R_{S_k}$</formula>, and <formula id="33">$\overline{S}_k(x,y) = \infty$</formula> otherwise.</para><para>Similarly, the <emphasis>upper envelope</emphasis> of <formula id="34">${\cal S}$</formula> is the point-wise maximum of the <formula id="35">$xy$</formula>-monotone surfaces in the set: <formula id="36">\begin{eqnarray*} {\cal U}_{{\cal S}} (x,y) = \max_{1 \leq k \leq n}{\underline{S}_k (x,y)} \ , \end{eqnarray*}</formula> where in this case <formula id="37">$ \underline{S}_k(x,y) = -\infty$</formula> for <formula id="38">$ (x,y) \not\in R_{S_k}$</formula>.</para><para>Given a set of <formula id="4">$ xy$</formula>-monotone surfaces <formula id="29">$ {\cal S}$</formula>, the <emphasis>minimization diagram</emphasis> of <formula id="29">$ {\cal S}$</formula> is a subdivision of the <formula id="4">$ xy$</formula>-plane into cells, such that the identity of the surfaces that induce the lower diagram over a specific cell of the subdivision (be it a face, an edge, or a vertex) is the same. In non-degenerate situation, a face is induced by a single surface (or by no surfaces at all, if there are no <formula id="4">$ xy$</formula>-monotone surfaces defined over it), an edge is induced by a single surface and corresponds to its projected boundary, or by two surfaces and corresponds to their projected intersection curve, and a vertex is induced by a single surface and corresponds to its projected boundary point, or by three surfaces and corresponds to their projected intersection point. The <emphasis>maximization diagram</emphasis> is symmetrically defined for upper envelopes. In the rest of this chapter, we refer to both these diagrams as <emphasis>envelope diagrams</emphasis>.</para><para>It is easy to see that an envelope diagram is no more than a planar arrangement (see Chapter <ref refid="index_1chapterArrangement_on_surface_2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">2D Arrangements</ref>), represented using an extended Dcel structure, such that every Dcel record (namely each face, halfedge and vertex) stores an additional container of it originators: the <formula id="4">$ xy$</formula>-monotone surfaces that induce this feature.</para><para>Lower and upper envelopes can be efficiently computed using a divide-and-conquer approach. First note that the envelope diagram for a single <formula id="4">$ xy$</formula>-monotone curve <formula id="39">$ S_k$</formula> is trivial to compute: we project the boundary of its range of definition <formula id="40">$ R_{S_k}$</formula> onto the <formula id="4">$ xy$</formula>-plane, and label the faces it induces accordingly. Given a set <formula id="41">$ {\cal D}$</formula> of (non necessarily <formula id="4">$ xy$</formula>-monotone) surfaces in <formula id="22">$ {\mathbb R}^3$</formula>, we subdivide each surface into a finite number of weakly <formula id="4">$ xy$</formula>-monotone surfaces, We consider <emphasis>vertical</emphasis> surfaces, namely patches of planes that are perpendicular to the <formula id="4">$ xy$</formula>-plane, as <emphasis>weakly</emphasis> <formula id="4">$ xy$</formula>-monotone, to handle degenerate inputs properly. and obtain the set <formula id="29">$ {\cal S}$</formula>. Then, we split the set into two disjoint subsets <formula id="42">$ {\cal S}_1$</formula> and <formula id="43">$ {\cal S}_2$</formula>, and we compute their envelope diagrams recursively. Finally, we merge the diagrams, and we do this by overlaying them and then applying some post-processing on the resulting diagram. The post-processing stage is non-trivial and involves the projection of intersection curves onto the <formula id="4">$ xy$</formula>-plane - see <ref refid="citelist_1CITEREF_cgal:m-rgece-06" kindref="member">[1]</ref> for more details.</para></sect1>
<sect1 id="index_1Envelope_3The">
<title>The Envelope-Traits Concept</title>
<para>The implementation of the envelope-computation algorithm is generic and can handle arbitrary surfaces. It is parameterized with a traits class, which defines the geometry of surfaces it handles, and supports all the necessary functionality on these surfaces, and on their projections onto the <formula id="4">$ xy$</formula>-plane. The traits class must model the <computeroutput><ref refid="classEnvelopeTraits__3" kindref="compound">EnvelopeTraits_3</ref></computeroutput> concept, the details of which are given below.</para><para>As the representation of envelope diagrams is based on 2D arrangements, and the envelop-computation algorithm employs overlay of planar arrangements, the <computeroutput><ref refid="classEnvelopeTraits__3" kindref="compound">EnvelopeTraits_3</ref></computeroutput> refines the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Namely, a model of this concept must define the planar types <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> and <computeroutput>X_monotone_curve_2</computeroutput> and support basic operations on them, as listed in Section <ref refid="index_1arr_sectraits" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Traits Classes</ref>. Moreover, it must define the spacial types <computeroutput>Surface_3</computeroutput> and <computeroutput>Xy_monotone_surface_3</computeroutput> (in practice, these two types may be the same). Any model of the envelope-traits concept must also support the following operations on these spacial types:</para><para><anchor id="index_1fig__env3_figcomp_over"/><center> <table rows="2" cols="2"><row>
<entry thead="no"><para><image type="html" name="compare_over_point.png"></image>
 <image type="latex" name="compare_over_point.png"></image>
  </para></entry><entry thead="no"><para><image type="html" name="compare_over_curve.png"></image>
 <image type="latex" name="compare_over_curve.png"></image>
   </para></entry></row>
<row>
<entry thead="no"><para>(a)</para></entry><entry thead="no"><para>(b) </para></entry></row>
</table>
</center>  <ref refid="index_1fig__env3_figcomp_over" kindref="member">fig__env3_figcomp_over</ref> (a) The spheres <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula> have only one two-dimensional point <formula id="20">$ p$</formula> in their common <formula id="4">$ xy$</formula>-definition range. They do not necessarily intersect over this point, and the envelope-construction algorithm needs to determine their relative <formula id="10">$ z$</formula>-order over <formula id="20">$ p$</formula>. (b) The <formula id="10">$ z$</formula>-order of the surfaces <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula> should be determined over the <formula id="5">$ x$</formula>-monotone curve <formula id="13">$ c$</formula>. The comparison is performed over the <emphasis>interior</emphasis> of <formula id="13">$ c$</formula>, excluding its endpoints.  <linebreak/>
</para><para><itemizedlist>
<listitem>
<para>Subdivide a given surface into continuous <formula id="4">$ xy$</formula>-monotone surfaces. It is possible to disregard <formula id="4">$ xy$</formula>-monotone surfaces that do not contribute to the surface envelope at this stage (for example, if we are given a sphere, it is possible to return just its lower hemisphere if we are interested in the lower envelope; the upper hemisphere is obviously redundant). </para></listitem>
<listitem>
<para>Given an <formula id="4">$ xy$</formula>-monotone surface <formula id="21">$ S$</formula>, construct all planar curves that form the boundary of the vertical projection <formula id="21">$ S$</formula>&apos;s boundary onto the <formula id="4">$ xy$</formula>-plane.</para><para>This operation is used at the bottom of the recursion to build the minimization diagram of a single <formula id="4">$ xy$</formula>-monotone surface. </para></listitem>
<listitem>
<para>Construct all geometric entities that comprise the projection (onto the <formula id="4">$ xy$</formula>-plane) of the intersection between two <formula id="4">$ xy$</formula>-monotone surfaces <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula>. These entities may be: <itemizedlist>
<listitem>
<para>A planar curve, which is the projection of an 3D intersection curve of <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula> (for example, the intersection curve between two spheres is a 3D circle, which becomes an ellipse when projected onto the <formula id="4">$ xy$</formula>-plane). In many cases it is also possible to indicate the multiplicity of the intersection: if it is odd, the two surfaces intersect transversely and change their relative <formula id="10">$ z$</formula>-positions on either side of the intersection curve; if it the multiplicity is even, they maintain their relative <formula id="10">$ z$</formula>-position. Providing the multiplicity information is optional. When provided, it is used by the algorithm to determine the relative order of <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula> on one side of their intersection curve when their order on the other side of that curve is known, thus improving the performance of the algorithm. </para></listitem>
<listitem>
<para>A point, induces by the projection of a tangency point of <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula>, <emphasis>or</emphasis> by the projection of a vertical intersection curve onto the <formula id="4">$ xy$</formula>-plane. </para></listitem>
</itemizedlist>
Needless to say, the set of intersection entities may be empty in case <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula> do not intersect. </para></listitem>
<listitem>
<para>Given two <formula id="4">$ xy$</formula>-monotone surfaces <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula>, and a planar point <formula id="46">$ p = (x_0,y_0)$</formula> that lies in their common <formula id="4">$ xy$</formula>-definition range, determine the <formula id="10">$ z$</formula>-order of <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula> over <formula id="20">$ p$</formula>, namely compare <formula id="47">$ S_1(x_0,y_0)$</formula> and <formula id="48">$ S_2(x_0,y_0)$</formula>. This operation is used only in degenerate situations, in order to determine the surface inducing the envelope over a vertex (see <ref refid="index_1fig__env3_figcomp_over" kindref="member">fig__env3_figcomp_over</ref> (a) for an illustration of a situation when this operation is used). </para></listitem>
<listitem>
<para>Given two <formula id="4">$ xy$</formula>-monotone surfaces <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula>, and a planar <formula id="5">$ x$</formula>-monotone curve <formula id="13">$ c$</formula>, which is a part of their projected intersection, determine the <formula id="10">$ z$</formula>-order of <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula> immediately above (or, similarly, immediately below) the curve <formula id="13">$ c$</formula>. Note that <formula id="13">$ c$</formula> is a planar <formula id="5">$ x$</formula>-monotone curve, and we refer to the region above (or below) it in the <emphasis>plane</emphasis>. If <formula id="13">$ c$</formula> is a vertical curve, we regard the region to its left as lying above it, and the region to its right as lying below it.</para><para>This operation is used by the algorithm to determine the surface that induce the envelope over a face incident to <formula id="13">$ c$</formula>. </para></listitem>
<listitem>
<para>Given two <formula id="4">$ xy$</formula>-monotone surfaces <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula>, and a planar <formula id="5">$ x$</formula>-monotone curve <formula id="13">$ c$</formula>, which fully lies in their common <formula id="4">$ xy$</formula>-definition range, and such that <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula> do not intersect over the interior of <formula id="13">$ c$</formula>, determine the relative <formula id="10">$ z$</formula>-order of <formula id="14">$ s_1$</formula> and <formula id="15">$ s_2$</formula> over the interior of <formula id="13">$ c$</formula>. Namely, we compare <formula id="47">$ S_1(x_0,y_0)$</formula> and <formula id="48">$ S_2(x_0,y_0)$</formula> for some point <formula id="49">$ (x_0, y_0)$</formula> on <formula id="13">$ c$</formula>.</para><para>This operation is used by the algorithm to determine which surface induce the envelope over an edge associated with the <formula id="5">$ x$</formula>-monotone curve <formula id="13">$ c$</formula>, or of a face incident to <formula id="13">$ c$</formula>, in situations where the previous predicate cannot be used, as <formula id="13">$ c$</formula> is <emphasis>not</emphasis> an intersection curve of <formula id="44">$ S_1$</formula> and <formula id="45">$ S_2$</formula> (see <ref refid="index_1fig__env3_figcomp_over" kindref="member">fig__env3_figcomp_over</ref> (b) for an illustration of a situation where this operation is used). </para></listitem>
</itemizedlist>
</para><para>The package currently contains a traits class for named <computeroutput><ref refid="classCGAL_1_1Env__triangle__traits__3" kindref="compound">Env_triangle_traits_3</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> handling 3D triangles, and another named <computeroutput><ref refid="classCGAL_1_1Env__sphere__traits__3" kindref="compound">Env_sphere_traits_3</ref>&lt;ConicTraits&gt;</computeroutput> for 3D spheres, based on geometric operations on conic curves (ellipses). In addition, the package includes a traits-class decorator that enables users to attach external (non-geometric) data to surfaces. The usage of the various traits classes is demonstrated in the next section.</para></sect1>
<sect1 id="index_1Envelope_3Examples">
<title>Examples</title>
<sect2 id="index_1Envelope_3ExampleforEnvelopeofTriangles">
<title>Example for Envelope of Triangles</title>
<para><anchor id="index_1fig__env3_figex_tri"/><center> <table rows="2" cols="3"><row>
<entry thead="no"><para><image type="html" name="ex_triangles.png"></image>
 <image type="latex" name="ex_triangles.png"></image>
  </para></entry><entry thead="no"><para><image type="html" name="ex_tri_le.png"></image>
 <image type="latex" name="ex_tri_le.png"></image>
  </para></entry><entry thead="no"><para><image type="html" name="ex_tri_ue.png"></image>
 <image type="latex" name="ex_tri_ue.png"></image>
  </para></entry></row>
<row>
<entry thead="no"><para>(a)</para></entry><entry thead="no"><para>(b)</para></entry><entry thead="no"><para>(c) </para></entry></row>
</table>
</center>  <ref refid="index_1fig__env3_figex_tri" kindref="member">fig__env3_figex_tri</ref> (a) Two triangles in <formula id="22">$ {\mathbb R}^3$</formula>, as given in <computeroutput>envelope_triangles.cpp</computeroutput>. (b) Their lower envelope. (c) Their upper envelope.  <linebreak/>
</para><para>The following example shows how to use the envelope-traits class for 3D triangles and how to traverse the envelope diagram. It constructs the lower and upper envelopes of the two triangles, as depicted in <ref refid="index_1fig__env3_figex_tri" kindref="member">fig__env3_figex_tri</ref> (a) and prints the triangles that induce each face and each edge in the output diagrams. For convenience, we use the traits-class decorator <computeroutput><ref refid="classCGAL_1_1Env__surface__data__traits__3" kindref="compound">Env_surface_data_traits_3</ref></computeroutput> to label the triangles. When printing the diagrams, we just output the labels of the triangles:</para><para><linebreak/>
<bold>File</bold> <ref refid="Envelope_3_2envelope_triangles_8cpp-example" kindref="compound">Envelope_3/envelope_triangles.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>the<sp/>lower<sp/>and<sp/>the<sp/>upper<sp/>envelope<sp/>of<sp/>a<sp/>set<sp/>of<sp/>triangles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_rational.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Env_triangle_traits_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Env_surface_data_traits_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/envelope_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Env__triangle__traits__3" kindref="compound">CGAL::Env_triangle_traits_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_3::Surface_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangle_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Env__surface__data__traits__3" kindref="compound">CGAL::Env_surface_data_traits_3&lt;Traits_3, char&gt;</ref><sp/><sp/>Data_traits_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Data_traits_3::Surface_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Data_triangle_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Envelope__diagram__2" kindref="compound">CGAL::Envelope_diagram_2&lt;Data_traits_3&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Envelope_diagram_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Auxiliary<sp/>function<sp/>-<sp/>print<sp/>the<sp/>features<sp/>of<sp/>the<sp/>given<sp/>envelope<sp/>diagram.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_diagram<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Envelope_diagram_2&amp;<sp/>diag)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>faces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Envelope_diagram_2::Face_const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Envelope_diagram_2::Ccb_halfedge_const_circulator<sp/><sp/>ccb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Envelope__diagram__2_1a8a2c4c2adcc103537b08f0a9475d4084" kindref="member">Envelope_diagram_2::Surface_const_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>diag.faces_begin();<sp/>fit<sp/>!=<sp/>diag.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>face<sp/>boundary.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fit-&gt;is_unbounded())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[Unbounded<sp/>face]&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>vertices<sp/>along<sp/>the<sp/>outer<sp/>boundary<sp/>of<sp/>the<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ccb<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[Face]<sp/><sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;(&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>ccb-&gt;target()-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/><sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++ccb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(ccb<sp/>!=<sp/>fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>labels<sp/>of<sp/>the<sp/>triangles<sp/>that<sp/>induce<sp/>the<sp/>envelope<sp/>on<sp/>this<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;--&gt;<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fit-&gt;number_of_surfaces()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>triangles:&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(sit<sp/>=<sp/>fit-&gt;surfaces_begin();<sp/>sit<sp/>!=<sp/>fit-&gt;surfaces_end();<sp/>++sit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>sit-&gt;data();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>edges.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Envelope_diagram_2::Edge_const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>eit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(eit<sp/>=<sp/>diag.edges_begin();<sp/>eit<sp/>!=<sp/>diag.edges_end();<sp/>++eit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>labels<sp/>of<sp/>the<sp/>triangles<sp/>that<sp/>induce<sp/>the<sp/>envelope<sp/>on<sp/>this<sp/>edge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[Edge]<sp/><sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;source()-&gt;point()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/><sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;target()-&gt;point()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/><sp/>--&gt;<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;number_of_surfaces()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>triangles:&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(sit<sp/>=<sp/>eit-&gt;surfaces_begin();<sp/>sit<sp/>!=<sp/>eit-&gt;surfaces_end();<sp/>++sit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>sit-&gt;data();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>The<sp/>main<sp/>program:<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>input<sp/>triangles,<sp/>makred<sp/>A<sp/>and<sp/>B.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Data_triangle_3&gt;<sp/><sp/><sp/>triangles;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>triangles.push_back<sp/>(Data_triangle_3<sp/>(Triangle_3<sp/>(Point_3<sp/>(0,<sp/>0,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3<sp/>(0,<sp/>6,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3<sp/>(5,<sp/>3,<sp/>4)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="charliteral">&apos;A&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>triangles.push_back<sp/>(Data_triangle_3<sp/>(Triangle_3<sp/>(Point_3<sp/>(6,<sp/>0,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3<sp/>(6,<sp/>6,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3<sp/>(1,<sp/>3,<sp/>4)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="charliteral">&apos;B&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>and<sp/>print<sp/>the<sp/>minimization<sp/>diagram.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Envelope_diagram_2<sp/><sp/><sp/><sp/><sp/><sp/>min_diag;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgEnvelope3_1gafd8dc9fadb187466e4c567099ec1a443" kindref="member">CGAL::lower_envelope_3</ref><sp/>(triangles.begin(),<sp/>triangles.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>min_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>minimization<sp/>diagram:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_diagram<sp/>(min_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>and<sp/>print<sp/>the<sp/>maximization<sp/>diagram.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Envelope_diagram_2<sp/><sp/><sp/><sp/><sp/><sp/>max_diag;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgEnvelope3_1ga1fbbe89e27c3dc3404bbbb3b1f7ceea1" kindref="member">CGAL::upper_envelope_3</ref><sp/>(triangles.begin(),<sp/>triangles.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>maximization<sp/>diagram:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_diagram<sp/>(max_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Envelope_3ExampleforEnvelopeofSpheres">
<title>Example for Envelope of Spheres</title>
<para>The next example demonstrates how to instantiate and use the envelope-traits class for spheres, based on the <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_conic_traits_2</ref></computeroutput> class that handles the projected intersecion curves. The program reads a set of spheres from an input file and constructs their lower envelope:</para><para><linebreak/>
<bold>File</bold> <ref refid="Envelope_3_2envelope_spheres_8cpp-example" kindref="compound">Envelope_3/envelope_spheres.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>the<sp/>lower<sp/>envelope<sp/>of<sp/>a<sp/>set<sp/>of<sp/>spheres<sp/>read<sp/>from<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/CORE_algebraic_number_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_conic_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Env_sphere_traits_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/envelope_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::CORE_algebraic_number_traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nt_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rational;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Algebraic<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rat_kernel::Point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Algebraic&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alg_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_conic_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Conic_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Env__sphere__traits__3" kindref="compound">CGAL::Env_sphere_traits_3&lt;Conic_traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/>Traits_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_3::Surface_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Sphere_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Envelope__diagram__2" kindref="compound">CGAL::Envelope_diagram_2&lt;Traits_3&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Envelope_diagram_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>**argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>fan_grids.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;spheres.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/><sp/><sp/><sp/><sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>spheres<sp/>from<sp/>the<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>input<sp/>file<sp/>format<sp/>should<sp/>be<sp/>(all<sp/>coordinate<sp/>values<sp/>are<sp/>integers):</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>number<sp/>of<sp/>spheres.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;x_1&gt;<sp/>&lt;y_1&gt;<sp/>&lt;x_1&gt;<sp/>&lt;R_1&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>center<sp/>and<sp/>squared<sp/>radious<sp/>of<sp/>sphere<sp/>#1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;x_2&gt;<sp/>&lt;y_2&gt;<sp/>&lt;x_2&gt;<sp/>&lt;R_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>center<sp/>and<sp/>squared<sp/>radious<sp/>of<sp/>sphere<sp/>#2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;x_n&gt;<sp/>&lt;y_n&gt;<sp/>&lt;x_n&gt;<sp/>&lt;R_n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>center<sp/>and<sp/>squared<sp/>radious<sp/>of<sp/>sphere<sp/>#n.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Sphere_3&gt;<sp/><sp/><sp/>spheres;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x<sp/>=<sp/>0,<sp/>y<sp/>=<sp/>0,<sp/>z<sp/>=<sp/>0,<sp/>sqr_r<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>x<sp/>&gt;&gt;<sp/>y<sp/>&gt;&gt;<sp/>z<sp/>&gt;&gt;<sp/>sqr_r;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>spheres.push_back(Sphere_3(Rat_point_3(x,<sp/>y,<sp/>z),<sp/>Rational(sqr_r)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>lower<sp/>envelope.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Envelope_diagram_2<sp/><sp/><sp/><sp/>min_diag;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Timer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Constructing<sp/>the<sp/>lower<sp/>envelope<sp/>of<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>spheres.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgEnvelope3_1gafd8dc9fadb187466e4c567099ec1a443" kindref="member">CGAL::lower_envelope_3</ref>(spheres.begin(),<sp/>spheres.end(),<sp/>min_diag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.stop();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>dimensions<sp/>of<sp/>the<sp/>minimization<sp/>diagram.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>min_diag.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>min_diag.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>min_diag.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construction<sp/>took<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>timer.time()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Envelope_3ExampleforEnvelopeofPlanes">
<title>Example for Envelope of Planes</title>
<para>The next example demonstrates how to instantiate and use the envelope-traits class for planes, based on the <computeroutput><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_linear_traits_2</ref></computeroutput> class that handles infinite linear objects such as lines and rays.</para><para><linebreak/>
<bold>File</bold> <ref refid="Envelope_3_2envelope_planes_8cpp-example" kindref="compound">Envelope_3/envelope_planes.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>the<sp/>lower<sp/>and<sp/>the<sp/>upper<sp/>envelope<sp/>of<sp/>a<sp/>set<sp/>of<sp/>planes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_rational.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Env_plane_traits_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/envelope_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Plane__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Plane_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Plane_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Env__plane__traits__3" kindref="compound">CGAL::Env_plane_traits_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_3::Surface_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Surface_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Envelope__diagram__2" kindref="compound">CGAL::Envelope_diagram_2&lt;Traits_3&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Envelope_diagram_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Auxiliary<sp/>function<sp/>-<sp/>print<sp/>the<sp/>features<sp/>of<sp/>the<sp/>given<sp/>envelope<sp/>diagram.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_diagram<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Envelope_diagram_2&amp;<sp/>diag)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>faces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Envelope_diagram_2::Face_const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Envelope_diagram_2::Ccb_halfedge_const_circulator<sp/><sp/>ccb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Envelope__diagram__2_1a8a2c4c2adcc103537b08f0a9475d4084" kindref="member">Envelope_diagram_2::Surface_const_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>diag.faces_begin();<sp/>fit<sp/>!=<sp/>diag.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>face<sp/>boundary.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>vertices<sp/>along<sp/>the<sp/>outer<sp/>boundary<sp/>of<sp/>the<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ccb<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[Face]<sp/><sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!ccb-&gt;is_fictitious())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;(&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>ccb-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++ccb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(ccb<sp/>!=<sp/>fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>planes<sp/>that<sp/>induce<sp/>the<sp/>envelope<sp/>on<sp/>this<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;--&gt;<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fit-&gt;number_of_surfaces()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>planes:&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(sit<sp/>=<sp/>fit-&gt;surfaces_begin();<sp/>sit<sp/>!=<sp/>fit-&gt;surfaces_end();<sp/>++sit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>sit-&gt;plane();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>The<sp/>main<sp/>program:<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>input<sp/>planes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Surface_3&gt;<sp/><sp/><sp/>planes;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>planes.push_back<sp/>(Surface_3(Plane_3(0,<sp/>-1,<sp/>1,<sp/>0)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>planes.push_back<sp/>(Surface_3(Plane_3(-1,<sp/>0,<sp/>1,<sp/>0)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>planes.push_back<sp/>(Surface_3(Plane_3(0,<sp/>1<sp/>,<sp/>1,<sp/>0)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>planes.push_back<sp/>(Surface_3(Plane_3(1,<sp/>0,<sp/>1,<sp/><sp/>0)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>and<sp/>print<sp/>the<sp/>minimization<sp/>diagram.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Envelope_diagram_2<sp/><sp/><sp/><sp/><sp/><sp/>min_diag;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgEnvelope3_1gafd8dc9fadb187466e4c567099ec1a443" kindref="member">CGAL::lower_envelope_3</ref><sp/>(planes.begin(),<sp/>planes.end(),<sp/>min_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>minimization<sp/>diagram:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_diagram<sp/>(min_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>and<sp/>print<sp/>the<sp/>maximization<sp/>diagram.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Envelope_diagram_2<sp/><sp/><sp/><sp/><sp/><sp/>max_diag;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgEnvelope3_1ga1fbbe89e27c3dc3404bbbb3b1f7ceea1" kindref="member">CGAL::upper_envelope_3</ref><sp/>(planes.begin(),<sp/>planes.end(),<sp/>max_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>maximization<sp/>diagram:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_diagram<sp/>(max_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
