<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_3D_Alpha_Shapes"/> <simplesect kind="authors"><para>Tran Kai Frank Da, S<eacute/>bastien Loriot, and Mariette Yvinec</para></simplesect>
<image type="html" name="alphashape.png"></image>
 <image type="latex" name="alphashape.png"></image>
</para><para>Assume we are given a set <formula id="0">$ S$</formula> of points in 2D or 3D and we would like to have something like &quot;the shape formed by these points&quot;. This is quite a vague notion and there are probably many possible interpretations, the alpha shape being one of them. Alpha shapes can be used for shape reconstruction from a dense unorganized set of data points. Indeed, an alpha shape is demarcated by a frontier, which is a linear approximation of the original shape <ref refid="citelist_1CITEREF_bb-srmua-97t" kindref="member">[1]</ref>.</para><para>As mentioned in Edelsbrunner&apos;s and M<uumlaut/>cke&apos;s paper <ref refid="citelist_1CITEREF_em-tdas-94" kindref="member">[2]</ref>, one can intuitively think of an alpha shape as the following. Imagine a huge mass of ice-cream making up the space <formula id="1">$ \mathbb{R}^3$</formula> and containing the points as &quot;hard&quot; chocolate pieces. Using one of those sphere-formed ice-cream spoons, we carve out all parts of the ice-cream block we can reach without bumping into chocolate pieces, thereby even carving out holes in the inside (e.g. parts not reachable by simply moving the spoon from the outside). We will eventually end up with a (not necessarily convex) object bounded by caps, arcs and points. If we now straighten all &quot;round&quot; faces to triangles and line segments, we have an intuitive description of what is called the alpha shape of <formula id="0">$ S$</formula>. The drawing above provides an example of this process in 2D (where our ice-cream spoon is simply a circle).</para><para>Alpha shapes depend on a parameter <formula id="2">$ \alpha$</formula> after which they are named. In the ice-cream analogy above, <formula id="2">$ \alpha$</formula> is the squared radius of the carving spoon. A very small value will allow us to eat up all of the ice-cream except the chocolate points themselves. Thus we already see that the alpha shape degenerates to the point-set <formula id="0">$ S$</formula> for <formula id="3">$ \alpha \rightarrow 0$</formula>. On the other hand, a huge value of <formula id="2">$ \alpha$</formula> will prevent us even from moving the spoon between two points since it is too large and we will never spoon up the ice-cream lying in the inside of the convex hull of <formula id="0">$ S$</formula>. Hence, the alpha shape becomes the convex hull of <formula id="0">$ S$</formula> as <formula id="4">$ \alpha \rightarrow \infty$</formula>.</para><para>CGAL offers 2D and 3D alpha shapes. The GUDHI library offers a <ulink url="http://gudhi.gforge.inria.fr/doc/latest/group__alpha__complex.html">dD Alpha complex</ulink>.</para><sect1 id="index_1Alpha_shapes_3Definitions">
<title>Definitions</title>
<para>We distinguish two versions of alpha shapes. <emphasis>Basic alpha shapes</emphasis> are based on the Delaunay triangulation. <emphasis>Weighted alpha shapes</emphasis> are based on its generalization, the regular triangulation (cf. Section <ref refid="index_1Triangulation3secclassRegulartriangulation" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Regular Triangulations</ref>), replacing the euclidean distance by the power to weighted points.</para><para>Let us consider the basic case with a Delaunay triangulation. We first define the alpha complex of the set of points <formula id="0">$ S$</formula>. The alpha complex is a subcomplex of the Delaunay triangulation. For a given value of <formula id="2">$ \alpha$</formula>, the alpha complex includes all the simplices in the Delaunay triangulation which have an empty circumscribing sphere with squared radius equal or smaller than <formula id="2">$ \alpha$</formula>. Here &quot;empty&quot; means that the open sphere does not include any points of <formula id="0">$ S$</formula>. The alpha shape is then simply the domain covered by the simplices of the alpha complex (see <ref refid="citelist_1CITEREF_em-tdas-94" kindref="member">[2]</ref>).</para><para>In general, an alpha complex is a disconnected and non-pure complex, meaning in particular that the alpha complex may have singular faces. For <formula id="5">$ 0 \leq k \leq d-1$</formula>, a <formula id="6">$ k$</formula>-simplex of the alpha complex is said to be singular if it is not a facet of a <formula id="7">$ (k+1)$</formula>-simplex of the complex. CGAL provides two versions of alpha shapes. In the general mode, the alpha shapes correspond strictly to the above definition. The regularized mode provides a regularized version of the alpha shapes. It corresponds to the domain covered by a regularized version of the alpha complex where singular faces are removed (See <ref refid="index_1fig__figgenregex" kindref="member">fig__figgenregex</ref> for an example).</para><para><anchor id="index_1fig__figgenregex"/><image type="html" name="gen-reg-ex.png"></image>
 <image type="latex" name="gen-reg-ex.png" width="15cm"></image>
  <ref refid="index_1fig__figgenregex" kindref="member">fig__figgenregex</ref> Comparison of general and regularized alpha-shape. <bold>Left:</bold> Some points are taken on the surface of a torus, three points being taken relatively far from the surface of the torus; <bold>Middle:</bold> The general alpha-shape (for a large enough alpha value) contains the singular triangle facet of the three isolated points; <bold>Right:</bold> The regularized version (for the same value of alpha) does not contains any singular facet.  <linebreak/>
</para><para>The alpha shapes of a set of points <formula id="0">$ S$</formula> form a discrete family, even though they are defined for all real numbers <formula id="2">$ \alpha$</formula>. The entire family of alpha shapes can be represented through the underlying triangulation of <formula id="0">$ S$</formula>. In this representation each <formula id="6">$ k$</formula>-simplex of the underlying triangulation is associated with an interval that specifies for which values of <formula id="2">$ \alpha$</formula> the <formula id="6">$ k$</formula>-simplex belongs to the alpha complex. Relying on this fact, the family of alpha shapes can be computed efficiently and relatively easily. Furthermore, we can select the optimal value of <formula id="2">$ \alpha$</formula> to get an alpha shape including all data points and having less than a given number of connected components. Also, the alpha-values allows to define a filtration on the faces of the triangulation of a set of points. In this filtration, the faces of the triangulation are output in increasing order of the alpha value for which they appear in the alpha complex. In case of equal alpha values, lower dimensional faces are output first.</para><para>The definition is analog in the case of weighted alpha shapes. The input set is now a set of weighted points (which can be regarded as spheres) and the underlying triangulation is the regular triangulation of this set. Two spheres, or two weighted points, with centers <formula id="8">$ C_1, C_2$</formula> and radii <formula id="9">$ r_1, r_2 $</formula> are said to be orthogonal iff <formula id="10">$ C_1C_2 ^2 = r_1^2 + r_2^2$</formula> and suborthogonal iff <formula id="11">$ C_1C_2 ^2 &lt; r_1^2 + r_2^2$</formula>. For a given value of <formula id="2">$ \alpha$</formula>, the weighted alpha complex is formed with the simplices of the regular triangulation triangulation such that there is a sphere orthogonal to the weighted points associated with the vertices of the simplex and suborthogonal to all the other input weighted points. Once again the alpha shape is then defined as the domain covered by a the alpha complex and comes in general and regularized versions.</para></sect1>
<sect1 id="index_1Alpha_Shape_3Functionality">
<title>Functionality</title>
<sect2 id="index_1AlphaShape_3DFamilyOfAlphaShapes">
<title>Family of Alpha Shapes</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">Alpha_shape_3</ref>&lt;Dt,ExactAlphaComparisonTag&gt;</computeroutput> represents the whole family of alpha shapes for a given set of points. The class includes the underlying triangulation <computeroutput>Dt</computeroutput> of the set, and associates to each <formula id="6">$ k$</formula>-face of this triangulation an interval specifying for which values of <formula id="2">$ \alpha$</formula> the face belongs to the alpha complex. The second template parameter, <computeroutput>ExactAlphaComparisonTag</computeroutput>, is a tag that, when set to <ref refid="group__PkgStlExtensionUtilities_1gab3e2296107b5d26c32c8183028a217f1" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Tag_true</ref>, triggers exact comparisons between alpha values.</para><para>The class provides functions to set and get the current <formula id="2">$ \alpha$</formula>-value, as well as an iterator that enumerates the <formula id="2">$ \alpha$</formula> values where the alpha shape changes.</para><para>Additionally, the class has a filtration member function that, given an output iterator with <computeroutput><ref refid="classCGAL_1_1Object" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Object</ref></computeroutput> as value type, outputs the faces of the triangulation according to the order of apparition in the alpha complex when alpha increases.</para><para>Finally, it provides a function to determine the smallest value <formula id="2">$ \alpha$</formula> such that the alpha shape satisfies the following two properties: <linebreak/>
 <orderedlist>
<listitem>
<para>All data points are either on the boundary or in the interior of the regularized version of the alpha shape (no singular faces). </para></listitem>
<listitem>
<para>The number of components is equal or less than a given number. </para></listitem>
</orderedlist>
</para><para>The current implementation is static, that is after its construction points cannot be inserted or removed.</para></sect2>
<sect2 id="index_1AlphaShape_3DAlphaShapeForAFixedAlpha">
<title>Alpha Shape for a Fixed Alpha</title>
<para>Given a value of alpha, the class <computeroutput><ref refid="classCGAL_1_1Fixed__alpha__shape__3" kindref="compound">Fixed_alpha_shape_3</ref>&lt;Dt&gt;</computeroutput> represents one alpha shape for a given set of points. The class includes the underlying triangulation <computeroutput>Dt</computeroutput> of the set, and associates to each <formula id="6">$ k$</formula>-face of this triangulation a classification type. This class is dynamic, that is after its construction points can be inserted or removed.</para></sect2>
<sect2 id="index_1AlphaShape_3DClassificationAndIterators">
<title>Classification and Iterators</title>
<para>Both classes provide member functions to classify for a (given) value of <formula id="2">$ \alpha$</formula> the different faces of the triangulation as <computeroutput>EXTERIOR</computeroutput>, <computeroutput>SINGULAR</computeroutput>, <computeroutput>REGULAR</computeroutput> or <computeroutput>INTERIOR</computeroutput> with respect to the alpha shape. A <formula id="6">$ k$</formula>-face on the boundary of the alpha complex is said to be: <computeroutput>REGULAR</computeroutput> if it is a subface of the alpha-complex which is a subface of a <formula id="7">$ (k+1)$</formula>-face of the alpha complex, and <computeroutput>SINGULAR</computeroutput> otherwise. A <formula id="6">$ k$</formula>-face of the alpha complex which is not on the boundary of the alpha complex is said to be <computeroutput>INTERIOR</computeroutput>. See <ref refid="index_1fig__figclassif" kindref="member">fig__figclassif</ref> for a 2D illustration.</para><para><anchor id="index_1fig__figclassif"/><image type="html" name="classif.png"></image>
 <image type="latex" name="classif.png" width="15cm"></image>
  <ref refid="index_1fig__figclassif" kindref="member">fig__figclassif</ref> Classification of simplices, a 2D example. <bold>Left:</bold> The 2D Delaunay triangulation of a set of points; <bold>Right:</bold> Classification of simplices for a given alpha (the squared radius of the red circle). <computeroutput>INTERIOR</computeroutput>, <computeroutput>REGULAR</computeroutput> and <computeroutput>SINGULAR</computeroutput> simplices are depicted in black, green and blue respectively. <computeroutput>EXTERIOR</computeroutput> simplices are not depicted. The vertex <computeroutput>s</computeroutput> and the edge <computeroutput>tu</computeroutput> are <computeroutput>SINGULAR</computeroutput> since all higher dimension simplices they are incident to are <computeroutput>EXTERIOR</computeroutput>. The facet <computeroutput>pqr</computeroutput> is <computeroutput>EXTERIOR</computeroutput> because the squared radius of its circumscribed circle is larger than alpha.  <linebreak/>
</para><para>The classes provide also output iterators to get for a given <computeroutput>alpha</computeroutput> value the vertices, edges, facets and cells of the different types (<computeroutput>EXTERIOR</computeroutput>, <computeroutput>SINGULAR</computeroutput>, <computeroutput>REGULAR</computeroutput> or <computeroutput>INTERIOR</computeroutput>).</para></sect2>
</sect1>
<sect1 id="index_1AlphaShape3D_ConceptAndModels">
<title>Concepts and Models</title>
<para>We currently do not specify concepts for the underlying triangulation type. Models that work for a family of alpha-shapes are the instantiations of the classes <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Delaunay_triangulation_3</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Periodic__3__Delaunay__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">Periodic_3_Delaunay_triangulation_3</ref></computeroutput> (see example <ref refid="index_1AlphaShape_3DExampleForPeriodicAlphaShapes" kindref="member">Example for Periodic Alpha Shapes</ref>). A model that works for a fixed alpha-shape are the instantiations of the class <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Delaunay_triangulation_3</ref></computeroutput>. Models that work for a weighted alpha-shape are the instantiations of the classes <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Regular_triangulation_3</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Periodic__3__regular__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">Periodic_3_regular_triangulation_3</ref></computeroutput>. The triangulation needs a geometric traits class and a triangulation data structure as template parameters.</para><sect2 id="index_1AlphaShape3D_ConceptAndModelsAlphaShapes">
<title>Alpha Shapes</title>
<para>For the class <computeroutput><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">Alpha_shape_3</ref>&lt;Dt,ExactAlphaComparisonTag&gt;</computeroutput>, the requirements of the traits class are described in the concepts <computeroutput><ref refid="classAlphaShapeTraits__3" kindref="compound">AlphaShapeTraits_3</ref></computeroutput> in the non-weighted case and <computeroutput><ref refid="classWeightedAlphaShapeTraits__3" kindref="compound">WeightedAlphaShapeTraits_3</ref></computeroutput> in the weighted case. All CGAL kernels are models of both concepts.</para><para>The triangulation data structure of the triangulation has to be a model of the concept <computeroutput>TriangulationDataStructure_3</computeroutput>, and it must be parameterized with vertex and cell classes, which are model of the concepts <computeroutput><ref refid="classAlphaShapeVertex__3" kindref="compound">AlphaShapeVertex_3</ref></computeroutput> and <computeroutput><ref refid="classAlphaShapeCell__3" kindref="compound">AlphaShapeCell_3</ref></computeroutput>. The classes <computeroutput><ref refid="classCGAL_1_1Alpha__shape__vertex__base__3" kindref="compound">Alpha_shape_vertex_base_3</ref>&lt;Gt&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Alpha__shape__cell__base__3" kindref="compound">Alpha_shape_cell_base_3</ref>&lt;Gt&gt;</computeroutput> are models of these concepts and can be used for all type of alpha shapes, provided that the template parameters <computeroutput>Vb</computeroutput> and <computeroutput>Fb</computeroutput> are appropriately chosen, as we shall see in the following section.</para></sect2>
<sect2 id="index_1AlphaShape3D_ConceptAndModelsFixedAlphaShapes">
<title>Fixed Alpha Shapes</title>
<para>For the class <computeroutput><ref refid="classCGAL_1_1Fixed__alpha__shape__3" kindref="compound">Fixed_alpha_shape_3</ref>&lt;Dt&gt;</computeroutput>, the requirements of the traits class are described in the concepts <computeroutput><ref refid="classFixedAlphaShapeTraits__3" kindref="compound">FixedAlphaShapeTraits_3</ref></computeroutput> in the non-weighted case and <computeroutput><ref refid="classFixedWeightedAlphaShapeTraits__3" kindref="compound">FixedWeightedAlphaShapeTraits_3</ref></computeroutput> in the weighted case. All CGAL kernels are models of both concepts. The triangulation data structure of the triangulation has to be a model of the concept <computeroutput>TriangulationDataStructure_3</computeroutput>, and it must be parameterized with vertex and cell classes, which are model of the concepts <computeroutput><ref refid="classFixedAlphaShapeVertex__3" kindref="compound">FixedAlphaShapeVertex_3</ref></computeroutput> and <computeroutput><ref refid="classFixedAlphaShapeCell__3" kindref="compound">FixedAlphaShapeCell_3</ref></computeroutput>. The package provides models <computeroutput><ref refid="classCGAL_1_1Fixed__alpha__shape__vertex__base__3" kindref="compound">Fixed_alpha_shape_vertex_base_3</ref>&lt;Gt&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Fixed__alpha__shape__cell__base__3" kindref="compound">Fixed_alpha_shape_cell_base_3</ref>&lt;Gt&gt;</computeroutput>, respectively.</para></sect2>
<sect2 id="index_1AlphaShape3D_ConceptAndModelsTDS">
<title>Triangulation data structure</title>
<para>Additional requirements are put when using weighted or periodic triangulations as underlying triangulation: <itemizedlist>
<listitem>
<para>When using a weighted triangulation (<computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Regular_triangulation_3</ref></computeroutput> or <computeroutput><ref refid="classCGAL_1_1Periodic__3__regular__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">Periodic_3_regular_triangulation_3</ref></computeroutput>), the vertex and cell classes must respectively be models to both <computeroutput><ref refid="classAlphaShapeVertex__3" kindref="compound">AlphaShapeVertex_3</ref></computeroutput> and <computeroutput><ref refid="classRegularTriangulationVertexBase__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">RegularTriangulationVertexBase_3</ref></computeroutput>, and to both <computeroutput><ref refid="classAlphaShapeCell__3" kindref="compound">AlphaShapeCell_3</ref></computeroutput> and <computeroutput><ref refid="classRegularTriangulationCellBase__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">RegularTriangulationCellBase_3</ref></computeroutput> (see example: <ref refid="index_1AlphaShape_3DExampleforWeightedAlphaShapes" kindref="member">Example for Weighted Alpha-Shapes</ref>). </para></listitem>
<listitem>
<para>When using a periodic triangulation (<computeroutput><ref refid="classCGAL_1_1Periodic__3__Delaunay__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">Periodic_3_Delaunay_triangulation_3</ref></computeroutput> or <computeroutput><ref refid="classCGAL_1_1Periodic__3__regular__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">Periodic_3_regular_triangulation_3</ref></computeroutput>), the vertex and cell classes must respectively be models to both <computeroutput><ref refid="classAlphaShapeVertex__3" kindref="compound">AlphaShapeVertex_3</ref></computeroutput> and <computeroutput><ref refid="classPeriodic__3TriangulationDSVertexBase__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">Periodic_3TriangulationDSVertexBase_3</ref></computeroutput>, and to both <computeroutput><ref refid="classAlphaShapeCell__3" kindref="compound">AlphaShapeCell_3</ref></computeroutput> and <computeroutput><ref refid="classPeriodic__3TriangulationDSCellBase__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">Periodic_3TriangulationDSCellBase_3</ref></computeroutput> (see example: <ref refid="index_1AlphaShape_3DExampleForPeriodicAlphaShapes" kindref="member">Example for Periodic Alpha Shapes</ref>). </para></listitem>
</itemizedlist>
</para></sect2>
</sect1>
<sect1 id="index_1Alpha_shapes_3AlphaShape3OrFixedAlphaShape3">
<title>Alpha_shape_3 vs. Fixed_alpha_shape_3</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">Alpha_shape_3</ref>&lt;Dt,ExactAlphaComparisonTag&gt;</computeroutput> represents the whole family of alpha shapes for a given set of points while the class <computeroutput><ref refid="classCGAL_1_1Fixed__alpha__shape__3" kindref="compound">Fixed_alpha_shape_3</ref>&lt;Dt&gt;</computeroutput> represents only one alpha shape (for a fixed alpha). When using the same kernel, <computeroutput><ref refid="classCGAL_1_1Fixed__alpha__shape__3" kindref="compound">Fixed_alpha_shape_3</ref>&lt;Dt&gt;</computeroutput> is a lighter version. It is thus naturally much more efficient when the alpha-shape is needed for a single given value of alpha. In addition, note that the class <computeroutput><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">Alpha_shape_3</ref>&lt;Dt,ExactAlphaComparisonTag&gt;</computeroutput> requires constructions (squared radius of simplices) while the class <computeroutput><ref refid="classCGAL_1_1Fixed__alpha__shape__3" kindref="compound">Fixed_alpha_shape_3</ref>&lt;Dt&gt;</computeroutput> uses only predicates. This implies that a certified construction of one (several) alpha-shape, using the <computeroutput><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">Alpha_shape_3</ref>&lt;Dt,ExactAlphaComparisonTag&gt;</computeroutput> requires a kernel with exact predicates and exact constructions (or setting <computeroutput>ExactAlphaComparisonTag</computeroutput> to <computeroutput>Tag_true</computeroutput>) while using a kernel with exact predicates is sufficient for the class <computeroutput><ref refid="classCGAL_1_1Fixed__alpha__shape__3" kindref="compound">Fixed_alpha_shape_3</ref>&lt;Dt&gt;</computeroutput>. This makes the class <computeroutput><ref refid="classCGAL_1_1Fixed__alpha__shape__3" kindref="compound">Fixed_alpha_shape_3</ref>&lt;Dt&gt;</computeroutput> even more efficient in this setting. In addition, note that the <computeroutput>Fixed</computeroutput> version is the only of the two that supports incremental insertion and removal of points.</para><para>We give the time spent while computing the alpha shape of a protein (considered as a set of weighted points) featuring 4251 atoms (using <computeroutput>gcc 4.3</computeroutput> under Linux with <computeroutput>-O3</computeroutput> and <computeroutput>-DNDEBUG</computeroutput> flags, on a 2.27GHz Intel(R) Xeon(R) E5520 CPU): Using <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>, building the regular triangulation requires 0.09s, then the class <computeroutput><ref refid="classCGAL_1_1Fixed__alpha__shape__3" kindref="compound">Fixed_alpha_shape_3</ref>&lt;Dt&gt;</computeroutput> required 0.05s while the class <computeroutput><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">Alpha_shape_3</ref>&lt;Dt,ExactAlphaComparisonTag&gt;</computeroutput> requires 0.35s if <computeroutput>ExactAlphaComparisonTag</computeroutput> is <computeroutput>Tag_false</computeroutput> (and 0.70s with <computeroutput>Tag_true</computeroutput>). Using <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput>, building the regular triangulation requires 0.19s and then the class <computeroutput><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">Alpha_shape_3</ref>&lt;Dt,ExactAlphaComparisonTag&gt;</computeroutput> requires 0.90s.</para></sect1>
<sect1 id="index_1Alpha_shapes_3Examples">
<title>Examples</title>
<sect2 id="index_1AlphaShape_3DExampleForBasicAlphaShapes">
<title>Example for Basic Alpha-Shapes</title>
<para>This example builds a basic alpha shape using a Delaunay triangulation as underlying triangulation.</para><para><linebreak/>
<bold>File</bold> <ref refid="Alpha_shapes_3_2ex_alpha_shapes_3_8cpp-example" kindref="compound">Alpha_shapes_3/ex_alpha_shapes_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_vertex_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__vertex__base__3" kindref="compound">CGAL::Alpha_shape_vertex_base_3&lt;Gt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__cell__base__3" kindref="compound">CGAL::Alpha_shape_cell_base_3&lt;Gt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_3&lt;Vb,Fb&gt;<sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::Delaunay_triangulation_3&lt;Gt,Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">CGAL::Alpha_shape_3&lt;Triangulation_3&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_shape_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Gt::Point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__3_1ac4275fa2b0b9312eb6c967f4e61afe35" kindref="member">Alpha_shape_3::Alpha_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point&gt;<sp/>lp;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//read<sp/>input</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>is(</highlight><highlight class="stringliteral">&quot;./data/bunny_1000&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>is<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/>;<sp/>n&gt;0<sp/>;<sp/>n--)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>is<sp/>&gt;&gt;<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lp.push_back(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>alpha<sp/>shape</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_3<sp/>as(lp.begin(),lp.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Alpha<sp/>shape<sp/>computed<sp/>in<sp/>REGULARIZED<sp/>mode<sp/>by<sp/>default&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>find<sp/>optimal<sp/>alpha<sp/>value</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_iterator<sp/>opt<sp/>=<sp/>as.find_optimal_alpha(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Optimal<sp/>alpha<sp/>value<sp/>to<sp/>get<sp/>one<sp/>connected<sp/>component<sp/>is<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*opt<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.set_alpha(*opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(as.number_of_solid_components()<sp/>==<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1AlphaShape_3DBuildingBasicAlphaShapesForManyPoints">
<title>Building Basic Alpha Shapes for Many Points</title>
<para>When many points are input in the alpha shape, say more than 10 000, it may pay off to use a Delaunay triangulation with the <computeroutput>Fast_location</computeroutput> policy as underlying triangulation in order to speed up point location queries (cf. Section <ref refid="index_1Triangulation3seclocpol" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">The Location Policy Parameter</ref>).</para><para><linebreak/>
<bold>File</bold> <ref refid="Alpha_shapes_3_2ex_alpha_shapes_with_fast_location_3_8cpp-example" kindref="compound">Alpha_shapes_3/ex_alpha_shapes_with_fast_location_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_vertex_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__vertex__base__3" kindref="compound">CGAL::Alpha_shape_vertex_base_3&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__cell__base__3" kindref="compound">CGAL::Alpha_shape_cell_base_3&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_3&lt;Vb,Fb&gt;<sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::Delaunay_triangulation_3&lt;K,Tds,CGAL::Fast_location&gt;</ref><sp/><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">CGAL::Alpha_shape_3&lt;Delaunay&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_shape_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__3_1ac4275fa2b0b9312eb6c967f4e61afe35" kindref="member">Alpha_shape_3::Alpha_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Alpha_shape_3::NT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>dt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>is(</highlight><highlight class="stringliteral">&quot;./data/bunny_1000&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>is<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points<sp/>read&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/>;<sp/>n&gt;0<sp/>;<sp/>n--)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>is<sp/>&gt;&gt;<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dt.insert(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Delaunay<sp/>computed.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>alpha<sp/>shape</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_3<sp/>as(dt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Alpha<sp/>shape<sp/>computed<sp/>in<sp/>REGULARIZED<sp/>mode<sp/>by<sp/>defaut.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>find<sp/>optimal<sp/>alpha<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_3::NT<sp/>alpha_solid<sp/>=<sp/>as.find_alpha_solid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_iterator<sp/>opt<sp/>=<sp/>as.find_optimal_alpha(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Smallest<sp/>alpha<sp/>value<sp/>to<sp/>get<sp/>a<sp/>solid<sp/>through<sp/>data<sp/>points<sp/>is<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>alpha_solid<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Optimal<sp/>alpha<sp/>value<sp/>to<sp/>get<sp/>one<sp/>connected<sp/>component<sp/>is<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><sp/>*opt<sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.set_alpha(*opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(as.number_of_solid_components()<sp/>==<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1AlphaShape_3DExampleforWeightedAlphaShapes">
<title>Example for Weighted Alpha-Shapes</title>
<para>The following examples build a weighted alpha shape requiring a regular triangulation as underlying triangulation. The alpha shape is built in <computeroutput>GENERAL</computeroutput> mode.</para><para><linebreak/>
<bold>File</bold> <ref refid="Alpha_shapes_3_2ex_weighted_alpha_shapes_3_8cpp-example" kindref="compound">Alpha_shapes_3/ex_weighted_alpha_shapes_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_vertex_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Regular_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__vertex__base__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::Regular_triangulation_vertex_base_3&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rvb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__vertex__base__3" kindref="compound">CGAL::Alpha_shape_vertex_base_3&lt;K,Rvb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__cell__base__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::Regular_triangulation_cell_base_3&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rcb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__cell__base__3" kindref="compound">CGAL::Alpha_shape_cell_base_3&lt;K,Rcb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cb;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_3&lt;Vb,Cb&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::Regular_triangulation_3&lt;K,Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">CGAL::Alpha_shape_3&lt;Triangulation_3&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_shape_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Alpha_shape_3::Cell_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cell_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Alpha_shape_3::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Alpha_shape_3::Facet<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Facet;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Alpha_shape_3::Edge<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Edge;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation_3::Weighted_point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Weighted_point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation_3::Bare_point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bare_point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Weighted_point&gt;<sp/>lwp;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//input<sp/>:<sp/>a<sp/>small<sp/>molecule</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lwp.push_back(Weighted_point(Bare_point(<sp/>1,<sp/>-1,<sp/>-1),<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lwp.push_back(Weighted_point(Bare_point(-1,<sp/><sp/>1,<sp/>-1),<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lwp.push_back(Weighted_point(Bare_point(-1,<sp/>-1,<sp/><sp/>1),<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lwp.push_back(Weighted_point(Bare_point(<sp/>1,<sp/><sp/>1,<sp/><sp/>1),<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lwp.push_back(Weighted_point(Bare_point(<sp/>2,<sp/><sp/>2,<sp/><sp/>2),<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//build<sp/>alpha_shape<sp/><sp/>in<sp/>GENERAL<sp/>mode<sp/>and<sp/>set<sp/>alpha=0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_3<sp/><sp/>as(lwp.begin(),<sp/>lwp.end(),<sp/>0,<sp/><ref refid="classCGAL_1_1Alpha__shape__3_1aa6941cdb345b82d9aad513f8b7b1a6efa4684ead732e31e7517685b9e59d3005c" kindref="member">Alpha_shape_3::GENERAL</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//explore<sp/>the<sp/>0-shape<sp/>-<sp/>It<sp/>is<sp/>dual<sp/>to<sp/>the<sp/>boundary<sp/>of<sp/>the<sp/>union.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Cell_handle&gt;<sp/>cells;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Facet&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>facets;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Edge&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>edges;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.get_alpha_shape_cells(std::back_inserter(cells),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Alpha__shape__3_1ae887e9ecdaca28790f6ccdd73b84e40ca8e65f253cf2f5db945f6665bfa645506" kindref="member">Alpha_shape_3::INTERIOR</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.get_alpha_shape_facets(std::back_inserter(facets),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Alpha__shape__3_1ae887e9ecdaca28790f6ccdd73b84e40ca0cd7a695e3b6b042c77b53c770dc776b" kindref="member">Alpha_shape_3::REGULAR</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.get_alpha_shape_facets(std::back_inserter(facets),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Alpha__shape__3_1ae887e9ecdaca28790f6ccdd73b84e40ca4fe33b826e16321706a6d2e3428fd992" kindref="member">Alpha_shape_3::SINGULAR</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.get_alpha_shape_edges(std::back_inserter(edges),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Alpha__shape__3_1ae887e9ecdaca28790f6ccdd73b84e40ca4fe33b826e16321706a6d2e3428fd992" kindref="member">Alpha_shape_3::SINGULAR</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>The<sp/>0-shape<sp/>has<sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>cells.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>interior<sp/>tetrahedra&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>facets.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>boundary<sp/>facets&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>edges.size()<sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>singular<sp/>edges&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1AlphaShape_3DExampleForFixedWeightedAlphaShapes">
<title>Example for Fixed Weighted Alpha-Shapes</title>
<para>Same example as previous but using a fixed value of alpha.</para><para><linebreak/>
<bold>File</bold> <ref refid="Alpha_shapes_3_2ex_fixed_weighted_alpha_shapes_3_8cpp-example" kindref="compound">Alpha_shapes_3/ex_fixed_weighted_alpha_shapes_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Fixed_alpha_shape_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Fixed_alpha_shape_vertex_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Fixed_alpha_shape_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Regular_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__vertex__base__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::Regular_triangulation_vertex_base_3&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Vbb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Fixed__alpha__shape__vertex__base__3" kindref="compound">CGAL::Fixed_alpha_shape_vertex_base_3&lt;K,Vbb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__cell__base__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::Regular_triangulation_cell_base_3&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rcb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Fixed__alpha__shape__cell__base__3" kindref="compound">CGAL::Fixed_alpha_shape_cell_base_3&lt;K,Rcb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cb;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_3&lt;Vb,Cb&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::Regular_triangulation_3&lt;K,Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Fixed__alpha__shape__3" kindref="compound">CGAL::Fixed_alpha_shape_3&lt;Triangulation_3&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Fixed_alpha_shape_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Fixed_alpha_shape_3::Cell_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cell_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Fixed_alpha_shape_3::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Fixed_alpha_shape_3::Facet<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Facet;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Fixed_alpha_shape_3::Edge<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Edge;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation_3::Weighted_point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Weighted_point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation_3::Bare_point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bare_point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Weighted_point&gt;<sp/>lwp;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//input<sp/>:<sp/>a<sp/>small<sp/>molecule</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lwp.push_back(Weighted_point(Bare_point(<sp/>1,<sp/>-1,<sp/>-1),<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lwp.push_back(Weighted_point(Bare_point(-1,<sp/><sp/>1,<sp/>-1),<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lwp.push_back(Weighted_point(Bare_point(-1,<sp/>-1,<sp/><sp/>1),<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lwp.push_back(Weighted_point(Bare_point(<sp/>1,<sp/><sp/>1,<sp/><sp/>1),<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lwp.push_back(Weighted_point(Bare_point(<sp/>2,<sp/><sp/>2,<sp/><sp/>2),<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//build<sp/>one<sp/>alpha_shape<sp/><sp/>with<sp/>alpha=0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Fixed_alpha_shape_3<sp/><sp/>as(lwp.begin(),<sp/>lwp.end(),<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//explore<sp/>the<sp/>0-shape<sp/>-<sp/>It<sp/>is<sp/>dual<sp/>to<sp/>the<sp/>boundary<sp/>of<sp/>the<sp/>union.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Cell_handle&gt;<sp/>cells;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Facet&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>facets;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Edge&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>edges;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.get_alpha_shape_cells(std::back_inserter(cells),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Fixed__alpha__shape__3_1a3c4c20b8aa43fbd4667a464f3487516aa0222b7c00ded8d629a971e4d2ee922cb" kindref="member">Fixed_alpha_shape_3::INTERIOR</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.get_alpha_shape_facets(std::back_inserter(facets),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Fixed__alpha__shape__3_1a3c4c20b8aa43fbd4667a464f3487516aa7a7519fb644538516dea97cd03ddb696" kindref="member">Fixed_alpha_shape_3::REGULAR</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.get_alpha_shape_facets(std::back_inserter(facets),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Fixed__alpha__shape__3_1a3c4c20b8aa43fbd4667a464f3487516aab3d4ba5f0b5938bac0cc63f496fb4e8c" kindref="member">Fixed_alpha_shape_3::SINGULAR</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.get_alpha_shape_edges(std::back_inserter(edges),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Fixed__alpha__shape__3_1a3c4c20b8aa43fbd4667a464f3487516aab3d4ba5f0b5938bac0cc63f496fb4e8c" kindref="member">Fixed_alpha_shape_3::SINGULAR</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>The<sp/>0-shape<sp/>has<sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>cells.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>interior<sp/>tetrahedra&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>facets.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>boundary<sp/>facets&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>edges.size()<sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>singular<sp/>edges&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1AlphaShape_3DBuildingAnAlphaShapesWithExactComparisonsOfAlphaValues">
<title>Building an Alpha Shapes with Exact Comparisons of Alpha Values</title>
<para>On some platforms, the alpha shapes of the set of points of this example cannot be computed when using a traits with inexact constructions. To be able to compute them with a traits with inexact constructions, the tag <computeroutput>ExactAlphaComparisonTag</computeroutput> is set to <computeroutput>Tag_true</computeroutput>. <linebreak/>
<bold>File</bold> <ref refid="Alpha_shapes_3_2ex_alpha_shapes_exact_alpha_8cpp-example" kindref="compound">Alpha_shapes_3/ex_alpha_shapes_exact_alpha.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_vertex_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Boolean__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Tag_true</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_cmp_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//We<sp/>use<sp/>CGAL::Default<sp/>to<sp/>skip<sp/>the<sp/>complete<sp/>declaration<sp/>of<sp/>base<sp/>classes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__vertex__base__3" kindref="compound">CGAL::Alpha_shape_vertex_base_3&lt;Gt,CGAL::Default,Alpha_cmp_tag&gt;</ref><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__cell__base__3" kindref="compound">CGAL::Alpha_shape_cell_base_3&lt;Gt,CGAL::Default,Alpha_cmp_tag&gt;</ref><sp/><sp/><sp/><sp/><sp/>Fb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_3&lt;Vb,Fb&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::Delaunay_triangulation_3&lt;Gt,Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//Alpha<sp/>shape<sp/>with<sp/>ExactAlphaComparisonTag<sp/>set<sp/>to<sp/>true<sp/>(note<sp/>that<sp/>the<sp/>tag<sp/>is<sp/>also</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//set<sp/>to<sp/>true<sp/>for<sp/>Vb<sp/>and<sp/>Fb)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">CGAL::Alpha_shape_3&lt;Triangulation_3,Alpha_cmp_tag&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alpha_shape_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Gt::Point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Set<sp/>of<sp/>points<sp/>for<sp/>which<sp/>the<sp/>alpha<sp/>shapes<sp/>cannot<sp/>be<sp/>computed<sp/>with</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//a<sp/>floating<sp/>point<sp/>alpha<sp/>value<sp/>(on<sp/>certain<sp/>platforms)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point&gt;<sp/>lp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lp.push_back(Point(49.2559,29.1767,6.7723));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lp.push_back(Point(49.3696,31.4775,5.33777));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lp.push_back(Point(49.4264,32.6279,4.6205));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lp.push_back(Point(49.3127,30.3271,6.05503));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>alpha<sp/>shape</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_3<sp/>as(lp.begin(),lp.end(),0,<ref refid="classCGAL_1_1Alpha__shape__3_1aa6941cdb345b82d9aad513f8b7b1a6efa4684ead732e31e7517685b9e59d3005c" kindref="member">Alpha_shape_3::GENERAL</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1AlphaShape_3DExampleForPeriodicAlphaShapes">
<title>Example for Periodic Alpha Shapes</title>
<para>The following example shows how to use a periodic Delaunay triangulation (Chapter <ref refid="index_1Chapter_3D_Periodic_Triangulations" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">3D Periodic Triangulations</ref>) as underlying triangulation for the alpha shape computation. Usage of a weighted Delaunay periodic triangulation is presented in the example: <ref refid="Alpha_shapes_3_2ex_weighted_periodic_alpha_shapes_3_8cpp-example" kindref="compound">ex_weighted_periodic_alpha_shapes_3.cpp</ref>.</para><para>In order to define the original domain and to benefit from the built-in heuristic optimizations of the periodic triangulation computation, it is recommended to first construct the triangulation and then construct the alpha shape from it. The alpha shape constructor that takes a point range can be used as well but in this case the original domain cannot be specified and the default unit cube will be chosen and no optimizations will be used.</para><para>It is also recommended to switch the triangulation to 1-sheeted covering if possible. Note that a periodic triangulation in 27-sheeted covering space is degenerate. In this case, an exact constructions kernel needs to be used to compute the alpha shapes. Otherwise the results will suffer from round-off problems.</para><para><linebreak/>
<bold>File</bold> <ref refid="Alpha_shapes_3_2ex_periodic_alpha_shapes_3_8cpp-example" kindref="compound">Alpha_shapes_3/ex_periodic_alpha_shapes_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Alpha_shape_vertex_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_3_Delaunay_triangulation_traits_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_3_Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Random.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Traits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__3__Delaunay__triangulation__traits__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">CGAL::Periodic_3_Delaunay_triangulation_traits_3&lt;K&gt;</ref><sp/>PK;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Vertex<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__3__triangulation__ds__vertex__base__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">CGAL::Periodic_3_triangulation_ds_vertex_base_3&lt;&gt;</ref><sp/>DsVb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::Triangulation_vertex_base_3&lt;PK,DsVb&gt;</ref><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__vertex__base__3" kindref="compound">CGAL::Alpha_shape_vertex_base_3&lt;PK,Vb&gt;</ref><sp/>AsVb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Cell<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__3__triangulation__ds__cell__base__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">CGAL::Periodic_3_triangulation_ds_cell_base_3&lt;&gt;</ref><sp/>DsCb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__cell__base__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">CGAL::Triangulation_cell_base_3&lt;PK,DsCb&gt;</ref><sp/>Cb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__cell__base__3" kindref="compound">CGAL::Alpha_shape_cell_base_3&lt;PK,Cb&gt;</ref><sp/>AsCb;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_3&lt;AsVb,AsCb&gt;<sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__3__Delaunay__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Periodic_3_triangulation_3.tag">CGAL::Periodic_3_Delaunay_triangulation_3&lt;PK,Tds&gt;</ref><sp/>P3DT3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Alpha__shape__3" kindref="compound">CGAL::Alpha_shape_3&lt;P3DT3&gt;</ref><sp/><sp/>Alpha_shape_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PK::Point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_3&lt;double, Point&gt;</ref><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random<sp/>random(7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_cube_3&lt;Point,<sp/>Creator&gt;<sp/>in_cube(1,<sp/>random);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Generating<sp/>1000<sp/>random<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0<sp/>;<sp/>i<sp/>&lt;<sp/>1000<sp/>;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point<sp/>p<sp/>=<sp/>*in_cube++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pts.push_back(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>the<sp/>periodic<sp/>cube</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P3DT3<sp/>pdt(PK::Iso_cuboid_3(-1,-1,-1,1,1,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Heuristic<sp/>for<sp/>inserting<sp/>large<sp/>point<sp/>sets<sp/>(if<sp/>pts<sp/>is<sp/>reasonably<sp/>large)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pdt.insert(pts.begin(),<sp/>pts.end(),<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>As<sp/>pdt<sp/>won&apos;t<sp/>be<sp/>modified<sp/>anymore<sp/>switch<sp/>to<sp/>1-sheeted<sp/>cover<sp/>if<sp/>possible</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pdt.is_triangulation_in_1_sheet())<sp/>pdt.convert_to_1_sheeted_covering();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Periodic<sp/>Delaunay<sp/>computed.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>alpha<sp/>shape</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_3<sp/>as(pdt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Alpha<sp/>shape<sp/>computed<sp/>in<sp/>REGULARIZED<sp/>mode<sp/>by<sp/>default.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>find<sp/>optimal<sp/>alpha<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alpha_shape_3::NT<sp/>alpha_solid<sp/>=<sp/>as.find_alpha_solid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Alpha__shape__3_1ac4275fa2b0b9312eb6c967f4e61afe35" kindref="member">Alpha_shape_3::Alpha_iterator</ref><sp/>opt<sp/>=<sp/>as.find_optimal_alpha(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Smallest<sp/>alpha<sp/>value<sp/>to<sp/>get<sp/>a<sp/>solid<sp/>through<sp/>data<sp/>points<sp/>is<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>alpha_solid<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Optimal<sp/>alpha<sp/>value<sp/>to<sp/>get<sp/>one<sp/>connected<sp/>component<sp/>is<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*opt<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>as.set_alpha(*opt);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(as.number_of_solid_components()<sp/>==<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
