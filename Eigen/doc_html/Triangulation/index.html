<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Triangulation/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - dD Triangulations: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - dD Triangulations
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Triangulations"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Olivier Devillers, Samuel Hornus, and Clément Jamin.</dd></dl>
<p>This package proposes data structures and algorithms to compute triangulations of points in any dimensions <a class="el" href="citelist.html#CITEREF_boissonnat2009Delaunay">[1]</a>. The <code><a class="el" href="classCGAL_1_1Triangulation__data__structure.html" title="This class is a data structure used for storing a triangulation of dimension  (D is the maximal dimen...">Triangulation_data_structure</a></code> handles the combinatorial aspect of triangulations while the geometric classes <code><a class="el" href="classCGAL_1_1Triangulation.html" title="This class implements triangulations of point sets in dimension . ">Triangulation</a></code>, <code><a class="el" href="classCGAL_1_1Delaunay__triangulation.html" title="This class is used to maintain the Delaunay triangulation of a set of points in . ...">Delaunay_triangulation</a></code> and <code><a class="el" href="classCGAL_1_1Regular__triangulation.html" title="This class is used to maintain the regular triangulation – also known as weighted Delaunay triangula...">Regular_triangulation</a></code> allow to compute and maintain triangulations, Delaunay triangulations, and regular triangulations of sets of points.</p>
<h1><a class="anchor" id="TriangulationSecIntro"></a>
Introduction</h1>
<h2>Some Definitions</h2>
<p>A <em>finite abstract simplicial complex</em> is built on a finite set of vertices \( V\) and consists of a collection \( S\) of subsets of \( V\) such that, if \( s\) is a set of vertices in \( S\), then all the subsets of \( s\) are also in \( S\).</p>
<p>The sets in \( S\) (which are subsets of \( V\)) are called <em>faces</em> or <em>simplices</em> (the singular of which is <em>simplex</em>). A simplex \( s\in S\) is <em>maximal</em> if it is not a proper subset of some other set in \( S\). A simplex having \( k+1 \) vertices is said of dimension \( k \). An \( k\)-face denotes a \( k\)-dimensional simplex, i.e., a simplex with \( k+1\) vertices. The simplicial complex is <em>pure</em> if all the maximal simplices have the same dimension.</p>
<p>A <em>triangulation</em> is a simplicial complex that is pure, connected and without boundaries nor singularities. The <em>dimension</em> of the triangulation is the dimension of its maximal simplices.</p>
<p>In the sequel, we will call these maximal simplices <em>full cells</em>. A <em>face</em> of a simplex is a subset of this simplex. A <em>proper face</em> of a simplex is a strict subset of this simplex. Two faces \( \sigma\) and \( \sigma'\) are <em>incident</em> if and only if \( \sigma'\) is a proper face of \( \sigma\) or <em>vice versa</em>.</p>
<p>A complex has <em>no boundaries</em> if any proper face of a simplex is also a proper face of another simplex.</p>
<p>If the triangulation is of dimension \( d \), we use the following terminology:</p><ul>
<li>
<em>face</em>: an \( i\)-face for some \( i\in[0,d]\); </li>
<li>
<em>vertex</em>: a \( 0\)-face; </li>
<li>
<em>edge</em>: a \( 1\)-face; </li>
<li>
<em>ridge</em>: a \( (d-2)\)-face; </li>
<li>
<em>facet</em>: a \( (d-1)\)-face; </li>
<li>
<em>full cell</em>: a \( d\)-face. </li>
</ul>
<p>If the vertices are embedded into Euclidean space \( \mathbb{R}^n\), we deal with <em>finite simplicial complexes</em>, which have slightly different simplices and additional requirements: </p><ul>
<li>
vertices correspond to points in space. </li>
<li>
a simplex \( s\in S\) is the convex hull of its vertices. </li>
<li>
the vertices of a simplex \( s\in S\) are affinely independent. </li>
<li>
the intersection of any two simplices of \( S\) is a proper face of both simplices (the empty set counts). </li>
</ul>
<h2>What is Provided in this Package?</h2>
<p>This <span style="font-variant: small-caps;">CGAL</span> package provides four main classes for creating and manipulating triangulations.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Triangulation__data__structure.html" title="This class is a data structure used for storing a triangulation of dimension  (D is the maximal dimen...">CGAL::Triangulation_data_structure</a>&lt;Dimensionality, TriangulationDSVertex_, TriangulationDSFullCell_&gt;</code> models an <em>abstract triangulation</em>: vertices in this class are not embedded in Euclidean space but are only of combinatorial nature.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Triangulation.html" title="This class implements triangulations of point sets in dimension . ">CGAL::Triangulation</a>&lt;TriangulationTraits_, TriangulationDataStructure_&gt;</code> describes an embedded triangulation that has as vertices a given set of points. Methods are provided for the insertion of points in the triangulation, the traversal of various elements of the triangulation, as well as the location of a query point inside the triangulation. The triangulation covers the convex hull of the set of points.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Delaunay__triangulation.html" title="This class is used to maintain the Delaunay triangulation of a set of points in . ...">CGAL::Delaunay_triangulation</a>&lt;DelaunayTriangulationTraits_, TriangulationDataStructure_&gt;</code> builds the Delaunay triangulation of a set of points. In a Delaunay triangulation, each face has the so-called <em>Delaunay</em> or <em>empty-ball</em> property: there exists a circumscribing ball whose interior does not contain any vertex of the triangulation.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Regular__triangulation.html" title="This class is used to maintain the regular triangulation – also known as weighted Delaunay triangula...">CGAL::Regular_triangulation</a>&lt;RegularTriangulationTraits_, TriangulationDataStructure_&gt;</code> builds the regular triangulation – also known as weighted Delaunay triangulation – of a set of points. A detailed definition of such a triangulation is available in section <a class="el" href="index.html#TriangulationSecRT">Regular Triangulations</a>.</p>
<h1><a class="anchor" id="TriangulationSecTDS"></a>
Triangulation Data Structure</h1>
<p>In this section, we describe the concept <code><a class="el" href="classTriangulationDataStructure.html" title="The TriangulationDataStructure concept describes objects responsible for storing and maintaining the ...">TriangulationDataStructure</a></code> for which <span style="font-variant: small-caps;">CGAL</span> provides one model class: <code><a class="el" href="classCGAL_1_1Triangulation__data__structure.html" title="This class is a data structure used for storing a triangulation of dimension  (D is the maximal dimen...">CGAL::Triangulation_data_structure</a>&lt;Dimensionality, TriangulationDSVertex_, TriangulationDSFullCell_&gt;</code>.</p>
<p>A triangulation data structure can represent an abstract triangulation.</p>
<p>The <em>maximal dimension</em> of a triangulation data structure is a positive integer equal to the maximum dimension a full cell can have. This maximal dimension can be chosen by the user at the creation of the triangulation data structure and can then be obtained using the method <code>tds.maximal_dimension()</code>. A triangulation data structure also knows the <em>current dimension</em> of its full cells, which can be obtained using <code>tds.current_dimension()</code>. In the sequel, let us denote the maximal dimension with \( D \) and the current dimension with \( d \). The inequalities \( -2 \leq d \leq D\) and \( 0 &lt; D\) always hold. The special meaning of negative values for \(d\) is explained below.</p>
<h2>The Set of Faces</h2>
<p>The set of faces of a triangulation data structure with current dimension \( d \) forms a triangulation of the topological sphere \( \mathbb{S}^d\).</p>
<p>Two full cells \( \sigma\) and \( \sigma'\) sharing a facet are called <em>neighbors</em>. A full cell has always exactly \( d+1\) neighbors.</p>
<p>Possible values of \(d\) (the <em>current dimension</em> of the triangulation) include </p><blockquote class="doxtable">
<dl>
<dt><b> \(d=-2\)</b></dt>
<dd>This corresponds to an empty triangulation data structure. </dd>
<dt><b> \(d=-1\)</b></dt>
<dd><p class="startdd">This corresponds to an abstract simplicial complex reduced to a single vertex.</p>
<p class="enddd"></p>
</dd>
<dt><b> \(d=0\)</b></dt>
<dd><p class="startdd">This corresponds to an abstract simplicial complex including two vertices, each corresponding to a full cell; the two full cells being neighbors of each other. This is the unique triangulation of the \( 0\)-sphere.</p>
<p class="enddd"></p>
</dd>
<dt><b> \( 0&lt; d \le D\)</b></dt>
<dd>This corresponds to a triangulation of the sphere \( \mathbb{S}^d\). </dd>
</dl>
</blockquote>
<h2>The <code><a class="el" href="classCGAL_1_1Triangulation__data__structure.html" title="This class is a data structure used for storing a triangulation of dimension  (D is the maximal dimen...">Triangulation_data_structure</a></code> Class</h2>
<p>We give here some details about the class <code><a class="el" href="classCGAL_1_1Triangulation__data__structure.html" title="This class is a data structure used for storing a triangulation of dimension  (D is the maximal dimen...">Triangulation_data_structure</a>&lt;Dimensionality, TriangulationDSVertex_, TriangulationDSFullCell_&gt;</code> implementing the concept <code><a class="el" href="classTriangulationDataStructure.html" title="The TriangulationDataStructure concept describes objects responsible for storing and maintaining the ...">TriangulationDataStructure</a></code>.</p>
<h3>Storage</h3>
<p>A triangulation data structure explicitly stores its vertices and full cells.</p>
<p>Each vertex stores a reference to one of its incident full cells.</p>
<p>Each full cell \( \sigma \) stores references to its \( d+1\) vertices and neighbors. Its vertices and neighbors are indexed from \( 0\) to \( d \). The indices of its neighbors have the following meaning: the \( i\)-th neighbor of \( \sigma\) is the unique neighbor of \( \sigma\) that does not contain the \( i\)-th vertex of \( \sigma\); in other words, it is the neighbor of \( \sigma\) <em>opposite</em> to the \( i\)-th vertex of \( \sigma\) (Figure <a class="el" href="index.html#fig__triangulationfigfullcell">Figure 45.1</a>).</p>
<p>The vertices and full cells of the triangulations are accessed through <code>handles</code> and <code>iterators</code>. A handle is a model of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/classHandle.html">Handle</a></code> concept, and supports the two dereference operators and <code>operator-&gt;</code>.</p>
<p><a class="anchor" id="fig__triangulationfigfullcell"></a></p><div class="image">
<img src="simplex-structure.png" alt="simplex-structure.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__triangulationfigfullcell">Figure 45.1</a> Indexing the vertices and neighbors of a full cell \( c\) in dimension \( d=2\).  </div>  <br />

<p>Faces of dimension between 0 and \( d-1 \) can be accessed as subfaces of a full cell, through the nested type <code>Face</code>. The <code>Face</code> instance corresponding to a face \( f \) stores a reference to a full cell <code>c</code> containing \( f \), and the indices of the vertices of <code>c</code> that belong to \( f \).</p>
<h3>Template Parameters</h3>
<p>The <code><a class="el" href="classCGAL_1_1Triangulation__data__structure.html" title="This class is a data structure used for storing a triangulation of dimension  (D is the maximal dimen...">Triangulation_data_structure</a>&lt;Dimensionality, TriangulationDSVertex_, TriangulationDSFullCell_&gt;</code> class is designed in such a way that its user can choose </p><ul>
<li>
the maximal dimension of the triangulation data structure by specifying the <code>Dimensionality</code> template parameter, </li>
<li>
the type used to represent vertices by specifying the <code>TriangulationDSVertex_</code> template parameter and </li>
<li>
the type used to represent full cells by specifying the <code>TriangulationDSFullCell_</code> template parameter. </li>
</ul>
<p>The last two parameters have default values and are thus not necessary, unless the user needs custom types (see <code><a class="el" href="classCGAL_1_1Triangulation__data__structure.html" title="This class is a data structure used for storing a triangulation of dimension  (D is the maximal dimen...">Triangulation_data_structure</a></code>). The first template parameter, <code>Dimensionality</code>, must be one of the following: </p><ul>
<li>
<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dimension__tag.html">CGAL::Dimension_tag</a>&lt;D&gt;</code> for some integer \( D \). This indicates that the triangulation can store full cells of dimension at most \( D \). The maximum dimension \( D \) is known by the compiler, which triggers some optimizations. </li>
<li>
<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dynamic__dimension__tag.html">CGAL::Dynamic_dimension_tag</a></code>. In this case, the maximum dimension of the full cells must be passed as an integer argument to an instance constructor (see <code><a class="el" href="classTriangulationDataStructure.html" title="The TriangulationDataStructure concept describes objects responsible for storing and maintaining the ...">TriangulationDataStructure</a></code>). </li>
</ul>
<p>The <code>TriangulationDSVertex_</code> and <code>TriangulationDSFullCell_</code> parameters to the class template must be models of the concepts <code><a class="el" href="classTriangulationDSVertex.html" title="The concept TriangulationDSVertex describes the requirements for the vertex base class of a CGAL::Tri...">TriangulationDSVertex</a></code> and <code><a class="el" href="classTriangulationDSFullCell.html" title="The concept TriangulationDSFullCell describes the requirements for the full cell class of a CGAL::Tri...">TriangulationDSFullCell</a></code> respectively. <span style="font-variant: small-caps;">CGAL</span> provides models for these concepts: <code><a class="el" href="classCGAL_1_1Triangulation__ds__vertex.html" title="The class Triangulation_ds_vertex serves as the default vertex template parameter in the class Triang...">Triangulation_ds_vertex</a>&lt;TriangulationDataStructure_&gt;</code> and <code><a class="el" href="classCGAL_1_1Triangulation__ds__full__cell.html" title="This class is the default model used for the full cell of the class Triangulation_data_structure. ">Triangulation_ds_full_cell</a>&lt;TriangulationDataStructure_, TriangulationDSFullCellStoragePolicy&gt;</code>, which, as one can see, take the triangulation data structure as a template parameter in order to get access to some nested types in <code>TriangulationDataStructure_</code>.</p>
<p>The default values are <code><a class="el" href="classCGAL_1_1Triangulation__ds__vertex.html" title="The class Triangulation_ds_vertex serves as the default vertex template parameter in the class Triang...">CGAL::Triangulation_ds_vertex</a>&lt;TDS&gt;</code> and <code><a class="el" href="classCGAL_1_1Triangulation__ds__full__cell.html" title="This class is the default model used for the full cell of the class Triangulation_data_structure. ">CGAL::Triangulation_ds_full_cell</a>&lt;TDS&gt;</code> where <code>TDS</code> is the current class <code><a class="el" href="classCGAL_1_1Triangulation__data__structure.html" title="This class is a data structure used for storing a triangulation of dimension  (D is the maximal dimen...">Triangulation_data_structure</a>&lt;Dimensionality, TriangulationDSVertex_, TriangulationDSFullCell_&gt;</code>. <em>This creates a circular dependency</em>, which we resolve in the same way as in the <span style="font-variant: small-caps;">CGAL</span> <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__2.html">Triangulation_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_3.tag:../Triangulation_3/" href="../Triangulation_3/classCGAL_1_1Triangulation__3.html">Triangulation_3</a></code> packages (see Chapters <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/index.html#Chapter_2D_Triangulation_Data_Structure">Chapter_2D_Triangulation_Data_Structure</a>, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/index.html#Chapter_2D_Triangulations">Chapter_2D_Triangulations</a>, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/TDS_3.tag:../TDS_3/" href="../TDS_3/index.html#Chapter_3D_Triangulation_Data_Structure">Chapter_3D_Triangulation_Data_Structure</a>, and <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_3.tag:../Triangulation_3/" href="../Triangulation_3/index.html#Chapter_3D_Triangulations">Chapter_3D_Triangulations</a>). In particular, models of the concepts <code><a class="el" href="classTriangulationDSVertex.html" title="The concept TriangulationDSVertex describes the requirements for the vertex base class of a CGAL::Tri...">TriangulationDSVertex</a></code> and <code><a class="el" href="classTriangulationDSFullCell.html" title="The concept TriangulationDSFullCell describes the requirements for the full cell class of a CGAL::Tri...">TriangulationDSFullCell</a></code> must provide a nested template <code>Rebind_TDS</code> which is documented in those two concept's reference manual pages. This mechanism can be used to provide a custom vertex or full cell class. The user is encouraged to read the documentation of the <span style="font-variant: small-caps;">CGAL</span> <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__2.html">Triangulation_2</a></code> or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_3.tag:../Triangulation_3/" href="../Triangulation_3/classCGAL_1_1Triangulation__3.html">Triangulation_3</a></code> package.</p>
<h2>Examples</h2>
<h3>Incremental Construction</h3>
<p>The following examples shows how to construct a triangulation data structure by inserting vertices. Its main interest is that it demonstrates most of the API to insert new vertices into the triangulation.</p>
<p><br />
<b>File</b> <a class="el" href="triangulation_data_structure_static_8cpp-example.html">triangulation_data_structure_static.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_data_structure.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/assertions.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__data__structure.html">CGAL::Triangulation_data_structure&lt;CGAL::Dimension_tag&lt;7&gt;</a> &gt; TDS;</div><div class="line"></div><div class="line">  TDS S;</div><div class="line">  CGAL_assertion( 7 == S.maximal_dimension() );</div><div class="line">  CGAL_assertion( -2 == S.current_dimension() );</div><div class="line">  CGAL_assertion( S.is_valid() );</div><div class="line"></div><div class="line">  std::vector&lt;TDS::Vertex_handle&gt; V(10);</div><div class="line">  V[0] = S.insert_increase_dimension(); <span class="comment">//insert first vertex</span></div><div class="line">  CGAL_assertion( -1 == S.current_dimension() );</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 1; i &lt;= 5; ++i )</div><div class="line">      V[i] = S.insert_increase_dimension(V[0]);</div><div class="line">  <span class="comment">// the first 6 vertices have created a triangulation</span></div><div class="line">  <span class="comment">// of the 4-dimensional topological sphere </span></div><div class="line">  <span class="comment">// (the boundary of a five dimensional simplex).</span></div><div class="line">  CGAL_assertion( 4 == S.current_dimension() );</div><div class="line">  CGAL_assertion( 6 == S.number_of_vertices() );</div><div class="line">  CGAL_assertion( 6 == S.number_of_full_cells() );</div><div class="line"></div><div class="line">  TDS::Full_cell_handle c = V[5]-&gt;full_cell();</div><div class="line">  V[6] = S.insert_in_full_cell(c);</div><div class="line">  <span class="comment">// full cell c is split in 5</span></div><div class="line">  CGAL_assertion( 7 == S.number_of_vertices() );</div><div class="line">  CGAL_assertion( 10 == S.number_of_full_cells() );</div><div class="line"></div><div class="line">  c = V[3]-&gt;full_cell();</div><div class="line">  TDS::Facet ft(c, 2); <span class="comment">// the Facet opposite to vertex 2 in c</span></div><div class="line">  V[7] = S.insert_in_facet(ft);</div><div class="line">  <span class="comment">// facet ft is split in 4 and the two incident cells are split accordingly</span></div><div class="line">  CGAL_assertion( 8 == S.number_of_vertices() );</div><div class="line">  CGAL_assertion( 16 == S.number_of_full_cells() );</div><div class="line"></div><div class="line">  c = V[3]-&gt;full_cell();</div><div class="line">  TDS::Face face(c);  </div><div class="line">  <span class="comment">// meant to contain the edge joining vertices 2 and 4 of full_cell c</span></div><div class="line">  face.set_index(0, 2); <span class="comment">// namely vertex 2</span></div><div class="line">  face.set_index(1, 4); <span class="comment">// and vertex 4</span></div><div class="line">  V[8] = S.insert_in_face(face);</div><div class="line">  <span class="comment">// face is split in 2, and all incident full cells also</span></div><div class="line">  CGAL_assertion( S.is_valid() );</div><div class="line"></div><div class="line">  TDS::Full_cell_handle hole[2];</div><div class="line">  hole[0] = V[8]-&gt;full_cell();</div><div class="line">  hole[1] = hole[0]-&gt;neighbor(0);</div><div class="line">  <span class="comment">// the hole is made of two adjacent full cells</span></div><div class="line">  ft = TDS::Facet(hole[0], 1);  <span class="comment">// a face on the boundary of hole[0]</span></div><div class="line">  V[9] = S.insert_in_hole(hole, hole+2, ft);</div><div class="line">  <span class="comment">// the hole is triangulated by linking a new vertex to its boundary</span></div><div class="line">  CGAL_assertion( S.is_valid() );</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>In the previous example, the maximal dimension is fixed at compile time. It is also possible to fix it at run time, as in the next example.</p>
<p><br />
<b>File</b> <a class="el" href="triangulation_data_structure_dynamic_8cpp-example.html">triangulation_data_structure_dynamic.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_data_structure.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/assertions.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> ddim = 5; <span class="comment">// dimension of TDS with dynamic dimension</span></div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__data__structure.html">CGAL::Triangulation_data_structure&lt;CGAL::Dynamic_dimension_tag&gt;</a></div><div class="line">          TDS;</div><div class="line">  <span class="keyword">typedef</span> TDS::Vertex_handle    Vertex_handle;</div><div class="line">  TDS D(ddim); <span class="comment">// the argument is taken into account.</span></div><div class="line"></div><div class="line">  CGAL_assertion( ddim == D.maximal_dimension() );</div><div class="line">  CGAL_assertion( -2 == D.current_dimension() );</div><div class="line">  CGAL_assertion( D.is_valid() );</div><div class="line">  std::vector&lt;Vertex_handle&gt; V(5);</div><div class="line">  V[0] = D.insert_increase_dimension();</div><div class="line">  V[1] = D.insert_increase_dimension(V[0]);</div><div class="line">  V[2] = D.insert_increase_dimension(V[0]);</div><div class="line">  V[3] = D.insert_increase_dimension(V[0]);</div><div class="line">  V[4] = D.insert_in_full_cell(V[3]-&gt;full_cell());</div><div class="line">  CGAL_assertion( 6 == D.number_of_full_cells() );</div><div class="line">  CGAL_assertion( 2 == D.current_dimension() );</div><div class="line">  CGAL_assertion( D.is_valid() );</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>Barycentric Subdivision</h3>
<p>This example provides a function for computing the barycentric subdivision of a single full cell <code>c</code> in a triangulation data structure. The other full cells adjacent to <code>c</code> are automatically subdivided to match the subdivision of the full cell <code>c</code>. The barycentric subdivision of <code>c</code> is obtained by enumerating all the faces of <code>c</code> in order of decreasing dimension, from the dimension of <code>c</code> to dimension 1, and inserting a new vertex in each face.</p>
<p><a class="anchor" id="fig__triangulationfigbarycentric"></a></p><div class="image">
<img src="barycentric-subdivision.png" alt="barycentric-subdivision.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__triangulationfigbarycentric">Figure 45.2</a> Barycentric subdivision in dimension \( d=2\).  </div>  <br />

<p><br />
<b>File</b> <a class="el" href="barycentric_subdivision_8cpp-example.html">barycentric_subdivision.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_data_structure.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Combination_enumerator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/assertions.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> TDS &gt;</div><div class="line"><span class="keywordtype">void</span> find_face_from_vertices(<span class="keyword">const</span> TDS &amp; tds,</div><div class="line">        <span class="keyword">const</span> std::vector&lt;typename TDS::Vertex_handle&gt; &amp; face_vertices,</div><div class="line">        <span class="keyword">typename</span> TDS::Face &amp; face);</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> TDS &gt;</div><div class="line"><span class="keywordtype">void</span> barycentric_subdivide(TDS &amp; tds, <span class="keyword">typename</span> TDS::Full_cell_handle fc)</div><div class="line">{ <span class="comment">/* This function builds the barycentric subdivision of a single</span></div><div class="line"><span class="comment">     full cell |fc| from a triangulation data structure |tds|.  */</span></div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> TDS::Vertex_handle Vertex_handle;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> TDS::Face Face;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> dim = tds.current_dimension();</div><div class="line"></div><div class="line">    <span class="comment">// First, read handles to the cell's vertices</span></div><div class="line">    std::vector&lt;Vertex_handle&gt; vertices;</div><div class="line">    std::vector&lt;Vertex_handle&gt; face_vertices;</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt;= dim; ++i ) vertices.push_back(fc-&gt;vertex(i));</div><div class="line"></div><div class="line">    <span class="comment">// Then, subdivide the cell |fc| once by inserting one vertex</span></div><div class="line">    tds.insert_in_full_cell(fc);</div><div class="line">    <span class="comment">// From now on, we can't use the variable |fc|...</span></div><div class="line"></div><div class="line">    <span class="comment">// Then, subdivide faces of |fc| in order of decreasing dimension</span></div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> d = dim-1; d &gt; 0; --d )</div><div class="line">    {</div><div class="line">        face_vertices.resize(d+1);</div><div class="line">        <span class="comment">// The following class</span></div><div class="line">        <span class="comment">// enumerates all (d+1)-tuple of the set {0, 1, ..., dim}</span></div><div class="line">        CGAL::Combination_enumerator&lt;unsigned int&gt; combi(d+1, 0, dim);</div><div class="line">        <span class="keywordflow">while</span> ( !combi.finished() )</div><div class="line">        {</div><div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt;= d; ++i )</div><div class="line">                face_vertices[i] = vertices[combi[i]];</div><div class="line">            <span class="comment">// we need to find a face with face_vertices</span></div><div class="line">            Face face(dim);</div><div class="line">            find_face_from_vertices(tds, face_vertices, face);</div><div class="line">            tds.insert_in_face(face);</div><div class="line">            ++combi;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> TDS &gt;</div><div class="line"><span class="keywordtype">void</span> find_face_from_vertices( <span class="keyword">const</span> TDS &amp; tds,</div><div class="line">        <span class="keyword">const</span> std::vector&lt;typename TDS::Vertex_handle&gt; &amp; face_vertices,</div><div class="line">        <span class="keyword">typename</span> TDS::Face &amp; face)</div><div class="line">{ <span class="comment">/* The main goal of this function is to find a full cell that</span></div><div class="line"><span class="comment">     contains a given set of vertices |face_vertices|. Then, it</span></div><div class="line"><span class="comment">     builds a corresponding |face|. */</span></div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> TDS::Vertex_handle           Vertex_handle;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> TDS::Full_cell_handle        Full_cell_handle;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> TDS::Full_cell::Vertex_handle_iterator Vertex_h_iterator;</div><div class="line"></div><div class="line">    <span class="comment">// get the dimension of the face we want to build</span></div><div class="line">    std::size_t fdim(face_vertices.size() - 1);</div><div class="line">    <span class="keywordflow">if</span>( fdim &lt;= 0) exit(-1);</div><div class="line"></div><div class="line">    <span class="comment">// find all full cells incident to the first vertex of |face|</span></div><div class="line">    <span class="keyword">typedef</span> std::vector&lt;Full_cell_handle&gt; Cells;</div><div class="line">    Cells cells;</div><div class="line">    std::back_insert_iterator&lt;Cells&gt; out(cells);</div><div class="line">    tds.incident_full_cells(face_vertices[0], out);</div><div class="line">    <span class="comment">// Iterate over the cells to find one which contains the face_vertices</span></div><div class="line">    <span class="keywordflow">for</span>( <span class="keyword">typename</span> Cells::iterator cit = cells.begin(); cit != cells.end(); ++cit){</div><div class="line">        <span class="comment">// find if the cell *cit contains the Face |face|</span></div><div class="line">        std::size_t i = 0;</div><div class="line">        <span class="keywordflow">for</span>( ; i &lt;= fdim; ++i ) {</div><div class="line">            Vertex_handle face_v(face_vertices[i]);</div><div class="line">            <span class="keywordtype">bool</span> found(<span class="keyword">false</span>);</div><div class="line">            Vertex_h_iterator vit = (*cit)-&gt;vertices_begin();</div><div class="line">            <span class="keywordflow">for</span>( ; vit != (*cit)-&gt;vertices_end(); ++vit ) {</div><div class="line">                <span class="keywordflow">if</span>( *vit == face_v ) {</div><div class="line">                    found = <span class="keyword">true</span>;</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">if</span>( ! found )</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span>( i &gt; fdim ) {<span class="comment">// the full cell |*cit| contains |face|</span></div><div class="line">            face.set_full_cell(*cit);</div><div class="line">            <span class="keywordflow">for</span>( std::size_t i = 0; i &lt;= fdim; ++i )</div><div class="line">            {</div><div class="line">              face.set_index(static_cast&lt;int&gt;(i), </div><div class="line">                             (*cit)-&gt;index(face_vertices[i]));</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Could not build a face from vertices"</span>&lt;&lt;std::endl;</div><div class="line">    CGAL_assertion(<span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> sdim = 5; <span class="comment">// dimension of TDS with compile-time dimension</span></div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__data__structure.html">CGAL::Triangulation_data_structure&lt;CGAL::Dimension_tag&lt;sdim&gt;</a> &gt;</div><div class="line">        TDS;</div><div class="line">    TDS  tds(sdim);</div><div class="line"></div><div class="line">    TDS::Vertex_handle one_vertex = tds.insert_increase_dimension();</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 1; i &lt; sdim+2; ++i )</div><div class="line">        tds.insert_increase_dimension(one_vertex);</div><div class="line">    <span class="comment">// we get a triangulation of space of dim sdim homeomorphic to</span></div><div class="line">    <span class="comment">// the boundary of simplex of dimension sdim+1 with sdim+2 vertices</span></div><div class="line">    CGAL_assertion( sdim   == tds.current_dimension() );</div><div class="line">    CGAL_assertion( 2+sdim == tds.number_of_vertices() );</div><div class="line">    CGAL_assertion( 2+sdim == tds.number_of_full_cells() );</div><div class="line"></div><div class="line">    barycentric_subdivide(tds, tds.full_cells_begin());</div><div class="line"></div><div class="line">    <span class="comment">// The number of full cells should be twice the factorial of</span></div><div class="line">    <span class="comment">// |tds.current_dimension()+1|. Eg, 1440 for dimension 5.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Triangulation has "</span> </div><div class="line">        &lt;&lt; tds.number_of_full_cells() &lt;&lt; <span class="stringliteral">" full cells"</span>;</div><div class="line">    CGAL_assertion( tds.is_valid() );</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" and is valid!"</span>&lt;&lt;std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="TriangulationSecTriangulations"></a>
Triangulations</h1>
<p>The class <code><a class="el" href="classCGAL_1_1Triangulation.html" title="This class implements triangulations of point sets in dimension . ">CGAL::Triangulation</a>&lt;TriangulationTraits_, TriangulationDataStructure_&gt;</code> maintains a triangulation embedded in Euclidean space. The triangulation covers the convex hull of the input points (the embedded vertices of the triangulation).</p>
<p>To store this triangulation in a triangulation data structure, we turn the set of its faces into a topological sphere by adding a fictitious vertex, called the <em>infinite vertex</em>, as well as infinite simplices incident to boundary faces of the convex hull. Each infinite \( i\)-simplex is incident to the infinite vertex and to an \( (i-1)\)-simplex of the convex hull boundary.</p>
<p>See Chapters <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/index.html#Chapter_2D_Triangulations">2D Triangulations</a> or <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_3.tag:../Triangulation_3/" href="../Triangulation_3/index.html#Chapter_3D_Triangulations">3D Triangulations</a> for more details about infinite vertices and cells.</p>
<p>Methods are provided for the insertion of points in the triangulation, the contraction of faces, the traversal of various elements of the triangulation as well as the location of a query point inside the triangulation.</p>
<p>The ordering of the vertices of a full cell defines an orientation of that full cell. As long as no <em>advanced</em> class method is called, it is guaranteed that all finite full cells have positive orientation. Each infinite full cell is oriented as if its infinite vertex was on the side of the hyperplane supported by its finite facet where there is no other point.</p>
<h2>Implementation</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Triangulation.html" title="This class implements triangulations of point sets in dimension . ">CGAL::Triangulation</a>&lt;TriangulationTraits_, TriangulationDataStructure_&gt;</code> stores a model of the concept <code><a class="el" href="classTriangulationDataStructure.html" title="The TriangulationDataStructure concept describes objects responsible for storing and maintaining the ...">TriangulationDataStructure</a></code> that is instantiated with a vertex type that stores a point.</p>
<p>The template parameter <code>TriangulationTraits_</code> must be a model of the concept <code><a class="el" href="classTriangulationTraits.html" title="This concept describes the geometric types and predicates required to build a triangulation. It corresponds to the first template parameter of the class CGAL::Triangulation&lt;TriangulationTraits_, TriangulationDataStructure_&gt;. ">TriangulationTraits</a></code>, which provides the point type as well as various geometric predicates used by the <code><a class="el" href="classCGAL_1_1Triangulation.html" title="This class implements triangulations of point sets in dimension . ">Triangulation</a></code> class.</p>
<p>The <code><a class="el" href="classTriangulationTraits.html" title="This concept describes the geometric types and predicates required to build a triangulation. It corresponds to the first template parameter of the class CGAL::Triangulation&lt;TriangulationTraits_, TriangulationDataStructure_&gt;. ">TriangulationTraits</a></code> concept includes a nested type <code><a class="el" href="classTriangulationTraits.html#a333a19426aa60c3363af494782caa891" title="A type representing the dimension of the predicates (but not necessarily the one of Point_d)...">TriangulationTraits::Dimension</a></code>. This dimension governs the number of points given as arguments to the predicates. This type is either <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dimension__tag.html">CGAL::Dimension_tag</a>&lt;D&gt;</code> or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dynamic__dimension__tag.html">CGAL::Dynamic_dimension_tag</a></code>. In any case, the dimension of the traits must match the maximal dimension of the triangulation data structure.</p>
<p>The template parameter <code>TriangulationDataStructure_</code> must be a model of the concept <code><a class="el" href="classTriangulationDataStructure.html" title="The TriangulationDataStructure concept describes objects responsible for storing and maintaining the ...">TriangulationDataStructure</a></code> which provides the triangulation data structure as described in the previous section.</p>
<h2>Examples</h2>
<h3>Incremental Construction</h3>
<p>The following example shows how to construct a triangulation in which we insert random points. In <code>STEP 1</code>, we generate one hundred random points in \( \mathbb{R}^5\), which we then insert into a triangulation. In <code>STEP 2</code>, we ask the triangulation to construct the set of edges ( \( 1\) dimensional faces) incident to the vertex at infinity. It is easy to see that these edges are in bijection with the vertices on the convex hull of the points. This gives us a handy way to count the convex hull vertices (include files <code>triangulation1.cpp</code> and <code>triangulation2.cpp</code> are given and commented below).</p>
<p><br />
<b>File</b> <a class="el" href="triangulation_8cpp-example.html">triangulation.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined(__GNUC__) &amp;&amp; defined(__GNUC_MINOR__) &amp;&amp; (__GNUC__ &lt;= 4) &amp;&amp; (__GNUC_MINOR__ &lt; 4)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"NOTICE: This test requires G++ &gt;= 4.4, and will not be compiled."</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Epick_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/algorithm.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/assertions.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/structCGAL_1_1Epick__d.html">CGAL::Epick_d&lt; CGAL::Dynamic_dimension_tag &gt;</a>  K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation.html">CGAL::Triangulation&lt;K&gt;</a>                        Triangulation;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> D = 5;   <span class="comment">// we work in Euclidean 5-space</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> N = 100; <span class="comment">// we will insert 100 points</span></div><div class="line">    <span class="comment">// - - - - - - - - - - - - - - - - - - - - - - - - STEP 1</span></div><div class="line">    CGAL::Random_points_in_cube_d&lt;Triangulation::Point&gt; rand_it(D, 1.0);</div><div class="line">    std::vector&lt;Triangulation::Point&gt; points;</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gadba21cc5c30a79519438dfe0f9264255">CGAL::cpp11::copy_n</a>(rand_it, N, std::back_inserter(points));</div><div class="line"></div><div class="line">    Triangulation t(D);                      <span class="comment">// create triangulation</span></div><div class="line">    CGAL_assertion(t.empty());</div><div class="line">    t.insert(points.begin(), points.end());  <span class="comment">// compute triangulation</span></div><div class="line">    CGAL_assertion( t.is_valid() );</div><div class="line">    <span class="comment">// - - - - - - - - - - - - - - - - - - - - - - - - STEP 2</span></div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation.html#ada52cef984f0e0c3a4feba1caaf5b2ba">Triangulation::Face</a> Face;</div><div class="line">    <span class="keyword">typedef</span> std::vector&lt;Face&gt; Faces;</div><div class="line">    Faces edges;</div><div class="line">    std::back_insert_iterator&lt;Faces&gt; out(edges);</div><div class="line">    t.tds().incident_faces(t.infinite_vertex(), 1, out);  </div><div class="line">    <span class="comment">// collect faces of dimension 1 (edges) incident to the infinite vertex</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"There are "</span> &lt;&lt; edges.size() </div><div class="line">              &lt;&lt; <span class="stringliteral">" vertices on the convex hull."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="preprocessor">#include "triangulation1.cpp"</span> <span class="comment">// See below</span></div><div class="line"><span class="preprocessor">#include "triangulation2.cpp"</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h3>Traversing the Facets of the Convex Hull</h3>
<p>Remember that a triangulation covers the convex hull of its vertices. Each facet of the convex hull is incident to one finite full cell and one infinite full cell. In fact there is a bijection between the infinite full cells and the facets of the convex hull. If vertices are not in general position, convex hull faces that are not simplices are triangulated. In order to traverse the convex hull facets, there are (at least) two possibilities:</p>
<p>The first is to iterate over the full cells of the triangulation and check if they are infinite or not:</p>
<p><br />
<b>File</b> <a class="el" href="triangulation1_8cpp-example.html">triangulation1.cpp</a> </p><div class="fragment"><div class="line">{ <span class="keywordtype">int</span> i=0;</div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation.html#a912c8764d774b853ee4965418ab39840">Triangulation::Full_cell_iterator</a> Full_cell_iterator;</div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation.html#a8b1939b059439a2039f0138e390c4955">Triangulation::Facet</a> Facet;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>( Full_cell_iterator cit = t.full_cells_begin();</div><div class="line">       cit != t.full_cells_end(); ++cit )</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span>( ! t.is_infinite(cit) )</div><div class="line">    <span class="keywordflow">continue</span>;</div><div class="line">      Facet ft(cit, cit-&gt;index(t.infinite_vertex()));</div><div class="line">      ++i;<span class="comment">// |ft| is a facet of the convex hull</span></div><div class="line">    }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"There are "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" facets on the convex hull."</span>&lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>A second possibility is to ask the triangulation to gather all the full cells incident to the infinite vertex: they form precisely the set of infinite full cells:</p>
<p><br />
<b>File</b> <a class="el" href="triangulation2_8cpp-example.html">triangulation2.cpp</a> </p><div class="fragment"><div class="line">{ <span class="keywordtype">int</span> i=0;</div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation.html#a9dc0c1f6f1974fbc59ad55e172bdbe0a">Triangulation::Full_cell_handle</a> Full_cell_handle;</div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation.html#a8b1939b059439a2039f0138e390c4955">Triangulation::Facet</a> Facet;</div><div class="line">  <span class="keyword">typedef</span> std::vector&lt;Full_cell_handle&gt; Full_cells;</div><div class="line">  </div><div class="line">  Full_cells infinite_full_cells;</div><div class="line">  std::back_insert_iterator&lt;Full_cells&gt; out(infinite_full_cells);</div><div class="line">  </div><div class="line">  t.incident_full_cells(t.infinite_vertex(), out);</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span>( Full_cells::iterator sit = infinite_full_cells.begin();</div><div class="line">       sit != infinite_full_cells.end(); ++sit )</div><div class="line">    {</div><div class="line">      Facet ft(*sit, (*sit)-&gt;index(t.infinite_vertex()));</div><div class="line">      ++i; <span class="comment">// |ft| is a facet of the convex hull</span></div><div class="line">    }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"There are "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" facets on the convex hull."</span>&lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>One important difference between the two examples above is that the first uses <em>little</em> memory but traverses <em>all</em> the full cells, while the second visits <em>only</em> the infinite full cells but stores handles to them into the <em>potentially big</em> array <code>infinite_full_cells</code>.</p>
<h1><a class="anchor" id="TriangulationSecDT"></a>
Delaunay Triangulations</h1>
<p>The class <code><a class="el" href="classCGAL_1_1Delaunay__triangulation.html" title="This class is used to maintain the Delaunay triangulation of a set of points in . ...">CGAL::Delaunay_triangulation</a>&lt;DelaunayTriangulationTraits_, TriangulationDataStructure_&gt;</code> derives from <code><a class="el" href="classCGAL_1_1Triangulation.html" title="This class implements triangulations of point sets in dimension . ">CGAL::Triangulation</a>&lt;DelaunayTriangulationTraits_, TriangulationDataStructure_&gt;</code> and represents Delaunay triangulations.</p>
<p>A <em>circumscribing ball</em> of a simplex is a ball having all vertices of the simplex on its boundary. In a Delaunay triangulation, each face has the so-called <em>Delaunay</em> or <em>empty-ball</em> property: there exists a circumscribing ball whose interior does not contain any vertex of the triangulation.</p>
<p>In case of degeneracies (co-spherical points) the triangulation is not uniquely defined. Note however that the <a class="el" href="namespaceCGAL.html">CGAL</a> implementation computes a unique triangulation even in these cases.</p>
<p>When a new point <code>p</code> is inserted into a Delaunay triangulation, the full cells whose circumscribing ball contains <code>p</code> are said to <em>be in conflict</em> with point <code>p</code>. Note that the circumscribing ball of an infinite full cell is the empty half-space bounded by the affine hull of the finite facet of this cell. The set of full cells that are in conflict with <code>p</code> form the <em>conflict zone</em>. The full cells in the conflict zone are removed, leaving a hole that contains <code>p</code>. That hole is ``star shaped'' around <code>p</code> and thus is re-triangulated using <code>p</code> as a center vertex.</p>
<p>Delaunay triangulations support insertion of points, removal of vertices, and location of a query point inside the triangulation. Note that inserting a large set of points at once is much faster than inserting the same points one by one.</p>
<h2>Implementation</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Delaunay__triangulation.html" title="This class is used to maintain the Delaunay triangulation of a set of points in . ...">CGAL::Delaunay_triangulation</a>&lt;DelaunayTriangulationTraits_, TriangulationDataStructure_&gt;</code> derives from <code><a class="el" href="classCGAL_1_1Triangulation.html" title="This class implements triangulations of point sets in dimension . ">CGAL::Triangulation</a>&lt;DelaunayTriangulationTraits_, TriangulationDataStructure_&gt;</code>. It thus stores a model of the concept <code><a class="el" href="classTriangulationDataStructure.html" title="The TriangulationDataStructure concept describes objects responsible for storing and maintaining the ...">TriangulationDataStructure</a></code>, which is instantiated with a vertex type that stores a geometric point and allows its retrieval.</p>
<p>The template parameter <code>DelaunayTriangulationTraits_</code> must be a model of the concept <code><a class="el" href="classDelaunayTriangulationTraits.html" title="This concept describes the geometric types and predicates required to build a Delaunay triangulation...">DelaunayTriangulationTraits</a></code> which provides the geometric <code>Point</code> type as well as various geometric predicates used by the <code><a class="el" href="classCGAL_1_1Delaunay__triangulation.html" title="This class is used to maintain the Delaunay triangulation of a set of points in . ...">Delaunay_triangulation</a></code> class. The concept <code><a class="el" href="classDelaunayTriangulationTraits.html" title="This concept describes the geometric types and predicates required to build a Delaunay triangulation...">DelaunayTriangulationTraits</a></code> refines the concept <code><a class="el" href="classTriangulationTraits.html" title="This concept describes the geometric types and predicates required to build a triangulation. It corresponds to the first template parameter of the class CGAL::Triangulation&lt;TriangulationTraits_, TriangulationDataStructure_&gt;. ">TriangulationTraits</a></code> by requiring a few additional geometric predicates, necessary for the computation of Delaunay triangulations.</p>
<h2>Examples</h2>
<h3>Access to the Conflict Zone and to the Full Cells Created during Point Insertion</h3>
<p>When using a full cell type containing additional custom information, it may be useful to get an efficient access to the full cells that are going to be erased upon the insertion of a new point in the Delaunay triangulation, and to the newly created full cells. The second part of code example below shows how one can have efficient access to both the conflict zone and the created full cells, while still retaining an efficient update of the Delaunay triangulation.</p>
<p><br />
<b>File</b> <a class="el" href="delaunay_triangulation_8cpp-example.html">delaunay_triangulation.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined(__GNUC__) &amp;&amp; defined(__GNUC_MINOR__) &amp;&amp; (__GNUC__ &lt;= 4) &amp;&amp; (__GNUC_MINOR__ &lt; 4)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"NOTICE: This test requires G++ &gt;= 4.4, and will not be compiled."</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Epick_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> pointsIn[][7] = {</div><div class="line">    { 42.89, 0, 60.55, 30.72, 0, 0, 0 },</div><div class="line">    { 45.65, 50.83, 50.37, 16.13, 0, 0, 0 },</div><div class="line">    { 79.06, 57.84, 61.59, 2.52, 0, 0, 0 },</div><div class="line">    { 44.47, 39.46, 39.53, 28.72, 0, 0, 0 },</div><div class="line">    { 0, 100, 0, 0, 100, 0, 53.47 },</div><div class="line">    { 66.95, 100, 33.6, 0, 0, 0, 0 },</div><div class="line">    { 42.89, 0, 0, 30.72, 100, 0, 53.47 },</div><div class="line">    { 100, 100, 100, 100, 100, 100, 100 }</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation.html">CGAL::Triangulation&lt;CGAL::Epick_d&lt; CGAL::Dimension_tag&lt;7&gt;</a> &gt; &gt;      T;</div><div class="line">  T dt(7);</div><div class="line"></div><div class="line">  std::vector&lt;T::Point&gt; points;</div><div class="line">  points.reserve(8);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 8; ++j) {</div><div class="line">    T::Point p(&amp;pointsIn[j][0], &amp;pointsIn[j][7]);</div><div class="line">    points.push_back(p);</div><div class="line">  }</div><div class="line"></div><div class="line">  T::Vertex_handle hint;</div><div class="line">  <span class="keywordtype">int</span> i = 0;</div><div class="line">  <span class="keywordflow">for</span> (std::vector&lt;T::Point&gt;::iterator it = points.begin(); it != points.end(); ++it) {</div><div class="line">    <span class="keywordflow">if</span> (T::Vertex_handle() != hint) {</div><div class="line">      hint = dt.insert(*it, hint);</div><div class="line">  }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">      hint = dt.insert(*it);</div><div class="line">    }</div><div class="line">    printf(<span class="stringliteral">"Processing: %d/%d\n"</span>, ++i, (<span class="keywordtype">int</span>)points.size());</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h1><a class="anchor" id="TriangulationSecRT"></a>
Regular Triangulations</h1>
<p>The class <code><a class="el" href="classCGAL_1_1Regular__triangulation.html" title="This class is used to maintain the regular triangulation – also known as weighted Delaunay triangula...">CGAL::Regular_triangulation</a>&lt;RegularTriangulationTraits_, TriangulationDataStructure_&gt;</code> derives from <code><a class="el" href="classCGAL_1_1Triangulation.html" title="This class implements triangulations of point sets in dimension . ">CGAL::Triangulation</a>&lt;RegularTriangulationTraits_, TriangulationDataStructure_&gt;</code> and represents regular triangulations.</p>
<p>Regular triangulations are also known as weighted Delaunay triangulations.</p>
<p>Let \( {S}^{(w)}\) be a set of weighted points in \( \mathbb{R}^D\). Let \( {p}^{(w)}=(p,w_p), p\in\mathbb{R}^D, w_p\in\mathbb{R}\) and \( {z}^{(w)}=(z,w_z), z\in\mathbb{R}^D, w_z\in\mathbb{R}\) be two weighted points. A weighted point \( {p}^{(w)}=(p,w_p)\) can also be seen as a sphere of center \( p\) and radius \( \sqrt{w_p}\). The <em>power product</em> (or <em>power distance</em> ) between \( {p}^{(w)}\) and \( {z}^{(w)}\) is defined as </p><p class="formulaDsp">
\[ \Pi({p}^{(w)},{z}^{(w)}) = {\|{p-z}\|^2-w_p-w_z} \]
</p>
<p> where \( \|{p-z}\|\) is the Euclidean distance between \( p\) and \( z\). \( {p}^{(w)}\) and \( {z}^{(w)}\) are said to be <em>orthogonal</em> if \( \Pi({p}^{(w)},{z}^{(w)}) = 0\).</p>
<p>\(D + 1\) weighted points have a unique common orthogonal weighted point called the <em>power sphere</em>. A sphere \( {z}^{(w)}\) is said to be <em>regular</em> if \( \forall {p}^{(w)}\in{S}^{(w)}, \Pi({p}^{(w)},{z}^{(w)})\geq 0\).</p>
<p>A triangulation of \( {S}^{(w)}\) is <em>regular</em> if the power spheres of all simplices are regular.</p>
<p>Note that as a result, some points can be hidden and do not result in vertices in the triangulation. Those points are discarded and cannot be retrieved.</p>
<p>A weighted point <code>p</code> is said to be in conflict with a simplex <code>s</code> if it has a negative power distance to the power sphere of <code>s</code>.</p>
<p>Regular triangulations support insertion of weighted points, and location of a query point inside the triangulation. Note that inserting a large set of points at once is much faster than inserting the same points one by one. </p><dl class="section warning"><dt>Warning</dt><dd>The removal of vertices is not supported yet.</dd></dl>
<h2>Implementation</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Regular__triangulation.html" title="This class is used to maintain the regular triangulation – also known as weighted Delaunay triangula...">CGAL::Regular_triangulation</a>&lt;RegularTriangulationTraits_, TriangulationDataStructure_&gt;</code> derives from <code><a class="el" href="classCGAL_1_1Triangulation.html" title="This class implements triangulations of point sets in dimension . ">CGAL::Triangulation</a>&lt;RegularTriangulationTraits_, TriangulationDataStructure_&gt;</code>. It thus stores a model of the concept <code>TriangulationDataStructure_</code> which is instantiated with a vertex type that stores a weighted point and allows its retrieval.</p>
<p>The template parameter <code>RegularTriangulationTraits_</code> must be a model of the concept <code><a class="el" href="classRegularTriangulationTraits.html" title="This concept describes the geometric types and predicates required to build a regular triangulation...">RegularTriangulationTraits</a></code>. It must provide the <code>Weighted_point_d</code> type as well as various geometric predicates used by the <code><a class="el" href="classCGAL_1_1Regular__triangulation.html" title="This class is used to maintain the regular triangulation – also known as weighted Delaunay triangula...">Regular_triangulation</a></code> class. The concept <code><a class="el" href="classRegularTriangulationTraits.html" title="This concept describes the geometric types and predicates required to build a regular triangulation...">RegularTriangulationTraits</a></code> refines the concept <code><a class="el" href="classTriangulationTraits.html" title="This concept describes the geometric types and predicates required to build a triangulation. It corresponds to the first template parameter of the class CGAL::Triangulation&lt;TriangulationTraits_, TriangulationDataStructure_&gt;. ">TriangulationTraits</a></code>.</p>
<h2>Example</h2>
<p>This simple example shows how to create a regular triangulation.</p>
<p><br />
<b>File</b> <a class="el" href="regular_triangulation_8cpp-example.html">regular_triangulation.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Epick_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Regular_triangulation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/assertions.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> D = 5;    <span class="comment">// Dimension</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> N = 100;  <span class="comment">// Number of points</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/structCGAL_1_1Epick__d.html">CGAL::Epick_d&lt; CGAL::Dimension_tag&lt;D&gt;</a> &gt;         K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Regular__triangulation.html">CGAL::Regular_triangulation&lt;K&gt;</a>                  T;</div><div class="line"><span class="keyword">typedef</span> K::Point_d                                      Bare_point;</div><div class="line"><span class="keyword">typedef</span> K::Weighted_point_d                             Weighted_point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Instantiate a random point generator</span></div><div class="line">  CGAL::Random rng(0);</div><div class="line">  <span class="keyword">typedef</span> CGAL::Random_points_in_cube_d&lt;Bare_point&gt; Random_points_iterator;</div><div class="line">  Random_points_iterator rand_it(D, 1.0, rng);</div><div class="line"></div><div class="line">  <span class="comment">// Generate N random points</span></div><div class="line">  std::vector&lt;Weighted_point&gt; points;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; ++i)</div><div class="line">    points.push_back(Weighted_point(*rand_it++, rng.get_double(0., 10.)));</div><div class="line">  </div><div class="line">  T t(D);</div><div class="line">  CGAL_assertion(t.empty());</div><div class="line">  </div><div class="line">  <span class="comment">// Insert the points in the triangulation</span></div><div class="line">  t.insert(points.begin(), points.end());</div><div class="line">  CGAL_assertion( t.is_valid() );</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Regular triangulation successfully computed: "</span> </div><div class="line">    &lt;&lt; t.number_of_vertices() &lt;&lt; <span class="stringliteral">" vertices, "</span></div><div class="line">    &lt;&lt; t.number_of_finite_full_cells() &lt;&lt; <span class="stringliteral">" finite cells."</span></div><div class="line">    &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="TriangulationSecPerf"></a>
Complexity and Performances</h1>
<p>When inserting a batch of points into a Delaunay triangulation, the current implementation starts by spatially sorting the points. Then, for each point to insert, it locates it by walking in the triangulation, using the previously inserted vertex as a "hint". Finally, the point is inserted. In the worst case scenario, without spatial sort, the expected complexity is \( O(n^{\lceil\frac{d}{2}\rceil+1}) \). When the algorithm is run on uniformly distributed points, the localization complexity is \( O(n^{\frac{1}{d}}) \) and the size of the triangulation is \( O(n) \), which gives a complexity of \( O(n^{1+\frac{1}{d}}) \) for the insertion. With spatial sort and random points, one can expect a complexity of \( O(n\log n) \). Please refer to <a class="el" href="citelist.html#CITEREF_boissonnat2009Delaunay">[1]</a> for more details.</p>
<p>We provide below (<a class="el" href="index.html#fig__Triangulationfigbenchmarks100">Figure 45.3</a>, <a class="el" href="index.html#fig__Triangulationfigbenchmarks1000">Figure 45.4</a> and <a class="el" href="index.html#fig__triangulationfigbenchmarkchart">Figure 45.5</a>) the performance of the Delaunay triangulation on randomly distributed points. The machine used is a PC running Windows 7 64-bits with an Intel Xeon CPU clocked at 2.80 GHz with 32GB of RAM. The program has been compiled with Microsoft Visual C++ 2013 in Release mode.</p>
<p><a class="anchor" id="fig__Triangulationfigbenchmarks100"></a></p><center> <table cellspacing="15" align="center">
<tr>
<td align="LEFT" colspan="13"><hr />
 </td></tr>
<tr>
<th align="RIGHT">Dimension</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12 </th></tr>
<tr>
<td align="LEFT" colspan="13"><hr />
 </td></tr>
<tr align="center">
<td align="right">Time (s)</td><td>0.003</td><td>0.007</td><td>0.03</td><td>0.14</td><td>0.56</td><td>2.7</td><td>11.3</td><td>45</td><td>185</td><td>686</td><td>2390 </td></tr>
<tr align="center">
<td align="right">Memory (MB)</td><td>&lt; 1</td><td>&lt; 1</td><td>&lt; 1</td><td>1</td><td>3</td><td>13</td><td>53</td><td>182</td><td>662</td><td>2187</td><td>7156 </td></tr>
<tr align="center">
<td align="right">Number of maximal simplices</td><td>184</td><td>487</td><td>1,548</td><td>5,548</td><td>19,598</td><td>67,102</td><td>230,375</td><td>715,984</td><td>2,570,623</td><td>7,293,293</td><td>21,235,615 </td></tr>
<tr align="center">
<td align="right">Number of convex hull facets</td><td>14</td><td>66</td><td>308</td><td>1,164</td><td>4,410</td><td>16,974</td><td>57,589</td><td>238,406</td><td>670,545</td><td>2,574,326</td><td>8,603,589</td><td></td></tr>
<tr>
<td align="LEFT" colspan="13"><hr />
 </td></tr>
</table>
</center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Triangulationfigbenchmarks100">Figure 45.3</a> Performance of the insertion of 100 points in a Delaunay triangulation.  </div>  <br />

<p><a class="anchor" id="fig__Triangulationfigbenchmarks1000"></a></p><center> <table cellspacing="15" align="center">
<tr>
<td align="LEFT" colspan="9"><hr />
 </td></tr>
<tr>
<th align="RIGHT">Dimension</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8 </th></tr>
<tr>
<td align="LEFT" colspan="9"><hr />
 </td></tr>
<tr align="center">
<td align="right">Time (s)</td><td>0.01</td><td>0.05</td><td>0.5</td><td>3.4</td><td>24</td><td>183</td><td>1365 </td></tr>
<tr align="center">
<td align="right">Memory (MB)</td><td>&lt; 1</td><td>&lt; 1</td><td>2.7</td><td>14</td><td>81</td><td>483</td><td>2827 </td></tr>
<tr align="center">
<td align="right">Number of maximal simplices</td><td>1,979</td><td>6,315</td><td>25,845</td><td>122,116</td><td>596,927</td><td>3,133,318</td><td>16,403,337 </td></tr>
<tr align="center">
<td align="right">Number of convex hull facets</td><td>19</td><td>138</td><td>963</td><td>6,184</td><td>41,135</td><td>241,540</td><td>1,406,797</td><td></td></tr>
<tr>
<td align="LEFT" colspan="9"><hr />
 </td></tr>
</table>
</center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Triangulationfigbenchmarks1000">Figure 45.4</a> Performance of the insertion of 1000 points in a Delaunay triangulation.  </div>  <br />

<p><a class="anchor" id="fig__triangulationfigbenchmarkchart"></a></p><div class="image">
<img src="benchmark_DTd.png" alt="benchmark_DTd.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__triangulationfigbenchmarkchart">Figure 45.5</a> Running time wrt. number of maximal simplices, for dimensions for 2 to 12.  </div>  <br />

<h1><a class="anchor" id="TriangulationSecDesign"></a>
Design and Implementation History</h1>
<p>Starting with the version 2.3 of <span style="font-variant: small-caps;">CGAL</span>, a package written by Susan Hert and Michael Seel was the first able to deal with triangulation and convex hulls in arbitrary dimension. It is deprecated since the version 4.6 of <span style="font-variant: small-caps;">CGAL</span> and this package should be used instead.</p>
<p>This package is heavily inspired by the works of Monique Teillaud and Sylvain Pion (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_3.tag:../Triangulation_3/" href="../Triangulation_3/classCGAL_1_1Triangulation__3.html">Triangulation_3</a></code>) and Mariette Yvinec (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__2.html">Triangulation_2</a></code>). The first version was written by Samuel Hornus. The final version is a joint work by Samuel Hornus, Olivier Devillers and Clément Jamin. In 2017, Clément Jamin added the regular triangulations.</p>
<p>Clément Jamin's work was supported by the <a href="http://cordis.europa.eu/project/rcn/111529_en.html">Advanced Grant of the European Research Council GUDHI</a> (Geometric Understanding in Higher Dimensions). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:00 for CGAL 4.13 - dD Triangulations by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
