<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_CGAL_and_the_Boost_Graph_Library"/><anchor id="index_1chapterBGL"/> <simplesect kind="authors"><para>Andreas Fabri, Fernando Cacciola, Philipp Moeller, and Ron Wein</para></simplesect>
Many geometric data structures can be interpreted as graphs as they consist of vertices and edges. This is the case for the halfedge data structure, for the polyhedral surface, for the arrangement, and for the 2D triangulation classes. With means of duality one can also interpret faces as vertices and edges between adjacent faces as edges of the dual graph.</para><para>The scope of CGAL is geometry and not graph algorithms. Nevertheless, this package provides the necessary classes and functions that enable using the algorithms of the <ulink url="https://www.boost.org/libs/graph/doc/index.html">Boost Graph Library</ulink> <ref refid="citelist_1CITEREF_cgal:sll-bgl-02" kindref="member">[3]</ref> (Bgl for short) with CGAL data structures.</para><para>Furthermore, this package extends the Bgl by introducing concepts such as <computeroutput><ref refid="classHalfedgeGraph" kindref="compound">HalfedgeGraph</ref></computeroutput> and <computeroutput><ref refid="classFaceGraph" kindref="compound">FaceGraph</ref></computeroutput> allowing to handle <emphasis>halfedges</emphasis> and <emphasis>faces</emphasis>. These concepts reflect the design of the halfedge data structure described in Chapter <ref refid="packages_1PkgHDSSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Halfedge Data Structures</ref>, with opposite halfedges and circular sequences of halfedges around vertices and around faces.</para><para>This chapter is organized as follows:<itemizedlist>
<listitem><para>The first section, Section <ref refid="index_1BGLA" kindref="member">A Short Introduction to the Boost Graph Library</ref>, summarizes the main ideas of the Bgl.</para></listitem><listitem><para>Section <ref refid="index_1BGLHeader" kindref="member">Header Files, Namespaces, and Naming Conventions</ref> then explains where to find header files and the chosen naming conventions, as we blend two different libraries.</para></listitem><listitem><para>The four following sections give examples on how to use CGAL graph and mesh data structures such as <ref refid="packages_1PkgSurfaceMeshSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Surface_mesh </ref>, <ref refid="packages_1PkgPolyhedronSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Polyhedron </ref>, <ref refid="packages_1PkgArrangement2Summary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Arrangement_2 </ref>, and the <ref refid="packages_1PkgTriangulation2Summary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">2D triangulation </ref> classes as models of the Bgl concepts.</para></listitem><listitem><para>Starting with Section <ref refid="index_1BGLExtensions" kindref="member">Extensions of the BGL</ref>, we introduce new graph concepts, classes, and functions that extend the functionalities of the Bgl.</para></listitem></itemizedlist>
</para><sect1 id="index_1BGLA">
<title>A Short Introduction to the Boost Graph Library</title>
<para>The algorithms of the Bgl operate on models of various <emphasis>graph concepts</emphasis>. The <emphasis>traits class</emphasis> <computeroutput>boost::graph_traits</computeroutput> enable algorithms to determine the types of vertices and edges (similar to <computeroutput>std::iterator_traits</computeroutput> for iterators). <emphasis>Free functions</emphasis> that operate on graphs enable algorithms to obtain, for example, the source vertex of an edge, or all edges incident to a vertex. The algorithms use <emphasis>property maps</emphasis> to associate information with vertices and edges. The algorithms enable <emphasis>visitors</emphasis> to register callbacks that are called later on during the execution of the algorithms. Finally, the graph algorithms use the <emphasis>named parameter</emphasis> mechanism, which enables passing the arguments in arbitrary order.</para><sect2 id="index_1BGLGraphConcepts">
<title>Graph Concepts</title>
<para>The Bgl introduces several <ulink url="https://www.boost.org/libs/graph/doc/graph_concepts.html">graph concepts</ulink>, which have different sets of characteristics and requirements. For example, iterating through all vertices or all edges in a graph, obtaining the outgoing or in-going edges of a vertex, inserting vertices and edges into a graph, and removing vertices and edges from a graph.</para></sect2>
<sect2 id="index_1BGLTheGraphTraitsClass">
<title>The Graph Traits Class</title>
<para>An algorithm operating on a graph model determines types with the help of the traits class <ulink url="https://www.boost.org/libs/graph/doc/graph_traits.html">boost::graph_traits</ulink>. Such types are the <computeroutput>vertex_descriptor</computeroutput>, which is similar to a vertex handle in CGAL data structures, or the <computeroutput>edge_descriptor</computeroutput>, which is similar to the <ref refid="classHalfedgeDSHalfedge" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">halfedge handle </ref> in the halfedge data structure or to the type <ref refid="classCGAL_1_1Triangulation__2_1ad28c6e0e0e65b8aaecb1ae76d8744b33" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Edge </ref> in 2D triangulations. There are also iterators, such as the <computeroutput>vertex_iterator</computeroutput>, which is similar to a vertex iterator in CGAL data structures, and the <computeroutput>out_edge_iterator</computeroutput>, which is similar to the edge circulator; it enables to iterate through the edges incident to a vertex. The iterators are similar and not equivalent, because their value type is a <computeroutput>vertex_descriptor</computeroutput>, whereas in CGAL handles, iterators, and circulators all have the same value type, namely the vertex or edge types.</para><para>Given a graph type <computeroutput>G</computeroutput>, definitions of descriptors and iterators look as follows:</para><para><programlisting><codeline><highlight class="normal">boost::graph_traits&lt;Graph&gt;::vertex_descriptor<sp/>vd;</highlight></codeline>
<codeline><highlight class="normal">boost::graph_traits&lt;Graph&gt;::edge_iterator<sp/>ei;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1BGLFreeFunctionsforExploringaGraph">
<title>Free Functions for Exploring a Graph</title>
<para>Algorithms obtain incidence information in graphs with the help of global functions such as:<itemizedlist>
<listitem><para><computeroutput>std::pair&lt;vertex_iterator,vertex_iterator&gt; vertices(const Graph&amp; g);</computeroutput> to obtain an iterator range providing access to all the vertices, or</para></listitem><listitem><para><computeroutput>int num_vertices(const Graph&amp;);</computeroutput> to obtain the number of vertices of a graph, or</para></listitem><listitem><para><computeroutput>vertex_descriptor source(edge_descriptor, const Graph&amp;);</computeroutput> to obtain the source vertex of an edge.</para></listitem></itemizedlist>
</para><para>Note, that the way we have written the types is a simplification; in reality, the signature of the first of the above functions is:</para><para><programlisting><codeline><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Graph&gt;::vertex_iterator<sp/>vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal">std::pair&lt;vertex_iterator,vertex_iterator&gt;<sp/>vertices(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Graph&amp;<sp/>g);</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1BGLPropertyMaps">
<title>Property Maps</title>
<para>Another feature extensively used in the Bgl is the <emphasis>property map</emphasis>, which is offered by the <ulink url="https://www.boost.org/libs/property_map/doc/property_map.html">Boost Property Map Library</ulink>. Property maps are a general purpose interface for mapping key objects to corresponding value objects.</para><para>The Bgl uses property maps to associate information with vertices and edges. This mechanism uses a traits class (<computeroutput>boost::property_traits</computeroutput>) and free functions to read (<computeroutput>get</computeroutput>) and write (<computeroutput>put</computeroutput>) information in vertices, edges, and also in halfedges and faces for models of the CGAL graph concepts. For example, the Bgl Dijksta&apos;s shortest path algorithm writes the predecessor of each vertex, as well as the distance to the source in such a property map.</para><para>Some default property maps are associated with the graph types. They are called <emphasis>internal property maps</emphasis> and can be retrieved using an overload of the function <computeroutput>get()</computeroutput>. For example, <programlisting><codeline><highlight class="normal">pm<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(boost::vertex_index,<sp/>g)</highlight></codeline>
</programlisting> returns a property map that associates an index in the range <computeroutput>[0, num_vertices(g))</computeroutput> with each vertex of the graph. This reduces the number of parameters to pass. The data itself may be stored in the vertex or the edge, or it may be stored in an external data structure, or it may be computed on the fly. This is an implementation detail of a particular property map.</para><para>See also Chapter <ref refid="packages_1PkgProperty_mapSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL and Boost Property Maps</ref>.</para></sect2>
<sect2 id="index_1BGLVisitors">
<title>Visitors</title>
<para>Visitors are objects that provide functions to be called at specified event points by the algorithm that they visit. The functions as well as the event points are algorithm-specific. Examples of such event points in graph algorithms are when a vertex is traversed the first time, or when all outgoing edges of a vertex have been traversed.<linebreak/>
</para><para>See also Section <ulink url="https://www.boost.org/libs/graph/doc/visitor_concepts.html">Visitor Concepts</ulink> in the Bgl manual.</para></sect2>
<sect2 id="index_1BGLNamedParameters">
<title>Named Parameters</title>
<para>The notion of <emphasis>named parameters</emphasis> was introduced in the Bgl, and allow the user to specify only those parameters which are really needed, by name, making the parameter ordering unimportant. See also <ulink url="https://www.boost.org/libs/graph/doc/bgl_named_params.html">this page</ulink> in the manual of the Bgl for more information.</para><para>Say there is a function <computeroutput>f()</computeroutput> that takes 3 parameters called name, age and gender, and you have variables <computeroutput>n</computeroutput>, <computeroutput>a</computeroutput> and <computeroutput>g</computeroutput> to pass as parameters to that function. Without named parameters, you would call it like this: <computeroutput>f(n,a,g)</computeroutput>, whereas with named parameters, you call it like this: <computeroutput>f(name(n).age(a).gender(g))</computeroutput>. That is, you give each parameter a name by wrapping it into a function whose name matches that of the parameter. The entire list of named parameters is really a composition of function calls separated by a dot (&quot;.&quot;). Thus, if the function takes a mix of mandatory and named parameters, you use a comma to separate the last non-named parameter from the first named parameters, like this: <programlisting><codeline><highlight class="normal">f(non_named_par0,<sp/>non_named_par1,<sp/>name(n).age(a).gender(g))</highlight></codeline>
</programlisting> When you use named parameters, the ordering is irrelevant, so <computeroutput>f(name(n).age(a).gender(g))</computeroutput> is equivalent to <computeroutput>f(age(a).gender(g).name(n))</computeroutput>, and you can just omit any named parameter that has a default value.</para><para>The sequence of named parameters should start with <computeroutput>CGAL::parameters::</computeroutput>.</para><sect3 id="index_1BGLNamedParametersExample">
<title>Example</title>
<para>Below is a sample call of a function that uses the optional BGL named parameters.</para><para><programlisting><codeline><highlight class="normal">//<sp/>pmesh<sp/>:<sp/>polygon<sp/>mesh<sp/>with<sp/>patches<sp/>to<sp/>be<sp/>refined</highlight></codeline>
<codeline><highlight class="normal">//<sp/>faces<sp/>:<sp/>the<sp/>range<sp/>of<sp/>faces<sp/>defining<sp/>the<sp/>patches<sp/>to<sp/>refine</highlight></codeline>
<codeline><highlight class="normal">//<sp/>faces_out<sp/>:<sp/>output<sp/>iterator<sp/>into<sp/>which<sp/>descriptors<sp/>of<sp/>new<sp/>faces<sp/>are<sp/>put</highlight></codeline>
<codeline><highlight class="normal">//<sp/>vertices_out<sp/>:<sp/>output<sp/>iterator<sp/>into<sp/>which<sp/>descriptors<sp/>of<sp/>new<sp/>vertices<sp/>are<sp/>put</highlight></codeline>
<codeline><highlight class="normal">//<sp/>vertex_point_map<sp/>:<sp/>the<sp/>property<sp/>map<sp/>with<sp/>the<sp/>points<sp/>associated<sp/>to<sp/>the<sp/>vertices<sp/>of<sp/>`pmesh`</highlight></codeline>
<codeline><highlight class="normal">//<sp/>density_control_factor<sp/>:<sp/>factor<sp/>to<sp/>control<sp/>density<sp/>of<sp/>the<sp/>output<sp/>mesh</highlight></codeline>
<codeline><highlight class="normal">refine(pmesh,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>faces,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>faces_out,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vertices_out,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::vertex_point_map(vpmap)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.density_control_factor(d));</highlight></codeline>
</programlisting></para></sect3>
</sect2>
</sect1>
<sect1 id="index_1BGLHeader">
<title>Header Files, Namespaces, and Naming Conventions</title>
<para>This package provides the necessary classes and functions that enable using CGAL data structures as models of the Bgl graph concepts. To this end, we offer partial specializations of the <computeroutput>boost::graph_traits&lt;Graph&gt;</computeroutput> for various CGAL packages. For each such package, denoted <computeroutput>PACKAGE</computeroutput>, the partial specializations live in the namespace <computeroutput>boost</computeroutput> and are located in the header file <computeroutput>CGAL/boost/graph/graph_traits_PACKAGE.h</computeroutput>. Free functions are in the namespace <computeroutput>CGAL</computeroutput>, and the compiler uses argument-dependent lookup to find them. Euler operations, described in Section <ref refid="index_1BGLEulerOperations" kindref="member">Euler Operations</ref>, are in the namespace <computeroutput>CGAL::Euler</computeroutput>, as the function <computeroutput><ref refid="group__PkgBGLEulerOperations_1gacfae7ff8e782da55b941e4487e86c738" kindref="member">remove_face()</ref></computeroutput> is at the same time a low-level and an Euler operation. Concerning the naming conventions, we have to use those of the Bgl, as to fulfill the requirements of the concepts defined in the Bgl.</para><para>Note that these partial specializations are often providing more than is required, making these classes not only models of the graph concepts of the Bgl, but also models of the CGAL graph concepts, that will be described in detail in Section <ref refid="index_1BGLExtensions" kindref="member">Extensions of the BGL</ref>. Correspondence tables between the types of a CGAL data structure and their Bgl equivalents can be found in the <ref refid="group__PkgBGLTraits" kindref="compound">Specializations of boost::graph_traits</ref> documentation page.</para><para>We present in the following sections some examples of utilization of some CGAL data structures as Bgl graphs.</para></sect1>
<sect1 id="index_1BGLSurface_mesh">
<title>The Class Surface_mesh as Model of the Boost Graph Concept</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput> is a model of most of the graph concepts of the Bgl as well as the concepts provided by CGAL. A complete list can be found in the documentation of <ref refid="group__PkgBGLTraits_1BGLSMGT" kindref="member">boost::graph_traits </ref>. The examples show how to use some of the Bgl algorithms with <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput> and show how to use the concepts provided by CGAL to implement a simple algorithm.</para><sect2 id="index_1BGLExampleMinimumSpanningTreeofaSurfaceMesh">
<title>Example: Minimum Spanning Tree of a Surface_mesh</title>
<para>The following example program computes the minimum spanning tree on a surface mesh. More examples can be found in Chapters <ref refid="packages_1PkgSurfaceMeshSimplificationSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Triangulated Surface Mesh Simplification</ref>, <ref refid="packages_1PkgSurfaceSegmentationSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Triangulated Surface Mesh Segmentation</ref>, and <ref refid="packages_1PkgSurfaceMeshDeformationSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Triangulated Surface Mesh Deformation</ref>.</para><para>The surface mesh class uses integer indices to address vertices and edges, and it comes with a built-in property mechanism that maps nicely on the Bgl.</para><para><linebreak/>
<bold>File</bold> <ref refid="BGL_surface_mesh_2prim_8cpp-example" kindref="compound">BGL_surface_mesh/prim.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/prim_minimum_spanning_tree.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/foreach.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Point&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Mesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Mesh&gt;::vertex_descriptor<sp/>vertex_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])<sp/></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mesh<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//std::cin<sp/>&gt;&gt;<sp/>P;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mesh::Property_map&lt;vertex_descriptor,vertex_descriptor&gt;<sp/><ref refid="group__STLAlgos_1ga6c5d40930db429775066babac7c35d7f" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">predecessor</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>predecessor<sp/>=<sp/>P.add_property_map&lt;vertex_descriptor,vertex_descriptor&gt;(</highlight><highlight class="stringliteral">&quot;v:predecessor&quot;</highlight><highlight class="normal">).first;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::prim_minimum_spanning_tree(P,<sp/>predecessor,<sp/>boost::root_vertex(*vertices(P).first));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#VRML<sp/>V2.0<sp/>utf8\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;DirectionalLight<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;direction<sp/>0<sp/>-1<sp/>0\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;}\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Shape<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>appearance<sp/>Appearance<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>material<sp/>Material<sp/>{<sp/>emissiveColor<sp/>1<sp/>0<sp/>0}}\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>geometry\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>IndexedLineSet<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/>coord<sp/>Coordinate<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point<sp/>[<sp/>\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BOOST_FOREACH(vertex_descriptor<sp/>vd,<sp/>vertices(P)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>P.point(vd)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>]\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/>}\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/>coordIndex<sp/>[\n&quot;</highlight><highlight class="normal">;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BOOST_FOREACH(vertex_descriptor<sp/>vd,<sp/>vertices(P)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(predecessor[vd]!=vd){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::size_t(vd)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::size_t(predecessor[vd])<sp/>&lt;&lt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;,<sp/>-1\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>}#IndexedLineSet\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;}#<sp/>Shape\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.remove_property_map(predecessor);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1BGLPolyhedral">
<title>The Class Polyhedron_3 as Model of the Boost Graph Concept</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput> is a model of most of the graph concepts of the Bgl as well as the concepts provided by CGAL. A complete list can be found in the documentation of <ref refid="group__PkgBGLTraits_1BGLPolyGT" kindref="member">boost::graph_traits </ref>. The examples show how to use some of the Bgl algorithms with <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput> and show how to use the concepts provided by CGAL to implement a simple algorithm.</para><sect2 id="index_1BGLExampleMinimumSpanningTreeofaPolyhedral">
<title>Example: Minimum Spanning Tree of a Polyhedral Surface</title>
<para>The following example program computes the minimum spanning tree on a polyhedral surface. More examples can be found in the Chapter <ref refid="packages_1PkgSurfaceMeshSimplificationSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Triangulated Surface Mesh Simplification</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="BGL_polyhedron_3_2kruskal_8cpp-example" kindref="compound">BGL_polyhedron_3/kruskal.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/kruskal_min_spanning_tree.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor<sp/>vertex_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator<sp/><sp/><sp/>vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Polyhedron&gt;::edge_descriptor<sp/><sp/><sp/>edge_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>BGL<sp/>makes<sp/>heavy<sp/>use<sp/>of<sp/>indices<sp/>associated<sp/>to<sp/>the<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>a<sp/>std::map<sp/>to<sp/>store<sp/>the<sp/>index</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::map&lt;vertex_descriptor,int&gt;<sp/>Vertex_index_map;</highlight></codeline>
<codeline><highlight class="normal">Vertex_index_map<sp/>vertex_index_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>std::map<sp/>is<sp/>not<sp/>a<sp/>property<sp/>map,<sp/>because<sp/>it<sp/>is<sp/>not<sp/>lightweight</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::associative_property_map&lt;Vertex_index_map&gt;<sp/>Vertex_index_pmap;</highlight></codeline>
<codeline><highlight class="normal">Vertex_index_pmap<sp/>vertex_index_pmap(vertex_index_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">kruskal(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Polyhedron&amp;<sp/>P)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>associate<sp/>indices<sp/>to<sp/>the<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertex_iterator<sp/>vb,<sp/>ve;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>boost::tie<sp/>assigns<sp/>the<sp/>first<sp/>and<sp/>second<sp/>element<sp/>of<sp/>the<sp/>std::pair</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>returned<sp/>by<sp/>boost::vertices<sp/>to<sp/>the<sp/>variables<sp/>vb<sp/>and<sp/>ve</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(boost::tie(vb,<sp/>ve)=vertices(P);<sp/>vb!=ve;<sp/>++vb){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertex_index_pmap[*vb]=<sp/>index++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>the<sp/>default<sp/>edge<sp/>weight<sp/>which<sp/>is<sp/>the<sp/>length<sp/>of<sp/>the<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>property<sp/>map<sp/>is<sp/>defined<sp/>in<sp/>graph_traits_Polyhedron_3.h</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>In<sp/>the<sp/>function<sp/>call<sp/>you<sp/>can<sp/>see<sp/>a<sp/>named<sp/>parameter:<sp/>vertex_index_map</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;edge_descriptor&gt;<sp/>mst;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::kruskal_minimum_spanning_tree(P,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(mst),<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::vertex_index_map(vertex_index_pmap));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#VRML<sp/>V2.0<sp/>utf8\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Shape<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>appearance<sp/>Appearance<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>material<sp/>Material<sp/>{<sp/>emissiveColor<sp/>1<sp/>0<sp/>0}}\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>geometry\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>IndexedLineSet<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/>coord<sp/>Coordinate<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point<sp/>[<sp/>\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(boost::tie(vb,<sp/>ve)<sp/>=<sp/>vertices(P);<sp/>vb!=ve;<sp/>++vb){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(*vb)-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>]\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/>}\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/>coordIndex<sp/>[\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::list&lt;edge_descriptor&gt;::iterator<sp/>it<sp/>=<sp/>mst.begin();<sp/>it<sp/>!=<sp/>mst.end();<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>edge_descriptor<sp/>e<sp/>=<sp/>*it<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertex_descriptor<sp/>s<sp/>=<sp/>source(e,P);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertex_descriptor<sp/>t<sp/>=<sp/>target(e,P);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vertex_index_pmap[s]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vertex_index_pmap[t]<sp/>&lt;&lt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;,<sp/>-1\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>}#IndexedLineSet\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;}#<sp/>Shape\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>a(1,0,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>b(0,1,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>c(0,0,1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>d(0,0,0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.make_tetrahedron(a,b,c,d);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>kruskal(P);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1BGLExampleUsingVerticesandEdgeswithanID">
<title>Example: Using Vertices, and Edges with an ID</title>
<para>The following example program shows a call to the Bgl Kruskal&apos;s minimum spanning tree algorithm accessing the <computeroutput>id()</computeroutput> field stored in a polyhedron vertex.</para><para>The main function illustrates the access to the <computeroutput>id()</computeroutput> field.</para><para><linebreak/>
<bold>File</bold> <ref refid="BGL_polyhedron_3_2kruskal_with_stored_id_8cpp-example" kindref="compound">BGL_polyhedron_3/kruskal_with_stored_id.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_items_with_id_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/kruskal_min_spanning_tree.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">CGAL::Polyhedron_3&lt;Kernel,CGAL::Polyhedron_items_with_id_3&gt;</ref><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor<sp/>vertex_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator<sp/><sp/><sp/>vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Polyhedron&gt;::edge_descriptor<sp/><sp/><sp/>edge_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">kruskal(<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Polyhedron&amp;<sp/>P)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>the<sp/>default<sp/>edge<sp/>weight<sp/>which<sp/>is<sp/>the<sp/>length<sp/>of<sp/>the<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>property<sp/>map<sp/>is<sp/>defined<sp/>in<sp/>graph_traits_Polyhedron_3.h</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>call<sp/>requires<sp/>a<sp/>vertex_index_map<sp/>named<sp/>parameter<sp/>which</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>when<sp/><sp/>ommitted<sp/>defaults<sp/>to<sp/>&quot;get(vertex_index,graph)&quot;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>That<sp/>default<sp/>works<sp/>here<sp/>because<sp/>the<sp/>vertex<sp/>type<sp/>has<sp/>an<sp/>&quot;id()&quot;<sp/>method</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>field<sp/>which<sp/>is<sp/>used<sp/>by<sp/>the<sp/>vertex_index<sp/>internal<sp/>property.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;edge_descriptor&gt;<sp/>mst;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::kruskal_minimum_spanning_tree(P,std::back_inserter(mst));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#VRML<sp/>V2.0<sp/>utf8\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Shape<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;appearance<sp/>Appearance<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;material<sp/>Material<sp/>{<sp/>emissiveColor<sp/>1<sp/>0<sp/>0}}\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;geometry\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;IndexedLineSet<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;coord<sp/>Coordinate<sp/>{\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;point<sp/>[<sp/>\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertex_iterator<sp/>vb,<sp/>ve;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(boost::tie(vb,ve)<sp/>=<sp/>vertices(P);<sp/>vb!=ve;<sp/>++vb){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>(*vb)-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;}\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;coordIndex<sp/>[\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::list&lt;edge_descriptor&gt;::iterator<sp/>it<sp/>=<sp/>mst.begin();<sp/>it<sp/>!=<sp/>mst.end();<sp/>++it){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>source(*it,P)-&gt;id()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>target(*it,P)-&gt;id()<sp/>&lt;&lt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;,<sp/>-1\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;}#IndexedLineSet\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;}#<sp/>Shape\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>a(1,0,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>b(0,1,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>c(0,0,1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>d(0,0,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.make_tetrahedron(a,b,c,d);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>associate<sp/>indices<sp/>to<sp/>the<sp/>vertices<sp/>using<sp/>the<sp/>&quot;id()&quot;<sp/>field<sp/>of<sp/>the<sp/>vertex.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertex_iterator<sp/>vb,<sp/>ve;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>boost::tie<sp/>assigns<sp/>the<sp/>first<sp/>and<sp/>second<sp/>element<sp/>of<sp/>the<sp/>std::pair</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>returned<sp/>by<sp/>boost::vertices<sp/>to<sp/>the<sp/>variables<sp/>vit<sp/>and<sp/>ve</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(boost::tie(vb,ve)=vertices(P);<sp/>vb!=ve;<sp/>++vb<sp/>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertex_descriptor<sp/><sp/>vd<sp/>=<sp/>*vb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vd-&gt;id()<sp/>=<sp/>index++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>kruskal(P);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1BGLTriangulations">
<title>Triangulations as Models of the Boost Graph Concept</title>
<para>Triangulations have vertices and faces, allowing for a direct translation as a graph. An edge is defined as a pair of a face handle and the index of the edge. Particular care has to be taken with the infinite vertex and its incident edges. One can either use a <ulink url="https://www.boost.org/libs/graph/doc/filtered_graph.html">boost::filtered_graph</ulink> in order to make the infinite edges invisible, or one can have a property map that returns an infinite length for these edges. A complete list can be found in the documentation of <ref refid="group__PkgBGLTraits_1BGLT2GT" kindref="member">boost::graph_traits </ref>.</para><para>A classical example for an algorithm that is a combination of computational geometry and graph theory is the <emphasis>Euclidean Minimum Spanning Tree</emphasis> for a point set in the plane. It can be computed by running the minimum spanning tree algorithm on a Delaunay triangulation of the point set.</para><sect2 id="index_1BGLExampleEuclideanMinimumSpanningTree">
<title>Example: Euclidean Minimum Spanning Tree</title>
<para>In the following example we create a Delaunay triangulation and run Kruskal&apos;s minimum spanning tree algorithm on it. Because the vertex handles of the triangulation are not indices in an array, we have to provide a property map that maps vertex handles to integers in the range <computeroutput>[0, t.number_of_vertices())</computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="BGL_triangulation_2_2emst_8cpp-example" kindref="compound">BGL_triangulation_2/emst.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/kruskal_min_spanning_tree.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/filtered_graph.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::Delaunay_triangulation_2&lt;K&gt;</ref><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>As<sp/>we<sp/>only<sp/>consider<sp/>finite<sp/>vertices<sp/>and<sp/>edges</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>we<sp/>need<sp/>the<sp/>following<sp/>filter</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Is_finite<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/>t_;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Is_finite()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>t_(NULL)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Is_finite(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>t)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>t_(&amp;t)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VertexOrEdge&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VertexOrEdge&amp;<sp/>voe)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!<sp/>t_-&gt;is_infinite(voe);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Is_finite&lt;Triangulation&gt;<sp/>Filter;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::filtered_graph&lt;Triangulation,Filter,Filter&gt;<sp/>Finite_triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Finite_triangulation&gt;::vertex_descriptor<sp/>vertex_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Finite_triangulation&gt;::vertex_iterator<sp/>vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Finite_triangulation&gt;::edge_descriptor<sp/>edge_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>BGL<sp/>makes<sp/>use<sp/>of<sp/>indices<sp/>associated<sp/>to<sp/>the<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>a<sp/>std::map<sp/>to<sp/>store<sp/>the<sp/>index</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::map&lt;vertex_descriptor,int&gt;<sp/>VertexIndexMap;</highlight></codeline>
<codeline><highlight class="normal">VertexIndexMap<sp/>vertex_id_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>std::map<sp/>is<sp/>not<sp/>a<sp/>property<sp/>map,<sp/>because<sp/>it<sp/>is<sp/>not<sp/>lightweight</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::associative_property_map&lt;VertexIndexMap&gt;<sp/>VertexIdPropertyMap;</highlight></codeline>
<codeline><highlight class="normal">VertexIdPropertyMap<sp/>vertex_index_pmap(vertex_id_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/points.xy&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>input(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Filter<sp/>is_finite(t);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Finite_triangulation<sp/>ft(t,<sp/>is_finite,<sp/>is_finite);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(input<sp/>&gt;&gt;<sp/>p){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>t.insert(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertex_iterator<sp/>vit,<sp/>ve;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Associate<sp/>indices<sp/>to<sp/>the<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>boost::tie<sp/>assigns<sp/>the<sp/>first<sp/>and<sp/>second<sp/>element<sp/>of<sp/>the<sp/>std::pair</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>returned<sp/>by<sp/>boost::vertices<sp/>to<sp/>the<sp/>variables<sp/>vit<sp/>and<sp/>ve</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(boost::tie(vit,ve)=boost::vertices(ft);<sp/>vit!=ve;<sp/>++vit<sp/>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertex_descriptor<sp/><sp/>vd<sp/>=<sp/>*vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertex_id_map[vd]=<sp/>index++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>the<sp/>default<sp/>edge<sp/>weight<sp/>which<sp/>is<sp/>the<sp/>squared<sp/>length<sp/>of<sp/>the<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>property<sp/>map<sp/>is<sp/>defined<sp/>in<sp/>graph_traits_Triangulation_2.h</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>In<sp/>the<sp/>function<sp/>call<sp/>you<sp/>can<sp/>see<sp/>a<sp/>named<sp/>parameter:<sp/>vertex_index_map</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::list&lt;edge_descriptor&gt;<sp/>mst;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>boost::kruskal_minimum_spanning_tree(ft,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(mst),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vertex_index_map(vertex_index_pmap));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>edges<sp/>of<sp/>the<sp/>Euclidean<sp/>mimimum<sp/>spanning<sp/>tree:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::list&lt;edge_descriptor&gt;::iterator<sp/>it<sp/>=<sp/>mst.begin();<sp/>it<sp/>!=<sp/>mst.end();<sp/>++it){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>edge_descriptor<sp/>ed<sp/>=<sp/>*it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>vertex_descriptor<sp/>svd<sp/>=<sp/>source(ed,t);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>vertex_descriptor<sp/>tvd<sp/>=<sp/>target(ed,t);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>Triangulation::Vertex_handle<sp/>sv<sp/>=<sp/>svd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>Triangulation::Vertex_handle<sp/>tv<sp/>=<sp/>tvd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>sv-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>|<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>tv-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>]<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1BGLExampleStoringtheVertexIDintheVertex">
<title>Example: Storing the Vertex ID in the Vertex</title>
<para>The algorithms of the Bgl extensively use of the indices of vertices. In the previous example we stored the indices in a <computeroutput>std::map</computeroutput> and turned that map in a property map. This property map was then passed as argument to the shortest path function.</para><para>If the user does not pass explicitly a property map, the graph algorithms use the property map returned by the call <computeroutput>get(boost::vertex_index,ft)</computeroutput>. This property map assumes that the vertex has a member function <computeroutput>id()</computeroutput> that returns a reference to an int. Therefore CGAL offers a class <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__with__id__2" kindref="compound">Triangulation_vertex_base_with_id_2</ref></computeroutput>. It is in the users responsibility to set the indices properly.</para><para>The example further illustrates that the graph traits also works for the Delaunay triangulation.</para><para><linebreak/>
<bold>File</bold> <ref refid="BGL_triangulation_2_2dijkstra_with_internal_properties_8cpp-example" kindref="compound">BGL_triangulation_2/dijkstra_with_internal_properties.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_with_id_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/filtered_graph.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__with__id__2" kindref="compound">CGAL::Triangulation_vertex_base_with_id_2&lt;K&gt;</ref><sp/>Tvb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__face__base__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::Triangulation_face_base_2&lt;K&gt;</ref><sp/>Tfb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_2&lt;Tvb,Tfb&gt;<sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</ref><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>consider<sp/>finite<sp/>vertices<sp/>and<sp/>edges.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Is_finite<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/>t_;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Is_finite()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>t_(NULL)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Is_finite(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>t)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>t_(&amp;t)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VertexOrEdge&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VertexOrEdge&amp;<sp/>voe)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!<sp/>t_-&gt;is_infinite(voe);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Is_finite&lt;Triangulation&gt;<sp/>Filter;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::filtered_graph&lt;Triangulation,Filter,Filter&gt;<sp/>Finite_triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Finite_triangulation&gt;::vertex_descriptor<sp/>vertex_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Finite_triangulation&gt;::vertex_iterator<sp/>vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/points.xy&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>input(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Filter<sp/>is_finite(t);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Finite_triangulation<sp/>ft(t,<sp/>is_finite,<sp/>is_finite);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(input<sp/>&gt;&gt;<sp/>p){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>t.insert(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertex_iterator<sp/>vit,<sp/>ve;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>associate<sp/>indices<sp/>to<sp/>the<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(boost::tie(vit,ve)=boost::vertices(ft);<sp/>vit!=ve;<sp/>++vit<sp/>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertex_descriptor<sp/><sp/>vd<sp/>=<sp/>*vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vd-&gt;id()=<sp/>index++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::property_map&lt;Triangulation,<sp/>boost::vertex_index_t&gt;::type<sp/>VertexIdPropertyMap;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>VertexIdPropertyMap<sp/>vertex_index_pmap<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(boost::vertex_index,<sp/>ft);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Dijkstra&apos;s<sp/>shortest<sp/>path<sp/>needs<sp/>property<sp/>maps<sp/>for<sp/>the<sp/>predecessor<sp/>and<sp/>distance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;vertex_descriptor&gt;<sp/><ref refid="group__STLAlgos_1ga6c5d40930db429775066babac7c35d7f" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">predecessor</ref>(boost::num_vertices(ft));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::iterator_property_map&lt;std::vector&lt;vertex_descriptor&gt;::iterator,<sp/>VertexIdPropertyMap&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>predecessor_pmap(predecessor.begin(),<sp/>vertex_index_pmap);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;double&gt;<sp/>distance(boost::num_vertices(ft));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::iterator_property_map&lt;std::vector&lt;double&gt;::iterator,<sp/>VertexIdPropertyMap&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>distance_pmap(distance.begin(),<sp/>vertex_index_pmap);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertex_descriptor<sp/>source<sp/>=<sp/><sp/>*boost::vertices(ft).first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\nStart<sp/>dijkstra_shortest_paths<sp/>at<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>source-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::dijkstra_shortest_paths(ft,<sp/>source<sp/>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>distance_map(distance_pmap)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.predecessor_map(predecessor_pmap));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(boost::tie(vit,ve)=boost::vertices(ft);<sp/>vit!=ve;<sp/>++vit<sp/>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertex_descriptor<sp/>vd<sp/>=<sp/>*vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>vd-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vd-&gt;id()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>has<sp/>distance<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(distance_pmap,vd)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>and<sp/>predecessor<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vd<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(predecessor_pmap,vd);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>vd-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vd-&gt;id()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1BGLArrangements">
<title>Arrangements as Models of the Boost Graph Concept</title>
<para>CGAL offers a partial specialization of the boost graph traits for its arrangement class as well as for its dual graph.</para><sect2 id="index_1arr_sssecbgl_primal">
<title>Example for the Arrangement as Graph</title>
<para>Arrangement instances are adapted to <emphasis>boost</emphasis> graphs by specializing the <computeroutput>boost:graph_traits</computeroutput> template for <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2</ref></computeroutput> instances. The graph-traits states the graph concepts that the arrangement class models (see below) and defines the types required by these concepts.</para><para>In this specialization the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2</ref></computeroutput> vertices correspond to the graph vertices, where two vertices are adjacent if there is at least one halfedge connecting them. More precisely, <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a7dac3eed2224beadf3658495bc671c49" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2::Vertex_handle</ref></computeroutput> is the graph-vertex type, while <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2::Halfedge_handle</ref></computeroutput> is the graph-edge type. As halfedges are directed, we consider the graph to be directed as well. Moreover, as several interior-disjoint <formula id="0">$ x$</formula>-monotone curves (say circular arcs) may share two common endpoints, inducing an arrangement with two vertices that are connected with several edges, we allow parallel edges in our <emphasis>boost</emphasis> graph.</para><para>Given an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2</ref></computeroutput> instance, we can efficiently traverse its vertices and halfedges. Thus, the arrangement graph is a model of the concepts <computeroutput><ref refid="classVertexListGraph" kindref="compound">VertexListGraph</ref></computeroutput> and <computeroutput><ref refid="classEdgeListGraph" kindref="compound">EdgeListGraph</ref></computeroutput> introduced by the Bgl. At the same time, we use an iterator adapter of the circulator over the halfedges incident to a vertex (<computeroutput><ref refid="classCGAL_1_1Halfedge__around__target__circulator" kindref="compound">Halfedge_around_target_circulator</ref></computeroutput> - see Section <ref refid="index_1arr_sssectr_vertex" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Traversal Methods for an Arrangement Vertex</ref> of the chapter on arrangements), so it is possible to go over the ingoing and outgoing edges of a vertex in linear time. Thus, our arrangement graph is a model of the concept <computeroutput><ref refid="classBidirectionalGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">BidirectionalGraph</ref></computeroutput> (this concept refines <computeroutput><ref refid="classIncidenceGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">IncidenceGraph</ref></computeroutput>, which requires only the traversal of outgoing edges).</para><para>It is important to notice that the vertex descriptors we use are <computeroutput>Vertex_handle</computeroutput> objects and <emphasis>not</emphasis> vertex indices. However, in order to gain more efficiency in most Bgl algorithm, it is better to have them indexed <formula id="1">$ 0, 1, \ldots, (n-1)$</formula>, where <formula id="2">$ n$</formula> is the number of vertices. We therefore introduce the <computeroutput><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_vertex_index_map</ref>&lt;Arrangement&gt;</computeroutput> class-template, which maintains a mapping of vertex handles to indices, as required by the Bgl. An instance of this class must be attached to a valid arrangement vertex when it is created. It uses the notification mechanism (see Section <ref refid="index_1arr_secnotif" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">The Notification Mechanism</ref>) to automatically maintain the mapping of vertices to indices, even when new vertices are inserted into the arrangement or existing vertices are removed.</para><para>A complete description of the types correspondences can be found in the documentation of <ref refid="group__PkgBGLTraits_1BGLArgtGT" kindref="member">boost::graph_traits </ref>.</para><para>In most algorithm provided by the Bgl, the output is given by <emphasis>property maps</emphasis>, such that each map entry corresponds to a vertex. For example, when we compute the shortest paths from a given source vertex <formula id="3">$ s$</formula> to all other vertices we can obtain a map of distances and a map of predecessors - namely for each <formula id="4">$ v$</formula> vertex we have its distance from <formula id="3">$ s$</formula> and a descriptor of the vertex that precedes <formula id="4">$ v$</formula> in the shortest path from <formula id="3">$ s$</formula>. If the vertex descriptors are simply indices, one can use vectors to efficiently represent the property maps. As this is not the case with the arrangement graph, we offer the <computeroutput>Arr_vertex_property_map&lt;Arrangement,Type&gt;</computeroutput> template allows for an efficient mapping of <computeroutput>Vertex_handle</computeroutput> objects to properties of type <computeroutput>Type</computeroutput>. Note however that unlike the <computeroutput><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_vertex_index_map</ref></computeroutput> class, the vertex property-map class is not kept synchronized with the number of vertices in the arrangement, so it should not be reused in calls to the Bgl functions in case the arrangement is modified in between these calls.</para><para><anchor id="index_1fig__figex_bgl"/><image type="html" name="ex_bgl.png"></image>
 <image type="latex" name="ex_bgl.png" width="15cm"></image>
  <ref refid="index_1fig__figex_bgl" kindref="member">fig__figex_bgl</ref> An arrangement of 7 line segments, as constructed by <computeroutput>ex_bgl_primal_adapter.cpp</computeroutput> and <computeroutput>ex_bgl_dual_adapter.cpp</computeroutput>. The breadth-first visit times for the arrangement faces, starting from the unbounded face <formula id="5">$ f_0$</formula>, are shown in brackets.  <linebreak/>
</para><para>In the following example we construct an arrangement of 7 line segments, as shown in <ref refid="index_1fig__figex_bgl" kindref="member">fig__figex_bgl</ref>, then use the Bgl Dijkstra&apos;s shortest-paths algorithm to compute the graph distance of all vertices from the leftmost vertex in the arrangement <formula id="6">$ v_0$</formula>. Note the usage of the <computeroutput><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_vertex_index_map</ref></computeroutput> and the <computeroutput>Arr_vertex_property_map</computeroutput> classes. The latter one, instantiated by the type <computeroutput>double</computeroutput> is used to map vertices to their distances from <formula id="6">$ v_0$</formula>.</para><para><linebreak/>
<bold>File</bold> <ref refid="BGL_arrangement_2_2primal_8cpp-example" kindref="compound">BGL_arrangement_2/primal.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Adapting<sp/>an<sp/>arrangement<sp/>to<sp/>a<sp/>BGL<sp/>graph.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_rational_nt.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/graph_traits_Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_vertex_index_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>functor<sp/>used<sp/>to<sp/>compute<sp/>the<sp/>length<sp/>of<sp/>an<sp/>edge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Edge_length_func</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Boost<sp/>property<sp/>type<sp/>definitions:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::readable_property_map_tag<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>category;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>value_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2::Halfedge_handle</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>operator()(<ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2::Halfedge_handle</ref><sp/>e)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>x1<sp/>=<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref><sp/>(e-&gt;source()-&gt;point().x());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>y1<sp/>=<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref><sp/>(e-&gt;source()-&gt;point().y());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>x2<sp/>=<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref><sp/>(e-&gt;target()-&gt;point().x());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>y2<sp/>=<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref><sp/>(e-&gt;target()-&gt;point().y());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>diff_x<sp/>=<sp/>x2<sp/>-<sp/>x1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>diff_y<sp/>=<sp/>y2<sp/>-<sp/>y1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">std::sqrt</ref>(diff_x*diff_x<sp/>+<sp/>diff_y*diff_y);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(Edge_length_func<sp/><ref refid="group__measure__grp_1gae1674775d9fecada7f25710f425cff3a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon_mesh_processing.tag">edge_length</ref>,<sp/><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2::Halfedge_handle</ref><sp/>e)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__measure__grp_1gae1674775d9fecada7f25710f425cff3a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon_mesh_processing.tag">edge_length</ref>(e);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>of<sp/>seven<sp/>intersecting<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>keep<sp/>a<sp/>handle<sp/>for<sp/>the<sp/>vertex<sp/>v_0<sp/>that<sp/>corresponds<sp/>to<sp/>the<sp/>point<sp/>(1,1).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2::Halfedge_handle</ref><sp/><sp/>e<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(1,<sp/>1),<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(7,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1a7dac3eed2224beadf3658495bc671c49" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2::Vertex_handle</ref><sp/><sp/><sp/><sp/>v0<sp/>=<sp/>e-&gt;source();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(1,<sp/>1),<sp/>Point_2<sp/>(3,<sp/>7)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(1,<sp/>4),<sp/>Point_2<sp/>(7,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(2,<sp/>2),<sp/>Point_2<sp/>(9,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(2,<sp/>2),<sp/>Point_2<sp/>(4,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(7,<sp/>1),<sp/>Point_2<sp/>(9,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(3,<sp/>7),<sp/>Point_2<sp/>(9,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>mapping<sp/>of<sp/>the<sp/>arrangement<sp/>vertices<sp/>to<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index_map(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>Dijkstra&apos;s<sp/>algorithm<sp/>from<sp/>the<sp/>vertex<sp/>v0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Edge_length_func<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__measure__grp_1gae1674775d9fecada7f25710f425cff3a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon_mesh_processing.tag">edge_length</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::vector_property_map&lt;double,<sp/>CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt;<sp/>&gt;<sp/>dist_map(static_cast&lt;unsigned<sp/>int&gt;(arr.number_of_vertices()),<sp/>index_map);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::dijkstra_shortest_paths(arr,<sp/>v0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::vertex_index_map(index_map).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>weight_map(edge_length).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>distance_map(dist_map));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>results:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1ac4a88fd2ca22b490454e4f425005e5c4" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2::Vertex_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>distances<sp/>of<sp/>the<sp/>arrangement<sp/>vertices<sp/>from<sp/>(&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>v0-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>at<sp/>distance<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>dist_map[vit]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_sssecbgl_dual">
<title>Example for the Dual of an Arrangement as Graph</title>
<para>It is possible to give a dual graph representation for an arrangement instance, such that each arrangement face corresponds to a graph vertex and two vertices are adjacent iff the corresponding faces share a common edge on their boundaries. This is done by specializing the <computeroutput>boost:graph_traits</computeroutput> template for <computeroutput><ref refid="classCGAL_1_1Dual" kindref="compound">Dual</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2</ref>&gt;</computeroutput> instances, where <computeroutput><ref refid="classCGAL_1_1Dual" kindref="compound">Dual</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2</ref>&gt;</computeroutput> is a template specialization that gives a dual interpretation to an arrangement instance.</para><para>In dual representation, <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1ad64170c3b8b8c4af16a4fb742bf56d48" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2::Face_handle</ref></computeroutput> is the graph-vertex type, while <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2::Halfedge_handle</ref></computeroutput> is the graph-edge type. We treat the graph edges as directed, such that a halfedge <computeroutput>e</computeroutput> is directed from <formula id="7">$ f_1$</formula>, which is its incident face, to <formula id="8">$ f_2$</formula>, which is the incident face of its twin halfedge. As two arrangement faces may share more than a single edge on their boundary, we allow parallel edges in our <emphasis>boost</emphasis> graph. As is the case in the primal graph, the dual arrangement graph is also a model of the concepts <computeroutput><ref refid="classVertexListGraph" kindref="compound">VertexListGraph</ref></computeroutput>, <computeroutput><ref refid="classEdgeListGraph" kindref="compound">EdgeListGraph</ref></computeroutput> and <computeroutput><ref refid="classBidirectionalGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">BidirectionalGraph</ref></computeroutput> (thus also of <computeroutput><ref refid="classIncidenceGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">IncidenceGraph</ref></computeroutput>).</para><para>Since we use <computeroutput>Face_handle</computeroutput> objects as the vertex descriptors, we define the <computeroutput><ref refid="classCGAL_1_1Arr__face__index__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_face_index_map</ref>&lt;Arrangement&gt;</computeroutput> class-template, which maintains an efficient mapping of face handles to indices. We also provide the template <computeroutput>Arr_face_property_map&lt;Arrangement,Type&gt;</computeroutput> for associating arbitrary data with the arrangement faces.</para><para>In the following example we construct the same arrangement as in example <computeroutput>ex_bgl_primal_adapter.cpp</computeroutput> (see <ref refid="index_1fig__arr_figex_bgl" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">fig__arr_figex_bgl</ref>), and perform breadth-first search on the graph faces, starting from the unbounded face. We extend the Dcel faces with an unsigned integer, marking the discover time of the face and use a breadth-first-search visitor to obtain these times and update the faces accordingly:</para><para><linebreak/>
<bold>File</bold> <ref refid="BGL_arrangement_2_2arrangement_dual_8cpp-example" kindref="compound">BGL_arrangement_2/arrangement_dual.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Adapting<sp/>the<sp/>dual<sp/>of<sp/>an<sp/>arrangement<sp/>to<sp/>a<sp/>BGL<sp/>graph.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_rational_nt.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/graph_traits_dual_arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_face_index_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;climits&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/breadth_first_search.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/visitors.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>property<sp/>map<sp/>that<sp/>reads/writes<sp/>the<sp/>information<sp/>to/from<sp/>the<sp/>extended<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Type&gt;<sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Extended_face_property_map<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Face_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Boost<sp/>property<sp/>type<sp/>definitions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::read_write_property_map_tag<sp/><sp/><sp/><sp/><sp/><sp/>category;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>value_type&amp;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Face_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>get<sp/>function<sp/>is<sp/>required<sp/>by<sp/>the<sp/>property<sp/>map<sp/>concept.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/>reference<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Extended_face_property_map&amp;,<sp/>key_type<sp/>key)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>key-&gt;data();<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>put<sp/>function<sp/>is<sp/>required<sp/>by<sp/>the<sp/>property<sp/>map<sp/>concept.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>put(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Extended_face_property_map&amp;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_type<sp/>key,<sp/>value_type<sp/>val)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>key-&gt;set_data(val);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_face_extended_dcel&lt;Traits_2, unsigned int&gt;</ref><sp/>Dcel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ex_arrangement;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Dual" kindref="compound">CGAL::Dual&lt;Ex_arrangement&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dual_arrangement;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__face__index__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_face_index_map&lt;Ex_arrangement&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_index_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Extended_face_property_map&lt;Ex_arrangement,unsigned<sp/>int&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_property_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>of<sp/>seven<sp/>intersecting<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>p1(1,<sp/>1),<sp/>p2(1,<sp/>4),<sp/>p3(2,<sp/>2),<sp/>p4(3,<sp/>7),<sp/>p5(4,<sp/>4),<sp/>p6(7,<sp/>1),<sp/>p7(9,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref>(arr,<sp/>Segment_2(p1,<sp/>p6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref>(arr,<sp/>Segment_2(p1,<sp/>p4));<sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref>(arr,<sp/>Segment_2(p2,<sp/>p6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref>(arr,<sp/>Segment_2(p3,<sp/>p7));<sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref>(arr,<sp/>Segment_2(p3,<sp/>p5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref>(arr,<sp/>Segment_2(p6,<sp/>p7));<sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert</ref>(arr,<sp/>Segment_2(p4,<sp/>p7));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>mapping<sp/>of<sp/>the<sp/>arrangement<sp/>faces<sp/>to<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_index_map<sp/><sp/>index_map(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>breadth-first<sp/>search<sp/>from<sp/>the<sp/>unbounded<sp/>face,<sp/>using<sp/>the<sp/>event</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>visitor<sp/>to<sp/>associate<sp/>each<sp/>arrangement<sp/>face<sp/>with<sp/>its<sp/>discover<sp/>time.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/>time<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::breadth_first_search(Dual_arrangement(arr),<sp/>arr.unbounded_face(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::vertex_index_map(index_map).visitor</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(boost::make_bfs_visitor</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(stamp_times(Face_property_map(),<sp/>time,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::on_discover_vertex()))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>discover<sp/>time<sp/>of<sp/>each<sp/>arrangement<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement::Face_iterator<sp/><sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Discover<sp/>time<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fit-&gt;data()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>for<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fit<sp/>!=<sp/>arr.unbounded_face())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;face<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>print_ccb&lt;Ex_arrangement&gt;(fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;the<sp/>unbounded<sp/>face.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1BGLExtensions">
<title>Extensions of the BGL</title>
<para>The previous sections introduced partial specializations and free functions so that several CGAL data structures are adapted as models of some of the Bgl graph concepts. In this section, we introduce new concepts, iterators, and property maps inspired by the functionalities of the Bgl.</para><sect2 id="index_1BGLExtensionsGraphConcepts">
<title>Graph concepts</title>
<para>In order to match <ref refid="packages_1PkgHDSSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Halfedge Data Structures</ref> more closely and to enable writing generic algorithms which operate on data structures that have faces and halfedges, we define a set of new concepts to extend the <ulink url="https://www.boost.org/libs/graph/doc/graph_concepts.html">graph concepts of the BGL</ulink>:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classHalfedgeGraph" kindref="compound">HalfedgeGraph</ref></computeroutput> refines <ulink url="https://www.boost.org/libs/graph/doc/Graph.html"><computeroutput>Graph</computeroutput></ulink> with operations to accommodate halfedge data structures: given a halfedge, say <computeroutput>h</computeroutput>, the concept <computeroutput><ref refid="classHalfedgeGraph" kindref="compound">HalfedgeGraph</ref></computeroutput> requires the provision of the halfedge opposite to <computeroutput>h</computeroutput>, the halfedge that succeeds <computeroutput>h</computeroutput>, and the halfedge that precedes <computeroutput>h</computeroutput>.</para></listitem><listitem><para><computeroutput><ref refid="classHalfedgeListGraph" kindref="compound">HalfedgeListGraph</ref></computeroutput> adds the requirement for efficient traversal of the halfedges of the graph.</para></listitem><listitem><para><computeroutput><ref refid="classMutableHalfedgeGraph" kindref="compound">MutableHalfedgeGraph</ref></computeroutput> adds the requirement for operations to change next/previous relations and to adjust the target of a halfedge.</para></listitem><listitem><para><computeroutput><ref refid="classFaceGraph" kindref="compound">FaceGraph</ref></computeroutput> adds the requirements to explicitly handle faces in a graph, to provide quick access to the incident halfedges of a face, and to enable access from every halfedge to an adjacent face.</para></listitem><listitem><para><computeroutput><ref refid="classFaceListGraph" kindref="compound">FaceListGraph</ref></computeroutput> adds the requirement for efficient traversal of the faces of a graph.</para></listitem><listitem><para><computeroutput><ref refid="classMutableFaceGraph" kindref="compound">MutableFaceGraph</ref></computeroutput> adds requirements to change adjacency of faces and halfedges, and to remove and add faces.</para></listitem></itemizedlist>
</para><para>A summary of the expressions and types associated with each of these concepts as well as a refinement relation graph can be found in the <ref refid="group__PkgBGLConcepts" kindref="compound">Concepts</ref> documentation page.</para></sect2>
<sect2 id="index_1BGLIteratorsAndCirculators">
<title>Iterators and Circulators</title>
<para>By combining basic operations on graphs, we create various useful <ref refid="devman_iterators_and_circulators" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">iterators and circulators</ref> to traverse specific types of elements. For example:</para><para><itemizedlist>
<listitem><para>Starting at a halfedge <computeroutput>h</computeroutput> of a halfedge graph <computeroutput>g</computeroutput>, applying several times <computeroutput>next(h,g)</computeroutput> brings us back to the halfedge where we started. All halfedges traversed on the way are incident to the same face.</para></listitem><listitem><para>Using the composition of the functions <computeroutput>next(h,g)</computeroutput> and <computeroutput>opposite(h,g)</computeroutput> results in another cycle, namely the cycle of halfedges which are incident to the same vertex.</para></listitem></itemizedlist>
</para><para>A complete list of these traversal tools can be found in <ref refid="group__PkgBGLIterators" kindref="compound">the reference manual</ref>.</para><para>For convenience, two iterator and circulator types enable the traversal of all halfedges incident to a given face, and all halfedges having a given vertex as target. These types are not part of the concept <computeroutput><ref refid="classHalfedgeGraph" kindref="compound">HalfedgeGraph</ref></computeroutput>, but they are class templates that work for any model of this concept.</para><sect3 id="index_1BGLExampleIncidentVertices">
<title>Example: Finding Incident Vertices in a HalfedgeGraph</title>
<para>The following example shows several functions to navigate in a <computeroutput><ref refid="classHalfedgeGraph" kindref="compound">HalfedgeGraph</ref></computeroutput>. We have two implementations of the operation that finds the vertices adjacent to a vertex <computeroutput>v</computeroutput>.</para><para>Let us have a look at the first version. Given a vertex descriptor <computeroutput>vd</computeroutput>, we first call <computeroutput>halfedge(vd,g)</computeroutput> to obtain the halfedge with <computeroutput>vd</computeroutput> as target. Applying <computeroutput><ref refid="classEdgeListGraph_1ac8f83485fc28d4149edd8eab690d40ab" kindref="member">source()</ref></computeroutput> then gives us an adjacent vertex. We then get to the next halfedge with <computeroutput>vd</computeroutput> as target, by first going to the next halfedge around the face, and then going to the opposite halfedge.</para><para>The second version does the <computeroutput>next()</computeroutput> and <computeroutput>opposite()</computeroutput> jumping with an iterator. Note that when calling <computeroutput><ref refid="classEdgeListGraph_1ac8f83485fc28d4149edd8eab690d40ab" kindref="member">source()</ref></computeroutput> we have to dereference <computeroutput>hi</computeroutput>, as the function expects a halfedge descriptor and not a halfedge iterator. Also observe that <computeroutput><ref refid="group__PkgBGLIterators_1ga2be4fd4d24b1e48e00a92f90f0f2923c" kindref="member">halfedges_around_target()</ref></computeroutput> expects a halfedge, and not a vertex. This provides the user with the ability to start the traversal at a specific halfedge incident to the input vertex (and not the arbitrary incident halfedge stored in the vertex record.)</para><para><linebreak/>
<bold>File</bold> <ref refid="BGL_polyhedron_3_2incident_vertices_8cpp-example" kindref="compound">BGL_polyhedron_3/incident_vertices.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/iterator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Polyhedron&gt;<sp/>GraphTraits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>GraphTraits::vertex_descriptor<sp/>vertex_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Halfedge__around__target__iterator" kindref="compound">CGAL::Halfedge_around_target_iterator&lt;Polyhedron&gt;</ref><sp/>halfedge_around_target_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>OutputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></highlight></codeline>
<codeline><highlight class="normal">adjacent_vertices_V1(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Polyhedron&amp;<sp/>g,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vertex_descriptor<sp/>vd,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref><sp/>out)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>GraphTraits::halfedge_descriptor<sp/>hb<sp/>=<sp/>halfedge(vd,g),<sp/>done(hb);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*out++<sp/>=<sp/>source(hb,g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hb<sp/>=<sp/><ref refid="group__kernel__enums_1gad0a8110cb95f76bac65649bfe58c650b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">opposite</ref>(<ref refid="group__STLAlgos_1gad4dbc8daf3c0e2201f4972eb9eea404d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">next</ref>(hb,g),g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(hb!=<sp/>done);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>out;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>OutputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></highlight></codeline>
<codeline><highlight class="normal">adjacent_vertices_V2(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Polyhedron&amp;<sp/>g,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vertex_descriptor<sp/>vd,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref><sp/>out)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>halfedge_around_target_iterator<sp/>hi,<sp/>he;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(boost::tie(hi,<sp/>he)<sp/>=<sp/><ref refid="group__PkgBGLIterators_1ga2be4fd4d24b1e48e00a92f90f0f2923c" kindref="member">halfedges_around_target</ref>(halfedge(vd,g),g);<sp/>hi<sp/>!=<sp/>he;<sp/>++hi)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*out++<sp/>=<sp/>source(*hi,g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>out;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GraphTraits::vertex_iterator<sp/>vi<sp/>=<sp/>vertices(P).first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;vertex_descriptor&gt;<sp/>V;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>adjacent_vertices_V1(P,<sp/>*vi,<sp/>std::back_inserter(V));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>++vi;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>adjacent_vertices_V2(P,<sp/>*vi,<sp/>std::back_inserter(V));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1BGLExampleNormalHalfedgeGraph">
<title>Example: Calculating Facet Normals using HalfedgeGraph</title>
<para>The following example program shows a simple algorithm for calculating facet normals for a polyhedron using the Bgl API. A <ulink url="https://www.boost.org/libs/property_map/doc/vector_property_map.html">boost::vector_property_map</ulink> is used to to store the calculated normals instead of changing the Polyhedron items class.</para><para><linebreak/>
<bold>File</bold> <ref refid="BGL_polyhedron_3_2normals_8cpp-example" kindref="compound">BGL_polyhedron_3/normals.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/graph_traits.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Kernel/global_functions.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Polyhedron</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_items_with_id_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">CGAL::Polyhedron_3&lt;Kernel, CGAL::Polyhedron_items_with_id_3&gt;</ref><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classHalfedgeGraph" kindref="compound">HalfedgeGraph</ref>,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PointMap,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>NormalMap&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>calculate_face_normals(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classHalfedgeGraph" kindref="compound">HalfedgeGraph</ref>&amp;<sp/>g,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PointMap<sp/>pm,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NormalMap<sp/>nm)<sp/></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;HalfedgeGraph&gt;<sp/>GraphTraits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>GraphTraits::face_iterator<sp/>face_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>GraphTraits::halfedge_descriptor<sp/>halfedge_descriptor;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>boost::property_traits&lt;PointMap&gt;::value_type<sp/>point;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>boost::property_traits&lt;NormalMap&gt;::value_type<sp/><ref refid="group__normal__grp_1ga49a712e57564602ad468a3888784e971" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">normal</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>face_iterator<sp/>fb,<sp/>fe;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(boost::tie(fb,<sp/>fe)<sp/>=<sp/>faces(g);<sp/>fb<sp/>!=<sp/>fe;<sp/>++fb)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>halfedge_descriptor<sp/>edg<sp/>=<sp/>halfedge(*fb,<sp/>g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>halfedge_descriptor<sp/>edgb<sp/>=<sp/>edg;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point<sp/>p0<sp/>=<sp/>pm[target(edg,<sp/>g)];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>edg<sp/>=<sp/><ref refid="group__STLAlgos_1gad4dbc8daf3c0e2201f4972eb9eea404d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">next</ref>(edg,<sp/>g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point<sp/>p1<sp/>=<sp/>pm[target(edg,<sp/>g)];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>edg<sp/>=<sp/><ref refid="group__STLAlgos_1gad4dbc8daf3c0e2201f4972eb9eea404d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">next</ref>(edg,<sp/>g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point<sp/>p2<sp/>=<sp/>pm[target(edg,<sp/>g)];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>edg<sp/>=<sp/><ref refid="group__STLAlgos_1gad4dbc8daf3c0e2201f4972eb9eea404d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">next</ref>(edg,<sp/>g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(edg<sp/>==<sp/>edgb)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>triangle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>nm[*fb]<sp/>=<sp/><ref refid="group__unit__normal__grp_1gaeb8231145ba0cdde8e28fc4f983f23ef" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::unit_normal</ref>(p1,<sp/>p2,<sp/>p0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>not<sp/>a<sp/>triangle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>normal<sp/>n(<ref refid="group__kernel__enums_1ga4a98ec6bd9dfd8fe8c46fea553b5d238" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::NULL_VECTOR</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>n<sp/>+<sp/><ref refid="group__normal__grp_1ga49a712e57564602ad468a3888784e971" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::normal</ref>(p1,<sp/>p2,<sp/>p0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p0<sp/>=<sp/>p1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p1<sp/>=<sp/>p2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>edg<sp/>=<sp/><ref refid="group__STLAlgos_1gad4dbc8daf3c0e2201f4972eb9eea404d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">next</ref>(edg,<sp/>g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p2<sp/>=<sp/>pm[target(edg,<sp/>g)];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(edg<sp/>!=<sp/>edgb);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>nm[*fb]<sp/>=<sp/>n<sp/>/<sp/><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::sqrt</ref>(n.squared_length());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::property_map&lt;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBGLProperties_1ga315e5c7e887e2c2937eb411e14115dc6" kindref="member">CGAL::face_index_t</ref><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&gt;::const_type<sp/>Face_index_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>P<sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>initialize<sp/>facet<sp/>indices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>i<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Polyhedron::Facet_iterator<sp/>it<sp/>=<sp/>P.facets_begin();<sp/>it<sp/>!=<sp/>P.facets_end();<sp/>++it,<sp/>++i)<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>it-&gt;id()<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Ad<sp/>hoc<sp/>property_map<sp/>to<sp/>store<sp/>normals.<sp/>Face_index_map<sp/>is<sp/>used<sp/>to</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>map<sp/>face_descriptors<sp/>to<sp/>a<sp/>contiguous<sp/>range<sp/>of<sp/>indices.<sp/>See</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>http://www.boost.org/libs/property_map/doc/vector_property_map.html</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>details.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::vector_property_map&lt;Vector,<sp/>Face_index_map&gt;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>normals(</highlight><highlight class="keyword">get</highlight><highlight class="normal">(CGAL::face_index,<sp/>P));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>calculate_face_normals(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P<sp/></highlight><highlight class="comment">//<sp/>Graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>,<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(CGAL::vertex_point,<sp/>P)<sp/></highlight><highlight class="comment">//<sp/>map<sp/>from<sp/>vertex_descriptor<sp/>to<sp/>point</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>,<sp/>normals<sp/></highlight><highlight class="comment">//<sp/>map<sp/>from<sp/>face_descriptor<sp/>to<sp/>Vector_3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Normals&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Polyhedron::Facet_iterator<sp/>it<sp/>=<sp/>P.facets_begin();<sp/>it<sp/>!=<sp/>P.facets_end();<sp/>++it)<sp/>{<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Facet_iterator<sp/>is<sp/>a<sp/>face_descriptor,<sp/>so<sp/>we<sp/>can<sp/>use<sp/>it<sp/>as<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>key<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>normals[it]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
</sect2>
<sect2 id="index_1BGLProperties">
<title>Properties and Dynamic Properties</title>
<para>As the concepts <computeroutput><ref refid="classHalfedgeGraph" kindref="compound">HalfedgeGraph</ref></computeroutput> and <computeroutput><ref refid="classFaceGraph" kindref="compound">FaceGraph</ref></computeroutput> add the notion of halfedges and faces, as well as a geometric embedding of the vertices, we have to add property tags such as <computeroutput>face_index_t</computeroutput> and <computeroutput>vertex_point_t</computeroutput>.</para><para>We further add <emphasis>dynamic properties</emphasis> that enable the user to add properties to vertices, halfedges, edges, and faces on the fly. The lifetime of a dynamic property is bound to the lifetime of the property map: reference counting is used to delete the property when no map refers to it.</para><para>Dynamic property tags, such as <computeroutput><ref refid="structCGAL_1_1dynamic__vertex__property__t" kindref="compound">dynamic_vertex_property_t</ref></computeroutput>, are a generalization of <computeroutput><ref refid="group__PkgBGLProperties_1gaec83b8086dfd0cb99447a6d0d14beeee" kindref="member">boost::vertex_index_t</ref></computeroutput>, as they have a template parameter for the value type of the dynamic property map, and a default value. <computeroutput>boost::property_map&lt;G,T&gt;::type</computeroutput> is used to obtain the type of the dynamic property map for a graph of type <computeroutput>G</computeroutput>, for a dynamic property tag <computeroutput>T</computeroutput>. This type must be default constructible and assignable. As for ordinary properties, the function <computeroutput>get()</computeroutput> is overloaded and serves for retrieving a property map for a given graph and dynamic property tag, as well as for retrieving a value for a given key and property map.</para><para>The following example shows how to attach a <computeroutput>string</computeroutput> property to vertices and a <computeroutput>double</computeroutput> value to the halfedges of a graph.</para><para><linebreak/>
<bold>File</bold> <ref refid="Property_map_2dynamic_properties_8cpp-example" kindref="compound">Property_map/dynamic_properties.cpp</ref> <programlisting><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_3<sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Point_3&gt;</ref><sp/>Mesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mesh<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBGLHelperFct_1ga81ac0b6fbedf7889e0164aec540bd112" kindref="member">CGAL::make_triangle</ref>(Point_3(0,0,0),Point_3(1,0,0),Point_3(1,1,0),<sp/>mesh);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::property_map&lt;Mesh,<sp/>CGAL::dynamic_vertex_property_t&lt;std::string&gt;<sp/>&gt;::type<sp/>VertexNameMap;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>VertexNameMap<sp/>vnm<sp/><sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(<ref refid="structCGAL_1_1dynamic__vertex__property__t" kindref="compound">CGAL::dynamic_vertex_property_t&lt;std::string&gt;</ref>(),<sp/>mesh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>put(vnm,<sp/>*(vertices(mesh).first),<sp/></highlight><highlight class="stringliteral">&quot;Paris&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(vnm,<sp/>*(vertices(mesh).first))<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::property_map&lt;Mesh,<sp/>CGAL::dynamic_halfedge_property_t&lt;double&gt;<sp/>&gt;::type<sp/>TrafficDensityMap;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>TrafficDensityMap<sp/>tdm<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(<ref refid="structCGAL_1_1dynamic__halfedge__property__t" kindref="compound">CGAL::dynamic_halfedge_property_t&lt;double&gt;</ref>(),<sp/>mesh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>put(tdm,<sp/>*(halfedges(mesh).first),<sp/>0.7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(tdm,<sp/>*(halfedges(mesh).first))<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1BGLEulerOperations">
<title>Euler Operations</title>
<para>There are two categories of mutating operations. The first category comprises low level operations that change incidences such as the target vertex of a halfedge. A halfedge graph might turn invalid by the application of inconsistent low lever operations. The second category of operations are called <emphasis>Euler Operations</emphasis>. These are high level operations such as adding a center vertex to a face, which means also adding halfedges and faces, and updating incidence information. The Euler operations enable manipulating models of <computeroutput><ref refid="classMutableFaceGraph" kindref="compound">MutableFaceGraph</ref></computeroutput>.</para><para>The complete list of Euler operations provided by this package can be found in <ref refid="group__PkgBGLEulerOperations" kindref="compound">the reference manual</ref>.</para></sect1>
<sect1 id="index_1BGLGraphAdaptors">
<title>Graph Adaptors</title>
<para>Graph adaptors are classes that build an interface over an existing graph to provide new functionalities. By operating almost entirely on the input graph, adaptors can avoid potentially expensive operations, both in term of time and memory.</para><sect2 id="index_1BGLDual">
<title>The Dual Graph</title>
<para>The <emphasis>dual graph</emphasis> of a <computeroutput><ref refid="classFaceGraph" kindref="compound">FaceGraph</ref></computeroutput> <computeroutput>G</computeroutput> is a graph that has a vertex for each face of <computeroutput>G</computeroutput>. The dual graph has an edge whenever two faces of <computeroutput>G</computeroutput> are separated from each other by an edge. Thus, each edge <computeroutput>e</computeroutput> of <computeroutput>G</computeroutput> has a corresponding dual edge, the edge that connects the two faces on either side of <computeroutput>e</computeroutput>. Computing the dual graph of a graph has many uses, for example when one wishes to compute the connected components of a mesh.</para><para>The class template <computeroutput><ref refid="classCGAL_1_1Dual" kindref="compound">Dual</ref></computeroutput> is an adaptor that creates the dual view of a <computeroutput><ref refid="classFaceGraph" kindref="compound">FaceGraph</ref></computeroutput>. Faces of the original graph correspond to vertices in the <computeroutput><ref refid="classCGAL_1_1Dual" kindref="compound">Dual</ref></computeroutput> and vice versa.</para><para>Note that border edges in a <computeroutput><ref refid="classCGAL_1_1Dual" kindref="compound">Dual</ref></computeroutput> have the <computeroutput>null_face</computeroutput> of the original graph as either source or target. This is unusual and might break other algorithms since edges are always assumed to have non-null vertices as a source and target. It is nevertheless possible to filter border edges using <ulink url="https://www.boost.org/libs/graph/doc/filtered_graph.html">boost::filtered_graph</ulink>, as shown in the following example.</para><para><linebreak/>
<bold>File</bold> <ref refid="BGL_surface_mesh_2surface_mesh_dual_8cpp-example" kindref="compound">BGL_surface_mesh/surface_mesh_dual.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/Dual.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/helpers.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/filtered_graph.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/connected_components.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/foreach.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Point&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Mesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Dual" kindref="compound">CGAL::Dual&lt;Mesh&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dual;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Dual&gt;::edge_descriptor<sp/>edge_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>G&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">noborder<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>noborder()<sp/>:<sp/>g(NULL)<sp/>{}<sp/></highlight><highlight class="comment">//<sp/>default-constructor<sp/>required<sp/>by<sp/>filtered_graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>noborder(G&amp;<sp/>g)<sp/>:<sp/>g(&amp;g)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>edge_descriptor&amp;<sp/>e)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!<ref refid="group__PkgBGLHelperFct_1gad93e429ad24efeaddeb836c437e719ab" kindref="member">is_border</ref>(e,*g);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>G*<sp/>g;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>dual<sp/>border<sp/>edge<sp/>has<sp/>a<sp/>null_face<sp/>as<sp/>the<sp/>source<sp/>or<sp/>target<sp/>&quot;vertex&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>BGL<sp/>algorithms<sp/>won&apos;t<sp/>like<sp/>that,<sp/>so<sp/>we<sp/>remove<sp/>border<sp/>edges<sp/>through<sp/>a</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>boost::filtered_graph.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::filtered_graph&lt;Dual,<sp/>noborder&lt;Mesh&gt;<sp/>&gt;<sp/><sp/><sp/>FiniteDual;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Mesh&gt;::vertex_descriptor<sp/><sp/><sp/>vertex_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Mesh&gt;::face_descriptor<sp/><sp/><sp/><sp/><sp/>face_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Mesh&gt;::edge_descriptor<sp/><sp/><sp/><sp/><sp/>edge_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mesh<sp/>primal;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/prim.off&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!(in<sp/>&gt;&gt;<sp/>primal))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error<sp/>reading<sp/>polyhedron<sp/>from<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dual<sp/>dual(primal);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FiniteDual<sp/>finite_dual(dual,noborder&lt;Mesh&gt;(primal));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;dual<sp/>has<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>num_vertices(dual)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>vertices<sp/>of<sp/>dual<sp/>are<sp/>faces<sp/>in<sp/>primal&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BOOST_FOREACH(boost::graph_traits&lt;Dual&gt;::vertex_descriptor<sp/>dvd<sp/>,<sp/>vertices(dual))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>dvd<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>edges<sp/>in<sp/>primal<sp/>and<sp/>dual<sp/>with<sp/>source<sp/>and<sp/>target&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BOOST_FOREACH(edge_descriptor<sp/>e<sp/>,<sp/>edges(dual))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>e<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>in<sp/>primal:<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>source(e,primal)<sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>--<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>target(e,primal)<sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/>in<sp/>dual<sp/><sp/>:<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>source(e,finite_dual)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>--<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>target(e,finite_dual)<sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;edges<sp/>of<sp/>the<sp/>finite<sp/>dual<sp/>graph&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/>BOOST_FOREACH(boost::graph_traits&lt;FiniteDual&gt;::edge_descriptor<sp/>e<sp/>,<sp/>edges(finite_dual))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>e<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>source(e,primal)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>source(e,finite_dual)<sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>the<sp/>storage<sp/>of<sp/>a<sp/>property<sp/>map<sp/>is<sp/>in<sp/>primal</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>Mesh::Property_map&lt;face_descriptor,int&gt;<sp/>fccmap;</highlight></codeline>
<codeline><highlight class="normal"><sp/>fccmap<sp/>=<sp/>primal.add_property_map&lt;face_descriptor,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;f:CC&quot;</highlight><highlight class="normal">).first;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num<sp/>=<sp/><ref refid="group__keep__connected__components__grp_1gabe2052b2281e1e628e68d8fea94be2d9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon_mesh_processing.tag">connected_components</ref>(finite_dual,<sp/>fccmap);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>graph<sp/>has<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>num<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>connected<sp/>components<sp/>(face<sp/>connectivity)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/>BOOST_FOREACH(face_descriptor<sp/>f<sp/>,<sp/>faces(primal))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>f<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>in<sp/>connected<sp/>component<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fccmap[f]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>Mesh::Property_map&lt;vertex_descriptor,int&gt;<sp/>vccmap;</highlight></codeline>
<codeline><highlight class="normal"><sp/>vccmap<sp/>=<sp/>primal.add_property_map&lt;vertex_descriptor,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;v:CC&quot;</highlight><highlight class="normal">).first;</highlight></codeline>
<codeline><highlight class="normal"><sp/>num<sp/>=<sp/><ref refid="group__keep__connected__components__grp_1gabe2052b2281e1e628e68d8fea94be2d9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon_mesh_processing.tag">connected_components</ref>(primal,<sp/>vccmap);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>graph<sp/>has<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>num<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>connected<sp/>components<sp/>(edge<sp/>connectvity)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/>BOOST_FOREACH(vertex_descriptor<sp/>v<sp/>,<sp/>vertices(primal))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>v<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>in<sp/>connected<sp/>component<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vccmap[v]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1BGLSeamMesh">
<title>The Seam Mesh</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Seam__mesh" kindref="compound">Seam_mesh</ref></computeroutput> allows to mark edges of a mesh as <emphasis>seam edges</emphasis> so that they <emphasis>virtually</emphasis> become border edges when exploring a seam mesh with the Bgl API. The input mesh is referred to as <emphasis>underlying</emphasis> mesh of the seam mesh. We denote <computeroutput>tm</computeroutput> and <computeroutput>sm</computeroutput> the underlying mesh and the seam mesh respectively.</para><para>Figure <ref refid="index_1fig__fig_Seam_mesh_1" kindref="member">fig__fig_Seam_mesh_1</ref> shows an example of mesh on which two edges, defined by the halfedge pairs <computeroutput>h2-h3</computeroutput> and <computeroutput>h6-h7</computeroutput>, are marked as seams. The introduction of virtual borders modifies the elementary Bgl graph traversal operations: when we circulate around the target of <computeroutput>h7</computeroutput> in the underlying mesh, we traverse <computeroutput>h7</computeroutput>, <computeroutput>h1</computeroutput>, <computeroutput>h3</computeroutput>, <computeroutput>h5</computeroutput>, before arriving at <computeroutput>h7</computeroutput> again. However, when we circulate in the seam mesh, we traverse <computeroutput>h7</computeroutput>, <computeroutput>h1</computeroutput>, <computeroutput>h3*</computeroutput>, before arriving at <computeroutput>h7</computeroutput> again. Similarly, if we start at <computeroutput>h3</computeroutput>, we traverse <computeroutput>h3</computeroutput>, <computeroutput>h5</computeroutput>, <computeroutput>h7*</computeroutput>, and <computeroutput>h3</computeroutput> again.</para><para><anchor id="index_1fig__fig_Seam_mesh_1"/><image type="html" name="seam_mesh_1.svg"></image>
 <image type="latex" name="seam_mesh_1.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_Seam_mesh_1" kindref="member">fig__fig_Seam_mesh_1</ref> A seam mesh with two seam edges <computeroutput>(h2, h3)</computeroutput> and <computeroutput>(h6, h7)</computeroutput>.  <linebreak/>
</para><para>A vertex of the underlying mesh may correspond to multiple vertices in the seam mesh. For example in Figure <ref refid="index_1fig__fig_Seam_mesh_1" kindref="member">fig__fig_Seam_mesh_1</ref>, the target of <computeroutput>h7</computeroutput> corresponds to two vertices in the seam mesh, on either side of the virtual border created by the seam edges. For this reason, a vertex <computeroutput>v</computeroutput> of the seam mesh is internally represented as a halfedge <computeroutput>h</computeroutput> of the seam mesh. To obtain a canonical definition, the halfedge <computeroutput>h</computeroutput> is defined as the halfedge that has <computeroutput>v</computeroutput> as target, that lies on the seam, and that is not a border halfedge. The function <computeroutput>target(hd, sm)</computeroutput> will return this halfedge. For vertices <computeroutput>v</computeroutput> in the underlying mesh that are not on a seam edge, we choose <computeroutput>halfedge(v, tm)</computeroutput> as its canonical halfedge.</para><sect3 id="index_1BGLSeamMeshTraversal">
<title>Seam Mesh Traversal</title>
<para>Using the function <computeroutput>next(halfedge_descriptor, FaceGraph)</computeroutput>, we can walk around a face but also around a border of a mesh. For the seam mesh <computeroutput>sm</computeroutput> from Figure <ref refid="index_1fig__fig_Seam_mesh_1" kindref="member">fig__fig_Seam_mesh_1</ref>, we have <computeroutput>opposite(h2, sm) == h3*</computeroutput>, and it holds that <computeroutput>face(h3*, sm) == null_face()</computeroutput>. We can walk along this virtual border: starting at <computeroutput>h3*</computeroutput> and repeatedly calling <computeroutput>next(..,sm)</computeroutput>, we will traverse <computeroutput>h6*</computeroutput>, <computeroutput>h7*</computeroutput>, <computeroutput>h2*</computeroutput>, before reaching <computeroutput>h3*</computeroutput> again.</para><para>All other traversal functions, iterators, and circulators (see <ref refid="group__PkgBGLIterators" kindref="compound">Iterators and Circulators</ref>) can be used on a seam mesh, but their behavior is similarly modified by the (virtual and real) border edges of the seam mesh.</para></sect3>
<sect3 id="index_1BGLSeamMeshNature">
<title>Seams</title>
<para>A collection of seam edges, or simply a <emphasis>seam</emphasis>, is not necessarily a simple polyline as we can see in the next figure: <itemizedlist>
<listitem>
<para>In <emphasis>(a)</emphasis>, the seam forms a tree. Consequently, we pass at a vertex as often as there are incident seam edges. </para></listitem>
<listitem>
<para>In <emphasis>(b)</emphasis>, the seam has a vertex <computeroutput>v</computeroutput> on the border of the underlying mesh. While walking along the border of the seam mesh, we leave the border of the underlying mesh when we reach <computeroutput>v</computeroutput> and walk on a virtual border until we reach <computeroutput>v</computeroutput> again, from the other side of the seam. </para></listitem>
<listitem>
<para>In <emphasis>(c)</emphasis>, the seam forms a closed polyline. While the first two define a single border, a cycle defines two borders and splits the set of faces in two connected components. Something similar happens when the seam touches the same border more than once. A seam can also connect different borders, potentially changing the genus of the mesh. Finally, a seam may have more than one connected component. </para></listitem>
</itemizedlist>
</para><para><anchor id="index_1fig__fig_Seam_mesh_2"/><image type="html" name="seam_mesh_2.svg"></image>
 <image type="latex" name="seam_mesh_2.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_Seam_mesh_2" kindref="member">fig__fig_Seam_mesh_2</ref> Walking around a seam <emphasis>(a)</emphasis> with no seam vertex on the real border, <emphasis>(b)</emphasis> with a seam vertex on the real border, <emphasis>(c)</emphasis> with a closed polyline. Vertices of the seam mesh that are linked by a green dashed segment correspond to the same vertex in the underlying mesh.  <linebreak/>
</para><para>Seam meshes are for example used in Chapter <ref refid="packages_1PkgSurfaceParameterizationSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Triangulated Surface Mesh Parameterization</ref> to parameterize a topological sphere by first virtually cutting it into a topological disk.</para></sect3>
</sect2>
</sect1>
<sect1 id="index_1BGLPartitioning">
<title>Graph Partitioning</title>
<para>For algorithms that operate locally, partitioning is often an easy way to parallelize the algorithm at little cost. The functions <computeroutput><ref refid="group__PkgBGLPartition_1gae7e37b6101e63f4c5959f1ae6c6fe7d2" kindref="member">CGAL::METIS::partition_graph()</ref></computeroutput> and <computeroutput><ref refid="group__PkgBGLPartition_1ga145334c09252126cfc87c6000263eb1d" kindref="member">CGAL::METIS::partition_dual_graph()</ref></computeroutput> provide wrappers to the graph partitioning library METIS <ref refid="citelist_1CITEREF_karypis1998fast" kindref="member">[2]</ref>, allowing to split triangular meshes that are models of the concept <computeroutput><ref refid="classFaceListGraph" kindref="compound">FaceListGraph</ref></computeroutput> into a given number of subdomains.</para><para>The following example shows how to read, partition, and write a mesh using <computeroutput><ref refid="group__PkgBGLPartition_1ga145334c09252126cfc87c6000263eb1d" kindref="member">partition_dual_graph()</ref></computeroutput>. The class template <computeroutput><ref refid="structCGAL_1_1Face__filtered__graph" kindref="compound">CGAL::Face_filtered_graph</ref></computeroutput> and the free function <computeroutput><ref refid="group__PkgBGLHelperFct_1ga2d3eb044bfe42eab566779ce32216c11" kindref="member">copy_face_graph()</ref></computeroutput> are used to create an independent mesh from one of the subdomains of the partition. Note that the copy is optional as writing can be done directly using <computeroutput><ref refid="structCGAL_1_1Face__filtered__graph" kindref="compound">Face_filtered_graph</ref></computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="BGL_surface_mesh_2surface_mesh_partition_8cpp-example" kindref="compound">BGL_surface_mesh/surface_mesh_partition.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/Face_filtered_graph.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="partition_8h" kindref="compound">CGAL/boost/graph/partition.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;K::Point_3&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SM;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in((argc&gt;1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/blobby.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_parts<sp/>=<sp/>(argc&gt;2)<sp/>?<sp/>atoi(argv[2])<sp/>:<sp/>8;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!in)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>could<sp/>not<sp/>read<sp/>input<sp/>file&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SM<sp/>sm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgPolyhedronIOFunc_1ga9791a3720c7a3e9e32e43aed28cd9695" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">CGAL::read_off</ref>(in,<sp/>sm);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>vertex<sp/>&lt;--&gt;<sp/>partition_id<sp/>property<sp/>map</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>SM::Property_map&lt;SM::Vertex_index,<sp/>std::size_t&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_id_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_id_map<sp/>vertex_pid_map<sp/>=<sp/>sm.add_property_map&lt;SM::Vertex_index,<sp/>std::size_t&gt;(</highlight><highlight class="stringliteral">&quot;v:pid&quot;</highlight><highlight class="normal">).first;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>face<sp/>&lt;--&gt;<sp/>partition_id<sp/>property<sp/>map</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>SM::Property_map&lt;SM::Face_index,<sp/>std::size_t&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_id_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_id_map<sp/>face_pid_map<sp/>=<sp/>sm.add_property_map&lt;SM::Face_index,<sp/>std::size_t&gt;(</highlight><highlight class="stringliteral">&quot;f:pid&quot;</highlight><highlight class="normal">).first;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Partition<sp/>the<sp/>mesh</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBGLPartition_1ga145334c09252126cfc87c6000263eb1d" kindref="member">CGAL::METIS::partition_dual_graph</ref>(sm,<sp/>number_of_parts,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::vertex_partition_id_map(vertex_pid_map)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.face_partition_id_map(face_pid_map));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>the<sp/>part<sp/>n0<sp/>of<sp/>the<sp/>partition<sp/>into<sp/>a<sp/>new,<sp/>independent<sp/>mesh</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Face__filtered__graph" kindref="compound">CGAL::Face_filtered_graph&lt;SM&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Filtered_graph;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Filtered_graph<sp/>filtered_sm(sm,<sp/>0<sp/></highlight><highlight class="comment">/*id<sp/>of<sp/>th<sp/>part*/</highlight><highlight class="normal">,<sp/>face_pid_map);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(filtered_sm.is_selection_valid());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SM<sp/>part_sm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBGLHelperFct_1ga2d3eb044bfe42eab566779ce32216c11" kindref="member">CGAL::copy_face_graph</ref>(filtered_sm,<sp/>part_sm);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>the<sp/>mesh<sp/>extracted<sp/>from<sp/>subpart<sp/>n0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out(</highlight><highlight class="stringliteral">&quot;sm_part_0.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgPolyhedronIOFunc_1gaf6c472230000452a586037b3d4f04561" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">CGAL::write_off</ref>(out,<sp/>part_sm);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>all<sp/>the<sp/>vertices<sp/>that<sp/>are<sp/>in<sp/>the<sp/>part<sp/>n0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>outxyz(</highlight><highlight class="stringliteral">&quot;out.xyz&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::graph_traits&lt;SM&gt;::vertex_iterator<sp/>vit,<sp/>ve;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::tie(vit,<sp/>ve)<sp/>=<sp/>vertices(sm);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(;<sp/>vit!=ve;<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(</highlight><highlight class="keyword">get</highlight><highlight class="normal">(vertex_pid_map,<sp/>*vit)<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>outxyz<sp/>&lt;&lt;<sp/>sm.point(*vit)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Using <ref refid="index_1BGLNamedParameters" kindref="member">Named Parameters</ref> some of the many options of METIS can be customized, as shown in <ref refid="BGL_polyhedron_3_2polyhedron_partition_8cpp-example" kindref="compound">this example</ref>. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
