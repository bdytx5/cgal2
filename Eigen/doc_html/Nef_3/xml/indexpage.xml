<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_3D_Boolean_Operations_on_Nef_Polyhedra"/><anchor id="index_1chapterNef3"/>  <formula id="4">$ \newcommand{\pyr}{\operatorname{Pyr}} \newcommand{\aff}{\operatorname{aff}} $</formula> </para><para> <simplesect kind="authors"><para>Peter Hachenberger and Lutz Kettner</para></simplesect>
</para><sect1 id="index_1Nef_3Introduction">
<title>Introduction</title>
<para>In solid modeling, two major representation schemes are used: <emphasis>constructive solid geometry</emphasis> (CSG) and <emphasis>boundary representations</emphasis> (B-rep). Both have inherent strengths and weaknesses, see <ref refid="citelist_1CITEREF_cgal:h-gsmi-89" kindref="member">[3]</ref> for a discussion.</para><para>In CSG a solid is represented as a set-theoretic Boolean combination of primitive solid objects, such as blocks, prisms, cylinders, or toruses. The Boolean operations are not evaluated, instead, objects are represented implicitly with a tree structure; leaves represent primitive objects and interior nodes represent Boolean operations or rigid motions, e.g., translation and rotation. Algorithms on such a CSG-tree first evaluate properties on the primitive objects and propagate the results using the tree structure.</para><para>A B-rep describes the incidence structure and the geometric properties of all lower-dimensional features of the boundary of a solid. Surfaces are oriented to decide between the interior and exterior of a solid.</para><para>The class of representable objects in a CSG is usually limited by the choice of the primitive solids. A B-rep is usually limited by the choice for the geometry of the supporting curves for edges and the supporting surfaces for surface patches, and, in addition, the connectivity structure that is allowed. In particular, a B-rep is not always closed under Boolean set operations. As an example, the class of orientable 2-manifold objects is a popular and well understood class of surfaces commonly used for B-reps. They can be represented and manipulated efficiently, the data structures are compact in storage size, and many algorithms are simple. On the other side, this object class is not closed under Boolean set operations, as many examples can illustrate, such as the Figure shown above that can be generated using Boolean set operations on cubes. The vertices bounding the tunnel, or the edge connecting the &quot;roof&quot; with the cube are non-manifold situations.</para><para>In our implementation of Nef polyhedra in 3D, we offer a B-rep data structure that is closed under Boolean operations and with all their generality. Starting from halfspaces (and also directly from oriented 2-manifolds), we can work with set union, set intersection, set difference, set complement, interior, exterior, boundary, closure, and regularization operations (see Section <ref refid="index_1sectoinRegularized" kindref="member">Regularized Set Operations</ref> for an explaination of regularized set operations). In essence, we can evaluate a CSG-tree with halfspaces as primitives and convert it into a B-rep representation.</para><para>In fact, we work with two data structures; one that represents the local neighborhoods of vertices, which is in itself already a complete description, and a data structure that connects these neighborhoods up to a global data structure with edges, facets, and volumes. We offer a rich interface to investigate these data structures, their different elements and their connectivity. We provide affine (rigid) transformations and a point location query operation. We have a custom file format for storing and reading Nef polyhedra from files.</para></sect1>
<sect1 id="index_1Nef_3Definition">
<title>Definition</title>
<para>The theory of Nef polyhedra has been developed for arbitrary dimensions. The class <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> implements a boundary representation for the 3-dimensional case.</para><para><bold>Definition:</bold> A <emphasis>Nef-poly-he-dron</emphasis> in dimension <formula id="5">$ d$</formula> is a point set <formula id="6">$ P \subseteq \mathbb{R}^d$</formula> generated from a finite number of open halfspaces by set complement and set intersection operations.</para><para>Set union, difference and symmetric difference can be reduced to intersection and complement. Set complement changes between open and closed halfspaces, thus the topological operations <emphasis>boundary</emphasis>, <emphasis>interior</emphasis>, <emphasis>exterior</emphasis>, <emphasis>closure</emphasis> and <emphasis>regularization</emphasis> are also in the modeling space of Nef polyhedra.</para><para>A face of a Nef polyhedron is defined as an equivalence class of <emphasis>local pyramids</emphasis> that are a characterization of the local space around a point.</para><para><bold>Definition:</bold> A point set <formula id="7">$ K \subseteq \mathbb{R}^d$</formula> is called a <emphasis>cone with apex <formula id="8">$ 0$</formula></emphasis>, if <formula id="9">$ K = \mathbb{R}^{+} K$</formula> (i.e., <formula id="10">$ \forall p \in K, \forall \lambda &gt; 0: \lambda p \in K$</formula>) and it is called a <emphasis>cone with apex <formula id="11">$ x$</formula></emphasis>, <formula id="12">$ x \in \mathbb{R}^d$</formula>, if <formula id="13">$ K = x + \mathbb{R}^{+} (K - x)$</formula>. A cone <formula id="14">$ K$</formula> is called a <emphasis>pyramid</emphasis> if <formula id="14">$ K$</formula> is a polyhedron.</para><para>Now let <formula id="15">$ P \in \mathbb{R}^d$</formula> be a polyhedron and <formula id="12">$ x \in \mathbb{R}^d$</formula>. There is a neighborhood <formula id="16">$ U_0(x)$</formula> of <formula id="11">$ x$</formula> such that the pyramid <formula id="17">$ Q := x + \mathbb{R}^{+} ((P \cap U(x)) - x)$</formula> is the same for all neighborhoods <formula id="18">$ U(x) \subseteq U_0(x)$</formula>. <formula id="19">$ Q$</formula> is called the <emphasis>local pyramid</emphasis> of <formula id="20">$ P$</formula> in <formula id="11">$ x$</formula> and denoted <formula id="21">$ \pyr_P(x)$</formula>.</para><para><bold>Definition:</bold> Let <formula id="15">$ P \in \mathbb{R}^d$</formula> be a polyhedron and <formula id="22">$ x, y \in \mathbb{R}^d$</formula> be two points. We define an equivalence relation <formula id="23">$ x \sim y$</formula> iff <formula id="24">$ \pyr_P(x) = \pyr_P(y)$</formula>. The equivalence classes of <formula id="25">$ \sim$</formula> are the <emphasis>faces</emphasis> of <formula id="20">$ P$</formula>. The dimension of a face <formula id="26">$ s$</formula> is the dimension of its affine hull, <formula id="27">$ \dim s := \dim \aff s$</formula>.</para><para>In other words, a <emphasis>face</emphasis> <formula id="26">$ s$</formula> of <formula id="20">$ P$</formula> is a maximal non-empty subset of <formula id="28">$ \mathbb{R}^d$</formula> such that all of its points have the same local pyramid <formula id="19">$ Q$</formula> denoted <formula id="29">$ \pyr_P(s)$</formula>. This definition of a face partitions <formula id="28">$ \mathbb{R}^d$</formula> into faces of different dimension. A face <formula id="26">$ s$</formula> is either a subset of <formula id="20">$ P$</formula>, or disjoint from <formula id="20">$ P$</formula>. We use this later in our data structure and store a selection mark in each face indicating its set membership.</para><para>Faces do not have to be connected. There are only two full-dimensional faces possible, one whose local pyramid is the space <formula id="28">$ \mathbb{R}^d$</formula> itself and the other with the empty set as a local pyramid. All lower-dimensional faces form the <emphasis>boundary</emphasis> of the polyhedron. As usual, we call zero-dimensional faces <emphasis>vertices</emphasis> and one-dimensional faces <emphasis>edges</emphasis>. In the case of polyhedra in space we call two-dimensional faces <emphasis>facets</emphasis> and the full-dimensional faces <emphasis>volumes</emphasis>. Faces are <emphasis>relative open</emphasis> sets, e.g., an edge does not contain its end-vertices.</para><para>We illustrate the definitions with an example in the plane. Given the closed halfspaces <formula id="30">\[ \begin{array}{lllll} h_1: y \ge 0,\ \ \ &amp; h_2: x - y \ge 0,\ \ \ &amp; h_3: x + y \le 3,\ \ \ &amp; h_4: x - y \ge 1,\ \ \ &amp; h_5: x + y \le 2, \end{array} \]</formula> we define our polyhedron <formula id="31">$ P := ( h_1 \cap h_2 \cap h_3) - ( h_4 \cap h_5)$</formula>.</para><para><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="nef_example.png"></image>
 <image type="latex" name="nef_example.png"></image>
  </para></entry><entry thead="no"><para><image type="html" name="nef_pyramids.png"></image>
 <image type="latex" name="nef_pyramids.png"></image>
   </para></entry></row>
</table>
</center></para><para>The left figure illustrates the polyhedron with its partially closed and partially open boundary, i.e., vertex <formula id="32">$ v_4, v_5, v_6$</formula>, and edges <formula id="33">$ e_4$</formula> and <formula id="34">$ e_5$</formula> are not part of <formula id="20">$ P$</formula>. The local pyramids for the faces are <formula id="35">$ \pyr_P(f_1) = \emptyset$</formula> and <formula id="36">$ \pyr_P(f_2) = \mathbb{R}^2$</formula>. Examples for the local pyramids of edges are the closed halfspace <formula id="37">$ h_2$</formula> for the edge <formula id="38">$ e_1$</formula>, <formula id="39">$ \pyr_P(e_1) = h_2$</formula>, and the open halfspace that is the complement of <formula id="40">$ h_4$</formula> for the edge <formula id="34">$ e_5$</formula>, <formula id="41">$ \pyr_P(e_5) = \{(x,y) | x - y &lt; 1\}$</formula>. The edge <formula id="42">$ e_3$</formula> consists actually of two disconnected parts, both with the same local pyramid <formula id="43">$ \pyr_P(e_3) = h_1$</formula>. In our data structure, we will represent the two connected components of the edge <formula id="42">$ e_3$</formula> separately. The figure on the right lists all local pyramids for this example.</para><para>The local pyramids of each vertex are represented by conceptually intersecting the local neighborhood with a small <formula id="44">$ \varepsilon$</formula>-sphere. This intersection forms a planar map on the sphere (see next two figures), which together with the set-selection mark for each item (i.e. vertices, edges, loops and faces) forms a two-dimensional Nef polyhedron embedded in the sphere. We add the set-selection mark for the vertex and call the resulting structure the <emphasis>sphere map</emphasis> of the vertex. We use the prefix <formula id="26">$ s$</formula> to distinguish the elements of the sphere map from the three-dimensional elements. See Chapter <ref refid="index_1Chapter_2D_Boolean_Operations_on_Nef_Polygons_Embedded_on_the_Sphere" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_S2.tag">Chapter_2D_Boolean_Operations_on_Nef_Polygons_Embedded_on_the_Sphere</ref> for further details.</para><para><image type="html" name="sphere_map.png"></image>
 <image type="latex" name="sphere_map.png"></image>
</para><para>Having sphere maps for all vertices of our polyhedron is a sufficient but not easily accessible representation of the polyhedron. We enrich the data structure with more explicit representations of all the faces and incidences between them.</para><para><image type="html" name="snc.png"></image>
 <image type="latex" name="snc.png"></image>
</para><para>We depart slightly from the definition of faces in a Nef polyhedron; we represent the connected components of a face individually and do not implement additional bookkeeping to recover the original faces (e.g., all edges on a common supporting line with the same local pyramid) as this is not needed in our algorithms. We discuss features in the increasing order of dimension.</para><para><variablelist>
<varlistentry><term><bold>edges:</bold></term></varlistentry>
<listitem><para>We store two oppositely oriented edges for each edge and have a pointer from one oriented edge to its opposite edge. Such an oriented edge can be identified with an <emphasis>svertex</emphasis> in a sphere map; it remains to link one <emphasis>svertex</emphasis> with the corresponding opposite <emphasis>svertex</emphasis> in the other sphere map. </para></listitem>
<varlistentry><term><bold>edge uses:</bold></term></varlistentry>
<listitem><para>An edge can have many incident facets (non-manifold situation). We introduce two oppositely oriented edge-uses for each incident facet; one for each orientation of the facet. An edge-use points to its corresponding oriented edge and to its oriented facet. We can identify an edge-use with an oriented <emphasis>sedge</emphasis> in the sphere map, or, in the special case also with an <emphasis>sloop</emphasis>. Without mentioning it explicitly in the remainder, all references to <emphasis>sedge</emphasis> can also refer to <emphasis>sloop</emphasis>. </para></listitem>
<varlistentry><term><bold>facets:</bold></term></varlistentry>
<listitem><para>We store oriented facets as boundary cycles of oriented edge-uses. We have a distinguished outer boundary cycle and several (or maybe none) inner boundary cycles representing holes in the facet. Boundary cycles are linked in one direction. We can access the other traversal direction when we switch to the oppositely oriented facet, i.e., by using the opposite edge-use. </para></listitem>
<varlistentry><term><bold>shells:</bold></term></varlistentry>
<listitem><para>The volume boundary decomposes into different connected components, the <emphasis>shells</emphasis>. A shell consists of a connected set of facets, edges, and vertices incident to this volume. Facets around an edge form a radial order that is captured in the radial order of <emphasis>sedges</emphasis> around an <emphasis>svertex</emphasis> in the sphere map. Using this information, we can trace a shell from one entry element with a graph search. We offer this graph traversal (to the user) in a visitor design pattern. </para></listitem>
<varlistentry><term><bold>volumes:</bold></term></varlistentry>
<listitem><para>A volume is defined by a set of shells, one outer shell containing the volume and several (or maybe none) inner shells separating voids which are excluded from the volume. </para></listitem>
</variablelist>
</para><para>For each face we store a label, e.g., a set-selection mark, which indicates whether the face is part of the solid or if it is excluded. We call the resulting data structure <emphasis>Selective Nef Complex</emphasis>, <emphasis>SNC</emphasis> for short <ref refid="citelist_1CITEREF_cgal:ghhkm-bosnc-03" kindref="member">[2]</ref>. However, in CGAL we identify the names and call the <emphasis>SNC</emphasis> data structure <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput>.</para></sect1>
<sect1 id="index_1sectionNef_3InfiBox">
<title>Infimaximal Box</title>
<para>We call a Nef polyhedron <emphasis>bounded</emphasis> if its boundary is bounded, i.e., finite, and <emphasis>unbounded</emphasis> otherwise. Note that unbounded point sets can have a bounded boundary, for example, the complement of a cube has an unbounded outer volume, but its boundary remains bounded.</para><para>Using a boundary representation, it is convenient (conceptually and in our implementation) to consider bounded Nef polyhedra only. Bounded Nef polyhedra are also closed under Boolean set operations. However, one needs to start with bounded primitives; the conceptually nice halfspaces cannot be used. Instead, we offer a construction from oriented 2-manifolds represented in a <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput>, see Section <ref refid="index_1subsectionNef_3Polyhedron" kindref="member">subsectionNef_3Polyhedron</ref> below.</para><para>In order to handle unbounded Nef polyhedra conceptually in the same way as we handle bounded Nef polyhedra, we intersect them with a bounding cubical volume of size <formula id="45">$ [-R,R]^3$</formula>, where <formula id="46">$ R$</formula> is a symbolical unspecified value, which is finite but larger than all coordinate values that may occur in the bounded part of the polyhedron. As a result, each Nef polyhedron becomes bounded. We call the boundary of the bounding volume the <emphasis>infimaximal box</emphasis> <ref refid="citelist_1CITEREF_cgal:sm-iftml-00" kindref="member">[5]</ref>.</para><para>We clip lines and rays at the infimaximal box. The intersection points with the infimaximal box are called <emphasis>non-standard points</emphasis>, which are points whose coordinates are <formula id="47">$ -R$</formula> or <formula id="46">$ R$</formula> in at least one dimension, and linear functions <formula id="48">$ f(R)$</formula> for the other dimensions. Such extended points (and developed from there also extended segments etc) are provided in CGAL with extended kernels - <computeroutput><ref refid="classCGAL_1_1Extended__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_2.tag">Extended_cartesian</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Extended__homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_2.tag">Extended_homogeneous</ref></computeroutput>. They are regular CGAL kernels with a polynomial type as coordinate number type.</para><para>As long as an extended kernel is used, the full functionality provided by the <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> class is available. If a kernel that does not use polynomials to represent coordinates is used, it is not possible to create or load unbounded Nef polyhedra, but all other operations work as expected. We provided both possibilities, since the restriction to bounded Nef polyhedra improves considerably space requirements (plain number type instead of polynomial), and runtime performance.</para></sect1>
<sect1 id="index_1sectoinRegularized">
<title>Regularized Set Operations</title>
<para>Since manifolds are not closed under Boolean operations, Requicha proposes to use <emphasis>regularized set operations</emphasis> <ref refid="citelist_1CITEREF_cgal:km-st-76" kindref="member">[4]</ref>, cgal:r-rrstm-80. A set is <emphasis>regular</emphasis>, if it equals the closure of its interior. A regularized set operation is defined as the standard set operation followed by a regularization of the result. Regularized sets are closed under regularized set operations.</para><para>Regularized set operations are important since they simplify the class of solids to exclude lower dimensional features and the boundary belongs to the point set. These properties are considered to reflect the nature of physical solids more closely.</para><para>Regularized polyhedral sets are a subclass of Nef polyhedra. We provide the <computeroutput>regularization</computeroutput> operation as a shortcut for the consecutive execution of the <computeroutput>interior</computeroutput> and the <computeroutput>closure</computeroutput> operations.</para></sect1>
<sect1 id="index_1Nef_3Example">
<title>Example Programs</title>
<para>The following example gives a first impression of how to instantiate and use <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput>. We use the <computeroutput><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref></computeroutput> kernel. All Cartesian and homogeneous kernels of CGAL are suitable if the number type parameter follows the usual requirements of being a model of the <computeroutput><ref refid="classFieldNumberType" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">FieldNumberType</ref></computeroutput> concept for the Cartesian kernels, or the <computeroutput><ref refid="classRingNumberType" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">RingNumberType</ref></computeroutput> concept for the homogeneous kernels, respectively. Note however, that in the current state, the Nef polyhedron works only with CGAL kernels. The implementation makes use of CGAL specific functions in kernel objects, and does not yet offer a designed interface to a clean kernel concept that could be offered by an external kernel as well.</para><para>The example creates two Nef polyhedra - <computeroutput>N0</computeroutput> is the empty set, while <computeroutput>N1</computeroutput> represents the full space, i.e., the set of all points in the 3-dimensional space. The assertion assures that the empty set is the complement of the full space.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2nef_3_simple_8cpp-example" kindref="compound">Nef_3/nef_3_simple.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;CGAL::Exact_integer&gt;</ref><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;Kernel&gt;</ref><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N0(Nef_polyhedron::EMPTY);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N1(Nef_polyhedron::COMPLETE);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(N0<sp/>==<sp/>N1.complement());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(N0<sp/>!=<sp/>N1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><sect2 id="index_1Nef_3ConstructionandComparison">
<title>Construction and Comparison</title>
<para>This example shows the various constructors. We can create the empty set, which is also the default constructor, and the full space, i.e. all points of <formula id="3">$ \mathbb{R}^3$</formula> belong to the polyhedron. We can create a halfspace defined by a plane bounding it. It is only available if an extended kernel is used. The halfspace constructor has a second parameter that specifies whether the defining plane belongs to the point set (<computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3_1a633628c79ae6839428de5704e69b1cf3a1055a68fddfc41b86d9e433c7bc088bd" kindref="member">Nef_polyhedron_3::INCLUDED</ref></computeroutput>) or not (<computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3_1a633628c79ae6839428de5704e69b1cf3a7edfb045fbf427924b425a20b0bb74e4" kindref="member">Nef_polyhedron_3::EXCLUDED</ref></computeroutput>). The default value is <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3_1a633628c79ae6839428de5704e69b1cf3a1055a68fddfc41b86d9e433c7bc088bd" kindref="member">Nef_polyhedron_3::INCLUDED</ref></computeroutput>. Additionally, we can create a <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> from a <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput>, see the Section <ref refid="index_1subsectionNef_3Polyhedron" kindref="member">subsectionNef_3Polyhedron</ref> below.</para><para>We can compute the point sets of two Nef polyhedra for equality and proper subset relationships. We offer the usual comparison operators <computeroutput>==</computeroutput>, <computeroutput>!=</computeroutput>, <computeroutput>&lt;=</computeroutput>, <computeroutput>&gt;=</computeroutput>, <computeroutput>&lt;</computeroutput> and <computeroutput>&gt;</computeroutput>.</para><para>Nef polyhedra have the important feature that a representation that is called the <emphasis>reduced W<uumlaut/>rzburg structure</emphasis> is unique, i.e., two point sets of Nef polyhedra are equal if and only if the representations are equal. The proof for the reduced W<uumlaut/>rzburg structure carries over to our representation and the comparison operators are therefore trivial to implement.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2nef_3_construction_8cpp-example" kindref="compound">Nef_3/nef_3_construction.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Extended_homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Extended__homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_2.tag">CGAL::Extended_homogeneous&lt;CGAL::Exact_integer&gt;</ref><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Plane_3<sp/><sp/>Plane_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N1(Nef_polyhedron::EMPTY);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N2(Nef_polyhedron::COMPLETE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N3(Plane_3(<sp/>1,<sp/>2,<sp/>5,-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N4(Plane_3(<sp/>1,<sp/>2,<sp/>5,-1),<sp/>Nef_polyhedron::INCLUDED);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N5(Plane_3(<sp/>1,<sp/>2,<sp/>5,-1),<sp/>Nef_polyhedron::EXCLUDED);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N0<sp/>==<sp/>N1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N3<sp/>==<sp/>N4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N0<sp/>!=<sp/>N2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N3<sp/>!=<sp/>N5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N4<sp/>&gt;=<sp/>N5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N5<sp/>&lt;=<sp/>N4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N4<sp/>&gt;<sp/>N5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N5<sp/>&lt;<sp/>N4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>N5<sp/>=<sp/>N5.closure();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N4<sp/>&gt;=<sp/>N5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N4<sp/>&lt;=<sp/>N5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Nef_3PointSetOperations">
<title>Point Set Operations</title>
<para>As explained in the introduction, Nef polyhedra are closed under all Boolean set operations. The class <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> provides functions and operators for the most common ones: complement (<computeroutput>operator!</computeroutput>), union (<computeroutput>operator+</computeroutput>), difference (<computeroutput>operator-</computeroutput>), intersection (<computeroutput>operator*</computeroutput>) and symmetric difference (<computeroutput>operator^</computeroutput>). Additionally, the operators <computeroutput>*=</computeroutput>, <computeroutput>-=</computeroutput>, <computeroutput>*=</computeroutput> and <computeroutput>^=</computeroutput> are defined.</para><para><computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> also provides the topological operations <computeroutput>interior()</computeroutput>, <computeroutput>closure()</computeroutput> and <computeroutput>boundary()</computeroutput>. With <computeroutput>interior()</computeroutput> one deselects all boundary items, with <computeroutput>boundary()</computeroutput> one deselects all volumes, and with <computeroutput>closure()</computeroutput> one selects all boundary items.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2point_set_operations_8cpp-example" kindref="compound">Nef_3/point_set_operations.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Extended_homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Extended__homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_2.tag">CGAL::Extended_homogeneous&lt;CGAL::Exact_integer&gt;</ref><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Plane__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Plane_3</ref><sp/><sp/>Plane_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N1(Plane_3(<sp/>1,<sp/>0,<sp/>0,-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N2(Plane_3(-1,<sp/>0,<sp/>0,-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N3(Plane_3(<sp/>0,<sp/>1,<sp/>0,-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N4(Plane_3(<sp/>0,-1,<sp/>0,-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N5(Plane_3(<sp/>0,<sp/>0,<sp/>1,-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N6(Plane_3(<sp/>0,<sp/>0,-1,-1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>I1(!N1<sp/>+<sp/>!N2);<sp/><sp/></highlight><highlight class="comment">//<sp/>open<sp/>slice<sp/>in<sp/>yz-plane</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>I2(N3<sp/>-<sp/>!N4);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>closed<sp/>slice<sp/>in<sp/>xz-plane</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>I3(N5<sp/>^<sp/>N6);<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>open<sp/>slice<sp/>in<sp/>yz-plane</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>Cube1(I2<sp/>*<sp/>!I1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Cube1<sp/>*=<sp/>!I3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>Cube2<sp/>=<sp/>N1<sp/>*<sp/>N2<sp/>*<sp/>N3<sp/>*<sp/>N4<sp/>*<sp/>N5<sp/>*<sp/>N6;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(Cube1<sp/>==<sp/>Cube2);<sp/><sp/></highlight><highlight class="comment">//<sp/>both<sp/>are<sp/>closed<sp/>cube</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(Cube1<sp/>==<sp/>Cube1.closure());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(Cube1<sp/>==<sp/>Cube1.regularization());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion((N1<sp/>-<sp/>N1.boundary())<sp/>==<sp/>N1.interior());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(I1.closure()<sp/>==<sp/>I1.complement().interior().complement());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(I1.regularization()<sp/>==<sp/>I1.interior().closure());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Nef_3Transformation">
<title>Transformation</title>
<para>Using the <computeroutput>std::transform</computeroutput> function, a Nef polyhedron can be translated, rotated and scaled. The usage is shown in the following example:</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2transformation_8cpp-example" kindref="compound">Nef_3/transformation.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Extended_homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//instead<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//typedef<sp/>CGAL::Extended_homogeneous&lt;CGAL::Exact_integer&gt;<sp/><sp/>Kernel;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>workaround<sp/>for<sp/>VC++</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Kernel<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Extended__homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_2.tag">CGAL::Extended_homogeneous</ref>&lt;CGAL::Exact_integer&gt;<sp/>{};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Plane_3<sp/><sp/>Plane_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Vector_3<sp/><sp/>Vector_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Aff_transformation_3<sp/><sp/>Aff_transformation_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N(Plane_3(0,1,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Aff_transformation_3<sp/>transl(CGAL::TRANSLATION,<sp/>Vector_3(5,<sp/>7,<sp/>9));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Aff_transformation_3<sp/>rotx90(1,0,0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,0,-1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,1,0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Aff_transformation_3<sp/>scale(3,0,0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,3,0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,0,3,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>N.transform(transl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N<sp/>==<sp/>Nef_polyhedron(Plane_3(0,1,0,-7)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>N.transform(rotx90);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N<sp/>==<sp/>Nef_polyhedron(Plane_3(0,0,1,-7)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>N.transform(scale);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(N<sp/>==<sp/>Nef_polyhedron(Plane_3(0,0,2,-21)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Nef_3TheInterfacebetweenPolyhedron3andNefpolyhedron3">
<title>The Interface between Polyhedron_3 and Nef_polyhedron_3</title>
<para><anchor id="index_1subsectionNef_3Polyhedron"/> <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> provides an interface for the conversion between polyhedral surfaces represented with the <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput> class and <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput>. <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput> represents orientable 2-manifold objects with boundaries. However, we exclude surfaces with boundaries from the conversion to <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> since they have no properly defined volume.</para><para>Both conversion directions can only be performed if the boundary of the point set is an oriented closed 2-manifold. <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> provides the function <computeroutput>is_simple()</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput> provides the function <computeroutput><ref refid="group__PkgBGLHelperFct_1gae04c8044cf1eee6a84baa5b79ab99fef" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">is_closed()</ref></computeroutput> to test for this property. The usage is illustrated by the example program below.</para><para>The conversion gives us the possibility to use several file formats. <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput> can read the (<computeroutput>.off</computeroutput>) file format and can write the (<computeroutput>.off</computeroutput>), OpenInventor (<computeroutput>.iv</computeroutput>), VRML 1.0 and 2.0 (<computeroutput>.wrl</computeroutput>) and Wavefront Advanced Visualizer object format (<computeroutput>.obj</computeroutput>), see Section <ref refid="index_1sectionPolyIO" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">sectionPolyIO</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2interface_polyhedron_8cpp-example" kindref="compound">Nef_3/interface_polyhedron.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;CGAL::Exact_integer&gt;</ref><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;Kernel&gt;</ref><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/><sp/>Vector_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::Aff_transformation_3<sp/><sp/>Aff_transformation_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cin<sp/>&gt;&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(P.is_closed())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Nef_polyhedron<sp/>N1(P);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Nef_polyhedron<sp/>N2(N1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Aff_transformation_3<sp/>aff(CGAL::TRANSLATION,<sp/>Vector_3(2,2,0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>N2.transform(aff);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>N1<sp/>+=<sp/>N2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(N1.is_simple())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>N1.convert_to_polyhedron(P);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;N1<sp/>is<sp/>not<sp/>a<sp/>2-manifold.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Nef_3NeftoPolygonMesh">
<title>Conversion of Nef_polyhedron_3 to Polygon Mesh</title>
<para><anchor id="index_1subsectionNef_3PolygonMesh"/> Conversion to models of <computeroutput><ref refid="classMutableFaceGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">MutableFaceGraph</ref></computeroutput> are possible using the function <computeroutput><ref refid="group__PkgNef3IOFunctions_1ga2e47f1a21e5b35af36c7ef665c66e848" kindref="member">convert_nef_polyhedron_to_polygon_mesh()</ref></computeroutput>. The following example shows how to output a simple <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> into a <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2nef_3_to_surface_mesh_8cpp-example" kindref="compound">Nef_3/nef_3_to_surface_mesh.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/convert_nef_polyhedron_to_polygon_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;sstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Exact_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">CGAL::Polyhedron_3&lt;Exact_kernel&gt;</ref><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Exact_kernel::Point_3&gt;</ref><sp/>Surface_mesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;Exact_kernel&gt;</ref><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fill_cube_1(Polyhedron&amp;<sp/>poly)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>input<sp/>=</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="stringliteral">&quot;OFF\n\</highlight></codeline>
<codeline><highlight class="stringliteral">8<sp/>12<sp/>0\n\</highlight></codeline>
<codeline><highlight class="stringliteral">-1<sp/>-1<sp/>-1\n\</highlight></codeline>
<codeline><highlight class="stringliteral">-1<sp/>1<sp/>-1\n\</highlight></codeline>
<codeline><highlight class="stringliteral">1<sp/>1<sp/>-1\n\</highlight></codeline>
<codeline><highlight class="stringliteral">1<sp/>-1<sp/>-1\n\</highlight></codeline>
<codeline><highlight class="stringliteral">-1<sp/>-1<sp/>1\n\</highlight></codeline>
<codeline><highlight class="stringliteral">-1<sp/>1<sp/>1\n\</highlight></codeline>
<codeline><highlight class="stringliteral">1<sp/>1<sp/>1\n\</highlight></codeline>
<codeline><highlight class="stringliteral">1<sp/>-1<sp/>1\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>0<sp/>1<sp/>3\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>3<sp/>1<sp/>2\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>0<sp/>4<sp/>1\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>1<sp/>4<sp/>5\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>3<sp/>2<sp/>7\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>7<sp/>2<sp/>6\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>4<sp/>0<sp/>3\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>7<sp/>4<sp/>3\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>6<sp/>4<sp/>7\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>6<sp/>5<sp/>4\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>1<sp/>5<sp/>6\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>2<sp/>1<sp/>6&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::stringstream<sp/>ss;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ss<sp/>&lt;&lt;<sp/>input;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ss<sp/>&gt;&gt;<sp/>poly;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fill_cube_2(Polyhedron&amp;<sp/>poly)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>input<sp/>=</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="stringliteral">&quot;OFF\n\</highlight></codeline>
<codeline><highlight class="stringliteral">8<sp/>12<sp/>0\n\</highlight></codeline>
<codeline><highlight class="stringliteral">-0.5<sp/>-0.5<sp/>-0.5\n\</highlight></codeline>
<codeline><highlight class="stringliteral">-0.5<sp/>0.5<sp/>-0.5\n\</highlight></codeline>
<codeline><highlight class="stringliteral">0.5<sp/>0.5<sp/>-0.5\n\</highlight></codeline>
<codeline><highlight class="stringliteral">0.5<sp/>-0.5<sp/>-0.5\n\</highlight></codeline>
<codeline><highlight class="stringliteral">-0.5<sp/>-0.5<sp/>0.5\n\</highlight></codeline>
<codeline><highlight class="stringliteral">-0.5<sp/>0.5<sp/>0.5\n\</highlight></codeline>
<codeline><highlight class="stringliteral">0.5<sp/>0.5<sp/>0.5\n\</highlight></codeline>
<codeline><highlight class="stringliteral">0.5<sp/>-0.5<sp/>0.5\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>0<sp/>1<sp/>3\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>3<sp/>1<sp/>2\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>0<sp/>4<sp/>1\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>1<sp/>4<sp/>5\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>3<sp/>2<sp/>7\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>7<sp/>2<sp/>6\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>4<sp/>0<sp/>3\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>7<sp/>4<sp/>3\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>6<sp/>4<sp/>7\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>6<sp/>5<sp/>4\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>1<sp/>5<sp/>6\n\</highlight></codeline>
<codeline><highlight class="stringliteral">3<sp/><sp/>2<sp/>1<sp/>6&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::stringstream<sp/>ss;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ss<sp/>&lt;&lt;<sp/>input;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ss<sp/>&gt;&gt;<sp/>poly;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>two<sp/>nested<sp/>cubes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyhedron<sp/>cube1,<sp/>cube2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fill_cube_1(cube1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fill_cube_2(cube2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>nef1(cube1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>nef2(cube2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>the<sp/>difference<sp/>of<sp/>the<sp/>nested<sp/>cubes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>nef=nef1-nef2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>output<sp/>the<sp/>result<sp/>into<sp/>a<sp/>Surface_mesh</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Surface_mesh<sp/>output;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgNef3IOFunctions_1ga2e47f1a21e5b35af36c7ef665c66e848" kindref="member">CGAL::convert_nef_polyhedron_to_polygon_mesh</ref>(nef,<sp/>output);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out.open(</highlight><highlight class="stringliteral">&quot;out.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out<sp/>&lt;&lt;<sp/>output;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out.close();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Nef_3UsinganExtendedKernel">
<title>Using an Extended Kernel</title>
<para>The provided extended kernels are used the same way as any other CGAL kernel. The essential difference is, that coordinates are not represented by the number type that was used to parameterize the kernel type, but by a <computeroutput>Nef_polynomial</computeroutput> parametrized by that number type.</para><para>The example iterates all vertices of a given Nef polyhedron and decides whether it is an standard vertex or a vertex on the infimaximal box. Furthermore, it tests whether any of the vertices is at <formula id="49">$ (R,R,R)$</formula>. Recall that <formula id="46">$ R$</formula> was the symbolical value, large but finite, for the size of the infimaximal box.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2extended_kernel_8cpp-example" kindref="compound">Nef_3/extended_kernel.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Extended_homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_integer</ref><sp/><sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//instead<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//typedef<sp/>CGAL::Extended_homogeneous&lt;NT&gt;<sp/><sp/>Kernel;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>workaround<sp/>for<sp/>VC++</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Kernel<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Extended__homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_2.tag">CGAL::Extended_homogeneous</ref>&lt;NT&gt;<sp/>{};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::RT<sp/><sp/>RT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Point_3<sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Plane_3<sp/><sp/>Plane_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Vertex_const_iterator<sp/><sp/>Vertex_const_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cin<sp/>&gt;&gt;<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_const_iterator<sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(v<sp/>=<sp/>N.vertices_begin();<sp/>v<sp/>!=<sp/>N.vertices_end();<sp/>++v)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>p(v-&gt;point());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(p.hx().degree()<sp/>&gt;<sp/>0<sp/>||<sp/>p.hy().degree()<sp/>&gt;<sp/>0<sp/>||<sp/>p.hz().degree()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;extended<sp/>vertex<sp/>at<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;standard<sp/>vertex<sp/>at<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(p<sp/>==<sp/>Point_3(RT(0,1),<sp/>RT(0,1),<sp/>RT(0,1)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>found<sp/>vertex<sp/>(right,back,top)<sp/>of<sp/>the<sp/>infimaximal<sp/>box&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Nef_3File">
<title>File I/O</title>
<para><anchor id="index_1sectionNef_3IO"/> <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> provides an input and an output operator for a proprietary file format. It includes the complete incidence structure, the geometric data, and the marks of each item. The output depends on the output operators of the geometric primitives provided by the traits class, and on the output operators of the used number type. Therefore, it is necessary to use the same kernel and the same number type for input and output operations.</para><para>We recommend the use of the CGAL kernels <computeroutput><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Homogeneous</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput>, or <computeroutput><ref refid="classCGAL_1_1Extended__homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_2.tag">Extended_homogeneous</ref></computeroutput>. The homogeneous kernel provides reliable fast performance. In combination with <computeroutput><ref refid="classleda__integer" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">leda_integer</ref></computeroutput> it is the fastest kernel for <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput>. The <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput> uses filtering. In non-degenerate scenarios it&apos;s faster than the <ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Homogeneous</ref> kernel. The most important advantage of the filtered kernel is that it is a Cartesian kernel, which allows the proper handling of OFF files using floating-point coordinates.</para><para>For effective filtering we had to change some concepts. The new concepts must be activated by using the <computeroutput>SNC_indexed_items</computeroutput>, because they don&apos;t apply for the extended kernels, yet. The new concepts also speed up <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> also in combination with all other standard kernels. The following example illustrates their usage.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2handling_double_coordinates_8cpp-example" kindref="compound">Nef_3/handling_double_coordinates.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cin<sp/>&gt;&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N(P);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Exact_predicates_exact_constructions_kernel<sp/>+<sp/>SNC_indexed_items&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>allows<sp/>efficient<sp/>handling<sp/>of<sp/>input<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;using<sp/>floating<sp/>point<sp/>coordinates&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(N.is_simple())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>N.convert_to_polyhedron(P);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>We provide compatibility between the input and output of various kernels. For most of the CGAL kernels it is possible to write a file constructed with one kernel and reread it with another. Also, it is possible to write a bounded Nef polyhedron using the <computeroutput><ref refid="classCGAL_1_1Extended__homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_2.tag">Extended_homogeneous</ref></computeroutput> kernel and to read it afterwards using a standard kernel.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2nefIO_8cpp-example" kindref="compound">Nef_3/nefIO.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Extended_homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_integer</ref><sp/><sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;NT&gt;</ref><sp/><sp/>SK;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Extended__homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_2.tag">CGAL::Extended_homogeneous&lt;NT&gt;</ref><sp/><sp/>EK;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;SK&gt;</ref><sp/><sp/>Nef_polyhedron_S;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;EK&gt;</ref><sp/><sp/>Nef_polyhedron_E;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron_E<sp/>E;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron_S<sp/>S;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cin<sp/>&gt;&gt;<sp/>E;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(E.is_bounded())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ofstream<sp/>out(</highlight><highlight class="stringliteral">&quot;temp.nef3&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/>E;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>in(</highlight><highlight class="stringliteral">&quot;temp.nef3&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in<sp/>&gt;&gt;<sp/>S;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1Nef_3Further">
<title>Further Example Programs</title>
<sect2 id="index_1Nef_3ExploringaSphereMap">
<title>Exploring a Sphere Map</title>
<para>A sphere map is explored by using the function <computeroutput>get_sphere_map()</computeroutput>, which returns the sphere map of the specified vertex as a <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_S2.tag">Nef_polyhedron_S2</ref></computeroutput>. <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_S2.tag">Nef_polyhedron_S2</ref></computeroutput> provides the functionality necessary for the exploration. Note, that one has to use the type <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__S2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_S2.tag">Nef_polyhedron_S2</ref></computeroutput> as specified in <computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> as is shown in the following example.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2exploration_SM_8cpp-example" kindref="compound">Nef_3/exploration_SM.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;CGAL::Exact_integer&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;Kernel&gt;</ref><sp/>Nef_polyhedron_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We&apos;ve<sp/>put<sp/>the<sp/>typedefs<sp/>here<sp/>as<sp/>VC7<sp/>gives<sp/>us<sp/>an<sp/>ICE<sp/>if<sp/>they<sp/>are<sp/>global<sp/>typedefs</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3_1a5bfb0f31e3c2992f7fb590a5a52bd955" kindref="member">Nef_polyhedron_3::Vertex_const_iterator</ref><sp/>Vertex_const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3_1aed7a232086efcb963201c14b8b684c64" kindref="member">Nef_polyhedron_3::Nef_polyhedron_S2</ref><sp/>Nef_polyhedron_S2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1ab8c065032149003b2a13676eead440e8" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_S2.tag">Nef_polyhedron_S2::SVertex_const_handle</ref><sp/>SVertex_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a451791355a3c6f37c518201f868fb481" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_S2.tag">Nef_polyhedron_S2::SHalfedge_const_handle</ref><sp/>SHalfedge_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a5e369fac0476252aa4922cd418ec3f11" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_S2.tag">Nef_polyhedron_S2::SHalfloop_const_handle</ref><sp/>SHalfloop_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a6e922713ff9859c939b90320cdcdd06c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_S2.tag">Nef_polyhedron_S2::SFace_const_iterator</ref><sp/>SFace_const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__S2_1a8bf70a1ec332bb0c1af5bea79a51fc72" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Nef_S2.tag">Nef_polyhedron_S2::SFace_cycle_const_iterator</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SFace_cycle_const_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron_3<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cin<sp/>&gt;&gt;<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_const_iterator<sp/>v<sp/>=<sp/>N.vertices_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron_S2<sp/>S(N.get_sphere_map(v));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SFace_const_iterator<sp/>sf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(sf<sp/>=<sp/>S.sfaces_begin();<sp/>sf<sp/>!=<sp/>S.sfaces_end();<sp/>sf++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SFace_cycle_const_iterator<sp/>it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;the<sp/>sface<sp/>cycles<sp/>of<sp/>sface<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i++<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>start<sp/>with<sp/>an\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(it<sp/>=<sp/>sf-&gt;sface_cycles_begin();<sp/>it<sp/>!=<sp/>sf-&gt;sface_cycles_end();<sp/>it++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it.is_svertex())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>svertex<sp/>at<sp/>position<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>SVertex_const_handle(it)-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it.is_shalfedge())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>shalfedge<sp/>from<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>SHalfedge_const_handle(it)-&gt;source()-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>to<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>SHalfedge_const_handle(it)-&gt;target()-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it.is_shalfloop())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>shalfloop<sp/>lying<sp/>in<sp/>the<sp/>plane<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>SHalfloop_const_handle(it)-&gt;circle()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>other<sp/>cases<sp/>can<sp/>not<sp/>occur.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1subsectionNef_3ShellExploration">
<title>Exploring Shells</title>
<para>A <emphasis>shell</emphasis> of a Nef polyhedron is the connected part of the surface incident to a certain volume. Each halffacet, sface and shalfedge belongs to a single shell. The figure below illustrates the notion of a shell. It shows a Nef polyhedron with two volumes and three shells.</para><para><image type="html" name="shells.png"></image>
 <image type="latex" name="shells.png"></image>
</para><para>The first volume is the outer volume and the second volume is the interior of the cube. The first shell is the whole surface of the left object. The second shell is the outer surface of the right object, and the third shell is the inner surface of the right object.</para><para>In detail, the first shell consists of two halffacets, eight halfedges and four vertices. The second shell consists of the eight vertices of the cube plus the two endpoints of the antenna, all halffacets oriented outwards, and all halfedges. The third shell consists of the same eight vertices of the cube, plus the endpoint of the antenna that is in contact with the cube, all halffacets oriented inwards, and all halfedges (the same as for the second shell).</para><para><image type="html" name="closeup.png"></image>
 <image type="latex" name="closeup.png"></image>
</para><para>We discuss how sfaces, shalfedges, and sloops belong to the shells with a closeup view of the situation at the antenna foot. As you can see, there are three items on the sphere map - a shalfloop for each halffacet which intersects the sphere, and an svertex where the antenna intersects the sphere. The upper shalfloop lies on the halffacet which is oriented outwards and is therefore also oriented outwards. This shalfloop and the svertex belong to the second shell. The other shalfloop lies on the inwards oriented halffacet and is oriented inwards, too. This shalfloop belongs to the third shell.</para><para><computeroutput><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">Nef_polyhedron_3</ref></computeroutput> offers a visitor interface to explore a shell following the well-known visitor pattern <ref refid="citelist_1CITEREF_cgal:ghjv-dpero-95" kindref="member">[1]</ref>. The interface is illustrated by the following example.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2shell_exploration_8cpp-example" kindref="compound">Nef_3/shell_exploration.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;CGAL::Exact_integer&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;Kernel&gt;</ref><sp/>Nef_polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Vertex_const_handle<sp/>Vertex_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Halfedge_const_handle<sp/>Halfedge_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Halffacet_const_handle<sp/>Halffacet_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::SHalfedge_const_handle<sp/>SHalfedge_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::SHalfloop_const_handle<sp/>SHalfloop_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::SFace_const_handle<sp/>SFace_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Volume_const_iterator<sp/>Volume_const_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nef_polyhedron::Shell_entry_const_iterator<sp/>Shell_entry_const_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Shell_explorer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_const_handle<sp/>v_min;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Shell_explorer()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>first(true)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>visit(Vertex_const_handle<sp/>v)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(first<sp/>||<sp/><ref refid="group__lexicographically__xyz__smaller__grp_1ga8bf93a0885a3a693c401cd229a52c633" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::lexicographically_xyz_smaller</ref>(v-&gt;point(),v_min-&gt;point()))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>v_min<sp/>=<sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>first=</highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>visit(Halfedge_const_handle<sp/>)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>visit(Halffacet_const_handle<sp/>)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>visit(SHalfedge_const_handle<sp/>)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>visit(SHalfloop_const_handle<sp/>)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>visit(SFace_const_handle<sp/>)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_const_handle&amp;<sp/>minimal_vertex()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>v_min;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>reset_minimal_vertex()<sp/>{<sp/>first<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cin<sp/>&gt;&gt;<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ic<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Volume_const_iterator<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Shell_explorer<sp/>SE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_forall_volumes(c,N)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Volume<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>ic++<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>is<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Shell_entry_const_iterator<sp/>it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_forall_shells_of(it,c)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>SE.reset_minimal_vertex();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>N.visit_shell_objects(SFace_const_handle(it),SE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Point_3<sp/>p(SE.minimal_vertex()-&gt;point());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>minimal<sp/>vertex<sp/>of<sp/>shell<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>is++</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>is<sp/>at<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The function <computeroutput>visit_shell_objects(SFace_const_handle sf, Visitor&amp; V)</computeroutput> explores a shell starting at the <computeroutput>sf</computeroutput>. The second argument expects any class providing the (possibly empty) functions <computeroutput>visit(Vertex_const_handle)</computeroutput>, <computeroutput>visit(Halfedge_const_handle)</computeroutput> (remember that Halfedge is the same type as SVertex), <computeroutput>visit(Halffacet_const_handle)</computeroutput>, <computeroutput>visit(SHalfedge_const_handle)</computeroutput>, <computeroutput>visit(SHalfloop_const_handle)</computeroutput> and <computeroutput>visit(SFace_const_handle)</computeroutput>. The <computeroutput>visit_shell_objects</computeroutput> function will call <computeroutput>visit</computeroutput> for each item belonging to the shell once. There are no further requirements on that class.</para><para>In the example, the class <computeroutput>Shell_explorer</computeroutput> is passed as second argument to <computeroutput>visit_shell_objects</computeroutput>. Its task is to find the lexicographically smallest vertex of a shell. Its internal state consists of three variables. The first one is a reference to the explored Nef polyhedron. This reference is often necessary to retrieve information from the Nef polyhedron. The second variable <computeroutput>v_min</computeroutput> stores the smallest vertex found so far, and the third variable <computeroutput>first</computeroutput> is initialized to <computeroutput>false</computeroutput> to signal that no vertex has been visited so far. After the first vertex has been visited <computeroutput>first</computeroutput> is changed to <computeroutput>true</computeroutput>.</para><para><computeroutput>Shell_explorer</computeroutput> provides further member functions. After the exploration of a shell the <computeroutput>minimal_vertex</computeroutput> function retrieves the smallest vertex. The <computeroutput>reset_minimal_vertex</computeroutput> function allows one to use the same instance of <computeroutput>Shell_explorer</computeroutput> on multiple shells. In this case, the <computeroutput>reset_minimal_vertex</computeroutput> function has to be called between the exploration of two shells.</para><para>The example program uses the <computeroutput>Shell_explorer</computeroutput> for each shell of the given Nef polyhedron once and reports the smallest vertex of each shell to the standard output.</para></sect2>
<sect2 id="index_1Nef_3PointLocation">
<title>Point Location</title>
<para>The <computeroutput>locate(Point_3 p)</computeroutput> function locates the point <computeroutput>p</computeroutput> in the Nef polyhedron and returns the item the point belongs to. The <computeroutput>locate</computeroutput> function returns an instance of <computeroutput>Object_handle</computeroutput>, which is a polymorphic handle type representing any handle type, no matter if it is mutable or const. For further usage of the result, the <computeroutput>Object_handle</computeroutput> has to be casted to the concrete handle type. The <computeroutput>assign()</computeroutput> function performs such a cast. It returns a Boolean that reports the success or the failure of of the cast. Looking at the possible return values of the <computeroutput>locate</computeroutput> function, the <computeroutput>Object_handle</computeroutput> can represent a <computeroutput>Vertex_const_handle</computeroutput>, a <computeroutput>Halfedge_const_handle</computeroutput>, a <computeroutput>Halffacet_handle</computeroutput>, or a <computeroutput>Volume_const_handle</computeroutput>. One of the four casts will succeed.</para><para><linebreak/>
<bold>File</bold> <ref refid="Nef_3_2nef_3_point_location_8cpp-example" kindref="compound">Nef_3/nef_3_point_location.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Nef_polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;CGAL::Exact_integer&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3" kindref="compound">CGAL::Nef_polyhedron_3&lt;Kernel&gt;</ref><sp/>Nef_polyhedron_3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//We&apos;ve<sp/>put<sp/>the<sp/>typedefs<sp/>here<sp/>as<sp/>VC7<sp/>gives<sp/>us<sp/>an<sp/>ICE<sp/>if<sp/>they<sp/>are<sp/>global<sp/>typedefs</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3_1a5fde720c2186d25775d05069d05b76e5" kindref="member">Nef_polyhedron_3::Vertex_const_handle</ref><sp/>Vertex_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3_1a4061a488824452b8b51a0c58e562cfaa" kindref="member">Nef_polyhedron_3::Halfedge_const_handle</ref><sp/>Halfedge_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3_1a002252714b0d2c87348b007feaa2db90" kindref="member">Nef_polyhedron_3::Halffacet_const_handle</ref><sp/>Halffacet_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3_1a700d159310b26ff96ef73382a0acd69c" kindref="member">Nef_polyhedron_3::Volume_const_handle</ref><sp/>Volume_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Nef__polyhedron__3_1a16441deda6df88164afc12cc04cddd71" kindref="member">Nef_polyhedron_3::Object_handle</ref><sp/>Object_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Nef_polyhedron_3<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cin<sp/>&gt;&gt;<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_const_handle<sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_const_handle<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halffacet_const_handle<sp/>f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Volume_const_handle<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Object_handle<sp/>o<sp/>=<sp/>N.locate(Point_3(0,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(CGAL::assign(v,o))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Locating<sp/>vertex&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(CGAL::assign(e,o))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Locating<sp/>edge&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(CGAL::assign(f,o))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Locating<sp/>facet&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(CGAL::assign(c,o))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Locating<sp/>volume&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//other<sp/>cases<sp/>can<sp/>not<sp/>occur</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
