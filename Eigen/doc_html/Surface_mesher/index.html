<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Surface_mesher/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 3D Surface Mesh Generation: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 3D Surface Mesh Generation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_3D_Surface_Mesh_Generation"></a> </p><dl class="section author"><dt>Authors</dt><dd>Laurent Rineau and Mariette Yvinec</dd></dl>
<p> </p><div id="autotoc" class="toc"></div> 
<div class="image">
<img src="segmented_head.png" alt="segmented_head.png" />
</div>
 <h1><a class="anchor" id="SurfaceMesher_section_intro"></a>
Introduction</h1>
<p>This package provides a function template to compute a triangular mesh approximating a surface.</p>
<p>The meshing algorithm requires to know the surface to be meshed only through an oracle able to tell whether a given segment, line or ray intersects the surface or not and to compute an intersection point if any. This feature makes the package generic enough to be applied in a wide variety of situations. For instance, it can be used to mesh implicit surfaces described as the zero level set of some function. It may also be used in the field of medical imaging to mesh surfaces described as a gray level set in a three dimensional image.</p>
<p>The meshing algorithm is based on the notion of the restricted Delaunay triangulation. Basically the algorithm computes a set of sample points on the surface, and extract an interpolating surface mesh from the three dimensional triangulation of these sample points. Points are iteratively added to the sample, as in a Delaunay refinement process, until some size and shape criteria on the elements of the surface mesh are satisfied.</p>
<p>The size and shape criteria guide the behavior of the refinement process and control its termination. They also condition the size and shape of the elements in the final mesh. Naturally, those criteria can be customized to satisfy the user needs. The Surface mesh generation package offers a set of standard criteria that can be scaled through three numerical values. Also the user can also plug in its own set of refinement criteria.</p>
<p>There is no restriction on the topology and number of components of the surface provided that the oracle (or the user) is able to provide one initial sample point on each connected component. If the surface is smooth enough, and if the size criteria are small enough, the algorithm guarantees that the output mesh is homeomorphic to the surface, and is within a small bounded distance (Hausdorff or even Frechet distance) from the surface. The algorithm can also be used for non smooth surfaces but then there is no guarantee.</p>
<h1><a class="anchor" id="SurfaceMesher_section_interface"></a>
The Surface Mesh Generator Interface for Smooth Surfaces</h1>
<p>The meshing process is launched through a call to a function template. There are two overloaded versions of the meshing function whose signatures are the following:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class </span>SurfaceMeshC2T3,</div><div class="line">          <span class="keyword">class </span>Surface,</div><div class="line">          <span class="keyword">class </span>FacetsCriteria,</div><div class="line">          <span class="keyword">class </span>Tag &gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgSurfaceMesher3FunctionsMakeMesh.html#ga7e188adef5bfadaafd08db82c8a25dc1">make_surface_mesh</a>(SurfaceMeshC2T3&amp; c2t3,</div><div class="line">                       Surface surface,</div><div class="line">                       FacetsCriteria criteria,</div><div class="line">                       Tag);</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class </span>SurfaceMeshC2T3,</div><div class="line">          <span class="keyword">class </span>SurfaceMeshTraits,</div><div class="line">          <span class="keyword">class </span>FacetsCriteria,</div><div class="line">          <span class="keyword">class </span>Tag &gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgSurfaceMesher3FunctionsMakeMesh.html#ga7e188adef5bfadaafd08db82c8a25dc1">make_surface_mesh</a>(SurfaceMeshC2T3&amp; c2t3,</div><div class="line">                       SurfaceMeshTraits::Surface_3 surface,</div><div class="line">                       SurfaceMeshTraits traits,</div><div class="line">                       FacetsCriteria criteria,</div><div class="line">                       Tag );</div></div><!-- fragment --><p>The template parameter <code>SurfaceMeshC2T3</code> stands for a data structure type that is used to store the surface mesh. This type is required to be a model of the concept <code><a class="el" href="classSurfaceMeshComplex__2InTriangulation__3.html" title="The concept SurfaceMeshComplex_2InTriangulation_3 describes a data structure designed to represent a ...">SurfaceMeshComplex_2InTriangulation_3</a></code>. Such a data structure has a pointer to a three dimensional triangulation and encodes the surface mesh as a subset of facets in this triangulation. An argument of type <code>SurfaceMeshC2T3</code> is passed by reference to the meshing function. This argument holds the output mesh at the end of the process.</p>
<p>The template parameter <code>Surface</code> stands for the surface type. This type has to be a model of the concept <code><a class="el" href="classSurface__3.html" title="The concept Surface_3 describes the types of surfaces to be meshed. The surface types are required to...">Surface_3</a></code>.</p>
<p>The knowledge on the surface, required by the surface mesh generator is encapsulated in a traits class. Actually, the mesh generator accesses the surface to be meshed through this traits class only. The traits class is required to be a model of the concept <code><a class="el" href="classSurfaceMeshTraits__3.html" title="The concept SurfaceMeshTraits_3 describes the knowledge that is required on the surface to be meshed...">SurfaceMeshTraits_3</a></code>. The difference between the two overloaded versions of <code><a class="el" href="group__PkgSurfaceMesher3FunctionsMakeMesh.html#ga7e188adef5bfadaafd08db82c8a25dc1" title="In the first overloaded version of of make_surface_mesh(), the surface type is given as template para...">make_surface_mesh()</a></code> can be explained as follows </p><ul>
<li>
In the first overloaded version of <code><a class="el" href="group__PkgSurfaceMesher3FunctionsMakeMesh.html#ga7e188adef5bfadaafd08db82c8a25dc1" title="In the first overloaded version of of make_surface_mesh(), the surface type is given as template para...">make_surface_mesh()</a></code>, the surface type is given as template parameter (<code>Surface</code>) and the <code>surface</code> to be meshed is passed as parameter to the mesh generator. In that case the surface mesh generator traits type is automatically generated from the surface type by an auxiliary class called the <code><a class="el" href="structCGAL_1_1Surface__mesh__traits__generator__3.html" title="The class Surface_mesh_traits_generator_3 provides a type type, that is a model of the concept Surfac...">Surface_mesh_traits_generator_3</a></code>. </li>
<li>
In the second overloaded version of <code><a class="el" href="group__PkgSurfaceMesher3FunctionsMakeMesh.html#ga7e188adef5bfadaafd08db82c8a25dc1" title="In the first overloaded version of of make_surface_mesh(), the surface type is given as template para...">make_surface_mesh()</a></code>, the surface mesh generator traits type is provided by the template parameter <code><a class="el" href="classSurfaceMeshTraits__3.html" title="The concept SurfaceMeshTraits_3 describes the knowledge that is required on the surface to be meshed...">SurfaceMeshTraits_3</a></code> and the surface type is obtained from this traits type. Both a surface and a traits are passed to the mesh generator as arguments. </li>
</ul>
<p>The first overloaded version can be used whenever the surface type either provides a nested type <code>Surface::Surface_mesher_traits_3</code> that is a model of <code><a class="el" href="classSurfaceMeshTraits__3.html" title="The concept SurfaceMeshTraits_3 describes the knowledge that is required on the surface to be meshed...">SurfaceMeshTraits_3</a></code> or is a surface type for which a specialization of the traits generator <code><a class="el" href="structCGAL_1_1Surface__mesh__traits__generator__3.html" title="The class Surface_mesh_traits_generator_3 provides a type type, that is a model of the concept Surfac...">Surface_mesh_traits_generator_3</a>&lt;Surface&gt;</code> is provided. Currently, the library provides partial specializations of <code><a class="el" href="structCGAL_1_1Surface__mesh__traits__generator__3.html" title="The class Surface_mesh_traits_generator_3 provides a type type, that is a model of the concept Surfac...">Surface_mesh_traits_generator_3</a>&lt;Surface&gt;</code> for implicit surfaces (<code><a class="el" href="classCGAL_1_1Implicit__surface__3.html" title="The class Implicit_surface_3 implements a surface described as the zero level set of a function ...">Implicit_surface_3</a>&lt;Traits, Function&gt;</code>) and gray level images (<code><a class="el" href="classCGAL_1_1Gray__level__image__3.html" title="A 3D gray image is a tri-dimensional array that associates a scalar value to each triple of integer  ...">Gray_level_image_3</a>&lt;FT, Point&gt;</code>).</p>
<p>The parameter <code>criteria</code> handles the description of the size and shape criteria driving the meshing process. The template parameter <code>FacetsCriteria</code> has to be instantiated by a model of the concept <code><a class="el" href="classSurfaceMeshFacetsCriteria__3.html" title="The Delaunay refinement process involved in the function template CGAL::make_surface_mesh() is guided...">SurfaceMeshFacetsCriteria_3</a></code>.</p>
<p>The parameter <code>Tag</code> is a tag whose type influences the behavior of the meshing algorithm. For instance, this parameter can be used to enforce the manifold property of the output mesh while avoiding an over-refinement of the mesh. Further details on this subject are given in Section <a class="el" href="index.html#SurfaceMesher_section_criteria">Meshing Criteria, Guarantees and Variations</a>.</p>
<p>A call to <a class="el" href="group__PkgSurfaceMesher3FunctionsMakeMesh.html#ga7e188adef5bfadaafd08db82c8a25dc1"><code>make_surface_mesh(c2t3,surface, criteria, tag)</code> </a> launches the meshing process with an initial set of points which is the union of two subsets: the set of vertices in the initial triangulation pointed to by <code>c2t3</code>, and a set of points provided by the <code>Construct_initial_points()</code> functor of the traits class. This initial set of points is required to include at least one point on each connected component of the surface to be meshed.</p>
<h1><a class="anchor" id="Surface_mesherExamples"></a>
Examples</h1>
<p><a class="anchor" id="SurfaceMesher_section_example"></a> </p>
<h2><a class="anchor" id="Surface_mesherMeshingIsosurfacesDefinedby"></a>
Meshing Isosurfaces Defined by Implicit Functions</h2>
<p>The first code example meshes a sphere given as the zero level set of a function \( \mathbb{R}^3 \longrightarrow \mathbb{R}\). More precisely, the surface to be meshed is created by the constructor of the class <code><a class="el" href="classCGAL_1_1Implicit__surface__3.html" title="The class Implicit_surface_3 implements a surface described as the zero level set of a function ...">Implicit_surface_3</a>&lt;Traits, Function&gt;</code> from a pointer to the function (<code>sphere_function</code>) and a bounding sphere.</p>
<p>The default meshing criteria are determined by three numerical values: </p><ul>
<li>
<code>angular_bound</code> is a lower bound in degrees for the angles of mesh facets. </li>
<li>
<code>radius_bound</code> is an upper bound on the radii of surface Delaunay balls. A surface Delaunay ball is a ball circumscribing a mesh facet and centered on the surface. </li>
<li>
<code>distance_bound</code> is an upper bound for the distance between the circumcenter of a mesh facet and the center of a surface Delaunay ball of this facet. </li>
</ul>
<p>Given this surface type, the surface mesh generator will use an automatically generated traits class.</p>
<p>The resulting mesh is shown in <a class="el" href="index.html#fig__figureSurface_mesherspheresurface">Figure 53.1</a>.</p>
<p><a class="anchor" id="fig__figureSurface_mesherspheresurface"></a></p><div class="image">
<img src="sphere-surface.png" alt="sphere-surface.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figureSurface_mesherspheresurface">Figure 53.1</a> Surface mesh of a sphere  </div>  <br />

<p><br />
<b>File</b> <a class="el" href="Surface_mesher_2mesh_an_implicit_function_8cpp-example.html">Surface_mesher/mesh_an_implicit_function.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_default_triangulation_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Complex_2_in_triangulation_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/make_surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_surface_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// default triangulation for Surface_mesher</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh__default__triangulation__3.html">CGAL::Surface_mesh_default_triangulation_3</a> Tr;</div><div class="line"></div><div class="line"><span class="comment">// c2t3</span></div><div class="line"><span class="keyword">typedef</span> CGAL::Complex_2_in_triangulation_3&lt;Tr&gt; C2t3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Tr::Geom_traits GT;</div><div class="line"><span class="keyword">typedef</span> GT::Sphere_3 Sphere_3;</div><div class="line"><span class="keyword">typedef</span> GT::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> GT::FT FT;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> FT (*Function)(Point_3);</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Implicit__surface__3.html">CGAL::Implicit_surface_3&lt;GT, Function&gt;</a> <a class="code" href="classSurface__3.html">Surface_3</a>;</div><div class="line"></div><div class="line">FT sphere_function (Point_3 p) {</div><div class="line">  <span class="keyword">const</span> FT x2=p.x()*p.x(), y2=p.y()*p.y(), z2=p.z()*p.z();</div><div class="line">  <span class="keywordflow">return</span> x2+y2+z2-1;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Tr tr;            <span class="comment">// 3D-Delaunay triangulation</span></div><div class="line">  C2t3 c2t3 (tr);   <span class="comment">// 2D-complex in 3D-Delaunay triangulation</span></div><div class="line"></div><div class="line">  <span class="comment">// defining the surface</span></div><div class="line">  <a class="code" href="classSurface__3.html">Surface_3</a> surface(sphere_function,             <span class="comment">// pointer to function</span></div><div class="line">                    Sphere_3(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>, 2.)); <span class="comment">// bounding sphere</span></div><div class="line">  <span class="comment">// Note that "2." above is the *squared* radius of the bounding sphere!</span></div><div class="line"></div><div class="line">  <span class="comment">// defining meshing criteria</span></div><div class="line">  <a class="code" href="classCGAL_1_1Surface__mesh__default__criteria__3.html">CGAL::Surface_mesh_default_criteria_3&lt;Tr&gt;</a> criteria(30.,  <span class="comment">// angular bound</span></div><div class="line">                                                     0.1,  <span class="comment">// radius bound</span></div><div class="line">                                                     0.1); <span class="comment">// distance bound</span></div><div class="line">  <span class="comment">// meshing surface</span></div><div class="line">  <a class="code" href="group__PkgSurfaceMesher3FunctionsMakeMesh.html#ga7e188adef5bfadaafd08db82c8a25dc1">CGAL::make_surface_mesh</a>(c2t3, surface, criteria, <a class="code" href="structCGAL_1_1Non__manifold__tag.html">CGAL::Non_manifold_tag</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Final number of points: "</span> &lt;&lt; tr.number_of_vertices() &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Surface_mesherMeshingIsosurfacesDefinedas"></a>
Meshing Isosurfaces Defined as Gray Levels in 3D Images</h2>
<p>In this example the surface to be meshed is defined as the locus of points with a given gray level in a 3D image. The code is quite similar to the previous example.</p>
<p>The main difference with the previous code is that the function used to define the surface is an object of type <code><a class="el" href="classCGAL_1_1Gray__level__image__3.html" title="A 3D gray image is a tri-dimensional array that associates a scalar value to each triple of integer  ...">Gray_level_image_3</a></code> created from an image file and a numerical value that is the gray value of the level one wishes to mesh.</p>
<p>Note that surface, which is still an object of type <code><a class="el" href="classCGAL_1_1Implicit__surface__3.html" title="The class Implicit_surface_3 implements a surface described as the zero level set of a function ...">Implicit_surface_3</a></code> is now, defined by three parameters that are the function, the bounding sphere and a numerical value called <em>the precision</em>. This precision, whose value is relative to the bounding sphere radius, is used in the intersection computation. This parameter has a default which was used in the previous example. Also note that the center of the bounding sphere is required to be internal a point where the function has a negative value.</p>
<p>The chosen iso-value of this 3D image corresponds to a head skull. The resulting mesh is shown in <a class="el" href="index.html#fig__figureSurface_mesherskull">Figure 53.2</a>.</p>
<p><a class="anchor" id="fig__figureSurface_mesherskull"></a></p><div class="image">
<img src="skull-surface.png" alt="skull-surface.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figureSurface_mesherskull">Figure 53.2</a> Surface mesh of an iso-contour extracted from a gray level 3D image  </div>  <br />

<p><br />
<b>File</b> <a class="el" href="Surface_mesher_2mesh_a_3d_gray_image_8cpp-example.html">Surface_mesher/mesh_a_3d_gray_image.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_default_triangulation_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_default_criteria_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Complex_2_in_triangulation_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Complex_2_in_triangulation_3_file_writer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/make_surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Gray_level_image_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_surface_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// default triangulation for Surface_mesher</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh__default__triangulation__3.html">CGAL::Surface_mesh_default_triangulation_3</a> Tr;</div><div class="line"></div><div class="line"><span class="comment">// c2t3</span></div><div class="line"><span class="keyword">typedef</span> CGAL::Complex_2_in_triangulation_3&lt;Tr&gt; C2t3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Tr::Geom_traits GT;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Gray__level__image__3.html">CGAL::Gray_level_image_3&lt;GT::FT, GT::Point_3&gt;</a> Gray_level_image;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Implicit__surface__3.html">CGAL::Implicit_surface_3&lt;GT, Gray_level_image&gt;</a> <a class="code" href="classSurface__3.html">Surface_3</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Tr tr;            <span class="comment">// 3D-Delaunay triangulation</span></div><div class="line">  C2t3 c2t3 (tr);   <span class="comment">// 2D-complex in 3D-Delaunay triangulation</span></div><div class="line"></div><div class="line">  <span class="comment">// the 'function' is a 3D gray level image</span></div><div class="line">  Gray_level_image image(<span class="stringliteral">"data/skull_2.9.inr"</span>, 2.9f);</div><div class="line"></div><div class="line">  <span class="comment">// Carefully choosen bounding sphere: the center must be inside the</span></div><div class="line">  <span class="comment">// surface defined by 'image' and the radius must be high enough so that</span></div><div class="line">  <span class="comment">// the sphere actually bounds the whole image.</span></div><div class="line">  GT::Point_3 bounding_sphere_center(122., 102., 117.);</div><div class="line">  GT::FT bounding_sphere_squared_radius = 200.*200.*2.;</div><div class="line">  GT::Sphere_3 bounding_sphere(bounding_sphere_center,</div><div class="line">                                   bounding_sphere_squared_radius);</div><div class="line"></div><div class="line">  <span class="comment">// definition of the surface, with 10^-5 as relative precision</span></div><div class="line">  Surface_3 surface(image, bounding_sphere, 1e-5);</div><div class="line"></div><div class="line">  <span class="comment">// defining meshing criteria</span></div><div class="line">  <a class="code" href="classCGAL_1_1Surface__mesh__default__criteria__3.html">CGAL::Surface_mesh_default_criteria_3&lt;Tr&gt;</a> criteria(30.,</div><div class="line">                                                     5.,</div><div class="line">                                                     5.);</div><div class="line"></div><div class="line">  <span class="comment">// meshing surface, with the "manifold without boundary" algorithm</span></div><div class="line">  <a class="code" href="group__PkgSurfaceMesher3FunctionsMakeMesh.html#ga7e188adef5bfadaafd08db82c8a25dc1">CGAL::make_surface_mesh</a>(c2t3, surface, criteria, <a class="code" href="structCGAL_1_1Manifold__tag.html">CGAL::Manifold_tag</a>());</div><div class="line">  std::ofstream out(<span class="stringliteral">"out.off"</span>);</div><div class="line">  <a class="code" href="group__PkgSurfaceMesher3FunctionsIO.html#ga7718d4e2047939882540d89fb5f28934">CGAL::output_surface_facets_to_off</a> (out, c2t3);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Final number of points: "</span> &lt;&lt; tr.number_of_vertices() &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="SurfaceMesher_section_criteria"></a>
Meshing Criteria, Guarantees and Variations</h1>
<p><a class="anchor" id="SurfaceMesher_section_variations"></a> The guarantees on the output mesh depend on the mesh criteria. Theoretical guarantees are given in <a class="el" href="citelist.html#CITEREF_cgal:bo-pgsms-05">[1]</a>. First, the meshing algorithm is proved to terminate if the lower bound on facets angles is not bigger than <code>30</code> degrees. Furthermore, the output mesh is guaranteed to be homeomorphic to the surface, and there is a guaranteed bound on the distance (Hausdorff and even Frechet distance) between the mesh and the surface if the radius bound is everywhere smaller than \( \epsilon\) times the local feature size. Here \( \epsilon\) is a constant that has to be less than <code>0.16</code>, and the local feature size \( \mathrm{lfs}(x)\) is defined on each point \( x\) of the surface as the distance from \( x\) to the medial axis. Note that the radius bound need not be uniform, although it is a uniform bound in the default criteria.</p>
<p>Naturally, such a theoretical guarantee can be only achieved for smooth surfaces that have a finite, non zero reach value. (The reach of a surface is the minimum value of local feature size on this surface).</p>
<p>The value of the local feature size on any point of the surface or its minimum on the surface it usually unknown although it can sometimes be guessed. Also it happens frequently that setting the meshing criteria so as to fulfill the theoretical conditions yields an over refined mesh. On the other hand, when the size criteria are relaxed, no homeomorphism with the input surface is guaranteed, and the output mesh is not even guaranteed to be manifold. To remedy this problem and give a more flexible meshing algorithm, the function template <code><a class="el" href="group__PkgSurfaceMesher3FunctionsMakeMesh.html#ga7e188adef5bfadaafd08db82c8a25dc1" title="In the first overloaded version of of make_surface_mesh(), the surface type is given as template para...">make_surface_mesh()</a></code> has a tag template parameter allowing to slightly change the behavior of the refinement process. This feature allows, for instance, to run the meshing algorithm with a relaxed size criteria, more coherent with the size of the mesh expected by the user, and still have a guarantee that the output mesh forms a manifold surface. The function <code><a class="el" href="group__PkgSurfaceMesher3FunctionsMakeMesh.html#ga7e188adef5bfadaafd08db82c8a25dc1" title="In the first overloaded version of of make_surface_mesh(), the surface type is given as template para...">make_surface_mesh()</a></code> has specialized versions for the following tag types:</p>
<p><code><a class="el" href="structCGAL_1_1Manifold__tag.html" title="The class Manifold_tag is a tag class used to monitor the surface meshing algorithm. ">Manifold_tag</a></code>: the output mesh is guaranteed to be a manifold surface without boundary.</p>
<p><code><a class="el" href="structCGAL_1_1Manifold__with__boundary__tag.html" title="The class Manifold_with_boundary_tag is a tag class used to monitor the surface meshing algorithm...">Manifold_with_boundary_tag</a></code>: the output mesh is guaranteed to be manifold but may have boundaries.</p>
<p><code><a class="el" href="structCGAL_1_1Non__manifold__tag.html" title="The class Non_manifold_tag is a tag class used to monitor the surface meshing algorithm. ">Non_manifold_tag</a></code>: the algorithm relies on the given criteria and guarantees nothing else.</p>
<h1><a class="anchor" id="Surface_mesherOutput"></a>
Output</h1>
<p>This <span style="font-variant: small-caps;">CGAL</span> component also provides functions to write the reconstructed surface mesh to the Object File Format (OFF) <a class="el" href="citelist.html#CITEREF_cgal:p-gmgv16-96">[2]</a> and to convert it to a <code>FaceGraph</code> (when it is manifold):</p>
<ul>
<li><code><a class="el" href="group__PkgSurfaceMesher3FunctionsIO.html#ga7718d4e2047939882540d89fb5f28934" title="writes a manifold or non-manifold surface reconstructed by make_surface_mesh() in the OFF file format...">output_surface_facets_to_off()</a></code></li>
<li><code><a class="el" href="namespaceCGAL.html#ab2fbf4e1a4cf30fa19304138461623e7">output_surface_facets_to_polyhedron()</a></code></li>
<li><code><a class="el" href="group__PkgSurfaceMesher3FunctionsIO.html#ga39a105bd1817a9200ec5df208888e8aa" title="converts a manifold surface reconstructed by make_surface_mesh() to a TriangleMesh. ">facets_in_complex_2_to_triangle_mesh()</a></code></li>
</ul>
<h1><a class="anchor" id="Surface_mesherUndocumented"></a>
Undocumented Features Available in Demos</h1>
<p>The Polyhedron demo has a feature that allows to remesh a polyhedral surface, using the 3D Surface Mesh Generator. That has been implemented as a special model of <code><a class="el" href="classSurfaceMeshTraits__3.html" title="The concept SurfaceMeshTraits_3 describes the knowledge that is required on the surface to be meshed...">SurfaceMeshTraits_3</a></code>, for polyhedra. That traits class is not yet documented because its interface and code have not yet been stabilized.</p>
<p>The Surface Mesh Generator demo allows to mesh not only gray level images, but also segmented images, when voxels are labelled with a domain index. Such images are for example the result of a segmentation of 3D medical images.</p>
<h1><a class="anchor" id="Surface_mesherDesign"></a>
Design and Implementation History</h1>
<p>The algorithm implemented in this package is mainly based on the work of Jean-Daniel Boissonnat and Steve Oudot <a class="el" href="citelist.html#CITEREF_cgal:bo-pgsms-05">[1]</a>. Steve Oudot implemented a first working prototype of the algorithm during his PhD thesis.</p>
<p>The meshing algorithm is implemented using the design of mesher levels described in <a class="el" href="citelist.html#CITEREF_cgal:ry-gsddrm-06">[3]</a>.</p>
<p>David Rey, Steve Oudot and Andreas Fabri have participated in the development of this package. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:02 for CGAL 4.13 - 3D Surface Mesh Generation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
