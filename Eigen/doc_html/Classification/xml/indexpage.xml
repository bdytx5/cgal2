<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Classification"/> <simplesect kind="authors"><para>Simon Giraudot, Florent Lafarge</para></simplesect>
This component implements the algorithm described in <ref refid="citelist_1CITEREF_cgal:lm-clscm-12" kindref="member">[4]</ref> (section 2), generalized to handle different types of data, multiple features and multiple labels. It classifies a data set into a user-defined set of labels, such as <emphasis>ground</emphasis>, <emphasis>vegetation</emphasis> and <emphasis>buildings</emphasis>. A flexible API is provided so that users can classify any type of data which they can index and for which they can compute relevant features, compute their own local features on the input data set and define their own labels.</para><para><simplesect kind="note"><para>This component requires C++11 and depends on the Boost libraries <ulink url="http://www.boost.org/libs/serialization">Serialization</ulink> and <ulink url="http://www.boost.org/libs/iostreams">IO Streams</ulink> (compiled with the GZIP dependency).</para></simplesect>
</para><sect1 id="index_1Classification_Organization">
<title>Package Organization</title>
<para>Classification of data sets is achieved as follows (see Figure <ref refid="index_1fig__Classification_organization_fig" kindref="member">fig__Classification_organization_fig</ref>):</para><para><itemizedlist>
<listitem><para>some analysis is performed on the input data set;</para></listitem><listitem><para>features are computed based on this analysis;</para></listitem><listitem><para>a set of labels (for example: <emphasis>ground</emphasis>, <emphasis>building</emphasis>, <emphasis>vegetation</emphasis>) is defined by the user;</para></listitem><listitem><para>a classifier is defined and trained: from the set of values taken by the features at an input item, it measures the likelihood of this item to belong to one label or another;</para></listitem><listitem><para>classification is computed itemwise using the classifier;</para></listitem><listitem><para>additional regularization can be used by smoothing either locally or globally through a <emphasis>Graph Cut</emphasis> <ref refid="citelist_1CITEREF_Boykov2001FastApproximate" kindref="member">[1]</ref> approach.</para></listitem></itemizedlist>
</para><para><anchor id="index_1fig__Classification_organization_fig"/><image type="html" name="organization.svg"></image>
 <image type="latex" name="organization.svg" width="15cm"></image>
  <ref refid="index_1fig__Classification_organization_fig" kindref="member">fig__Classification_organization_fig</ref> Organization of the package.  <linebreak/>
</para><para>This package is designed to be easily extended by users: more specifically, features and labels can be defined by users to handle any data they need to classify.</para><para>Currently, CGAL provides data structures to handle classification of point sets, surface meshes and clusters.</para></sect1>
<sect1 id="index_1Classification_structures">
<title>Common Data Structures</title>
<sect2 id="index_1Classification_labels">
<title>Label Set</title>
<para>A label represents how an item should be classified, for example: <emphasis>vegetation</emphasis>, <emphasis>building</emphasis>, <emphasis>road</emphasis>, etc. In CGAL, a label has a name and is simply identified by a <ref refid="classCGAL_1_1Classification_1_1Label__handle" kindref="compound">Label_handle</ref>. Note that names are not used for identification: two labels in the same set can have the same name (but not the same handle).</para><para>The following code snippet shows how to add labels to the classification object:</para><para><programlisting><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_set<sp/>labels;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>ground<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;ground&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>vegetation<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;vegetation&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>roof<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;roof&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting> </para></sect2>
<sect2 id="index_1Classification_features">
<title>Feature Set</title>
<para>Features are defined as scalar fields that associate each input item with a specific value. Note that in order to limit memory consumption, we use the type <computeroutput>float</computeroutput> for these scalar values (as well as for every floating point value in this package). A feature has a name and is identified by a <ref refid="classCGAL_1_1Classification_1_1Feature__handle" kindref="compound">Feature_handle</ref>.</para><para>The computation of features and their addition to the feature set is done in a single step using the <ref refid="classCGAL_1_1Classification_1_1Feature__set_1a2d7dc5beaa908425dcf000ed441aa4bf" kindref="member">Feature_set::add&lt;Feature&gt;()</ref> method. If CGAL was linked with <ref refid="installation_1thirdpartyTBB" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Intel TBB</ref>, features can be computed in parallel (see below).</para><para>CGAL provides some predefined features (see <ref refid="index_1Classification_point_sets" kindref="member">Point Set Classification</ref> for example). In the following code snippet, a subset of these predefined features are instantiated (in parallel if <ref refid="installation_1thirdpartyTBB" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Intel TBB</ref> is available). Note that all the predefined features can also be automatically generated in multiple scales (see <ref refid="index_1Classification_point_sets" kindref="member">Point Set Classification</ref> for example).</para><para><programlisting><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>radius_neighbors<sp/>=<sp/>1.7f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>radius_dtm<sp/>=<sp/>15.0f;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Computing<sp/>features&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_handle<sp/>distance_to_plane<sp/>=<sp/>features.add&lt;Distance_to_plane&gt;<sp/>(pts,<sp/>Pmap(),<sp/>eigen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_handle<sp/>dispersion<sp/>=<sp/>features.add&lt;Dispersion&gt;<sp/>(pts,<sp/>Pmap(),<sp/>grid,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>radius_neighbors);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_handle<sp/>elevation<sp/>=<sp/>features.add&lt;Elevation&gt;<sp/>(pts,<sp/>Pmap(),<sp/>grid,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>radius_dtm);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
</programlisting> Users may want to define their own features, especially if the input data set comes with additional properties that were not anticipated by CGAL. A user-defined feature must inherit from <ref refid="classCGAL_1_1Classification_1_1Feature__base" kindref="compound">Feature_base</ref> and provide a method <ref refid="classCGAL_1_1Classification_1_1Feature__base_1a601e16c0026bd33f28fc8bfd68b30461" kindref="member">value()</ref> that associates a scalar value to each input item.</para><para>The following example shows how to define a feature that discriminates points that lie inside a 2D box from the others:</para><para><programlisting><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>User-defined<sp/>feature<sp/>that<sp/>identifies<sp/>a<sp/>specific<sp/>area<sp/>of<sp/>the<sp/>3D</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>space.<sp/>This<sp/>feature<sp/>takes<sp/>value<sp/>1<sp/>for<sp/>points<sp/>that<sp/>lie<sp/>inside<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>area<sp/>and<sp/>0<sp/>for<sp/>the<sp/>others.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_feature<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Classification_1_1Feature__base" kindref="compound">CGAL::Classification::Feature_base</ref></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_range&amp;<sp/>range;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>xmin,<sp/>xmax,<sp/>ymin,<sp/>ymax;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_feature<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_range&amp;<sp/>range,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>xmin,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>xmax,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ymin,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ymax)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>range<sp/>(range),<sp/>xmin(xmin),<sp/>xmax(xmax),<sp/>ymin(ymin),<sp/>ymax(ymax)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>this-&gt;set_name<sp/>(</highlight><highlight class="stringliteral">&quot;my_feature&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>value<sp/>(std::size_t<sp/>pt_index)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(xmin<sp/>&lt;<sp/>range[pt_index].x()<sp/>&amp;&amp;<sp/>range[pt_index].x()<sp/>&lt;<sp/>xmax<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ymin<sp/>&lt;<sp/>range[pt_index].y()<sp/>&amp;&amp;<sp/>range[pt_index].y()<sp/>&lt;<sp/>ymax)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting> This feature can then be instantiated from the feature set the same way as the others:</para><para><programlisting><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Computing<sp/>features&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Feature<sp/>that<sp/>identifies<sp/>points<sp/>whose<sp/>x<sp/>coordinate<sp/>is<sp/>between<sp/>-20</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>20<sp/>and<sp/>whose<sp/>y<sp/>coordinate<sp/>is<sp/>between<sp/>-15<sp/>and<sp/>15</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_handle<sp/>my_feature<sp/>=<sp/>features.add&lt;My_feature&gt;<sp/>(pts,<sp/>-20.,<sp/>20.,<sp/>-15.,<sp/>15.);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
</programlisting> </para></sect2>
</sect1>
<sect1 id="index_1Classification_structures_specialized">
<title>Specialized Data Structures</title>
<para>Classification is based on the computation of local features. These features can take advantage of shared data structures that are precomputed and stored separately. Both these features and the underlying data structures depend on the type of data that needs to be classified. CGAL provides data structures to classify point sets, surface meshes and clusters.</para><sect2 id="index_1Classification_point_sets">
<title>Point Set Classification</title>
<para>CGAL provides the following structures:</para><para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Classification_1_1Point__set__neighborhood" kindref="compound">Point_set_neighborhood</ref> stores spatial searching structures and provides adapted queries for points;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Local__eigen__analysis" kindref="compound">Local_eigen_analysis</ref> precomputes covariance matrices on local neighborhoods of points and stores the associated eigenvectors and eigenvalues;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Planimetric__grid" kindref="compound">Planimetric_grid</ref> is a 2D grid used for digital terrain modeling.</para></listitem></itemizedlist>
</para><para>Most of these data structures depend on a scale parameter. CGAL provides a method to estimate the average spacing based on a number of neighbors (see <ref refid="group__PkgPointSetProcessingAlgorithms_1gabb9a90622271869b3f2393314075fa0e" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::compute_average_spacing()</ref>), which usually provides satisfying results in the absence of noise. In the presence of noise, <ref refid="group__PkgPointSetProcessingAlgorithms_1ga8b8e7e8e694d746cfa0bca11f87fb527" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::estimate_global_range_scale()</ref> provides an estimation of the smallest scale such that the point set has the local dimension of a surface (this method is both robust to noise and outliers, see <ref refid="index_1Classification_sowf_result" kindref="member">Result</ref>).</para><para>The eigen analysis can be used to estimate normals. Note however that this analysis (based on Principal Component Analysis) might not be robust to a high level of noise. CGAL also provides more robust normal estimation functions (see for example <ref refid="group__PkgPointSetProcessingAlgorithms_1ga0cd0f87de690d4edf82740e856efa491" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::jet_estimate_normals()</ref>).</para><para>The following code snippet shows how to instantiate such data structures from an input PLY point set (the <ref refid="index_1Classification_example_general" kindref="member">full example</ref> is given at the end of the manual).</para><para><programlisting><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename<sp/>(argc<sp/>&gt;<sp/>1<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/b9.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in<sp/>(filename.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>input&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>!(<ref refid="group__PkgPointSetProcessingIOPly_1ga1cff0be3f76b7e5f70dbd4320b06394a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::read_ply_points</ref><sp/>(in,<sp/>std::back_inserter<sp/>(pts))))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>grid_resolution<sp/>=<sp/>0.34f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_neighbors<sp/>=<sp/>6;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Computing<sp/>useful<sp/>structures&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Iso_cuboid_3<sp/>bbox<sp/>=<sp/>CGAL::bounding_box<sp/>(pts.begin(),<sp/>pts.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Planimetric_grid<sp/>grid<sp/>(pts,<sp/>Pmap(),<sp/>bbox,<sp/>grid_resolution);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighborhood<sp/>neighborhood<sp/>(pts,<sp/>Pmap());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Local_eigen_analysis<sp/>eigen</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>=<sp/>Local_eigen_analysis::create_from_point_set</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(pts,<sp/>Pmap(),<sp/>neighborhood.k_neighbor_query(number_of_neighbors));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting> CGAL provides some predefined features:</para><para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Distance__to__plane" kindref="compound">Distance_to_plane</ref> measures how far away a point is from a locally estimated plane;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue" kindref="compound">Eigenvalue</ref> measures one of the three local eigenvalues;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Elevation" kindref="compound">Elevation</ref> computes the local distance to an estimation of the ground;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Vertical__dispersion" kindref="compound">Vertical_dispersion</ref> computes how noisy the point set is on a local Z-cylinder;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Verticality" kindref="compound">Verticality</ref> compares the local normal vector to the vertical vector.</para></listitem></itemizedlist>
</para><para>These features are designed for point sets but can easily be used with surface meshes as well (see <ref refid="index_1Classification_meshes" kindref="member">Mesh Classification</ref>). For more details about how these different features can help to identify one label or the other, please refer to their associated reference manual pages.</para><para>In addition, if the input data set has additional properties, these can also be used as features. For example, CGAL provides the following features:</para><para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Color__channel" kindref="compound">Color_channel</ref> uses input color information if available;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Echo__scatter" kindref="compound">Echo_scatter</ref> uses the number of returns (echo) provided by most LIDAR scanners if available;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Simple__feature" kindref="compound">Simple_feature</ref> uses any property map applicable to the input range and whose value type is castable to <computeroutput>float</computeroutput> (useful if an additional property of the input set should be used as is, for example an <computeroutput>intensity</computeroutput> measurement).</para></listitem></itemizedlist>
</para><para>Users commonly want to use all predefined features to get the best result possible. CGAL provides a class <ref refid="classCGAL_1_1Classification_1_1Point__set__feature__generator" kindref="compound">Point_set_feature_generator</ref> that performs the following operations:</para><para><itemizedlist>
<listitem><para>it estimates the smallest relevant scale;</para></listitem><listitem><para>it generates all needed analysis structures and provides access to them;</para></listitem><listitem><para>it generates all possible features (among all the CGAL predefined ones) based on which property maps are available (they use colors if available, etc.).</para></listitem></itemizedlist>
</para><para>Multiple scales that are sequentially larger can be used to increase the quality of the results <ref refid="citelist_1CITEREF_cgal:hws-fsso3-16" kindref="member">[3]</ref>.</para><para>Note that using this class in order to generate features is not mandatory, as features and data structures can all be handled by hand. It is mainly provided to make the specific case of point sets simpler to handle. Users can still add their own features within their feature set.</para><para>The following snippet shows how to use the point set feature generator:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>number_of_scales<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_generator<sp/>generator<sp/>(pts,<sp/>pts.point_map(),<sp/>number_of_scales);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>generator.generate_point_based_features<sp/>(features);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
</programlisting> <anchor id="index_1fig__Classification_point_set_fig"/><image type="html" name="point_set.png"></image>
 <image type="latex" name="point_set.png" width="15cm"></image>
  <ref refid="index_1fig__Classification_point_set_fig" kindref="member">fig__Classification_point_set_fig</ref> Example of point set classification (left: input, right: output). <emphasis>Ground</emphasis> is grey, <emphasis>roofs</emphasis> are orange, <emphasis>vegetation</emphasis> is green.  <linebreak/>
</para></sect2>
<sect2 id="index_1Classification_meshes">
<title>Mesh Classification</title>
<para>Classification of mesh is performed by considering the face of a mesh as an atomic element that should be assign one label or another. Some structures such as neighborhood or Eigen analysis are significantly different from their equivalent for point sets; other data structures from point sets can be directly used by viewing the mesh as a point set through the use of a property map that associates each face with a representative point.</para><para>Hereafter, a <emphasis>mesh</emphasis> refers to a model of <computeroutput><ref refid="classFaceListGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">FaceListGraph</ref></computeroutput>.</para><para>CGAL provides the following structures:</para><para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Classification_1_1Face__descriptor__to__center__of__mass__map" kindref="compound">Face_descriptor_to_center_of_mass_map</ref> is a property map that takes the face of a mesh as key type and returns the <computeroutput><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Point_3</ref></computeroutput> located at the center of mass of the face. It is useful to apply point set structures and features to surface meshes;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Face__descriptor__to__face__descriptor__with__bbox__map" kindref="compound">Face_descriptor_to_face_descriptor_with_bbox_map</ref> is a property map that takes the face of a mesh as key type and returns the same face along with its bounding box as a value type. It is useful to call <computeroutput><ref refid="group__PkgClassificationMain_1ga2a4c1b0816b81b628dc9023e104449eb" kindref="member">CGAL::Classification::classify_with_graphcut()</ref></computeroutput> which requires objects that provide a <computeroutput>bbox()</computeroutput> method (see <ref refid="index_1Classification_classification_functions" kindref="member">Classification Functions</ref>);</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Mesh__neighborhood" kindref="compound">Mesh_neighborhood</ref> provides adapted queries for surface meshes;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Local__eigen__analysis" kindref="compound">Local_eigen_analysis</ref> precomputes covariance matrices on local neighborhoods of triangles and stores the associated eigenvectors and eigenvalues (it is the same object as for point sets called with a different named constructor);</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Planimetric__grid" kindref="compound">Planimetric_grid</ref> is the 2D grid used for digital terrain modeling of point sets, it can be used with meshes through <ref refid="classCGAL_1_1Classification_1_1Face__descriptor__to__center__of__mass__map" kindref="compound">Face_descriptor_to_center_of_mass_map</ref>.</para></listitem></itemizedlist>
</para><para>The point set features can be used for mesh classification as well:</para><para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue" kindref="compound">Eigenvalue</ref> takes the <ref refid="classCGAL_1_1Classification_1_1Local__eigen__analysis" kindref="compound">Local_eigen_analysis</ref> object computed on faces as input;</para></listitem><listitem><para>the other ones are computed by considering the mesh as a point set.</para></listitem></itemizedlist>
</para><para>Similarly to <ref refid="classCGAL_1_1Classification_1_1Point__set__feature__generator" kindref="compound">Point_set_feature_generator</ref>, CGAL provides a class <ref refid="classCGAL_1_1Classification_1_1Mesh__feature__generator" kindref="compound">Mesh_feature_generator</ref> that estimates the smallest scale automatically and computes all predefined features on several scales. As for point sets, using this class in order to generate features is not mandatory, as features and data structures can all be handled by hand. It is mainly provided to make the specific case of meshes simpler to handle. Users can still add their own features within their feature set.</para><para>The following snippet shows how to use the mesh feature generator:</para><para><programlisting><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_point_map<sp/>face_point_map<sp/>(&amp;mesh);<sp/></highlight><highlight class="comment">//<sp/>Associates<sp/>each<sp/>face<sp/>to<sp/>its<sp/>center<sp/>of<sp/>mass</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>number_of_scales<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_generator<sp/>generator<sp/>(mesh,<sp/>face_point_map,<sp/>number_of_scales);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>generator.generate_point_based_features<sp/>(features);<sp/></highlight><highlight class="comment">//<sp/>Features<sp/>that<sp/>consider<sp/>the<sp/>mesh<sp/>as<sp/>a<sp/>point<sp/>set</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>generator.generate_face_based_features<sp/>(features);<sp/><sp/></highlight><highlight class="comment">//<sp/>Features<sp/>computed<sp/>directly<sp/>on<sp/>mesh<sp/>faces</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
</programlisting> The <ref refid="index_1Classification_example_mesh" kindref="member">full example</ref> is given at the end of the manual.</para><para><anchor id="index_1fig__Classification_mesh_fig"/><image type="html" name="mesh.png"></image>
 <image type="latex" name="mesh.png" width="15cm"></image>
  <ref refid="index_1fig__Classification_mesh_fig" kindref="member">fig__Classification_mesh_fig</ref> Example of mesh classification (left: input, right: output). <emphasis>Ground</emphasis> is grey, <emphasis>roofs</emphasis> are orange, <emphasis>vegetation</emphasis> is green.  <linebreak/>
</para></sect2>
<sect2 id="index_1Classification_clusters">
<title>Cluster Classification</title>
<para>Classifying clusters of items instead of raw sets of items can have several advantages:</para><para><itemizedlist>
<listitem><para>if the data set is very large, using clusters can drastically decrease the complexity and thus the need for computation time and memory;</para></listitem><listitem><para>clusters are more complex objects than raw items (isolated points or triangles of a mesh) and thus provide additional information (size of cluster, spatial consistency, etc.);</para></listitem><listitem><para>by construction, the output classification is less noisy (if all points of a facade are in the same cluster, then they are guaranteed to all be classified in the same label).</para></listitem></itemizedlist>
</para><para>For example, when dealing with urban scenes that typically contain large planar sections, it may be more efficient to first detect planes (with <computeroutput><ref refid="classCGAL_1_1Shape__detection__3_1_1Region__growing" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Region_growing</ref></computeroutput> or <computeroutput><ref refid="classCGAL_1_1Shape__detection__3_1_1Efficient__RANSAC" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Efficient_RANSAC</ref></computeroutput> for example) and then to classify each subset of points belonging to a specific plane as clusters.</para><para>CGAL provides some tools to classify clusters:</para><para><itemizedlist>
<listitem><para>the class <computeroutput><ref refid="classCGAL_1_1Classification_1_1Cluster" kindref="compound">CGAL::Classification::Cluster</ref></computeroutput> can be used to represent a cluster of items (points, for example);</para></listitem><listitem><para>the function <computeroutput><ref refid="group__PkgClassificationCluster_1ga6c0c1a27071cf5ebfac967d6847cbbf9" kindref="member">CGAL::Classification::create_clusters_from_indices()</ref></computeroutput> takes indices over items as input (for example, shape indices taken from shape detection) and generates one cluster per index.</para></listitem></itemizedlist>
</para><para>The following snippet shows how to create classification clusters from a shape detection algorithm (<ref refid="classCGAL_1_1Shape__detection__3_1_1Region__growing" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">Region Growing</ref>):</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Detecting<sp/>planes&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_growing::Parameters<sp/>parameters;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.min_points<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.epsilon<sp/>=<sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.cluster_epsilon<sp/>=<sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.normal_threshold<sp/>=<sp/>0.9;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_growing<sp/>region_growing;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.set_input<sp/>(pts,<sp/>pts.point_map(),<sp/>pts.normal_map());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.add_shape_factory&lt;Plane&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.detect<sp/>(parameters);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>region_growing.shapes().end()<sp/>-<sp/>region_growing.shapes().begin()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>planes<sp/>detected<sp/>in<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Creating<sp/>clusters&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Cluster&gt;<sp/>clusters;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgClassificationCluster_1ga6c0c1a27071cf5ebfac967d6847cbbf9" kindref="member">Classification::create_clusters_from_indices</ref><sp/>(pts,<sp/>pts.point_map(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Shape__detection__3_1_1Point__to__shape__index__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Point_to_shape_index_map&lt;SD_traits&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(pts,<sp/>region_growing.planes()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clusters);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>clusters.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>clusters<sp/>created<sp/>in<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting> The class <ref refid="classCGAL_1_1Classification_1_1Local__eigen__analysis" kindref="compound">Local_eigen_analysis</ref> can also take point clusters as input:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Local_eigen_analysis<sp/>eigen<sp/>=<sp/>Local_eigen_analysis::create_from_point_clusters<sp/>(clusters);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting> As clusters are based on simple items, users can compute cluster features based on statistics over the itemwise features:</para><para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Cluster__mean__of__feature" kindref="compound">Cluster_mean_of_feature</ref> computes, for a cluster, the mean value of an itemwise feature over the inliers of this cluster;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Cluster__variance__of__feature" kindref="compound">Cluster_variance_of_feature</ref> computes, for a cluster, the variance of an itemwise feature over the inliers of this cluster.</para></listitem></itemizedlist>
</para><para>Some additional features are provided specifically for clusters:</para><para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Cluster__size" kindref="compound">Cluster_size</ref> uses the number of items in a cluster;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Cluster__vertical__extent" kindref="compound">Cluster_vertical_extent</ref> computes the length of the smallest interval on the <computeroutput>Z</computeroutput> axis that contains all the items of a cluster;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue" kindref="compound">Eigenvalue</ref>, similarly to point sets and meshes, can use the <ref refid="classCGAL_1_1Classification_1_1Local__eigen__analysis" kindref="compound">Local_eigen_analysis</ref> object computed on clusters.</para></listitem></itemizedlist>
</para><para>The following snippet shows, from a pointwise feature set, how to generate the statistical features from a pointwise feature set (along with these latest cluster features):</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>First<sp/>compute<sp/>means<sp/>of<sp/>features</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>pointwise_features.size();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>features.add&lt;Classification::Feature::Cluster_mean_of_feature&gt;<sp/>(clusters,<sp/>pointwise_features[i]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Then<sp/>compute<sp/>variances<sp/>of<sp/>features<sp/>(and<sp/>remaining<sp/>cluster<sp/>features)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>pointwise_features.size();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>features.add&lt;Classification::Feature::Cluster_variance_of_feature&gt;<sp/>(clusters,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointwise_features[i],<sp/></highlight><highlight class="comment">//<sp/>i^th<sp/>feature</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>features[i]);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>mean<sp/>of<sp/>i^th<sp/>feature</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.add&lt;Classification::Feature::Cluster_size&gt;<sp/>(clusters);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.add&lt;Classification::Feature::Cluster_vertical_extent&gt;<sp/>(clusters);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>3;<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>features.add&lt;Classification::Feature::Eigenvalue&gt;<sp/>(clusters,<sp/>eigen,<sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)(i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
</programlisting> The <ref refid="index_1Classification_example_cluster" kindref="member">full example</ref> is given at the end of the manual.</para><para><anchor id="index_1fig__Classification_cluster_fig"/><image type="html" name="clusters.png"></image>
 <image type="latex" name="clusters.png" width="15cm"></image>
  <ref refid="index_1fig__Classification_cluster_fig" kindref="member">fig__Classification_cluster_fig</ref> Example of cluster classification mesh (left: input, middle: clusters computed from region growing, right: output). <emphasis>Ground</emphasis> is grey, <emphasis>roofs</emphasis> are orange, <emphasis>vegetation</emphasis> is green, points not assigned to a cluster are <emphasis>black</emphasis>.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1Classification_classifiers">
<title>Classifiers</title>
<para>Classification relies on a classifier: this classifier is an object that, from the set of values taken by the features at an input item, computes the probability that an input item belongs to one label or another. A model of the concept <computeroutput><ref refid="classCGAL_1_1Classification_1_1Classifier" kindref="compound">CGAL::Classification::Classifier</ref></computeroutput> must take the index of an input item and store the probability associated to each label in a vector. If a classifier returns the value 1 for a pair of label and input item, it means that this item belongs to this label with certainty; values close to 0 mean that this item is not likely to belong to this label.</para><para>CGAL provides three models for this concept, <ref refid="classCGAL_1_1Classification_1_1ETHZ__random__forest__classifier" kindref="compound">ETHZ_random_forest_classifier</ref>, <ref refid="classCGAL_1_1Classification_1_1OpenCV__random__forest__classifier" kindref="compound">OpenCV_random_forest_classifier</ref> and <ref refid="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier" kindref="compound">Sum_of_weighted_features_classifier</ref>.</para><para>To perform classification based on these classifiers, please refer to <ref refid="index_1Classification_classification_functions" kindref="member">Classification Functions</ref>.</para><sect2 id="index_1Classification_ETHZ_random_forest">
<title>ETHZ Random Forest</title>
<para>CGAL provides <ref refid="classCGAL_1_1Classification_1_1ETHZ__random__forest__classifier" kindref="compound">ETHZ_random_forest_classifier</ref>, a classifier based on the Random Forest Template Library developed by Stefan Walk at ETH Zurich <ref refid="citelist_1CITEREF_cgal:w-erftl-14" kindref="member">[2]</ref> (the library is distributed under the MIT license and is included with the CGAL release, the user does not have to install anything more). This classifier uses a ground truth training set to construct several decision trees that are then used to assign a label to each input item.</para><para><bold>This classifier is currently the best available in CGAL and we strongly advise users to use it.</bold></para><para>This classifier cannot be set up by hand and requires a ground truth training set. The training algorithm is fast but usually requires a high number of inliers. The training algorithm uses more memory at runtime and the configuration files are larger than those produced by <ref refid="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier" kindref="compound">Sum_of_weighted_features_classifier</ref>, but the output quality is usually significantly better, especially in the cases where many labels are used (more than five).</para><para>An <ref refid="index_1Classification_example_ethz_random_forest" kindref="member">example</ref> shows how to use this classifier. For more details about the algorithm, please refer to README provided in the <ulink url="https://www.ethz.ch/content/dam/ethz/special-interest/baug/igp/photogrammetry-remote-sensing-dam/documents/sourcecode-and-datasets/Random%20Forest/rforest.zip">ETH Zurich&apos;s code archive</ulink>.</para></sect2>
<sect2 id="index_1Classification_OpenCV_random_forest">
<title>OpenCV Random Forest</title>
<para>The second classifier is <ref refid="classCGAL_1_1Classification_1_1OpenCV__random__forest__classifier" kindref="compound">OpenCV_random_forest_classifier</ref>. It uses the <ref refid="installation_1thirdpartyOpenCV" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OpenCV</ref> library, more specifically the <ulink url="http://docs.opencv.org/2.4/modules/ml/doc/random_trees.html">Random Trees</ulink> package.</para><para>Note that this classifier usually produces results with a lower quality than <ref refid="classCGAL_1_1Classification_1_1ETHZ__random__forest__classifier" kindref="compound">ETHZ_random_forest_classifier</ref>.</para><para>It is provided for the sake of completeness and for testing purposes, but if you are not sure what to use, we advise using the ETHZ Random Forest instead.</para><para>An <ref refid="index_1Classification_example_opencv_random_forest" kindref="member">example</ref> shows how to use this classifier. For more details about the algorithm, please refer to <ulink url="http://docs.opencv.org/2.4/modules/ml/doc/random_trees.html">the official documentation</ulink> of OpenCV.</para></sect2>
<sect2 id="index_1Classification_sowf">
<title>Sum of Weighted Features</title>
<para>This latest classifier defines the following attributes:</para><para><itemizedlist>
<listitem><para>a weight applied to each feature;</para></listitem><listitem><para>an effect applied to each pair of feature and label.</para></listitem></itemizedlist>
</para><para>For each label, the classifier computes an energy as a sum of features normalized with both their weight and the effect they have on this specific label.</para><para>The main advantage of this classifier is that it can be set up by hand. Nevertheless, it also embeds a training algorithm.</para><sect3 id="index_1Classification_sowf_weights_effects">
<title>Weights and Effects</title>
<para>Each feature is assigned a weight that measures its strength with respect to the other features.</para><para>Each pair of feature and label is assigned an effect that can either be:</para><para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier_1a6aab054f8adf32f1e05b693f5caf9512a9f79d37660f7ace2f1c3a790edb4171a" kindref="member">FAVORING</ref>: the label is favored by high values of the feature;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier_1a6aab054f8adf32f1e05b693f5caf9512aafe5766bc7d9202e9e856491e311d954" kindref="member">NEUTRAL</ref>: the label is not affected by the feature;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier_1a6aab054f8adf32f1e05b693f5caf9512a2dd2e92685af72202d0875fb898f391e" kindref="member">PENALIZING</ref>: the label is favored by low values of the feature.</para></listitem></itemizedlist>
</para><para>For example, <emphasis>vegetation</emphasis> is expected to have a high distance to plane and have a color close to green (if colors are available); <emphasis>facades</emphasis> have a low distance to plane and a low verticality; etc.</para><para>Let <formula id="0">$x=(x_i)_{i=1..N}$</formula> be a potential classification result with <formula id="1">$N$</formula> the number of input items and <formula id="2">$x_i$</formula> the class of the <formula id="3">$i^{th}$</formula> item (for example: <emphasis>vegetation</emphasis>, <emphasis>ground</emphasis>, etc.). Let <formula id="4">$f_j(i)$</formula> be the raw value of the <formula id="5">$j^{th}$</formula> feature at the <formula id="3">$i^{th}$</formula> item and <formula id="6">$w_j$</formula> be the weight of this feature. We define the normalized value <formula id="7">$F_j(x_i) \in [0:1]$</formula> of the <formula id="5">$j^{th}$</formula> feature at the <formula id="3">$i^{th}$</formula> item as follows:</para><para><formula id="8">\begin{eqnarray*} F_j(x_i) = &amp; (1 - \min(\max(0,\frac{f_j(i)}{w_j}), 1)) &amp; \mbox{if } f_j \mbox{ favors } x_i \\ &amp; 0.5 &amp; \mbox{if } f_j \mbox{ is neutral for } x_i \\ &amp; \min(\max(0,\frac{f_j(i)}{w_j}), 1) &amp; \mbox{if } f_j \mbox{ penalizes } x_i \end{eqnarray*}</formula></para><para>The itemwise energy measures the coherence of the label <formula id="2">$x_i$</formula> at the <formula id="3">$i^{th}$</formula> item and is defined as:</para><para><formula id="9">\[ E_{di}(x_i) = \sum_{j = 1..N_f} F_j(x_i) \]</formula></para><para>The following code snippet shows how to define the weights and effects of features and labels:</para><para><programlisting><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Setting<sp/>weights&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classifier<sp/>classifier<sp/>(labels,<sp/>features);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_weight<sp/>(distance_to_plane,<sp/>6.75e-2f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_weight<sp/>(dispersion,<sp/>5.45e-1f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_weight<sp/>(elevation,<sp/>1.47e1f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Setting<sp/>effects&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(ground,<sp/>distance_to_plane,<sp/>Classifier::NEUTRAL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(ground,<sp/>dispersion,<sp/>Classifier::NEUTRAL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(ground,<sp/>elevation,<sp/>Classifier::PENALIZING);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(vegetation,<sp/>distance_to_plane,<sp/><sp/>Classifier::FAVORING);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(vegetation,<sp/>dispersion,<sp/>Classifier::FAVORING);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(vegetation,<sp/>elevation,<sp/>Classifier::NEUTRAL);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(roof,<sp/>distance_to_plane,<sp/><sp/>Classifier::NEUTRAL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(roof,<sp/>dispersion,<sp/>Classifier::NEUTRAL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(roof,<sp/>elevation,<sp/>Classifier::FAVORING);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting> </para></sect3>
<sect3 id="index_1Classification_sowf_training">
<title>Training</title>
<para>Each feature has a specific weight and each pair of feature-label has a specific effect. This means that the number of parameters to set up can quickly explode: if 6 features are used to classify between 4 labels, 30 parameters have to be set up (6 weights + 6x4 feature-label relationships).</para><para>Though it is possible to set them up one by one, CGAL also provides a method <ref refid="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier_1a11bcf5a1416f0fd2c4855af9c73797cc" kindref="member">train()</ref> that requires a small set of ground truth items provided by users. More specifically, users must provide, for each label they want to classify, a set of known inliers among the input data set (for example, selecting one roof, one tree and one section of the ground). The training algorithm works as follows:</para><para><itemizedlist>
<listitem><para>for each feature, a range of weights is tested: the effect each feature has on each label is estimated. For a given weight, if a feature has the same effect on each label, it is non-relevant for classification. The range of weights such that the feature is relevant is estimated;</para></listitem><listitem><para>for each feature, uniformly picked weight values are tested and their effects are estimated;</para></listitem><listitem><para>each inlier provided by the user is classified using this set of weights and effects;</para></listitem><listitem><para>the mean intersection-over-union (see <ref refid="index_1Classification_evaluation" kindref="member">Evaluation</ref>) is used to evaluate the quality of this set of weights and effects;</para></listitem><listitem><para>the same mechanism is repeated until all features&apos; ranges have been tested. Weights are only changed one by one, the other ones are kept to the values that gave the latest best score.</para></listitem></itemizedlist>
</para><para>This usually converges to a satisfying solution (see Figure <ref refid="index_1fig__Classification_trainer_fig" kindref="member">fig__Classification_trainer_fig</ref>). The number of trials is user defined, set to 300 by default. Using at least 10 times the number of features is advised (for example, at least 300 iterations if 30 features are used). If the solution is not satisfying, more inliers can be selected, for example, in a region that the user identifies as misclassified with the current configuration. The training algorithm keeps, as initialization, the best weights found at the previous round and carries on trying new weights by taking new inliers into account.</para><para><anchor id="index_1fig__Classification_trainer_fig"/><image type="html" name="classif_training.png"></image>
 <image type="latex" name="classif_training.png" width="15cm"></image>
  <ref refid="index_1fig__Classification_trainer_fig" kindref="member">fig__Classification_trainer_fig</ref> Example of evolution of the mean intersection-over-union. The purple curve is the score computed at the current iteration, green curve is the best score found so far.  <linebreak/>
</para></sect3>
<sect3 id="index_1Classification_sowf_result">
<title>Result</title>
<para>Figure <ref refid="index_1fig__Classification_sowf_result_fig" kindref="member">fig__Classification_sowf_result_fig</ref> shows an example of output on a defect-laden point set. The accuracy on this example is 0.97 with a mean intersection-over-union of 0.85 (see section <ref refid="index_1Classification_evaluation" kindref="member">Evaluation</ref>).</para><para><anchor id="index_1fig__Classification_sowf_result_fig"/><image type="html" name="noise_outliers.png"></image>
 <image type="latex" name="noise_outliers.png" width="15cm"></image>
  <ref refid="index_1fig__Classification_sowf_result_fig" kindref="member">fig__Classification_sowf_result_fig</ref> Example of classification on a point set with medium noise and outliers (left: input, right: output). <emphasis>Ground</emphasis> is orange, <emphasis>roofs</emphasis> are pink, <emphasis>vegetation</emphasis> is green. Outliers are classified with an additional label <emphasis>outlier</emphasis> in black.  <linebreak/>
</para></sect3>
</sect2>
</sect1>
<sect1 id="index_1Classification_classification_functions">
<title>Classification Functions</title>
<para>Classification is performed by minimizing an energy over the input data set that may include regularization. CGAL provides three different methods for classification, ranging from high speed / low quality to low speed / high quality:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgClassificationMain_1gaea3ed82bf801bc9fbd00b63da48df73e" kindref="member">CGAL::Classification::classify()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgClassificationMain_1ga266e487bd1ab9dd4036e3fbd2ec4e8a0" kindref="member">CGAL::Classification::classify_with_local_smoothing()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgClassificationMain_1ga2a4c1b0816b81b628dc9023e104449eb" kindref="member">CGAL::Classification::classify_with_graphcut()</ref></computeroutput></para></listitem></itemizedlist>
</para><para>On a point set of 3 millions of points, the first method takes about 4 seconds, the second about 40 seconds and the third about 2 minutes.</para><para><anchor id="index_1fig__Classification_image"/><image type="html" name="classif.png"></image>
 <image type="latex" name="classif.png" width="15cm"></image>
  <ref refid="index_1fig__Classification_image" kindref="member">fig__Classification_image</ref> Top-Left: input point set. Top-Right: raw output classification represented by a set of colors (<emphasis>ground</emphasis> is orange, <emphasis>facades</emphasis> are blue, <emphasis>roofs</emphasis> are pink and <emphasis>vegetation</emphasis> is green). Bottom-Left: output classification using local smoothing. Bottom-Right: output classification using graphcut.  <linebreak/>
</para><para>Mathematical details are provided hereafter.</para><sect2 id="index_1Classification_classify">
<title>Raw classification</title>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgClassificationMain_1gaea3ed82bf801bc9fbd00b63da48df73e" kindref="member">CGAL::Classification::classify()</ref></computeroutput>: this is the fastest method that provides acceptable but usually noisy results (see Figure <ref refid="index_1fig__Classification_image" kindref="member">fig__Classification_image</ref>, top-right).</para></listitem></itemizedlist>
</para><para>Let <formula id="0">$x=(x_i)_{i=1..N}$</formula> be a potential classification result with <formula id="1">$N$</formula> the number of input items and <formula id="2">$x_i$</formula> the label of the <formula id="3">$i^{th}$</formula> item (for example: <emphasis>vegetation</emphasis>, <emphasis>ground</emphasis>, etc.). The classification is performed by minimizing the following energy:</para><para><formula id="10">\[ E(x) = \sum_{i = 1..N} E_{di}(x_i) \]</formula></para><para>This energy is a sum of itemwise energies provided by the classifier and involves no regularization.</para><para>The following snippet shows how to classify points based on a label set and a classifier. The result is stored in <computeroutput>label_indices</computeroutput>, following the same order as the input set and providing for each point the index (in the label set) of its assigned label.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::size_t&gt;<sp/>label_indices;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Real_timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify&lt;Concurrency_tag&gt;<sp/>(pts,<sp/>labels,<sp/>classifier,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Raw<sp/>classification<sp/>performed<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
</programlisting> </para></sect2>
<sect2 id="index_1Classification_smoothing">
<title>Local Regularization</title>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgClassificationMain_1ga266e487bd1ab9dd4036e3fbd2ec4e8a0" kindref="member">CGAL::Classification::classify_with_local_smoothing()</ref></computeroutput>: this method is a tradeoff between quality and efficiency (see Figure <ref refid="index_1fig__Classification_image" kindref="member">fig__Classification_image</ref>, bottom-left). The minimized energy is defined as follows:</para><para><formula id="11">\[ E(x) = \sum_{i = 1..N} E_{si}(x_i) \]</formula></para></listitem></itemizedlist>
</para><para>The energy <formula id="12">$E_{si}(x_i)$</formula> is defined on a small local neighborhood <formula id="13">$Nb(i)$</formula> of the <formula id="3">$i^{th}$</formula> item (including itself):</para><para><formula id="14">\[ E_{si}(x_i) = \frac{\sum_{k \in Nb(i)} E_{di}(x_k)}{\left| Nb(i) \right|} \]</formula></para><para>This allows to eliminate local noisy variations of assigned labels. Increasing the size of the neighborhood increases the noise reduction at the cost of higher computation times.</para><para>The following snippet shows how to classify points using local smoothing by providing a model of <computeroutput><ref refid="classCGAL_1_1Classification_1_1NeighborQuery" kindref="compound">CGAL::Classification::NeighborQuery</ref></computeroutput>.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify_with_local_smoothing&lt;Concurrency_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(pts,<sp/>Pmap(),<sp/>labels,<sp/>classifier,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>neighborhood.sphere_neighbor_query(radius_neighbors),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classification<sp/>with<sp/>local<sp/>smoothing<sp/>performed<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
</programlisting> </para></sect2>
<sect2 id="index_1Classification_graphcut">
<title>Global Regularization (Graph Cut)</title>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgClassificationMain_1ga2a4c1b0816b81b628dc9023e104449eb" kindref="member">CGAL::Classification::classify_with_graphcut()</ref></computeroutput>: this method offers the best quality but requires longer computation time (see Figure <ref refid="index_1fig__Classification_image" kindref="member">fig__Classification_image</ref>, bottom-right). The total energy that is minimized is the sum of the partial data term <formula id="15">$E_{di}(x_i)$</formula> and of a pairwise interaction energy defined by the standard Potts model <ref refid="citelist_1CITEREF_cgal:l-mrfmi-09" kindref="member">[5]</ref> :</para><para><formula id="16">\[ E(x) = \sum_{i = 1..N} E_{di}(x_i) + \gamma \sum_{i \sim j} \mathbf{1}_{x_i \neq x_j} \]</formula></para></listitem></itemizedlist>
</para><para>where <formula id="17">$\gamma&gt;0$</formula> is the parameter of the Potts model that quantifies the strengh of the regularization, <formula id="18">$i \sim j$</formula> represents the pairs of neighboring items and <formula id="19">$\mathbf{1}_{\{.\}}$</formula> the characteristic function.</para><para>A <emphasis>Graph Cut</emphasis> based algorithm (Alpha Expansion) is used to quickly reach an approximate solution close to the global optimum of this energy.</para><para>This method allows to consistently segment the input data set in piecewise constant parts and to correct large wrongly classified clusters. Increasing <formula id="20">$\gamma$</formula> produces more regular result with a constant computation time.</para><para>To speed up computations, the input domain can be subdivided into smaller subsets such that several smaller graph cuts are applied instead of a big one. The computation of these smaller graph cuts can be done in parallel. Increasing the number of subsets allows for faster computation times but can also reduce the quality of the results.</para><para>The following snippet shows how to classify points using a graph cut regularization providing a model of <computeroutput><ref refid="classCGAL_1_1Classification_1_1NeighborQuery" kindref="compound">CGAL::Classification::NeighborQuery</ref></computeroutput>, a strengh parameter <formula id="20">$\gamma$</formula> and a number of subdivisions.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify_with_graphcut&lt;Concurrency_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(pts,<sp/>Pmap(),<sp/>labels,<sp/>classifier,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>neighborhood.k_neighbor_query(12),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>0.2f,<sp/>4,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classification<sp/>with<sp/>graphcut<sp/>performed<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
<sect1 id="index_1Classification_evaluation">
<title>Evaluation</title>
<para>The class <ref refid="classCGAL_1_1Classification_1_1Evaluation" kindref="compound">Evaluation</ref> allows users to evaluate the reliability of the classification with respect to a provided ground truth. The following measurements are available:</para><para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Classification_1_1Evaluation_1a040d137ec34590b2e2364d42264a901e" kindref="member">precision()</ref> computes, for one label, the ratio of true positives over the total number of detected positives;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Evaluation_1a40cd95adcd26d7b16cd6daaf56dfba27" kindref="member">recall()</ref> computes, for one label, the ratio of true positives over the total number of provided inliers of this label;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Evaluation_1a8de98452ad8bafc018b18d75e1e55a47" kindref="member">f1_score()</ref> is the harmonic mean of precision and recall;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Evaluation_1a2d4513d5a5256fda156d5b4fd1ddfbe7" kindref="member">intersection_over_union()</ref> computes the ratio of true positives over the union of the detected positives and of the provided inliers;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Evaluation_1ac2c9a217607e34f38541d10adc77b336" kindref="member">accuracy()</ref> computes the ratio of all true positives over the total number of provided inliers;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Evaluation_1aca8eaa6bf226fc44a3740b376acce804" kindref="member">mean_f1_score()</ref>;</para></listitem><listitem><para><ref refid="classCGAL_1_1Classification_1_1Evaluation_1aae3761d28e2b0585c8715edbff790c14" kindref="member">mean_intersection_over_union()</ref>.</para></listitem></itemizedlist>
</para><para>All these values range from 0 (poor quality) to 1 (perfect quality).</para></sect1>
<sect1 id="index_1Classification_examples">
<title>Full Examples</title>
<sect2 id="index_1Classification_example_general">
<title>Simple Point Set Classification</title>
<para>The following example:</para><para><itemizedlist>
<listitem><para>reads an input file (LIDAR point set in PLY format);</para></listitem><listitem><para>computes useful structures from this input;</para></listitem><listitem><para>computes features from the input and the precomputed structures;</para></listitem><listitem><para>defines 3 labels (<emphasis>vegetation</emphasis>, <emphasis>ground</emphasis> and <emphasis>roof</emphasis>);</para></listitem><listitem><para>sets up the classification classifier <ref refid="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier" kindref="compound">Sum_of_weighted_features_classifier</ref>;</para></listitem><listitem><para>classifies the point set with the 3 different methods (this is for the sake of the example: each method overwrites the previous result, users should only call one of the methods);</para></listitem><listitem><para>saves the result in a colored PLY format.</para></listitem></itemizedlist>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Classification_2example_classification_8cpp-example" kindref="compound">Classification/example_classification.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#if<sp/>defined<sp/>(_MSC_VER)<sp/>&amp;&amp;<sp/>!defined<sp/>(_WIN64)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>warning(disable:4244)<sp/>//<sp/>boost::number_distance::distance()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>converts<sp/>64<sp/>to<sp/>32<sp/>bits<sp/>integers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Classification.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/bounding_box.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_ply_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Real_timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Sequential__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Sequential_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::Iso_cuboid_3</ref><sp/>Iso_cuboid_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point&gt;<sp/>Point_range;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Identity_property_map&lt;Point&gt;<sp/>Pmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">Classification<sp/>=<sp/><ref refid="namespaceCGAL_1_1Classification" kindref="compound">CGAL::Classification</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Sum_of_weighted_features_classifier<sp/>Classifier;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Planimetric_grid&lt;Kernel,<sp/>Point_range,<sp/>Pmap&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Planimetric_grid;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Point_set_neighborhood&lt;Kernel,<sp/>Point_range,<sp/>Pmap&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>Neighborhood;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Local_eigen_analysis<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Local_eigen_analysis;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature::Distance_to_plane&lt;Point_range,<sp/>Pmap&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Distance_to_plane;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature::Elevation&lt;Kernel,<sp/>Point_range,<sp/>Pmap&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Elevation;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature::Vertical_dispersion&lt;Kernel,<sp/>Point_range,<sp/>Pmap&gt;<sp/>Dispersion;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename<sp/>(argc<sp/>&gt;<sp/>1<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/b9.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in<sp/>(filename.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>input&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>!(<ref refid="group__PkgPointSetProcessingIOPly_1ga1cff0be3f76b7e5f70dbd4320b06394a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::read_ply_points</ref><sp/>(in,<sp/>std::back_inserter<sp/>(pts))))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>grid_resolution<sp/>=<sp/>0.34f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_neighbors<sp/>=<sp/>6;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Computing<sp/>useful<sp/>structures&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Iso_cuboid_3<sp/>bbox<sp/>=<sp/>CGAL::bounding_box<sp/>(pts.begin(),<sp/>pts.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Planimetric_grid<sp/>grid<sp/>(pts,<sp/>Pmap(),<sp/>bbox,<sp/>grid_resolution);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighborhood<sp/>neighborhood<sp/>(pts,<sp/>Pmap());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Local_eigen_analysis<sp/>eigen</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>=<sp/>Local_eigen_analysis::create_from_point_set</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(pts,<sp/>Pmap(),<sp/>neighborhood.k_neighbor_query(number_of_neighbors));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>radius_neighbors<sp/>=<sp/>1.7f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>radius_dtm<sp/>=<sp/>15.0f;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Computing<sp/>features&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_handle<sp/>distance_to_plane<sp/>=<sp/>features.add&lt;Distance_to_plane&gt;<sp/>(pts,<sp/>Pmap(),<sp/>eigen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_handle<sp/>dispersion<sp/>=<sp/>features.add&lt;Dispersion&gt;<sp/>(pts,<sp/>Pmap(),<sp/>grid,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>radius_neighbors);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_handle<sp/>elevation<sp/>=<sp/>features.add&lt;Elevation&gt;<sp/>(pts,<sp/>Pmap(),<sp/>grid,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>radius_dtm);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_set<sp/>labels;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>ground<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;ground&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>vegetation<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;vegetation&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>roof<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;roof&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Setting<sp/>weights&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classifier<sp/>classifier<sp/>(labels,<sp/>features);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_weight<sp/>(distance_to_plane,<sp/>6.75e-2f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_weight<sp/>(dispersion,<sp/>5.45e-1f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_weight<sp/>(elevation,<sp/>1.47e1f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Setting<sp/>effects&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(ground,<sp/>distance_to_plane,<sp/>Classifier::NEUTRAL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(ground,<sp/>dispersion,<sp/>Classifier::NEUTRAL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(ground,<sp/>elevation,<sp/>Classifier::PENALIZING);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(vegetation,<sp/>distance_to_plane,<sp/><sp/>Classifier::FAVORING);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(vegetation,<sp/>dispersion,<sp/>Classifier::FAVORING);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(vegetation,<sp/>elevation,<sp/>Classifier::NEUTRAL);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(roof,<sp/>distance_to_plane,<sp/><sp/>Classifier::NEUTRAL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(roof,<sp/>dispersion,<sp/>Classifier::NEUTRAL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(roof,<sp/>elevation,<sp/>Classifier::FAVORING);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>classification</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classifying&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::size_t&gt;<sp/>label_indices;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Real_timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify&lt;Concurrency_tag&gt;<sp/>(pts,<sp/>labels,<sp/>classifier,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Raw<sp/>classification<sp/>performed<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify_with_local_smoothing&lt;Concurrency_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(pts,<sp/>Pmap(),<sp/>labels,<sp/>classifier,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>neighborhood.sphere_neighbor_query(radius_neighbors),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classification<sp/>with<sp/>local<sp/>smoothing<sp/>performed<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify_with_graphcut&lt;Concurrency_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(pts,<sp/>Pmap(),<sp/>labels,<sp/>classifier,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>neighborhood.k_neighbor_query(12),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>0.2f,<sp/>4,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classification<sp/>with<sp/>graphcut<sp/>performed<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Save<sp/>the<sp/>output<sp/>in<sp/>a<sp/>colored<sp/>PLY<sp/>format</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>f<sp/>(</highlight><highlight class="stringliteral">&quot;classification.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ply&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;format<sp/>ascii<sp/>1.0&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;element<sp/>vertex<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>pts.size()<sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;property<sp/>float<sp/>x&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;property<sp/>float<sp/>y&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;property<sp/>float<sp/>z&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;property<sp/>uchar<sp/>red&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;property<sp/>uchar<sp/>green&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;property<sp/>uchar<sp/>blue&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;end_header&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>pts.size();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>f<sp/>&lt;&lt;<sp/>pts[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Label_handle<sp/>label<sp/>=<sp/>labels[label_indices[i]];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(label<sp/>==<sp/>ground)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>f<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;245<sp/>180<sp/>0&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(label<sp/>==<sp/>vegetation)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>f<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;0<sp/>255<sp/>27&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(label<sp/>==<sp/>roof)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>f<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;255<sp/>0<sp/>170&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>f<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;0<sp/>0<sp/>0&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>unknown<sp/>classification<sp/>label&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;All<sp/>done&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Classification_example_feeature">
<title>Defining a Custom Feature</title>
<para>The following example shows how to define a custom feature and how to integrate it in the CGAL classification framework.</para><para><linebreak/>
<bold>File</bold> <ref refid="Classification_2example_feature_8cpp-example" kindref="compound">Classification/example_feature.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#if<sp/>defined<sp/>(_MSC_VER)<sp/>&amp;&amp;<sp/>!defined<sp/>(_WIN64)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>warning(disable:4244)<sp/>//<sp/>boost::number_distance::distance()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>converts<sp/>64<sp/>to<sp/>32<sp/>bits<sp/>integers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Classification.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_ply_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::Iso_cuboid_3</ref><sp/>Iso_cuboid_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point&gt;<sp/>Point_range;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Identity_property_map&lt;Point&gt;<sp/>Pmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">Classification<sp/>=<sp/><ref refid="namespaceCGAL_1_1Classification" kindref="compound">CGAL::Classification</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Sum_of_weighted_features_classifier<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Classifier;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Point_set_neighborhood&lt;Kernel,<sp/>Point_range,<sp/>Pmap&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>Neighborhood;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Local_eigen_analysis<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Local_eigen_analysis;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature::Verticality&lt;Kernel&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Verticality;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>User-defined<sp/>feature<sp/>that<sp/>identifies<sp/>a<sp/>specific<sp/>area<sp/>of<sp/>the<sp/>3D</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>space.<sp/>This<sp/>feature<sp/>takes<sp/>value<sp/>1<sp/>for<sp/>points<sp/>that<sp/>lie<sp/>inside<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>area<sp/>and<sp/>0<sp/>for<sp/>the<sp/>others.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_feature<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Classification_1_1Feature__base" kindref="compound">CGAL::Classification::Feature_base</ref></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_range&amp;<sp/>range;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>xmin,<sp/>xmax,<sp/>ymin,<sp/>ymax;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_feature<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_range&amp;<sp/>range,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>xmin,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>xmax,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ymin,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ymax)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>range<sp/>(range),<sp/>xmin(xmin),<sp/>xmax(xmax),<sp/>ymin(ymin),<sp/>ymax(ymax)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>this-&gt;set_name<sp/>(</highlight><highlight class="stringliteral">&quot;my_feature&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>value<sp/>(std::size_t<sp/>pt_index)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(xmin<sp/>&lt;<sp/>range[pt_index].x()<sp/>&amp;&amp;<sp/>range[pt_index].x()<sp/>&lt;<sp/>xmax<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ymin<sp/>&lt;<sp/>range[pt_index].y()<sp/>&amp;&amp;<sp/>range[pt_index].y()<sp/>&lt;<sp/>ymax)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename<sp/>(argc<sp/>&gt;<sp/>1<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/b9.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in<sp/>(filename.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>input&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>!(<ref refid="group__PkgPointSetProcessingIOPly_1ga1cff0be3f76b7e5f70dbd4320b06394a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::read_ply_points</ref><sp/>(in,<sp/>std::back_inserter<sp/>(pts))))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighborhood<sp/>neighborhood<sp/>(pts,<sp/>Pmap());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Local_eigen_analysis<sp/>eigen</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>=<sp/>Local_eigen_analysis::create_from_point_set<sp/>(pts,<sp/>Pmap(),<sp/>neighborhood.k_neighbor_query(6));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_set<sp/>labels;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>a<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;label_A&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>b<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;label_B&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Computing<sp/>features&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Feature<sp/>that<sp/>identifies<sp/>points<sp/>whose<sp/>x<sp/>coordinate<sp/>is<sp/>between<sp/>-20</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>20<sp/>and<sp/>whose<sp/>y<sp/>coordinate<sp/>is<sp/>between<sp/>-15<sp/>and<sp/>15</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_handle<sp/>my_feature<sp/>=<sp/>features.add&lt;My_feature&gt;<sp/>(pts,<sp/>-20.,<sp/>20.,<sp/>-15.,<sp/>15.);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_handle<sp/>verticality<sp/>=<sp/>features.add&lt;Verticality&gt;<sp/>(pts,<sp/>eigen);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classifier<sp/>classifier<sp/>(labels,<sp/>features);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Setting<sp/>weights&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_weight(verticality,<sp/>0.5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_weight(my_feature,<sp/>0.25);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Setting<sp/>up<sp/>labels&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(a,<sp/>verticality,<sp/>Classifier::FAVORING);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(a,<sp/>my_feature,<sp/>Classifier::FAVORING);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(b,<sp/>verticality,<sp/>Classifier::PENALIZING);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.set_effect<sp/>(b,<sp/>my_feature,<sp/>Classifier::PENALIZING);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classifying&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::size_t&gt;<sp/>label_indices(pts.size(),<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify_with_graphcut&lt;CGAL::Sequential_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(pts,<sp/>Pmap(),<sp/>labels,<sp/>classifier,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>neighborhood.k_neighbor_query(12),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>0.5,<sp/>1,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;All<sp/>done&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Classification_example_training">
<title>Feature Generation and Training</title>
<para>The following example:</para><para><itemizedlist>
<listitem><para>reads a point set with a training set (embedded as a PLY feature <emphasis>label</emphasis>);</para></listitem><listitem><para>automatically generates features on 5 scales;</para></listitem><listitem><para>trains the classifier <ref refid="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier" kindref="compound">Sum_of_weighted_features_classifier</ref> using 800 trials;</para></listitem><listitem><para>runs the algorithm using the graphcut regularization;</para></listitem><listitem><para>prints some evaluation measurements;</para></listitem><listitem><para>saves the configuration of the classifier for further use.</para></listitem></itemizedlist>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Classification_2example_generation_and_training_8cpp-example" kindref="compound">Classification/example_generation_and_training.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#if<sp/>defined<sp/>(_MSC_VER)<sp/>&amp;&amp;<sp/>!defined<sp/>(_WIN64)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>warning(disable:4244)<sp/>//<sp/>boost::number_distance::distance()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>converts<sp/>64<sp/>to<sp/>32<sp/>bits<sp/>integers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Classification.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3/IO.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Real_timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Point_set_3&lt;Point&gt;<sp/>Point_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::Iso_cuboid_3</ref><sp/>Iso_cuboid_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Point_map<sp/>Pmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Property_map&lt;int&gt;<sp/>Imap;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">Classification<sp/>=<sp/><ref refid="namespaceCGAL_1_1Classification" kindref="compound">CGAL::Classification</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Sum_of_weighted_features_classifier<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Classifier;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Point_set_feature_generator&lt;Kernel,<sp/>Point_set,<sp/>Pmap&gt;<sp/><sp/><sp/><sp/>Feature_generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename<sp/>(argc<sp/>&gt;<sp/>1<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;data/b9_training.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in<sp/>(filename.c_str(),<sp/>std::ios::binary);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>input&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Imap<sp/>label_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>lm_found<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::tie<sp/>(label_map,<sp/>lm_found)<sp/>=<sp/>pts.property_map&lt;</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;<sp/>(</highlight><highlight class="stringliteral">&quot;label&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!lm_found)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>\&quot;label\&quot;<sp/>property<sp/>not<sp/>found<sp/>in<sp/>input<sp/>file.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;int&gt;<sp/>ground_truth;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ground_truth.reserve<sp/>(pts.size());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::copy<sp/>(pts.range(label_map).begin(),<sp/>pts.range(label_map).end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter<sp/>(ground_truth));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Generating<sp/>features&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Real_timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>number_of_scales<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_generator<sp/>generator<sp/>(pts,<sp/>pts.point_map(),<sp/>number_of_scales);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>generator.generate_point_based_features<sp/>(features);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>features.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>feature(s)<sp/>generated<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_set<sp/>labels;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>ground<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;ground&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>vegetation<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;vegetation&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>roof<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;roof&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classifier<sp/>classifier<sp/>(labels,<sp/>features);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Training&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.train&lt;<ref refid="structCGAL_1_1Sequential__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Sequential_tag</ref>&gt;<sp/>(ground_truth,<sp/>800);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;int&gt;<sp/>label_indices(pts.size(),<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify_with_graphcut&lt;CGAL::Sequential_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(pts,<sp/>pts.point_map(),<sp/>labels,<sp/>classifier,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>generator.neighborhood().k_neighbor_query(12),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>0.2f,<sp/>10,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classification<sp/>with<sp/>graphcut<sp/>done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Precision,<sp/>recall,<sp/>F1<sp/>scores<sp/>and<sp/>IoU:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::Evaluation<sp/>evaluation<sp/>(labels,<sp/>ground_truth,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>labels.size();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>*<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>labels[i]-&gt;name()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.precision(labels[i])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.recall(labels[i])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.f1_score(labels[i])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.intersection_over_union(labels[i])<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Accuracy<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>evaluation.accuracy()<sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Mean<sp/>F1<sp/>score<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>evaluation.mean_f1_score()<sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Mean<sp/>IoU<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>evaluation.mean_intersection_over_union()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>fconfig<sp/>(</highlight><highlight class="stringliteral">&quot;config.xml&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.save_configuration<sp/>(fconfig);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fconfig.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;All<sp/>done&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Classification_example_ethz_random_forest">
<title>ETHZ Random Forest</title>
<para>The following example shows how to use the classifier <ref refid="classCGAL_1_1Classification_1_1ETHZ__random__forest__classifier" kindref="compound">ETHZ_random_forest_classifier</ref> using an input training set.</para><para><linebreak/>
<bold>File</bold> <ref refid="Classification_2example_ethz_random_forest_8cpp-example" kindref="compound">Classification/example_ethz_random_forest.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#if<sp/>defined<sp/>(_MSC_VER)<sp/>&amp;&amp;<sp/>!defined<sp/>(_WIN64)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>warning(disable:4244)<sp/>//<sp/>boost::number_distance::distance()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>converts<sp/>64<sp/>to<sp/>32<sp/>bits<sp/>integers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Classification.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3/IO.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Real_timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Point_set_3&lt;Point&gt;<sp/>Point_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::Iso_cuboid_3</ref><sp/>Iso_cuboid_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Point_map<sp/>Pmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Property_map&lt;int&gt;<sp/>Imap;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Property_map&lt;unsigned<sp/>char&gt;<sp/>UCmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">Classification<sp/>=<sp/><ref refid="namespaceCGAL_1_1Classification" kindref="compound">CGAL::Classification</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Point_set_feature_generator&lt;Kernel,<sp/>Point_set,<sp/>Pmap&gt;<sp/><sp/><sp/><sp/>Feature_generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;data/b9_training.ply&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>filename<sp/>=<sp/>argv[1];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in<sp/>(filename.c_str(),<sp/>std::ios::binary);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>input&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Imap<sp/>label_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>lm_found<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::tie<sp/>(label_map,<sp/>lm_found)<sp/>=<sp/>pts.property_map&lt;</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;<sp/>(</highlight><highlight class="stringliteral">&quot;label&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!lm_found)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>\&quot;label\&quot;<sp/>property<sp/>not<sp/>found<sp/>in<sp/>input<sp/>file.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;int&gt;<sp/>ground_truth;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ground_truth.reserve<sp/>(pts.size());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::copy<sp/>(pts.range(label_map).begin(),<sp/>pts.range(label_map).end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter<sp/>(ground_truth));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Generating<sp/>features&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Real_timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_generator<sp/>generator<sp/>(pts,<sp/>pts.point_map(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>5);<sp/><sp/></highlight><highlight class="comment">//<sp/>using<sp/>5<sp/>scales</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>generator.generate_point_based_features<sp/>(features);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_set<sp/>labels;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>ground<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;ground&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>vegetation<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;vegetation&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>roof<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;roof&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;int&gt;<sp/>label_indices(pts.size(),<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Using<sp/>ETHZ<sp/>Random<sp/>Forest<sp/>Classifier&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::ETHZ_random_forest_classifier<sp/>classifier<sp/>(labels,<sp/>features);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Training&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.train<sp/>(ground_truth);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify_with_graphcut&lt;CGAL::Sequential_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(pts,<sp/>pts.point_map(),<sp/>labels,<sp/>classifier,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>generator.neighborhood().k_neighbor_query(12),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>0.2f,<sp/>1,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classification<sp/>with<sp/>graphcut<sp/>done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Precision,<sp/>recall,<sp/>F1<sp/>scores<sp/>and<sp/>IoU:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::Evaluation<sp/>evaluation<sp/>(labels,<sp/>ground_truth,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>labels.size();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>*<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>labels[i]-&gt;name()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.precision(labels[i])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.recall(labels[i])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.f1_score(labels[i])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.intersection_over_union(labels[i])<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Accuracy<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>evaluation.accuracy()<sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Mean<sp/>F1<sp/>score<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>evaluation.mean_f1_score()<sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Mean<sp/>IoU<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>evaluation.mean_intersection_over_union()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Color<sp/>point<sp/>set<sp/>according<sp/>to<sp/>class</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>UCmap<sp/>red<sp/>=<sp/>pts.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;red&quot;</highlight><highlight class="normal">,<sp/>0).first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>UCmap<sp/>green<sp/>=<sp/>pts.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;green&quot;</highlight><highlight class="normal">,<sp/>0).first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>UCmap<sp/>blue<sp/>=<sp/>pts.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;blue&quot;</highlight><highlight class="normal">,<sp/>0).first;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>label_indices.size();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>label_map[i]<sp/>=<sp/>label_indices[i];<sp/></highlight><highlight class="comment">//<sp/>update<sp/>label<sp/>map<sp/>with<sp/>computed<sp/>classification</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Label_handle<sp/>label<sp/>=<sp/>labels[label_indices[i]];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(label<sp/>==<sp/>ground)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>red[i]<sp/>=<sp/>245;<sp/>green[i]<sp/>=<sp/>180;<sp/>blue[i]<sp/>=<sp/><sp/><sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(label<sp/>==<sp/>vegetation)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>red[i]<sp/>=<sp/><sp/><sp/>0;<sp/>green[i]<sp/>=<sp/>255;<sp/>blue[i]<sp/>=<sp/><sp/>27;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(label<sp/>==<sp/>roof)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>red[i]<sp/>=<sp/>255;<sp/>green[i]<sp/>=<sp/><sp/><sp/>0;<sp/>blue[i]<sp/>=<sp/>170;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>f<sp/>(</highlight><highlight class="stringliteral">&quot;classification.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f.precision(18);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f<sp/>&lt;&lt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;All<sp/>done&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Classification_example_opencv_random_forest">
<title>OpenCV Random Forest</title>
<para>The following example shows how to use the classifier <ref refid="classCGAL_1_1Classification_1_1OpenCV__random__forest__classifier" kindref="compound">OpenCV_random_forest_classifier</ref> using an input training set.</para><para><linebreak/>
<bold>File</bold> <ref refid="Classification_2example_opencv_random_forest_8cpp-example" kindref="compound">Classification/example_opencv_random_forest.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#if<sp/>defined<sp/>(_MSC_VER)<sp/>&amp;&amp;<sp/>!defined<sp/>(_WIN64)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>warning(disable:4244)<sp/>//<sp/>boost::number_distance::distance()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>converts<sp/>64<sp/>to<sp/>32<sp/>bits<sp/>integers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Classification.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3/IO.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Real_timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Point_set_3&lt;Point&gt;<sp/>Point_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::Iso_cuboid_3</ref><sp/>Iso_cuboid_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Point_map<sp/>Pmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Property_map&lt;int&gt;<sp/>Imap;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Property_map&lt;unsigned<sp/>char&gt;<sp/>UCmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">Classification<sp/>=<sp/><ref refid="namespaceCGAL_1_1Classification" kindref="compound">CGAL::Classification</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Point_set_feature_generator&lt;Kernel,<sp/>Point_set,<sp/>Pmap&gt;<sp/><sp/><sp/><sp/>Feature_generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;data/b9_training.ply&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>filename<sp/>=<sp/>argv[1];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in<sp/>(filename.c_str(),<sp/>std::ios::binary);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>input&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Imap<sp/>label_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>lm_found<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::tie<sp/>(label_map,<sp/>lm_found)<sp/>=<sp/>pts.property_map&lt;</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;<sp/>(</highlight><highlight class="stringliteral">&quot;label&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!lm_found)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>\&quot;label\&quot;<sp/>property<sp/>not<sp/>found<sp/>in<sp/>input<sp/>file.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;int&gt;<sp/>ground_truth;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ground_truth.reserve<sp/>(pts.size());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::copy<sp/>(pts.range(label_map).begin(),<sp/>pts.range(label_map).end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter<sp/>(ground_truth));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Generating<sp/>features&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Real_timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_generator<sp/>generator<sp/>(pts,<sp/>pts.point_map(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>5);<sp/><sp/></highlight><highlight class="comment">//<sp/>using<sp/>5<sp/>scales</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>generator.generate_point_based_features<sp/>(features);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_set<sp/>labels;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>ground<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;ground&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>vegetation<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;vegetation&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>roof<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;roof&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;int&gt;<sp/>label_indices(pts.size(),<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Using<sp/>OpenCV<sp/>Random<sp/>Forest<sp/>Classifier&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::OpenCV_random_forest_classifier<sp/>classifier<sp/>(labels,<sp/>features);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Training&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.train<sp/>(ground_truth);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify_with_graphcut&lt;CGAL::Sequential_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(pts,<sp/>pts.point_map(),<sp/>labels,<sp/>classifier,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>generator.neighborhood().k_neighbor_query(12),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>0.2f,<sp/>1,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classification<sp/>with<sp/>graphcut<sp/>done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Precision,<sp/>recall,<sp/>F1<sp/>scores<sp/>and<sp/>IoU:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::Evaluation<sp/>evaluation<sp/>(labels,<sp/>ground_truth,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>labels.size();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>*<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>labels[i]-&gt;name()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.precision(labels[i])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.recall(labels[i])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.f1_score(labels[i])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>evaluation.intersection_over_union(labels[i])<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Accuracy<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>evaluation.accuracy()<sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Mean<sp/>F1<sp/>score<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>evaluation.mean_f1_score()<sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Mean<sp/>IoU<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>evaluation.mean_intersection_over_union()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Color<sp/>point<sp/>set<sp/>according<sp/>to<sp/>class</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>UCmap<sp/>red<sp/>=<sp/>pts.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;red&quot;</highlight><highlight class="normal">,<sp/>0).first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>UCmap<sp/>green<sp/>=<sp/>pts.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;green&quot;</highlight><highlight class="normal">,<sp/>0).first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>UCmap<sp/>blue<sp/>=<sp/>pts.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;blue&quot;</highlight><highlight class="normal">,<sp/>0).first;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>label_indices.size();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>label_map[i]<sp/>=<sp/>label_indices[i];<sp/></highlight><highlight class="comment">//<sp/>update<sp/>label<sp/>map<sp/>with<sp/>computed<sp/>classification</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Label_handle<sp/>label<sp/>=<sp/>labels[label_indices[i]];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(label<sp/>==<sp/>ground)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>red[i]<sp/>=<sp/>245;<sp/>green[i]<sp/>=<sp/>180;<sp/>blue[i]<sp/>=<sp/><sp/><sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(label<sp/>==<sp/>vegetation)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>red[i]<sp/>=<sp/><sp/><sp/>0;<sp/>green[i]<sp/>=<sp/>255;<sp/>blue[i]<sp/>=<sp/><sp/>27;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(label<sp/>==<sp/>roof)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>red[i]<sp/>=<sp/>255;<sp/>green[i]<sp/>=<sp/><sp/><sp/>0;<sp/>blue[i]<sp/>=<sp/>170;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>f<sp/>(</highlight><highlight class="stringliteral">&quot;classification.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f.precision(18);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f<sp/>&lt;&lt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;All<sp/>done&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Classification_example_mesh">
<title>Mesh Classification</title>
<para>The following example:</para><para><itemizedlist>
<listitem><para>reads a mesh in OFF format;</para></listitem><listitem><para>automatically generates features on 5 scales;</para></listitem><listitem><para>loads a configuration file for classifier <ref refid="classCGAL_1_1Classification_1_1ETHZ__random__forest__classifier" kindref="compound">ETHZ_random_forest_classifier</ref>;</para></listitem><listitem><para>runs the algorithm using the graphcut regularization.</para></listitem></itemizedlist>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Classification_2example_mesh_classification_8cpp-example" kindref="compound">Classification/example_mesh_classification.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#if<sp/>defined<sp/>(_MSC_VER)<sp/>&amp;&amp;<sp/>!defined<sp/>(_WIN64)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>warning(disable:4244)<sp/>//<sp/>boost::number_distance::distance()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>converts<sp/>64<sp/>to<sp/>32<sp/>bits<sp/>integers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Classification.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Real_timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Surface_mesh&lt;Point&gt;<sp/>Mesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">Classification<sp/>=<sp/><ref refid="namespaceCGAL_1_1Classification" kindref="compound">CGAL::Classification</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Face_descriptor_to_center_of_mass_map&lt;Mesh&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Face_descriptor_to_face_descriptor_with_bbox_map&lt;Mesh&gt;<sp/><sp/>Face_with_bbox_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Mesh_feature_generator&lt;Kernel,<sp/>Mesh,<sp/>Face_point_map&gt;<sp/><sp/><sp/><sp/>Feature_generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;data/b9_mesh.off&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename_config<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;data/b9_mesh_config.gz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>filename<sp/>=<sp/>argv[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>filename_config<sp/>=<sp/>argv[2];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in<sp/>(filename.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mesh<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>input&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Generating<sp/>features&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Real_timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_point_map<sp/>face_point_map<sp/>(&amp;mesh);<sp/></highlight><highlight class="comment">//<sp/>Associates<sp/>each<sp/>face<sp/>to<sp/>its<sp/>center<sp/>of<sp/>mass</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>number_of_scales<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_generator<sp/>generator<sp/>(mesh,<sp/>face_point_map,<sp/>number_of_scales);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>generator.generate_point_based_features<sp/>(features);<sp/></highlight><highlight class="comment">//<sp/>Features<sp/>that<sp/>consider<sp/>the<sp/>mesh<sp/>as<sp/>a<sp/>point<sp/>set</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>generator.generate_face_based_features<sp/>(features);<sp/><sp/></highlight><highlight class="comment">//<sp/>Features<sp/>computed<sp/>directly<sp/>on<sp/>mesh<sp/>faces</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_set<sp/>labels;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>ground<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;ground&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>vegetation<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;vegetation&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>roof<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;roof&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;int&gt;<sp/>label_indices(mesh.number_of_faces(),<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Using<sp/>ETHZ<sp/>Random<sp/>Forest<sp/>Classifier&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::ETHZ_random_forest_classifier<sp/>classifier<sp/>(labels,<sp/>features);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Loading<sp/>configuration&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_config<sp/>(filename_config,<sp/>std::ios_base::in<sp/>|<sp/>std::ios_base::binary);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.load_configuration<sp/>(in_config);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classifying<sp/>with<sp/>graphcut&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify_with_graphcut&lt;CGAL::Sequential_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(mesh.faces(),<sp/>Face_with_bbox_map(&amp;mesh),<sp/>labels,<sp/>classifier,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>generator.neighborhood().n_ring_neighbor_query(2),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>0.2f,<sp/>1,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classification<sp/>with<sp/>graphcut<sp/>done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Classification_example_cluster">
<title>Cluster Classification</title>
<para>The following example:</para><para><itemizedlist>
<listitem><para>reads a point set in PLY format;</para></listitem><listitem><para>estimates the normal vectors of the point set;</para></listitem><listitem><para>automatically generates pointwise features on 5 scales;</para></listitem><listitem><para>detects plane using the algorithm <computeroutput><ref refid="classCGAL_1_1Shape__detection__3_1_1Region__growing" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Region_growing</ref></computeroutput>;</para></listitem><listitem><para>creates <ref refid="classCGAL_1_1Classification_1_1Cluster" kindref="compound">Cluster</ref> objects from these detected planes;</para></listitem><listitem><para>computes cluster features from the pointwise features;</para></listitem><listitem><para>loads a configuration file for classifier <ref refid="classCGAL_1_1Classification_1_1ETHZ__random__forest__classifier" kindref="compound">ETHZ_random_forest_classifier</ref>;</para></listitem><listitem><para>runs the algorithm using the raw algorithm.</para></listitem></itemizedlist>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Classification_2example_cluster_classification_8cpp-example" kindref="compound">Classification/example_cluster_classification.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#if<sp/>defined<sp/>(_MSC_VER)<sp/>&amp;&amp;<sp/>!defined<sp/>(_WIN64)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>warning(disable:4244)<sp/>//<sp/>boost::number_distance::distance()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>converts<sp/>64<sp/>to<sp/>32<sp/>bits<sp/>integers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Classification.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3/IO.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/jet_estimate_normals.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Shape__detection__3_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL/Shape_detection_3.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Real_timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Sequential__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Sequential_tag</ref><sp/>Concurrency_tag;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Point_set_3&lt;Point&gt;<sp/>Point_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::Iso_cuboid_3</ref><sp/>Iso_cuboid_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Point_map<sp/>Pmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Vector_map<sp/>Vmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Property_map&lt;int&gt;<sp/>Imap;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_set::Property_map&lt;unsigned<sp/>char&gt;<sp/>UCmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Shape__detection__3_1_1Shape__detection__traits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Shape_detection_traits&lt;Kernel, Point_set, Pmap, Vmap&gt;</ref><sp/>SD_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection__3_1_1Region__growing" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Region_growing&lt;SD_traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Region_growing;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection__3_1_1Plane" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Plane&lt;SD_traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Plane;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">Classification<sp/>=<sp/><ref refid="namespaceCGAL_1_1Classification" kindref="compound">CGAL::Classification</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Label_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Label_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Feature_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Feature_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Local_eigen_analysis<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Local_eigen_analysis;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Point_set_feature_generator&lt;Kernel,<sp/>Point_set,<sp/>Pmap&gt;<sp/><sp/><sp/><sp/>Feature_generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Classification::Cluster&lt;Point_set,<sp/>Pmap&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cluster;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;data/b9.ply&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename_config<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;data/b9_clusters_config.gz&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>filename<sp/>=<sp/>argv[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>filename_config<sp/>=<sp/>argv[2];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in<sp/>(filename.c_str(),<sp/>std::ios::binary);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading<sp/>input&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Estimating<sp/>normals&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Real_timer<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pts.add_normal_map();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::jet_estimate_normals&lt;Concurrency_tag&gt;<sp/>(pts,<sp/>12);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>pointwise_features;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Generating<sp/>pointwise<sp/>features&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_generator<sp/>generator<sp/>(pts,<sp/>pts.point_map(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>5);<sp/><sp/></highlight><highlight class="comment">//<sp/>using<sp/>5<sp/>scales</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pointwise_features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>generator.generate_point_based_features<sp/>(pointwise_features);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>generator.generate_normal_based_features<sp/>(pointwise_features,<sp/>pts.normal_map());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pointwise_features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Detecting<sp/>planes&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_growing::Parameters<sp/>parameters;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.min_points<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.epsilon<sp/>=<sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.cluster_epsilon<sp/>=<sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.normal_threshold<sp/>=<sp/>0.9;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_growing<sp/>region_growing;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.set_input<sp/>(pts,<sp/>pts.point_map(),<sp/>pts.normal_map());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.add_shape_factory&lt;Plane&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.detect<sp/>(parameters);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>region_growing.shapes().end()<sp/>-<sp/>region_growing.shapes().begin()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>planes<sp/>detected<sp/>in<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Creating<sp/>clusters&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Cluster&gt;<sp/>clusters;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgClassificationCluster_1ga6c0c1a27071cf5ebfac967d6847cbbf9" kindref="member">Classification::create_clusters_from_indices</ref><sp/>(pts,<sp/>pts.point_map(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Shape__detection__3_1_1Point__to__shape__index__map" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Point_set_shape_detection_3.tag">CGAL::Shape_detection_3::Point_to_shape_index_map&lt;SD_traits&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(pts,<sp/>region_growing.planes()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clusters);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>clusters.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>clusters<sp/>created<sp/>in<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Computing<sp/>cluster<sp/>features&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Local_eigen_analysis<sp/>eigen<sp/>=<sp/>Local_eigen_analysis::create_from_point_clusters<sp/>(clusters);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Feature_set<sp/>features;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>First<sp/>compute<sp/>means<sp/>of<sp/>features</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>pointwise_features.size();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>features.add&lt;Classification::Feature::Cluster_mean_of_feature&gt;<sp/>(clusters,<sp/>pointwise_features[i]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.begin_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Then<sp/>compute<sp/>variances<sp/>of<sp/>features<sp/>(and<sp/>remaining<sp/>cluster<sp/>features)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>pointwise_features.size();<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>features.add&lt;Classification::Feature::Cluster_variance_of_feature&gt;<sp/>(clusters,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointwise_features[i],<sp/></highlight><highlight class="comment">//<sp/>i^th<sp/>feature</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>features[i]);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>mean<sp/>of<sp/>i^th<sp/>feature</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.add&lt;Classification::Feature::Cluster_size&gt;<sp/>(clusters);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.add&lt;Classification::Feature::Cluster_vertical_extent&gt;<sp/>(clusters);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>3;<sp/>++<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>features.add&lt;Classification::Feature::Eigenvalue&gt;<sp/>(clusters,<sp/>eigen,<sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)(i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>features.end_parallel_additions();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_set<sp/>labels;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>ground<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;ground&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>vegetation<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;vegetation&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Label_handle<sp/>roof<sp/>=<sp/>labels.add<sp/>(</highlight><highlight class="stringliteral">&quot;roof&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;int&gt;<sp/>label_indices(clusters.size(),<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Using<sp/>ETHZ<sp/>Random<sp/>Forest<sp/>Classifier&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::ETHZ_random_forest_classifier<sp/>classifier<sp/>(labels,<sp/>features);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Loading<sp/>configuration&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_config<sp/>(filename_config,<sp/>std::ios_base::in<sp/>|<sp/>std::ios_base::binary);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>classifier.load_configuration<sp/>(in_config);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classifying&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Classification::classify&lt;Concurrency_tag&gt;<sp/>(clusters,<sp/>labels,<sp/>classifier,<sp/>label_indices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>t.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Classification<sp/>done<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>t.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>second(s)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Classification_history">
<title>History</title>
<para>This package is based on a research code by <ulink url="https://www-sop.inria.fr/members/Florent.Lafarge/">Florent Lafarge</ulink> that was generalized, extended and packaged by <ulink url="http://geometryfactory.com/who-we-are/">Simon Giraudot</ulink> in CGAL 4.12. Classification of surface meshes and of clusters were introduced in CGAL 4.13. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
