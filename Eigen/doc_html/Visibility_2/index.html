<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Visibility_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Visibility: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Visibility
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Visibility_Computation"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Michael Hemmer, Kan Huang, Francisc Bungiu, Ning Xu</dd></dl>
<h1><a class="anchor" id="visibility_2_introduction"></a>
Introduction</h1>
<p>This package provides functionality to compute the visibility region within polygons in two dimensions. The package is based on the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangement2Summary">2D Arrangements</a> and uses <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2</a> as the fundamental class to specify the input as well as the output. Hence, a polygon \( P \) is represented by a bounded arrangement face \( f \) that does not have any isolated vertices and any edge that is adjacent to \( f \) separates \( f \) from another face. Note that \( f \) may contain holes. Similarly, a simple polygon is represented by a face without holes.</p>
<p>Given two points \( p \) and \( q \) in \( P \), they are said to be visible to each other iff the segment \( pq \subset P \), where \( P \) is considered to be closed, that is, \(\partial P \subset P\). For a query point \( q \in P \), the set of points that are visible from \( q \) is defined as the visibility region of \( q \), denoted by \( V_q \)</p>
<h2><a class="anchor" id="visibility_2_degeneracies"></a>
Degeneracies and Regularization</h2>
<p><a class="anchor" id="fig__definition-fig"></a></p><div class="image">
<img src="example1.png" alt="example1.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__definition-fig">Figure 23.1</a> Non-regularized visibility and regularized visibility.  </div>  <br />

<p>As illustrated in <a class="el" href="index.html#fig__definition-fig">Figure 23.1</a> (1) the visibility region \( V_q \) of a query point \( q \) may not be a polygon. In the figure, all labeled points are collinear, which implies that the point \( c \) is visible to \( q \), that is, the segment \( bc \) is part of \( V_q \). We call such low dimensional features that are caused by degeneracies <code>needles</code>. However, for many applications these needles are actually irrelevant. Moreover, for some algorithms it is even more efficient to ignore needles in the first place. Therefore, this package offers also functionality to compute the regularized visibility area \( \overline{V_q} = closure(interior(V_q)) = (V_q\setminus\partial V_q) \cup \partial (V_q\setminus\partial V_q)\), as shown in <a class="el" href="index.html#fig__definition-fig">Figure 23.1</a> (2). For more information about regularization, refer to Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBooleanSetOperations2Summary">2D Regularized Boolean Set-Operations</a>.</p>
<h1><a class="anchor" id="visibility_2_classes"></a>
Classes and Algorithms</h1>
<p>Answering visibility queries is, in many ways, similar to answering point-location queries. Thus, we use the same design used to implement <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangement2Summary">2D Arrangements</a> point location. Each of the various visibility class templates employs a different algorithm or <em>strategy</em> for answering queries<span class="footnote">The term <em>strategy</em> is borrowed from the design-pattern taxonomy <a class="el" href="citelist.html#CITEREF_cgal:ghjv-dpero-95">[3]</a>. A <em>strategy</em> provides the means to define a family of algorithms, each implemented by a separate class. All classes that implement the various algorithms are made interchangeable, letting the algorithm in use vary according to the user choice.</span>. Similar to the point-location case, some of the strategies require preprocessing. Thus, before a visibility object is used to answer visibility queries, it must be attached to an arrangement object. Afterwards, the visibility object observes changes to the attached arrangement. Hence, it is possible to modify the arrangement after attaching the visibility object. However, this feature should be used with caution as each change to the arrangement also requires an update of the auxiliary data structures in the attached object.</p>
<p>An actual query is performed by giving the view point \( p \) and its containing face \( f \) (which must represent a valid polygon) to a visibility object. For more details see the documentation of the overloaded member function <code><a class="el" href="classVisibility__2.html#a9c90c6b55b2053cef2071a31864afd08" title="Computes the visibility region for the given query point q in the face  of the arrangement that is at...">Visibility_2::compute_visibility()</a></code>.</p>
<p>The following models of the <code><a class="el" href="classVisibility__2.html" title="A model of the Visibility_2 concept can be attached to an Arrangement_2 instance to answer visibility...">Visibility_2</a></code> concept are provided:</p>
<center> <table class="doxtable">
<tr>
<th>Class </th><th>Function </th><th>Preprocessing </th><th>Query </th><th>Algorithm  </th></tr>
<tr>
<td><code><a class="el" href="classCGAL_1_1Simple__polygon__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a simple polyg...">Simple_polygon_visibility_2</a></code> </td><td>simple polygons </td><td>No </td><td>\( O(n) \) time and \( O(n) \) space </td><td>B. Joe and R. B. Simpson <a class="el" href="citelist.html#CITEREF_bjrb-clvpa-87">[4]</a> </td></tr>
<tr>
<td><code><a class="el" href="classCGAL_1_1Rotational__sweep__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a polygon that...">Rotational_sweep_visibility_2</a></code> </td><td>polygons with holes </td><td>No </td><td>\( O(n\log n) \) time and \( O(n) \) space </td><td>T. Asano <a class="el" href="citelist.html#CITEREF_ta-aeafvpprh-85">[1]</a> </td></tr>
<tr>
<td><code><a class="el" href="classCGAL_1_1Triangular__expansion__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a polygon that...">Triangular_expansion_visibility_2</a></code> </td><td>polygons with holes </td><td>\( O(n) \) time and \( O(n) \) space </td><td>\( O(nh) \) time and \( O(n) \) space. </td><td>Bungiu et al. <a class="el" href="citelist.html#CITEREF_ecvp-bhhhk-14">[2]</a> </td></tr>
</table>
</center><p>Where \( n \) denotes the number of vertices of \( f \) and \( h \) the number of holes+1.</p>
<h1><a class="anchor" id="benchmarks"></a>
Running Time in Practice</h1>
<p><a class="anchor" id="fig__cathedral-fig"></a></p><div class="image">
<img src="cathedral_2.png" alt="cathedral_2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__cathedral-fig">Figure 23.2</a> Example representing a cathedral.  </div>  <br />

<p>The left hand side of Figure <a class="el" href="index.html#fig__cathedral-fig">Figure 23.2</a> depicts the outer boundary of a cathedral, which is a simple polygon with 565 vertices. The right hand side shows the cathedral also with its inner pillars, which is a polygon (with holes) with 1153 vertices. The following table shows the total running time consumption of the computation of all visibility polygons for all vertices of the cathedral.</p>
<center> <table class="doxtable">
<tr>
<th>Boundary Cathedral </th><th>total preprocessing time </th><th>total query time  </th></tr>
<tr>
<td><code><a class="el" href="classCGAL_1_1Simple__polygon__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a simple polyg...">Simple_polygon_visibility_2</a></code> </td><td>- </td><td>0.38 </td></tr>
<tr>
<td><code><a class="el" href="classCGAL_1_1Rotational__sweep__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a polygon that...">Rotational_sweep_visibility_2</a></code> </td><td>- </td><td>1.01 </td></tr>
<tr>
<td><code><a class="el" href="classCGAL_1_1Triangular__expansion__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a polygon that...">Triangular_expansion_visibility_2</a></code> </td><td>0.01 </td><td>0.06 </td></tr>
</table>
</center><p>The second table shows the same for the complete cathedral. The table does not report the time for <code><a class="el" href="classCGAL_1_1Simple__polygon__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a simple polyg...">Simple_polygon_visibility_2</a></code> as this algorithm can only handle simple polygons.</p>
<center> <table class="doxtable">
<tr>
<th>Complete Cathedral </th><th>total preprocessing time </th><th>total query time  </th></tr>
<tr>
<td><code><a class="el" href="classCGAL_1_1Rotational__sweep__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a polygon that...">Rotational_sweep_visibility_2</a></code> </td><td>- </td><td>1.91 </td></tr>
<tr>
<td><code><a class="el" href="classCGAL_1_1Triangular__expansion__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a polygon that...">Triangular_expansion_visibility_2</a></code> </td><td>0.01 </td><td>0.04 </td></tr>
</table>
</center><p>Thus, in general we recommend to use <code><a class="el" href="classCGAL_1_1Triangular__expansion__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a polygon that...">Triangular_expansion_visibility_2</a></code> even if the polygon is simple. The main advantage of the algorithm is its locality. After the triangle that contains the query point is located in the triangulation, the algorithm explores neighboring triangles, but only those that are actually seen. In this sense the algorithm can be considered as output sensitive. Note that the <code><a class="el" href="classCGAL_1_1Triangular__expansion__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a polygon that...">Triangular_expansion_visibility_2</a></code> algorithm performs better on the full cathedral since the additional pillars block the view early in many cases. However, if the simple polygon is rather convex (i.e., nearly all boundary is seen) or if only one (or very little) queries are required, using one of the algorithms that does not require preprocessing is advantageous.</p>
<h1><a class="anchor" id="simple_polygon_visibility_example"></a>
Example of Visibility in a Simple Polygon</h1>
<p>The following example shows how to obtain the regularized and non-regularized visibility regions.</p>
<p><a class="anchor" id="fig__simple_example"></a></p><div class="image">
<img src="simple_example.png" alt="simple_example.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__simple_example">Figure 23.3</a>
<p>The visibility region of \( q \) in a simple polygon: (1) non-regularized visibility; and (2) regularized visibility.  </p></div>  <br />
 <br />
<b>File</b> <a class="el" href="Visibility_2_2simple_polygon_visibility_2_8cpp-example.html">Visibility_2/simple_polygon_visibility_2.cpp</a> <div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_polygon_visibility_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_naive_point_location.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;istream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>               <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                                 Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a>                                               Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                              Traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                                   Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#ad64170c3b8b8c4af16a4fb742bf56d48">Arrangement_2::Face_handle</a>                                      Face_handle;</div><div class="line"><span class="keyword">typedef</span> Arrangement_2::Edge_const_iterator                              Edge_const_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#ab4a594c193ca09a672dbe2fcafa090e9">Arrangement_2::Ccb_halfedge_circulator</a>                          Ccb_halfedge_circulator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">//create environment</span></div><div class="line">  Point_2 p1(0,4), p2(0,0), p3(3,2), p4(4,0), p5(4,4), p6(1,2);</div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  segments.push_back(Segment_2(p1, p2));</div><div class="line">  segments.push_back(Segment_2(p2, p3));</div><div class="line">  segments.push_back(Segment_2(p3, p4));</div><div class="line">  segments.push_back(Segment_2(p4, p5));</div><div class="line">  segments.push_back(Segment_2(p5, p6));</div><div class="line">  segments.push_back(Segment_2(p6, p1));</div><div class="line"></div><div class="line">  Arrangement_2 env;</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangement2Funcs.html#gad4aa37a4e938747028690579fb703d67">CGAL::insert_non_intersecting_curves</a>(env,segments.begin(),segments.end());</div><div class="line"></div><div class="line">  <span class="comment">// find the face of the query point </span></div><div class="line">  <span class="comment">// (usually you may know that by other means)</span></div><div class="line">  Point_2 q(0.5, 2);</div><div class="line">  Arrangement_2::Face_const_handle * face;</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__naive__point__location.html">CGAL::Arr_naive_point_location&lt;Arrangement_2&gt;</a> pl(env);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Arr_point_location_result&lt;Arrangement_2&gt;::Type</a> obj = pl.locate(q);</div><div class="line">  <span class="comment">// The query point locates in the interior of a face</span></div><div class="line">  face = boost::get&lt;Arrangement_2::Face_const_handle&gt; (&amp;obj);</div><div class="line">  </div><div class="line">  <span class="comment">// compute non regularized visibility area  </span></div><div class="line">  <span class="comment">// Define visibiliy object type that computes non-regularized visibility area</span></div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Simple__polygon__visibility__2.html">CGAL::Simple_polygon_visibility_2&lt;Arrangement_2, CGAL::Tag_false&gt;</a> NSPV;</div><div class="line">  Arrangement_2 non_regular_output;</div><div class="line">  NSPV non_regular_visibility(env);</div><div class="line"></div><div class="line">  non_regular_visibility.compute_visibility(q, *face, non_regular_output);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Non-regularized visibility region of q has "</span></div><div class="line">            &lt;&lt; non_regular_output.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">" edges:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (Edge_const_iterator eit = non_regular_output.edges_begin(); eit != non_regular_output.edges_end(); ++eit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; eit-&gt;source()-&gt;point() &lt;&lt; <span class="stringliteral">" -&gt; "</span> &lt;&lt; eit-&gt;target()-&gt;point() &lt;&lt; <span class="stringliteral">"]"</span> &lt;&lt; std::endl;</div><div class="line">   </div><div class="line"></div><div class="line">  <span class="comment">// compute non regularized visibility area </span></div><div class="line">  <span class="comment">// Define visibiliy object type that computes regularized visibility area</span></div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Simple__polygon__visibility__2.html">CGAL::Simple_polygon_visibility_2&lt;Arrangement_2, CGAL::Tag_true&gt;</a> RSPV;</div><div class="line">  Arrangement_2 regular_output;</div><div class="line">  RSPV regular_visibility(env);</div><div class="line"></div><div class="line">  regular_visibility.compute_visibility(q, *face, regular_output);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Regularized visibility region of q has "</span></div><div class="line">            &lt;&lt; regular_output.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">" edges:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (Edge_const_iterator eit = regular_output.edges_begin(); eit != regular_output.edges_end(); ++eit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; eit-&gt;source()-&gt;point() &lt;&lt; <span class="stringliteral">" -&gt; "</span> &lt;&lt; eit-&gt;target()-&gt;point() &lt;&lt; <span class="stringliteral">"]"</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="general_polygon_example"></a>
Example of Visibility in a Polygon with Holes</h1>
<p>The following example shows how to obtain the regularized visibility region using the model <code><a class="el" href="classCGAL_1_1Triangular__expansion__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a polygon that...">Triangular_expansion_visibility_2</a></code>, see <a class="el" href="index.html#fig__general_polygon">Figure 23.4</a>. The arrangement has six bounded faces and an unbounded face. The query point \( q \) is on a vertex. The red arrow denotes the halfedge \( \overrightarrow{pq} \), which also identifies the face in which the visibility region is computed. <a class="anchor" id="fig__general_polygon"></a></p><div class="image">
<img src="general_polygon_example.png" alt="general_polygon_example.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__general_polygon">Figure 23.4</a> The visibility region of \( q \) in a polygon with two holes.  </div>  <br />
 <br />
<b>File</b> <a class="el" href="Visibility_2_2general_polygon_example_8cpp-example.html">Visibility_2/general_polygon_example.cpp</a> <div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangular_expansion_visibility_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define the used kernel and arrangement  </span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>       <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                         Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a>                                       Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                      Traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                           Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> Arrangement_2::Halfedge_const_handle                    Halfedge_const_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#ad64170c3b8b8c4af16a4fb742bf56d48">Arrangement_2::Face_handle</a>                              Face_handle;</div><div class="line"></div><div class="line"><span class="comment">// Define the used visibility class </span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangular__expansion__visibility__2.html">CGAL::Triangular_expansion_visibility_2&lt;Arrangement_2&gt;</a>  TEV;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Defining the input geometry </span></div><div class="line">  Point_2 p1(1,2), p2(12, 3), p3(19,-2), p4(12,6), p5(14,14), p6( 9,5);</div><div class="line">  Point_2 h1(8,3), h2(10, 3), h3( 8, 4), h4(10,6), h5(11, 6), h6(11,7);</div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  segments.push_back(Segment_2(p1,p2));</div><div class="line">  segments.push_back(Segment_2(p2,p3));</div><div class="line">  segments.push_back(Segment_2(p3,p4));</div><div class="line">  segments.push_back(Segment_2(p4,p5));</div><div class="line">  segments.push_back(Segment_2(p5,p6));</div><div class="line">  segments.push_back(Segment_2(p6,p1));</div><div class="line">  </div><div class="line">  segments.push_back(Segment_2(h1,h2));</div><div class="line">  segments.push_back(Segment_2(h2,h3));</div><div class="line">  segments.push_back(Segment_2(h3,h1));</div><div class="line">  segments.push_back(Segment_2(h4,h5));</div><div class="line">  segments.push_back(Segment_2(h5,h6));</div><div class="line">  segments.push_back(Segment_2(h6,h4));</div><div class="line">  </div><div class="line">  <span class="comment">// insert geometry into the arrangement </span></div><div class="line">  Arrangement_2 env;</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangement2Funcs.html#gad4aa37a4e938747028690579fb703d67">CGAL::insert_non_intersecting_curves</a>(env,segments.begin(),segments.end());</div><div class="line">  </div><div class="line">  <span class="comment">//Find the halfedge whose target is the query point.</span></div><div class="line">  <span class="comment">//(usually you may know that already by other means)  </span></div><div class="line">  Point_2 query_point = p4;</div><div class="line">  Halfedge_const_handle he = env.halfedges_begin();</div><div class="line">  <span class="keywordflow">while</span> (he-&gt;source()-&gt;point() != p3 || he-&gt;target()-&gt;point() != p4)</div><div class="line">    he++;</div><div class="line">  </div><div class="line">  <span class="comment">//visibility query</span></div><div class="line">  Arrangement_2 output_arr;</div><div class="line">  TEV tev(env);</div><div class="line">  Face_handle fh = tev.compute_visibility(query_point, he, output_arr);</div><div class="line">  </div><div class="line">  <span class="comment">//print out the visibility region.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Regularized visibility region of q has "</span></div><div class="line">            &lt;&lt; output_arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">" edges."</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Boundary edges of the visibility region:"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#ab4a594c193ca09a672dbe2fcafa090e9">Arrangement_2::Ccb_halfedge_circulator</a> curr = fh-&gt;outer_ccb();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; curr-&gt;source()-&gt;point() &lt;&lt; <span class="stringliteral">" -&gt; "</span> &lt;&lt; curr-&gt;target()-&gt;point() &lt;&lt; <span class="stringliteral">"]"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">while</span> (++curr != fh-&gt;outer_ccb())</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; curr-&gt;source()-&gt;point() &lt;&lt; <span class="stringliteral">" -&gt; "</span> &lt;&lt; curr-&gt;target()-&gt;point() &lt;&lt; <span class="stringliteral">"]"</span>&lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="implementation_history"></a>
Implementation History</h1>
<p>This package was first developed during Google Summer of Code 2013: Francisc Bungiu developed the <code><a class="el" href="classCGAL_1_1Simple__polygon__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a simple polyg...">CGAL::Simple_polygon_visibility_2</a></code>, Kan Huang developed the <code><a class="el" href="classCGAL_1_1Rotational__sweep__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a polygon that...">CGAL::Rotational_sweep_visibility_2</a></code>, and Michael Hemmer developed the <code><a class="el" href="classCGAL_1_1Triangular__expansion__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a polygon that...">CGAL::Triangular_expansion_visibility_2</a></code>.</p>
<p>During Google Summer of Code 2014 Ning Xu fixed a bug in <code><a class="el" href="classCGAL_1_1Simple__polygon__visibility__2.html" title="This class is a model of the concept Visibility_2 can answer visibility queries within a simple polyg...">CGAL::Simple_polygon_visibility_2</a></code> and improved the testsuite. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:10 for CGAL 4.13 - 2D Visibility by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
