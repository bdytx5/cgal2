<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Generalized_Maps"/><anchor id="index_1ChapterGeneralizedMap"/> <simplesect kind="author"><para>Guillaume Damiand </para></simplesect>
</para><sect1 id="index_1Generalized_mapIntroduction">
<title>Introduction</title>
<para>A <emphasis>d</emphasis>-dimensional generalized map is a data structure representing an orientable or non-orientable subdivided <emphasis>d</emphasis>-dimensional object obtained by taking <emphasis>d</emphasis>D cells, and allowing to glue <emphasis>d</emphasis>D cells along <emphasis>(d-1)</emphasis>D cells. It provides a description of all the cells of the subdivision (for example vertices and edges), together with incidence and adjacency relationships.</para><para>This package is a generalization of the <ref refid="index_1ChapterCombinatorialMap" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">combinatorial maps</ref> data structure (which allows to describe only orientable objects) in order to be able to describe also non-orientable objects such as a Möbius strip (<ref refid="index_1fig__fig_gmap_non_orientable_objects" kindref="member">fig__fig_gmap_non_orientable_objects</ref> Left) or a Klein bottle (<ref refid="index_1fig__fig_gmap_non_orientable_objects" kindref="member">fig__fig_gmap_non_orientable_objects</ref> Right).</para><para><anchor id="index_1fig__fig_gmap_non_orientable_objects"/><image type="html" name="gmap_non_orientable_objects.png"></image>
 <image type="latex" name="gmap_non_orientable_objects.png" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_non_orientable_objects" kindref="member">fig__fig_gmap_non_orientable_objects</ref> Example of two non-orientable objects. Left: A Möbius strip. Right: A Klein bottle.  <linebreak/>
</para><para>We denote <emphasis>i</emphasis>-cell for an <emphasis>i</emphasis>-dimensional cell (for example in 3D, 0-cells are <emphasis>vertices</emphasis>, 1-cells are <emphasis>edges</emphasis>, 2-cells are <emphasis>facets</emphasis>, and 3-cells are <emphasis>volumes</emphasis>). A <emphasis>boundary relation</emphasis> is defined on these cells, giving for each <emphasis>i</emphasis>-cell <emphasis>c</emphasis> the set of <emphasis>(i-1)</emphasis>-cells contained in the boundary of <emphasis>c</emphasis>. Two cells <emphasis>c1</emphasis> and <emphasis>c2</emphasis> are <emphasis>incident</emphasis> if there is a path of cells, starting from the cell of highest dimension to the other cell, such that each cell of the path (except the first one) belongs to the boundary of the previous cell in the path. Two <emphasis>i</emphasis>-cells <emphasis>c3</emphasis> and <emphasis>c4</emphasis> are <emphasis>adjacent</emphasis> if there is an <emphasis>(i-1)</emphasis>-cell incident to both <emphasis>c3</emphasis> and <emphasis>c4</emphasis>. You can see an example of a 2D object and a 3D object in <ref refid="index_1fig__fig_gmap_example_subdivisions" kindref="member">fig__fig_gmap_example_subdivisions</ref> showing some cells of the subdivision and some adjacency and incidence relations.</para><para><anchor id="index_1fig__fig_gmap_example_subdivisions"/><image type="html" name="gmap_example_subdivisions.svg"></image>
 <image type="latex" name="gmap_example_subdivisions.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_example_subdivisions" kindref="member">fig__fig_gmap_example_subdivisions</ref> Example of subdivided objects that can be described by generalized maps. Left: A 2D object composed of three facets (2-cells), named <emphasis>f1</emphasis>, <emphasis>f2</emphasis> and <emphasis>f3</emphasis>, nine edges (1-cells) and seven vertices (0-cells). <emphasis>f1</emphasis> and <emphasis>f2</emphasis> are adjacent along edge <emphasis>e1</emphasis>, thus <emphasis>e1</emphasis> is incident both to <emphasis>f1</emphasis> and <emphasis>f2</emphasis>. Vertex <emphasis>v1</emphasis> is incident to edge <emphasis>e1</emphasis>, thus <emphasis>v1</emphasis> is incident to <emphasis>f1</emphasis> and <emphasis>f2</emphasis> by transitivity. Right: A 3D object (only partially represented for vertices and edges) composed of three volumes (3-cells), named <emphasis>vol1</emphasis>, <emphasis>vol2</emphasis> and <emphasis>vol3</emphasis>, twelve facets (2-cells) (there is one facet <emphasis>f4</emphasis> between <emphasis>vol1</emphasis> and <emphasis>vol2</emphasis>, and similarly between <emphasis>vol1</emphasis> and <emphasis>vol3</emphasis> and <emphasis>vol2</emphasis> and <emphasis>vol3</emphasis>), sixteen edges (1-cells), and eight vertices (0-cells). <emphasis>vol1</emphasis> and <emphasis>vol2</emphasis> are adjacent along facet <emphasis>f4</emphasis>, thus <emphasis>f4</emphasis> is incident both to <emphasis>vol1</emphasis> and <emphasis>vol2</emphasis>. Edge <emphasis>e4</emphasis> is incident to the three facets between <emphasis>vol1</emphasis> and <emphasis>vol2</emphasis>, <emphasis>vol1</emphasis> and <emphasis>vol3</emphasis>, and <emphasis>vol2</emphasis> and <emphasis>vol3</emphasis>. <emphasis>e4</emphasis> is also incident to the three volumes by transitivity.  <linebreak/>
</para><para>A generalized map is an edge-centered data structure, describing the cells and the incidence and adjacency relations. It uses only one basic element called <emphasis>dart</emphasis>, and a set of <emphasis>pointers</emphasis> between these darts. A dart can be thought as a part of an edge (1-cell), together with a part of incident cells of dimensions 0, 2, 3, ..., <emphasis>d</emphasis>. When a dart <emphasis>d0</emphasis> describes a part of an <emphasis>i</emphasis>-cell <emphasis>c</emphasis>, we say that <emphasis>d0</emphasis> <emphasis>belongs</emphasis> to <emphasis>c</emphasis>, and that <emphasis>c</emphasis> <emphasis>contains</emphasis> <emphasis>d0</emphasis>. Let us look at the example in <ref refid="index_1fig__fig_gmap_examples" kindref="member">fig__fig_gmap_examples</ref> showing the 2D and 3D generalized maps describing the two objects of <ref refid="index_1fig__fig_gmap_example_subdivisions" kindref="member">fig__fig_gmap_example_subdivisions</ref>.</para><para><anchor id="index_1fig__fig_gmap_examples"/><image type="html" name="gmap_examples.svg"></image>
 <image type="latex" name="gmap_examples.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_examples" kindref="member">fig__fig_gmap_examples</ref> Generalized maps representing the objects given in <ref refid="index_1fig__fig_gmap_example_subdivisions" kindref="member">fig__fig_gmap_example_subdivisions</ref>. Left: The 2D generalized map which contains 24 darts. Right: The 3D generalized map which contains 108 darts (36 for each volume).  <linebreak/>
</para><para>First let us start in 2D (<ref refid="index_1fig__fig_gmap_examples" kindref="member">fig__fig_gmap_examples</ref> (Left)). Edge <emphasis>e1</emphasis> contains four darts. These darts are linked together with pointers called <formula id="3">$ \alpha_0$</formula> and <formula id="17">$ \alpha_2$</formula>. Starting from a dart and following an <formula id="3">$ \alpha_0$</formula> pointer, we get to a dart which belongs to the same edge, to the same facet but to the other vertex (0-cell, which explains the index 0 of <formula id="3">$ \alpha_0$</formula>). Starting from a dart and following an <formula id="17">$ \alpha_2$</formula> pointer, we get to a dart which belongs to the same vertex, to the same edge but to the other facet (2-cell, which explains the index 2).</para><para>Facet <emphasis>f1</emphasis> is represented by four edges, and thus contains eight darts. The edges are linked together with pointers called <formula id="3">$ \alpha_0$</formula> and <formula id="15">$ \alpha_1$</formula>. Starting from a dart and following an <formula id="15">$ \alpha_1$</formula> pointer, we get to a dart which belongs to the same vertex, the same facet but to the other edge (1-cell, which explains the index 1 of <formula id="15">$ \alpha_1$</formula>).</para><para>Similarly, vertex <emphasis>v1</emphasis> contains six darts, linked together with pointers <formula id="15">$ \alpha_1$</formula> and <formula id="17">$ \alpha_2$</formula>.</para><para>The main interest of generalized map definition based on darts and <formula id="14">$ \alpha_i$</formula> pointers is to be able to increase the dimension <emphasis>only</emphasis> by adding new pointers. This is illustrated thanks to the 3D example given in <ref refid="index_1fig__fig_gmap_examples" kindref="member">fig__fig_gmap_examples</ref> (Right). In addition to <formula id="3">$ \alpha_0$</formula>, <formula id="15">$ \alpha_1$</formula> and <formula id="17">$ \alpha_2$</formula> of the 2D case, there is a new pointer <formula id="16">$ \alpha_3$</formula>.</para><para>If we take a closer look at the central edge <emphasis>e4</emphasis> shown in <ref refid="index_1fig__fig_gmap_examples_zoom" kindref="member">fig__fig_gmap_examples_zoom</ref> (Left), we can see that it contains twelve darts linked together. Starting from a dart and following an <formula id="16">$ \alpha_3$</formula> pointer, we get to a dart which belongs to the same vertex, to the same edge, to the same facet, but to the neighboring volume (a 3-cell, which explains the index 3 in <formula id="16">$ \alpha_3$</formula>). Similarly, starting from a dart and following an <formula id="17">$ \alpha_2$</formula> pointer, we get to a dart which belongs to the same vertex, to the same edge, to the same volume, but to the neighboring facet (2-cell). And starting from a dart and following an <formula id="3">$ \alpha_0$</formula> pointer, we get to a dart which belongs to the same edge, to the same facet, to the same volume, but to the neighboring vertex (0-cell). Starting from any of these twelve darts and following <formula id="3">$ \alpha_0$</formula>, <formula id="17">$ \alpha_2$</formula> and <formula id="16">$ \alpha_3$</formula> pointers, we can reach exactly the twelve darts that belong to edge <emphasis>e4</emphasis>.</para><para><anchor id="index_1fig__fig_gmap_examples_zoom"/><image type="html" name="gmap_examples_zoom.svg"></image>
 <image type="latex" name="gmap_examples_zoom.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_examples_zoom" kindref="member">fig__fig_gmap_examples_zoom</ref> Two zooms on the 3D generalized map given in <ref refid="index_1fig__fig_gmap_examples" kindref="member">fig__fig_gmap_examples</ref> (Right). Left: Zoom around the central edge <emphasis>e4</emphasis> which details the twelve darts belonging to the edge. Right: Zoom around the facet between volumes <emphasis>vol2</emphasis> and <emphasis>vol3</emphasis> which details the sixteen darts belonging to the facet.  <linebreak/>
</para><para>For facets, by following an <formula id="15">$ \alpha_1$</formula> pointer, we get to a dart which belongs to the same vertex, to the same facet, to the same volume, but to the next edge (1-cell, which explains the index 1 of <formula id="15">$ \alpha_1$</formula>). Starting from any dart and following <formula id="3">$ \alpha_0$</formula>, <formula id="15">$ \alpha_1$</formula> and <formula id="16">$ \alpha_3$</formula> pointers, we can reach exactly all the darts belonging to the facet (see <ref refid="index_1fig__fig_gmap_examples_zoom" kindref="member">fig__fig_gmap_examples_zoom</ref> (Right)). For volumes, starting from any dart and following <formula id="3">$ \alpha_0$</formula>, <formula id="15">$ \alpha_1$</formula> and <formula id="17">$ \alpha_2$</formula> pointers, we can reach exactly all the darts belonging to the volume. For vertices, we have to follow <formula id="15">$ \alpha_1$</formula>, <formula id="17">$ \alpha_2$</formula> and <formula id="16">$ \alpha_3$</formula> pointers to reach exactly the darts belonging to the vertex <emphasis>v</emphasis>.</para><para>In some cases, the general rule that by following an <formula id="14">$ \alpha_i$</formula> we get a dart which belongs to the neighboring <emphasis>i</emphasis>-cell is not true, as for example for darts belonging to the boundary of the represented object. For example, in <ref refid="index_1fig__fig_gmap_example_subdivisions" kindref="member">fig__fig_gmap_example_subdivisions</ref> (Left), any dart <emphasis>d0</emphasis> that does not belong to edge <emphasis>e1</emphasis>, <emphasis>e2</emphasis> and <emphasis>e3</emphasis> belongs to a 2-cell, and there is no neighboring facet along the edge containing <emphasis>d0</emphasis>. Another example is in <ref refid="index_1fig__fig_gmap_example_subdivisions" kindref="member">fig__fig_gmap_example_subdivisions</ref> (Right), for any dart <emphasis>d0</emphasis> that belongs to facet <emphasis>f5</emphasis>. <emphasis>d0</emphasis> belongs to volume <emphasis>vol2</emphasis>, but there is no neighboring volume along this facet. The general rule is also not true for unbounded cells. For example if we remove a dart in <ref refid="index_1fig__fig_gmap_examples" kindref="member">fig__fig_gmap_examples</ref> (Left), we obtain an unbounded facet having one dart without next dart for <formula id="3">$ \alpha_0$</formula>, and one dart without next dart for <formula id="15">$ \alpha_1$</formula>, and if we remove a facet in <ref refid="index_1fig__fig_gmap_examples" kindref="member">fig__fig_gmap_examples</ref> (Right), we obtain an unbounded volume having some darts without neighboring facet for <formula id="17">$ \alpha_2$</formula>. In such a case, the darts are linked with themselves for <formula id="14">$ \alpha_i$</formula> to describe that a dart <emphasis>d0</emphasis> is not linked to another dart in dimension <emphasis>i</emphasis>.</para><para>Generalized maps are defined in any dimension. A -1D generalized map is a set of isolated darts describing isolated vertices. A 0D generalized map is a set of darts paired by <formula id="3">$ \alpha_0$</formula> describing isolated edges. A 1D generalized map describes paths or cycles of darts corresponding to paths or cycles of edges. The most useful cases are 2D and 3D generalized maps. In 2D, a generalized map is a set of surfaces (orientable or not), and in 3D a generalized map is a set of connected volumes. In the following, notions are mainly illustrated in 3D. But it is important to keep in mind that one main interest of generalized maps is their generic definition in any dimension, and that everything presented in this manual is valid in any dimension.</para><para>A <emphasis>d</emphasis>D generalized map is useful when you want to describe <emphasis>d</emphasis>D objects and the adjacency relations between these objects, and you want to be able to efficiency traverse these objects by using the different relations. For example, we can use a 3D generalized map to describe a 3D segmented image: each 3-cell corresponds to a region in the image and each 2-cell corresponds to a contact area between two regions.</para><para>A generalized map does not contain any geometric information. However, this package allows to associate any information to the cells of the generalized map. A specific information, which is often used in practice, consists in adding linear geometry to a generalized map by associating a point to each vertex of the map: this is the object of the <ref refid="index_1ChapterLinearCellComplex" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Linear_cell_complex.tag">Linear cell complex</ref> package (when an object has a point associated to each vertex, each edge is thus a straight line segment, which explains the name <emphasis>linear geometry</emphasis>). The <ref refid="index_1ChapterLinearCellComplex" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Linear_cell_complex.tag">Linear cell complex</ref> package can for example be useful to describe 3D buildings as set of walls, rooms, doors and windows (both combinatorial and geometric descriptions) and all the adjacency relations between these elements allowing for example to move a camera in a given building from rooms to rooms by traversing doors.</para></sect1>
<sect1 id="index_1sec_presentation_gmap">
<title>Data Structure Presentation</title>
<para>In this section, we describe <emphasis>d</emphasis>D generalized maps in terms of data structure and operations. Mathematical definitions are provided in Section <ref refid="index_1sec_definition_gmap" kindref="member">Mathematical Definitions</ref>, and a package description is given in Section <ref refid="index_1secsoftwaredesign_gmap" kindref="member">Software Design</ref>.</para><sect2 id="index_1ssecgenmapanddarts">
<title>Generalized Map and Darts</title>
<para>A <emphasis>d</emphasis>D generalized map is a set of darts <emphasis>D</emphasis>. A dart <emphasis>d0</emphasis> is an element that can be <emphasis>linked</emphasis> with <emphasis>d</emphasis>+1 darts by pointers called <formula id="14">$ \alpha_i$</formula>, with 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>. Dart <emphasis>d0</emphasis> is said <emphasis>i-free</emphasis> when <formula id="14">$ \alpha_i$</formula>(<emphasis>d0</emphasis>)=<emphasis>d0</emphasis>. Each <formula id="14">$ \alpha_i$</formula> is its own inverse, i.e. <formula id="14">$ \alpha_i$</formula>( <formula id="14">$ \alpha_i$</formula>(<emphasis>d0</emphasis>))=<emphasis>d0</emphasis>.</para><para>A generalized map is <emphasis>without i-boundary</emphasis> if there is no <emphasis>i</emphasis>-free dart, and it is <emphasis>without boundary</emphasis> if it is without <emphasis>i</emphasis>-boundary for all dimensions 1 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>.</para><para>We show in <ref refid="index_1fig__fig_gmap_detailed_example" kindref="member">fig__fig_gmap_detailed_example</ref> a 3D object and the corresponding 3D generalized map. This map has 80 darts, some darts being numbered. In this generalized map, we have for example <formula id="3">$ \alpha_0$</formula>(1)=2, <formula id="15">$ \alpha_1$</formula>(1)=8, <formula id="17">$ \alpha_2$</formula>(1)=24, and <formula id="16">$ \alpha_3$</formula>(1)=9. This generalized map is without 0-boundary, without 1-boundary and 2-boundary, but has some 3-boundary, because some darts are 3-free, for example <formula id="16">$ \alpha_3$</formula>(17)=17.</para><para><anchor id="index_1fig__fig_gmap_detailed_example"/><image type="html" name="gmap_detailed_example.svg"></image>
 <image type="latex" name="gmap_detailed_example.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_detailed_example" kindref="member">fig__fig_gmap_detailed_example</ref> Example of a 3D generalized map. Left: A 3D object made of two volumes adjacent along facet <emphasis>f2</emphasis>. Right: The corresponding 3D generalized map. Darts are drawn with dark grey and black segments, black darts being numbered. Two darts linked by <formula id="3">$ \alpha_0$</formula> are drawn aligned and separated by a small gray orthogonal segment (for example <formula id="3">$ \alpha_0$</formula>(1)=2), two darts linked by <formula id="15">$ \alpha_1$</formula> are drawn consecutively and separated by a small gray disk (for example <formula id="15">$ \alpha_1$</formula>(1)=8), and two darts linked by <formula id="17">$ \alpha_2$</formula> are drawn parallel, in reverse orientations, with the little gray segment joining them (for example <formula id="17">$ \alpha_2$</formula>(1)=24). <formula id="16">$ \alpha_3$</formula> pointers are represented by blue segments in this figure (for example <formula id="16">$ \alpha_3$</formula>(1)=9).  <linebreak/>
</para></sect2>
<sect2 id="index_1sseccellsingmap">
<title>Cells as Sets of Darts</title>
<para>A cell in a <emphasis>d</emphasis>D generalized map is implicitly represented by a subset of darts. In this section, we will see how to retrieve all cells containing a given dart, how to retrieve all darts belonging to a cell containing a given dart, and how incidence and adjacency relations are defined in terms of darts.</para><para>The first important property of a generalized map is that each dart belongs to an <emphasis>i</emphasis>-cell, <formula id="21">$ \forall $</formula> <emphasis>i</emphasis>, 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>. For example in 3D, a dart belongs to a vertex, an edge, a facet, and a volume. This means that a 3D generalized map containing an isolated dart contains exactly one vertex, one edge, one facet and one volume.</para><para>The second important property is that cells of a generalized map correspond to specific <emphasis>orbits</emphasis>. Given a set <emphasis>S</emphasis> <formula id="27">$ \subseteq$</formula>{ <formula id="15">$ \alpha_1$</formula>,..., <formula id="7">$ \alpha_d$</formula>} and a dart <emphasis>d0</emphasis>, the <emphasis>orbit</emphasis> <formula id="2">$ \langle{}$</formula> <emphasis>S</emphasis> <formula id="8">$ \rangle{}$</formula>(<emphasis>d0</emphasis>) is the set of darts that can be reached from <emphasis>d0</emphasis> by following any combination of any <formula id="14">$ \alpha_i$</formula>&apos;s in <emphasis>S</emphasis> (to simplify notations, we can use for example <formula id="2">$ \langle{}$</formula> <formula id="15">$ \alpha_1$</formula>, <formula id="28">$ \alpha_4$</formula> <formula id="29">$\rangle{}$</formula>(<emphasis>d0</emphasis>) to denote <formula id="2">$ \langle{}$</formula> <emphasis>S</emphasis> <formula id="8">$ \rangle{}$</formula>(<emphasis>d0</emphasis>) with <emphasis>S</emphasis>={ <formula id="15">$ \alpha_1$</formula>, <formula id="28">$ \alpha_4$</formula>}).</para><para>Given a dart <emphasis>d0</emphasis>, in general, <formula id="14">$ \alpha_i$</formula>(<emphasis>d0</emphasis>) (with 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>) belongs to the same cells as <emphasis>d0</emphasis>, only the <emphasis>i</emphasis>-cell is different. There are two exceptions: <orderedlist>
<listitem>
<para>if <emphasis>d0</emphasis> is <emphasis>i</emphasis>-free, then <formula id="14">$ \alpha_i$</formula>(<emphasis>d0</emphasis>)=<emphasis>d0</emphasis>, the <emphasis>i</emphasis>-cell is not different; </para></listitem>
<listitem>
<para>if <formula id="14">$ \alpha_i$</formula>(<emphasis>d0</emphasis>) belongs to the same <emphasis>i</emphasis>-cell as <emphasis>d0</emphasis> (case of multi-incidence). For example if an edge is an isolated loop, it is incident twice to the same vertex, then given a dart <emphasis>d0</emphasis> belonging to this edge, <formula id="15">$ \alpha_1$</formula>(<emphasis>d0</emphasis>) goes to the next edge, which is in fact the same edge. </para></listitem>
</orderedlist>
</para><para>Since <formula id="14">$ \alpha_i$</formula>(<emphasis>d0</emphasis>) (with 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>) allows to change the current <emphasis>i</emphasis>-cell, all the darts that can be reached from <emphasis>d0</emphasis> by using any combination of <formula id="13">$ \alpha_j$</formula>&apos;s, <formula id="21">$ \forall $</formula> <emphasis>j</emphasis>, 0 <formula id="18">$ \leq $</formula> <emphasis>j</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis> and <emphasis>j</emphasis> <formula id="30">$ \neq $</formula> <emphasis>i</emphasis> are contained in the same <emphasis>i</emphasis>-cell as <emphasis>d0</emphasis>. The <emphasis>i</emphasis>-cell containing <emphasis>d0</emphasis> is defined in terms of orbit by <formula id="2">$ \langle{}$</formula> <formula id="3">$ \alpha_0$</formula>,..., <formula id="31">$ \alpha_{i-1}$</formula>, <formula id="32">$ \alpha_{i+1}$</formula>,..., <formula id="7">$ \alpha_d$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>d0</emphasis>).</para><para>Orbit <formula id="2">$ \langle{}$</formula> <formula id="3">$ \alpha_0$</formula>,..., <formula id="7">$ \alpha_d$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>d0</emphasis>) is the <emphasis>connected component</emphasis> containing dart <emphasis>d0</emphasis>. A generalized map is <emphasis>connected</emphasis> if this set is equal to the set of all the darts of the generalized map.</para><para>A last important property of cells is that for all dimensions <emphasis>i</emphasis> the set of <emphasis>i</emphasis>-cells forms a partition of the set of darts <emphasis>D</emphasis>, i.e. for any <emphasis>i</emphasis>, the union of the sets of darts of all the <emphasis>i</emphasis>-cells is equal to <emphasis>D</emphasis>, and the sets of darts of two different <emphasis>i</emphasis>-cells are disjoint.</para><para>Let us give some examples of cells in 3D, for the 3D generalized map of <ref refid="index_1fig__fig_gmap_detailed_example" kindref="member">fig__fig_gmap_detailed_example</ref> : <itemizedlist>
<listitem>
<para>All the darts belonging to the same vertex can be obtained by any combination of <formula id="15">$ \alpha_1$</formula>, <formula id="17">$ \alpha_2$</formula> and <formula id="16">$ \alpha_3$</formula>: for example vertex <emphasis>v</emphasis> of the object corresponds in the generalized map to the set of darts {1,8,9,16,17,24,25,27,28,29,30,31}. Given any dart belonging to this vertex, we retrieve all the other darts by, for example, a breadth-first traversal. In terms of orbits, this 0-cell corresponds to <formula id="2">$ \langle{}$</formula> <formula id="15">$ \alpha_1$</formula>, <formula id="17">$ \alpha_2$</formula>, <formula id="16">$ \alpha_3$</formula> <formula id="8">$ \rangle{}$</formula>(1). </para></listitem>
<listitem>
<para>All the darts belonging to the same edge can be obtained by any combination of <formula id="3">$ \alpha_0$</formula>, <formula id="17">$ \alpha_2$</formula> and <formula id="16">$ \alpha_3$</formula>: for example edge <emphasis>e</emphasis> of the object corresponds in the generalized map to the set of darts {1,2,9,10,23,24,25,26}. In terms of orbits, this 1-cell corresponds to <formula id="2">$ \langle{}$</formula> <formula id="3">$ \alpha_0$</formula>, <formula id="17">$ \alpha_2$</formula>, <formula id="16">$ \alpha_3$</formula> <formula id="8">$ \rangle{}$</formula>(1). </para></listitem>
<listitem>
<para>All the darts belonging to the same facet can be obtained by any combination of <formula id="3">$ \alpha_0$</formula>, <formula id="15">$ \alpha_1$</formula> and <formula id="16">$ \alpha_3$</formula>: for example facet <emphasis>f2</emphasis> corresponds in the generalized map to the set of darts {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}. Facet <emphasis>f1</emphasis> corresponds to the set of darts {17,18,19,20,21,22,23,24}. Note that these last darts are 3-free since there is no other volume sharing this facet. In terms of orbits, <emphasis>f2</emphasis> corresponds to <formula id="2">$ \langle{}$</formula> <formula id="3">$ \alpha_0$</formula>, <formula id="15">$ \alpha_1$</formula>, <formula id="16">$ \alpha_3$</formula> <formula id="8">$ \rangle{}$</formula>(1) and <emphasis>f1</emphasis> corresponds to <formula id="2">$ \langle{}$</formula> <formula id="3">$ \alpha_0$</formula>, <formula id="15">$ \alpha_1$</formula>, <formula id="16">$ \alpha_3$</formula> <formula id="8">$ \rangle{}$</formula>(17). </para></listitem>
<listitem>
<para>All the darts belonging to the same volume can be obtained by any combination of <formula id="3">$ \alpha_0$</formula>, <formula id="15">$ \alpha_1$</formula> and <formula id="17">$ \alpha_2$</formula>: for example volume <emphasis>vol1</emphasis> corresponds in the generalized map to the set of the 48 darts belonging to the cube. In terms of orbits, <emphasis>vol1</emphasis> corresponds to <formula id="2">$ \langle{}$</formula> <formula id="3">$ \alpha_0$</formula>, <formula id="15">$ \alpha_1$</formula>, <formula id="17">$ \alpha_2$</formula> <formula id="8">$ \rangle{}$</formula>(1). </para></listitem>
</itemizedlist>
</para><para>Using this definition of cells as sets of darts, we can retrieve all the incidence and adjacency relations between the cells of the subdivision in a generalized map. Two cells are <emphasis>incident</emphasis> if the intersection of their two sets of darts is non empty (whatever the dimension of the two cells). Two <emphasis>i</emphasis>-cells <emphasis>c1</emphasis> and <emphasis>c2</emphasis>, 1 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>, are <emphasis>adjacent</emphasis> if there is <emphasis>d1</emphasis> <formula id="26">$ \in $</formula> <emphasis>c1</emphasis> and <emphasis>d2</emphasis> <formula id="26">$ \in $</formula> <emphasis>c2</emphasis> such that <emphasis>d1</emphasis> and <emphasis>d2</emphasis> belong to the same <emphasis>(i-1)</emphasis>-cell.</para><para>In the example of <ref refid="index_1fig__fig_gmap_detailed_example" kindref="member">fig__fig_gmap_detailed_example</ref>, vertex <emphasis>v</emphasis> and edge <emphasis>e</emphasis> are incident since the intersection of the two corresponding sets of darts is {1,9,24,25} <formula id="30">$ \neq $</formula> <formula id="33">$ \emptyset$</formula>. Vertex <emphasis>v</emphasis> is incident to facet <emphasis>f2</emphasis> since the intersection of the two corresponding sets of darts is {1,8,9,16} <formula id="30">$ \neq $</formula> <formula id="33">$ \emptyset$</formula>. Edge <emphasis>e</emphasis> and facet <emphasis>f1</emphasis> are incident since the intersection of the two corresponding sets of darts is {23,24} <formula id="30">$ \neq $</formula> <formula id="33">$ \emptyset$</formula>. Finally, facets <emphasis>f1</emphasis> and <emphasis>f2</emphasis> are adjacent because 1 <formula id="26">$ \in $</formula> <emphasis>f1</emphasis>, 24 <formula id="26">$ \in $</formula> <emphasis>f2</emphasis> and 1 and 24 belong to the same edge.</para><para>We can consider <emphasis>i</emphasis>-cells in a dimension <emphasis>d&apos;</emphasis> with <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d&apos;</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>. The idea is to consider the <emphasis>i</emphasis>-cells as if the generalized map was in <emphasis>d&apos;</emphasis> dimension. For that, we only take into account the <formula id="34">$ \alpha_j $</formula>s for <emphasis>j</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d&apos;</emphasis>. The <emphasis>i</emphasis>-cell containing <emphasis>d0</emphasis> in dimension <emphasis>d&apos;</emphasis> is the orbit <formula id="2">$ \langle{}$</formula> <formula id="3">$ \alpha_0$</formula>,..., <formula id="31">$ \alpha_{i-1}$</formula>, <formula id="32">$ \alpha_{i+1}$</formula>,..., <formula id="35">$ \alpha_{d&apos;}$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>d0</emphasis>). By default, <emphasis>i</emphasis>-cells are considered in dimension <emphasis>d</emphasis>, the dimension of the generalized map.</para><para>In the example of <ref refid="index_1fig__fig_gmap_detailed_example" kindref="member">fig__fig_gmap_detailed_example</ref>, the 2-cell containing dart 1 is facet <emphasis>f2</emphasis> which is the set of darts {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}. If we consider the same 2-cell in dimension 2, we obtain the set of darts {1,2,3,4,5,6,7,8}. Intuitively we <emphasis>forget</emphasis> <formula id="16">$ \alpha_3$</formula> and we obtain the set of darts of the facet containing dart 1 restricted to the volume containing this dart.</para></sect2>
<sect2 id="index_1ssecassociateattributesgmap">
<title>How to Associate Information to Cells</title>
<para>Generalized maps only describe the cells of the subdvision, and all the incidence and adjacency relations between these cells. This is not enough for many applications which need to associate <emphasis>information</emphasis> to cells. This can be geometric or non-geometric information, such as 3D points associated to vertices, the edge length associated to edges, or a color or normal to a facet.</para><para>To answer this need, a generalized map allows to create <emphasis>attributes</emphasis> which are able to store any information, and to associate attributes to cells of the generalized map. We denote <emphasis>i</emphasis>-attributes for the attributes associated with <emphasis>i</emphasis>-cells. Attributes may exist for only some of the dimensions, and if they exist for dimension <emphasis>i</emphasis>, they do not necessarily exist for each of the <emphasis>i</emphasis>-cells. More precisely, <emphasis>i</emphasis>-attributes are associated to <emphasis>i</emphasis>-cells by an injection: <itemizedlist>
<listitem>
<para>two different <emphasis>i</emphasis>-cells are associated to two different <emphasis>i</emphasis>-attributes; </para></listitem>
<listitem>
<para>an <emphasis>i</emphasis>-cell may have no associated <emphasis>i</emphasis>-attribute. </para></listitem>
</itemizedlist>
</para><para>Since <emphasis>i</emphasis>-cells are not explicitely represented in generalized maps, the association between <emphasis>i</emphasis>-cells and <emphasis>i</emphasis>-attributes is transferred to darts: if attribute <emphasis>a</emphasis> is associated to <emphasis>i</emphasis>-cell <emphasis>c</emphasis>, all the darts belonging to <emphasis>c</emphasis> are associated to <emphasis>a</emphasis>.</para><para>We can see two examples of generalized maps having some attributes in <ref refid="index_1fig__fig_gmap_with_attribs" kindref="member">fig__fig_gmap_with_attribs</ref>. In the first example (Left), a 2D generalized map has 1-attributes containing a float, for example corresponding to the length of the associated 1-cell, and 2-attributes containing a color in RGB format. In the second example (Right), a 3D generalized map has 2-attributes containing a color in RGB format.</para><para><anchor id="index_1fig__fig_gmap_with_attribs"/><image type="html" name="gmap_with_attribs.svg"></image>
 <image type="latex" name="gmap_with_attribs.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_with_attribs" kindref="member">fig__fig_gmap_with_attribs</ref> Example of generalized maps with attributes. Attributes are represented by black rectangles containing an information, and association between darts and attributes are represented by small red lines. Left: A 2D generalized map with 1-attributes containing a double, for example corresponding to the length of the 1-cell, and 2-attributes containing a color in RGB format. Only three edges of the generalized map, among the nine, are associated to a 1-attribute. All the 2-cells are associated to a 2-attribute. Right: A 3D generalized map with 2-attributes containing a color in RGB format. Only three 2-cells of the generalized map, among the ten, are associated to a 2-attribute.  <linebreak/>
</para></sect2>
<sect2 id="index_1ssecgenmapvalidity">
<title>Generalized Map Properties</title>
<para>There are some conditions that a generalized map must satisfy to be valid. Some of them have already been given about the <formula id="36">$ \alpha$</formula> pointers (see Section <ref refid="index_1ssecgenmapanddarts" kindref="member">Generalized Map and Darts</ref>) and about the association between darts and attributes (see Section <ref refid="index_1ssecassociateattributesgmap" kindref="member">How to Associate Information to Cells</ref>).</para><para>There is an additional condition related to the type of represented objects, which are <emphasis>quasi-manifold</emphasis> <emphasis>d</emphasis>D objects. A <emphasis>d</emphasis>D quasi-manifold is an object obtained by taking some isolated <emphasis>d</emphasis>-cells, and allowing to glue <emphasis>d</emphasis>-cells along <emphasis>(d-1)</emphasis>-cells. In 2D, quasi-manifolds are manifolds, but this is no longer true in higher dimension as we can see in the example presented in <ref refid="index_1fig__fig_gmap_quasi_manifold" kindref="member">fig__fig_gmap_quasi_manifold</ref>. In this example, the object to the right is not a manifold since the neighborhood of the point <emphasis>p</emphasis> in the object is not homeomorphic to a 3D ball (intuitively, two objects are homeomorphic if each object can be continuously deformed into the second one; in such a case, the two objects have exactly the same topological properties).</para><para><anchor id="index_1fig__fig_gmap_quasi_manifold"/><image type="html" name="gmap_quasi_manifold.svg"></image>
 <image type="latex" name="gmap_quasi_manifold.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_quasi_manifold" kindref="member">fig__fig_gmap_quasi_manifold</ref> Example of a 3D quasi-manifold which is not a manifold. The object to the right is made of the four pyramids (shown to the left) glued together along facets, thus it is a quasi-manifold.  <linebreak/>
</para><para>Generalized maps can only represent quasi-manifolds due to the definition of <formula id="36">$ \alpha$</formula> pointers. As we have seen in Section <ref refid="index_1sseccellsingmap" kindref="member">Cells as Sets of Darts</ref>, <formula id="14">$ \alpha_i$</formula>(<emphasis>d0</emphasis>) (with 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>) belongs to the same cells as <emphasis>d0</emphasis>, only the <emphasis>i</emphasis>-cell is different. In other words, <formula id="14">$ \alpha_i$</formula> links two <emphasis>i</emphasis>-cells that share a common <emphasis>(i-1)</emphasis>-cell: it is not possible to link more than two <emphasis>i</emphasis>-cells along a same <emphasis>(i-1)</emphasis>-cell. For this reason, it is not possible to describe non quasi-manifold objects as those shown in <ref refid="index_1fig__fig_gmap_non_manifolds" kindref="member">fig__fig_gmap_non_manifolds</ref> by generalized maps.</para><para><anchor id="index_1fig__fig_gmap_non_manifolds"/><image type="html" name="gmap_non_manifolds.svg"></image>
 <image type="latex" name="gmap_non_manifolds.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_non_manifolds" kindref="member">fig__fig_gmap_non_manifolds</ref> Three examples of non quasi-manifold objects. Left: A 2D object which is not a quasi-manifold since the two 2-cells share a common vertex but no common 1-cell. Middle: A 3D object which is not a quasi-manifold since is it not only composed by 3D cells glued together (there is an isolated 2-cell in dark gray). Right: A 3D object which is not a quasi-manifold since the two 3-cells share a common edge but no common 2-cell.  <linebreak/>
</para><para>Due to this additional condition, any objects can not be represented by a generalized map but only quasi-manifolds. We need to study now the inverse relation. Does any set of darts linked together by <formula id="14">$ \alpha_i$</formula>&apos;s, with 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis> correspond to a quasi-manifold? As we can see in <ref refid="index_1fig__fig_gmap_non_valid" kindref="member">fig__fig_gmap_non_valid</ref>, the answer is no.</para><para><anchor id="index_1fig__fig_gmap_non_valid"/><image type="html" name="gmap_non_valid.svg"></image>
 <image type="latex" name="gmap_non_valid.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_non_valid" kindref="member">fig__fig_gmap_non_valid</ref> Two examples of darts linked together by some <formula id="3">$ \alpha_0$</formula>, <formula id="15">$ \alpha_1$</formula>, <formula id="17">$ \alpha_2$</formula> and <formula id="16">$ \alpha_3$</formula> which does not represent a 3D quasi-manifold, and thus which are not 3D generalized map. Left: In this example, all the darts are 3-free except <formula id="16">$ \alpha_3$</formula>(1)=a, <formula id="16">$ \alpha_3$</formula>(2)=b, <formula id="16">$ \alpha_3$</formula>(7)=g and <formula id="16">$ \alpha_3$</formula>(8)=h (and vice-versa). Right: In this example, darts 1 to 8 and a to h linked by <formula id="16">$ \alpha_3$</formula> are not in the same order in both 3-cells.  <linebreak/>
</para><para>In the first example (Left), there are two 3-cells (one to the left for the cube, a second to the right for the pyramid) which are <emphasis>partially adjacent</emphasis> along one 2-cell. Indeed, only four darts of the 2-cell are linked by <formula id="16">$ \alpha_3$</formula>. We have <formula id="16">$ \alpha_3$</formula>(1)=a, <formula id="16">$ \alpha_3$</formula>(2)=b, <formula id="16">$ \alpha_3$</formula>(7)=g and <formula id="16">$ \alpha_3$</formula>(8)=h (and vice-versa). This configuration is not possible in a quasi-manifold: two <emphasis>d</emphasis>-cells are always glue along an <emphasis>entire</emphasis> <emphasis>(d-1)</emphasis>-cells.</para><para>But as we can see in the second example (Right), the condition that all the darts of the cell are linked in not sufficient. Indeed, in this example, all the darts of the 2-cell between the cube and the pyramid are linked together by <formula id="16">$ \alpha_3$</formula>. However, this configuration does not correspond to a 3D quasi-manifold. Indeed, the operation of gluing two <emphasis>d</emphasis>-cells along one <emphasis>(d-1)</emphasis>-cell must preserve the structure of the initial <emphasis>(d-1)</emphasis>-cell.</para><para>To avoid these two kinds of configurations, conditions are added on <formula id="36">$ \alpha$</formula> pointers compositions (see Section <ref refid="index_1sec_definition_gmap" kindref="member">Mathematical Definitions</ref>, condition (3) of the definition of generalized maps). Intuitively these conditions say that if two darts are linked by <formula id="14">$ \alpha_i$</formula>, then all the required darts are linked by <formula id="14">$ \alpha_i$</formula> two by two in such a way that neighborhood relations are preserved.</para><para>We say that a generalized map is <emphasis>valid</emphasis> if it satisfies all the conditions on <formula id="36">$ \alpha$</formula> pointers and on association between darts and attributes. High level operations provided on generalized maps ensure that these conditions are always satisfied. Sometimes, it can be useful to use low level operations in a specific algorithm, for example to modify locally a generalized map in a really fast way. In such a case, additional operations may be needed to restore these validity conditions.</para></sect2>
<sect2 id="index_1ssec-comparison-gmaps-with-cmaps">
<title>Comparison with Combinatorial Maps</title>
<para>Generalized maps and <ref refid="index_1ChapterCombinatorialMap" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">combinatorial maps</ref> are very similar: they are both based on darts and functions, and they both allow to represent quasi-manifold <emphasis>n</emphasis>D objects. This explains that they share their main concepts.</para><para>However, they have three main differences. Firstly, generalized maps allow to represent orientable and non-orientable objects while combinatorial maps allow only to represent orientable objects. Secondly, generalized maps are homogeneous in each dimension since all functions are involutions, while combinatorial maps are not homogeneous since one function is a permutation while other ones are involutions. This homogeneity simplifies algorithms for generalized maps since it allows to avoid a specific case for the first dimension. Thirdly, a generalized map requires twice the number of darts of a combinatorial map in order to represent an orientable object.</para><para>Considering these different advantages and drawbacks, you can choose to use generalized maps or combinatorial maps depending on the needs of your application.</para></sect2>
</sect1>
<sect1 id="index_1secsoftwaredesign_gmap">
<title>Software Design</title>
<para>The diagram in <ref refid="index_1fig__fig_gmap_diagramme_class" kindref="member">fig__fig_gmap_diagramme_class</ref> shows the different classes of the package. <computeroutput><ref refid="classCGAL_1_1Generalized__map" kindref="compound">Generalized_map</ref></computeroutput> is the main class (see Section <ref refid="index_1ssecgeneralizedmap" kindref="member">Generalized Maps</ref>). It allows to manage darts and attributes (see Section <ref refid="index_1ssecattributesgmap" kindref="member">Cell Attributes</ref>). Users can customize a generalized map thanks to an items class (see Section <ref refid="index_1ssecitemgmap" kindref="member">Generalized Map Items</ref>), which defines the information associated with darts and the attribute types. These types may be different for different dimensions, and they may also be void (note that the main concepts of <computeroutput><ref refid="classGenericMap" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">GenericMap</ref></computeroutput>, <computeroutput><ref refid="classGenericMapItems" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">GenericMapItems</ref></computeroutput> and <computeroutput><ref refid="classCellAttribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">CellAttribute</ref></computeroutput> are shared between combinatorial maps and generalized maps).</para><para>The darts and attributes are accessed through <emphasis>handles</emphasis>. A handle is a model of the <computeroutput><ref refid="classHandle" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circulator.tag">Handle</ref></computeroutput> concept, thus supporting the two dereference operators <computeroutput>operator*</computeroutput> and <computeroutput>operator-&gt;</computeroutput>. All handles are model of <computeroutput><ref refid="classLessThanComparable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">LessThanComparable</ref></computeroutput> and <computeroutput><ref refid="classHashable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Hashable</ref></computeroutput>, that is they can be used as keys in containers such as <computeroutput>std::map</computeroutput> and <computeroutput>boost::unordered_map</computeroutput>.</para><para><anchor id="index_1fig__fig_gmap_diagramme_class"/><image type="html" name="gmap_diagramme_class.svg"></image>
 <image type="latex" name="gmap_diagramme_class.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_diagramme_class" kindref="member">fig__fig_gmap_diagramme_class</ref> UML diagram of the main classes of the package. k is the number of non void attributes.  <linebreak/>
</para><sect2 id="index_1ssecgeneralizedmap">
<title>Generalized Maps</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Generalized__map" kindref="compound">Generalized_map</ref>&lt;d,Items,Alloc&gt;</computeroutput> is a model of the <computeroutput><ref refid="classGeneralizedMap" kindref="compound">GeneralizedMap</ref></computeroutput> concept which refines the generic concept of <computeroutput><ref refid="classGenericMap" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">GenericMap</ref></computeroutput>. It has three template parameters standing for the dimension of the generalized map (an <computeroutput>unsigned int</computeroutput>), an items class (a model of the <computeroutput><ref refid="classGenericMapItems" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">GenericMapItems</ref></computeroutput> concept), and an allocator which must be a model of the allocator concept of the STL. Default classes are provided for the items and the allocator classes.</para><para>The main role of the class <computeroutput><ref refid="classCGAL_1_1Generalized__map" kindref="compound">Generalized_map</ref></computeroutput> is the storage and the management of darts. It allows to create or remove an isolated dart from the generalized map. The <ref refid="classGenericMap_1ad0ca6f8641bb5dfc4550fba716df0d70" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_handle</computeroutput></ref> type defines a handle to the type of used darts (given in the items class). <computeroutput><ref refid="classCGAL_1_1Generalized__map" kindref="compound">Generalized_map</ref></computeroutput> provides several <emphasis>ranges</emphasis> which allow to iterate over specific subsets of darts of the generalized map (see Section <ref refid="index_1ssecrange" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Iterating over Orbits, Cells, and Attributes</ref>). It also defines several methods to link and to unlink darts by <formula id="14">$ \alpha_i$</formula>s (see Section <ref refid="index_1sseclinkdarts_gmap" kindref="member">Sewing Orbits and Linking Darts</ref>). We said that a dart <emphasis>d0</emphasis> is <emphasis>i</emphasis>-free if <formula id="14">$ \alpha_i$</formula>(<emphasis>d0</emphasis>)=<emphasis>d0</emphasis>. Finally, some high level operations are defined to update the generalized map (see Section <ref refid="index_1ssecoperationsgmap" kindref="member">Removal and Insertion Operations</ref>)</para><para>The second role of the class <computeroutput><ref refid="classCGAL_1_1Generalized__map" kindref="compound">Generalized_map</ref></computeroutput> is the storage and the management of attributes. It allows to create or remove an attribute, and provides methods to associate attributes and cells. A range is defined for each <emphasis>i</emphasis>-attribute allowing to iterate over all the <emphasis>i</emphasis>-attributes of the generalized map. Finally, <computeroutput><ref refid="classCGAL_1_1Generalized__map" kindref="compound">Generalized_map</ref></computeroutput> defines several types allowing to manage the attributes. We can use <ref refid="classGenericMap_1a0d7c2eec818bf0f5e0e4239feff21980" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Generalized_map::Attribute_handle&lt;i&gt;::type</computeroutput></ref> for a handle to the <emphasis>i</emphasis>-attributes (and the const version <ref refid="classGenericMap_1adfc1c9f38230637e6a483d62374af04d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Generalized_map::Attribute_const_handle&lt;i&gt;::type</computeroutput></ref>) and <ref refid="classGenericMap_1a01213a6b36324a8e006d18afc57fc551" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Generalized_map::Attribute_type&lt;i&gt;::type</computeroutput></ref> for the type of the <emphasis>i</emphasis>-attributes.</para><para>All information associated to darts ( <formula id="36">$ \alpha$</formula> links and attributes) are accessed through member functions in <computeroutput><ref refid="classGeneralizedMap" kindref="compound">GeneralizedMap</ref></computeroutput>.</para></sect2>
<sect2 id="index_1ssecitemgmap">
<title>Generalized Map Items</title>
<para>The <computeroutput><ref refid="classGenericMapItems" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">GenericMapItems</ref></computeroutput> concept defines information associated with darts and attribute types of a generalized map. It contains one inner class named <ref refid="classGenericMapItems_1ae25d6c2751d48c79de9f92f106eed684" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_wrapper</computeroutput></ref>, having one template parameter, <computeroutput>Map</computeroutput>, a model of <computeroutput><ref refid="classGenericMap" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">GenericMap</ref></computeroutput> concept. The <ref refid="classGenericMapItems_1ae25d6c2751d48c79de9f92f106eed684" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_wrapper&lt;Map&gt;</computeroutput></ref> class can provide two local types: <computeroutput>Dart_info</computeroutput> for the information associated with darts, and <computeroutput>Attributes</computeroutput> which defines the attributes and their types.</para><para>If <computeroutput>Dart_info</computeroutput> is not defined or if it is equal to <computeroutput>void</computeroutput>, no information is associated with darts.</para><para>The <computeroutput>Attributes</computeroutput> tuple must contain at most <emphasis>d</emphasis>+1 types (one for each possible cell dimension of the generalized map). Each type of the tuple must be either a model of the <computeroutput><ref refid="classCellAttribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">CellAttribute</ref></computeroutput> concept or <computeroutput>void</computeroutput>. The first type corresponds to 0-attributes, the second to 1-attributes and so on. If the <emphasis>i <superscript>th</superscript></emphasis> type in the tuple is <computeroutput>void</computeroutput>, <emphasis>(i-1)</emphasis>-attributes are disabled: we say that <emphasis>(i-1)</emphasis>-attributes are <emphasis>void</emphasis>. Otherwise, <emphasis>(i-1)</emphasis>-attributes are enabled and have the given type: we say <emphasis>(i-1)</emphasis>-attributes are <emphasis>non void</emphasis>. If the size of the tuple is <emphasis>k</emphasis>, with <emphasis>k</emphasis> <formula id="37">$ &lt; $</formula> <ref refid="classGenericMap_1a3480ee52e53430cd773cbc941d7ad9e8" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>dimension</computeroutput></ref> +1, <formula id="21">$ \forall $</formula> <emphasis>i</emphasis>: <emphasis>k</emphasis> <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <ref refid="classGenericMap_1a3480ee52e53430cd773cbc941d7ad9e8" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>dimension</computeroutput></ref>, <emphasis>i</emphasis>-attributes are void. If this type is not defined, all attributes are disabled.</para><para>The class <computeroutput><ref refid="structCGAL_1_1Generic__map__min__items" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Generic_map_min_items</ref></computeroutput> is a model of the <computeroutput><ref refid="classGenericMapItems" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">GenericMapItems</ref></computeroutput> concept which can be used for default behaviors. It defines <computeroutput>void</computeroutput> as type of information associated with darts, and <computeroutput>Attributes</computeroutput> as empty tuple.</para></sect2>
<sect2 id="index_1ssecattributesgmap">
<title>Cell Attributes</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Cell__attribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Cell_attribute</ref>&lt;Map,Info_,Tag,OnMerge,OnSplit&gt;</computeroutput>, a model of the <computeroutput><ref refid="classCellAttribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">CellAttribute</ref></computeroutput> concept, represents an attribute associated with a cell of a generalized map. The template parameter <computeroutput>Map</computeroutput> must be a model of the <computeroutput><ref refid="classGenericMap" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">GenericMap</ref></computeroutput> concept. The attribute stores a handle to one dart of its associated cell when the template parameter <computeroutput>Tag</computeroutput> is <ref refid="group__PkgStlExtensionUtilities_1gab3e2296107b5d26c32c8183028a217f1" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag"><computeroutput>Tag_true</computeroutput></ref>. <computeroutput>Info_</computeroutput> is the type of information stored in the attribute. It may be <computeroutput>void</computeroutput>. <computeroutput>OnMerge</computeroutput> and <computeroutput>OnSplit</computeroutput> must be either <computeroutput><ref refid="structCGAL_1_1Null__functor" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Null_functor</ref></computeroutput>, or models of the <computeroutput>Binary Function</computeroutput> concept having two references to a model of <computeroutput><ref refid="classCellAttribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">CellAttribute</ref></computeroutput> as type of both parameters and <computeroutput>void</computeroutput> as return type. There are two default parameters for <computeroutput>OnMerge</computeroutput> and <computeroutput>OnSplit</computeroutput>, which are <computeroutput><ref refid="structCGAL_1_1Null__functor" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Null_functor</ref></computeroutput>, a default parameter for <computeroutput>Tag</computeroutput> which is <computeroutput>Tag_true</computeroutput>, and a default parameter for <computeroutput>Info_</computeroutput> which is <computeroutput>void</computeroutput>.</para><para>If <computeroutput>Info_</computeroutput> is different from <computeroutput>void</computeroutput>, the class <computeroutput><ref refid="classCGAL_1_1Cell__attribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Cell_attribute</ref></computeroutput> contains two methods <computeroutput>info()</computeroutput> returning the information contained in the attribute (const and non const version). The information is returned by reference, thus the non const version allows the modification of the information.</para><para>Two attributes are merged when their corresponding cells are merged into one cell during some operation. In this case, the functor <computeroutput>OnMerge</computeroutput> is called, unless it is equal to <computeroutput><ref refid="structCGAL_1_1Null__functor" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Null_functor</ref></computeroutput>. This functor allows the user to define its own custom behavior when two attributes are merged (for example if the information is a color, we can compute the average color of the two initial attributes, and affect this value to the first attribute, see example in Section <ref refid="index_1ssecgenmapwithcolor" kindref="member">Generalized Map With Attributes</ref>). Similarly, the functor <computeroutput>OnSplit</computeroutput> is called when one attribute is split in two, because its corresponding cell is split in two during some operation, unless it is equal to <computeroutput><ref refid="structCGAL_1_1Null__functor" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Null_functor</ref></computeroutput>. In any high level operation, <computeroutput>OnMerge</computeroutput> is called before to start the operation (i.e. before modifying the generalized map), and <computeroutput>OnSplit</computeroutput> is called when the operation is finished (i.e. after all the modifications were made).</para><para>In addition, there are dynamic onmerge and onsplit functions that can be associated to i-attributes, and modified, thanks to the <ref refid="classGenericMap_1a2f7596c483cad45a7e3813be074c0070" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>onmerge_function()</computeroutput></ref> and <ref refid="classGenericMap_1a50cbe1541d64238d3a0e5216c68b595d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>onsplit_function()</computeroutput></ref>. When these functions are set, they are also called in addition to the previous mechanism when two attributes are merged or one attribute is split into two (see example in Section <ref refid="index_1ssecgenmapdynamicattibute" kindref="member">Use of Dynamic Onmerge and Onsplit Functors</ref>).</para><para>What we said for the dart also holds for the cell attribute. The generalized map can be used with any user defined model of the <computeroutput><ref refid="classCellAttribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">CellAttribute</ref></computeroutput> concept.</para></sect2>
<sect2 id="index_1ssecexampledefgmap">
<title>Example of Generalized Map Definition</title>
<para>Here comes an example of two generalized map definitions. The first case <computeroutput>Example_gmap4</computeroutput> defines a 4D generalized map which uses all the default values (<computeroutput><ref refid="structCGAL_1_1Generic__map__min__items" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Generic_map_min_items</ref></computeroutput>). The second example <computeroutput>Example_custom_gmap3</computeroutput> uses its own model of the <computeroutput><ref refid="classGenericMapItems" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">GenericMapItems</ref></computeroutput> concept. In this model, a <computeroutput>double</computeroutput> is associated as information on darts, and an attribute containing an integer is associated to edges.</para><para><programlisting><codeline><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Generalized__map" kindref="compound">CGAL::Generalized_map&lt;4&gt;</ref><sp/>Example_gmap4;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Example_items_3</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>GMap&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Dart_wrapper</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>Dart_info;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Cell__attribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">CGAL::Cell_attribute&lt;GMap, int&gt;</ref><sp/>Edge_attrib;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1cpp11_1_1tuple" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::tuple&lt;void,Edge_attrib&gt;</ref><sp/>Attributes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Generalized__map" kindref="compound">CGAL::Generalized_map&lt;3, Example_items_3&gt;</ref><sp/>Example_custom_gmap3;</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Generalized_mapIteration">
<title>Iteration and Creation Operations</title>
<para>An important operation in generalized maps consists in iterating over specific subsets of darts or over attributes. For that, several <emphasis>ranges</emphasis> are offered (see Section <ref refid="index_1ssecrange" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Iterating over Orbits, Cells, and Attributes</ref>). A range is a model of the <computeroutput><ref refid="classRange" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circulator.tag">Range</ref></computeroutput> concept, thus supporting the two methods <computeroutput>begin()</computeroutput> and <computeroutput>end()</computeroutput> allowing to iterate over all the elements in the range. Several functions allow to create specific configurations of darts into a generalized map (see Section <ref refid="index_1ssecconstructiongmap" kindref="member">Construction Operations</ref>). Darts can be marked during operations, for example when performing a breadth-first search traversal, thanks to Boolean marks (see Sections <ref refid="index_1ssecadvmarksgmap" kindref="member">Boolean Marks</ref>). In the following, we denote by <computeroutput>dh0</computeroutput>, <computeroutput>dh1</computeroutput>, <computeroutput>dh2</computeroutput> the dart handles for the darts <computeroutput>d0</computeroutput>, <computeroutput>d1</computeroutput>, <computeroutput>d2</computeroutput>, respectively. That is <computeroutput>d0 == *dh0</computeroutput>.</para><sect2 id="index_1ssecrangegmap">
<title>Iterating over Orbits, Cells, and Attributes</title>
<para>The generalized map offers iterators to traverse the darts of a specific orbit, to traverse all darts of one cell, or one dart per cell, and to traverse all <emphasis>i</emphasis>-attributes.</para><para>Instead of the <computeroutput>begin()/end()</computeroutput> member function pair as we know it from STL containers, and from most CGAL data structures, the generalized map defines range classes which are all models of the <computeroutput><ref refid="classRange" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circulator.tag">Range</ref></computeroutput> concept.</para><para>There are three different categories of dart range classes: <itemizedlist>
<listitem>
<para><ref refid="classGenericMap_1a3f67e5f77a6a61281054ee9c1d619c58" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_range</computeroutput></ref>: range of all the darts of a generalized map;</para><para></para></listitem>
<listitem>
<para><ref refid="classGenericMap_1abf73974dbf5e7d9e01c7d8912f58edd3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_of_orbit_range&lt;Alpha...&gt;</computeroutput></ref>: range of all the darts of the orbit <formula id="2">$ \langle{}$</formula><computeroutput>Alpha...</computeroutput> <formula id="8">$ \rangle{}$</formula>(<emphasis>d0</emphasis>) for a given <emphasis>d0</emphasis>. <computeroutput>Alpha...</computeroutput> is a sequence of integers <formula id="38">$ i_1$</formula>,..., <formula id="39">$ i_k$</formula>, each <formula id="40">$ i_j$</formula> <formula id="26">$ \in $</formula> {0, ..., <emphasis>d</emphasis>}. These integers must satisfy: <formula id="38">$ i_1$</formula> <formula id="37">$ &lt; $</formula> <formula id="41">$ i_2$</formula> <formula id="37">$ &lt; $</formula>... <formula id="37">$ &lt; $</formula> <formula id="39">$ i_k$</formula> (for example <ref refid="classGenericMap_1abf73974dbf5e7d9e01c7d8912f58edd3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_of_orbit_range&lt;1,2&gt;</computeroutput></ref> for the orbit <formula id="2">$ \langle{}$</formula> <formula id="15">$ \alpha_1$</formula>, <formula id="17">$ \alpha_2$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>d0</emphasis>));</para><para></para></listitem>
<listitem>
<para><ref refid="classGenericMap_1ab598f5933eb3662863c2e33ae9320d93" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_of_cell_range&lt;i,dim&gt;</computeroutput></ref>: range of all the darts of the <emphasis>i</emphasis>-cell containing a given dart. The <emphasis>i</emphasis>-cell is considered in dimension <computeroutput>dim</computeroutput> (with 0 <formula id="18">$ \leq $</formula> <emphasis>dim</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>, <emphasis>dim</emphasis>=<emphasis>d</emphasis> by default), with 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>dim+1</emphasis>. If <emphasis>i</emphasis>=<emphasis>dim+1</emphasis>, <ref refid="classGenericMap_1ab598f5933eb3662863c2e33ae9320d93" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_of_cell_range&lt;i,dim&gt;</computeroutput></ref> is the range of all the darts of the connected component containing a given dart. </para></listitem>
</itemizedlist>
</para><para>There are also two different classes of ranges containing one dart per <emphasis>i</emphasis>-cell. Note that in these classes, the dart of each <emphasis>i</emphasis>-cell can be any dart of the cell. Moreover, each <emphasis>i</emphasis>-cell (and <emphasis>j</emphasis>-cell in the second case) is considered in dimension <computeroutput>dim</computeroutput> (with 0 <formula id="18">$ \leq $</formula> <emphasis>dim</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>, <emphasis>dim=d</emphasis> by default). <itemizedlist>
<listitem>
<para><ref refid="classGenericMap_1ae9588233426a0e74848af1c8c79cede9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>One_dart_per_cell_range&lt;i,dim&gt;</computeroutput></ref>: range containing one dart of each <emphasis>i</emphasis>-cell of the generalized map, 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>dim+1</emphasis> (for example <ref refid="classGenericMap_1ae9588233426a0e74848af1c8c79cede9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>One_dart_per_cell_range&lt;2&gt;</computeroutput></ref> for the range of one dart per 2-cell of the generalized map);</para><para></para></listitem>
<listitem>
<para><ref refid="classGenericMap_1a6d6212f4fc539c0054a2cfc3387ca096" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>One_dart_per_incident_cell_range&lt;i,j,dim&gt;</computeroutput></ref>: range containing one dart of each <emphasis>i</emphasis>-cell incident to the <emphasis>j</emphasis>-cell containing a given dart, with 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>dim+1</emphasis> and 0 <formula id="18">$ \leq $</formula> <emphasis>j</emphasis> <formula id="18">$ \leq $</formula> <emphasis>dim+1</emphasis> (for example <ref refid="classGenericMap_1a6d6212f4fc539c0054a2cfc3387ca096" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>One_dart_per_incident_cell_range&lt;0,3&gt;</computeroutput></ref> for the range of one dart per vertex of the volume incident to the starting dart). If <emphasis>i</emphasis>=<emphasis>j</emphasis>, the range contains only the given dart. </para></listitem>
</itemizedlist>
</para><para>The iterators of the <ref refid="classGenericMap_1a3f67e5f77a6a61281054ee9c1d619c58" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_range</computeroutput></ref> are bidirectional iterators, while the iterators of the other four ranges are forward iterators. The value type of all these iterators is <computeroutput><ref refid="structCGAL_1_1Dart" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Dart</ref></computeroutput> thus all these iterators can be directly used as <ref refid="classGenericMap_1ad0ca6f8641bb5dfc4550fba716df0d70" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_handle</computeroutput></ref>.</para><para>Additionally, there is a range over non void <emphasis>i</emphasis>-attributes: <ref refid="classGenericMap_1ae567e6737eb1577fb34e43bb257d8776" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Attribute_range&lt;i&gt;::type</computeroutput></ref>, having a bidirectional iterator with value type <ref refid="classGenericMap_1a01213a6b36324a8e006d18afc57fc551" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Attribute_type&lt;i&gt;::type`</ref>.</para><para>For each range, there is an associated const range, a model of the <computeroutput><ref refid="classConstRange" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circulator.tag">ConstRange</ref></computeroutput> concept. You can find some examples of ranges in Section <ref refid="index_1ssecexample3DGM" kindref="member">A 3D Generalized Map</ref>.</para></sect2>
<sect2 id="index_1ssecconstructiongmap">
<title>Construction Operations</title>
<para>Several functions allow to create specific configurations of darts into a generalized map. Existing darts in the generalized map are not modified. Note that the dimension of the generalized map must be large enough: darts must contain all the <formula id="36">$ \alpha$</formula> pointers used by the operation. All these functions return a <ref refid="classGenericMap_1ad0ca6f8641bb5dfc4550fba716df0d70" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_handle</computeroutput></ref> to a new dart created during the operation.</para><para><itemizedlist>
<listitem>
<para><computeroutput>gm.</computeroutput><ref refid="classGenericMap_1a6f455fd64b650495392bddecedbd5afe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>make_edge()</computeroutput></ref>: creates an isolated edge (two darts linked by <formula id="3">$ \alpha_0$</formula>); dimension must be greater or equal than zero; </para></listitem>
<listitem>
<para><computeroutput>gm.</computeroutput><ref refid="classGenericMap_1a3b96033006873f36ea81c51925eb8be1" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>make_combinatorial_polygon(lg)</computeroutput></ref>: creates an isolated combinatorial polygon of length <computeroutput>lg</computeroutput> (<computeroutput>lg</computeroutput> edges linked by <formula id="15">$ \alpha_1$</formula>), for <computeroutput>lg&gt;0</computeroutput>; dimension must be greater or equal than one; </para></listitem>
<listitem>
<para><computeroutput>gm.</computeroutput><ref refid="classGenericMap_1a7f3014036c3fe9d132698f1c92de1f95" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>make_combinatorial_tetrahedron()</computeroutput></ref>: creates an isolated combinatorial tetrahedron (four combinatorial triangles linked together by <formula id="17">$ \alpha_2$</formula>); dimension must be greater or equal than two; </para></listitem>
<listitem>
<para><computeroutput>gm.</computeroutput><ref refid="classGenericMap_1a7dd6108f23e2b12436aa7a809034ec82" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>make_combinatorial_hexahedron()</computeroutput></ref>: creates an isolated combinatorial hexahedron (six combinatorial quadrangles linked together by <formula id="17">$ \alpha_2$</formula>); dimension must be greater or equal than two. </para></listitem>
</itemizedlist>
</para></sect2>
<sect2 id="index_1ssecadvmarksgmap">
<title>Boolean Marks</title>
<para>It is often necessary to mark darts, for example to retrieve in <emphasis>O(1)</emphasis> if a given dart was already processed during a specific algorithm, for example, iteration over a given range. Users can also mark specific parts of a generalized map (for example mark all the darts belonging to objects having specific semantics). To answer these needs, a <computeroutput><ref refid="classGeneralizedMap" kindref="compound">GeneralizedMap</ref></computeroutput> has a certain number of Boolean marks (fixed by the constant <ref refid="classGenericMap_1a6e4ee8b525afeb9bbaed065623e26e68" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>NB_MARKS</computeroutput></ref>). When one wants to use a Boolean mark, the following methods are available (with <computeroutput>gm</computeroutput> an instance of a generalized map): <itemizedlist>
<listitem>
<para>get a new free mark: <computeroutput>size_type m = gm.</computeroutput><ref refid="classGenericMap_1a8c66e1d43055fe732354eedb0f1a780b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>get_new_mark()</computeroutput></ref> (throws the exception Exception_no_more_available_mark if no mark is available); </para></listitem>
<listitem>
<para>set mark <computeroutput>m</computeroutput> for a given dart <computeroutput>d0</computeroutput>: <computeroutput>gm.</computeroutput><ref refid="classGenericMap_1ae444b97ab2983b7cc3fd1b0d6e3dcfe9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>mark(dh0,m)</computeroutput></ref>; </para></listitem>
<listitem>
<para>unset mark <computeroutput>m</computeroutput> for a given dart <computeroutput>d0</computeroutput>: <computeroutput>gm.</computeroutput><ref refid="classGenericMap_1ad55a2a8e0c030a71e3ee0e3be3e15f96" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>unmark(dh0,m)</computeroutput></ref>; </para></listitem>
<listitem>
<para>test if a given dart <computeroutput>d0</computeroutput> is marked for <computeroutput>m</computeroutput>: <computeroutput>gm.</computeroutput><ref refid="classGenericMap_1a27763ddbd462d2a47f48d00f50f31d14" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>is_marked(dh0,m)</computeroutput></ref>; </para></listitem>
<listitem>
<para>unmark all the darts of <computeroutput>gm</computeroutput> for <computeroutput>m</computeroutput>: <computeroutput>gm.</computeroutput><ref refid="classGenericMap_1ab63ba9e899d2c231ba06a95030ecbd2e" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>unmark_all(m)</computeroutput></ref>; </para></listitem>
<listitem>
<para>negate mark <computeroutput>m</computeroutput> of all the darts of <computeroutput>gm</computeroutput>: <computeroutput>gm.</computeroutput><ref refid="classGenericMap_1a9996d3fe87eb7cb6ecaae192312eae89" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>negate_mark(m)</computeroutput></ref>. All the marked darts become unmarked and all the unmarked darts become marked; </para></listitem>
<listitem>
<para>free mark <computeroutput>m</computeroutput>: <computeroutput>gm.</computeroutput><ref refid="classGenericMap_1a7feb8a3d9e53f8c863acf3767886e4c2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>free_mark(m)</computeroutput></ref>. This method unmarks all the darts of <computeroutput>gm</computeroutput> for <computeroutput>m</computeroutput> before freeing it. </para></listitem>
</itemizedlist>
</para><para>It is important to free a mark when it is no longer needed, otherwise you may at some point run out of marks.</para><para>The following example illustrates how to use marks. Two combinatorial tetrahedra are created and 3-sewn (see Section <ref refid="index_1sseclinkdarts_gmap" kindref="member">Sewing Orbits and Linking Darts</ref> for a detailed description of the sew operation). Then a mark is reserved and used to mark all the darts belonging to the first combinatorial tetrahedron. Finally, these tetrahedron are merged. The marks allow us to know which darts come from the first and second tetrahedron.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generalized_map_2gmap_3_marks_8cpp-example" kindref="compound">Generalized_map/gmap_3_marks.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Generalized_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Generalized__map" kindref="compound">CGAL::Generalized_map&lt;3&gt;</ref><sp/>GMap_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>GMap_3::Dart_handle<sp/>Dart_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>GMap_3::size_type<sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GMap_3<sp/>gm;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>1)<sp/>Reserve<sp/>a<sp/>mark.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_type<sp/>amark;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>amark<sp/>=<sp/>gm.get_new_mark();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal"><sp/>(GMap_3::Exception_no_more_available_mark)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr&lt;&lt;</highlight><highlight class="stringliteral">&quot;No<sp/>more<sp/>free<sp/>mark,<sp/>exit.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>2)<sp/>Create<sp/>two<sp/>tetrahedra.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>dh1<sp/>=<sp/>gm.make_combinatorial_tetrahedron();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>dh2<sp/>=<sp/>gm.make_combinatorial_tetrahedron();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>gm.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>gm.is_volume_combinatorial_tetrahedron(dh1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>gm.is_volume_combinatorial_tetrahedron(dh2)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>3)<sp/>3-sew<sp/>them.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.sew&lt;3&gt;(dh1,<sp/>dh2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>4)<sp/>Mark<sp/>the<sp/>darts<sp/>belonging<sp/>to<sp/>the<sp/>first<sp/>tetrahedron.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Mark<sp/>the<sp/>darts<sp/>belonging<sp/>to<sp/>the<sp/>first<sp/>tetrahedron.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::Dart_of_cell_range&lt;3&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it(gm.darts_of_cell&lt;3&gt;(dh1).begin()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend(gm.darts_of_cell&lt;3&gt;(dh1).end());<sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>gm.mark(it,<sp/>amark);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>4)<sp/>Remove<sp/>the<sp/>common<sp/>2-cell<sp/>between<sp/>the<sp/>two<sp/>cubes:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>the<sp/>two<sp/>tetrahedra<sp/>are<sp/>merged.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.remove_cell&lt;2&gt;(dh1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>5)<sp/>Thanks<sp/>to<sp/>the<sp/>mark,<sp/>we<sp/>know<sp/>which<sp/>darts<sp/>come<sp/>from<sp/>the<sp/>first<sp/>tetrahedron.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>res=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::Dart_range::iterator<sp/>it(gm.darts().begin()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend(gm.darts().end());<sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>gm.is_marked(it,<sp/>amark)<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>darts<sp/>from<sp/>the<sp/>first<sp/>tetrahedron:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;res&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.free_mark(amark);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1ssecmodoperations_gmap">
<title>Modification Operations</title>
<para>Several operations allow to modify a given generalized map. There are two main categories of modification operations: <itemizedlist>
<listitem>
<para><ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member">Sew</ref>, <ref refid="classGeneralizedMap_1a6197c4b336eb5d16432ece30eccf95e4" kindref="member">link_alpha</ref>, <ref refid="classGeneralizedMap_1a5bf1efadce33d43e4eb2e32844084591" kindref="member">unsew</ref> and <ref refid="classGeneralizedMap_1a606ad087f9795771924794422bdae1bb" kindref="member">unlink_alpha</ref> which modify some existing <formula id="36">$ \alpha$</formula> pointers, without creating or removing darts (see Section <ref refid="index_1sseclinkdarts_gmap" kindref="member">Sewing Orbits and Linking Darts</ref>); </para></listitem>
<listitem>
<para>Removal and insertion of cells which modify both darts and <formula id="36">$ \alpha$</formula> pointers (see Section <ref refid="index_1ssecoperationsgmap" kindref="member">Removal and Insertion Operations</ref>). </para></listitem>
</itemizedlist>
</para><sect2 id="index_1sseclinkdarts_gmap">
<title>Sewing Orbits and Linking Darts</title>
<para>The <computeroutput><ref refid="classGeneralizedMap" kindref="compound">GeneralizedMap</ref></computeroutput> defines two groups of methods to modify the <formula id="36">$ \alpha$</formula> pointers of existing darts.</para><para>The sew and unsew methods iterate over two orbits in order to link or unlink specific darts two by two. Intuitively, a <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;i&gt;</computeroutput></ref> operation glues two <emphasis>i</emphasis>-cells by identifying two of their <emphasis>(i-1)</emphasis>-cells (see example in <ref refid="index_1fig__fig_gmap_example_3d_sew" kindref="member">fig__fig_gmap_example_3d_sew</ref> where <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;3&gt;</computeroutput></ref> is used to glue two 3-cells along one 2-cell). Reciprocally, a <ref refid="classGeneralizedMap_1a5bf1efadce33d43e4eb2e32844084591" kindref="member"><computeroutput>unsew&lt;i&gt;</computeroutput></ref> operation un-glues two <emphasis>i</emphasis>-cells which were glued along one of their <emphasis>(i-1)</emphasis>-cells. These methods guarantee that given a valid generalized map and a possible operation we obtain a valid generalized map as result of the operation.</para><para></para><para>The <ref refid="classGeneralizedMap_1a6197c4b336eb5d16432ece30eccf95e4" kindref="member"><computeroutput>link_alpha</computeroutput></ref> and <ref refid="classGeneralizedMap_1a606ad087f9795771924794422bdae1bb" kindref="member"><computeroutput>unlink_alpha</computeroutput></ref> methods only modify the pointer of two darts: the obtained generalized maps may be not valid. These operations can be useful to use low level operations in a specific algorithm, for example to modify locally a generalized map in a really fast way. In such a case, additional operations may be needed to restore the validity conditions. </para><para>Linking two darts <emphasis>d1</emphasis> and <emphasis>d2</emphasis> by <formula id="14">$ \alpha_i$</formula>, with 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis> and <emphasis>d1</emphasis> <formula id="30">$ \neq $</formula> <emphasis>d2</emphasis>, consists in modifying two <formula id="14">$ \alpha_i$</formula> pointers such that <formula id="14">$ \alpha_i$</formula>(<emphasis>d1</emphasis>)=<emphasis>d2</emphasis> and <formula id="14">$ \alpha_i$</formula>(<emphasis>d2</emphasis>)=<emphasis>d1</emphasis>.</para><para>Reciprocally, unlinking a given dart <emphasis>d0</emphasis> by <formula id="14">$ \alpha_i$</formula>, with 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>, consists in modifying two <formula id="14">$ \alpha_i$</formula> pointers such that <formula id="14">$ \alpha_i$</formula>( <formula id="14">$ \alpha_i$</formula>(<emphasis>d0</emphasis>))= <formula id="14">$ \alpha_i$</formula>(<emphasis>d0</emphasis>) and <formula id="14">$ \alpha_i$</formula>(<emphasis>d0</emphasis>)=<emphasis>d0</emphasis>. Note that is it possible to unlink a given dart for <formula id="14">$ \alpha_i$</formula> only if it is not <emphasis>i</emphasis>-free.</para><para><anchor id="index_1fig__fig_gmap_example_3d_sew"/><image type="html" name="gmap_example_3d_sew.svg"></image>
 <image type="latex" name="gmap_example_3d_sew.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_example_3d_sew" kindref="member">fig__fig_gmap_example_3d_sew</ref> Example of 3-sew operation. Left: A 3D generalized map containing two volumes that are not connected, with 2-attributes. Each attribute contains a color in RGB format, and there are four 2-cells associated with attributes. Associations between darts and attributes are drawn with red segments. Right: The 3D generalized map obtained as result of <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;3&gt;(1,a)</computeroutput></ref> (or <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;3&gt;(2,b)</computeroutput></ref> ... or <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;3&gt;(8,h)</computeroutput></ref>). Darts (1,a), ..., (8,h) are linked together by <formula id="16">$ \alpha_3$</formula>. The two 2-cells <emphasis>c1</emphasis>={1,...,8} and <emphasis>c2</emphasis>={a,...,h} are merged after the sew into the 2-cell {1,...,8,a,...,h}. We are in the case where the two attributes are non NULL, thus the first one is kept, and all the darts of <emphasis>c2</emphasis> are associated with the first attribute.  <linebreak/>
</para><para>The <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;i&gt;(dh1,dh2)</computeroutput></ref> method consists mainly to link two by two several darts by <formula id="14">$ \alpha_i$</formula>. This operation is possible only if there is a bijection <emphasis>f</emphasis> between all the darts of the orbit <emphasis>D1</emphasis>= <formula id="2">$ \langle{}$</formula> <formula id="15">$ \alpha_1$</formula>,..., <formula id="5">$ \alpha_{i-2}$</formula>, <formula id="6">$ \alpha_{i+2}$</formula>,..., <formula id="7">$ \alpha_d$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>d1</emphasis>) and <emphasis>D2</emphasis>= <formula id="2">$ \langle{}$</formula> <formula id="15">$ \alpha_1$</formula>,..., <formula id="5">$ \alpha_{i-2}$</formula>, <formula id="6">$ \alpha_{i+2}$</formula>,..., <formula id="7">$ \alpha_d$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>d2</emphasis>) satisfying: <emphasis>f</emphasis>(<emphasis>d1</emphasis>)=<emphasis>d2</emphasis>, and for all <emphasis>e</emphasis> <formula id="26">$ \in $</formula> <emphasis>D1</emphasis>, for all <emphasis>j</emphasis> <formula id="26">$ \in $</formula> {1,..., i-2,i+2,...,<emphasis>d</emphasis>}, <emphasis>f</emphasis>( <formula id="13">$ \alpha_j$</formula>(<emphasis>e</emphasis>))= <formula id="42">$ \alpha_j^{-1}$</formula>(<emphasis>f</emphasis>(<emphasis>e</emphasis>)). Intuitively, this condition ensures the validity of the generalized map by verifying that condition discussed in Section <ref refid="index_1ssecgenmapvalidity" kindref="member">Generalized Map Properties</ref> will be satisfied after the operation. This condition can be tested by using the method <ref refid="classGeneralizedMap_1a149d20ef211f5c855ca8a024cffe4f41" kindref="member"><computeroutput>is_sewable&lt;i&gt;(dh1,dh2)</computeroutput></ref>. For example, the function <ref refid="classGeneralizedMap_1a149d20ef211f5c855ca8a024cffe4f41" kindref="member"><computeroutput>is_sewable&lt;3&gt;</computeroutput></ref> would return <computeroutput>false</computeroutput> if we tried to 3-sew a triangular facet with a quad facet. Note that given two darts <emphasis>d1</emphasis> and <emphasis>d2</emphasis>, if there is such a bijection, it is uniquely defined. So giving the two darts as arguments of the <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;i&gt;</computeroutput></ref> is enough to retrieve all the pairs of darts to link. If such a bijection exists, the <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;i&gt;(dh1,dh2)</computeroutput></ref> operation consists only in linking by <formula id="14">$ \alpha_i$</formula> each couple of darts <emphasis>d3</emphasis> and <emphasis>d4</emphasis> such that <emphasis>d3</emphasis>=<emphasis>f</emphasis>(<emphasis>d4</emphasis>).</para><para>In addition, the sew operation updates the associations between darts and non void attributes in order to guarantee that all the darts belonging to a given cell are associated with the same attribute (which is a condition of generalized map validity). For each couple of <emphasis>j</emphasis>-cells <emphasis>c1</emphasis> and <emphasis>c2</emphasis> that are merged into one <emphasis>j</emphasis>-cell during the sew, we have to update the two associated attributes <emphasis>attr1</emphasis> and <emphasis>attr2</emphasis>. If both are NULL, there is nothing to do. If one is NULL and the other not, we only associate the non NULL attribute to all the darts of the resulting cell. When the two attributes are non NULL, we first apply functor <ref refid="classCellAttribute_1a31081515f9da08876797a998f7199b27" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>On_merge</computeroutput></ref> on the two attributes <emphasis>attr1</emphasis> and <emphasis>attr2</emphasis> (see Section <ref refid="index_1ssecattributesgmap" kindref="member">Cell Attributes</ref>). Then, we associate the attribute <emphasis>attr1</emphasis> to all darts of the resulting <emphasis>j</emphasis>-cell. Finally, attribute <emphasis>attr2</emphasis> is removed from the generalized map.</para><para>Note that when the two attributes are non NULL, the first one is kept. But user can customize this behavior in order to update the information contained in the attributes according to its needs. For that, we can define a specific functor, and use it as template argument for <ref refid="classCellAttribute_1a31081515f9da08876797a998f7199b27" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>On_merge</computeroutput></ref> parameter of the <computeroutput><ref refid="classCGAL_1_1Cell__attribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">Cell_attribute</ref></computeroutput> definition. This functor can for example copy the information of the second attribute in the information of the first one to make as if the second attribute is kept.</para><para>For example, in <ref refid="index_1fig__fig_gmap_example_3d_sew" kindref="member">fig__fig_gmap_example_3d_sew</ref>, we want to 3-sew the two initial volumes. <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;3&gt;(1,a)</computeroutput></ref> links by <formula id="16">$ \alpha_3$</formula> the pairs of darts (1,a), ..., (8,g), thus the generalized map obtained is valid. 2-attributes are updated so that all the darts belonging to the 2-cell containing dart 1 become associated to the same 2-attribute after the operation.</para><para>Similarly, <ref refid="classGeneralizedMap_1a5bf1efadce33d43e4eb2e32844084591" kindref="member"><computeroutput>unsew&lt;i&gt;(dh0)</computeroutput></ref> operation unlinks <formula id="14">$ \alpha_i$</formula> for all the darts in the orbit <formula id="2">$ \langle{}$</formula> <formula id="15">$ \alpha_1$</formula>,..., <formula id="5">$ \alpha_{i-2}$</formula>, <formula id="6">$ \alpha_{i+2}$</formula>,..., <formula id="7">$ \alpha_d$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>d0</emphasis>), and thus guarantees to obtain a valid generalized map. This operation is possible for any non <emphasis>i</emphasis>-free dart.</para><para>As for the sew operations, attributes are updated to guarantee that two darts belonging to two different <emphasis>j</emphasis>-cells are associated to two different <emphasis>j</emphasis>-attributes. If the unsew operation splits a <emphasis>j</emphasis>-cell <emphasis>c</emphasis> in two <emphasis>j</emphasis>-cells <emphasis>c1</emphasis> and <emphasis>c2</emphasis>, and if <emphasis>c</emphasis> is associated to a <emphasis>j</emphasis>-attribute <emphasis>attr1</emphasis>, then this attribute is duplicated into <emphasis>attr2</emphasis>, and all the darts belonging to <emphasis>c2</emphasis> are associated with this new attribute. Finally, we call the functor <ref refid="classCellAttribute_1a3b4b722747fa2e6f52331bf92ea4f92f" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>On_split</computeroutput></ref> on the two attributes <emphasis>attr1</emphasis> and <emphasis>attr2</emphasis> (see Section <ref refid="index_1ssecattributesgmap" kindref="member">Cell Attributes</ref>).</para><para>Let us consider the generalized map given in <ref refid="index_1fig__fig_gmap_example_3d_sew" kindref="member">fig__fig_gmap_example_3d_sew</ref> (Right). If we call <ref refid="classGeneralizedMap_1a5bf1efadce33d43e4eb2e32844084591" kindref="member"><computeroutput>unsew&lt;3&gt;(1)</computeroutput></ref>, we obtain the generalized map in <ref refid="index_1fig__fig_gmap_example_3d_sew" kindref="member">fig__fig_gmap_example_3d_sew</ref> (Left) (except for the color of the attribute associated to the 2-cell {a,...,g} which would be <computeroutput>#00ff00</computeroutput>). The <ref refid="classGeneralizedMap_1a5bf1efadce33d43e4eb2e32844084591" kindref="member"><computeroutput>unsew&lt;3&gt;</computeroutput></ref> operation has duplicated the 2-attribute associated to the initial 2-cell {1,...,8,a,...,g} since this 2-cell is split in two after the unsew operation.</para><para></para><para>If one wants to modify a generalized map <emphasis>manually</emphasis>, it is possible to switch off the updating between darts and attributes by calling <ref refid="classGenericMap_1af7fcbe383d43efece8525654b45741bf" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>set_automatic_attributes_management(false)</computeroutput></ref> before to call <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;i&gt;(dh1,dh2)</computeroutput></ref> and <ref refid="classGeneralizedMap_1a5bf1efadce33d43e4eb2e32844084591" kindref="member"><computeroutput>unsew&lt;i&gt;(dh0)</computeroutput></ref>. In these cases, the generalized map obtained may be no longer valid due to incorrect associations between darts and attributes. A call later to <ref refid="classGenericMap_1af7fcbe383d43efece8525654b45741bf" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>set_automatic_attributes_management(true)</computeroutput></ref> will correct the invalid non void attributes.</para><para>In <ref refid="index_1fig__fig_gmap_example_3d_sew" kindref="member">fig__fig_gmap_example_3d_sew</ref> (Left), if we call <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;3&gt;(1,5)</computeroutput></ref>, the resulting generalized map is similar to the generalized map of <ref refid="index_1fig__fig_gmap_example_3d_sew" kindref="member">fig__fig_gmap_example_3d_sew</ref> (Right) (we have linked by <formula id="16">$ \alpha_3$</formula> the pairs of darts (1,a), ..., (8,g), but associations between darts and attributes are not valid. Indeed, we have kept the four initial attributes and all the associations between darts and attributes, thus two darts belonging to the same 2-cell (for example darts 1 and a) are associated with two different attributes.</para><para>We can also use the <ref refid="classGeneralizedMap_1a6197c4b336eb5d16432ece30eccf95e4" kindref="member"><computeroutput>link_alpha&lt;i&gt;(dh1,dh2)</computeroutput></ref> which links <computeroutput>d1</computeroutput> and <computeroutput>d2</computeroutput> by <formula id="14">$ \alpha_i$</formula> without modifying the other links. Association between darts and attributes are only modified for darts <computeroutput>d1</computeroutput> and <computeroutput>d2</computeroutput>, and similarly as for <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;i&gt;</computeroutput></ref>, this updating can be avoided by calling <ref refid="classGenericMap_1af7fcbe383d43efece8525654b45741bf" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>set_automatic_attributes_management(false)</computeroutput></ref> before to call <ref refid="classGeneralizedMap_1a6197c4b336eb5d16432ece30eccf95e4" kindref="member"><computeroutput>link_alpha&lt;i&gt;(dh1,dh2)</computeroutput></ref>. Lastly, we can use <ref refid="classGeneralizedMap_1a606ad087f9795771924794422bdae1bb" kindref="member"><computeroutput>unlink_alpha&lt;i&gt;(dh0)</computeroutput></ref> to unlink <computeroutput>d0</computeroutput> for <formula id="14">$ \alpha_i$</formula>. In this last case, there is no modification of association between darts and attributes.</para><para>In <ref refid="index_1fig__fig_gmap_example_3d_sew" kindref="member">fig__fig_gmap_example_3d_sew</ref> (Left), if we call <ref refid="classGeneralizedMap_1a6197c4b336eb5d16432ece30eccf95e4" kindref="member"><computeroutput>link_alpha&lt;3&gt;(1,a)</computeroutput></ref>, in the resulting generalized map we have now <formula id="16">$ \alpha_3$</formula>(1)=a and <formula id="16">$ \alpha_3$</formula>(a)=1. This generalized map is no longer valid (for example dart 2 is 3-free and we should have <formula id="16">$ \alpha_3$</formula>(2)=b). </para><para>Sewing operations can be used in order to build a non-orientable generalized map. Let us consider the 2D generalized map representing a square given in <ref refid="index_1fig__fig_gmap_sew_non_orientable" kindref="member">fig__fig_gmap_sew_non_orientable</ref> (Left). Two opposite edges of the square can be identified by using the <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;2&gt;</computeroutput></ref> operation. But there are two possibilities to make this identification. The first one, shown in <ref refid="index_1fig__fig_gmap_sew_non_orientable" kindref="member">fig__fig_gmap_sew_non_orientable</ref> (Middle), creates an annulus which is thus orientable. The second one, shown in <ref refid="index_1fig__fig_gmap_sew_non_orientable" kindref="member">fig__fig_gmap_sew_non_orientable</ref> (Right), creates a Möbius strip which is thus non-orientable. The choice of the two darts for the sew operation is thus crucial. See the example <ref refid="index_1ssecexample2DGMNO" kindref="member">A non orientable 2D Generalized Map</ref>.</para><para><anchor id="index_1fig__fig_gmap_sew_non_orientable"/><image type="html" name="gmap_sew_non_orientable.svg"></image>
 <image type="latex" name="gmap_sew_non_orientable.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_sew_non_orientable" kindref="member">fig__fig_gmap_sew_non_orientable</ref> Illustration of the use of the 2-sew operation to construct a non-orientable generalized map. Left: A 2D generalized map <emphasis>M</emphasis> representing a square (one side colored in orange, the other side in green). Middle: the generalized map obtained from <emphasis>M</emphasis> after <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;2&gt;(1,3)</computeroutput></ref>. This map is orientable and corresponds to an annulus. Right: the generalized map obtained from <emphasis>M</emphasis> after <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;2&gt;(1,4)</computeroutput></ref>. This map is non-orientable and corresponds to a Möbius strip.  <linebreak/>
</para></sect2>
<sect2 id="index_1ssecoperationsgmap">
<title>Removal and Insertion Operations</title>
<para>The following high level operations are defined. All these methods ensure that given a valid generalized map and a possible operation, the modified generalized map is also valid.</para><para>The first one is <computeroutput>gm</computeroutput>.<ref refid="classGenericMap_1a389c061e7bd6d6f975ddf35332a86971" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>remove_cell&lt;i&gt;(dh0)</computeroutput></ref> which modifies the generalized map to remove the <emphasis>i</emphasis>-cell containing dart <computeroutput>d0</computeroutput>, with 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>. This operation is possible if <emphasis>i</emphasis>=<emphasis>d</emphasis> or if the given <emphasis>i</emphasis>-cell is incident to at most two <emphasis>(i+1)</emphasis>-cells which can be tested thanks to <computeroutput>gm.</computeroutput><ref refid="classGenericMap_1ae984451f87a342d85838b959525afdb4" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>is_removable&lt;i&gt;(dh0)</computeroutput></ref>. If the removed <emphasis>i</emphasis>-cell was incident to two different <emphasis>(i+1)</emphasis>-cells, these two cells are merged into one <emphasis>(i+1)</emphasis>-cell. In this case, the <ref refid="classCellAttribute_1a31081515f9da08876797a998f7199b27" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>On_merge</computeroutput></ref> functor is called if two <emphasis>(i+1)</emphasis>-attributes are associated to the two <emphasis>(i+1)</emphasis>-cells. If the <emphasis>i</emphasis>-cell is associated with a non void attribute, it is removed from the generalized map (see three examples on <ref refid="index_1fig__fig_gmap_insert_vertex" kindref="member">fig__fig_gmap_insert_vertex</ref>, <ref refid="index_1fig__fig_gmap_insert_edge" kindref="member">fig__fig_gmap_insert_edge</ref> and <ref refid="index_1fig__fig_gmap_insert_facet" kindref="member">fig__fig_gmap_insert_facet</ref>).</para><para><anchor id="index_1fig__fig_gmap_insert_vertex"/><image type="html" name="gmap_insert_vertex.svg"></image>
 <image type="latex" name="gmap_insert_vertex.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_insert_vertex" kindref="member">fig__fig_gmap_insert_vertex</ref> Example of <ref refid="classGenericMap_1a7ca9a5f6c514cdd3c0fdd31e81163774" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_0_in_cell_1</computeroutput></ref> and <ref refid="classGenericMap_1a389c061e7bd6d6f975ddf35332a86971" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>remove_cell&lt;0&gt;</computeroutput></ref> operations. Left: Initial generalized map. Right: After the insertion of a 0-cell in the 1-cell containing dart <computeroutput>d1</computeroutput>. Now if we remove the 0-cell containing dart <computeroutput>d2</computeroutput>, we obtain the initial generalized map.  <linebreak/>
</para><para>The inverse operation of the removal is the insertion operation. Several versions exist, sharing a common principle. They consist in adding a new <emphasis>i</emphasis>-cell <emphasis>inside</emphasis> an existing <emphasis>j</emphasis>-cell, <emphasis>i</emphasis> <formula id="37">$ &lt; $</formula><emphasis>j</emphasis>, by splitting the <emphasis>j</emphasis>-cell into several <emphasis>j</emphasis>-cells. Contrary to <computeroutput>remove_cell&lt;i&gt;</computeroutput>, is it not possible to define a unique <computeroutput>insert_cell_i_in_cell_j&lt;i,j&gt;</computeroutput> function because parameters are different depending on <computeroutput>i</computeroutput> and <computeroutput>j</computeroutput>.</para><para><computeroutput>gm.</computeroutput><ref refid="classGenericMap_1a7ca9a5f6c514cdd3c0fdd31e81163774" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_0_in_cell_1(dh0)</computeroutput></ref> adds a 0-cell in the 1-cell containing dart <computeroutput>d0</computeroutput>. The 1-cell is split in two. This operation is possible if <computeroutput>d0</computeroutput> <formula id="26">$ \in $</formula> <ref refid="classGenericMap_1aebcaaf5b48b571d26a77c74c5583bc1c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>gm.darts()</computeroutput></ref> (see example on <ref refid="index_1fig__fig_gmap_insert_vertex" kindref="member">fig__fig_gmap_insert_vertex</ref>).</para><para><computeroutput>gm.</computeroutput><ref refid="classGenericMap_1a6e286a26bbb5d897e0b830fff3721a8c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_0_in_cell_2(dh0)</computeroutput></ref> adds a 0-cell in the 2-cell containing dart <computeroutput>d0</computeroutput>. The 2-cell is split in triangles, one for each initial edge of the facet. This operation is possible if <computeroutput>d0</computeroutput> <formula id="26">$ \in $</formula> <ref refid="classGenericMap_1aebcaaf5b48b571d26a77c74c5583bc1c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>gm.darts()</computeroutput></ref> (see example on <ref refid="index_1fig__fig_gmap_triangulation" kindref="member">fig__fig_gmap_triangulation</ref>).</para><para><anchor id="index_1fig__fig_gmap_triangulation"/><image type="html" name="gmap_triangulation.svg"></image>
 <image type="latex" name="gmap_triangulation.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_triangulation" kindref="member">fig__fig_gmap_triangulation</ref> Example of <ref refid="classGenericMap_1a6e286a26bbb5d897e0b830fff3721a8c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_0_in_cell_2</computeroutput></ref> operation.  <linebreak/>
</para><para><computeroutput>gm.</computeroutput><ref refid="classGenericMap_1af052e3f6c70a2d691a2bdbccfa9c3908" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_1_in_cell_2(dh1,dh2)</computeroutput></ref> adds a 1-cell in the 2-cell containing darts <computeroutput>d1</computeroutput> and <computeroutput>d2</computeroutput>, between the two 0-cells containing darts <computeroutput>d1</computeroutput> and <computeroutput>d2</computeroutput>. The 2-cell is split in two. This operation is possible if <emphasis>d1</emphasis> <formula id="26">$ \in $</formula> <formula id="2">$ \langle{}$</formula> <formula id="43">$ \alpha_0, \alpha_1$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>d2</emphasis>) which can be tested thanks to <computeroutput>gm.</computeroutput><ref refid="classGenericMap_1abef4982f87b00f703fd19d1309654075" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>is_insertable_cell_1_in_cell_2(dh1,dh2)</computeroutput></ref>. In the example on <ref refid="index_1fig__fig_gmap_insert_edge" kindref="member">fig__fig_gmap_insert_edge</ref>, it is possible to insert an edge between darts <emphasis>d2</emphasis> and <emphasis>d3</emphasis>, but it is not possible to insert an edge between <emphasis>d1</emphasis> and <emphasis>d3</emphasis>.</para><para><anchor id="index_1fig__fig_gmap_insert_edge"/><image type="html" name="gmap_insert_edge.svg"></image>
 <image type="latex" name="gmap_insert_edge.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_insert_edge" kindref="member">fig__fig_gmap_insert_edge</ref> Example of <ref refid="classGenericMap_1af052e3f6c70a2d691a2bdbccfa9c3908" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_1_in_cell_2</computeroutput></ref> and <ref refid="classGenericMap_1a389c061e7bd6d6f975ddf35332a86971" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>remove_cell&lt;1&gt;</computeroutput></ref> operations. Left: Initial generalized map. Right: After the insertion of two 1-cells: a first one between the two 0-cells containing darts <computeroutput>d2</computeroutput> and <computeroutput>d3</computeroutput>, and a second one incident to the 0-cell containing dart <computeroutput>d1</computeroutput>. Now if we remove the two 1-cells containing darts <computeroutput>d4</computeroutput> and <computeroutput>d5</computeroutput>, we obtain the initial generalized map.  <linebreak/>
</para><para><computeroutput>gm.</computeroutput><ref refid="classGenericMap_1a1e129b7060aa80feb689ecf51068e4ca" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_dangling_cell_1_in_cell_2(dh0)</computeroutput></ref> adds a 1-cell in the 2-cell containing dart <computeroutput>d0</computeroutput>, the 1-cell being attached by only one of its vertex to the 0-cell containing dart <computeroutput>d0</computeroutput>. This operation is possible if <computeroutput>d0</computeroutput> <formula id="26">$ \in $</formula> <ref refid="classGenericMap_1aebcaaf5b48b571d26a77c74c5583bc1c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>gm.darts()</computeroutput></ref>.</para><para><computeroutput>gm.</computeroutput><ref refid="classGenericMap_1ae07843054741ac7462b4e90dc945a28b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_2_in_cell_3(itbegin,itend)</computeroutput></ref> adds a 2-cell in the 3-cell containing all the darts between <computeroutput>itbegin</computeroutput> and <computeroutput>itend</computeroutput>, along the path of 1-cells containing darts in [<computeroutput>itbegin</computeroutput>,<computeroutput>itend</computeroutput>). The 3-cell is split in two. This operation is possible if all the darts in [<computeroutput>itbegin</computeroutput>,<computeroutput>itend</computeroutput>) form a closed path inside a same 3-cell which can be tested thanks to <computeroutput>gm.</computeroutput><ref refid="classGenericMap_1ab7cf6baf7cfeb73597a1e4be4df5ec36" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>is_insertable_cell_2_in_cell_3(itbegin,itend)</computeroutput></ref> (see example on <ref refid="index_1fig__fig_gmap_insert_facet" kindref="member">fig__fig_gmap_insert_facet</ref>).</para><para><anchor id="index_1fig__fig_gmap_insert_facet"/><image type="html" name="gmap_insert_facet.svg"></image>
 <image type="latex" name="gmap_insert_facet.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_insert_facet" kindref="member">fig__fig_gmap_insert_facet</ref> Example of <ref refid="classGenericMap_1ae07843054741ac7462b4e90dc945a28b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_2_in_cell_3</computeroutput></ref> and <ref refid="classGenericMap_1a389c061e7bd6d6f975ddf35332a86971" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>remove_cell&lt;2&gt;</computeroutput></ref> operations. Left: Initial generalized map. Right: After the insertion of a 2-cell along the path of 1-cells containing respectively <computeroutput>d1,d2,d3,d4</computeroutput>. Now if we remove the 2-cell containing dart <computeroutput>d5</computeroutput>, we obtain the initial generalized map.  <linebreak/>
</para><para>As the sew operation, insertion operations could create non-orientable generalized map. This is for example the case if we start from the 3D generalized map given in <ref refid="index_1fig__fig_gmap_insert_edge" kindref="member">fig__fig_gmap_insert_edge</ref> (Left) and insert an edge not between darts <computeroutput>d2</computeroutput> and <computeroutput>d3</computeroutput> but between darts <computeroutput>d2</computeroutput> and <formula id="15">$ \alpha_1$</formula>(<computeroutput>d3</computeroutput>).</para><para>Some examples of use of these operations are given in Section <ref refid="index_1ssecexempleoperationsgmap" kindref="member">High Level Operations</ref>.</para><para></para><para>If <ref refid="classGenericMap_1af7fcbe383d43efece8525654b45741bf" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>set_automatic_attributes_management(false)</computeroutput></ref> is called, all the future insertion or removal operations will not update non void attributes. These attributes will be updated later by the call to <ref refid="classGenericMap_1af7fcbe383d43efece8525654b45741bf" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>set_automatic_attributes_management(true)</computeroutput></ref>. This can be useful to speed up an algorithm which uses several successive insertion and removal operations. See example <ref refid="index_1ssecAttributesManagement" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Linear_cell_complex.tag">Automatic attributes management</ref>. </para></sect2>
</sect1>
<sect1 id="index_1Generalized_mapExamples">
<title>Examples</title>
<sect2 id="index_1ssecexample3DGM">
<title>A 3D Generalized Map</title>
<para>In this example, a 3-dimensional generalized map is constructed. Two combinatorial tetrahedra are created, then the numbers of cells of the generalized map are displayed, and the validity of the generalized map is checked. Then, we illustrate the use of ranges to iterate over specific darts. The first loop enumerates all the darts of the first tetrahedron by using the range <ref refid="classGenericMap_1abf73974dbf5e7d9e01c7d8912f58edd3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_of_orbit_range&lt;0,1,2&gt;</computeroutput></ref>, and the second loop enumerates all the darts of the facet containing dart <computeroutput>dh2</computeroutput> by using the range <ref refid="classGenericMap_1abf73974dbf5e7d9e01c7d8912f58edd3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_of_orbit_range&lt;0,1&gt;</computeroutput></ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generalized_map_2gmap_3_simple_example_8cpp-example" kindref="compound">Generalized_map/gmap_3_simple_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Generalized_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Generalized__map" kindref="compound">CGAL::Generalized_map&lt;3&gt;</ref><sp/>GMap_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>GMap_3::Dart_handle<sp/>Dart_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GMap_3<sp/>gm;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>two<sp/>tetrahedra.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_const_handle<sp/>dh1<sp/>=<sp/>gm.make_combinatorial_tetrahedron();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_const_handle<sp/>dh2<sp/>=<sp/>gm.make_combinatorial_tetrahedron();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Display<sp/>the<sp/>generalized<sp/>map<sp/>characteristics.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.display_characteristics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal">&lt;&lt;gm.is_valid()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>res<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Iterate<sp/>through<sp/>all<sp/>the<sp/>darts<sp/>of<sp/>the<sp/>first<sp/>tetrahedron.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>GMap_3::Dart_of_orbit_range&lt;0,1,2&gt;<sp/>in<sp/>3D<sp/>is<sp/>equivalent<sp/>to</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>GMap_3::Dart_of_cell_range&lt;3&gt;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::Dart_of_orbit_range&lt;0,1,2&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it(gm.darts_of_orbit&lt;0,1,2&gt;(dh1).begin()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend(gm.darts_of_orbit&lt;0,1,2&gt;(dh1).end());<sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++res;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>darts<sp/>of<sp/>the<sp/>first<sp/>tetrahedron:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;res&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Iterate<sp/>through<sp/>all<sp/>the<sp/>darts<sp/>of<sp/>the<sp/>face<sp/>incident<sp/>to<sp/>dh2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::Dart_of_orbit_range&lt;0,1&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it(gm.darts_of_orbit&lt;0,1&gt;(dh2).begin()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend(gm.darts_of_orbit&lt;0,1&gt;(dh2).end());<sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++res;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>darts<sp/>of<sp/>the<sp/>face<sp/>incident<sp/>to<sp/>dh2:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;res&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para><para>The output is: <verbatim>#Darts=48, #0-cells=8, #1-cells=12, #2-cells=8, #3-cells=2, #ccs=2, orientable=true, valid=1
Number of darts of the first tetrahedron: 24
Number of darts of the face incident to d1: 6
</verbatim></para><para>which gives the number of darts of the generalized map, the numbers of different cells, the number of connected components, a Boolean showing if the generalized map is orientable or not and finally a Boolean showing the validity of the generalized map (a tetrahedron is made up of 48 darts because there are 12 darts per facet and there are 4 facets).</para><para>Note the creation in the for loops of the two instances of <ref refid="classGenericMap_1abf73974dbf5e7d9e01c7d8912f58edd3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Dart_of_orbit_range</computeroutput></ref>::<computeroutput>const_iterator</computeroutput>: <computeroutput>it</computeroutput> is the current iterator, and <computeroutput>itend</computeroutput> an iterator to the end of the range. Having <computeroutput>itend</computeroutput> avoids calling <ref refid="classGenericMap_1a7063c7bd9d94a3e19d6b39a05f78a00d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>gm.darts_of_orbit&lt;0,1,2&gt;(dh1)</computeroutput></ref><computeroutput>.end()</computeroutput> again and again as in the following example (which is a bad solution):</para><para><programlisting><codeline><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::Dart_of_orbit_range&lt;0,1,2&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>it(gm.darts_of_orbit&lt;0,1,2&gt;(dh1).begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>it!=gm.darts_of_orbit&lt;0,1,2&gt;(dh1).end());<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal">{...}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1ssecexample2DGMNO">
<title>A non orientable 2D Generalized Map</title>
<para>In this example, a square is constructed in a 2-dimensional generalized map. Then two darts belonging to two opposite edges of the square are 2-sewn. Since they darts do not belong to the same orientation of the initial square, this creates a torsion and thus leads to a non orientable generalized map which represents a Möbius strip (cf. <ref refid="index_1fig__fig_gmap_sew_non_orientable" kindref="member">fig__fig_gmap_sew_non_orientable</ref> (Right)).</para><para>The output is: <verbatim>#Darts=8, #0-cells=2, #1-cells=3, #2-cells=1, #ccs=1, orientable=false, valid=1
</verbatim></para><para>showing that the generalized map is non orientable.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generalized_map_2gmap_2_moebius_8cpp-example" kindref="compound">Generalized_map/gmap_2_moebius.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Generalized_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Generalized__map" kindref="compound">CGAL::Generalized_map&lt;2&gt;</ref><sp/>GMap_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>GMap_2::Dart_handle<sp/>Dart_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GMap_2<sp/>gm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>dh=gm.make_combinatorial_polygon(4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.sew&lt;2&gt;(dh,<sp/>gm.alpha&lt;1,0,1,0&gt;(dh));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.display_characteristics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal">&lt;&lt;gm.is_valid()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Generalized_mapHighLevelOperations">
<title>High Level Operations</title>
<para><anchor id="index_1ssecexempleoperationsgmap"/> This example shows some uses of high level operations. First we create a combinatorial hexahedron, the generalized map obtained is shown in <ref refid="index_1fig__fig_gmap_example_insertions" kindref="member">fig__fig_gmap_example_insertions</ref> (Left). Then we insert two 1-cells along two opposite 2-cells of the hexahedron. The generalized map obtained is shown in <ref refid="index_1fig__fig_gmap_example_insertions" kindref="member">fig__fig_gmap_example_insertions</ref> (Middle). Finally, we insert a 2-cell in the diagonal of the hexahedron in order to split it into two parts. We obtain the generalized map shown in <ref refid="index_1fig__fig_gmap_example_insertions" kindref="member">fig__fig_gmap_example_insertions</ref> (Right). We display the characteristics of the generalized map and check its validity.</para><para>The second part of this example removes the inserted elements. First we remove the inserted 2-cell, then the two inserted 1-cells. We get back the initial combinatorial hexahedron, which is verified by displaying once again the characteristics of the generalized map.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generalized_map_2gmap_3_operations_8cpp-example" kindref="compound">Generalized_map/gmap_3_operations.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Generalized_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Generalized__map" kindref="compound">CGAL::Generalized_map&lt;3&gt;</ref><sp/>GMap_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>GMap_3::Dart_handle<sp/><sp/><sp/><sp/><sp/><sp/>Dart_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GMap_3<sp/>gm;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>one<sp/>combinatorial<sp/>hexahedron.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d1<sp/>=<sp/>gm.make_combinatorial_hexahedron();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>two<sp/>edges<sp/>along<sp/>two<sp/>opposite<sp/>facets.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.insert_cell_1_in_cell_2(d1,gm.alpha&lt;0,1,0&gt;(d1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>gm.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d2=gm.alpha&lt;2,1,0,1,2&gt;(d1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.insert_cell_1_in_cell_2(d2,gm.alpha&lt;0,1,0&gt;(d2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>gm.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>facet<sp/>along<sp/>these<sp/>two<sp/>new<sp/>edges<sp/>plus<sp/>two<sp/>initial<sp/>edges</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>of<sp/>the<sp/>hexahedron.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Dart_handle&gt;<sp/>path;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>path.push_back(gm.alpha&lt;1&gt;(d1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>path.push_back(gm.alpha&lt;1,0,1,2,1&gt;(d1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>path.push_back(gm.alpha&lt;1,0&gt;(d2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>path.push_back(gm.alpha&lt;2,1&gt;(d2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d3=gm.insert_cell_2_in_cell_3(path.begin(),path.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>gm.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Display<sp/>the<sp/>generalized<sp/>map<sp/>characteristics.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.display_characteristics(std::cout)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gm.is_valid()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>the<sp/>removal<sp/>operations<sp/>to<sp/>get<sp/>back<sp/>to<sp/>the<sp/>initial<sp/>hexahedron.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.remove_cell&lt;2&gt;(d3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>gm.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.remove_cell&lt;1&gt;(gm.alpha&lt;1&gt;(d1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>gm.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.remove_cell&lt;1&gt;(gm.alpha&lt;1&gt;(d2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>gm.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>gm.is_volume_combinatorial_hexahedron(d1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Display<sp/>the<sp/>generalized<sp/>map<sp/>characteristics.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.display_characteristics(std::cout)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>gm.is_valid()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para><para>The output is: <verbatim>#Darts=72, #0-cells=8, #1-cells=14, #2-cells=9, #3-cells=2, #ccs=1, orientable=true, valid=1
#Darts=48, #0-cells=8, #1-cells=12, #2-cells=6, #3-cells=1, #ccs=1, orientable=true, valid=1
</verbatim></para><para>The first line gives the characteristics of the generalized map after all the insertions (the generalized map drawn in <ref refid="index_1fig__fig_gmap_example_insertions" kindref="member">fig__fig_gmap_example_insertions</ref> (Right)). There are two 3-cells (since the combinatorial hexahedron was split in two by the 2-cell insertion), nine 2-cells (since two 2-cells of the original hexahedron were split in two by the two 1-cell insertions, and a new 2-cell was created during the 2-cell insertion), fourteen 1-cells (since there are two new 1-cells created by the 1-cell insertion) while the number of 0-cells remains unchanged.</para><para>The second line is the result after the removal operations. We retrieve the original combinatorial hexahedron since we have removed all the inserted elements.</para><para><anchor id="index_1fig__fig_gmap_example_insertions"/><image type="html" name="gmap_example_insertions.svg"></image>
 <image type="latex" name="gmap_example_insertions.svg" width="15cm"></image>
  <ref refid="index_1fig__fig_gmap_example_insertions" kindref="member">fig__fig_gmap_example_insertions</ref> Example of high level operations. Left: Initial 3D generalized map after the creation of the generalized hexahedron. Middle: Generalized map obtained after the two 1-cell insertions. The two 2-cells were split in two. Right: Generalized map obtained after the 2-cell insertion. The 3-cell was split in two.  <linebreak/>
</para></sect2>
<sect2 id="index_1Generalized_mapA4DGeneralizedMap">
<title>A 4D Generalized Map</title>
<para>In this example, a 4-dimensional generalized map is used. Two tetrahedral cells are created and sewn by <formula id="28">$ \alpha_4$</formula>. Then the numbers of cells of the generalized map are displayed, and its validity is checked.</para><para>By looking at these numbers of cells, we can see that the 4D generalized map contains only one 3-cell. Indeed, the <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;4&gt;</computeroutput></ref> operation has identified by pairs all the darts of the two 3-cells by definition of the sew operation (see Section <ref refid="index_1sseclinkdarts_gmap" kindref="member">Sewing Orbits and Linking Darts</ref>) which, in 4D, links by <formula id="16">$ \alpha_3$</formula> all the darts in <formula id="2">$ \langle{}$</formula> <formula id="15">$ \alpha_1$</formula>, <formula id="17">$ \alpha_2$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>d1</emphasis>) and in <formula id="2">$ \langle{}$</formula> <formula id="15">$ \alpha_1$</formula>, <formula id="17">$ \alpha_2$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>d2</emphasis>). The situation is similar (but in higher dimension) to the configuration where we have two triangles in a 3D generalized map, and you use <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;3&gt;</computeroutput></ref> between these two triangles. The two triangles are identified since all their darts are linked by <formula id="16">$ \alpha_3$</formula>, thus we obtain a 3D generalized map containing only one 3-cell. Note that this 3-cell is unbounded since the darts of the two triangles are all 2-free. In the 4D case, the 4-cell is unbounded since all its darts are 3-free.</para><para>In this example, we also illustrate how to use the basic methods to build <emphasis>by hand</emphasis> some specific configuration in a generalized map. In fact, these functions are already present in the package: function <computeroutput>make_triangle(gm)</computeroutput> is equivalent to <ref refid="classGenericMap_1a3b96033006873f36ea81c51925eb8be1" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>gm.make_combinatorial_polygon(3)</computeroutput></ref> and <computeroutput>make_tetrahedron(gm)</computeroutput> is equivalent to <ref refid="classGenericMap_1a7f3014036c3fe9d132698f1c92de1f95" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>gm.make_combinatorial_tetrahedron()</computeroutput></ref>. If we want to create a 4D simplex, we must create five 3D simplexes, and sew them correctly two by two by <formula id="16">$ \alpha_3$</formula> (and so on if you want to create higher dimensional generalized map).</para><para><linebreak/>
<bold>File</bold> <ref refid="Generalized_map_2gmap_4_simple_example_8cpp-example" kindref="compound">Generalized_map/gmap_4_simple_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Generalized_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Generalized__map" kindref="compound">CGAL::Generalized_map&lt;4&gt;</ref><sp/>GMap_4;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>GMap_4::Dart_handle<sp/>Dart_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GMap_4<sp/>gm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d1<sp/>=<sp/>gm.make_combinatorial_tetrahedron();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>d2<sp/>=<sp/>gm.make_combinatorial_tetrahedron();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(gm.is_valid());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.sew&lt;4&gt;(d1,d2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.display_characteristics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal">&lt;&lt;gm.is_valid()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The output is: <verbatim>#Darts=48, #0-cells=4, #1-cells=6, #2-cells=4, #3-cells=1, #4-cells=2, #ccs=1, orientable=true, valid=1
</verbatim></para></sect2>
<sect2 id="index_1ssecgenmapwithcolor">
<title>Generalized Map With Attributes</title>
<para>In the following example, we illustrate how to specify the 2-attributes in a 3D generalized map. For that, we define our own item class using <ref refid="classCGAL_1_1Cell__attribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>Cell_attribute&lt;GMap,int,Tag_true,Sum_functor,Divide_by_two_functor&gt;</computeroutput></ref> as attributes which contain an <computeroutput>int</computeroutput> and which are associated to 2-cells of the generalized map.</para><para>Functors <computeroutput>Sum_functor</computeroutput> and <computeroutput>Divide_by_two_functor</computeroutput> define a custom behavior: when two attributes <computeroutput>ca1</computeroutput> and <computeroutput>ca2</computeroutput> are merged into <computeroutput>ca1</computeroutput>, the value of <computeroutput>ca1</computeroutput> is the sum of the two initial values. When an attribute <computeroutput>ca1</computeroutput> is split in the two attributes <computeroutput>ca1</computeroutput> and <computeroutput>ca2</computeroutput>, the value of each attribute is half of the first value.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generalized_map_2gmap_3_with_colored_facets_8cpp-example" kindref="compound">Generalized_map/gmap_3_with_colored_facets.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Generalized_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cell_attribute.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Sum_functor</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Cell_attribute&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(Cell_attribute&amp;<sp/>ca1,Cell_attribute&amp;<sp/>ca2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>ca1.info()=ca1.info()+ca2.info();<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Divide_by_two_functor</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Cell_attribute&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(Cell_attribute&amp;<sp/>ca1,Cell_attribute&amp;<sp/>ca2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ca1.info()=(ca1.info()/2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ca2.info()=(ca1.info());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Myitem</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>GMap&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Dart_wrapper</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Cell__attribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">CGAL::Cell_attribute</ref>&lt;GMap,<sp/>int,<sp/><ref refid="group__PkgStlExtensionUtilities_1gab3e2296107b5d26c32c8183028a217f1" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Tag_true</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>Sum_functor,<sp/>Divide_by_two_functor&gt;<sp/>Facet_attribute;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1cpp11_1_1tuple" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::tuple&lt;void,void,Facet_attribute&gt;</ref><sp/>Attributes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Generalized__map" kindref="compound">CGAL::Generalized_map&lt;3,Myitem&gt;</ref><sp/>GMap_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>GMap_3::Dart_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dart_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GMap_3<sp/>gm;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>2<sp/>hexahedra.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>dh1<sp/>=<sp/>gm.make_combinatorial_hexahedron();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>dh2<sp/>=<sp/>gm.make_combinatorial_hexahedron();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>1)<sp/>Create<sp/>all<sp/>2-attributes<sp/>and<sp/>associated<sp/>them<sp/>to<sp/>darts.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::Dart_range::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it=gm.darts().begin(),<sp/>itend=gm.darts().end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>gm.attribute&lt;2&gt;(it)==NULL<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>gm.set_attribute&lt;2&gt;(it,<sp/>gm.create_attribute&lt;2&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>2)<sp/>Set<sp/>the<sp/>color<sp/>of<sp/>all<sp/>facets<sp/>of<sp/>the<sp/>first<sp/>hexahedron<sp/>to<sp/>7.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::One_dart_per_incident_cell_range&lt;2,<sp/>3&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it=gm.one_dart_per_incident_cell&lt;2,3&gt;(dh1).begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend=gm.one_dart_per_incident_cell&lt;2,3&gt;(dh1).end();<sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>gm.info&lt;2&gt;(it)=7;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>3)<sp/>Set<sp/>the<sp/>color<sp/>of<sp/>all<sp/>facets<sp/>of<sp/>the<sp/>second<sp/>hexahedron<sp/>to<sp/>13.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::One_dart_per_incident_cell_range&lt;2,<sp/>3&gt;::iterator<sp/>it=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>gm.one_dart_per_incident_cell&lt;2,3&gt;(dh2).begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>itend=gm.one_dart_per_incident_cell&lt;2,3&gt;(dh2).end();<sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>gm.info&lt;2&gt;(it)=13;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>4)<sp/>3-Sew<sp/>the<sp/>two<sp/>hexahedra<sp/>along<sp/>one<sp/>facet.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.sew&lt;3&gt;(dh1,<sp/>dh2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>5)<sp/>Display<sp/>all<sp/>the<sp/>values<sp/>of<sp/>2-attributes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::Attribute_range&lt;2&gt;::type::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it=gm.attributes&lt;2&gt;().begin(),<sp/>itend=gm.attributes&lt;2&gt;().end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;gm.info_of_attribute&lt;2&gt;(it)&lt;&lt;</highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>6)<sp/>Insert<sp/>a<sp/>vertex<sp/>in<sp/>the<sp/>facet<sp/>between<sp/>the<sp/>two<sp/>hexahedra.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.insert_cell_0_in_cell_2(dh2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>7)<sp/>Display<sp/>all<sp/>the<sp/>values<sp/>of<sp/>2-attributes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::Attribute_range&lt;2&gt;::type::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it=gm.attributes&lt;2&gt;().begin(),<sp/>itend=gm.attributes&lt;2&gt;().end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;gm.info_of_attribute&lt;2&gt;(it)&lt;&lt;</highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.display_characteristics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal">&lt;&lt;gm.is_valid()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The output is: <verbatim>20; 7; 7; 7; 7; 7; 13; 13; 13; 13; 13;
2; 7; 7; 7; 7; 7; 10; 13; 13; 13; 13; 13; 5; 2;
#Darts=128, #0-cells=13, #1-cells=24, #2-cells=14, #3-cells=2, #ccs=1, orientable=true, valid=1
</verbatim></para><para>Before the <computeroutput>gm.</computeroutput><ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;3&gt;</computeroutput></ref>, each 2-cell of the first cube is associated with an attribute having 7 as value, and each 2-cell of the second cube with an attribute having 13 as value. During the <computeroutput>gm.</computeroutput><ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;3&gt;</computeroutput></ref>, two 2-cells are merged, thus the functor <computeroutput>Sum_functor</computeroutput> is called on the two associated 2-attributes, and the value of the new 2-cell is the sum of the two previous one: 20.</para><para>Then we call <ref refid="classGenericMap_1a6e286a26bbb5d897e0b830fff3721a8c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_0_in_cell_2</computeroutput></ref> on a dart which belong to this 2-cell. This method splits the existing 2-cell in <emphasis>k</emphasis> 2-cells, <emphasis>k</emphasis> being the number of 1-cells of the initial 2-cell (4 in this example). These splits are made consecutively, thus for the first split, we create a new attribute as copy of the initial one and call functor <computeroutput>Divide_by_two_functor</computeroutput> on these two attributes: the value of each attribute is thus 20/2=10. For the second split, the value of each attribute is thus 10/2=5, and for the last split the value of each attribute is thus 5/2=2 (remember that information contained in 2-attributes in an <computeroutput>int</computeroutput>). At the end, we obtain five 2-attributes with 7 as value, five 2-attributes with 13 as value, and four 2-attributes having respectively 2, 2, 5 and 10 as values.</para></sect2>
<sect2 id="index_1ssecgenmapdynamicattibute">
<title>Use of Dynamic Onmerge and Onsplit Functors</title>
<para>In the following example, we show an example of use of dynamic onmerge and onsplit functor. We define our 3D generalized map with 2-attributes. Then we create two hexahedra and create all the 2-attributes, having their info initialized to 1.</para><para>Step 2 defines the onsplit and onmerge dynamic functors. We can see here that with this mechanism, functors can store data member. This is the case in the example for <computeroutput>Split_functor</computeroutput> which stores a reference to the generalized map.</para><para>The next operations will call these functors when 2-cells are split or merged. The <ref refid="classGeneralizedMap_1ab521d38908d046c0883d324fb29ef670" kindref="member"><computeroutput>sew&lt;3&gt;</computeroutput></ref> operation calls 1 onmerge as two faces are identified; the <ref refid="classGenericMap_1a6e286a26bbb5d897e0b830fff3721a8c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag"><computeroutput>insert_cell_0_in_cell_2</computeroutput></ref> operation calls 3 onsplit as one face is split in 4.</para><para>Lastly we remove the dynamic onmerge functor (step 7). This is done by initializing the fonctor to a default boost::function. After this initialization, no dynamic merge functor is called when two faces are merged.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generalized_map_2gmap_3_dynamic_onmerge_8cpp-example" kindref="compound">Generalized_map/gmap_3_dynamic_onmerge.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Generalized_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cell_attribute.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>My<sp/>item<sp/>class:<sp/>no<sp/>static<sp/>functor<sp/>is<sp/>associated<sp/>with<sp/>Face_attribute.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Myitem</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>GMap&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Dart_wrapper</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Cell__attribute" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Combinatorial_map.tag">CGAL::Cell_attribute&lt;GMap, double&gt;</ref><sp/>Face_attribute;<sp/></highlight><highlight class="comment">//<sp/>A<sp/>weight</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1cpp11_1_1tuple" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::tuple&lt;void,void,Face_attribute&gt;</ref><sp/>Attributes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Definition<sp/>of<sp/>my<sp/>generalized<sp/>map.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Generalized__map" kindref="compound">CGAL::Generalized_map&lt;3,Myitem&gt;</ref><sp/>GMap_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>GMap_3::Dart_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dart_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>GMap_3::Attribute_type&lt;2&gt;::type<sp/>Face_attribute;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Functor<sp/>called<sp/>when<sp/>two<sp/>faces<sp/>are<sp/>merged.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Merge_functor</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>operator()<sp/>automatically<sp/>called<sp/>before<sp/>a<sp/>merge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(Face_attribute&amp;<sp/>ca1,<sp/>Face_attribute&amp;<sp/>ca2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ca1.info()=ca1.info()+ca2.info();<sp/></highlight><highlight class="comment">//<sp/>Update<sp/>can<sp/>be<sp/>done<sp/>incrementally.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;After<sp/>on<sp/>merge<sp/>faces:<sp/>info<sp/>of<sp/>face1=&quot;</highlight><highlight class="normal">&lt;&lt;ca1.info()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>info<sp/>of<sp/>face2=&quot;</highlight><highlight class="normal">&lt;&lt;ca2.info()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Functor<sp/>called<sp/>when<sp/>one<sp/>face<sp/>is<sp/>split<sp/>in<sp/>two.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Split_functor</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Split_functor(GMap_3&amp;<sp/>amap)<sp/>:<sp/>mmap(amap)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>operator()<sp/>automatically<sp/>called<sp/>after<sp/>a<sp/>split.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(Face_attribute&amp;<sp/>ca1,<sp/>Face_attribute&amp;<sp/>ca2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>need<sp/>to<sp/>reinitalize<sp/>the<sp/>weight<sp/>of<sp/>the<sp/>two<sp/>faces</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GMap_3::size_type<sp/>nb1=mmap.darts_of_cell&lt;2&gt;(ca1.dart()).size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GMap_3::size_type<sp/>nb2=mmap.darts_of_cell&lt;2&gt;(ca2.dart()).size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mmap.info&lt;2&gt;(ca1.dart())*=(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">(nb1)/(nb1+nb2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mmap.info&lt;2&gt;(ca2.dart())*=(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">(nb2)/(nb1+nb2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;After<sp/>on<sp/>split<sp/>faces:<sp/>info<sp/>of<sp/>face1=&quot;</highlight><highlight class="normal">&lt;&lt;ca1.info()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>info<sp/>of<sp/>face2=&quot;</highlight><highlight class="normal">&lt;&lt;ca2.info()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GMap_3&amp;<sp/>mmap;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Function<sp/>allowing<sp/>to<sp/>display<sp/>all<sp/>the<sp/>2-attributes,<sp/>and<sp/>the<sp/>characteristics</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>of<sp/>a<sp/>given<sp/>combinatorial<sp/>map.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>display_map_and_2attributes(GMap_3&amp;<sp/>gm)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::Attribute_range&lt;2&gt;::type::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it=gm.attributes&lt;2&gt;().begin(),<sp/>itend=gm.attributes&lt;2&gt;().end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>std::cout&lt;&lt;gm.info_of_attribute&lt;2&gt;(it)&lt;&lt;</highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.display_characteristics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;,<sp/>valid=&quot;</highlight><highlight class="normal">&lt;&lt;gm.is_valid()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GMap_3<sp/>gm;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>0)<sp/>Create<sp/>2<sp/>hexahedra.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>dh1<sp/>=<sp/>gm.make_combinatorial_hexahedron();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>dh2<sp/>=<sp/>gm.make_combinatorial_hexahedron();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>1)<sp/>Create<sp/>and<sp/>initialize<sp/>2-attributes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(GMap_3::One_dart_per_cell_range&lt;2&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it=gm.one_dart_per_cell&lt;2&gt;().begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itend=gm.one_dart_per_cell&lt;2&gt;().end();<sp/>it!=itend;<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>gm.set_attribute&lt;2&gt;(it,<sp/>gm.create_attribute&lt;2&gt;(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>2)<sp/>Set<sp/>the<sp/>onsplit<sp/>and<sp/>onmerge<sp/>functors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.onsplit_functor&lt;2&gt;()=Split_functor(gm);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.onmerge_functor&lt;2&gt;()=Merge_functor();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>3)<sp/>3-Sew<sp/>the<sp/>two<sp/>hexahedra<sp/>along<sp/>one<sp/>face.<sp/>This<sp/>calls<sp/>1<sp/>onmerge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.sew&lt;3&gt;(dh1,<sp/>dh2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>4)<sp/>Display<sp/>all<sp/>the<sp/>values<sp/>of<sp/>2-attributes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>display_map_and_2attributes(gm);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>5)<sp/>Insert<sp/>a<sp/>vertex<sp/>in<sp/>the<sp/>face<sp/>between<sp/>the<sp/>two<sp/>hexahedra.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>This<sp/>calls<sp/>3<sp/>onsplit.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dart_handle<sp/>resdart=gm.insert_cell_0_in_cell_2(dh2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>6)<sp/>Display<sp/>all<sp/>the<sp/>values<sp/>of<sp/>2-attributes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>display_map_and_2attributes(gm);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>7)<sp/>&quot;Remove&quot;<sp/>the<sp/>dynamic<sp/>onmerge<sp/>functor.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.onmerge_functor&lt;2&gt;()=boost::function&lt;</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">(Face_attribute&amp;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_attribute&amp;)&gt;();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>8)<sp/>Remove<sp/>one<sp/>edge:<sp/>this<sp/>merges<sp/>two<sp/>faces,<sp/>however<sp/>no<sp/>dynamic</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>functor<sp/>is<sp/>called<sp/>(because<sp/>it<sp/>was<sp/>removed).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>gm.remove_cell&lt;1&gt;(resdart);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>9)<sp/>Display<sp/>all<sp/>the<sp/>values<sp/>of<sp/>2-attributes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>display_map_and_2attributes(gm);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1sec_definition_gmap">
<title>Mathematical Definitions</title>
<para>The definition of generalized map in any dimension is given in <ref refid="citelist_1CITEREF_cgal:l-tmbrc-91" kindref="member">[2]</ref>, <ref refid="citelist_1CITEREF_l-ndgcm-94" kindref="member">[3]</ref>. See also the book <ref refid="citelist_1CITEREF_cgal:dl-cmeds-14" kindref="member">[1]</ref> which regroups many definitions, operations and algorithms about combinatorial and generalized maps.</para><para>An <emphasis>involution</emphasis> on a finite set <emphasis>E</emphasis> is a mapping <emphasis>f</emphasis> from <emphasis>E</emphasis> to <emphasis>E</emphasis> which is bijective and equal to its inverse. Thus <formula id="21">$ \forall $</formula> <emphasis>e</emphasis> <formula id="26">$ \in $</formula> <emphasis>E</emphasis>, we have <emphasis>f</emphasis>(<emphasis>e</emphasis>) = <formula id="44">$ f^{-1}$</formula>(<emphasis>e</emphasis>) and <emphasis>f</emphasis>(<emphasis>f</emphasis>(<emphasis>e</emphasis>))=<emphasis>e</emphasis>.</para><para>Let <emphasis>d</emphasis> <formula id="45">$ \geq$</formula> 0. A <emphasis>d</emphasis>-dimensional generalized map (or <emphasis>d</emphasis>-Gmap) is a (d+1)-tuple <emphasis>G</emphasis>=(<emphasis>D</emphasis>, <formula id="3">$ \alpha_0$</formula>,..., <formula id="7">$ \alpha_d$</formula>) where: <orderedlist>
<listitem>
<para><emphasis>D</emphasis> is a finite set of darts; </para></listitem>
<listitem>
<para><formula id="21">$ \forall $</formula> <emphasis>i</emphasis>, 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>, <formula id="46">$ \alpha_i $</formula> is an involution on <emphasis>D</emphasis>; </para></listitem>
<listitem>
<para><anchor id="index_1gmapcondcomposition"/><formula id="21">$ \forall $</formula> <emphasis>i</emphasis>: 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>-2, <formula id="21">$ \forall $</formula> <emphasis>j</emphasis>: 2 <formula id="18">$ \leq $</formula> <emphasis>j</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>, <emphasis>i</emphasis>+2 <formula id="18">$ \leq $</formula> <emphasis>j</emphasis>, <formula id="46">$ \alpha_i $</formula> <formula id="47">$ \circ $</formula> <formula id="13">$ \alpha_j$</formula> is an involution. </para></listitem>
</orderedlist>
</para><para>A <emphasis>d</emphasis>-dimensional generalized map represents a subdivision of an orientable or non-orientable <emphasis>d</emphasis>-dimensional quasi-manifold. A dart is an abstract element which is only required to define involutions. The last line of the definition fixes constraints which guarantee the topological validity of the represented object, i.e., the fact that it is a quasi-manifold. This definition allows us to verify the validity of a given generalized map by checking if each item of the definition is satisfied.</para><para>Given a set of involutions <emphasis>S</emphasis>= <formula id="48">$\{f_1$</formula>,..., <formula id="49">$ f_k\}$</formula>, we denote by <formula id="2">$ \langle{}$</formula> <emphasis>S</emphasis> <formula id="8">$ \rangle{}$</formula> the <emphasis>permutation group</emphasis> generated by <formula id="48">$\{f_1$</formula>,..., <formula id="49">$ f_k\}$</formula> and whose group operation is the composition of involutions. The orbit <formula id="2">$ \langle{}$</formula> <formula id="50">$ f_1$</formula>,..., <formula id="51">$ f_k$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>a</emphasis>) is the set of darts which can be obtained from <emphasis>a</emphasis> by elements of <formula id="2">$ \langle{}$</formula> <emphasis>S</emphasis> <formula id="8">$ \rangle{}$</formula>: <formula id="2">$ \langle{}$</formula> <formula id="50">$ f_1$</formula>,..., <formula id="51">$ f_k$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>a</emphasis>)= <formula id="52">$\{ \phi$</formula>(<emphasis>a</emphasis>) <formula id="53">$ |$</formula> <formula id="54">$ \phi$</formula> <formula id="26">$ \in $</formula> <formula id="2">$ \langle{}$</formula><emphasis>S</emphasis> <formula id="55">$ \rangle{}\}$</formula>.</para><para>Let <emphasis>d0</emphasis> <formula id="26">$ \in $</formula> <emphasis>D</emphasis> be a dart. Given <emphasis>i</emphasis>, 0 <formula id="18">$ \leq $</formula> <emphasis>i</emphasis> <formula id="18">$ \leq $</formula> <emphasis>d</emphasis>, the <emphasis>i</emphasis>-cell containing <emphasis>d0</emphasis> is <formula id="2">$ \langle{}$</formula> <formula id="3">$ \alpha_0$</formula>,..., <formula id="31">$ \alpha_{i-1}$</formula>, <formula id="32">$ \alpha_{i+1}$</formula>,..., <formula id="7">$ \alpha_d$</formula> <formula id="8">$ \rangle{}$</formula>(<emphasis>d0</emphasis>).</para></sect1>
<sect1 id="index_1Generalized_mapDesign">
<title>Design and Implementation History</title>
<para>The code of this package followed the code of Combinatorial maps and was inspired by Moka, a 3D topological modeler that uses 3D generalized maps (<ulink url="http://moka-modeller.sourceforge.net/">http://moka-modeller.sourceforge.net/</ulink>). </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
