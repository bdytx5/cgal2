<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Segment_Delaunay_graph_Linf_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - L Infinity Segment Delaunay Graphs: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - L Infinity Segment Delaunay Graphs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_L_Infinity_Segment_Delaunay_Graphs"></a><a class="anchor" id="chaptersdglinf"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Panagiotis Cheilaris, Sandeep Kumar Dey, Evanthia Papadopoulou</dd></dl>
<p>This chapter describes the algorithm and the geometric traits for constructing the segment Delaunay graph under the \( L_{\infty} \) distance. The traits also contain methods to draw the edges of the dual of the segment Delaunay graph under the \( L_{\infty} \) distance, i.e., the segment Voronoi diagram under the \( L_{\infty} \) distance. The \( L_{\infty} \) algorithm and traits rely on the segment Delaunay graph algorithm and traits under the Euclidean (or \( L_{2} \)) distance.</p>
<p>Segment Voronoi diagrams in the \( L_{\infty} \) metric have applications in VLSI design <a class="el" href="citelist.html#CITEREF_pl-svdlinf-2001">[3]</a>, <a class="el" href="citelist.html#CITEREF_cdgp-icms-2014">[1]</a>.</p>
<p>In Section <a class="el" href="index.html#secsdglinfdefinitions">Definitions</a> we give some definitions. In Section <a class="el" href="index.html#secsdglinfdesign">Software Design</a> we explain the design of the algorithm and traits.</p>
<p><a class="anchor" id="fig__figsvdlinf"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<object type="image/svg+xml" data="svdlinfweak.svg">svdlinfweak.svg</object>
</div>
   </td><td><div class="image">
<object type="image/svg+xml" data="svdlinfstrong.svg">svdlinfstrong.svg</object>
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__figsvdlinf">Figure 49.1</a> The \( L_{\infty} \) segment Voronoi diagram for a set of weakly (left) and strongly (right) intersecting sites.  </div>  <br />

<h1><a class="anchor" id="secsdglinfdefinitions"></a>
Definitions</h1>
<p>A pair of segment sites is called <em>weakly intersecting</em> if they have a single common point and this common point does not lie in the interior of any of the two sites. A pair of segment sites is called <em>strongly intersecting</em> if they intersect and they either have more than one common point or their common point lies in the interior of at least one of the two sites. We call a set of segment sites weakly (resp. strongly) intersecting if all its pairs are weakly (resp. strongly) intersecting or non-intersecting. See figure <a class="el" href="index.html#fig__figsvdlinf">Figure 49.1</a>.</p>
<p>Given two points \( p=(p_x,p_y) \), \( q=(q_x,q_y) \) in the plane, their \( L_{\infty} \) distance is </p><p class="formulaDsp">
\[ d_{\infty}(p,q) = \max(|p_x-q_x|,|p_y-q_y|). \]
</p>
<p> It is not difficult to see that the geometric locus of points at an equal fixed \( L_{\infty} \) distance \( r \) from a fixed point \( c \) is the axis-parallel square with center \( c \) and side length \( 2r \) (the analog in \( L_2 \) is a circle with center \( c \) and diameter \( 2r \)).</p>
<h2><a class="anchor" id="subsecbis1dim"></a>
Bisectors and 1-Dimensionalization</h2>
<p>If we assume general position of sites, then the \( L_{\infty} \) bisectors between two points or between a point and a segment are polygonal chains; see figure <a class="el" href="index.html#fig__figbislinf">Figure 49.2</a> for examples. This is in contrast with the \( L_{2} \) Voronoi diagram in which the bisector between a point and a segment is a parabolic arc. In the \( L_{\infty} \) Voronoi diagram, if the coordinates of the input sites are rational, then the coordinates of the vertices of the diagram are also rational, which is not true for the \( L_{2} \) diagram. For more details on \( L_{\infty} \) bisectors and the diagram, see <a class="el" href="citelist.html#CITEREF_cdgp-icms-2014">[1]</a>.</p>
<p><a class="anchor" id="fig__figbislinf"></a></p><div class="image">
<object type="image/svg+xml" data="bislinf.svg">bislinf.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figbislinf">Figure 49.2</a> The \( L_{\infty} \) bisectors between two points and between a segment and a point.  </div>  <br />

<p>One very important difference in the \( L_{\infty} \) setting (in comparison to the \( L_{2} \) setting) is that in some special non-general position cases the \( L_{\infty} \) bisector between two sites can be 2-dimensional. Since this creates problems when drawing the diagram, we resort to a 1-dimensionalization of these bisectors, by assigning portions of two-dimensional regions of a bisector to the two sites of the bisector. Moreover, this simplification of the diagram is acceptable in the VLSI applications, where the \( L_{\infty} \) diagram is employed <a class="el" href="citelist.html#CITEREF_pl-svdlinf-2001">[3]</a>.</p>
<p>If two different points \( p \), \( q \) share one coordinate, then their \( L_{\infty} \) bisector is 2-dimensional as shown in <a class="el" href="index.html#fig__figbispointsbidim">Figure 49.3</a>. In this special case, we 1-dimensionalize the bisector, by taking instead the Euclidean bisector of the two points.</p>
<p><a class="anchor" id="fig__figbispointsbidim"></a></p><div class="image">
<object type="image/svg+xml" data="bidim1dim.svg">bidim1dim.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figbispointsbidim">Figure 49.3</a> The \( L_{\infty} \) bisector between two points with the same \( y \) coordinate and its 1-dimensionalization.  </div>  <br />

<p>Similarly, the bisector between the interior of an axis-parallel segment and one of its endpoints is also 2-dimensional as shown in <a class="el" href="index.html#fig__figbisspbidim">Figure 49.4</a>. We 1-dimensionalize this bisector by taking instead the line passing through the endpoint that is perpendicular to the segment.</p>
<p><a class="anchor" id="fig__figbisspbidim"></a></p><div class="image">
<object type="image/svg+xml" data="bidim1dimsp.svg">bidim1dimsp.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figbisspbidim">Figure 49.4</a> The \( L_{\infty} \) bisector between a vertical segment and one of its endpoints and its 1-dimensionalization.  </div>  <br />

<h1><a class="anchor" id="secsdglinfdesign"></a>
Software Design</h1>
<p>In general, the software design of the algorithms and traits for the \( L_{\infty} \) segment Delaunay graph rely on the corresponding algorithms and traits for the \( L_{2} \) Segment Delaunay graph. We implement the \( L_{\infty} \) classes as subclasses of corresponding \( L_{2} \) classes from the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSegmentDelaunayGraph2Summary">2D Segment Delaunay Graphs</a>. The names of the \( L_{\infty} \) classes contain an additional <code>_Linf</code> after <code>graph</code>, in comparison with the corresponding \( L_{2} \) classes. For more details, see <a class="el" href="citelist.html#CITEREF_cdgp-icms-2014">[1]</a>.</p>
<p>The order of complexity of the construction of the \( L_{\infty} \) diagram is the same as the one of the \( L_{2} \) diagram and thus we refer the end user to <a class="el" href="citelist.html#CITEREF_cgal:k-reisv-04">[2]</a> for complexity analysis.</p>
<h2><a class="anchor" id="Segment_Delaunay_graph_Linf_2_Graph"></a>
Segment Delaunay Graph</h2>
<p>The \( L_{\infty} \) segment Delaunay graph class template <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__Linf__2.html" title="The class Segment_Delaunay_graph_Linf_2 represents the segment Delaunay graph under the  metric (whic...">Segment_Delaunay_graph_Linf_2</a>&lt;<a class="el" href="classSegmentDelaunayGraphLinfTraits__2.html" title="The concept SegmentDelaunayGraphLinfTraits_2 provides traits for constructing the segment Delaunay gr...">SegmentDelaunayGraphLinfTraits_2</a>,<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Segment_Delaunay_graph_2.tag:../Segment_Delaunay_graph_2/" href="../Segment_Delaunay_graph_2/classSegmentDelaunayGraphDataStructure__2.html">SegmentDelaunayGraphDataStructure_2</a>&gt;</code> is derived from the class template <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Segment_Delaunay_graph_2.tag:../Segment_Delaunay_graph_2/" href="../Segment_Delaunay_graph_2/classCGAL_1_1Segment__Delaunay__graph__2.html">Segment_Delaunay_graph_2</a></code>. In the \( L_{\infty} \) class template, a few methods that are used when inserting a point in the interior of an existing segment are overridden.</p>
<h2><a class="anchor" id="Segment_Delaunay_graph_Linf_2_Traits"></a>
Segment Delaunay Graph Traits</h2>
<p>As in the case of \( L_{2} \), the geometric predicates are quite elaborate and we do not bother the end user with details. Our implementation reuses the \( L_{2} \) traits, wherever possible, but there are extensive differences. We support geometric and arithmetic filtering, as the \( L_{2} \) predicates do. For more details on these filtering techniques, see Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Segment_Delaunay_graph_2.tag:../Segment_Delaunay_graph_2/" href="../Segment_Delaunay_graph_2/index.html#secsdg2traits">The Geometric Traits</a> of the segment Delaunay graph package manual.</p>
<p>In analogy with the \( L_{2} \) setting, there are four models of the <code><a class="el" href="classSegmentDelaunayGraphLinfTraits__2.html" title="The concept SegmentDelaunayGraphLinfTraits_2 provides traits for constructing the segment Delaunay gr...">SegmentDelaunayGraphLinfTraits_2</a></code> concept, two of which support strongly intersecting sites (<code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__Linf__traits__2.html" title="The class Segment_Delaunay_graph_Linf_traits_2 provides a model for the SegmentDelaunayGraphLinfTrait...">Segment_Delaunay_graph_Linf_traits_2</a></code>, <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__2.html" title="The class Segment_Delaunay_graph_Linf_filtered_traits_2 provides a model for the SegmentDelaunayGraph...">Segment_Delaunay_graph_Linf_filtered_traits_2</a></code>) and two of which support sites without intersections (<code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__Linf__traits__without__intersections__2.html" title="The class Segment_Delaunay_graph_Linf_traits_without_intersections_2 provides a model for the Segment...">Segment_Delaunay_graph_Linf_traits_without_intersections_2</a></code>, <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__without__intersections__2.html" title="The class Segment_Delaunay_graph_Linf_filtered_traits_without_intersections_2 provides a model for th...">Segment_Delaunay_graph_Linf_filtered_traits_without_intersections_2</a></code>). Refer to Subsection <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Segment_Delaunay_graph_2.tag:../Segment_Delaunay_graph_2/" href="../Segment_Delaunay_graph_2/index.html#Segment_Delaunay_graph_2OptimizingMemory">Optimizing Memory Allocation</a> of the segment Delaunay graph package manual, which explains when to use each of these traits.</p>
<h2><a class="anchor" id="Segment_Delaunay_graph_Linf_2_Hierarchy"></a>
Segment Delaunay Graph Hierarchy</h2>
<p>The <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__Linf__hierarchy__2.html" title="This class is equivalent to the Segment_Delaunay_graph_hierarchy_2 class, but it uses Segment_Delauna...">Segment_Delaunay_graph_Linf_hierarchy_2</a></code> class is equivalent to the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Segment_Delaunay_graph_2.tag:../Segment_Delaunay_graph_2/" href="../Segment_Delaunay_graph_2/classCGAL_1_1Segment__Delaunay__graph__hierarchy__2.html">Segment_Delaunay_graph_hierarchy_2</a>, but it uses the <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__Linf__2.html" title="The class Segment_Delaunay_graph_Linf_2 represents the segment Delaunay graph under the  metric (whic...">Segment_Delaunay_graph_Linf_2</a></code> class in each level of the hierarchy instead of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Segment_Delaunay_graph_2.tag:../Segment_Delaunay_graph_2/" href="../Segment_Delaunay_graph_2/classCGAL_1_1Segment__Delaunay__graph__2.html">Segment_Delaunay_graph_2</a></code>. For a comparison of the performance of the plain graph class and the hierarchy class, we refer the end user to Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Segment_Delaunay_graph_2.tag:../Segment_Delaunay_graph_2/" href="../Segment_Delaunay_graph_2/index.html#secsdg2hierarchy">The Segment Delaunay Graph Hierarchy</a> of the segment Delaunay graph package manual.</p>
<h2><a class="anchor" id="secsdglinfVD"></a>
Obtaining the Voronoi Diagram from the Delaunay Graph</h2>
<p>Class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Voronoi_diagram_2.tag:../Voronoi_diagram_2/" href="../Voronoi_diagram_2/classCGAL_1_1Voronoi__diagram__2.html">Voronoi_diagram_2</a></code> from the Voronoi diagram adaptor package can be used to obtain the \( L_{\infty} \) segment Voronoi diagram from the \( L_{\infty} \) segment Delaunay graph (or hierarchy).</p>
<h1><a class="anchor" id="secsdglinfexamples"></a>
Examples</h1>
<p>The following examples show the usage of the \( L_{\infty} \) algorithm and traits. They are similar to the examples in the \( L_{2} \) segment Delaunay graph package.</p>
<h2><a class="anchor" id="Segment_Delaunay_graph_Linf_2FirstExample"></a>
First Example using the Filtered Traits</h2>
<p>The following example shows how to use the segment Delaunay graph filtered traits mechanism. In addition it shows how to use a few of the iterators provided by the <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__Linf__2.html" title="The class Segment_Delaunay_graph_Linf_2 represents the segment Delaunay graph under the  metric (whic...">Segment_Delaunay_graph_Linf_2</a></code> class in order to count a few site-related quantities. <br />
<b>File</b> <a class="el" href="Segment_Delaunay_graph_Linf_2_2sdg-count-sites-linf_8cpp-example.html">Segment_Delaunay_graph_Linf_2/sdg-count-sites-linf.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// define the input kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>     CK;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_Linf_filtered_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_Linf_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__2.html">CGAL::Segment_Delaunay_graph_Linf_filtered_traits_2</a>&lt;</div><div class="line">          CK,<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/structCGAL_1_1Field__with__sqrt__tag.html">CGAL::Field_with_sqrt_tag</a>&gt;  Gt;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Segment__Delaunay__graph__Linf__2.html">CGAL::Segment_Delaunay_graph_Linf_2&lt;Gt&gt;</a>      SDG2;</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] ) {</div><div class="line">  <span class="keywordflow">if</span> ( ! (( argc == 1 ) || (argc == 2)) ) {</div><div class="line">    std::cout &lt;&lt;<span class="stringliteral">"usage: "</span>&lt;&lt; argv[0] &lt;&lt;<span class="stringliteral">" [filename]\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  ifstream ifs( (argc == 1) ? <span class="stringliteral">"data/sitesx.cin"</span> : argv[1] );</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  SDG2          sdg;</div><div class="line">  SDG2::Site_2  site;</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) { sdg.insert( site ); }</div><div class="line"></div><div class="line">  ifs.close();</div><div class="line"></div><div class="line">  assert( sdg.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line">  cout &lt;&lt; endl &lt;&lt; endl;</div><div class="line"></div><div class="line">  <span class="comment">// print the number of input and output sites</span></div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of input sites : "</span> &lt;&lt; sdg.number_of_input_sites() &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of output sites: "</span> &lt;&lt; sdg.number_of_output_sites() &lt;&lt; endl;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_ipt(0), n_iseg(0), n_opt(0), n_oseg(0), n_ptx(0);</div><div class="line"></div><div class="line">  <span class="comment">// count the number of input points and input segments</span></div><div class="line">  SDG2::Input_sites_iterator iit;</div><div class="line">  <span class="keywordflow">for</span> (iit = sdg.input_sites_begin(); iit != sdg.input_sites_end(); ++iit)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> ( iit-&gt;is_point() ) { n_ipt++; } <span class="keywordflow">else</span> { n_iseg++; }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// count the number of output points and output segments, as well</span></div><div class="line">  <span class="comment">// as the number of points that are points of intersection of pairs</span></div><div class="line">  <span class="comment">// of strongly intersecting sites</span></div><div class="line">  SDG2::Output_sites_iterator oit;</div><div class="line">  <span class="keywordflow">for</span> (oit = sdg.output_sites_begin(); oit != sdg.output_sites_end(); ++oit)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> ( oit-&gt;is_segment() ) { n_oseg++; } <span class="keywordflow">else</span> {</div><div class="line">        n_opt++;</div><div class="line">        <span class="keywordflow">if</span> ( !oit-&gt;is_input() ) { n_ptx++; }</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"# of input segments:  "</span> &lt;&lt; n_iseg &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of input points:    "</span> &lt;&lt; n_ipt &lt;&lt; endl &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of output segments: "</span> &lt;&lt; n_oseg &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of output points:   "</span> &lt;&lt; n_opt &lt;&lt; endl &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; <span class="stringliteral">"# of intersection points: "</span> &lt;&lt; n_ptx &lt;&lt; endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Segment_Delaunay_graph_Linf_2FastSP"></a>
Using Spatial Sorting to Speed up Insertion</h2>
<p>If you have a rather large input, you better use an insertion function that uses the spatial sorting of your input (end) points. Note that the functions <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Segment_Delaunay_graph_2.tag:../Segment_Delaunay_graph_2/" href="../Segment_Delaunay_graph_2/classCGAL_1_1Segment__Delaunay__graph__2.html#af190978a7ec3bdc26e96566548c11f63"><code>insert_points</code> </a> or <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Segment_Delaunay_graph_2.tag:../Segment_Delaunay_graph_2/" href="../Segment_Delaunay_graph_2/classCGAL_1_1Segment__Delaunay__graph__2.html#a896a91e35dabbeb3463ae428e21da5a5"><code>insert_segments</code> </a> can be used if your input is only composed of points or segments. <br />
<b>File</b> <a class="el" href="Segment_Delaunay_graph_Linf_2_2sdg-fast-sp-linf_8cpp-example.html">Segment_Delaunay_graph_Linf_2/sdg-fast-sp-linf.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// example that uses the filtered traits,</span></div><div class="line"><span class="comment">// the segment Delaunay graph and the spatial sorting</span></div><div class="line"></div><div class="line"><span class="comment">// choose the kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_Linf_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_Linf_filtered_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__without__intersections__2.html">CGAL::Segment_Delaunay_graph_Linf_filtered_traits_without_intersections_2&lt;K&gt;</a> Gt;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Segment__Delaunay__graph__Linf__2.html">CGAL::Segment_Delaunay_graph_Linf_2&lt;Gt&gt;</a>  SDG2;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::ifstream ifs(<span class="stringliteral">"data/sites.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  SDG2          sdg;</div><div class="line">  SDG2::Site_2  site;</div><div class="line"></div><div class="line">  std::vector&lt;SDG2::Site_2&gt; sites;</div><div class="line">  <span class="comment">// read the sites</span></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) {</div><div class="line">    sites.push_back(site);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//insert the sites all at once using spatial sorting to speed the insertion</span></div><div class="line">  sdg.insert( sites.begin(), sites.end(),<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__PkgStlExtensionUtilities.html#gab3e2296107b5d26c32c8183028a217f1">CGAL::Tag_true</a>() );</div><div class="line"></div><div class="line">  <span class="comment">// validate the segment Delaunay graph</span></div><div class="line">  assert( sdg.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Segment_Delaunay_graph_Linf_2FastSPPolygon"></a>
Delaunay Graph of a Polygon</h2>
<p>This example shows how to efficiently compute the Delaunay graph of a simple polygon using the spatial sorting to speed up the insertion. <br />
<b>File</b> <a class="el" href="Segment_Delaunay_graph_Linf_2_2sdg-fast-sp-polygon-linf_8cpp-example.html">Segment_Delaunay_graph_Linf_2/sdg-fast-sp-polygon-linf.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// example that uses the filtered traits,</span></div><div class="line"><span class="comment">// the segment Delaunay graph and the spatial sorting</span></div><div class="line"></div><div class="line"><span class="comment">// choose the kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_Linf_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_Linf_filtered_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__without__intersections__2.html">CGAL::Segment_Delaunay_graph_Linf_filtered_traits_without_intersections_2&lt;K&gt;</a> Gt;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Segment__Delaunay__graph__Linf__2.html">CGAL::Segment_Delaunay_graph_Linf_2&lt;Gt&gt;</a>  SDG2;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::ifstream ifs(<span class="stringliteral">"data/sites.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  <span class="comment">//polygon points</span></div><div class="line">  std::vector&lt;Gt::Point_2&gt; points;</div><div class="line">  <span class="comment">//segments of the polygon as a pair of point indices</span></div><div class="line">  std::vector&lt;std::pair&lt;std::size_t,std::size_t&gt; &gt; indices;</div><div class="line"></div><div class="line">  SDG2::Site_2 site;</div><div class="line">  <span class="comment">//read a close polygon given by its segments</span></div><div class="line">  <span class="comment">// s x0 y0 x1 y1</span></div><div class="line">  <span class="comment">// s x1 y1 x2 y2</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="comment">// s xn yn x0 y0</span></div><div class="line">  ifs &gt;&gt; site;</div><div class="line">  assert( site.is_segment() );</div><div class="line">  points.push_back( site.source_of_supporting_site() );</div><div class="line"></div><div class="line">  std::size_t k=0;</div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) {</div><div class="line">    assert( site.is_segment() );</div><div class="line">    points.push_back( site.source_of_supporting_site() );</div><div class="line">    indices.push_back( std::make_pair(k, k+1) );</div><div class="line">    ++k;</div><div class="line">  }</div><div class="line">  indices.push_back( std::make_pair(k, 0) );</div><div class="line">  ifs.close();</div><div class="line"></div><div class="line">  SDG2          sdg;</div><div class="line"></div><div class="line">  <span class="comment">//insert the polygon segments all at once using spatial sorting to speed the insertion</span></div><div class="line">  sdg.insert_segments( points.begin(), points.end(), indices.begin(), indices.end() );</div><div class="line"></div><div class="line">  <span class="comment">// validate the segment Delaunay graph</span></div><div class="line">  assert( sdg.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Segment_Delaunay_graph_Linf_2ExHierarchy"></a>
Using the Hierarchy for Faster Location</h2>
<p>The following example shows how to use the segment Delaunay graph hierarchy along with the filtered traits class that supports intersecting sites. The hierarchy should be preferred when the size of the input is large: Experiments suggest that the hierarchy is faster than the plain segment Delaunay graph when the size of the input exceeds 1000 sites. <br />
<b>File</b> <a class="el" href="Segment_Delaunay_graph_Linf_2_2sdg-filtered-traits-linf_8cpp-example.html">Segment_Delaunay_graph_Linf_2/sdg-filtered-traits-linf.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// example that uses the filtered traits and</span></div><div class="line"><span class="comment">// the segment Delaunay graph hierarchy</span></div><div class="line"></div><div class="line"><span class="comment">// choose the kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Rep;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_Linf_hierarchy_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_Linf_filtered_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__2.html">CGAL::Segment_Delaunay_graph_Linf_filtered_traits_2&lt;Rep&gt;</a> Gt;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Segment__Delaunay__graph__Linf__hierarchy__2.html">CGAL::Segment_Delaunay_graph_Linf_hierarchy_2&lt;Gt&gt;</a>  SDG2;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] )</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> ( ! (( argc == 1 ) || (argc == 2)) ) {</div><div class="line">    std::cout &lt;&lt;<span class="stringliteral">"usage: "</span>&lt;&lt; argv[0] &lt;&lt;<span class="stringliteral">" [filename]\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ifstream ifs( (argc == 1) ? <span class="stringliteral">"data/sites.cin"</span> : argv[1] );</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  SDG2          sdg;</div><div class="line">  SDG2::Site_2  site;</div><div class="line"></div><div class="line">  <span class="comment">// read the sites and insert them in the segment Delaunay graph</span></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) {</div><div class="line">    sdg.insert(site);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// validate the segment Delaunay graph</span></div><div class="line">  assert( sdg.is_valid(<span class="keyword">true</span>, 1) );</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Segment_Delaunay_graph_Linf_2ExVorEdges"></a>
Voronoi Edges</h2>
<p>The following example demonstrates how to recover the defining sites for the edges of the Voronoi diagram (which are the duals of the edges of the segment Delaunay graph computed). <br />
<b>File</b> <a class="el" href="Segment_Delaunay_graph_Linf_2_2sdg-voronoi-edges-linf_8cpp-example.html">Segment_Delaunay_graph_Linf_2/sdg-voronoi-edges-linf.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// define the kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Filtered_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>    CK;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Filtered__kernel.html">CGAL::Filtered_kernel&lt;CK&gt;</a>         <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"></div><div class="line"><span class="comment">// typedefs for the traits and the algorithm</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_Linf_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_Delaunay_graph_Linf_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Segment__Delaunay__graph__Linf__traits__2.html">CGAL::Segment_Delaunay_graph_Linf_traits_2&lt;Kernel&gt;</a>  Gt;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Segment__Delaunay__graph__Linf__2.html">CGAL::Segment_Delaunay_graph_Linf_2&lt;Gt&gt;</a>             SDG2;</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] ) {</div><div class="line">  <span class="keywordflow">if</span> ( ! (( argc == 1 ) || (argc == 2)) ) {</div><div class="line">    std::cout &lt;&lt;<span class="stringliteral">"usage: "</span>&lt;&lt; argv[0] &lt;&lt;<span class="stringliteral">" [filename]\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  ifstream ifs( (argc == 1) ? <span class="stringliteral">"data/sites2.cin"</span> : argv[1] );</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  SDG2          sdg;</div><div class="line">  SDG2::Site_2  site;</div><div class="line"></div><div class="line">  <span class="comment">// read the sites from the stream and insert them in the diagram</span></div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; site ) {</div><div class="line">    sdg.insert( site );</div><div class="line">    CGAL_SDG_DEBUG( sdg.file_output_verbose(std::cout); );</div><div class="line">    CGAL_assertion( sdg.is_valid(<span class="keyword">false</span>, 1) );</div><div class="line">  }</div><div class="line"></div><div class="line">  ifs.close();</div><div class="line"></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"About to validate diagram ..."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// validate the diagram</span></div><div class="line">  assert( sdg.is_valid(<span class="keyword">false</span>, 1) );</div><div class="line">  cout &lt;&lt; endl &lt;&lt; endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Diagram validated."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">  // now walk through the non-infinite edges of the segment Delaunay</span></div><div class="line"><span class="comment">  // graphs (which are dual to the edges in the Voronoi diagram) and</span></div><div class="line"><span class="comment">  // print the sites defining each Voronoi edge.</span></div><div class="line"><span class="comment">  //</span></div><div class="line"><span class="comment">  // Each oriented Voronoi edge (horizontal segment in the figure</span></div><div class="line"><span class="comment">  // below) is defined by four sites A, B, C and D.</span></div><div class="line"><span class="comment">  //</span></div><div class="line"><span class="comment">  //     \                     /</span></div><div class="line"><span class="comment">  //      \         B         /</span></div><div class="line"><span class="comment">  //       \                 /</span></div><div class="line"><span class="comment">  //     C  -----------------  D</span></div><div class="line"><span class="comment">  //       /                 \</span></div><div class="line"><span class="comment">  //      /         A         \</span></div><div class="line"><span class="comment">  //     /                     \</span></div><div class="line"><span class="comment">  //</span></div><div class="line"><span class="comment">  // The sites A and B define the (oriented) bisector on which the</span></div><div class="line"><span class="comment">  // edge lies whereas the sites C and D, along with A and B define</span></div><div class="line"><span class="comment">  // the two endpoints of the edge. These endpoints are the Voronoi</span></div><div class="line"><span class="comment">  // vertices of the triples A, B, C and B, A, D.</span></div><div class="line"><span class="comment">  // If one of these vertices is the vertex at infinity the string</span></div><div class="line"><span class="comment">  // "infinite vertex" is printed; the corresponding Voronoi edge is</span></div><div class="line"><span class="comment">  // actually a stright-line or parabolic ray.</span></div><div class="line"><span class="comment">  // The sites below are printed in the order A, B, C, D.</span></div><div class="line"><span class="comment">  */</span></div><div class="line"></div><div class="line">  <span class="keywordtype">string</span> inf_vertex(<span class="stringliteral">"infinite vertex"</span>);</div><div class="line">  <span class="keywordtype">char</span> vid[] = {<span class="charliteral">'A'</span>, <span class="charliteral">'B'</span>, <span class="charliteral">'C'</span>, <span class="charliteral">'D'</span>};</div><div class="line"></div><div class="line">  SDG2::Finite_edges_iterator eit = sdg.finite_edges_begin();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 1; eit != sdg.finite_edges_end(); ++eit, ++k) {</div><div class="line">    SDG2::Edge e = *eit;</div><div class="line">    <span class="comment">// get the vertices defining the Voronoi edge</span></div><div class="line">    SDG2::Vertex_handle v[] = { e.first-&gt;vertex( sdg.ccw(e.second) ),</div><div class="line">                                e.first-&gt;vertex( sdg.cw(e.second) ),</div><div class="line">                                e.first-&gt;vertex( e.second ),</div><div class="line">                                sdg.tds().mirror_vertex(e.first, e.second) };</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">"--- Edge "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" ---"</span> &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++) {</div><div class="line">      <span class="comment">// check if the vertex is the vertex at infinity; if yes, print</span></div><div class="line">      <span class="comment">// the corresponding string, otherwise print the site</span></div><div class="line">      <span class="keywordflow">if</span> ( sdg.is_infinite(v[i]) ) {</div><div class="line">        cout &lt;&lt; vid[i] &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; inf_vertex &lt;&lt; endl;</div><div class="line">      } <span class="keywordflow">else</span> {</div><div class="line">        cout &lt;&lt; vid[i] &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; v[i]-&gt;site() &lt;&lt; endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:43 for CGAL 4.13 - L Infinity Segment Delaunay Graphs by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
