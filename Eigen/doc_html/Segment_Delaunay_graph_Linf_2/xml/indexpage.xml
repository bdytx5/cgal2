<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_L_Infinity_Segment_Delaunay_Graphs"/><anchor id="index_1chaptersdglinf"/> <simplesect kind="authors"><para>Panagiotis Cheilaris, Sandeep Kumar Dey, Evanthia Papadopoulou</para></simplesect>
This chapter describes the algorithm and the geometric traits for constructing the segment Delaunay graph under the <formula id="0">$ L_{\infty} $</formula> distance. The traits also contain methods to draw the edges of the dual of the segment Delaunay graph under the <formula id="0">$ L_{\infty} $</formula> distance, i.e., the segment Voronoi diagram under the <formula id="0">$ L_{\infty} $</formula> distance. The <formula id="0">$ L_{\infty} $</formula> algorithm and traits rely on the segment Delaunay graph algorithm and traits under the Euclidean (or <formula id="1">$ L_{2} $</formula>) distance.</para><para>Segment Voronoi diagrams in the <formula id="0">$ L_{\infty} $</formula> metric have applications in VLSI design <ref refid="citelist_1CITEREF_pl-svdlinf-2001" kindref="member">[3]</ref>, <ref refid="citelist_1CITEREF_cdgp-icms-2014" kindref="member">[1]</ref>.</para><para>In Section <ref refid="index_1secsdglinfdefinitions" kindref="member">Definitions</ref> we give some definitions. In Section <ref refid="index_1secsdglinfdesign" kindref="member">Software Design</ref> we explain the design of the algorithm and traits.</para><para><anchor id="index_1fig__figsvdlinf"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="svdlinfweak.svg"></image>
 <image type="latex" name="svdlinfweak.svg" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="svdlinfstrong.svg"></image>
 <image type="latex" name="svdlinfstrong.svg" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__figsvdlinf" kindref="member">fig__figsvdlinf</ref> The <formula id="0">$ L_{\infty} $</formula> segment Voronoi diagram for a set of weakly (left) and strongly (right) intersecting sites.  <linebreak/>
</para><sect1 id="index_1secsdglinfdefinitions">
<title>Definitions</title>
<para>A pair of segment sites is called <emphasis>weakly intersecting</emphasis> if they have a single common point and this common point does not lie in the interior of any of the two sites. A pair of segment sites is called <emphasis>strongly intersecting</emphasis> if they intersect and they either have more than one common point or their common point lies in the interior of at least one of the two sites. We call a set of segment sites weakly (resp. strongly) intersecting if all its pairs are weakly (resp. strongly) intersecting or non-intersecting. See figure <ref refid="index_1fig__figsvdlinf" kindref="member">fig__figsvdlinf</ref>.</para><para>Given two points <formula id="31">$ p=(p_x,p_y) $</formula>, <formula id="32">$ q=(q_x,q_y) $</formula> in the plane, their <formula id="0">$ L_{\infty} $</formula> distance is <formula id="33">\[ d_{\infty}(p,q) = \max(|p_x-q_x|,|p_y-q_y|). \]</formula> It is not difficult to see that the geometric locus of points at an equal fixed <formula id="0">$ L_{\infty} $</formula> distance <formula id="34">$ r $</formula> from a fixed point <formula id="35">$ c $</formula> is the axis-parallel square with center <formula id="35">$ c $</formula> and side length <formula id="36">$ 2r $</formula> (the analog in <formula id="37">$ L_2 $</formula> is a circle with center <formula id="35">$ c $</formula> and diameter <formula id="36">$ 2r $</formula>).</para><sect2 id="index_1subsecbis1dim">
<title>Bisectors and 1-Dimensionalization</title>
<para>If we assume general position of sites, then the <formula id="0">$ L_{\infty} $</formula> bisectors between two points or between a point and a segment are polygonal chains; see figure <ref refid="index_1fig__figbislinf" kindref="member">fig__figbislinf</ref> for examples. This is in contrast with the <formula id="1">$ L_{2} $</formula> Voronoi diagram in which the bisector between a point and a segment is a parabolic arc. In the <formula id="0">$ L_{\infty} $</formula> Voronoi diagram, if the coordinates of the input sites are rational, then the coordinates of the vertices of the diagram are also rational, which is not true for the <formula id="1">$ L_{2} $</formula> diagram. For more details on <formula id="0">$ L_{\infty} $</formula> bisectors and the diagram, see <ref refid="citelist_1CITEREF_cdgp-icms-2014" kindref="member">[1]</ref>.</para><para><anchor id="index_1fig__figbislinf"/><image type="html" name="bislinf.svg"></image>
 <image type="latex" name="bislinf.svg" width="15cm"></image>
  <ref refid="index_1fig__figbislinf" kindref="member">fig__figbislinf</ref> The <formula id="0">$ L_{\infty} $</formula> bisectors between two points and between a segment and a point.  <linebreak/>
</para><para>One very important difference in the <formula id="0">$ L_{\infty} $</formula> setting (in comparison to the <formula id="1">$ L_{2} $</formula> setting) is that in some special non-general position cases the <formula id="0">$ L_{\infty} $</formula> bisector between two sites can be 2-dimensional. Since this creates problems when drawing the diagram, we resort to a 1-dimensionalization of these bisectors, by assigning portions of two-dimensional regions of a bisector to the two sites of the bisector. Moreover, this simplification of the diagram is acceptable in the VLSI applications, where the <formula id="0">$ L_{\infty} $</formula> diagram is employed <ref refid="citelist_1CITEREF_pl-svdlinf-2001" kindref="member">[3]</ref>.</para><para>If two different points <formula id="38">$ p $</formula>, <formula id="39">$ q $</formula> share one coordinate, then their <formula id="0">$ L_{\infty} $</formula> bisector is 2-dimensional as shown in <ref refid="index_1fig__figbispointsbidim" kindref="member">fig__figbispointsbidim</ref>. In this special case, we 1-dimensionalize the bisector, by taking instead the Euclidean bisector of the two points.</para><para><anchor id="index_1fig__figbispointsbidim"/><image type="html" name="bidim1dim.svg"></image>
 <image type="latex" name="bidim1dim.svg" width="15cm"></image>
  <ref refid="index_1fig__figbispointsbidim" kindref="member">fig__figbispointsbidim</ref> The <formula id="0">$ L_{\infty} $</formula> bisector between two points with the same <formula id="40">$ y $</formula> coordinate and its 1-dimensionalization.  <linebreak/>
</para><para>Similarly, the bisector between the interior of an axis-parallel segment and one of its endpoints is also 2-dimensional as shown in <ref refid="index_1fig__figbisspbidim" kindref="member">fig__figbisspbidim</ref>. We 1-dimensionalize this bisector by taking instead the line passing through the endpoint that is perpendicular to the segment.</para><para><anchor id="index_1fig__figbisspbidim"/><image type="html" name="bidim1dimsp.svg"></image>
 <image type="latex" name="bidim1dimsp.svg" width="15cm"></image>
  <ref refid="index_1fig__figbisspbidim" kindref="member">fig__figbisspbidim</ref> The <formula id="0">$ L_{\infty} $</formula> bisector between a vertical segment and one of its endpoints and its 1-dimensionalization.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1secsdglinfdesign">
<title>Software Design</title>
<para>In general, the software design of the algorithms and traits for the <formula id="0">$ L_{\infty} $</formula> segment Delaunay graph rely on the corresponding algorithms and traits for the <formula id="1">$ L_{2} $</formula> Segment Delaunay graph. We implement the <formula id="0">$ L_{\infty} $</formula> classes as subclasses of corresponding <formula id="1">$ L_{2} $</formula> classes from the package <ref refid="packages_1PkgSegmentDelaunayGraph2Summary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">2D Segment Delaunay Graphs</ref>. The names of the <formula id="0">$ L_{\infty} $</formula> classes contain an additional <computeroutput>_Linf</computeroutput> after <computeroutput>graph</computeroutput>, in comparison with the corresponding <formula id="1">$ L_{2} $</formula> classes. For more details, see <ref refid="citelist_1CITEREF_cdgp-icms-2014" kindref="member">[1]</ref>.</para><para>The order of complexity of the construction of the <formula id="0">$ L_{\infty} $</formula> diagram is the same as the one of the <formula id="1">$ L_{2} $</formula> diagram and thus we refer the end user to <ref refid="citelist_1CITEREF_cgal:k-reisv-04" kindref="member">[2]</ref> for complexity analysis.</para><sect2 id="index_1Segment_Delaunay_graph_Linf_2_Graph">
<title>Segment Delaunay Graph</title>
<para>The <formula id="0">$ L_{\infty} $</formula> segment Delaunay graph class template <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__Linf__2" kindref="compound">Segment_Delaunay_graph_Linf_2</ref>&lt;<ref refid="classSegmentDelaunayGraphLinfTraits__2" kindref="compound">SegmentDelaunayGraphLinfTraits_2</ref>,<ref refid="classSegmentDelaunayGraphDataStructure__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Segment_Delaunay_graph_2.tag">SegmentDelaunayGraphDataStructure_2</ref>&gt;</computeroutput> is derived from the class template <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Segment_Delaunay_graph_2.tag">Segment_Delaunay_graph_2</ref></computeroutput>. In the <formula id="0">$ L_{\infty} $</formula> class template, a few methods that are used when inserting a point in the interior of an existing segment are overridden.</para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_Linf_2_Traits">
<title>Segment Delaunay Graph Traits</title>
<para>As in the case of <formula id="1">$ L_{2} $</formula>, the geometric predicates are quite elaborate and we do not bother the end user with details. Our implementation reuses the <formula id="1">$ L_{2} $</formula> traits, wherever possible, but there are extensive differences. We support geometric and arithmetic filtering, as the <formula id="1">$ L_{2} $</formula> predicates do. For more details on these filtering techniques, see Section <ref refid="index_1secsdg2traits" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Segment_Delaunay_graph_2.tag">The Geometric Traits</ref> of the segment Delaunay graph package manual.</para><para>In analogy with the <formula id="1">$ L_{2} $</formula> setting, there are four models of the <computeroutput><ref refid="classSegmentDelaunayGraphLinfTraits__2" kindref="compound">SegmentDelaunayGraphLinfTraits_2</ref></computeroutput> concept, two of which support strongly intersecting sites (<computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__Linf__traits__2" kindref="compound">Segment_Delaunay_graph_Linf_traits_2</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__2" kindref="compound">Segment_Delaunay_graph_Linf_filtered_traits_2</ref></computeroutput>) and two of which support sites without intersections (<computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__Linf__traits__without__intersections__2" kindref="compound">Segment_Delaunay_graph_Linf_traits_without_intersections_2</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__without__intersections__2" kindref="compound">Segment_Delaunay_graph_Linf_filtered_traits_without_intersections_2</ref></computeroutput>). Refer to Subsection <ref refid="index_1Segment_Delaunay_graph_2OptimizingMemory" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Segment_Delaunay_graph_2.tag">Optimizing Memory Allocation</ref> of the segment Delaunay graph package manual, which explains when to use each of these traits.</para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_Linf_2_Hierarchy">
<title>Segment Delaunay Graph Hierarchy</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__Linf__hierarchy__2" kindref="compound">Segment_Delaunay_graph_Linf_hierarchy_2</ref></computeroutput> class is equivalent to the <ref refid="classCGAL_1_1Segment__Delaunay__graph__hierarchy__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Segment_Delaunay_graph_2.tag">Segment_Delaunay_graph_hierarchy_2</ref>, but it uses the <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__Linf__2" kindref="compound">Segment_Delaunay_graph_Linf_2</ref></computeroutput> class in each level of the hierarchy instead of <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Segment_Delaunay_graph_2.tag">Segment_Delaunay_graph_2</ref></computeroutput>. For a comparison of the performance of the plain graph class and the hierarchy class, we refer the end user to Section <ref refid="index_1secsdg2hierarchy" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Segment_Delaunay_graph_2.tag">The Segment Delaunay Graph Hierarchy</ref> of the segment Delaunay graph package manual.</para></sect2>
<sect2 id="index_1secsdglinfVD">
<title>Obtaining the Voronoi Diagram from the Delaunay Graph</title>
<para>Class <computeroutput><ref refid="classCGAL_1_1Voronoi__diagram__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Voronoi_diagram_2.tag">Voronoi_diagram_2</ref></computeroutput> from the Voronoi diagram adaptor package can be used to obtain the <formula id="0">$ L_{\infty} $</formula> segment Voronoi diagram from the <formula id="0">$ L_{\infty} $</formula> segment Delaunay graph (or hierarchy).</para></sect2>
</sect1>
<sect1 id="index_1secsdglinfexamples">
<title>Examples</title>
<para>The following examples show the usage of the <formula id="0">$ L_{\infty} $</formula> algorithm and traits. They are similar to the examples in the <formula id="1">$ L_{2} $</formula> segment Delaunay graph package.</para><sect2 id="index_1Segment_Delaunay_graph_Linf_2FirstExample">
<title>First Example using the Filtered Traits</title>
<para>The following example shows how to use the segment Delaunay graph filtered traits mechanism. In addition it shows how to use a few of the iterators provided by the <computeroutput><ref refid="classCGAL_1_1Segment__Delaunay__graph__Linf__2" kindref="compound">Segment_Delaunay_graph_Linf_2</ref></computeroutput> class in order to count a few site-related quantities. <linebreak/>
<bold>File</bold> <ref refid="Segment_Delaunay_graph_Linf_2_2sdg-count-sites-linf_8cpp-example" kindref="compound">Segment_Delaunay_graph_Linf_2/sdg-count-sites-linf.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>define<sp/>the<sp/>input<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/>CK;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_Linf_filtered_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_Linf_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__2" kindref="compound">CGAL::Segment_Delaunay_graph_Linf_filtered_traits_2</ref>&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CK,<ref refid="structCGAL_1_1Field__with__sqrt__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::Field_with_sqrt_tag</ref>&gt;<sp/><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Segment__Delaunay__graph__Linf__2" kindref="compound">CGAL::Segment_Delaunay_graph_Linf_2&lt;Gt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>SDG2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespacestd" kindref="compound">std</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[]<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!<sp/>((<sp/>argc<sp/>==<sp/>1<sp/>)<sp/>||<sp/>(argc<sp/>==<sp/>2))<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;usage:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>argv[0]<sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>[filename]\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifstream<sp/>ifs(<sp/>(argc<sp/>==<sp/>1)<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;data/sitesx.cin&quot;</highlight><highlight class="normal"><sp/>:<sp/>argv[1]<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Site_2<sp/><sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{<sp/>sdg.insert(<sp/>site<sp/>);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifs.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>sdg.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>the<sp/>number<sp/>of<sp/>input<sp/>and<sp/>output<sp/>sites</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>input<sp/>sites<sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>sdg.number_of_input_sites()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>output<sp/>sites:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>sdg.number_of_output_sites()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n_ipt(0),<sp/>n_iseg(0),<sp/>n_opt(0),<sp/>n_oseg(0),<sp/>n_ptx(0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>count<sp/>the<sp/>number<sp/>of<sp/>input<sp/>points<sp/>and<sp/>input<sp/>segments</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Input_sites_iterator<sp/>iit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(iit<sp/>=<sp/>sdg.input_sites_begin();<sp/>iit<sp/>!=<sp/>sdg.input_sites_end();<sp/>++iit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>iit-&gt;is_point()<sp/>)<sp/>{<sp/>n_ipt++;<sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{<sp/>n_iseg++;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>count<sp/>the<sp/>number<sp/>of<sp/>output<sp/>points<sp/>and<sp/>output<sp/>segments,<sp/>as<sp/>well</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>as<sp/>the<sp/>number<sp/>of<sp/>points<sp/>that<sp/>are<sp/>points<sp/>of<sp/>intersection<sp/>of<sp/>pairs</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>of<sp/>strongly<sp/>intersecting<sp/>sites</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Output_sites_iterator<sp/>oit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(oit<sp/>=<sp/>sdg.output_sites_begin();<sp/>oit<sp/>!=<sp/>sdg.output_sites_end();<sp/>++oit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>oit-&gt;is_segment()<sp/>)<sp/>{<sp/>n_oseg++;<sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n_opt++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!oit-&gt;is_input()<sp/>)<sp/>{<sp/>n_ptx++;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>input<sp/>segments:<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n_iseg<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>input<sp/>points:<sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n_ipt<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>output<sp/>segments:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n_oseg<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>output<sp/>points:<sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n_opt<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;#<sp/>of<sp/>intersection<sp/>points:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n_ptx<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_Linf_2FastSP">
<title>Using Spatial Sorting to Speed up Insertion</title>
<para>If you have a rather large input, you better use an insertion function that uses the spatial sorting of your input (end) points. Note that the functions <ref refid="classCGAL_1_1Segment__Delaunay__graph__2_1af190978a7ec3bdc26e96566548c11f63" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Segment_Delaunay_graph_2.tag"><computeroutput>insert_points</computeroutput> </ref> or <ref refid="classCGAL_1_1Segment__Delaunay__graph__2_1a896a91e35dabbeb3463ae428e21da5a5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Segment_Delaunay_graph_2.tag"><computeroutput>insert_segments</computeroutput> </ref> can be used if your input is only composed of points or segments. <linebreak/>
<bold>File</bold> <ref refid="Segment_Delaunay_graph_Linf_2_2sdg-fast-sp-linf_8cpp-example" kindref="compound">Segment_Delaunay_graph_Linf_2/sdg-fast-sp-linf.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>that<sp/>uses<sp/>the<sp/>filtered<sp/>traits,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph<sp/>and<sp/>the<sp/>spatial<sp/>sorting</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>choose<sp/>the<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_Linf_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_Linf_filtered_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__without__intersections__2" kindref="compound">CGAL::Segment_Delaunay_graph_Linf_filtered_traits_without_intersections_2&lt;K&gt;</ref><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Segment__Delaunay__graph__Linf__2" kindref="compound">CGAL::Segment_Delaunay_graph_Linf_2&lt;Gt&gt;</ref><sp/><sp/>SDG2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>ifs(</highlight><highlight class="stringliteral">&quot;data/sites.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Site_2<sp/><sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;SDG2::Site_2&gt;<sp/>sites;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>the<sp/>sites</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sites.push_back(site);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//insert<sp/>the<sp/>sites<sp/>all<sp/>at<sp/>once<sp/>using<sp/>spatial<sp/>sorting<sp/>to<sp/>speed<sp/>the<sp/>insertion</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sdg.insert(<sp/>sites.begin(),<sp/>sites.end(),<ref refid="group__PkgStlExtensionUtilities_1gab3e2296107b5d26c32c8183028a217f1" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Tag_true</ref>()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>sdg.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_Linf_2FastSPPolygon">
<title>Delaunay Graph of a Polygon</title>
<para>This example shows how to efficiently compute the Delaunay graph of a simple polygon using the spatial sorting to speed up the insertion. <linebreak/>
<bold>File</bold> <ref refid="Segment_Delaunay_graph_Linf_2_2sdg-fast-sp-polygon-linf_8cpp-example" kindref="compound">Segment_Delaunay_graph_Linf_2/sdg-fast-sp-polygon-linf.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>that<sp/>uses<sp/>the<sp/>filtered<sp/>traits,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph<sp/>and<sp/>the<sp/>spatial<sp/>sorting</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>choose<sp/>the<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_Linf_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_Linf_filtered_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__without__intersections__2" kindref="compound">CGAL::Segment_Delaunay_graph_Linf_filtered_traits_without_intersections_2&lt;K&gt;</ref><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Segment__Delaunay__graph__Linf__2" kindref="compound">CGAL::Segment_Delaunay_graph_Linf_2&lt;Gt&gt;</ref><sp/><sp/>SDG2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>ifs(</highlight><highlight class="stringliteral">&quot;data/sites.cin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//polygon<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Gt::Point_2&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//segments<sp/>of<sp/>the<sp/>polygon<sp/>as<sp/>a<sp/>pair<sp/>of<sp/>point<sp/>indices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::pair&lt;std::size_t,std::size_t&gt;<sp/>&gt;<sp/>indices;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Site_2<sp/>site;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//read<sp/>a<sp/>close<sp/>polygon<sp/>given<sp/>by<sp/>its<sp/>segments</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>s<sp/>x0<sp/>y0<sp/>x1<sp/>y1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>s<sp/>x1<sp/>y1<sp/>x2<sp/>y2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>s<sp/>xn<sp/>yn<sp/>x0<sp/>y0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifs<sp/>&gt;&gt;<sp/>site;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>site.is_segment()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>site.source_of_supporting_site()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>k=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>site.is_segment()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points.push_back(<sp/>site.source_of_supporting_site()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>indices.push_back(<sp/>std::make_pair(k,<sp/>k+1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(<sp/>std::make_pair(k,<sp/>0)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifs.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//insert<sp/>the<sp/>polygon<sp/>segments<sp/>all<sp/>at<sp/>once<sp/>using<sp/>spatial<sp/>sorting<sp/>to<sp/>speed<sp/>the<sp/>insertion</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sdg.insert_segments(<sp/>points.begin(),<sp/>points.end(),<sp/>indices.begin(),<sp/>indices.end()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>sdg.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_Linf_2ExHierarchy">
<title>Using the Hierarchy for Faster Location</title>
<para>The following example shows how to use the segment Delaunay graph hierarchy along with the filtered traits class that supports intersecting sites. The hierarchy should be preferred when the size of the input is large: Experiments suggest that the hierarchy is faster than the plain segment Delaunay graph when the size of the input exceeds 1000 sites. <linebreak/>
<bold>File</bold> <ref refid="Segment_Delaunay_graph_Linf_2_2sdg-filtered-traits-linf_8cpp-example" kindref="compound">Segment_Delaunay_graph_Linf_2/sdg-filtered-traits-linf.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>example<sp/>that<sp/>uses<sp/>the<sp/>filtered<sp/>traits<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph<sp/>hierarchy</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>choose<sp/>the<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Rep;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_Linf_hierarchy_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_Linf_filtered_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Segment__Delaunay__graph__Linf__filtered__traits__2" kindref="compound">CGAL::Segment_Delaunay_graph_Linf_filtered_traits_2&lt;Rep&gt;</ref><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Segment__Delaunay__graph__Linf__hierarchy__2" kindref="compound">CGAL::Segment_Delaunay_graph_Linf_hierarchy_2&lt;Gt&gt;</ref><sp/><sp/>SDG2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[]<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!<sp/>((<sp/>argc<sp/>==<sp/>1<sp/>)<sp/>||<sp/>(argc<sp/>==<sp/>2))<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;usage:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>argv[0]<sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>[filename]\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>ifs(<sp/>(argc<sp/>==<sp/>1)<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;data/sites.cin&quot;</highlight><highlight class="normal"><sp/>:<sp/>argv[1]<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Site_2<sp/><sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>the<sp/>sites<sp/>and<sp/>insert<sp/>them<sp/>in<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sdg.insert(site);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>segment<sp/>Delaunay<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>sdg.is_valid(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Segment_Delaunay_graph_Linf_2ExVorEdges">
<title>Voronoi Edges</title>
<para>The following example demonstrates how to recover the defining sites for the edges of the Voronoi diagram (which are the duals of the edges of the segment Delaunay graph computed). <linebreak/>
<bold>File</bold> <ref refid="Segment_Delaunay_graph_Linf_2_2sdg-voronoi-edges-linf_8cpp-example" kindref="compound">Segment_Delaunay_graph_Linf_2/sdg-voronoi-edges-linf.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>standard<sp/>includes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>define<sp/>the<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Filtered_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/>CK;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Filtered__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Filtered_kernel&lt;CK&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs<sp/>for<sp/>the<sp/>traits<sp/>and<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_Linf_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_Delaunay_graph_Linf_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Segment__Delaunay__graph__Linf__traits__2" kindref="compound">CGAL::Segment_Delaunay_graph_Linf_traits_2&lt;Kernel&gt;</ref><sp/><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Segment__Delaunay__graph__Linf__2" kindref="compound">CGAL::Segment_Delaunay_graph_Linf_2&lt;Gt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SDG2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespacestd" kindref="compound">std</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[]<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!<sp/>((<sp/>argc<sp/>==<sp/>1<sp/>)<sp/>||<sp/>(argc<sp/>==<sp/>2))<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;usage:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>argv[0]<sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>[filename]\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifstream<sp/>ifs(<sp/>(argc<sp/>==<sp/>1)<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;data/sites2.cin&quot;</highlight><highlight class="normal"><sp/>:<sp/>argv[1]<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>ifs<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Site_2<sp/><sp/>site;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>the<sp/>sites<sp/>from<sp/>the<sp/>stream<sp/>and<sp/>insert<sp/>them<sp/>in<sp/>the<sp/>diagram</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>ifs<sp/>&gt;&gt;<sp/>site<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sdg.insert(<sp/>site<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_SDG_DEBUG(<sp/>sdg.file_output_verbose(std::cout);<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>sdg.is_valid(</highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ifs.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;About<sp/>to<sp/>validate<sp/>diagram<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>validate<sp/>the<sp/>diagram</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>sdg.is_valid(</highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/>1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Diagram<sp/>validated.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>now<sp/>walk<sp/>through<sp/>the<sp/>non-infinite<sp/>edges<sp/>of<sp/>the<sp/>segment<sp/>Delaunay</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>graphs<sp/>(which<sp/>are<sp/>dual<sp/>to<sp/>the<sp/>edges<sp/>in<sp/>the<sp/>Voronoi<sp/>diagram)<sp/>and</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>print<sp/>the<sp/>sites<sp/>defining<sp/>each<sp/>Voronoi<sp/>edge.</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>Each<sp/>oriented<sp/>Voronoi<sp/>edge<sp/>(horizontal<sp/>segment<sp/>in<sp/>the<sp/>figure</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>below)<sp/>is<sp/>defined<sp/>by<sp/>four<sp/>sites<sp/>A,<sp/>B,<sp/>C<sp/>and<sp/>D.</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/>\<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/>\<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/>\<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/>C<sp/><sp/>-----------------<sp/><sp/>D</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/>/<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/>/<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>A<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/>/<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>The<sp/>sites<sp/>A<sp/>and<sp/>B<sp/>define<sp/>the<sp/>(oriented)<sp/>bisector<sp/>on<sp/>which<sp/>the</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>edge<sp/>lies<sp/>whereas<sp/>the<sp/>sites<sp/>C<sp/>and<sp/>D,<sp/>along<sp/>with<sp/>A<sp/>and<sp/>B<sp/>define</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>the<sp/>two<sp/>endpoints<sp/>of<sp/>the<sp/>edge.<sp/>These<sp/>endpoints<sp/>are<sp/>the<sp/>Voronoi</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>vertices<sp/>of<sp/>the<sp/>triples<sp/>A,<sp/>B,<sp/>C<sp/>and<sp/>B,<sp/>A,<sp/>D.</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>If<sp/>one<sp/>of<sp/>these<sp/>vertices<sp/>is<sp/>the<sp/>vertex<sp/>at<sp/>infinity<sp/>the<sp/>string</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>&quot;infinite<sp/>vertex&quot;<sp/>is<sp/>printed;<sp/>the<sp/>corresponding<sp/>Voronoi<sp/>edge<sp/>is</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>actually<sp/>a<sp/>stright-line<sp/>or<sp/>parabolic<sp/>ray.</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>//<sp/>The<sp/>sites<sp/>below<sp/>are<sp/>printed<sp/>in<sp/>the<sp/>order<sp/>A,<sp/>B,<sp/>C,<sp/>D.</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>inf_vertex(</highlight><highlight class="stringliteral">&quot;infinite<sp/>vertex&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>vid[]<sp/>=<sp/>{</highlight><highlight class="charliteral">&apos;A&apos;</highlight><highlight class="normal">,<sp/></highlight><highlight class="charliteral">&apos;B&apos;</highlight><highlight class="normal">,<sp/></highlight><highlight class="charliteral">&apos;C&apos;</highlight><highlight class="normal">,<sp/></highlight><highlight class="charliteral">&apos;D&apos;</highlight><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SDG2::Finite_edges_iterator<sp/>eit<sp/>=<sp/>sdg.finite_edges_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>1;<sp/>eit<sp/>!=<sp/>sdg.finite_edges_end();<sp/>++eit,<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SDG2::Edge<sp/>e<sp/>=<sp/>*eit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>get<sp/>the<sp/>vertices<sp/>defining<sp/>the<sp/>Voronoi<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SDG2::Vertex_handle<sp/>v[]<sp/>=<sp/>{<sp/>e.first-&gt;vertex(<sp/>sdg.ccw(e.second)<sp/>),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>e.first-&gt;vertex(<sp/>sdg.cw(e.second)<sp/>),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>e.first-&gt;vertex(<sp/>e.second<sp/>),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sdg.tds().mirror_vertex(e.first,<sp/>e.second)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;---<sp/>Edge<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>---&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>4;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>if<sp/>the<sp/>vertex<sp/>is<sp/>the<sp/>vertex<sp/>at<sp/>infinity;<sp/>if<sp/>yes,<sp/>print</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>corresponding<sp/>string,<sp/>otherwise<sp/>print<sp/>the<sp/>site</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>sdg.is_infinite(v[i])<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>vid[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>inf_vertex<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>vid[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>v[i]-&gt;site()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
