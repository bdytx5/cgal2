<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Voronoi_diagram_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Voronoi Diagram Adaptor: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Voronoi Diagram Adaptor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Voronoi_Diagram_Adaptor"></a><a class="anchor" id="chaptervda"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Author</dt><dd>Menelaos Karavelas</dd></dl>
<p>This chapter describes an adaptor that adapts two-dimensional triangulated Delaunay graphs to the corresponding Voronoi diagrams. We start with a few definitions and a description of the issues that this adaptor addresses in Section <a class="el" href="index.html#secvda2intro">Introduction</a>. The software design of the Voronoi diagram adaptor package is described in Section <a class="el" href="index.html#secvda2design">Software Design</a>. In Section <a class="el" href="index.html#secvda2traits">The Adaptation Traits</a> we discuss the traits required for performing the adaptation, and finally in Section <a class="el" href="index.html#secvda2examples">Examples</a> we present a few examples using this adaptor.</p>
<h1><a class="anchor" id="secvda2intro"></a>
Introduction</h1>
<p>A Voronoi diagram is typically defined for a set of objects, also called sites in the sequel, that lie in some space \( \Sigma\) and a distance function that measures the distance of a point \( x\) in \( \Sigma\) from an object in the object set. In this package we are interested in planar Voronoi diagrams, so in the sequel the space \( \Sigma\) will be the space \( \mathbb{R}^2\). Let \( \mathcal{S}=\{S_1,S_2,\ldots,S_n\}\) be our set of sites and let \( \delta(x,S_i)\) denote the distance of a point \( x\in\mathbb{R}^2\) from the site \( S_i\). Given two sites \( S_i\) and \( S_j\), the set \( V_{ij}\) of points that are closer to \( S_i\) than to \( S_j\) with respect to the distance function \( \delta(x,\cdot)\) is simply the set: </p><p class="formulaDsp">
\[ V_{ij} = \{x\in\mathbb{R}^2:\, \delta(x,S_i)&lt;\delta(x,S_j)\}. \]
</p>
<p> We can then define the set \( V_i\) of points on the plane that are closer to \( S_i\) than to any other object in \( \mathcal{S}\) as: </p><p class="formulaDsp">
\[ V_i = \bigcap_{i\neq j} V_{ij}. \]
</p>
<p> The set \( V_i\) is said to be the <em>Voronoi cell</em> or <em>Voronoi face</em> of the site \( S_i\). The locus of points on the plane that are equidistant from exactly two sites \( S_i\) and \( S_j\) is called a <em>Voronoi bisector</em>. A point that is equidistant to three or more objects in \( \mathcal{S}\) is called a <em>Voronoi vertex</em>. A simply connected subset of a Voronoi bisector is called a <em>Voronoi edge</em>. The collection of Voronoi faces, edges and vertices is called the <em>Voronoi diagram</em> of the set \( \mathcal{S}\) with respect to the distance function \( \delta(x,\cdot)\), and it turns out that it is a subdivision of the plane, i.e., it is a planar graph.</p>
<p>We typically think of faces as 2-dimensional objects, edges as 1-dimensional objects and vertices as 0-dimensional objects. However, this may not be the case for several combinations of sites and distance functions (for example points in \( \mathbb{R}^2\) under the \( L_1\) or the \( L_\infty\) distance can produce 2-dimensional Voronoi edges). We call a Voronoi diagram <em>nice</em> if no such artifacts exist, i.e., if all vertices edges and faces are 0-, 1- and 2-dimensional, respectively.</p>
<p>Even nice Voronoi diagrams can end up being not so nice. The cell of a site can in general consist of several disconnected components. Such a case can happen, for example, when we consider weighted points \( Q_i=(p_i,\lambda_i)\), where \( p_i\in\mathbb{R}^2\), \( \lambda_i\in\mathbb{R}\), and the distance function is the Euclidean distance multiplied by the weight of each site, i.e., \( \delta_M(x,Q_i)=\lambda_i\,\|x-p_i\|\), where \( \|\cdot\|\) denotes the Euclidean norm. In this package we are going to restrict ourselves to nice Voronoi diagrams that have the property that the Voronoi cell of each site is a simply connected region of the plane. We are going to call such Voronoi diagrams <em>simple Voronoi diagrams</em>. Examples of simple Voronoi diagrams include the usual Euclidean Voronoi diagram of points, the Euclidean Voronoi diagram of a set of disks on the plane (i.e., the Apollonius diagram), the Euclidean Voronoi diagram of a set of disjoint convex objects on the plane, or the power or (Laguerre) diagram for a set of circles on the plane. In fact every instance of an <em>abstract Voronoi diagram</em> in the sense of Klein <a class="el" href="citelist.html#CITEREF_k-cavd-89">[1]</a> is a simple Voronoi diagram in our setting. In the sequel when we refer to Voronoi diagrams we will refer to simple Voronoi diagrams.</p>
<p>In many cases we are not really interested in computing the Voronoi diagram itself, but rather its dual graph, called the <em>Delaunay graph</em>. In general the Delaunay graph is a planar graph, each face of which consists of at least three edges. Under the non-degeneracy assumption that no point on the plane is equidistant, under the distance function, to more than three sites, the Delaunay graph is a planar graph with triangular faces. In certain cases this graph can actually be embedded with straight line segments in which case we talk about a triangulation. This is the case, for example, for the Euclidean Voronoi diagram of points, or the power diagram of a set of circles. The dual graphs are, respectively, the Delaunay triangulation and the regular triangulation of the corresponding site sets. Graphs of non-constant non-uniform face complexity can be undesirable in many applications, so typically we end up triangulating the non-triangular faces of the Delaunay graph. Intuitively this amounts to imposing an implicit or explicit perturbation scheme during the construction of the Delaunay graph, that perturbs the input sites in such a way so as not to have degenerate configurations.</p>
<p>Choosing between computing the Voronoi diagram or the (triangulated) Delaunay graph is a major decision while implementing an algorithm. It heavily affects the design and choice of the different data structures involved. Although in theory the two approaches are entirely equivalent, it is not so straightforward to go from one representation to the other. The objective of this package is to provide a generic way of going from triangulated Delaunay graphs to planar subdivisions represented through a DCEL data structure. The goal is to provide an adaptor that gives the look and feel of a DCEL data structure, although internally it keeps a graph data structure representing triangular graphs.</p>
<p>The adaptation might seem straightforward at a first glance, and more or less this is case; after all one graph is the dual of the other. The situation becomes complicated whenever we want to treat artifacts of the representation used. Suppose for example that we have a set of sites that contains subsets of sites in degenerate positions. The computed triangulated Delaunay graph has triangular faces that may be the result of an implicit or explicit perturbation scheme. The dual of such a triangulated Delaunay graph is a Voronoi diagram that has all its vertices of degree 3, and for that purpose we are going to call it a <em>degree-3 Voronoi diagram</em> in order to distinguish it from the true Voronoi diagram of the input sites. A degree-3 Voronoi diagram can have degenerate features, namely Voronoi edges of zero length, and/or Voronoi faces of zero area. Although we can potentially treat such artifacts, they are nonetheless artifacts of the algorithm we used and do not correspond to the true geometry of the Voronoi diagram.</p>
<p>The manner that we treat such issues in this package in a generic way is by defining an <em>adaptation policy</em>. The adaptation policy is responsible for determining which features in the degree-3 Voronoi diagram are to be rejected and which not. The policy to be used can vary depending on the application or the intended usage of the resulting Voronoi diagram. What we care about is that firstly the policy itself is consistent and, secondly, that the adaptation is also done in a consistent manner. The latter is the responsibility of the adaptor provided by this package, whereas the former is the responsibility of the implementor of a policy.</p>
<p>In this package we currently provide two types of adaptation policies. The first one is the simplest: we reject no feature of the degree-3 Voronoi diagram; we call such a policy an <em>identity policy</em> since the Voronoi diagram produced is identical to the degree-3 Voronoi diagram. The second type of policy eliminates the degenerate features from the degree-3 Voronoi diagram yielding the true geometry of the Voronoi diagram of the input sites; we call such policies <em>degeneracy removal policies</em>.</p>
<p>Delaunay graphs can be mutable or non-mutable. By mutable we mean that sites can be inserted or removed at any time, in an entirely on-line fashion. By non-mutable we mean that once the Delaunay graph has been created, no changes, with respect to the set of sites defining it, are allowed. If the Delaunay graph is a non-mutable one, then the Voronoi diagram adaptor is a non-mutable adaptor as well.</p>
<p>If the Delaunay graph is mutable then the question of whether the Voronoi diagram adaptor is also mutable is slightly more complex to answer. As long as the adaptation policy used does not maintain a state, the Voronoi diagram adaptor is a mutable one; this is the case, for example, with our identity policy or the degeneracy removal policies. If, however, the adaptor maintains a state, then whether it is mutable or non-mutable really depends on whether its state can be updated after every change in the Delaunay graph. Such policies are our caching degeneracy removal policies: some of them result in mutable adaptors others result in non-mutable ones. In Section <a class="el" href="index.html#secvda2ap">The Adaptation Policy</a> we discuss the issue in more detail.</p>
<h1><a class="anchor" id="secvda2design"></a>
Software Design</h1>
<p>The <code><a class="el" href="classCGAL_1_1Voronoi__diagram__2.html" title="The class Voronoi_diagram_2 provides an adaptor that enables us to view a triangulated Delaunay graph...">Voronoi_diagram_2</a>&lt;DG,AT,AP&gt;</code> class is parameterized by three template parameters. The first one must be a model of the <code><a class="el" href="classDelaunayGraph__2.html" title="The concept DelaunayGraph_2 defines the requirements for the first template parameter of the Voronoi_...">DelaunayGraph_2</a></code> concept. It corresponds to the API required by an object representing a Delaunay graph. All classes of <span style="font-variant: small-caps;">CGAL</span> that represent Delaunay diagrams are models of this concept, namely, Delaunay triangulations, regular triangulations, Apollonius graphs and segment Delaunay graphs. The second template parameter must be a model of the <code><a class="el" href="classAdaptationTraits__2.html" title="The concept AdaptationTraits_2 defines the functors required for accessing geometric information in t...">AdaptationTraits_2</a></code> concept. We discuss this concept in detail in Section <a class="el" href="index.html#secvda2traits">The Adaptation Traits</a>. The third template parameter must be model of the <code><a class="el" href="classAdaptationPolicy__2.html" title="The concept AdaptationPolicy_2 defines the requirements on the predicate functors that determine whet...">AdaptationPolicy_2</a></code> concept, which we discuss in detail in Section <a class="el" href="index.html#secvda2ap">The Adaptation Policy</a>.</p>
<p>The <code><a class="el" href="classCGAL_1_1Voronoi__diagram__2.html" title="The class Voronoi_diagram_2 provides an adaptor that enables us to view a triangulated Delaunay graph...">Voronoi_diagram_2</a>&lt;DG,AT,AP&gt;</code> class has been intentionally designed to provide an API similar to the arrangements class in <span style="font-variant: small-caps;">CGAL</span>: Voronoi diagrams are special cases of arrangements after all. The API of the two classes, however, could not be identical. The reason is that arrangements in <span style="font-variant: small-caps;">CGAL</span> do not yet support more than one unbounded faces, or equivalently, cannot handle unbounded curves. On the contrary, a Voronoi diagram defined over at least two generating sites, has at least two unbounded faces.</p>
<p>On a more technical level, the <code><a class="el" href="classCGAL_1_1Voronoi__diagram__2.html" title="The class Voronoi_diagram_2 provides an adaptor that enables us to view a triangulated Delaunay graph...">Voronoi_diagram_2</a>&lt;DG,AT,AP&gt;</code> class imitates the representation of the Voronoi diagram (seen as a planar subdivision) by a DCEL (Doubly Connected Edge List) data structure. We have vertices (the Voronoi vertices), halfedges (oriented versions of the Voronoi edges) and faces (the Voronoi cells). In particular, we can basically perform every operation we can perform in a standard DCEL data structure: </p><ul>
<li>
go from a halfedge to its next and previous in the face; </li>
<li>
go from one face to an adjacent one through a halfedge and its twin (opposite) halfedge; </li>
<li>
walk around the boundary of a face; </li>
<li>
enumerate/traverse the halfedges incident to a vertex </li>
<li>
from a halfedge, access the adjacent face; </li>
<li>
from a face, access an adjacent halfedges; </li>
<li>
from a halfedges, access its source and target vertices; </li>
<li>
from a vertex, access an incident halfedge. </li>
</ul>
<p>In addition to the above possibilities for traversal, we can also traverse the following features through iterators: </p><ul>
<li>
the vertices of the Voronoi diagram; </li>
<li>
the edges or halfedges of the Voronoi diagram; </li>
<li>
the faces of the Voronoi diagram; </li>
<li>
the bounded faces of the Voronoi diagram; </li>
<li>
the bounded halfedges of the Voronoi diagram; </li>
<li>
the unbounded faces of the Voronoi diagram; </li>
<li>
the unbounded halfedges of the Voronoi diagram; </li>
<li>
the sites defining the Voronoi diagram. </li>
</ul>
<p>Finally, depending on the adaptation traits passed to the Voronoi diagram adaptor, we can perform point location queries, namely given a point \( p\) we can determine the feature of the Voronoi diagram (vertex, edge, face) on which \( p\) lies.</p>
<h1><a class="anchor" id="secvda2traits"></a>
The Adaptation Traits</h1>
<p>The <code><a class="el" href="classAdaptationTraits__2.html" title="The concept AdaptationTraits_2 defines the functors required for accessing geometric information in t...">AdaptationTraits_2</a></code> concept defines the types and functors required by the adaptor in order to access geometric information in the Delaunay graph that is needed by the <code><a class="el" href="classCGAL_1_1Voronoi__diagram__2.html" title="The class Voronoi_diagram_2 provides an adaptor that enables us to view a triangulated Delaunay graph...">Voronoi_diagram_2</a>&lt;DG,AT,AP&gt;</code> class. In particular, it provides functors for accessing sites in the Delaunay graph and constructing Voronoi vertices from their dual faces in the Delaunay graph. Finally, it defines a tag that indicates whether nearest site queries are to be supported by the Voronoi diagram adaptor. If such queries are to be supported, a functor is required.</p>
<p>Given a query point, the nearest site functor should return information related to how many and which sites of the Voronoi diagram are at equal and minimal distance from the query point. In particular, if the query point is closest to a single site, the vertex handle of the Delaunay graph corresponding to this site is returned. If the query point is closest to exactly two site, the edge of the Delaunay graph that is dual to the Voronoi edges on which the query point lies is returned. If three (or more) sites are closest to the query point, then the query point coincides with a vertex in the Voronoi diagram, and the face handle of the face in the Delaunay graph that is dual to the Voronoi vertex is returned. This way of abstracting the point location mechanism allows for multiple different point location strategies, which are passed to the Voronoi diagram adaptor through different models of the <code><a class="el" href="classAdaptationTraits__2.html" title="The concept AdaptationTraits_2 defines the functors required for accessing geometric information in t...">AdaptationTraits_2</a></code> concept. The point location and nearest sites queries of the <code><a class="el" href="classCGAL_1_1Voronoi__diagram__2.html" title="The class Voronoi_diagram_2 provides an adaptor that enables us to view a triangulated Delaunay graph...">Voronoi_diagram_2</a>&lt;DG,AT,AP&gt;</code> class use internally this nearest site query functor.</p>
<p>In this package we provide four adaptation traits classes, all of which support nearest site queries: </p><ul>
<li>
The <code><a class="el" href="structCGAL_1_1Apollonius__graph__adaptation__traits__2.html" title="The class Apollonius_graph_adaptation_traits_2 provides a model for the AdaptationTraits_2 concept...">Apollonius_graph_adaptation_traits_2</a>&lt;AG2&gt;</code> class: it provides the adaptation traits for Apollonius graphs. </li>
<li>
The <code><a class="el" href="structCGAL_1_1Delaunay__triangulation__adaptation__traits__2.html" title="The class Delaunay_triangulation_adaptation_traits_2 provides a model for the AdaptationTraits_2 conc...">Delaunay_triangulation_adaptation_traits_2</a>&lt;DT2&gt;</code> class: it provides the adaptation traits for Delaunay triangulations. </li>
<li>
The <code><a class="el" href="structCGAL_1_1Regular__triangulation__adaptation__traits__2.html" title="The class Regular_triangulation_adaptation_traits_2 provides a model for the AdaptationTraits_2 conce...">Regular_triangulation_adaptation_traits_2</a>&lt;RT2&gt;</code> class: it provides the adaptation traits for regular triangulations. </li>
<li>
The <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__adaptation__traits__2.html" title="The class Segment_Delaunay_graph_adaptation_traits_2 provides a model for the AdaptationTraits_2 conc...">Segment_Delaunay_graph_adaptation_traits_2</a>&lt;SDG2&gt;</code> class: it provides the adaptation traits for segment Delaunay graphs. </li>
</ul>
<h1><a class="anchor" id="secvda2ap"></a>
The Adaptation Policy</h1>
<p>As mentioned above, when we perform the adaptation of a triangulated Delaunay graph to a Voronoi diagram, a question that arises is whether we want to eliminate certain features of the Delaunay graph when we construct its Voronoi diagram representation (such features could be the Voronoi edges of zero length or, for the Voronoi diagram of a set of segments forming a polygon, all edges outside the polygon). The manner that we treat such issues in this package in a generic way is by defining an adaptation policy. The adaptation policy is responsible for determining which features in the degree-3 Voronoi diagram are to be rejected and which not. The policy to be used can vary depending on the application or the intended usage of the resulting Voronoi diagram.</p>
<p>The concept <code><a class="el" href="classAdaptationPolicy__2.html" title="The concept AdaptationPolicy_2 defines the requirements on the predicate functors that determine whet...">AdaptationPolicy_2</a></code> defines the requirements on the predicate functors that determine whether a feature of the triangulated Delaunay graph should be rejected or not. More specifically it defines an <code>Edge_rejector</code> and a <code>Face_rejector</code> functor that answer the question: "Should this
edge (face) of the Voronoi diagram be rejected?". In addition to the edge and face rejectors the adaptation policy defines a tag, the <code>Has_inserter</code> tag. This tag is either set to <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__PkgStlExtensionUtilities.html#gab3e2296107b5d26c32c8183028a217f1"><code>CGAL::Tag_true</code></a> or to <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__PkgStlExtensionUtilities.html#ga89d5ecf1540b2ec0a2bf5dd003e186d0"><code>CGAL::Tag_false</code></a>. Semantically it determines if the adaptor is allowed to insert sites in an on-line fashion (on-line removals are not yet supported). In the former case, i.e., when on-line site insertions are allowed, an additional functor is required, the <code>Site_inserter</code> functor. This functor takes a reference to a Delaunay graph and a site, and inserts the site in the Delaunay graph. Upon successful insertion, a handle to the vertex representing the site in the Delaunay graph is returned.</p>
<p>We have implemented two types of policies that provide two different ways for answering the question of which features of the Voronoi diagram to keep and which to discard. The first one is called the <em>identity policy</em> and corresponds to the <code><a class="el" href="structCGAL_1_1Identity__policy__2.html" title="The class Identity_policy_2 provides a model for the AdaptationPolicy_2 concept. ">Identity_policy_2</a>&lt;DG,VT&gt;</code> class. This policy is in some sense the simplest possible one, since it does not reject any feature of the Delaunay graph. The Voronoi diagram provided by the adaptor is the true dual (from the graph-theoretical point of view) of the triangulated Delaunay graph adapted. This policy assumes that the Delaunay graph adapted allows for on-line insertions, and the <code>Has_inserter</code> tag is set to <code>Tag_true</code>. A default site inserter functor is also provided.</p>
<p>The second type of policy we provide is called <em>degeneracy removal policy</em>. If the set of sites defining the triangulated Delaunay graph contains subsets of sites in degenerate configurations, the graph-theoretical dual of the triangulated Delaunay graph has edges and potentially faces that are geometrically degenerate. By that we mean that the dual of the triangulated Delaunay graph can have Voronoi edges of zero length or Voronoi faces/cells of zero area. Such features may not be desirable and ideally we would like to eliminate them. The degeneracy removal policies eliminate exactly these features and provide a Voronoi diagram where all edges have non-zero length and all cells have non-zero area. More specifically, in these policies the <code>Edge_rejector</code> and <code>Face_rejector</code> functors reject the edges and vertices of the Delaunay graph that correspond to dual edges and faces that have zero length and area, respectively. In this package we provide four degeneracy removal policies, namely: </p><ul>
<li>
The <code><a class="el" href="structCGAL_1_1Apollonius__graph__degeneracy__removal__policy__2.html" title="The class Apollonius_graph_degeneracy_removal_policy_2 provides a model for the AdaptationPolicy_2 co...">Apollonius_graph_degeneracy_removal_policy_2</a>&lt;AG2&gt;</code> class: it provides an adaptation policy for removing degeneracies when adapting an Apollonius graph to an Apollonius diagram. </li>
<li>
The <code><a class="el" href="structCGAL_1_1Delaunay__triangulation__degeneracy__removal__policy__2.html" title="The class Delaunay_triangulation_degeneracy_removal_policy_2 provides a model for the AdaptationPolic...">Delaunay_triangulation_degeneracy_removal_policy_2</a>&lt;DT2&gt;</code> class: it provides an adaptation policy for removing degeneracies when adapting a Delaunay triangulation to a point Voronoi diagram. </li>
<li>
<p class="startli">The <code><a class="el" href="structCGAL_1_1Regular__triangulation__degeneracy__removal__policy__2.html" title="The class Regular_triangulation_degeneracy_removal_policy_2 provides a model for the AdaptationPolicy...">Regular_triangulation_degeneracy_removal_policy_2</a>&lt;RT2&gt;</code> class: it provides an adaptation policy for removing degeneracies when adapting a regular triangulation to a power diagram</p>
<p class="endli"></p>
</li>
<li>
The <code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__degeneracy__removal__policy__2.html" title="The class Segment_Delaunay_graph_degeneracy_removal_policy_2 provides a model for the AdaptationPolic...">Segment_Delaunay_graph_degeneracy_removal_policy_2</a>&lt;SDG2&gt;</code> class: it provides an adaptation policy for removing degeneracies when adapting a segment Delaunay graph to a segment Voronoi diagram. </li>
</ul>
<p>A variation of the degeneracy removal policies are the <em>caching degeneracy removal policies</em>. In these policies we cache the results of the edge and face rejectors. In particular, every time we want to determine, for example, if an edge of the Delaunay graph has, as dual edge in the Voronoi diagram, an edge of zero length, we check if the result has already been computed. If yes, we simply return the outcome. If not, we perform the necessary geometric tests, compute the answer, cache it and return it. Such a policy really pays off when we have a lot of degenerate data in our input set of sites. Verifying whether a Voronoi edge is degenerate or not implies computing the outcome of a predicate in a possibly degenerate or near degenerate configuration, which is typically very costly (compared to computing the same predicate in a generic configuration). To avoid this cost every single time we want to check if a Voronoi edge is degenerate or not, we compute the result of the geometric predicate the first time the adaptor asks for it, and simply lookup the answer in the future. In this package we provide four caching degeneracy removal policies, one per degeneracy removal policy mentioned above. Intentionally, we have not indicated the value of the <code>Has_inserter</code> tag for the degeneracy removal and caching degeneracy removal policies. The issue is discussed in detail in the sequel.</p>
<p>We raised the question above, as to whether the adaptor is a mutable or non-mutable one, in the sense of whether we can add/remove sites in an on-line fashion. The answer to this question depends on: (1) whether the Delaunay graph adapted allows for on-line insertions/removals and (2) whether the adaptation policies maintains a state and whether this state is easily maintainable when we want to allow for on-line modifications.</p>
<p>The way we indicate if we allow on-line insertions of sites is via the <code>Has_inserter</code> tag (as mentioned, on-line removals are currently not supported). The <code>Has_inserter</code> tag has two possible values, namely, <code>Tag_true</code> and <code>Tag_false</code>. The value <code>Tag_true</code> indicates that the Delaunay graph allows for on-line insertions, whereas the value <code>Tag_false</code> indicates the opposite. Note that these values <em>do not</em> indicate if the Delaunay graph supports on-line insertions, but rather whether the Voronoi diagram adaptor should be able to perform on-line insertions or not. This delicate point will be become clearer below.</p>
<p>Let us consider the various scenarios. If the Delaunay graph is non-mutable, the Voronoi diagram adaptor cannot perform on-line insertions of sites. In this case not only degeneracy removal policies, but rather every single adaptation policy for adapting the Delaunay graph in question should have the <code>Has_inserter</code> tag set to <code>Tag_false</code>.</p>
<p>If the Delaunay graph is mutable, i.e., on-line site insertions as are allowed, we can choose between two types of adaptation policies, those that allow these on-line insertions and those that do not. In the former case the <code>Has_inserter</code> tag should be set to <code>Tag_true</code>, whereas in the latter to <code>Tag_false</code>. In other words, even if the Delaunay graph is mutable, we can choose (by properly determining the value of the <code>Has_inserter</code> tag) if the adaptor should be mutable as well. At a first glance it may seem excessive to restrict existing functionality. There are situations, however, where such a choice is necessary.</p>
<p>Consider a caching degeneracy removal policy. If we do not allow for on-line insertions then the cached quantities are always valid since the Voronoi diagram never changes. If we allow for on-line insertions the Voronoi diagram can change, which implies that the results of the edge and faces degeneracy testers that we have cached are no longer valid or relevant. In these cases, we need to somehow update these cached results, and ideally we would like to do this in an efficient manner. The inherent dilemma in the above discussion is whether the Voronoi diagram adaptor should be able to perform on-line insertions of sites. The answer to this question in this framework is given by the <code>Has_inserter</code> tag. If the tag is set to <code>Tag_false</code> the adaptor cannot insert sites on-line, whereas if the tag is set to <code>Tag_true</code> the adaptor can add sites on-line. In other words, the <code>Has_inserter</code> tag determines how the Voronoi diagram adaptor should behave, and this is enough from the adaptor's point of view.</p>
<p>From the point of a view of a policy writer the dilemma is still there: "Should the policy allow for on-line insertions or not?" The answer really depends on what are the consequences of such a choice. For a policy that has no state, such as our degeneracy removal policies, it is natural to set the <code>Has_inserter</code> tag to <code>Tag_true</code>. For our caching degeneracy removal policies, our choice was made on the grounds of whether we can update the cached results efficiently when insertions are performed. For <span style="font-variant: small-caps;">CGAL</span>'s Apollonius graphs, Delaunay triangulation and regular triangulations it is possible to ask what are the edges and faces of the Delaunay graph that are to be destroyed when a query site is inserted. This is done via the <code>get_conflicts</code> method provided by these classes. Using the outcome of the <code>get_conflicts</code> method the site inserter can first update the cached results (i.e., indicate which are invalidated) and then perform the actual insertion. Such a method does not yet exist for segment Delaunay graphs. We have thus chosen to support on-line insertions for all non-caching degeneracy removal policies. The caching degeneracy removal policy for segment Delaunay graphs does not support on-line insertions, whereas the remaining three caching degeneracy removal policies support on-line insertions.</p>
<h2><a class="anchor" id="subsecvda2efficiency"></a>
Efficiency Considerations</h2>
<p>One last item that merits some discussion are the different choices from the point of view of time- and space-efficiency.</p>
<p>As far as the Voronoi diagram adaptor is concerned, only a copy of the adaptation traits and a copy of the adaptation policy are stored in it. The various adaptation traits classes we provide are empty classes (i.e., they do not store anything). The major time and space efficiency issues arise from the various implementations of the adaptation policies. Clearly, the identity policy has no dominant effect on neither the time or space efficiency. The costs when choosing this policy are due to the underlying Delaunay graph.</p>
<p>The non-caching degeneracy removal policies create a significant time overhead since every time we want to access a feature of the Voronoi diagram, we need to perform geometric tests in order to see if this feature or one of its neighboring ones has been rejected. Such a policy is acceptable if we know we are away from degeneracies or for small input sizes. In the case of the segment Delaunay graph, it is also the only policy we provide that at the same time removes degeneracies and allows for on-line insertion of sites. Caching policies seem to be the best choice for moderate to large input sizes (1000 sites and more). They do not suffer from the problem of dealing with degenerate configurations, but since they cache the results, they increase the space requirements by linear additive factor. To conclude, if the user is interested in getting a Voronoi diagram without degenerate features and knows all sites in advance, the best course of action is to insert all sites at construction time and use a caching degeneracy removal policy. This strategy avoids the updates of the cached results after each individual insertion, due to the features of the Voronoi diagram destroyed because of the site inserted.</p>
<h1><a class="anchor" id="secvda2examples"></a>
Examples</h1>
<p>In this section we present an example that shows how to perform point location queries.</p>
<p><br />
<b>File</b> <a class="el" href="Voronoi_diagram_2_2vd_2_point_location_8cpp-example.html">Voronoi_diagram_2/vd_2_point_location.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// standard includes</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// includes for defining the Voronoi diagram adaptor</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Voronoi_diagram_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_adaptation_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_adaptation_policies_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// typedefs for defining the adaptor</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>                  K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K&gt;</a>                                    DT;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Delaunay__triangulation__adaptation__traits__2.html">CGAL::Delaunay_triangulation_adaptation_traits_2&lt;DT&gt;</a>                 AT;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Delaunay__triangulation__caching__degeneracy__removal__policy__2.html">CGAL::Delaunay_triangulation_caching_degeneracy_removal_policy_2&lt;DT&gt;</a> AP;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Voronoi__diagram__2.html">CGAL::Voronoi_diagram_2&lt;DT,AT,AP&gt;</a>                                    VD;</div><div class="line"></div><div class="line"><span class="comment">// typedef for the result type of the point location</span></div><div class="line"><span class="keyword">typedef</span> AT::Site_2                    Site_2;</div><div class="line"><span class="keyword">typedef</span> AT::Point_2                   Point_2;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> VD::Locate_result             Locate_result;</div><div class="line"><span class="keyword">typedef</span> VD::Vertex_handle             Vertex_handle;</div><div class="line"><span class="keyword">typedef</span> VD::Face_handle               Face_handle;</div><div class="line"><span class="keyword">typedef</span> VD::Halfedge_handle           Halfedge_handle;</div><div class="line"><span class="keyword">typedef</span> VD::Ccb_halfedge_circulator   Ccb_halfedge_circulator;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> print_endpoint(Halfedge_handle e, <span class="keywordtype">bool</span> is_src) {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\t"</span>;</div><div class="line">  <span class="keywordflow">if</span> ( is_src ) {</div><div class="line">    <span class="keywordflow">if</span> ( e-&gt;has_source() )  std::cout &lt;&lt; e-&gt;source()-&gt;point() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span>  std::cout &lt;&lt; <span class="stringliteral">"point at infinity"</span> &lt;&lt; std::endl;</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <span class="keywordflow">if</span> ( e-&gt;has_target() )  std::cout &lt;&lt; e-&gt;target()-&gt;point() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span>  std::cout &lt;&lt; <span class="stringliteral">"point at infinity"</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::ifstream ifs(<span class="stringliteral">"data/data1.dt.cin"</span>);</div><div class="line">  assert( ifs );</div><div class="line"></div><div class="line">  VD vd;</div><div class="line"></div><div class="line">  Site_2 t;</div><div class="line">  <span class="keywordflow">while</span> ( ifs &gt;&gt; t ) { vd.insert(t); }</div><div class="line">  ifs.close();</div><div class="line"></div><div class="line">  assert( vd.is_valid() );</div><div class="line"></div><div class="line">  std::ifstream ifq(<span class="stringliteral">"data/queries1.dt.cin"</span>);</div><div class="line">  assert( ifq );</div><div class="line"></div><div class="line">  Point_2 p;</div><div class="line">  <span class="keywordflow">while</span> ( ifq &gt;&gt; p ) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Query point ("</span> &lt;&lt; p.x() &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; p.y()</div><div class="line">              &lt;&lt; <span class="stringliteral">") lies on a Voronoi "</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    Locate_result lr = vd.locate(p);</div><div class="line">    <span class="keywordflow">if</span> ( Vertex_handle* v = boost::get&lt;Vertex_handle&gt;(&amp;lr) ) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"vertex."</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"The Voronoi vertex is:"</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; (*v)-&gt;point() &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( Halfedge_handle* e = boost::get&lt;Halfedge_handle&gt;(&amp;lr) ) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"edge."</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"The source and target vertices "</span></div><div class="line">                &lt;&lt; <span class="stringliteral">"of the Voronoi edge are:"</span> &lt;&lt; std::endl;</div><div class="line">      print_endpoint(*e, <span class="keyword">true</span>);</div><div class="line">      print_endpoint(*e, <span class="keyword">false</span>);</div><div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( Face_handle* f = boost::get&lt;Face_handle&gt;(&amp;lr) ) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"face."</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"The vertices of the Voronoi face are"</span></div><div class="line">                &lt;&lt; <span class="stringliteral">" (in counterclockwise order):"</span> &lt;&lt; std::endl;</div><div class="line">      Ccb_halfedge_circulator ec_start = (*f)-&gt;ccb();</div><div class="line">      Ccb_halfedge_circulator ec = ec_start;</div><div class="line">      <span class="keywordflow">do</span> {</div><div class="line">        print_endpoint(ec, <span class="keyword">false</span>);</div><div class="line">      } <span class="keywordflow">while</span> ( ++ec != ec_start );</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  ifq.close();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:08 for CGAL 4.13 - 2D Voronoi Diagram Adaptor by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
