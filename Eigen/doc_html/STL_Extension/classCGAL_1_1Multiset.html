<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/STL_Extension/classCGAL_1_1Multiset.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - STL Extensions for CGAL: CGAL::Multiset&lt; Type, Compare, Allocator &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - STL Extensions for CGAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classCGAL_1_1Multiset.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Multiset-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CGAL::Multiset&lt; Type, Compare, Allocator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgStlExtension.html">STL Extensions for CGAL Reference</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Multiset.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"> 

<p><a class="anchor" id="classcgal_multimap"></a></p>
<p>An instance <code>s</code> of the parametrized data type <code><a class="el" href="classCGAL_1_1Multiset.html">Multiset</a></code> is a multi-set of elements of type <code>Type</code>, represented as a red-black tree (see [<a class="el" href="citelist.html#CITEREF_clrs-ia-01">[3]</a> Chapter 13 for an excellent introduction to red-black trees). The main difference between <code><a class="el" href="classCGAL_1_1Multiset.html">Multiset</a></code> and the <span style="font-variant: small-caps;">STL</span> <code>std::multiset</code> is that the latter uses a less-than functor with a Boolean return type, while our <code><a class="el" href="classCGAL_1_1Multiset.html">Multiset</a></code> class is parameterized by a comparison functor <code>Compare</code> that returns the three-valued <code>Comparison_result</code> (namely it returns either <code>SMALLER</code>, <code>EQUAL</code>, or <code>LARGER</code>). It is thus possible to maintain the underlying red-black tree with less invocations of the comparison functor. This leads to a speedup of about 5% even if we maintain a set of integers. When each comparison of two elements of type <code>Type</code> is an expensive operation (for example, when they are geometric entities represented using exact arithmetic), the usage of a three-valued comparison functor can lead to considerable decrease in the running times.</p>
<p>Moreover, <code><a class="el" href="classCGAL_1_1Multiset.html">Multiset</a></code> allows the insertion of an element into the set given its <em>exact</em> position, and not just using an insertion hint, as done by <code>std::multiset</code>. This can further reduce the running times, as additional comparison operations can be avoided.</p>
<p>In addition, the <code><a class="el" href="classCGAL_1_1Multiset.html">Multiset</a></code> guarantees that the order of elements sent to the comparison functor is fixed. For example, if we insert a new element <code>x</code> into the set (or erase an element from the set), then we always invoke <code>Compare() (x, y)</code> (and never <code>Compare() (y, x)</code>), where <code>y</code> is an element already stored in the set. This behavior, not supported by <code>std::multiset</code>, is sometimes crucial for designing more efficient comparison predicates.</p>
<p><code><a class="el" href="classCGAL_1_1Multiset.html">Multiset</a></code> also allows for look-up of keys whose type may differ from <code>Type</code>, as long as users supply a comparison functor <code>CompareKey</code>, where <code>CompareKey() (key, y)</code> returns the three-valued <code>Comparison_result</code> (<code>key</code> is the look-up key and <code>y</code> is an element of type <code>Type</code>). Indeed, it is very convenient to look-up equivalent objects in the set given just by their key. We note however that it is also possible to use a key of type <code>Type</code> and to employ the default <code>Compare</code> functor for the look-up, as done when using the <code>std::multiset</code> class.</p>
<dl class="section warning"><dt>Warning</dt><dd>Finally, <code><a class="el" href="classCGAL_1_1Multiset.html">Multiset</a></code> introduces the <code><a class="el" href="classCGAL_1_1Multiset.html#a1be039295328763c3094388b630c4fe7" title="concatenates all elements in s_prime into s and clears s_prime. ">catenate()</a></code> and <code><a class="el" href="classCGAL_1_1Multiset.html#a2ae90f67b298c349a83a6ef2304cc11c" title="splits s such that it contains all elements that are less than the given key and such that s_prime co...">split()</a></code> functions. The first function operates on <code>s</code> and accepts a second set <code>s2</code>, such that the maximum element in <code>s</code> is not greater than the minimal element in <code>s2</code>, and concatenates <code>s2</code> to <code>s</code>. The second function splits <code>s</code> into two sets, one containing all the elements that are less than a given key, and the other contains all elements greater than (or equal to) this key.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>the type of the stored elements. </td></tr>
    <tr><td class="paramname">Compare</td><td>the comparison-functor type. This type should provide the following operator for comparing two <code>Type</code> elements, namely: <br />
 <code>Comparison_result operator() (const Type&amp; t1, const Type&amp; t2) const;</code> <br />
 The <code>CGAL::Compare&lt;Type&gt;</code> functor is used by default. In this case, <code>Type</code> must support an equality operator (<code>operator==</code>) and a less-than operator (<code>operator&lt;</code>). </td></tr>
    <tr><td class="paramname">Allocator</td><td>the allocator type. <code>CGAL_ALLOCATOR</code> is used by default.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Assertions</b><br />
</p>
<p>The assertion and precondition flags for the <code><a class="el" href="classCGAL_1_1Multiset.html">Multiset</a></code> class use <code>MULTISET</code> in their names (i.e., <code>CGAL_MULTISET_NO_ASSERTIONS</code> and <code>CGAL_MULTISET_NO_PRECONDITIONS</code>).</p>
<p><b>Implementation</b><br />
</p>
<p><code><a class="el" href="classCGAL_1_1Multiset.html">Multiset</a></code> uses a proprietary implementation of a red-black tree data-structure. The red-black tree invariants guarantee that the height of a tree containing \( n\) elements is \( O(\log{n})\) (more precisely, it is bounded by \( 2 \log_{2}{n}\)). As a consequence, all methods that accept an element and need to locate it in the tree (namely <code>insert(x)</code>, <code>erase(x)</code>, <code>find(x)</code>, <code>count(x)</code>, <code>lower_bound(x)</code> , <code>upper_bound(x)</code>, <code>find_lower(x)</code> and <code>equal_range(x)</code>) take \( O(\log{n})\) time and perform \( O(\log{n})\) comparison operations.</p>
<p>On the other hand, the set operations that accept a position iterator (namely <code>insert_before(pos, x)</code>, <code>insert_after(pos, x)</code> and <code>erase(pos)</code>) are much more efficient as they can be performed at a <em>constant</em> amortized cost (see <a class="el" href="citelist.html#CITEREF_gs-dfbt-78">[4]</a> and <a class="el" href="citelist.html#CITEREF_t-dsna-83">[6]</a> for more details). More important, these set operations require <em>no</em> comparison operations. Therefore, it is highly recommended to maintain the set via iterators to the stored elements, whenever possible. The function <code>insert(pos, x)</code> is safer to use, but it takes amortized \( O(\min\{d,\log{n}\})\) time, where \( d\) is the distance between the given position and the true position of <code>x</code>. In addition, it always performs at least two comparison operations.</p>
<p>The <code><a class="el" href="classCGAL_1_1Multiset.html#a1be039295328763c3094388b630c4fe7" title="concatenates all elements in s_prime into s and clears s_prime. ">catenate()</a></code> and <code><a class="el" href="classCGAL_1_1Multiset.html#a2ae90f67b298c349a83a6ef2304cc11c" title="splits s such that it contains all elements that are less than the given key and such that s_prime co...">split()</a></code> functions are also very efficient, and can be performed in \( O(\log{n})\) time, where \( n\) is the total number of elements in the sets, and without performing any comparison operations (see <a class="el" href="citelist.html#CITEREF_t-dsna-83">[6]</a> for the details). Note however that the size of two sets resulting from a split operation is initially unknown, as it is impossible to compute it in less than linear time. Thus, the first invocation of <code><a class="el" href="classCGAL_1_1Multiset.html#a2cbe7ebc009b815552b7f91f39861d26" title="returns the number of elements stored in the set. ">size()</a></code> on such a set takes linear time, and <em>not</em> constant time.</p>
<p>The design is derived from the <span style="font-variant: small-caps;">STL</span> <code>multiset</code> class-template (see, e.g, <a class="el" href="citelist.html#CITEREF_cgal:ms-strg-96">[5]</a>), where the main differences between the two classes are highlighted in the class definition above. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf2d346b1bb7c1c85ab6f7f21e3666b9f"></a>In compliance with <span style="font-variant: small-caps;">STL</span>, the types <code>value_type</code> and <code>key_type</code> (both equivalent to <code>Type</code>), <code>reference</code> and <code>const_reference</code> (reference to a value-type), <code>key_compare</code> and <code>value_compare</code> (both equivalent to <code>Compare</code>), <code>size_type</code> and <code>difference_type</code> are defined as well. </p>
</td></tr>
<tr class="memitem:ab6755f133101132f62eaf49e4f8a2faa"><td class="memItemLeft" align="right" valign="top"><a id="ab6755f133101132f62eaf49e4f8a2faa"></a>
typedef <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a></td></tr>
<tr class="separator:ab6755f133101132f62eaf49e4f8a2faa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7e20d7e960306e8b3c25c9174e4a4075"><td class="memItemLeft" align="right" valign="top"><a id="a7e20d7e960306e8b3c25c9174e4a4075"></a>
typedef <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a7e20d7e960306e8b3c25c9174e4a4075">const_iterator</a></td></tr>
<tr class="memdesc:a7e20d7e960306e8b3c25c9174e4a4075"><td class="mdescLeft"> </td><td class="mdescRight">bi-directional iterators for the elements stored in the set. <br /></td></tr>
<tr class="separator:a7e20d7e960306e8b3c25c9174e4a4075"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b73fc6a125e01bd662d59bd2b7965c6"><td class="memItemLeft" align="right" valign="top"><a id="a5b73fc6a125e01bd662d59bd2b7965c6"></a>
typedef <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a5b73fc6a125e01bd662d59bd2b7965c6">reverse_iterator</a></td></tr>
<tr class="separator:a5b73fc6a125e01bd662d59bd2b7965c6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2c52a692f7283555e88ad75c2681a7b0"><td class="memItemLeft" align="right" valign="top"><a id="a2c52a692f7283555e88ad75c2681a7b0"></a>
typedef <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a2c52a692f7283555e88ad75c2681a7b0">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a2c52a692f7283555e88ad75c2681a7b0"><td class="mdescLeft"> </td><td class="mdescRight">reverse bi-directional iterators for the elements stored in the set. <br /></td></tr>
<tr class="separator:a2c52a692f7283555e88ad75c2681a7b0"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Creation</h2></td></tr>
<tr class="memitem:ac279545948dac161fb8a16b0dbc7ac2a"><td class="memItemLeft" align="right" valign="top"><a id="ac279545948dac161fb8a16b0dbc7ac2a"></a>
 </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#ac279545948dac161fb8a16b0dbc7ac2a">Multiset</a> ()</td></tr>
<tr class="memdesc:ac279545948dac161fb8a16b0dbc7ac2a"><td class="mdescLeft"> </td><td class="mdescRight">creates an an empty set <code>s</code> that uses a default comparison functor. <br /></td></tr>
<tr class="separator:ac279545948dac161fb8a16b0dbc7ac2a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a57d2a5a483e7df5231703916a2a0bfee"><td class="memItemLeft" align="right" valign="top"><a id="a57d2a5a483e7df5231703916a2a0bfee"></a>
 </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a57d2a5a483e7df5231703916a2a0bfee">Multiset</a> (const Compare &amp;comp)</td></tr>
<tr class="memdesc:a57d2a5a483e7df5231703916a2a0bfee"><td class="mdescLeft"> </td><td class="mdescRight">creates an an empty set <code>s</code> that uses the given comparison functor <code>comp</code>. <br /></td></tr>
<tr class="separator:a57d2a5a483e7df5231703916a2a0bfee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a75bd014fdd6f115cd60a3290e3165af7"><td class="memTemplParams" colspan="2"><a id="a75bd014fdd6f115cd60a3290e3165af7"></a>
template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a75bd014fdd6f115cd60a3290e3165af7"><td class="memTemplItemLeft" align="right" valign="top"> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a75bd014fdd6f115cd60a3290e3165af7">Multiset</a> (<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classInputIterator.html">InputIterator</a> last, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a75bd014fdd6f115cd60a3290e3165af7"><td class="mdescLeft"> </td><td class="mdescRight">creates a set <code>s</code> containing all elements in the range <code>[first, last)</code>, that uses the comparison functor <code>comp</code>. <br /></td></tr>
<tr class="separator:a75bd014fdd6f115cd60a3290e3165af7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afc7a2011be4ed7ad5122c44a83939722"><td class="memItemLeft" align="right" valign="top"><a id="afc7a2011be4ed7ad5122c44a83939722"></a>
 </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#afc7a2011be4ed7ad5122c44a83939722">Multiset</a> (const <a class="el" href="classCGAL_1_1Multiset.html">Multiset</a>&lt; Type, Compare, Allocator &gt; &amp;other)</td></tr>
<tr class="memdesc:afc7a2011be4ed7ad5122c44a83939722"><td class="mdescLeft"> </td><td class="mdescRight">copy constructor. <br /></td></tr>
<tr class="separator:afc7a2011be4ed7ad5122c44a83939722"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab9ae95de49206604173be46baac7ecf9"><td class="memItemLeft" align="right" valign="top"><a id="ab9ae95de49206604173be46baac7ecf9"></a>
const <a class="el" href="classCGAL_1_1Multiset.html">Multiset</a>&lt; Type, Compare, Allocator &gt; &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#ab9ae95de49206604173be46baac7ecf9">operator=</a> (const <a class="el" href="classCGAL_1_1Multiset.html">Multiset</a>&lt; Type, Compare, Allocator &gt; &amp;other)</td></tr>
<tr class="memdesc:ab9ae95de49206604173be46baac7ecf9"><td class="mdescLeft"> </td><td class="mdescRight">assignment operator. <br /></td></tr>
<tr class="separator:ab9ae95de49206604173be46baac7ecf9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8394ebc72a1bec73a8e6ab2b10875357"><td class="memItemLeft" align="right" valign="top"><a id="a8394ebc72a1bec73a8e6ab2b10875357"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a8394ebc72a1bec73a8e6ab2b10875357">swap</a> (<a class="el" href="classCGAL_1_1Multiset.html">Multiset</a>&lt; Type, Compare, Allocator &gt; &amp;other)</td></tr>
<tr class="memdesc:a8394ebc72a1bec73a8e6ab2b10875357"><td class="mdescLeft"> </td><td class="mdescRight">swaps the contents of <code>s</code> with those of the other set. <br /></td></tr>
<tr class="separator:a8394ebc72a1bec73a8e6ab2b10875357"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Access Member Functions</h2></td></tr>
<tr class="memitem:a5b9a2ec88f7d2842d977b0a0b8b82e3f"><td class="memItemLeft" align="right" valign="top"><a id="a5b9a2ec88f7d2842d977b0a0b8b82e3f"></a>
Compare </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a5b9a2ec88f7d2842d977b0a0b8b82e3f">key_comp</a> () const</td></tr>
<tr class="memdesc:a5b9a2ec88f7d2842d977b0a0b8b82e3f"><td class="mdescLeft"> </td><td class="mdescRight">the comparison functor used. <br /></td></tr>
<tr class="separator:a5b9a2ec88f7d2842d977b0a0b8b82e3f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a03efda11d41cc87e99f2da84287d3fec"><td class="memItemLeft" align="right" valign="top">Compare </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a03efda11d41cc87e99f2da84287d3fec">value_comp</a> () const</td></tr>
<tr class="memdesc:a03efda11d41cc87e99f2da84287d3fec"><td class="mdescLeft"> </td><td class="mdescRight">the comparison functor used (same as above).  <a href="#a03efda11d41cc87e99f2da84287d3fec">More...</a><br /></td></tr>
<tr class="separator:a03efda11d41cc87e99f2da84287d3fec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a002b03e915e8589f4f121f20dd5e689c"><td class="memItemLeft" align="right" valign="top"><a id="a002b03e915e8589f4f121f20dd5e689c"></a>
bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a002b03e915e8589f4f121f20dd5e689c">empty</a> ()</td></tr>
<tr class="memdesc:a002b03e915e8589f4f121f20dd5e689c"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code> if the set is empty, <code>false</code> otherwise. <br /></td></tr>
<tr class="separator:a002b03e915e8589f4f121f20dd5e689c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2cbe7ebc009b815552b7f91f39861d26"><td class="memItemLeft" align="right" valign="top"><a id="a2cbe7ebc009b815552b7f91f39861d26"></a>
size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a2cbe7ebc009b815552b7f91f39861d26">size</a> ()</td></tr>
<tr class="memdesc:a2cbe7ebc009b815552b7f91f39861d26"><td class="mdescLeft"> </td><td class="mdescRight">returns the number of elements stored in the set. <br /></td></tr>
<tr class="separator:a2cbe7ebc009b815552b7f91f39861d26"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8b5cd63c730990c614f55756ae3a6ae2"><td class="memItemLeft" align="right" valign="top"><a id="a8b5cd63c730990c614f55756ae3a6ae2"></a>
size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a8b5cd63c730990c614f55756ae3a6ae2">max_size</a> ()</td></tr>
<tr class="memdesc:a8b5cd63c730990c614f55756ae3a6ae2"><td class="mdescLeft"> </td><td class="mdescRight">returns the maximal number of elements the set can store (same as <code><a class="el" href="classCGAL_1_1Multiset.html#a2cbe7ebc009b815552b7f91f39861d26" title="returns the number of elements stored in the set. ">size()</a></code>). <br /></td></tr>
<tr class="separator:a8b5cd63c730990c614f55756ae3a6ae2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2428093d3eb307834678072d107aae18"><td class="memItemLeft" align="right" valign="top"><a id="a2428093d3eb307834678072d107aae18"></a>
<a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a2428093d3eb307834678072d107aae18">begin</a> ()</td></tr>
<tr class="memdesc:a2428093d3eb307834678072d107aae18"><td class="mdescLeft"> </td><td class="mdescRight">returns an iterator pointing to the first element stored in the set (a <code>const</code> version is also available). <br /></td></tr>
<tr class="separator:a2428093d3eb307834678072d107aae18"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a105830a7f979031fd40c96e88db7d49b"><td class="memItemLeft" align="right" valign="top"><a id="a105830a7f979031fd40c96e88db7d49b"></a>
<a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a105830a7f979031fd40c96e88db7d49b">end</a> ()</td></tr>
<tr class="memdesc:a105830a7f979031fd40c96e88db7d49b"><td class="mdescLeft"> </td><td class="mdescRight">returns an iterator pointing beyond the last element stored in the set (a <code>const</code> version is also available). <br /></td></tr>
<tr class="separator:a105830a7f979031fd40c96e88db7d49b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a039a792a26bfabc10bd3f2e180da1f4c"><td class="memItemLeft" align="right" valign="top"><a id="a039a792a26bfabc10bd3f2e180da1f4c"></a>
<a class="el" href="classCGAL_1_1Multiset.html#a5b73fc6a125e01bd662d59bd2b7965c6">reverse_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a039a792a26bfabc10bd3f2e180da1f4c">rbegin</a> ()</td></tr>
<tr class="memdesc:a039a792a26bfabc10bd3f2e180da1f4c"><td class="mdescLeft"> </td><td class="mdescRight">returns a reverse iterator pointing beyond the last element stored in the set (a <code>const</code> version is also available). <br /></td></tr>
<tr class="separator:a039a792a26bfabc10bd3f2e180da1f4c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a71e79822809560ce3e1cc7ac5352b533"><td class="memItemLeft" align="right" valign="top"><a id="a71e79822809560ce3e1cc7ac5352b533"></a>
<a class="el" href="classCGAL_1_1Multiset.html#a5b73fc6a125e01bd662d59bd2b7965c6">reverse_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a71e79822809560ce3e1cc7ac5352b533">rend</a> ()</td></tr>
<tr class="memdesc:a71e79822809560ce3e1cc7ac5352b533"><td class="mdescLeft"> </td><td class="mdescRight">returns a reverse iterator pointing to the first element stored in the set (a <code>const</code> version is also available). <br /></td></tr>
<tr class="separator:a71e79822809560ce3e1cc7ac5352b533"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Comparison Operations</h2></td></tr>
<tr class="memitem:a717f06e6a6f7ee880fe8f6eab1579960"><td class="memItemLeft" align="right" valign="top"><a id="a717f06e6a6f7ee880fe8f6eab1579960"></a>
bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a717f06e6a6f7ee880fe8f6eab1579960">operator==</a> (const <a class="el" href="classCGAL_1_1Multiset.html">Multiset</a>&lt; Type, Compare, Allocator &gt; &amp;other) const</td></tr>
<tr class="memdesc:a717f06e6a6f7ee880fe8f6eab1579960"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code> if the sequences of elements in the two sets are pairwise equal (using the comparison functor). <br /></td></tr>
<tr class="separator:a717f06e6a6f7ee880fe8f6eab1579960"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac51a626d8a5bb74b00dcdf40e8c5d8ff"><td class="memItemLeft" align="right" valign="top"><a id="ac51a626d8a5bb74b00dcdf40e8c5d8ff"></a>
bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#ac51a626d8a5bb74b00dcdf40e8c5d8ff">operator&lt;</a> (const <a class="el" href="classCGAL_1_1Multiset.html">Multiset</a>&lt; Type, Compare, Allocator &gt; &amp;other) const</td></tr>
<tr class="memdesc:ac51a626d8a5bb74b00dcdf40e8c5d8ff"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code> if the element sequence in <code>s</code> is lexicographically smaller than the element sequence of <code>other</code>. <br /></td></tr>
<tr class="separator:ac51a626d8a5bb74b00dcdf40e8c5d8ff"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Insertion Methods</h2></td></tr>
<tr class="memitem:a38025b7f2edf0c1658e797712efbafe5"><td class="memItemLeft" align="right" valign="top"><a id="a38025b7f2edf0c1658e797712efbafe5"></a>
<a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a38025b7f2edf0c1658e797712efbafe5">insert</a> (const Type &amp;x)</td></tr>
<tr class="memdesc:a38025b7f2edf0c1658e797712efbafe5"><td class="mdescLeft"> </td><td class="mdescRight">inserts the element <code>x</code> into the set and returns an iterator pointing to the newly inserted element. <br /></td></tr>
<tr class="separator:a38025b7f2edf0c1658e797712efbafe5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0cf593a9103b8110358027db5736290b"><td class="memTemplParams" colspan="2"><a id="a0cf593a9103b8110358027db5736290b"></a>
template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a0cf593a9103b8110358027db5736290b"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a0cf593a9103b8110358027db5736290b">insert</a> (<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classInputIterator.html">InputIterator</a> last)</td></tr>
<tr class="memdesc:a0cf593a9103b8110358027db5736290b"><td class="mdescLeft"> </td><td class="mdescRight">inserts all elements in the range <code>[first, last)</code> into the set. <br /></td></tr>
<tr class="separator:a0cf593a9103b8110358027db5736290b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4eeaf8f905eeb2674e29d2c0439a1c6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a4eeaf8f905eeb2674e29d2c0439a1c6b">insert</a> (<a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> position, const Type &amp;x)</td></tr>
<tr class="memdesc:a4eeaf8f905eeb2674e29d2c0439a1c6b"><td class="mdescLeft"> </td><td class="mdescRight">inserts the element <code>x</code> with a given iterator used as a hint for the position of the new element.  <a href="#a4eeaf8f905eeb2674e29d2c0439a1c6b">More...</a><br /></td></tr>
<tr class="separator:a4eeaf8f905eeb2674e29d2c0439a1c6b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a28e033f431134f9abcb888f33371b6a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a28e033f431134f9abcb888f33371b6a9">insert_before</a> (<a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> position, const Type &amp;x)</td></tr>
<tr class="memdesc:a28e033f431134f9abcb888f33371b6a9"><td class="mdescLeft"> </td><td class="mdescRight">inserts the element <code>x</code> as the predecessor of the element at the given position.  <a href="#a28e033f431134f9abcb888f33371b6a9">More...</a><br /></td></tr>
<tr class="separator:a28e033f431134f9abcb888f33371b6a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a9a6e1d5be4e10b9377455cce7cc89b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a6a9a6e1d5be4e10b9377455cce7cc89b">insert_after</a> (<a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> position, const Type &amp;x)</td></tr>
<tr class="memdesc:a6a9a6e1d5be4e10b9377455cce7cc89b"><td class="mdescLeft"> </td><td class="mdescRight">inserts the element <code>x</code> as the successor of the element at the given position.  <a href="#a6a9a6e1d5be4e10b9377455cce7cc89b">More...</a><br /></td></tr>
<tr class="separator:a6a9a6e1d5be4e10b9377455cce7cc89b"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Removal Methods</h2></td></tr>
<tr class="memitem:a8844fd265441635f374fac7f0507cc80"><td class="memItemLeft" align="right" valign="top"><a id="a8844fd265441635f374fac7f0507cc80"></a>
size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a8844fd265441635f374fac7f0507cc80">erase</a> (const Type &amp;x)</td></tr>
<tr class="memdesc:a8844fd265441635f374fac7f0507cc80"><td class="mdescLeft"> </td><td class="mdescRight">erases all elements equivalent to <code>x</code> from the set and returns the number of erased elements. <br /></td></tr>
<tr class="separator:a8844fd265441635f374fac7f0507cc80"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae9c79a7f3c1f85b96cdc6e8e89e06472"><td class="memItemLeft" align="right" valign="top"><a id="ae9c79a7f3c1f85b96cdc6e8e89e06472"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#ae9c79a7f3c1f85b96cdc6e8e89e06472">erase</a> (<a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> position)</td></tr>
<tr class="memdesc:ae9c79a7f3c1f85b96cdc6e8e89e06472"><td class="mdescLeft"> </td><td class="mdescRight">erases the element pointed by <code>position</code>. <br /></td></tr>
<tr class="separator:ae9c79a7f3c1f85b96cdc6e8e89e06472"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a726e1bbf117a2e76c02241e7ba5cb5a0"><td class="memItemLeft" align="right" valign="top"><a id="a726e1bbf117a2e76c02241e7ba5cb5a0"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a726e1bbf117a2e76c02241e7ba5cb5a0">clear</a> ()</td></tr>
<tr class="memdesc:a726e1bbf117a2e76c02241e7ba5cb5a0"><td class="mdescLeft"> </td><td class="mdescRight">clears the set (erases all stored elements). <br /></td></tr>
<tr class="separator:a726e1bbf117a2e76c02241e7ba5cb5a0"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Look-up Methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb8512b07e35659c86b79292ceb3a09ef"></a>All methods listed in this section can also accept a <code>Type</code> element as a look-up key.</p>
<p>In this case, it is not necessary to supply a <code>CompareKey</code> functor, as the <code>Compare</code> functor will be used by default. </p>
</td></tr>
<tr class="memitem:acf24c120c80b8a15a2fb0cdffad6bb1a"><td class="memTemplParams" colspan="2">template&lt;class Key , class CompareKey &gt; </td></tr>
<tr class="memitem:acf24c120c80b8a15a2fb0cdffad6bb1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#acf24c120c80b8a15a2fb0cdffad6bb1a">find</a> (const Key &amp;key, const CompareKey &amp;comp_key)</td></tr>
<tr class="memdesc:acf24c120c80b8a15a2fb0cdffad6bb1a"><td class="mdescLeft"> </td><td class="mdescRight">searches for the an element equivalent to <code>key</code> in the set.  <a href="#acf24c120c80b8a15a2fb0cdffad6bb1a">More...</a><br /></td></tr>
<tr class="separator:acf24c120c80b8a15a2fb0cdffad6bb1a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aab0ca799d988fde17441fdf5aabfad10"><td class="memTemplParams" colspan="2"><a id="aab0ca799d988fde17441fdf5aabfad10"></a>
template&lt;class Key , class CompareKey &gt; </td></tr>
<tr class="memitem:aab0ca799d988fde17441fdf5aabfad10"><td class="memTemplItemLeft" align="right" valign="top">size_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#aab0ca799d988fde17441fdf5aabfad10">count</a> (const Key &amp;key, const CompareKey &amp;comp_key) const</td></tr>
<tr class="memdesc:aab0ca799d988fde17441fdf5aabfad10"><td class="mdescLeft"> </td><td class="mdescRight">returns the number of elements equivalent to <code>key</code> in the set. <br /></td></tr>
<tr class="separator:aab0ca799d988fde17441fdf5aabfad10"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ada002f4a091eb4885bbdabcb7fd1020a"><td class="memTemplParams" colspan="2">template&lt;class Key , class CompareKey &gt; </td></tr>
<tr class="memitem:ada002f4a091eb4885bbdabcb7fd1020a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#ada002f4a091eb4885bbdabcb7fd1020a">lower_bound</a> (const Key &amp;key, const CompareKey &amp;comp_key)</td></tr>
<tr class="memdesc:ada002f4a091eb4885bbdabcb7fd1020a"><td class="mdescLeft"> </td><td class="mdescRight">returns an iterator pointing to the first element in the set that is not less than <code>key</code>.  <a href="#ada002f4a091eb4885bbdabcb7fd1020a">More...</a><br /></td></tr>
<tr class="separator:ada002f4a091eb4885bbdabcb7fd1020a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7997169c93dd4df7ff093b17f032e778"><td class="memTemplParams" colspan="2">template&lt;class Key , class CompareKey &gt; </td></tr>
<tr class="memitem:a7997169c93dd4df7ff093b17f032e778"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a7997169c93dd4df7ff093b17f032e778">upper_bound</a> (const Key &amp;key, const CompareKey &amp;comp_key)</td></tr>
<tr class="memdesc:a7997169c93dd4df7ff093b17f032e778"><td class="mdescLeft"> </td><td class="mdescRight">returns an iterator pointing to the first element in the set that is greater than <code>key</code>.  <a href="#a7997169c93dd4df7ff093b17f032e778">More...</a><br /></td></tr>
<tr class="separator:a7997169c93dd4df7ff093b17f032e778"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a48c422643f91a96a4a8d56f2caa3cd54"><td class="memTemplParams" colspan="2"><a id="a48c422643f91a96a4a8d56f2caa3cd54"></a>
template&lt;class Key , class CompareKey &gt; </td></tr>
<tr class="memitem:a48c422643f91a96a4a8d56f2caa3cd54"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a>, <a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a48c422643f91a96a4a8d56f2caa3cd54">equal_range</a> (const Key &amp;key, const CompareKey &amp;comp_key)</td></tr>
<tr class="memdesc:a48c422643f91a96a4a8d56f2caa3cd54"><td class="mdescLeft"> </td><td class="mdescRight">returns the range of set elements equivalent to the given key, namely <code>(lower_bound(key), upper_bound(key))</code> (a <code>const</code> version is also available). <br /></td></tr>
<tr class="separator:a48c422643f91a96a4a8d56f2caa3cd54"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a76622e6f890afddce5836acc0619c2"><td class="memTemplParams" colspan="2"><a id="a6a76622e6f890afddce5836acc0619c2"></a>
template&lt;class Key , class CompareKey &gt; </td></tr>
<tr class="memitem:a6a76622e6f890afddce5836acc0619c2"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a>, bool &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a6a76622e6f890afddce5836acc0619c2">find_lower</a> (const Key &amp;key, const CompareKey &amp;comp_key)</td></tr>
<tr class="memdesc:a6a76622e6f890afddce5836acc0619c2"><td class="mdescLeft"> </td><td class="mdescRight">returns a pair comprised of <code>lower_bound(key)</code> and a Boolean flag indicating whether this iterator points to an element equivalent to the given key (a <code>const</code> version is also available). <br /></td></tr>
<tr class="separator:a6a76622e6f890afddce5836acc0619c2"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Special Operations</h2></td></tr>
<tr class="memitem:ac5560e651858b35365af3f45e7854a73"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#ac5560e651858b35365af3f45e7854a73">replace</a> (<a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> position, const Type &amp;x)</td></tr>
<tr class="memdesc:ac5560e651858b35365af3f45e7854a73"><td class="mdescLeft"> </td><td class="mdescRight">replaces the element stored at the given position with <code>x</code>.  <a href="#ac5560e651858b35365af3f45e7854a73">More...</a><br /></td></tr>
<tr class="separator:ac5560e651858b35365af3f45e7854a73"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9d72aeedf37177117efac368604081e6"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a9d72aeedf37177117efac368604081e6">swap</a> (<a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> pos1, <a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> pos2)</td></tr>
<tr class="memdesc:a9d72aeedf37177117efac368604081e6"><td class="mdescLeft"> </td><td class="mdescRight">swaps places between the two elements given by <code>pos1</code> and <code>pos2</code>.  <a href="#a9d72aeedf37177117efac368604081e6">More...</a><br /></td></tr>
<tr class="separator:a9d72aeedf37177117efac368604081e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1be039295328763c3094388b630c4fe7"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a1be039295328763c3094388b630c4fe7">catenate</a> (Self &amp;s_prime)</td></tr>
<tr class="memdesc:a1be039295328763c3094388b630c4fe7"><td class="mdescLeft"> </td><td class="mdescRight">concatenates all elements in <code>s_prime</code> into <code>s</code> and clears <code>s_prime</code>.  <a href="#a1be039295328763c3094388b630c4fe7">More...</a><br /></td></tr>
<tr class="separator:a1be039295328763c3094388b630c4fe7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2ae90f67b298c349a83a6ef2304cc11c"><td class="memTemplParams" colspan="2">template&lt;class Key , class CompareKey &gt; </td></tr>
<tr class="memitem:a2ae90f67b298c349a83a6ef2304cc11c"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#a2ae90f67b298c349a83a6ef2304cc11c">split</a> (Key key, CompareKey comp_key, Self &amp;s_prime)</td></tr>
<tr class="memdesc:a2ae90f67b298c349a83a6ef2304cc11c"><td class="mdescLeft"> </td><td class="mdescRight">splits <code>s</code> such that it contains all elements that are less than the given <code>key</code> and such that <code>s_prime</code> contains all other elements.  <a href="#a2ae90f67b298c349a83a6ef2304cc11c">More...</a><br /></td></tr>
<tr class="separator:a2ae90f67b298c349a83a6ef2304cc11c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa4257434f06b5553ff71e94d7a6a182e"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Multiset.html#aa4257434f06b5553ff71e94d7a6a182e">split</a> (<a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> position, Self &amp;s_prime)</td></tr>
<tr class="memdesc:aa4257434f06b5553ff71e94d7a6a182e"><td class="mdescLeft"> </td><td class="mdescRight">splits <code>s</code> such that it contains all set elements in the range <code>[begin, position)</code> and such that <code>s_prime</code> contains all elements in the range <code>[position, <a class="el" href="classCGAL_1_1Multiset.html#a105830a7f979031fd40c96e88db7d49b" title="returns an iterator pointing beyond the last element stored in the set (a const version is also avail...">end()</a>)</code>.  <a href="#aa4257434f06b5553ff71e94d7a6a182e">More...</a><br /></td></tr>
<tr class="separator:aa4257434f06b5553ff71e94d7a6a182e"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1be039295328763c3094388b630c4fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be039295328763c3094388b630c4fe7">◆ </a></span>catenate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::catenate </td>
          <td>(</td>
          <td class="paramtype">Self &amp; </td>
          <td class="paramname"><em>s_prime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>concatenates all elements in <code>s_prime</code> into <code>s</code> and clears <code>s_prime</code>. </p>
<p>All iterators to <code>s</code> and to <code>s_prime</code> remain valid. </p><dl class="section pre"><dt>Precondition</dt><dd>The maximal element in <code>s</code> is not greater than the minimal element in <code>s_prime</code>. </dd></dl>

</div>
</div>
<a id="acf24c120c80b8a15a2fb0cdffad6bb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf24c120c80b8a15a2fb0cdffad6bb1a">◆ </a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Key , class CompareKey &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp; </td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompareKey &amp; </td>
          <td class="paramname"><em>comp_key</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>searches for the an element equivalent to <code>key</code> in the set. </p>
<p>If the set contains objects equivalent to <code>key</code>, it returns an iterator pointing to the first one. Otherwise, <code><a class="el" href="classCGAL_1_1Multiset.html#a105830a7f979031fd40c96e88db7d49b" title="returns an iterator pointing beyond the last element stored in the set (a const version is also avail...">end()</a></code> is returned (a <code>const</code> version is also available). </p>

</div>
</div>
<a id="a4eeaf8f905eeb2674e29d2c0439a1c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eeaf8f905eeb2674e29d2c0439a1c6b">◆ </a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp; </td>
          <td class="paramname"><em>x</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts the element <code>x</code> with a given iterator used as a hint for the position of the new element. </p>
<p>It Returns an iterator pointing to the newly inserted element. </p>

</div>
</div>
<a id="a6a9a6e1d5be4e10b9377455cce7cc89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9a6e1d5be4e10b9377455cce7cc89b">◆ </a></span>insert_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp; </td>
          <td class="paramname"><em>x</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts the element <code>x</code> as the successor of the element at the given position. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The operation does not violate the set order - that is, <code>x</code> is not less than the element pointed by <code>position</code> and not greater than its current successor. </dd></dl>

</div>
</div>
<a id="a28e033f431134f9abcb888f33371b6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e033f431134f9abcb888f33371b6a9">◆ </a></span>insert_before()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::insert_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp; </td>
          <td class="paramname"><em>x</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts the element <code>x</code> as the predecessor of the element at the given position. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The operation does not violate the set order - that is, <code>x</code> is not greater than the element pointed by <code>position</code> and not less than its current predecessor. </dd></dl>

</div>
</div>
<a id="ada002f4a091eb4885bbdabcb7fd1020a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada002f4a091eb4885bbdabcb7fd1020a">◆ </a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Key , class CompareKey &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp; </td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompareKey &amp; </td>
          <td class="paramname"><em>comp_key</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns an iterator pointing to the first element in the set that is not less than <code>key</code>. </p>
<p>If all set elements are less than <code>key</code>, <code><a class="el" href="classCGAL_1_1Multiset.html#a105830a7f979031fd40c96e88db7d49b" title="returns an iterator pointing beyond the last element stored in the set (a const version is also avail...">end()</a></code> is returned (a <code>const</code> version is also available). </p>

</div>
</div>
<a id="ac5560e651858b35365af3f45e7854a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5560e651858b35365af3f45e7854a73">◆ </a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp; </td>
          <td class="paramname"><em>x</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>replaces the element stored at the given position with <code>x</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The operation does not violate the set order - that is, <code>x</code> is not less that <code>position</code>'s predecessor and not greater than its successor. </dd></dl>

</div>
</div>
<a id="a2ae90f67b298c349a83a6ef2304cc11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae90f67b298c349a83a6ef2304cc11c">◆ </a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Key , class CompareKey &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::split </td>
          <td>(</td>
          <td class="paramtype">Key </td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompareKey </td>
          <td class="paramname"><em>comp_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Self &amp; </td>
          <td class="paramname"><em>s_prime</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>splits <code>s</code> such that it contains all elements that are less than the given <code>key</code> and such that <code>s_prime</code> contains all other elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>s_prime</code> is initially empty. </dd></dl>

</div>
</div>
<a id="aa4257434f06b5553ff71e94d7a6a182e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4257434f06b5553ff71e94d7a6a182e">◆ </a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Self &amp; </td>
          <td class="paramname"><em>s_prime</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>splits <code>s</code> such that it contains all set elements in the range <code>[begin, position)</code> and such that <code>s_prime</code> contains all elements in the range <code>[position, <a class="el" href="classCGAL_1_1Multiset.html#a105830a7f979031fd40c96e88db7d49b" title="returns an iterator pointing beyond the last element stored in the set (a const version is also avail...">end()</a>)</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>s_prime</code> is initially empty. </dd></dl>

</div>
</div>
<a id="a9d72aeedf37177117efac368604081e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d72aeedf37177117efac368604081e6">◆ </a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> </td>
          <td class="paramname"><em>pos2</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>swaps places between the two elements given by <code>pos1</code> and <code>pos2</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The operation does not violate the set order - that is, <code>pos1</code> and <code>pos2</code> store equivalent elements. </dd></dl>

</div>
</div>
<a id="a7997169c93dd4df7ff093b17f032e778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7997169c93dd4df7ff093b17f032e778">◆ </a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Key , class CompareKey &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Multiset.html#ab6755f133101132f62eaf49e4f8a2faa">iterator</a> <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp; </td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompareKey &amp; </td>
          <td class="paramname"><em>comp_key</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns an iterator pointing to the first element in the set that is greater than <code>key</code>. </p>
<p>If no set element is greater than <code>key</code>, <code><a class="el" href="classCGAL_1_1Multiset.html#a105830a7f979031fd40c96e88db7d49b" title="returns an iterator pointing beyond the last element stored in the set (a const version is also avail...">end()</a></code> is returned (a <code>const</code> version is also available). </p>

</div>
</div>
<a id="a03efda11d41cc87e99f2da84287d3fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03efda11d41cc87e99f2da84287d3fec">◆ </a></span>value_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Compare <a class="el" href="classCGAL_1_1Multiset.html">CGAL::Multiset</a>&lt; Type, Compare, Allocator &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the comparison functor used (same as above). </p>
<p>Both functions have a non-const version that return a reference to the comparison functor. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../Manual/namespaceCGAL.html">CGAL</a></li><li class="navelem"><a class="el" href="classCGAL_1_1Multiset.html">Multiset</a></li>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:07 for CGAL 4.13 - STL Extensions for CGAL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>



</html>
