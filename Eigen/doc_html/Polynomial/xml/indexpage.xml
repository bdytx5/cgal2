<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Polynomial"/><anchor id="index_1ChapterPolynomial"/> <simplesect kind="author"><para>Michael Hemmer</para></simplesect>
</para><sect1 id="index_1PolynomialFundamentals">
<title>Fundamentals</title>
<para>Note that this is just a very brief introduction to polynomials. For a quick reference we refer to the Wikipedia or for a more elaborate introduction to any class book on elementary algebra.</para><para>A <emphasis>polynomial</emphasis> is either zero, or can be written as the sum of one or more non-zero <emphasis>terms</emphasis>. The number of terms is finite. A term consist of a constant <emphasis>coefficient</emphasis> and a <emphasis>monomial</emphasis>, that is, the product of zero or more variables. Each variable may have an exponent that is a non-negative integer. The exponent on a variable in a term is equal to the <emphasis>degree</emphasis> of that variable in that term. A term with no variables is called a constant term. The degree of a constant term is 0.</para><para>For example, <formula id="152">$ -7x^3y$</formula> is a term. The coefficient is <formula id="153">$ -7$</formula>, the monomial is <formula id="154">$ x^3y$</formula>, comprised of the variables <formula id="4">$ x$</formula> and <formula id="155">$ y$</formula>, the degree of <formula id="4">$ x$</formula> is three, and the degree of <formula id="155">$ y$</formula> is one. The <emphasis>total degree</emphasis> of the entire term is the sum of the degrees in each variable. In the example above, the degree is <formula id="156">$ 3 + 1 = 4$</formula>.</para><para>A one-variable (univariate) polynomial <formula id="7">$ f$</formula> of degree <formula id="91">$ n$</formula> has the following form:</para><para><formula id="157">\[ f = a_nx^n + a_{n-1}x^{n-1} + ... + a_2x^2 + a_1x + a_0 \]</formula></para><para>The coefficient <formula id="158">$ a_0$</formula> is called the <emphasis>constant coefficient</emphasis>, <formula id="159">$ a_n$</formula> is called the <emphasis>leading coefficient</emphasis>. If <formula id="7">$ f$</formula> is not the zero polynomial the leading coefficient is not zero. The polynomial is called monic if <formula id="160">$ a_n = 1$</formula>. In case the coefficient domain of <formula id="7">$ f$</formula> possess a greatest common divisor (gcd) the <emphasis>content</emphasis> of <formula id="7">$ f$</formula> is the gcd of all coefficients of <formula id="7">$ f$</formula>. For instance, the content of <formula id="161">$ 12 x^3 + 6$</formula> is <formula id="162">$ 6$</formula>.</para><para>A multivariate polynomial is a polynomial in more than one variable. According to the number of variables it is possible to further classify multivariate polynomials as bivariate, trivariate etc. In contrast to univariate polynomials the terms of a multivariate polynomial are not completely ordered by their total degree. However, given a certain order on the variables it is possible to define a lexicographic order on the terms. Given this order the leading coefficient of a multivariate polynomial is defined as the coefficient of the highest term. For instance the leading coefficient of the multivariate polynomial <formula id="163">$ p = 5 x^3y + 7xy^2$</formula> is <formula id="164">$ 7$</formula>, given that <formula id="155">$ y$</formula> has an higher order than <formula id="4">$ x$</formula>.</para><para>However, it is also possible to interpret a multivariate polynomial as a univariate polynomial in that variable. For instance the trivariate polynomial <formula id="165">\[ q = x^5 + 7x^2y^1z^2 + 13x^1y^2z^2 \in \Z[x,y,z] \]</formula> may be interpreted as a univariate polynomial in <formula id="166">$ z$</formula>, that is, <formula id="21">$ q$</formula> is interpreted as an element of <formula id="167">$ R[z]$</formula>, with <formula id="168">$ R=\Z[x,y]$</formula>. <formula id="169">\[ q = (13x^1y^2 + 7x^2y^1)z^2 + x^5z^0 \in R[z] \]</formula> In this case the leading coefficient of <formula id="21">$ q$</formula> with respect to <formula id="166">$ z$</formula> is <formula id="170">$ 13x^1y^2 + 7x^2y^1$</formula> and <formula id="171">$ x^5$</formula> becomes the &apos;constant&apos; term.</para><para>A <emphasis>homogeneous polynomial</emphasis> is a polynomial whose terms do all have the same total degree. For example, <formula id="172">$ h = x^5 + 7x^2y^1z^2 + 13x^1y^2z^2$</formula> is a homogeneous polynomial of degree <formula id="143">$ 5$</formula>, in three variables.</para></sect1>
<sect1 id="index_1PolynomialGeneral">
<title>General Design</title>
<para>The package introduces a concept <computeroutput><ref refid="classPolynomial__d" kindref="compound">Polynomial_d</ref></computeroutput>, a concept for multivariate polynomials in <formula id="3">$ d$</formula> variables. Though the concept is written for an arbitrary number of variables, the number of variables is considered as fixed for a particular model of <computeroutput><ref refid="classPolynomial__d" kindref="compound">Polynomial_d</ref></computeroutput>. The concept also allows univariate polynomials.</para><para>First of all a model of <computeroutput><ref refid="classPolynomial__d" kindref="compound">Polynomial_d</ref></computeroutput> is considered as an algebraic structure, that is, the ring operations <formula id="173">$ \{+, -, \cdot\}$</formula> are provided due to the fact that <computeroutput><ref refid="classPolynomial__d" kindref="compound">Polynomial_d</ref></computeroutput> refines at least the concept <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomainWithoutDivision</ref></computeroutput>. However, a model of <computeroutput><ref refid="classPolynomial__d" kindref="compound">Polynomial_d</ref></computeroutput> has to be accompanied by a traits class <computeroutput><ref refid="classCGAL_1_1Polynomial__traits__d" kindref="compound">Polynomial_traits_d</ref>&lt;<ref refid="classPolynomial__d" kindref="compound">Polynomial_d</ref>&gt;</computeroutput> being a model of <computeroutput><ref refid="classPolynomialTraits__d" kindref="compound">PolynomialTraits_d</ref></computeroutput>. This traits class provides all further functionalities on polynomials.</para><para>Given a <formula id="3">$ d$</formula>-variate polynomial over some base ring <formula id="26">$ R$</formula> there are at least two different possible views on such a polynomial. <itemizedlist>
<listitem>
<para>The recursive or univariate view: In this view, a polynomial is considered as an element of <formula id="149">$ R[x_0,\dots,x_{d-2}][x_{d-1}]$</formula>. That is, the polynomial is treated as a univariate polynomial over the ring <formula id="150">$ R[x_0,\dots,x_{d-2}]$</formula>. </para></listitem>
<listitem>
<para>The symmetric or multivariate view: This view is almost symmetric with respect to all variables. It considers the polynomial as an element of <formula id="151">$ R [x_0,\dots,x_{d-1}]$</formula>. </para></listitem>
</itemizedlist>
</para><para>According to these two different views the traits class is required to provide two different coefficient types: <itemizedlist>
<listitem>
<para><computeroutput>Polynomial_traits_d::Coefficient_type</computeroutput> representing <formula id="150">$ R[x_0,\dots,x_{d-2}]$</formula>. </para></listitem>
<listitem>
<para><computeroutput>Polynomial_traits_d::Innermost_coefficient_type</computeroutput> representing the base ring <formula id="26">$ R$</formula>. </para></listitem>
</itemizedlist>
</para><para>Another important type which is introduced by this package is <computeroutput><ref refid="classCGAL_1_1Exponent__vector" kindref="compound">Exponent_vector</ref></computeroutput>. It is derived from <computeroutput>std::vector&lt;int&gt;</computeroutput> and used to identify multivariate monomials. For instance the exponent vector containing the sequence <formula id="174">$ [3,2,4]$</formula> corresponds to the trivariate monomial <formula id="175">$ x_0^3x_1^2x_2^4$</formula>. Note that a vector with negative exponents is considered as invalid. However, we allow negative exponents as they may appear as intermediate results, in particular we did <emphasis>not</emphasis> derive from <computeroutput>std::vector&lt;unsigned int&gt;</computeroutput>.</para></sect1>
<sect1 id="index_1PolynomialConstructing">
<title>Constructing a Multivariate Polynomial</title>
<para>First of all the concept <computeroutput><ref refid="classPolynomial__d" kindref="compound">Polynomial_d</ref></computeroutput> requires that the model is constructible from int. This is due to the fact that <computeroutput><ref refid="classPolynomial__d" kindref="compound">Polynomial_d</ref></computeroutput> refines <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomainWithoutDivision</ref></computeroutput> which in turn refines <computeroutput><ref refid="classFromIntConstructible" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">FromIntConstructible</ref></computeroutput>. Of course this allows only the construction of constant polynomials.</para><para>In general a polynomial is constructed using the functor <computeroutput>Polynomial_traits_d::Construct_polynomial</computeroutput> a model of <computeroutput><ref refid="classPolynomialTraits__d_1_1ConstructPolynomial" kindref="compound">PolynomialTraits_d::ConstructPolynomial</ref></computeroutput>. Basically there are two options: <itemizedlist>
<listitem>
<para>The polynomial is constructed from an iterator range with value type <computeroutput>Polynomial_traits_d::Coefficient_type</computeroutput>, where the <computeroutput>begin</computeroutput> iterator refers to the constant term (constant with respect to the outermost variable). </para></listitem>
<listitem>
<para>The polynomial is constructed from an iterator range with value type <computeroutput>std::pair&lt;<ref refid="classCGAL_1_1Exponent__vector" kindref="compound">Exponent_vector</ref>, Polynomial_traits_d::Innermost_coefficient_type&gt;</computeroutput>, where each pair defines the coefficient for the monomial defined by the exponent vector. </para></listitem>
</itemizedlist>
</para><para>However, in some cases it might be more convenient to just construct the polynomials representing the different variables and to obtain the final polynomial using algebraic expressions. The most elegant way to construct a certain variable is <computeroutput>Polynomial_traits_d::Shift</computeroutput> being a model of <computeroutput><ref refid="classPolynomialTraits__d_1_1Shift" kindref="compound">PolynomialTraits_d::Shift</ref></computeroutput>.</para><sect2 id="index_1PolynomialExample">
<title>Example</title>
<para>The following example illustrates different ways to construct a bivariate polynomial: <linebreak/>
<bold>File</bold> <ref refid="Polynomial_2construction_8cpp-example" kindref="compound">Polynomial/construction.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_traits_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_type_generator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Polynomial_type_generator&lt;int,2&gt;::Type</ref><sp/>Poly_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polynomial__traits__d" kindref="compound">CGAL::Polynomial_traits_d&lt;Poly_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PT_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PT_2::Coefficient_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Poly_1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PT_2::Innermost_coefficient_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Integer;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Construct_polynomial<sp/>construct_polynomial;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>dc;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>constructing<sp/>a<sp/>constant<sp/>polynomial<sp/>from<sp/>int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>two(2);<sp/></highlight><highlight class="comment">//<sp/>=<sp/>2<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;A<sp/>constant<sp/>polynomial:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>two<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>construction<sp/>from<sp/>an<sp/>iterator<sp/>range<sp/>of<sp/>univariate<sp/>polynomials</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Poly_1&gt;<sp/>univariate_coeffs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>univariate_coeffs.push_back(Poly_1(3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>univariate_coeffs.push_back(Poly_1(0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>univariate_coeffs.push_back(Poly_1(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>F<sp/>=<sp/></highlight><highlight class="comment">//<sp/>5*y^2<sp/>+<sp/>3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>construct_polynomial(univariate_coeffs.begin(),univariate_coeffs.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>bivariate<sp/>polynomial<sp/>F:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>F<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>construction<sp/>from<sp/>an<sp/>iterator<sp/>range<sp/>over<sp/>monomials<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;std::pair&lt;CGAL::Exponent_vector,<sp/>Integer&gt;<sp/>&gt;<sp/>innermost_coeffs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>innermost_coeffs.push_back(std::make_pair(<ref refid="classCGAL_1_1Exponent__vector" kindref="compound">CGAL::Exponent_vector</ref>(0,0),-2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>innermost_coeffs.push_back(std::make_pair(<ref refid="classCGAL_1_1Exponent__vector" kindref="compound">CGAL::Exponent_vector</ref>(3,5),2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>G<sp/>=<sp/></highlight><highlight class="comment">//<sp/>(2*x^3)*y^5<sp/>+<sp/>(-2)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>construct_polynomial(innermost_coeffs.begin(),innermost_coeffs.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>bivariate<sp/>polynomial<sp/>G:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>G<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//construction<sp/>using<sp/>shift<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Shift<sp/><ref refid="group__PkgPolynomialFunctions_1ga19a6f91ab72ba7ad5139f7c7bc759e08" kindref="member">shift</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>x<sp/>=<sp/><ref refid="group__PkgPolynomialFunctions_1ga19a6f91ab72ba7ad5139f7c7bc759e08" kindref="member">shift</ref>(Poly_2(1),1,0);<sp/></highlight><highlight class="comment">//<sp/>&apos;multiply&apos;<sp/>1<sp/>by<sp/>x_0^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>y<sp/>=<sp/><ref refid="group__PkgPolynomialFunctions_1ga19a6f91ab72ba7ad5139f7c7bc759e08" kindref="member">shift</ref>(Poly_2(1),1,1);<sp/></highlight><highlight class="comment">//<sp/>&apos;multiply&apos;<sp/>1<sp/>by<sp/>x_1^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>H<sp/>=<sp/>5<sp/>*<sp/>x<sp/>*<sp/>y<sp/>+<sp/>3<sp/>*<sp/>y<sp/>*<sp/>y;<sp/></highlight><highlight class="comment">//<sp/>=<sp/>3*y^2<sp/>+<sp/>(5*x)*y</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>bivariate<sp/>polynomial<sp/>H:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>H<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1PolynomialCoefficient">
<title>Coefficient Access</title>
<para>In order to obtain a certain coefficient the traits class provides several functors. Note that the functors do not allow a write access to the coefficients. <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1GetCoefficient" kindref="compound">PolynomialTraits_d::GetCoefficient</ref></computeroutput>: a model of this concept provides access to a coefficient in the univariate view, that is, it returns elements of <formula id="150">$ R[x_0,\dots,x_{d-2}]$</formula>. </para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1GetInnermostCoefficient" kindref="compound">PolynomialTraits_d::GetInnermostCoefficient</ref></computeroutput>: a model of this concept provides access to a coefficient in the multivariate view, that is, it returns elements of <formula id="26">$ R$</formula>. </para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1LeadingCoefficient" kindref="compound">PolynomialTraits_d::LeadingCoefficient</ref></computeroutput>: a model of this concept provides access to the leading coefficient in the univariate view. </para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1InnermostLeadingCoefficient" kindref="compound">PolynomialTraits_d::InnermostLeadingCoefficient</ref></computeroutput>: a model of this concept provides access to the leading coefficient in the multivariate view, that is, it returns the (innermost) coefficient of the leading multivariate monomial. See also <computeroutput><ref refid="classPolynomialTraits__d_1_1DegreeVector" kindref="compound">PolynomialTraits_d::DegreeVector</ref></computeroutput>. </para></listitem>
</itemizedlist>
</para><sect2 id="index_1PolynomialExample_1">
<title>Example</title>
<para>The following example illustrates the application of the functors discussed above: <linebreak/>
<bold>File</bold> <ref refid="Polynomial_2coefficient_access_8cpp-example" kindref="compound">Polynomial/coefficient_access.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_traits_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_type_generator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Polynomial_type_generator&lt;int,2&gt;::Type</ref><sp/>Poly_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polynomial__traits__d" kindref="compound">CGAL::Polynomial_traits_d&lt;Poly_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PT_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//construction<sp/>using<sp/>shift<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>x<sp/>=<sp/>PT_2::Shift()(Poly_2(1),1,0);<sp/></highlight><highlight class="comment">//<sp/>=<sp/>x^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>y<sp/>=<sp/>PT_2::Shift()(Poly_2(1),1,1);<sp/></highlight><highlight class="comment">//<sp/>=<sp/>y^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>F<sp/></highlight><highlight class="comment">//<sp/>=<sp/>(11*x^2<sp/>+<sp/>5*x)*y^4<sp/>+<sp/>(7*x^2)*y^3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>=<sp/>11<sp/>*<sp/>CGAL::ipower(y,4)<sp/>*<sp/>CGAL::ipower(x,2)<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>+<sp/>5<sp/>*<sp/>CGAL::ipower(y,4)<sp/><sp/>*<sp/>CGAL::ipower(x,1)<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>+<sp/>7<sp/>*<sp/>CGAL::ipower(y,3)<sp/><sp/>*<sp/>CGAL::ipower(x,2);<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>bivariate<sp/>polynomial<sp/>F:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>F<sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Get_coefficient<sp/><ref refid="group__PkgPolynomialFunctions_1gaefbd9822a52e0a98a0709d9efdae3d42" kindref="member">get_coefficient</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Coefficient<sp/>of<sp/>y^0:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaefbd9822a52e0a98a0709d9efdae3d42" kindref="member">get_coefficient</ref>(F,0)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Coefficient<sp/>of<sp/>y^1:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaefbd9822a52e0a98a0709d9efdae3d42" kindref="member">get_coefficient</ref>(F,1)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Coefficient<sp/>of<sp/>y^2:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaefbd9822a52e0a98a0709d9efdae3d42" kindref="member">get_coefficient</ref>(F,2)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Coefficient<sp/>of<sp/>y^3:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaefbd9822a52e0a98a0709d9efdae3d42" kindref="member">get_coefficient</ref>(F,3)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Coefficient<sp/>of<sp/>y^4:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaefbd9822a52e0a98a0709d9efdae3d42" kindref="member">get_coefficient</ref>(F,4)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Coefficient<sp/>of<sp/>y^5:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaefbd9822a52e0a98a0709d9efdae3d42" kindref="member">get_coefficient</ref>(F,5)<sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Leading_coefficient<sp/>lcoeff;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Leading<sp/>coefficient<sp/>with<sp/>respect<sp/>to<sp/>y:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>lcoeff(F)<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>11*x^2<sp/>+<sp/>5*x</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Get_innermost_coefficient<sp/>get_icoeff;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Innermost<sp/>coefficient<sp/>of<sp/>monomial<sp/>x^1y^4:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>get_icoeff(F,<ref refid="classCGAL_1_1Exponent__vector" kindref="compound">CGAL::Exponent_vector</ref>(1,4))<sp/></highlight><highlight class="comment">//<sp/>=<sp/>5</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Innermost_leading_coefficient<sp/>ilcoeff;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Innermost<sp/>leading<sp/>coefficient<sp/>with<sp/>respect<sp/>to<sp/>y:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>ilcoeff(F)<sp/></highlight><highlight class="comment">//<sp/>=<sp/>11<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1PolynomialDegree">
<title>Degree, Total Degree and Degree Vector</title>
<para>There are three functors in <computeroutput><ref refid="classPolynomialTraits__d" kindref="compound">PolynomialTraits_d</ref></computeroutput> related to the degree of a polynomial. <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1Degree" kindref="compound">PolynomialTraits_d::Degree</ref></computeroutput>: a model of this concept returns the degree of the polynomial in the univariate view. By default this is the degree with respect to the outermost variable, but it is also possible to select another variable. </para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1TotalDegree" kindref="compound">PolynomialTraits_d::TotalDegree</ref></computeroutput>: a model of this concept returns the <emphasis>total degree</emphasis> of a polynomial. The polynomial is considered as a multivariate polynomial. The total degree is the maximum over the sums of the exponents of each multivariate monomial. </para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1DegreeVector" kindref="compound">PolynomialTraits_d::DegreeVector</ref></computeroutput>: a model of this concept returns the exponent vector of the leading monomial, where the monomial order is lexicographic and starts with the outermost variable. See also <computeroutput><ref refid="classPolynomialTraits__d_1_1InnermostLeadingCoefficient" kindref="compound">PolynomialTraits_d::InnermostLeadingCoefficient</ref></computeroutput>. </para></listitem>
</itemizedlist>
</para><sect2 id="index_1PolynomialExample_2">
<title>Example</title>
<para>The following example illustrates the application of the functors discussed above: <linebreak/>
<bold>File</bold> <ref refid="Polynomial_2degree_8cpp-example" kindref="compound">Polynomial/degree.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_traits_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_type_generator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Polynomial_type_generator&lt;int,2&gt;::Type</ref><sp/>Poly_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polynomial__traits__d" kindref="compound">CGAL::Polynomial_traits_d&lt;Poly_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PT_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//construction<sp/>using<sp/>shift<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>x<sp/>=<sp/>PT_2::Shift()(Poly_2(1),1,0);<sp/></highlight><highlight class="comment">//<sp/>x_0^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>y<sp/>=<sp/>PT_2::Shift()(Poly_2(1),1,1);<sp/></highlight><highlight class="comment">//<sp/>x_1^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>F<sp/></highlight><highlight class="comment">//<sp/>=<sp/>(11*x^2<sp/>+<sp/>5*x)*y^4<sp/>+<sp/>(7*x^2)*y^3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>=<sp/>11<sp/>*<sp/>CGAL::ipower(y,4)<sp/>*<sp/>CGAL::ipower(x,2)<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>+<sp/>5<sp/>*<sp/>CGAL::ipower(y,4)<sp/><sp/>*<sp/>CGAL::ipower(x,1)<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>+<sp/>7<sp/>*<sp/>CGAL::ipower(y,3)<sp/><sp/>*<sp/>CGAL::ipower(x,2);<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>bivariate<sp/>polynomial<sp/>F:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>F<sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Degree<sp/><ref refid="group__PkgPolynomialFunctions_1gaa84566608255db58148c67fec626aa1f" kindref="member">degree</ref>;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Total_degree<sp/><ref refid="group__PkgPolynomialFunctions_1ga240791d9e31b77bbd8f4b0cae54520dd" kindref="member">total_degree</ref>;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Degree_vector<sp/><ref refid="group__PkgPolynomialFunctions_1gaf3368de315ff982392d6fe5afdde8830" kindref="member">degree_vector</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>degree<sp/>of<sp/>F<sp/>with<sp/>respect<sp/>to<sp/>y:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaa84566608255db58148c67fec626aa1f" kindref="member">degree</ref>(F)<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>4<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>degree<sp/>of<sp/>F<sp/>with<sp/>respect<sp/>to<sp/>x:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaa84566608255db58148c67fec626aa1f" kindref="member">degree</ref>(F,0)<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>2<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>total<sp/>degree<sp/>of<sp/>F<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1ga240791d9e31b77bbd8f4b0cae54520dd" kindref="member">total_degree</ref>(F)<sp/></highlight><highlight class="comment">//<sp/>=<sp/>6<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>degree<sp/>vector<sp/>of<sp/>F<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaf3368de315ff982392d6fe5afdde8830" kindref="member">degree_vector</ref>(F)</highlight><highlight class="comment">//<sp/>=<sp/>(2,4)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1PolynomialChanging">
<title>Changing the Order of Variables</title>
<para>Given for instance a bivariate polynomial it is conceivable that one wants to interchange the role of <formula id="4">$ x$</formula> and <formula id="155">$ y$</formula>. That is one wants to interpret the <formula id="4">$ x$</formula> as <formula id="155">$ y$</formula> and vice versa. For such a case the polynomial traits provides <computeroutput><ref refid="classPolynomialTraits__d_1_1Swap" kindref="compound">PolynomialTraits_d::Swap</ref></computeroutput>:</para><para>Given a polynomial <formula id="20">$ p$</formula> and to two indices <formula id="15">$ i$</formula> and <formula id="69">$ j$</formula>, the functor returns the polynomial in which <formula id="32">$ x_i$</formula> is substituted by <formula id="70">$ x_j$</formula> and vice versa, that is, the variables swap their positions. The order of the other variables remains untouched.</para><para>Another scenario is, that a particular variable should be moved to another position, for instance, it should become the outermost variable while the relative order of the other variables remains unchanged. For such a case the polynomial traits provides <computeroutput><ref refid="classPolynomialTraits__d_1_1Move" kindref="compound">PolynomialTraits_d::Move</ref></computeroutput>.</para><para>Of course there is also a general method to interchange the order of variables, namely <computeroutput><ref refid="classPolynomialTraits__d_1_1Permute" kindref="compound">PolynomialTraits_d::Permute</ref></computeroutput>.</para><sect2 id="index_1PolynomialExample_3">
<title>Example</title>
<para>The following example illustrates the application of the functors discussed above: <linebreak/>
<bold>File</bold> <ref refid="Polynomial_2swap_move_8cpp-example" kindref="compound">Polynomial/swap_move.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_traits_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_type_generator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Polynomial_type_generator&lt;int,3&gt;::Type</ref><sp/>Poly_3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polynomial__traits__d" kindref="compound">CGAL::Polynomial_traits_d&lt;Poly_3&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PT_3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//construction<sp/>using<sp/>shift<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_3<sp/>x<sp/>=<sp/>PT_3::Shift()(Poly_3(1),1,0);<sp/></highlight><highlight class="comment">//<sp/>x_0^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_3<sp/>y<sp/>=<sp/>PT_3::Shift()(Poly_3(1),1,1);<sp/></highlight><highlight class="comment">//<sp/>x_1^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_3<sp/>z<sp/>=<sp/>PT_3::Shift()(Poly_3(1),1,2);<sp/></highlight><highlight class="comment">//<sp/>x_2^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_3<sp/>F<sp/>=<sp/>x*y*y*z*z*z;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>trivariate<sp/>polynomial<sp/>F:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>F<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_3::Swap<sp/><ref refid="group__PkgPolynomialFunctions_1gaa555a2d0a5bf3730c337f08f07356c07" kindref="member">swap</ref>;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_3::Move<sp/><ref refid="group__PkgPolynomialFunctions_1ga0a646debf9094d532bfaaf024e32ae12" kindref="member">move</ref>;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_3::Permute<sp/><ref refid="group__PkgPolynomialFunctions_1ga2a622bd113102bff26ca196256718346" kindref="member">permute</ref>;<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;x<sp/>and<sp/>z<sp/>swapped:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaa555a2d0a5bf3730c337f08f07356c07" kindref="member">swap</ref>(F,0,2)<sp/></highlight><highlight class="comment">//<sp/>=<sp/>x^3*y^2*z</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;x<sp/>and<sp/>y<sp/>swapped:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaa555a2d0a5bf3730c337f08f07356c07" kindref="member">swap</ref>(F,0,1)<sp/></highlight><highlight class="comment">//<sp/>=<sp/>x^2*y*z^3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;x<sp/>moved<sp/>to<sp/>outermost<sp/>position<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1ga0a646debf9094d532bfaaf024e32ae12" kindref="member">move</ref>(F,0,2)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>x^2*y^3*z</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Same<sp/>as<sp/>swap(swap(F,0,1),1,2)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gaa555a2d0a5bf3730c337f08f07356c07" kindref="member">swap</ref>(<ref refid="group__PkgPolynomialFunctions_1gaa555a2d0a5bf3730c337f08f07356c07" kindref="member">swap</ref>(F,0,1),1,2)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>x^2*y^3*z</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Same<sp/>as<sp/>the<sp/>permutation<sp/>(0,1,2)-&gt;(2,0,1):<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;int&gt;<sp/>perm;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>perm.push_back(2);perm.push_back(0);perm.push_back(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1ga2a622bd113102bff26ca196256718346" kindref="member">permute</ref>(F,perm.begin(),perm.end())</highlight><highlight class="comment">//<sp/>=<sp/>x^2*y^3*z</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1PolynomialGCD">
<title>GCD and More</title>
<para>Since the concept <computeroutput><ref refid="classPolynomialTraits__d" kindref="compound">PolynomialTraits_d</ref></computeroutput> refines the concept <computeroutput><ref refid="classAlgebraicStructureTraits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">AlgebraicStructureTraits</ref></computeroutput> the polynomial traits provides functors for integral division, division with remainder, greatest common divisor, etc. But note that the algebraic structure of a polynomial depends on the algebraic structure of the innermost coefficient, for instance, a gcd is available if and only if the innermost coefficient is a <computeroutput><ref refid="classField" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Field</ref></computeroutput> or a <computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">UniqueFactorizationDomain</ref></computeroutput>. Hence, we can not provide a <formula id="46">$ gcd$</formula> if the innermost coefficient is just an <computeroutput><ref refid="classIntegralDomain" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomain</ref></computeroutput> since it is simply not well definedAn example for such a number type is the template <computeroutput>Sqrt_extension&lt;NT,ROOT&gt;</computeroutput> representing an algebraic extension of degree two. This is just an <computeroutput><ref refid="classIntegralDomain" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomain</ref></computeroutput> if NT is not a <computeroutput><ref refid="classField" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Field</ref></computeroutput>. . However, if we would consider the polynomial over the quotient field of the integral domain the <formula id="46">$ gcd$</formula> would be well defined. The only problem is that the result can not be represented over the ring since it contains denominators. Therefore, the <computeroutput><ref refid="classPolynomialTraits__d" kindref="compound">PolynomialTraits_d</ref></computeroutput> requires functors such as <computeroutput><ref refid="classPolynomialTraits__d_1_1GcdUpToConstantFactor" kindref="compound">PolynomialTraits_d::GcdUpToConstantFactor</ref></computeroutput>. This functor computes the gcd of two polynomials up to a constant factor (utcf). That is, it returns the correct gcd for polynomials over the quotient field, but multiplied by some constant such that the result is representable with coefficients in the ring.</para><para>However, note that these &apos;utcf&apos; functions are usually a bit faster than their strict counterparts. This is due to the fact that the &apos;utcf&apos; functions are allowed to skip the computation of the correct constant factor. Note that in many cases the constant factor is in fact not needed. In particular if the polynomials are supposed to represent some zero set, that is, an algebraic curve or surface.</para><para>The concepts for the related functors are: <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classAlgebraicStructureTraits_1a2e8adafb865d8bb1c2cafb13c8a6ccf3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">AlgebraicStructureTraits::Gcd</ref></computeroutput></para><para><computeroutput><ref refid="classPolynomialTraits__d_1_1GcdUpToConstantFactor" kindref="compound">PolynomialTraits_d::GcdUpToConstantFactor</ref></computeroutput></para><para></para></listitem>
<listitem>
<para><computeroutput>AlgebraicStructureTraits::IntegralDivision</computeroutput></para><para><computeroutput><ref refid="classPolynomialTraits__d_1_1IntegralDivisionUpToConstantFactor" kindref="compound">PolynomialTraits_d::IntegralDivisionUpToConstantFactor</ref></computeroutput></para><para></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1UnivariateContent" kindref="compound">PolynomialTraits_d::UnivariateContent</ref></computeroutput></para><para><computeroutput><ref refid="classPolynomialTraits__d_1_1UnivariateContentUpToConstantFactor" kindref="compound">PolynomialTraits_d::UnivariateContentUpToConstantFactor</ref></computeroutput></para><para></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1SquareFreeFactorize" kindref="compound">PolynomialTraits_d::SquareFreeFactorize</ref></computeroutput></para><para><computeroutput><ref refid="classPolynomialTraits__d_1_1SquareFreeFactorizeUpToConstantFactor" kindref="compound">PolynomialTraits_d::SquareFreeFactorizeUpToConstantFactor</ref></computeroutput> </para></listitem>
</itemizedlist>
</para><para>Another analog functionality is the pseudo division. The related functors replace the usual division with remainder in case the <ref refid="classCGAL_1_1Polynomial" kindref="compound">Polynomial</ref> is not a <computeroutput><ref refid="classEuclideanRing" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">EuclideanRing</ref></computeroutput>.</para><para>The concepts for the related functors are: <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classAlgebraicStructureTraits_1a5126d89547cc79c8d8d315ff93614278" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">AlgebraicStructureTraits::Div_mod</ref></computeroutput></para><para><computeroutput><ref refid="classPolynomialTraits__d_1_1PseudoDivision" kindref="compound">PolynomialTraits_d::PseudoDivision</ref></computeroutput> </para></listitem>
<listitem>
<para><computeroutput><ref refid="classAlgebraicStructureTraits_1ad6ede0c3350eafd2fcc2e42e10fecfdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">AlgebraicStructureTraits::Div</ref></computeroutput></para><para><computeroutput><ref refid="classPolynomialTraits__d_1_1PseudoDivisionQuotient" kindref="compound">PolynomialTraits_d::PseudoDivisionQuotient</ref></computeroutput> </para></listitem>
<listitem>
<para><computeroutput><ref refid="classAlgebraicStructureTraits_1a83c550874e27c05507c89a976bf32cdf" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">AlgebraicStructureTraits::Mod</ref></computeroutput></para><para><computeroutput><ref refid="classPolynomialTraits__d_1_1PseudoDivisionRemainder" kindref="compound">PolynomialTraits_d::PseudoDivisionRemainder</ref></computeroutput> </para></listitem>
</itemizedlist>
</para><sect2 id="index_1PolynomialExample_4">
<title>Example</title>
<para>The following example illustrates the application of some functors discussed above: <linebreak/>
<bold>File</bold> <ref refid="Polynomial_2gcd_up_to_constant_factor_8cpp-example" kindref="compound">Polynomial/gcd_up_to_constant_factor.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_traits_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_type_generator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Polynomial_type_generator&lt;int,1&gt;::Type</ref><sp/>Poly_1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polynomial__traits__d" kindref="compound">CGAL::Polynomial_traits_d&lt;Poly_1&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PT_1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_1::Shift<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PkgPolynomialFunctions_1ga19a6f91ab72ba7ad5139f7c7bc759e08" kindref="member">shift</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_1::Gcd<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PkgAlgebraicFoundations_1gade2b63594fb6827c33c0dcd73b4c7cfe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">gcd</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_1::Gcd_up_to_constant_factor<sp/>gcd_utcf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_1::Multivariate_content<sp/><sp/><sp/><sp/><sp/><sp/>mcontent;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_1::Canonicalize<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PkgPolynomialFunctions_1ga01adc4ff64da4e12534dead6a49e5cc7" kindref="member">canonicalize</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//construction<sp/>using<sp/>shift<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_1<sp/>x<sp/>=<sp/><ref refid="group__PkgPolynomialFunctions_1ga19a6f91ab72ba7ad5139f7c7bc759e08" kindref="member">shift</ref>(Poly_1(1),1,0);<sp/></highlight><highlight class="comment">//<sp/>x^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>common<sp/>factor<sp/>7<sp/>*<sp/>(x^2-2)<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_1<sp/>F<sp/>=<sp/>21*(x-5)*(x*x-2);<sp/></highlight><highlight class="comment">//<sp/>=<sp/>21*x^3<sp/>+<sp/>(-105)*x^2<sp/>+<sp/>(-42)*x<sp/>+<sp/>210</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_1<sp/>G<sp/>=<sp/>14*(x-3)*(x*x-2);<sp/></highlight><highlight class="comment">//<sp/>=<sp/>14*x^3<sp/>+<sp/>(-42)*x^2<sp/>+<sp/>(-28)*x<sp/>+<sp/>84</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>univariate<sp/>polynomial<sp/>F:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>F<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>univariate<sp/>polynomial<sp/>G:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>G<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Common<sp/>multivariate<sp/>content:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1gade2b63594fb6827c33c0dcd73b4c7cfe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::gcd</ref>(mcontent(F),mcontent(G))<sp/></highlight><highlight class="comment">//<sp/>=<sp/>7<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>gcd<sp/>of<sp/>F<sp/>and<sp/>G:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1gade2b63594fb6827c33c0dcd73b4c7cfe" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">gcd</ref>(F,G)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>7*x^2<sp/>+<sp/>(-14)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>gcd<sp/>up<sp/>to<sp/>constant<sp/>factor<sp/>of<sp/>F<sp/>and<sp/>G:<sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>gcd_utcf(F,G)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>x^2<sp/>+<sp/>(-2)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Same<sp/>as<sp/>canonicalized<sp/>gcd<sp/>of<sp/>F<sp/>and<sp/>G:<sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1ga01adc4ff64da4e12534dead6a49e5cc7" kindref="member">canonicalize</ref>(gcd_utcf(F,G))<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>x^2<sp/>+<sp/>(-2)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1PolynomialEvaluation">
<title>Evaluation and Substitution</title>
<para>Of course, it should also be possible to evaluate a polynomial or substitute its variables. We also require a special functor to determine whether a polynomial is zero at a given point. In case the inner most coefficient is <computeroutput><ref refid="classRealEmbeddable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">RealEmbeddable</ref></computeroutput> the traits also must provide a function to compute the sign at a given point.</para><para>The concepts for the related functors are: <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1Substitute" kindref="compound">PolynomialTraits_d::Substitute</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1Evaluate" kindref="compound">PolynomialTraits_d::Evaluate</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1IsZeroAt" kindref="compound">PolynomialTraits_d::IsZeroAt</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1SignAt" kindref="compound">PolynomialTraits_d::SignAt</ref></computeroutput> </para></listitem>
</itemizedlist>
</para><para>The traits is also required to provide variants of these functors that interpret the polynomial as a homogeneous polynomial by adding a virtual homogeneous variable such that each term has the same degree, namely the degree of the polynomial. Of course there is a difference between the univariate and multivariate view. For instance the polynomial <formula id="176">\[ 5x^3 + 7x - 3 \]</formula> has degree 3, hence it is interpreted as the homogeneous polynomial <formula id="177">\[ 5x^3 + 7xw^2 -3w^3 \]</formula> by adding the homogeneous variable <formula id="178">$ w$</formula>. In case of the multivariate view each term is filled up by the homogeneous variable such that the degree of each term is equal to the total degree of the polynomial. Note that these functors may significantly improve efficiency. For instance, it is possible to determine the sign of a polynomial over integer coefficients at a rational point without changing the coefficient domain of the polynomial. For more details have a look at the following concepts: <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1SubstituteHomogeneous" kindref="compound">PolynomialTraits_d::SubstituteHomogeneous</ref></computeroutput> </para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1EvaluateHomogeneous" kindref="compound">PolynomialTraits_d::EvaluateHomogeneous</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1IsZeroAtHomogeneous" kindref="compound">PolynomialTraits_d::IsZeroAtHomogeneous</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1SignAtHomogeneous" kindref="compound">PolynomialTraits_d::SignAtHomogeneous</ref></computeroutput> </para></listitem>
</itemizedlist>
</para><para>Note that substitute allows the substitution of the variables by any type that is <computeroutput><ref refid="classExplicitInteroperable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">ExplicitInteroperable</ref></computeroutput> with the innermost coefficient type. This is a very powerful tool since it allows the substitution of the variables by polynomials. However, for some standard manipulations such as translation or scaling we require special functors since they are expected to be faster than their equivalent implementation using substitution:</para><para><itemizedlist>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1Shift" kindref="compound">PolynomialTraits_d::Shift</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1Negate" kindref="compound">PolynomialTraits_d::Negate</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1Invert" kindref="compound">PolynomialTraits_d::Invert</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1Translate" kindref="compound">PolynomialTraits_d::Translate</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1TranslateHomogeneous" kindref="compound">PolynomialTraits_d::TranslateHomogeneous</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1Scale" kindref="compound">PolynomialTraits_d::Scale</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1ScaleHomogeneous" kindref="compound">PolynomialTraits_d::ScaleHomogeneous</ref></computeroutput> </para></listitem>
</itemizedlist>
</para><sect2 id="index_1PolynomialExample_5">
<title>Example</title>
<para>The following example illustrates the application of some functors discussed above: <linebreak/>
<bold>File</bold> <ref refid="Polynomial_2substitute_8cpp-example" kindref="compound">Polynomial/substitute.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_traits_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_type_generator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Polynomial_type_generator&lt;int,2&gt;::Type</ref><sp/>Poly_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polynomial__traits__d" kindref="compound">CGAL::Polynomial_traits_d&lt;Poly_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PT_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//construction<sp/>using<sp/>shift<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>x<sp/>=<sp/>PT_2::Shift()(Poly_2(1),1,0);<sp/></highlight><highlight class="comment">//<sp/>x^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>y<sp/>=<sp/>PT_2::Shift()(Poly_2(1),1,1);<sp/></highlight><highlight class="comment">//<sp/>y^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_2<sp/>F<sp/>=<sp/>2*x*y<sp/>+<sp/>3*CGAL::ipower(y,3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>bivariate<sp/>polynomial<sp/>F:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>F<sp/></highlight><highlight class="comment">//<sp/>=<sp/>3*y^3<sp/>+<sp/>(2*x)*y</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Evaluate<sp/><ref refid="group__PkgPolynomialFunctions_1gafa3f901a791e00db48197828c4ccae78" kindref="member">evaluate</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Evaluate_homogeneous<sp/>hevaluate;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Evaluation<sp/>considers<sp/>a<sp/>polynomials<sp/>as<sp/>univariate:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;F(5):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gafa3f901a791e00db48197828c4ccae78" kindref="member">evaluate</ref>(F,5)<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>10*x<sp/>+<sp/>375</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Evaluate_homogeneous<sp/>considers<sp/>F<sp/>as<sp/>a<sp/>homogeneous<sp/>polynomial<sp/>in<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>outermost<sp/>variable<sp/>only,<sp/>that<sp/>is,<sp/>F<sp/>is<sp/>interpreted<sp/>as<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>F(u,v)<sp/>=<sp/>2*x*u*v^2<sp/>+<sp/>3<sp/>*<sp/>u^3<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;F(5,7):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>hevaluate(F,5,7)<sp/></highlight><highlight class="comment">//<sp/>=<sp/>490*x<sp/>+<sp/>375</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Substitute<sp/><ref refid="group__PkgPolynomialFunctions_1gab56d5f9b520a1a95aeb7823335088653" kindref="member">substitute</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_2::Substitute_homogeneous<sp/>hsubstitute;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Substitute<sp/>considers<sp/>a<sp/>polynomials<sp/>as<sp/>multivariate,<sp/>that<sp/>is,<sp/>the<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>new<sp/>values<sp/>for<sp/>the<sp/>variables<sp/>are<sp/>given<sp/>by<sp/>an<sp/>iterator<sp/>range</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>the<sp/>value<sp/>type<sp/>only<sp/>has<sp/>to<sp/>be<sp/>interoperable<sp/>with<sp/>the<sp/>innermost<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>coefficient</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Poly_2&gt;<sp/>replacements;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>replacements.push_back(x-1);<sp/></highlight><highlight class="comment">//<sp/>replace<sp/>x<sp/>by<sp/>x-1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>replacements.push_back(y);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>replace<sp/>y<sp/>by<sp/>y,<sp/>i.e.,<sp/>do<sp/>nothing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>bivariate<sp/>polynomial<sp/>F:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>F<sp/></highlight><highlight class="comment">//<sp/>=<sp/>3*y^3<sp/>+<sp/>(2*x)*y</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;F(x-1,y):<sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>=<sp/>3*y^3<sp/>+<sp/>(2*x<sp/>+<sp/>(-2))*y</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gab56d5f9b520a1a95aeb7823335088653" kindref="member">substitute</ref>(F,replacements.begin(),replacements.end())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Substitute_homogeneous<sp/>considers<sp/>F<sp/>as<sp/>a<sp/>homogeneous<sp/>polynomial<sp/>in<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>all<sp/>variable,<sp/>that<sp/>is,<sp/>F<sp/>is<sp/>interpreted<sp/>as<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>F(x,y,w)<sp/>=<sp/>2*x*y*w<sp/>+<sp/>3<sp/>*<sp/>y^3<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>replacements.push_back(y);<sp/><sp/></highlight><highlight class="comment">//<sp/>replace<sp/>z<sp/>by<sp/>y<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;F(x-1,y,y):<sp/>&quot;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>=<sp/>3*y^3<sp/>+<sp/>(2*x<sp/>+<sp/>(-2))*y^2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>hsubstitute(F,replacements.begin(),replacements.end())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1PolynomialResultants">
<title>Resultants, Subresultants and Sturm-Habicht Sequences</title>
<para>The <computeroutput><ref refid="classPolynomialTraits__d" kindref="compound">PolynomialTraits_d</ref></computeroutput> concept also provides more sophisticated functors for computations with polynomials - computing the resultant of two polynomials, their polynomial subresultant sequence, with or without cofactors, and their principal subresultant coefficients. <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1Resultant" kindref="compound">PolynomialTraits_d::Resultant</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1PolynomialSubresultants" kindref="compound">PolynomialTraits_d::PolynomialSubresultants</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1PolynomialSubresultantsWithCofactors" kindref="compound">PolynomialTraits_d::PolynomialSubresultantsWithCofactors</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1PrincipalSubresultants" kindref="compound">PolynomialTraits_d::PrincipalSubresultants</ref></computeroutput> </para></listitem>
</itemizedlist>
Moreover, functors to compute the Sturm-Habicht sequence, with or without cofactors, and for the principal Sturm-Habicht coefficients exist. <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1SturmHabichtSequence" kindref="compound">PolynomialTraits_d::SturmHabichtSequence</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1SturmHabichtSequenceWithCofactors" kindref="compound">PolynomialTraits_d::SturmHabichtSequenceWithCofactors</ref></computeroutput></para></listitem>
<listitem>
<para><computeroutput><ref refid="classPolynomialTraits__d_1_1PrincipalSturmHabichtSequence" kindref="compound">PolynomialTraits_d::PrincipalSturmHabichtSequence</ref></computeroutput> </para></listitem>
</itemizedlist>
For a formal definition of all used terms, we refer to the corresponding reference pages.</para><para>The principal Sturm-Habicht sequence allows to count the number of real roots of a polynomial using the function <itemizedlist>
<listitem>
<para><ref refid="group__PkgPolynomialFunctions_1ga0148f1612807b08b433f96c3ce07f2be" kindref="member">number_of_real_roots()</ref>. </para></listitem>
</itemizedlist>
As input, this function requires an iterator range that represents the principal Sturm-Habicht coefficients. This might look complicated at a first sight, as one has to store the principal Sturm-Habicht sequence temporarily. However, we remark an important property of the (principal) Sturm-Habicht sequence. Having a polynomial <formula id="179">$ f_t(x)$</formula> that depends on a parameter <formula id="180">$ t$</formula>, and its (principal) Sturm-Habicht coefficients <formula id="181">$ \mathrm{stha}_0(f_t),\ldots,\mathrm{stha}_n(f_t)$</formula>, evaluating <formula id="182">$ \mathrm{stha}_0(f_t)$</formula> for <formula id="183">$ t=t_0$</formula> yields a valid (principal) Sturm-Habicht sequence for <formula id="184">$ f_{t_0}$</formula>. The same holds for (principal) subresultants. Thus, it is enough in such situations to compute the sequence once for the parameter <formula id="180">$ t$</formula>, and call <computeroutput><ref refid="group__PkgPolynomialFunctions_1ga0148f1612807b08b433f96c3ce07f2be" kindref="member">number_of_real_roots()</ref></computeroutput> for each specialized parameter value.</para><para>We finally remark that computing subresultants and Sturm-Habicht sequences introduces an enormous coefficient blow-up. An application of the functors therefore does not make sense for built-in integers except for toy examples. To avoid overflows, one should use arbitrary size integer types in real applications.</para><sect2 id="index_1PolynomialExample_6">
<title>Example</title>
<para>The following example illustrates how two compute resultants of two polynomials, and how to count the number of distinct real roots of a polynomial using its principal Sturm-Habicht coefficients.</para><para><linebreak/>
<bold>File</bold> <ref refid="Polynomial_2subresultants_8cpp-example" kindref="compound">Polynomial/subresultants.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_traits_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polynomial_type_generator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_integer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(std::cout);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_integer<sp/>Int;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Polynomial_type_generator&lt;Int,1&gt;::Type</ref><sp/>Poly_1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polynomial__traits__d" kindref="compound">CGAL::Polynomial_traits_d&lt;Poly_1&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PT_1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//construction<sp/>using<sp/>shift<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_1<sp/>x<sp/>=<sp/>PT_1::Shift()(Poly_1(1),1);<sp/></highlight><highlight class="comment">//<sp/>x^1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_1<sp/>F<sp/></highlight><highlight class="comment">//<sp/>=<sp/>(x+1)^2*(x-1)*(2x-1)=2x^4+x^3-3x^2-x+1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>=<sp/><sp/><sp/>2<sp/>*<sp/>CGAL::ipower(x,4)<sp/>+<sp/>1<sp/>*<sp/>CGAL::ipower(x,3)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>3<sp/>*<sp/>CGAL::ipower(x,2)<sp/>-<sp/>1<sp/>*<sp/>CGAL::ipower(x,1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>1<sp/>*<sp/>CGAL::ipower(x,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;F=&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>F<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Poly_1<sp/>G<sp/></highlight><highlight class="comment">//<sp/>=<sp/>(x+1)*(x+3)=x^2+4*x+3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>=<sp/><sp/><sp/>1<sp/>*<sp/>CGAL::ipower(x,2)<sp/>+<sp/>4<sp/>*<sp/>CGAL::ipower(x,1)<sp/>+<sp/>3<sp/>*<sp/>CGAL::ipower(x,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;G=&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>G<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Resultant<sp/>computation:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_1::Resultant<sp/><ref refid="group__PkgPolynomialFunctions_1gae9a956401279deeecd1caededf9a3f2c" kindref="member">resultant</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>resultant<sp/>of<sp/>F<sp/>and<sp/>G<sp/>is:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgPolynomialFunctions_1gae9a956401279deeecd1caededf9a3f2c" kindref="member">resultant</ref>(F,G)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>It<sp/>is<sp/>zero,<sp/>because<sp/>F<sp/>and<sp/>G<sp/>have<sp/>a<sp/>common<sp/>factor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Real<sp/>root<sp/>counting:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PT_1::Principal_sturm_habicht_sequence<sp/>stha;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Int&gt;<sp/>psc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>stha(F,std::back_inserter(psc));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>roots<sp/>=<sp/><ref refid="group__PkgPolynomialFunctions_1ga0148f1612807b08b433f96c3ce07f2be" kindref="member">CGAL::number_of_real_roots</ref>(psc.begin(),psc.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>number<sp/>of<sp/>real<sp/>roots<sp/>of<sp/>F<sp/>is:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>roots<sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight><highlight class="comment">//<sp/>3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>roots<sp/>=<sp/><sp/><ref refid="group__PkgPolynomialFunctions_1ga0148f1612807b08b433f96c3ce07f2be" kindref="member">CGAL::number_of_real_roots</ref>(G);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>number<sp/>of<sp/>real<sp/>roots<sp/>of<sp/>G<sp/>is:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>roots<sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight><highlight class="comment">//<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1PolynomialDesign">
<title>Design and Implementation History</title>
<para>This package is the result of the integration process of the NumeriX library of Exacus <ref refid="citelist_1CITEREF_beh-eeeafcs-05" kindref="member">[1]</ref> into CGAL.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Polynomial" kindref="compound">Polynomial</ref>&lt;Coeff&gt;</computeroutput> had been started by Michael Seel within <ref refid="namespaceCGAL" kindref="compound">CGAL</ref> as part of the Nef_2 package. As part of the Exacus project it got significantly improved by Arno Eigenwillig and Michael Hemmer.</para><para>However, due to the recursive definition the class was rather restricted to the univariate view. Moreover, it is clear that depending on the context other classes that are symmetric in all variables or dedicated for sparse polynomials may be more efficient. As a consequence this package introduced the <computeroutput><ref refid="classCGAL_1_1Polynomial__traits__d" kindref="compound">Polynomial_traits_d</ref>&lt;<ref refid="classPolynomial__d" kindref="compound">Polynomial_d</ref>&gt;</computeroutput> giving also the symmetric view on polynomials and the opportunity to introduce and use other classes representing polynomials within CGAL. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
