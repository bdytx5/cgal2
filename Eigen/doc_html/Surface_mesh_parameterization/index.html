<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Surface_mesh_parameterization/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Planar Parameterization of Triangulated Surface Meshes: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Planar Parameterization of Triangulated Surface Meshes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Planar_Parameterization_of_Triangulated_Surface_Meshes"></a> <a class="anchor" id="chapsurface_mesh_parameterization"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Laurent Saboret, Pierre Alliez, Bruno Lévy, Andreas Fabri, and Mael Rouxel-Labbé</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The API and structure of this package have greatly changed with CGAL 4.11. Users who wish to use the former API must use a version prior to 4.11. Section <a class="el" href="index.html#Surface_mesh_parameterizationBasics">Basics</a> gives a gentle introduction to the new, much simpler, API.</dd></dl>
<h1><a class="anchor" id="Surface_mesh_parameterizationIntroduction"></a>
Introduction</h1>
<p>Parameterizing a surface amounts to finding a one-to-one mapping from a suitable domain to the surface. A good mapping is the one which minimizes either angle distortions (conformal parameterization) or area distortions (equiareal parameterization) in some sense. In this package, we focus on parameterizing triangulated surfaces which are homeomorphic to a disk or a sphere, and on piecewise linear mappings onto a planar domain.</p>
<p>Although the main motivation behind the first parameterization methods was the application to texture mapping, it is now frequently used for mapping more sophisticated modulation signals (such as normal, transparency, reflection or light modulation maps), fitting scattered data, re-parameterizing spline surfaces, repairing CAD models, approximating surfaces and remeshing.</p>
<p>This <span style="font-variant: small-caps;">CGAL</span> package implements surface parameterization methods, such as As Rigid As Possible Parameterization, Tutte Barycentric Mapping, Discrete Authalic Parameterization, Discrete Conformal Maps, Least Squares Conformal Maps, Floater Mean Value Coordinates, or Orbifold Tutte Embeddings. These methods mainly distinguish by the distortion they minimize (angles vs. areas), by the constrained border onto the planar domain (convex polygon vs. free border) and by the bijectivity guarantees of the mapping.</p>
<p>The package proposes an interface for any model of the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceGraph.html">FaceGraph</a></code>, such as the classes <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Seam__mesh.html">Seam_mesh</a></code>, or the mesh classes of <a href="https://www.openmesh.org">OpenMesh</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Seam__mesh.html">Seam_mesh</a></code> can be used to virtually cut a mesh, allowing to transform an input mesh in subdomain(s) that fit the disk-or-sphere topology requirement.</dd></dl>
<p>Since parameterizing meshes requires an efficient representation of sparse matrices and efficient iterative or direct linear solvers, we provide a unified interface to linear solvers as described in Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSolverSummary">CGAL and Solvers</a>.</p>
<p>Note that linear solvers commonly use double precision floating point numbers. Therefore, this package is intended to be used with a <span style="font-variant: small-caps;">CGAL</span> Cartesian kernel with doubles.</p>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfigintroduction"></a></p><div class="image">
<img src="introduction.jpg" alt="introduction.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigintroduction">Figure 66.1</a> Texture mapping via Least Squares Conformal Maps parameterization. Top: original mesh and texture. Bottom: parameterized mesh (left: parameter space, right: textured mesh).  </div>  <br />

<h1><a class="anchor" id="Surface_mesh_parameterizationBasics"></a>
Basics</h1>
<h2><a class="anchor" id="Surface_mesh_parameterizationDefaultSurface"></a>
Default Surface Parameterization</h2>
<p>From the user point of view, the simplest entry point to this package is the following function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TriangleMesh, <span class="keyword">typename</span> VertexUVMap&gt;</div><div class="line"><a class="code" href="group__PkgSurfaceParameterizationEnums.html#gaee614329039ca5fdba0e1059cd7d3e94">Error_code</a> <a class="code" href="group__PkgSurfaceParameterizationMainFunction.html#gad05bcd0979ce93d681d4f27a9ccd820b">parameterize</a>(TriangleMesh &amp; mesh,</div><div class="line">                        boost::graph_traits&lt;TriangleMesh&gt;::halfedge_descriptor bhd,</div><div class="line">                        VertexUVMap uvm);</div></div><!-- fragment --><p>The function <code><a class="el" href="group__PkgSurfaceParameterizationMainFunction.html#gad05bcd0979ce93d681d4f27a9ccd820b" title="Compute a one-to-one mapping from a 3D triangle surface mesh to a simple 2D domain. ">parameterize()</a></code> applies a default surface parameterization method, namely Floater Mean Value Coordinates <a class="el" href="citelist.html#CITEREF_cgal:f-mvc-03">[4]</a> (see Section <a class="el" href="index.html#Surface_mesh_parameterizationFloaterMean">Floater Mean Value Coordinates</a>), to the connected component of the mesh of type <code>TriangleMesh</code> with the border given by the halfedge <code>bhd</code>. This border is parameterized with an arc-length circular border parameterization. The sparse linear solver of the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/installation.html#thirdpartyEigen">Eigen</a> library is used.</p>
<p>The mesh of type <code>TriangleMesh</code> must be a model of the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceGraph.html">FaceGraph</a></code> and must additionally be triangulated, 2-manifold, oriented, and homeomorphic to a disc (possibly with holes). The last requirement is not hard and we will later show how to parameterize a mesh that is not a topological disk (Section <a class="el" href="index.html#secCuttingaMesh">Cutting a Mesh</a>). The result is stored in a property map (whose type is here VertexUVMap) for the mesh vertices. See also Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgProperty_mapSummary">CGAL and Boost Property Maps</a>.</p>
<h2><a class="anchor" id="Surface_mesh_parameterizationDefaultExample"></a>
Default Parameterization Example</h2>
<p>In the following example, we apply the default parameterization (Floater Mean Value Coordinates) to a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> mesh. We store the UV-coordinates as a vertex property using the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> built-in property mechanism.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_parameterization_2simple_parameterization_8cpp-example.html">Surface_mesh_parameterization/simple_parameterization.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/IO/File_off.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/parameterize.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/measure.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>          <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                         Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                         Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a>     SurfaceMesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;SurfaceMesh&gt;::vertex_descriptor     vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;SurfaceMesh&gt;::halfedge_descriptor   halfedge_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;SurfaceMesh&gt;::face_descriptor       face_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SMP = <a class="code" href="namespaceCGAL_1_1Surface__mesh__parameterization.html">CGAL::Surface_mesh_parameterization</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1) ? argv[1] : <span class="stringliteral">"data/nefertiti.off"</span>);</div><div class="line">  <span class="keywordflow">if</span>(!in) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Problem loading the input data"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  SurfaceMesh sm;</div><div class="line">  in &gt;&gt; sm;</div><div class="line"></div><div class="line">  <span class="comment">// a halfedge on the border</span></div><div class="line">  halfedge_descriptor bhd = CGAL::Polygon_mesh_processing::longest_border(sm).first;</div><div class="line"></div><div class="line">  <span class="comment">// The UV property map that holds the parameterized values</span></div><div class="line">  <span class="keyword">typedef</span> SurfaceMesh::Property_map&lt;vertex_descriptor, Point_2&gt;  UV_pmap;</div><div class="line">  UV_pmap uv_map = sm.add_property_map&lt;vertex_descriptor, Point_2&gt;(<span class="stringliteral">"h:uv"</span>).first;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgSurfaceParameterizationMainFunction.html#gad05bcd0979ce93d681d4f27a9ccd820b">SMP::parameterize</a>(sm, bhd, uv_map);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">"result.off"</span>);</div><div class="line">  SMP::IO::output_uvmap_to_off(sm, bhd, uv_map, out);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>Figure <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigsimple">Figure 66.2</a> illustrates the input and output of this program.</p>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfigsimple"></a></p><center> <div class="image">
<img src="nefertiti.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigsimple">Figure 66.2</a> Input (left), parameter space (middle), and textured mesh (right) corresponding to the example <a class="el" href="Surface_mesh_parameterization_2simple_parameterization_8cpp-example.html">simple_parameterization.cpp</a>.  </div>  <br />

<h2><a class="anchor" id="Surface_mesh_parameterizationEnhancedparameterize"></a>
Choosing a Parameterization Algorithm</h2>
<p>This package provides a second <code><a class="el" href="group__PkgSurfaceParameterizationMainFunction.html#gad05bcd0979ce93d681d4f27a9ccd820b" title="Compute a one-to-one mapping from a 3D triangle surface mesh to a simple 2D domain. ">parameterize()</a></code> entry point where the user can specify a parameterization method:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TriangleMesh, <span class="keyword">typename</span> Parameterizer_3, <span class="keyword">typename</span> VertexUVMap&gt;</div><div class="line"><a class="code" href="group__PkgSurfaceParameterizationEnums.html#gaee614329039ca5fdba0e1059cd7d3e94">Error_code</a> <a class="code" href="group__PkgSurfaceParameterizationMainFunction.html#gad05bcd0979ce93d681d4f27a9ccd820b">parameterize</a>(TriangleMesh&amp; mesh,</div><div class="line">                        <a class="code" href="classParameterizer__3.html">Parameterizer_3</a> parameterizer,</div><div class="line">                        boost::graph_traits&lt;TriangleMesh&gt;::halfedge_descriptor bhd,</div><div class="line">                        VertexUVMap uvm);</div></div><!-- fragment --><p>It computes a one-to-one mapping from a 3D triangle surface mesh to a simple 2D domain. The mapping is piecewise linear on the triangle mesh. The result is a pair (u,v) of parameter coordinates for each vertex of the input mesh. A one-to-one mapping may be guaranteed or not, depending on the choice of the <a class="el" href="classParameterizer__3.html" title="Parameterizer_3 is a concept of parameterization object for a given type of mesh, TriangleMesh...">Parameterizer_3</a> algorithm.</p>
<p>In the following example, we use the Discrete Authalic parameterizer with a circular border parameterization. We use a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> for the mesh and store the UV-coordinates as a vertex property using the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> built-in property mechanism.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_parameterization_2discrete_authalic_8cpp-example.html">Surface_mesh_parameterization/discrete_authalic.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/IO/File_off.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/Circular_border_parameterizer_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/Discrete_authalic_parameterizer_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/Error_code.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/parameterize.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/measure.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>       <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                      Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                      Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a>  SurfaceMesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;SurfaceMesh&gt;::halfedge_descriptor  halfedge_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;SurfaceMesh&gt;::vertex_descriptor    vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;SurfaceMesh&gt;::face_descriptor      face_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SMP = <a class="code" href="namespaceCGAL_1_1Surface__mesh__parameterization.html">CGAL::Surface_mesh_parameterization</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1) ? argv[1] : <span class="stringliteral">"data/three_peaks.off"</span>);</div><div class="line">  <span class="keywordflow">if</span>(!in) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Problem loading the input data"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  SurfaceMesh sm;</div><div class="line">  in &gt;&gt; sm;</div><div class="line"></div><div class="line">  <span class="comment">// A halfedge on the border</span></div><div class="line">  halfedge_descriptor bhd = CGAL::Polygon_mesh_processing::longest_border(sm).first;</div><div class="line"></div><div class="line">  <span class="comment">// The 2D points of the uv parametrisation will be written into this map</span></div><div class="line">  <span class="keyword">typedef</span> SurfaceMesh::Property_map&lt;vertex_descriptor, Point_2&gt;  UV_pmap;</div><div class="line">  UV_pmap uv_map = sm.add_property_map&lt;vertex_descriptor, Point_2&gt;(<span class="stringliteral">"v:uv"</span>).first;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> SMP::Circular_border_arc_length_parameterizer_3&lt;SurfaceMesh&gt;  Border_parameterizer;</div><div class="line">  <span class="keyword">typedef</span> SMP::Discrete_authalic_parameterizer_3&lt;SurfaceMesh, Border_parameterizer&gt; Parameterizer;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgSurfaceParameterizationEnums.html#gaee614329039ca5fdba0e1059cd7d3e94">SMP::Error_code</a> err = <a class="code" href="group__PkgSurfaceParameterizationMainFunction.html#gad05bcd0979ce93d681d4f27a9ccd820b">SMP::parameterize</a>(sm, Parameterizer(), bhd, uv_map);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(err != <a class="code" href="group__PkgSurfaceParameterizationEnums.html#ggaee614329039ca5fdba0e1059cd7d3e94a79a3df3fec6f1020a94571c1ea277557">SMP::OK</a>) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: "</span> &lt;&lt; <a class="code" href="group__PkgSurfaceParameterizationEnums.html#ga37b53162f5cb508857672cd249d16399">SMP::get_error_message</a>(err) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">"result.off"</span>);</div><div class="line">  SMP::IO::output_uvmap_to_off(sm, bhd, uv_map, out);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>Other parameterization methods can easily be swapped in by simply replacing the lines</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/Circular_border_parameterizer_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/Discrete_authalic_parameterizer_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> SMP::Circular_border_arc_length_parameterizer_3&lt;SurfaceMesh&gt;  Border_parameterizer;</div><div class="line"><span class="keyword">typedef</span> SMP::Discrete_authalic_parameterizer_3&lt;SurfaceMesh, Border_parameterizer&gt; Parameterizer;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div></div><!-- fragment --><p>with other <em>compatible</em> border and domain parameterizers, e.g.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/Square_border_parameterizer_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/Barycentric_mapping_parameterizer_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> SMP::Square_border_uniform_parameterizer_3&lt;SurfaceMesh&gt; Border_parameterizer;</div><div class="line"><span class="keyword">typedef</span> SMP::Barycentric_mapping_parameterizer_3&lt;SurfaceMesh, Border_parameterizer&gt; Parameterizer;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div></div><!-- fragment --><p>Which border and which domain parameterizers can be combined is explained in the next section.</p>
<h1><a class="anchor" id="secSurfaceParameterizationMethods"></a>
Surface Parameterization Methods</h1>
<p>This <span style="font-variant: small-caps;">CGAL</span> package implements surface parameterization methods, such as As Rigid as Possible, Tutte Barycentric, Discrete Authalic Parameterization, Discrete Conformal Map, Least Squares Conformal Maps, Floater Mean Value Coordinates, or Orbifold Tutte Embeddings. These methods are provided as models of the <code><a class="el" href="classParameterizer__3.html" title="Parameterizer_3 is a concept of parameterization object for a given type of mesh, TriangleMesh...">Parameterizer_3</a></code> concept.</p>
<p>The different parameterization methods can be classified into three categories depending on the type of border parameterization that is required: fixed border, free border, and borderless.</p>
<p>Illustrations of the different methods are obtained with the same input model, the <em>hand</em> model, shown in Figure <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigbase">Figure 66.3</a>. The hand is a topological sphere, and a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Seam__mesh.html">Seam_mesh</a></code> is used to cut it into a topological disk. In Figure <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigbase">Figure 66.3</a>, the seam is traced in red and the four cones used for Orbifold Tutte Parameterization (Section <a class="el" href="index.html#Surface_mesh_parameterizationOrbi">Orbifold Tutte Embeddings</a>) are marked with green dots.</p>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfigbase"></a></p><center> <div class="image">
<img src="hand_base.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigbase">Figure 66.3</a> The base mesh used in the illustrations of the different methods throughout this Section. The seam is traced in red. Vertices marked with green dots are cones.  </div>  <br />

<h2><a class="anchor" id="Surface_mesh_parameterizationFixedBorder"></a>
Fixed Border Surface Parameterizations</h2>
<p>Fixed border surface parameterizations are characterized by having a constrained border in parameter space: two (u,v) coordinates for each vertex along the border. Different choices exist for such border parameterization methods, described in Section <a class="el" href="index.html#secBorderParameterizationsforFixedMethods">Border Parameterizations for Fixed Methods</a>.</p>
<h3><a class="anchor" id="Surface_mesh_parameterizationTutteBarycentric"></a>
Tutte Barycentric Mapping</h3>
<p><code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1Barycentric__mapping__parameterizer__3.html" title="The class Barycentric_mapping_parameterizer_3 implements Tutte Barycentric Mapping algorithm...">Surface_mesh_parameterization::Barycentric_mapping_parameterizer_3</a>&lt;TriangleMesh, BorderParameterizer, SolverTraits&gt;</code></p>
<p>The Barycentric Mapping parameterization method has been introduced by Tutte <a class="el" href="citelist.html#CITEREF_t-hdg-63">[10]</a>. In parameter space, each vertex is placed at the barycenter of its neighbors to achieve the so-called convex combination condition. This algorithm amounts to solve one sparse linear system for each set of parameter coordinates, with a #vertices x #vertices sparse and symmetric positive definite matrix (if the border vertices are eliminated from the linear system). A coefficient \( (i, j)\) of the matrix is set to 1 for an edge linking the vertex \( v_i\) to the vertex \( v_j\), to minus the degree of the vertex \( v_i\) for a diagonal element, and to 0 for any other matrix entry. Although a bijective mapping is guaranteed when the border is convex, this method does not minimize either angle nor area distortion.</p>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfiguniform"></a></p><center> <div class="image">
<img src="uniform_new.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfiguniform">Figure 66.4</a> Tutte Barycentric mapping parameterization (the blue line depicts the cut graph). Rightmost: parameter space.  </div>  <br />

<h3><a class="anchor" id="Surface_mesh_parameterizationDiscreteAuthalic"></a>
Discrete Authalic Parameterization</h3>
<p><code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1Discrete__authalic__parameterizer__3.html" title="The class Discrete_authalic_parameterizer_3 implements the Discrete Authalic Parameterization algorit...">Surface_mesh_parameterization::Discrete_authalic_parameterizer_3</a>&lt;TriangleMesh, BorderParameterizer, SolverTraits&gt;</code></p>
<p>The Discrete Authalic parameterization method has been introduced by Desbrun et al. <a class="el" href="citelist.html#CITEREF_cgal:dma-ipsm-02">[2]</a>. It corresponds to a weak formulation of an area-preserving method, and in essence locally minimizes the area distortion. A one-to-one mapping is guaranteed only if the convex combination condition is fulfilled and the border is convex. This method solves two #vertices x #vertices sparse linear systems. The matrix (the same for both systems) is asymmetric.</p>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfigauthalic"></a></p><center> <div class="image">
<img src="authalic_new.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigauthalic">Figure 66.5</a> Discrete Authalic Parameterization (the blue line depicts the cut graph). Rightmost: parameter space.  </div>  <br />

<h3><a class="anchor" id="Surface_mesh_parameterizationDiscreteConformal"></a>
Discrete Conformal Map</h3>
<p><code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1Discrete__conformal__map__parameterizer__3.html" title="The class Discrete_conformal_map_parameterizer_3 implements the Discrete Conformal Map (DCM) paramete...">Surface_mesh_parameterization::Discrete_conformal_map_parameterizer_3</a>&lt;TriangleMesh, BorderParameterizer, SolverTraits&gt;</code></p>
<p>Discrete Conformal Map parameterization has been introduced to the graphics community by Eck et al. <a class="el" href="citelist.html#CITEREF_cgal:eddhls-maam-95">[3]</a>. It attempts to lower angle deformation by minimizing a discrete version of the Dirichlet energy as derived by Pinkall and Polthier <a class="el" href="citelist.html#CITEREF_cgal:pp-cdmsc-93">[9]</a>. A one-to-one mapping is guaranteed only when the two following conditions are fulfilled: the barycentric mapping condition (each vertex in parameter space is a convex combination of its neighboring vertices), and the border is convex. This method solves two #vertices x #vertices sparse linear systems. The matrix (the same for both systems) is sparse and symmetric positive definite (if the border vertices are eliminated from the linear system and if the mesh contains no hole), and thus can be efficiently solved using dedicated linear solvers.</p>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfigconformal"></a></p><center> <div class="image">
<img src="conformal_new.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigconformal">Figure 66.6</a> Discrete Conformal Map. Rightmost: parameter space.  </div>  <br />

<h3><a class="anchor" id="Surface_mesh_parameterizationFloaterMean"></a>
Floater Mean Value Coordinates</h3>
<p><code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1Mean__value__coordinates__parameterizer__3.html" title="The class Mean_value_coordinates_parameterizer_3 implements Floater Mean Value Coordinates parameteri...">Surface_mesh_parameterization::Mean_value_coordinates_parameterizer_3</a>&lt;TriangleMesh, BorderParameterizer, SolverTraits&gt;</code></p>
<p>The Mean Value Coordinates parameterization method has been introduced by Floater <a class="el" href="citelist.html#CITEREF_cgal:f-mvc-03">[4]</a>. Each vertex in parameter space is optimized to be a convex combination of its neighboring vertices. This method is in essence an approximation of the Discrete Conformal Map, with a guaranteed one-to-one mapping when the border is convex. This method solves two #vertices x #vertices sparse linear systems. The matrix (the same for both systems) is asymmetric.</p>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfigfloater"></a></p><center> <div class="image">
<img src="floater_new.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigfloater">Figure 66.7</a> Floater Mean Value Coordinates. Rightmost: parameter space.  </div>  <br />

<h3><a class="anchor" id="secBorderParameterizationsforFixedMethods"></a>
Border Parameterizations for Fixed Methods</h3>
<p>Parameterization methods for borders are used as traits classes modifying the behavior of <code><a class="el" href="classParameterizer__3.html" title="Parameterizer_3 is a concept of parameterization object for a given type of mesh, TriangleMesh...">Parameterizer_3</a></code> models. They are also provided as models of the <code><a class="el" href="classParameterizer__3.html" title="Parameterizer_3 is a concept of parameterization object for a given type of mesh, TriangleMesh...">Parameterizer_3</a></code> concept. Border parameterizations for fixed border surface parameterizations are a family of methods to define a set of constraints, namely two \( u,v\) coordinates for each vertex along the border.</p>
<p>Different choices are offered to the user when choosing border parameterizers for fixed border methods: </p><ul>
<li>
<p class="startli">The user can select a border parameterization among two commonly used methods: uniform or arc-length parameterization.</p>
<p><em>Usage:</em> Uniform border parameterizations are more stable, although they yield poor visual results. The arc-length border parameterization is used by default.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">One convex shape specified by one shape among two standard ones: a circle or a square.</p>
<p class="endli"><em>Usage:</em> The circular border parameterization is used by default as it corresponds to the simplest convex shape. The square border parameterization is commonly used for texture mapping. </p>
</li>
</ul>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfigcircular_border"></a></p><div class="image">
<img src="border.png" alt="border.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigcircular_border">Figure 66.8</a> Left: Julius Cesar mask parameterization with Authalic/circular border. Right: Julius Cesar mask's image with Floater/square border.  </div>  <br />

<p>All combinations of uniform/arc-length and circle/square are provided by the following classes:</p>
<ul>
<li>
<code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1Circular__border__arc__length__parameterizer__3.html" title="This class parameterizes the border of a 3D surface onto a circle, with an arc-length parameterizatio...">Surface_mesh_parameterization::Circular_border_arc_length_parameterizer_3</a>&lt;TriangleMesh&gt;</code> </li>
<li>
<code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1Circular__border__uniform__parameterizer__3.html" title="This class parameterizes the border of a 3D surface onto a circle in a uniform manner: points are equ...">Surface_mesh_parameterization::Circular_border_uniform_parameterizer_3</a>&lt;TriangleMesh&gt;</code> </li>
<li>
<code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1Square__border__arc__length__parameterizer__3.html" title="This class parameterizes the border of a 3D surface onto a square, with an arc-length parameterizatio...">Surface_mesh_parameterization::Square_border_arc_length_parameterizer_3</a>&lt;TriangleMesh&gt;</code> </li>
<li>
<code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1Square__border__uniform__parameterizer__3.html" title="This class parameterizes the border of a 3D surface onto a square in a uniform manner: points are equ...">Surface_mesh_parameterization::Square_border_uniform_parameterizer_3</a>&lt;TriangleMesh&gt;</code> </li>
</ul>
<p>An illustration of the use of different border parameterizers can be found in the example <a class="el" href="Surface_mesh_parameterization_2square_border_parameterizer_8cpp-example.html">square_border_parameterizer.cpp</a>.</p>
<h2><a class="anchor" id="Surface_mesh_parameterizationFreeBorderSurface"></a>
Free Border Surface Parameterizations</h2>
<p>For free border parameterization methods, the vertices of the border are free to move.</p>
<h3><a class="anchor" id="Surface_mesh_parameterizationLeastSquares"></a>
Least Squares Conformal Maps</h3>
<p><code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1LSCM__parameterizer__3.html" title="The class LSCM_parameterizer_3 implements the Least Squares Conformal Maps (LSCM) parameterization ...">Surface_mesh_parameterization::LSCM_parameterizer_3</a>&lt;TriangleMesh, BorderParameterizer, SolverTraits&gt;</code></p>
<p>The Least Squares Conformal Maps (LSCM) parameterization method has been introduced by Lévy et al. <a class="el" href="citelist.html#CITEREF_cgal:lprm-lscm-02">[7]</a>. It corresponds to a conformal method with a free border (at least two vertices have to be constrained to obtain a unique solution), which allows further lowering of the angle distortion. A one-to-one mapping is not guaranteed by this method. It solves a (2 \( \times\) #triangles) \( \times\) #vertices sparse linear system in the least squares sense, which implies solving a symmetric matrix.</p>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfigLSCM"></a></p><center> <div class="image">
<img src="LSCM_new.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigLSCM">Figure 66.9</a> Least Squares Conformal Maps. Rightmost: parameter space.  </div>  <br />

<h3><a class="anchor" id="Surface_mesh_parameterizationARAP"></a>
As Rigid As Possible Parameterization</h3>
<p><code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1ARAP__parameterizer__3.html" title="The class ARAP_parameterizer_3 implements the Local/Global Approach to Mesh Parameterization ...">Surface_mesh_parameterization::ARAP_parameterizer_3</a>&lt;TriangleMesh, BorderParameterizer, SolverTraits&gt;</code></p>
<p>An as-rigid-as-possible parameterization was introduced by Liu et al. <a class="el" href="citelist.html#CITEREF_liu2008local">[8]</a>. It is a shape-preserving method based on an iterative energy minimization process. Each step alternates a local optimization technique to find the best local mapping and a global stitching technique equivalent to the resolution of a linear system to guarantee that the parameterized mesh is a triangulation.</p>
<p>A generalization of the formulation of the local optimization introduces a scalar coefficient λ that allows the user to balance angle and shape distortion: the closer λ is to 0, the more importance is given to the minimization of angle distortion; inversely, when λ grows, the parameterizer gives more and more importance to the minimization of shape distortion.</p>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfigARAP"></a></p><center> <div class="image">
<img src="ARAP_new.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigARAP">Figure 66.10</a> As Rigid As Possible parameterization (the blue line depicts the cut graph). Rightmost: parameter space.  </div>  <br />

<h3><a class="anchor" id="secBorderParameterizationsforFreeMethods"></a>
Border Parameterizations for Free Methods</h3>
<p>Parameterization methods for borders are used as traits classes modifying the behavior of <code><a class="el" href="classParameterizer__3.html" title="Parameterizer_3 is a concept of parameterization object for a given type of mesh, TriangleMesh...">Parameterizer_3</a></code> models. They are also provided as models of the <code><a class="el" href="classParameterizer__3.html" title="Parameterizer_3 is a concept of parameterization object for a given type of mesh, TriangleMesh...">Parameterizer_3</a></code> concept. The border parameterizations associated to free border surface parameterization methods define only two constraints: the pinned vertices.</p>
<ul>
<li>
<p class="startli"><code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1Two__vertices__parameterizer__3.html" title="The class Two_vertices_parameterizer_3 parameterizes two extreme vertices of a 3D surface...">Surface_mesh_parameterization::Two_vertices_parameterizer_3</a>&lt;TriangleMesh&gt;</code></p>
<p><em>Usage:</em> <code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1Two__vertices__parameterizer__3.html" title="The class Two_vertices_parameterizer_3 parameterizes two extreme vertices of a 3D surface...">Surface_mesh_parameterization::Two_vertices_parameterizer_3</a>&lt;TriangleMesh&gt;</code> is the default free border parameterization, and is the only one available in the current version of this package.</p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="Surface_mesh_parameterizationBorderless"></a>
Borderless Surface Parameterizations</h2>
<p>Borderless parameterization methods do not require as input a mesh that is homeomorphic to a disk.</p>
<h3><a class="anchor" id="Surface_mesh_parameterizationOrbi"></a>
Orbifold Tutte Embeddings</h3>
<p><code><a class="el" href="classCGAL_1_1Surface__mesh__parameterization_1_1Orbifold__Tutte__parameterizer__3.html" title="The class Orbifold_Tutte_parameterizer_3 implements Orbifold Tutte Planar Embeddings ...">Surface_mesh_parameterization::Orbifold_Tutte_parameterizer_3</a>&lt;SeamMesh, SolverTraits&gt;</code></p>
<p>Orbifold-Tutte Planar Embedding was introduced by Aigerman and Lipman <a class="el" href="citelist.html#CITEREF_aigerman2015orbifold">[1]</a> and is a generalization of Tutte’s embedding to other topologies, and in particular spheres, which we consider here. The orbifold-Tutte embedding bijectively maps the original surface, that is required to be a topological ball, to a canonical, topologically equivalent, two-dimensional flat surface called an Euclidean orbifold. There are 17 Euclidean orbifolds, of which only the 4 sphere orbifolds are currently implemented in CGAL.</p>
<p>The orbifold-Tutte embedding yields a seamless, globally bijective parameterization that, similarly to the classic Tutte embedding, only requires solving a sparse linear system for its computation.</p>
<p>The algorithm requires the user to select a set of vertices of the input mesh and mark them as <em>cones</em>, which will be the singularities of the unfolding. Internally, the process requires the use of (virtual) seams between the cones, but the choice of these seams does not influence the result. The <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Seam__mesh.html">Seam_mesh</a></code> structure (see also Section <a class="el" href="index.html#secCuttingaMesh">Cutting a Mesh</a>) is used for this purpose.</p>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfigOrbifold"></a></p><center> <div class="image">
<img src="orbifold_new.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigOrbifold">Figure 66.11</a> Type IV Orbifold Tutte Embedding. The (four) base cones are shown in green and the virtual cut is traced in blue. Rightmost: parameter space.  </div>  <br />

<h1><a class="anchor" id="secCuttingaMesh"></a>
Cutting a Mesh</h1>
<p>The surface parameterization methods proposed in this package only deal with meshes which are homeomorphic (topologically equivalent) to discs. Nevertheless, meshes with arbitrary topology and number of connected components can be parameterized, provided that the user specifies a cut graph (a set of edges), which defines the border of a topological disc. These edges can be passed together with a mesh via the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Seam__mesh.html">Seam_mesh</a></code> structure.</p>
<p><a class="anchor" id="fig__Surface_mesh_parameterizationfigcut"></a></p><div class="image">
<img src="cut.png" alt="cut.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Surface_mesh_parameterizationfigcut">Figure 66.12</a> Cut Graph  </div>  <br />

<p>In the following example, we apply the default parameterization to a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code>-based <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Seam__mesh.html">Seam_mesh</a></code>. We store the UV-coordinates as a halfedge property using a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Miscellany.tag:../Miscellany/" href="../Miscellany/classCGAL_1_1Unique__hash__map.html">Unique_hash_map</a></code>.</p>
<p>Note that vertices on a seam are duplicated in a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Seam__mesh.html">Seam_mesh</a></code> structure and thus the UV-coordinates are here associated to the halfedges of the underlying (input) mesh.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_parameterization_2seam_Polyhedron_3_8cpp-example.html">Surface_mesh_parameterization/seam_Polyhedron_3.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/Seam_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/IO/File_off.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_parameterization/parameterize.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Unique_hash_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/measure.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>      Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                     Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                     Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>          PolyMesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;PolyMesh&gt;::edge_descriptor SM_edge_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;PolyMesh&gt;::halfedge_descriptor SM_halfedge_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;PolyMesh&gt;::vertex_descriptor SM_vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Miscellany.tag:../Miscellany/" href="../Miscellany/classCGAL_1_1Unique__hash__map.html">CGAL::Unique_hash_map&lt;SM_halfedge_descriptor, Point_2&gt;</a> UV_uhm;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Miscellany.tag:../Miscellany/" href="../Miscellany/classCGAL_1_1Unique__hash__map.html">CGAL::Unique_hash_map&lt;SM_edge_descriptor, bool&gt;</a> Seam_edge_uhm;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Miscellany.tag:../Miscellany/" href="../Miscellany/classCGAL_1_1Unique__hash__map.html">CGAL::Unique_hash_map&lt;SM_vertex_descriptor, bool&gt;</a> Seam_vertex_uhm;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;UV_uhm&gt; UV_pmap;</div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Seam_edge_uhm&gt; Seam_edge_pmap;</div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Seam_vertex_uhm&gt; Seam_vertex_pmap;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Seam__mesh.html">CGAL::Seam_mesh&lt;PolyMesh, Seam_edge_pmap, Seam_vertex_pmap&gt;</a> Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::halfedge_descriptor halfedge_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor face_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SMP = <a class="code" href="namespaceCGAL_1_1Surface__mesh__parameterization.html">CGAL::Surface_mesh_parameterization</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream in_mesh((argc&gt;1)?argv[1]:<span class="stringliteral">"data/lion.off"</span>);</div><div class="line">  <span class="keywordflow">if</span>(!in_mesh) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: problem loading the input data"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  PolyMesh sm;</div><div class="line">  in_mesh &gt;&gt; sm;</div><div class="line"></div><div class="line">  <span class="comment">// Two property maps to store the seam edges and vertices</span></div><div class="line">  Seam_edge_uhm seam_edge_uhm(<span class="keyword">false</span>);</div><div class="line">  Seam_edge_pmap seam_edge_pm(seam_edge_uhm);</div><div class="line"></div><div class="line">  Seam_vertex_uhm seam_vertex_uhm(<span class="keyword">false</span>);</div><div class="line">  Seam_vertex_pmap seam_vertex_pm(seam_vertex_uhm);</div><div class="line"></div><div class="line">  Mesh mesh(sm, seam_edge_pm, seam_vertex_pm);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc&gt;2) ? argv[2] : <span class="stringliteral">"data/lion.selection.txt"</span>;</div><div class="line">  SM_halfedge_descriptor smhd = mesh.add_seams(filename);</div><div class="line">  <span class="keywordflow">if</span>(smhd == SM_halfedge_descriptor() ) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Warning: No seams in input"</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// The 2D points of the uv parametrisation will be written into this map</span></div><div class="line">  <span class="comment">// Note that this is a halfedge property map, and that uv values</span></div><div class="line">  <span class="comment">// are only stored for the canonical halfedges representing a vertex</span></div><div class="line">  UV_uhm uv_uhm;</div><div class="line">  UV_pmap uv_pm(uv_uhm);</div><div class="line"></div><div class="line">  <span class="comment">// A halfedge on the (possibly virtual) border</span></div><div class="line">  halfedge_descriptor bhd = CGAL::Polygon_mesh_processing::longest_border(mesh).first;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgSurfaceParameterizationMainFunction.html#gad05bcd0979ce93d681d4f27a9ccd820b">SMP::parameterize</a>(mesh, bhd, uv_pm);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">"result.off"</span>);</div><div class="line">  SMP::IO::output_uvmap_to_off(mesh, bhd, uv_pm, out);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Surface_mesh_parameterizationComplexity"></a>
Complexity and Guarantees</h1>
<h2><a class="anchor" id="Surface_mesh_parameterizationParameterization"></a>
Parameterization Methods and Guarantees</h2>
<ul>
<li>
<p class="startli">Fixed boundaries</p>
<ul>
<li>
<p class="startli">One-to-one mapping</p>
<p>Tutte's theorem guarantees a one-to-one mapping provided that the weights are all positive and the border is convex. It is the case for Tutte Barycentric Mapping and Floater Mean Value Coordinates. It is not always the case for Discrete Conformal Map (cotangents) and Discrete Authalic parameterization.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Non-singularity of the matrix</p>
<p>Geshorgin's theorem guarantees the convergence of the solver if the matrix is diagonal dominant. This is the case with positive weights (Tutte Barycentric Mapping and Floater Mean Value Coordinates).</p>
<p class="endli"></p>
</li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Free boundaries</p>
<ul>
<li>
<p class="startli">One-to-one mapping</p>
<p>No guarantee is provided by either LSCM or ARAP parameterizations (both global overlaps and triangle flips can occur).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Non-singularity of the matrix</p>
<p>For LSCM, the matrix of the system is the Gram matrix of a matrix with maximal rank, and is therefore non-singular (Gram theorem).</p>
<p class="endli"></p>
</li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Boundary-less</p>
<ul>
<li>
<p class="startli">One-to-one mapping</p>
<p>The Orbifold-Tutte embedding is guaranteed to exist and to be computable via a sparse linear system.</p>
<p class="endli"></p>
</li>
</ul>
<p class="endli"></p>
</li>
</ul>
<h1><a class="anchor" id="Surface_mesh_parameterizationExtendingthe"></a>
Implementation History</h1>
<p>The main author of the first version of this package was Laurent Saboret, who worked as an engineer at Inria Sophia-Antipolis under the supervision of Pierre Alliez and Bruno Lévy. Bruno Lévy added OpenNL support to the package.</p>
<p>For CGAL 4.11, the package has undergone a major rewrite by Andreas Fabri and Mael Rouxel-Labbé. The As-Rigid-As-Possible parameterization technique was added and all algorithms are now based on the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceGraph.html">FaceGraph</a></code> API. The Orbifold Tutte Embedding parameterization technique was also added with the help of its authors, Noam Aigerman and Yaron Lipman. Finally, the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Seam__mesh.html">Seam_mesh</a></code> was introduced to handle virtual borders. The class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Seam__mesh.html">Seam_mesh</a></code> is also a model of a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceGraph.html">FaceGraph</a></code>, and replaces a wrapper which had a more complicated API. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:04 for CGAL 4.13 - Planar Parameterization of Triangulated Surface Meshes by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
