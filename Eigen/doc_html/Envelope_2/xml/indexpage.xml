<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Envelopes_of_Curves_in_2D"/> <anchor id="index_1chapterEnvelope2"/>  <simplesect kind="author"><para>Ron Wein</para></simplesect>
<anchor id="index_1fig__LowEnv2Fig"/><image type="html" name="lwrenv.png"></image>
 <image type="latex" name="lwrenv.png" width="15cm"></image>
  <ref refid="index_1fig__LowEnv2Fig" kindref="member">fig__LowEnv2Fig</ref> The lower envelope of a set of line segments and hyperbolic arc.  <linebreak/>
</para><sect1 id="index_1Envelope_2Introduction">
<title>Introduction</title>
<para>A continuous curve <formula id="6">$ C$</formula> in <formula id="7">$ {\mathbb R}^2$</formula> is called <emphasis> <formula id="1">$ x$</formula>-monotone</emphasis>, if every vertical line intersects it at a single point at most. For example, the circle <formula id="8">$ x^2 + y^2 = 1$</formula> is <emphasis>not</emphasis> <formula id="9">$ xy$</formula>-monotone as the vertical line <formula id="10">$ x = 0$</formula> intersects it at <formula id="11">$ (0, -1)$</formula> and at <formula id="12">$ (0, 1)$</formula>; however, it is possible to split the circle into an upper part and a lower part, such that both of these parts are <formula id="1">$ x$</formula>-monotone. We consider vertical segments as <emphasis>weakly</emphasis> <formula id="1">$ x$</formula>-monotone, to properly handle inputs that contain such vertical curves.</para><para>An <formula id="1">$ x$</formula>-monotone curve can be represented as a univariate function <formula id="13">$ y = C(x)$</formula>, defined over some continuous range <formula id="14">$ R_C \subseteq {\mathbb R}$</formula>. Given a set <formula id="15">$ {\cal C} = \{ C_1, C_2, \ldots, C_n \}$</formula> of <formula id="1">$ x$</formula>-monotone curves, their <emphasis>lower envelope</emphasis> is defined as the point-wise minimum of all curves. Namely, the lower envelope of the set <formula id="16">$ {\cal C}$</formula> can be defined as the following function:</para><para><formula id="17">\begin{eqnarray*} {\cal L}_{{\cal C}} (x) = \min_{1 \leq k \leq n}{\overline{C}_k (x)} \ , \end{eqnarray*}</formula></para><para>where we define <formula id="18">$\overline{C}_k(x) = C_k(x)$</formula> for <formula id="19">$x \in R_{C_k}$</formula>, and <formula id="20">$\overline{C}_k(x) = \infty$</formula> otherwise.</para><para>Similarly, the <emphasis>upper envelope</emphasis> of <formula id="21">${\cal C}$</formula> is the point-wise maximum of the <formula id="22">$x$</formula>-monotone curves in the set: <formula id="23">\begin{eqnarray*} {\cal U}_{{\cal C}} (x) = \max_{1 \leq k \leq n}{\underline{C}_k (x)} \ , \end{eqnarray*}</formula> where in this case <formula id="24">$ \underline{C}_k(x) = -\infty$</formula> for <formula id="25">$ x \not\in R_{C_k}$</formula>.</para><para>Given a set of <formula id="1">$ x$</formula>-monotone curves <formula id="16">$ {\cal C}$</formula>, the <emphasis>minimization diagram</emphasis> of <formula id="16">$ {\cal C}$</formula> is a subdivision of the <formula id="1">$ x$</formula>-axis into cells, such that the identity of the curves that induce the lower envelope over a specific cell of the subdivision (an edge or a vertex) is the same. In non-degenerate situations, an edge - which represents a continuous interval on the <formula id="1">$ x$</formula>-axis - is induced by a single curve (or by no curves at all, if there are no <formula id="1">$ x$</formula>-monotone curves defined over the interval), and a vertex is induced by a single curve and corresponds to one of its endpoints, or by two curves and corresponds to their intersection point. The <emphasis>maximization diagram</emphasis> is symmetrically defined for upper envelopes. In the rest of this chapter, we refer to both these diagrams as <emphasis>envelope diagrams</emphasis>.</para><para>Lower and upper envelopes can be efficiently computed using a divide-and-conquer approach. First, note that the envelope diagram for a single <formula id="1">$ x$</formula>-monotone curve <formula id="26">$ C_k$</formula> is trivial to compute: we project the boundary of its range of definition <formula id="27">$ R_{C_k}$</formula> onto the <formula id="1">$ x$</formula>-axis and label the features it induces accordingly. Given a set <formula id="28">$ {\cal D}$</formula> of (non necessarily <formula id="1">$ x$</formula>-monotone) curves in <formula id="7">$ {\mathbb R}^2$</formula>, we subdivide each curve into a finite number of weakly <formula id="1">$ x$</formula>-monotone curves, and obtain the set <formula id="16">$ {\cal C}$</formula>. Then, we split the set into two disjoint subsets <formula id="29">$ {\cal C}_1$</formula> and <formula id="30">$ {\cal C}_2$</formula>, and we compute their envelope diagrams recursively. Finally, we merge the diagrams in linear time by traversing both diagrams in parallel.</para></sect1>
<sect1 id="index_1env2_secenv_diag">
<title>The Envelope Diagram</title>
<para>The package basically contains two sets of free functions: <ref refid="group__PkgEnvelope2_1ga6567d5008ff085e1e7ed4d8b4baaaf68" kindref="member"><computeroutput>lower_envelope_x_monotone_2(begin, end, diag)</computeroutput></ref> (similarly <computeroutput><ref refid="group__PkgEnvelope2_1ga5cf2e72a9a4680d5abc12ba16b43906e" kindref="member">upper_envelope_x_monotone_2()</ref></computeroutput>) construct the envelope diagram for a given range of <formula id="1">$ x$</formula>-monotone curves, while <ref refid="group__PkgEnvelope2_1ga6567d5008ff085e1e7ed4d8b4baaaf68" kindref="member"><computeroutput>lower_envelope_2(begin, end, diag)</computeroutput></ref> (similarly <computeroutput><ref refid="group__PkgEnvelope2_1ga680a36e045fb4afea381c24423898c40" kindref="member">upper_envelope_2()</ref></computeroutput>) construct the envelope diagram for a range of <emphasis>arbitrary</emphasis> (not necessarily <formula id="1">$ x$</formula>-monotone) curves. In this section we explain more on the structure of the envelope diagram these functions output.</para><para><anchor id="index_1fig__env2_figmin_diag"/><image type="html" name="min_diag.png"></image>
 <image type="latex" name="min_diag.png" width="15cm"></image>
  <ref refid="index_1fig__env2_figmin_diag" kindref="member">fig__env2_figmin_diag</ref> The lower envelope of eight line segments, labeled <formula id="31">$ A, \ldots, H$</formula>, as constructed in <computeroutput>envelope_segments.cpp</computeroutput>. The minimization diagram is shown at the bottom, where each diagram vertex points to the point associated with it, and the labels of the segment that induce a diagram edge are displayed below this edge. Note that there exists one edge that represents an overlap (i.e., there are two segments that induce it), and there are also a few edges that represent empty intervals.  <linebreak/>
</para><para>A minimization diagram or a maximization diagram is represented by a model of the concept <computeroutput><ref refid="classEnvelopeDiagram__1" kindref="compound">EnvelopeDiagram_1</ref></computeroutput>. This concept defines the structure of the subdivision of the <formula id="1">$ x$</formula>-axis into 0-dimensional cells called <emphasis>vertices</emphasis>, and 1-dimensional cells called <emphasis>edges</emphasis>. The important property of this subdivision is that the identity of the curves that induce the lower envelope (or the upper envelope) over each cell is fixed.</para><para><ref refid="index_1fig__env2_figmin_diag" kindref="member">fig__env2_figmin_diag</ref> shows the lower envelope of a set of eight line segments, and sketches the structure of their minimization diagram. Each diagram vertex <formula id="32">$ v$</formula> is associated with a point <formula id="33">$ p_v$</formula> on the envelope, which corresponds to either a curve endpoint or to an intersection point of two (or more) curves. The vertex is therefore associated with a set of <formula id="1">$ x$</formula>-monotone curves that induce the envelope over <formula id="33">$ p_v$</formula>. Each vertex is incident to two edges, one lying to its left and the other to its right.</para><para>An edge in the envelope diagram represents a continuous portion of the <formula id="1">$ x$</formula>-axis, and is associated with a set of <formula id="1">$ x$</formula>-monotone curves that induce the envelope over this interval. Note that this set may be empty if no <formula id="1">$ x$</formula>-monotone curves are defined over this interval. In degenerate situations where curves overlap, there may be more than a single curve that induces the envelope over the interval the edge represents. An envelop diagram of a set of curves either consists of a single unbounded edge (in case the curve set is empty or if the envelope contains a single unbounded curve that is below or above all other curves), or at least one vertex and two unbounded edges, while each additional vertex comes along with an additional edge. It is possible to directly access the <emphasis>leftmost</emphasis> edge, representing the unbounded interval that starts at <formula id="34">$ -\infty$</formula>, and the <emphasis>rightmost</emphasis> edge, representing the unbounded interval that ends at <formula id="35">$ \infty$</formula>. (In the example depicted in <ref refid="index_1fig__env2_figmin_diag" kindref="member">fig__env2_figmin_diag</ref> we have only bounded curves, so the leftmost and rightmost edges represent empty intervals. This is not the case when we deal, for example, with envelopes of sets of lines.)</para><para>Any model of the <computeroutput><ref refid="classEnvelopeDiagram__1" kindref="compound">EnvelopeDiagram_1</ref></computeroutput> concept must define a geometric traits class, which in turn defines the <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> and <computeroutput>X_monotone_curve_2</computeroutput> types defined with the diagram features. The geometric traits class must be a model of the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">ArrangementXMonotoneTraits_2</ref></computeroutput> concept in case we construct envelopes of <formula id="1">$ x$</formula>-monotone curves. If we are interested in handling arbitrary (not necessarily <formula id="1">$ x$</formula>-monotone) curves, the traits class must be a model of the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">ArrangementTraits_2</ref></computeroutput> concept. This concepts refined the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">ArrangementXMonotoneTraits_2</ref></computeroutput> concept; a traits class that models this concepts must also defines a <computeroutput>Curve_2</computeroutput> type, representing an arbitrary planar curve, and provide a functor for subdividing such curves into <formula id="1">$ x$</formula>-monotone subcurves.</para></sect1>
<sect1 id="index_1Envelope_2Examples">
<title>Examples</title>
<sect2 id="index_1Envelope_2ExampleforEnvelopeofLineSegments">
<title>Example for Envelope of Line Segments</title>
<para>The following example demonstrates how to compute and traverse the minimization diagram of line segments, as illustrated in <ref refid="index_1fig__env2_figmin_diag" kindref="member">fig__env2_figmin_diag</ref>. We use the curve-data traits instantiated by the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_segment_traits_2</ref></computeroutput> class, in order to attach a label (a <computeroutput>char</computeroutput> in this case) to each input segment. We use these labels when we print the minimization diagram.</para><para><linebreak/>
<bold>File</bold> <ref refid="Envelope_2_2envelope_segments_8cpp-example" kindref="compound">Envelope_2/envelope_segments.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>the<sp/>lower<sp/>envelope<sp/>of<sp/>a<sp/>set<sp/>of<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_rational.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_curve_data_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Envelope_diagram_1.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/envelope_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Segment_traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_curve_data_traits_2</ref>&lt;Segment_traits_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Labeled_segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Envelope__diagram__1" kindref="compound">CGAL::Envelope_diagram_1&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Diagram_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Consrtuct<sp/>the<sp/>input<sp/>segments<sp/>and<sp/>label<sp/>them<sp/>&apos;A&apos;<sp/>...<sp/>&apos;H&apos;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Labeled_segment_2&gt;<sp/><sp/><sp/>segments;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back<sp/>(Labeled_segment_2<sp/>(Segment_2<sp/>(Point_2<sp/>(0,<sp/>1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(2,<sp/>3)),<sp/></highlight><highlight class="charliteral">&apos;A&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back<sp/>(Labeled_segment_2<sp/>(Segment_2<sp/>(Point_2<sp/>(1,<sp/>2),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(4,<sp/>5)),<sp/></highlight><highlight class="charliteral">&apos;B&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back<sp/>(Labeled_segment_2<sp/>(Segment_2<sp/>(Point_2<sp/>(1,<sp/>5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(7,<sp/>2)),<sp/></highlight><highlight class="charliteral">&apos;C&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back<sp/>(Labeled_segment_2<sp/>(Segment_2<sp/>(Point_2<sp/>(4,<sp/>2),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(6,<sp/>4)),<sp/></highlight><highlight class="charliteral">&apos;D&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back<sp/>(Labeled_segment_2<sp/>(Segment_2<sp/>(Point_2<sp/>(8,<sp/>3),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(8,<sp/>6)),<sp/></highlight><highlight class="charliteral">&apos;E&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back<sp/>(Labeled_segment_2<sp/>(Segment_2<sp/>(Point_2<sp/>(9,<sp/>2),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(12,<sp/>4)),<sp/></highlight><highlight class="charliteral">&apos;F&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back<sp/>(Labeled_segment_2<sp/>(Segment_2<sp/>(Point_2<sp/>(10,<sp/>2),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(12,<sp/>1)),<sp/></highlight><highlight class="charliteral">&apos;G&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back<sp/>(Labeled_segment_2<sp/>(Segment_2<sp/>(Point_2<sp/>(11,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(11,<sp/>5)),<sp/></highlight><highlight class="charliteral">&apos;H&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>minimization<sp/>diagram<sp/>that<sp/>represents<sp/>their<sp/>lower<sp/>envelope.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Diagram_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>min_diag;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgEnvelope2_1ga6567d5008ff085e1e7ed4d8b4baaaf68" kindref="member">lower_envelope_x_monotone_2</ref><sp/>(segments.begin(),<sp/>segments.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>min_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>minimization<sp/>diagram.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Diagram_1::Edge_const_handle<sp/><sp/><sp/><sp/><sp/>e<sp/>=<sp/>min_diag.leftmost();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Diagram_1::Vertex_const_handle<sp/><sp/><sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Diagram_1::Curve_const_iterator<sp/><sp/>cit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(e<sp/>!=<sp/>min_diag.rightmost())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Edge:&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>e-&gt;is_empty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(cit<sp/>=<sp/>e-&gt;curves_begin();<sp/>cit<sp/>!=<sp/>e-&gt;curves_end();<sp/>++cit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>cit-&gt;data();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[empty]&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>=<sp/>e-&gt;right();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Vertex<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>v-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;):&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(cit<sp/>=<sp/>v-&gt;curves_begin();<sp/>cit<sp/>!=<sp/>v-&gt;curves_end();<sp/>++cit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>cit-&gt;data();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>e<sp/>=<sp/>v-&gt;right();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(e-&gt;is_empty());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Edge:<sp/>[empty]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Envelope_2ExampleforComputingtheConvexHull">
<title>Example for Computing the Convex Hull with Envelopes</title>
<para>The next example computes the convex hull of a set of input points by constructing envelopes of unbounded curves, in our case lines that are dual to the input points. Here use the <computeroutput><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_linear_traits_2</ref></computeroutput> class to compute the lower envelope of the set of dual lines. We read a set of points <formula id="36">$ {\cal P} = p_1, \ldots, p_n$</formula> from an input file, and construct the corresponding dual lines <formula id="37">$ {\cal P}^{*} = p^{*}_1, \ldots, p^{*}_n$</formula>, where the line <formula id="38">$ p^{*}$</formula> dual to a point <formula id="39">$ p = (p_x, p_y)$</formula> is given by <formula id="40">$ y = p_x x - p_y$</formula>. We then compute the convex hull of the point-set <formula id="41">$ {\cal P}$</formula>, using the fact that the lines that form the lower envelope of <formula id="42">$ {\cal P}^{*}$</formula> are dual to the points along the <emphasis>upper</emphasis> part of <formula id="41">$ {\cal P}$</formula>&apos;s convex hull, and the lines that form the upper envelope of <formula id="42">$ {\cal P}^{*}$</formula> are dual to the points along the <emphasis>lower</emphasis> part of the convex hull; see, e.g., <ref refid="citelist_1CITEREF_bkos-cgaa-97" kindref="member">[1]</ref>, Section 11.4 for more details. Note that the leftmost edge of the minimization diagram is associated with the same line as the rightmost edge of the maximization diagram, and vice-verse. We can therefore skip the rightmost edges of both diagrams.</para><para><linebreak/>
<bold>File</bold> <ref refid="Envelope_2_2convex_hull_2_8cpp-example" kindref="compound">Envelope_2/convex_hull_2.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Compute<sp/>the<sp/>convex<sp/>hull<sp/>of<sp/>set<sp/>of<sp/>points<sp/>using<sp/>the<sp/>lower<sp/>envelope<sp/>and<sp/>upper</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>envelopes<sp/>of<sp/>their<sp/>dual<sp/>line.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_rational.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_linear_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_curve_data_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Envelope_diagram_1.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/envelope_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Linear_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Linear_traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Linear_traits_2::Line_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Line_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_curve_data_traits_2</ref>&lt;Linear_traits_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;<sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dual_line_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Envelope__diagram__1" kindref="compound">CGAL::Envelope_diagram_1&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Diagram_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>points<sp/>from<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;ch_points.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>points<sp/>from<sp/>the<sp/>file,<sp/>and<sp/>construct<sp/>their<sp/>dual<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Dual_line_2&gt;<sp/><sp/>dual_lines;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;<sp/><sp/><sp/><sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.resize(n);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>n;<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>px,<sp/>py;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>px<sp/>&gt;&gt;<sp/>py;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points[k]<sp/>=<sp/>Point_2<sp/>(px,<sp/>py);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>line<sp/>dual<sp/>to<sp/>the<sp/>point<sp/>(p_x,<sp/>p_y)<sp/>is<sp/>y<sp/>=<sp/>p_x*x<sp/>-<sp/>p_y,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>or:<sp/>p_x*x<sp/>-<sp/>y<sp/>-<sp/>p_y<sp/>=<sp/>0:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Line_2<sp/>line<sp/>=<sp/>Line_2<sp/>(Number_type(px),<sp/>Number_type(-1),<sp/>Number_type(-py));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Generate<sp/>the<sp/>x-monotone<sp/>curve<sp/>based<sp/>on<sp/>the<sp/>line<sp/>and<sp/>the<sp/>point<sp/>index.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dual_lines.push_back<sp/>(Dual_line_2<sp/>(line,<sp/>k));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>lower<sp/>envelope<sp/>of<sp/>dual<sp/>lines,<sp/>which<sp/>corresponds<sp/>to<sp/>the<sp/>upper</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>part<sp/>of<sp/>the<sp/>convex<sp/>hull,<sp/>and<sp/>their<sp/>upper<sp/>envelope,<sp/>which<sp/>corresponds<sp/>to</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>lower<sp/>part<sp/>of<sp/>the<sp/>convex<sp/>hull.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Diagram_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>min_diag;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Diagram_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_diag;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgEnvelope2_1ga6567d5008ff085e1e7ed4d8b4baaaf68" kindref="member">lower_envelope_x_monotone_2</ref>(dual_lines.begin(),<sp/>dual_lines.end(),<sp/>min_diag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgEnvelope2_1ga5cf2e72a9a4680d5abc12ba16b43906e" kindref="member">upper_envelope_x_monotone_2</ref>(dual_lines.begin(),<sp/>dual_lines.end(),<sp/>max_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>the<sp/>points<sp/>along<sp/>the<sp/>boundary<sp/>convex<sp/>hull<sp/>in<sp/>counterclockwise</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>order.<sp/>We<sp/>start<sp/>by<sp/>traversing<sp/>the<sp/>minimization<sp/>diagram<sp/>from<sp/>left<sp/>to</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>right,<sp/>then<sp/>the<sp/>maximization<sp/>diagram<sp/>from<sp/>right<sp/>to<sp/>left.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>convex<sp/>hull<sp/>of<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>input<sp/>points:&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Diagram_1::Edge_const_handle<sp/><sp/>e<sp/>=<sp/>min_diag.leftmost();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(e<sp/>!=<sp/>min_diag.rightmost())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points[e-&gt;curve().data()]<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;)&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>e<sp/>=<sp/>e-&gt;right()-&gt;right();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Handle<sp/>the<sp/>degenerate<sp/>case<sp/>of<sp/>a<sp/>vertical<sp/>convex<sp/>hull<sp/>edge:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(e-&gt;curve().data()<sp/>!=<sp/>max_diag.leftmost()-&gt;curve().data())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points[e-&gt;curve().data()]<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;)&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>e<sp/>=<sp/>max_diag.leftmost();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(e<sp/>!=<sp/>max_diag.rightmost())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points[e-&gt;curve().data()]<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;)&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>e<sp/>=<sp/>e-&gt;right()-&gt;right();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__env2_figex_circ"/><image type="html" name="ex_circle.png"></image>
 <image type="latex" name="ex_circle.png" width="15cm"></image>
  <ref refid="index_1fig__env2_figex_circ" kindref="member">fig__env2_figex_circ</ref> A set of four circles, as constructed in <ref refid="Envelope_2_2envelope_circles_8cpp-example" kindref="compound">Envelope_2/envelope_circles.cpp</ref>. The lower envelope and the upper envelope are shown using thick dashed lines of different colors respectively.  <linebreak/>
</para></sect2>
<sect2 id="index_1Envelope_2ExampleforEnvelopeofNonLinearCurves">
<title>Example for Envelope of Non-Linear Curves</title>
<para>We conclude by an example of envelopes of non-linear curves. We use the <computeroutput><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_circle_segment_traits_2</ref></computeroutput> class to construct the lower and the upper envelopes of a set of four circles, as depicted in <ref refid="index_1fig__env2_figex_circ" kindref="member">fig__env2_figex_circ</ref>. Note that unlike the two previous examples, here our curves are not <formula id="1">$ x$</formula>-monotone, so we use the functions that compute envelopes of arbitrary curves.</para><para><linebreak/>
<bold>File</bold> <ref refid="Envelope_2_2envelope_circles_8cpp-example" kindref="compound">Envelope_2/envelope_circles.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>the<sp/>envelopes<sp/>of<sp/>a<sp/>set<sp/>of<sp/>circles<sp/>using<sp/>the<sp/>circle-segment</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>traits.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_rational.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_circle_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Envelope_diagram_1.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/envelope_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel_point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Circle__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Circle_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Circle_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_circle_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Envelope__diagram__1" kindref="compound">CGAL::Envelope_diagram_1&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Diagram_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_diagram<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Diagram_1&amp;<sp/>diag)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Diagram_1::Edge_const_handle<sp/><sp/><sp/><sp/><sp/>e<sp/>=<sp/>diag.leftmost();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Diagram_1::Vertex_const_handle<sp/><sp/><sp/>v;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(e<sp/>!=<sp/>diag.rightmost())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Edge:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>e-&gt;is_empty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Circle_2<sp/><sp/><sp/><sp/><sp/><sp/>circ<sp/>=<sp/>e-&gt;curve().supporting_circle();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(x<sp/>-<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(circ.center().x())<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)^2<sp/>+&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(y<sp/>-<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(circ.center().y())<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)^2<sp/>=<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(circ.squared_radius())<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[empty]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>=<sp/>e-&gt;right();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Vertex<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(v-&gt;point().x())<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(v-&gt;point().y())<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;)&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>e<sp/>=<sp/>v-&gt;right();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(e-&gt;is_empty());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Edge:<sp/>[empty]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>four<sp/>input<sp/>circles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>circles[4];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>circles[0]<sp/>=<sp/>Circle_2<sp/>(Kernel_point_2<sp/>(1,<sp/>3),<sp/><ref refid="group__PkgAlgebraicFoundations_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::square</ref>(2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>circles[1]<sp/>=<sp/>Circle_2<sp/>(Kernel_point_2<sp/>(4,<sp/>5),<sp/><ref refid="group__PkgAlgebraicFoundations_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::square</ref>(4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>circles[2]<sp/>=<sp/>Circle_2<sp/>(Kernel_point_2<sp/>(5,<sp/>1),<sp/><ref refid="group__PkgAlgebraicFoundations_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::square</ref>(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>circles[3]<sp/>=<sp/>Circle_2<sp/>(Kernel_point_2<sp/>(6,<sp/>7),<sp/><ref refid="group__PkgAlgebraicFoundations_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::square</ref>(2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>minimization<sp/>diagram<sp/>that<sp/>represents<sp/>their<sp/>lower<sp/>envelope.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Diagram_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>min_diag;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgEnvelope2_1gac7c1cea8786016979758adab53e9686f" kindref="member">lower_envelope_2</ref><sp/>(&amp;(circles[0]),<sp/>&amp;(circles[4]),<sp/>min_diag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_diagram<sp/>(min_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>maximization<sp/>diagram<sp/>that<sp/>represents<sp/>the<sp/>upper<sp/>envelope.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Diagram_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_diag;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgEnvelope2_1ga680a36e045fb4afea381c24423898c40" kindref="member">upper_envelope_2</ref><sp/>(&amp;(circles[0]),<sp/>&amp;(circles[4]),<sp/>max_diag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_diagram<sp/>(max_diag);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
