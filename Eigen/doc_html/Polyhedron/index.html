<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Polyhedron/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 3D Polyhedral Surface: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 3D Polyhedral Surface
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_3D_Polyhedral_Surfaces"></a><a class="anchor" id="chapterPolyhedron"></a> </p><dl class="section author"><dt>Author</dt><dd>Lutz Kettner  <div id="autotoc" class="toc"></div> </dd></dl>
<h1><a class="anchor" id="sectionPolyIntro"></a>
Introduction</h1>
<p>Polyhedral surfaces in three dimensions are composed of vertices, edges, facets and an incidence relationship on them. The organization beneath is a halfedge data structure, which restricts the class of representable surfaces to orientable 2-manifolds - with and without boundary. If the surface is closed we call it a <em>polyhedron</em>, for example, see the following model of a hammerhead:</p>
<div class="image">
<img src="shark.png" alt="shark.png" />
</div>
 <p>The polyhedral surface is realized as a container class that manages vertices, halfedges, facets with their incidences, and that maintains the combinatorial integrity of them. It is based on the highly flexible design of the halfedge data structure, see the introduction in Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/index.html#chapterHalfedgeDS">Halfedge Data Structures</a> and <a class="el" href="citelist.html#CITEREF_k-ugpdd-99">[3]</a>. However, the polyhedral surface can be used and understood without knowing the underlying design. Some of the examples in this chapter introduce also gradually into first applications of this flexibility.</p>
<h1><a class="anchor" id="PolyhedronDefinition"></a>
Definition</h1>
<p>A polyhedral surface <code><a class="el" href="classCGAL_1_1Polyhedron__3.html" title="A polyhedral surface Polyhedron_3 consists of vertices V, edges E, facets F and an incidence relation...">Polyhedron_3</a>&lt;<a class="el" href="classPolyhedronTraits__3.html" title="Required types and member functions for the PolyhedronTraits_3 concept. This geometric traits concept...">PolyhedronTraits_3</a>&gt;</code> in three dimensions consists of vertices <code>V</code>, edges <code>E</code>, facets <code>F</code> and an incidence relation on them. Each edge is represented by two halfedges with opposite orientations. The incidences stored with a halfedge are illustrated in the following figure:</p>
<div class="image">
<img src="halfedge_small.png" alt="halfedge_small.png" />
</div>
 <p>Vertices represent points in space. Edges are straight line segments between two endpoints. Facets are planar polygons without holes. Facets are defined by the circular sequence of halfedges along their boundary. The polyhedral surface itself can have holes (with at least two facets surrounding it since a single facet cannot have a hole). The halfedges along the boundary of a hole are called <em>border halfedges</em> and have no incident facet. An edge is a <em>border edge</em> if one of its halfedges is a border halfedge. A surface is <em>closed</em> if it contains no border halfedges. A closed surface is a boundary representation for polyhedra in three dimensions. The convention is that the halfedges are oriented counterclockwise around facets as seen from the outside of the polyhedron. An implication is that the halfedges are oriented clockwise around the vertices. The notion of the solid side of a facet as defined by the halfedge orientation extends to polyhedral surfaces with border edges although they do not define a closed object. If normal vectors are considered for the facets, normals point outwards (following the right-hand rule).</p>
<p>The strict definition can be found in <a class="el" href="citelist.html#CITEREF_k-ugpdd-99">[3]</a>. One implication of this definition is that the polyhedral surface is always an orientable and oriented 2-manifold with border edges, i.e., the neighborhood of each point on the polyhedral surface is either homeomorphic to a disc or to a half disc, except for vertices where many holes and surfaces with boundary can join. Another implication is that the smallest representable surface avoiding self intersections is a triangle (for polyhedral surfaces with border edges) or a tetrahedron (for polyhedra). Boundary representations of orientable 2-manifolds are closed under Euler operations. They are extended with operations that create or close holes in the surface.</p>
<p>Other intersections besides the incidence relation are not allowed. However, this is not automatically verified in the operations, since self intersections are not easy to check efficiently. <code><a class="el" href="classCGAL_1_1Polyhedron__3.html" title="A polyhedral surface Polyhedron_3 consists of vertices V, edges E, facets F and an incidence relation...">Polyhedron_3</a>&lt;<a class="el" href="classPolyhedronTraits__3.html" title="Required types and member functions for the PolyhedronTraits_3 concept. This geometric traits concept...">PolyhedronTraits_3</a>&gt;</code> does only maintain the combinatorial integrity of the polyhedral surface (using Euler operations) and does not consider the coordinates of the points or any other geometric information.</p>
<p><code><a class="el" href="classCGAL_1_1Polyhedron__3.html" title="A polyhedral surface Polyhedron_3 consists of vertices V, edges E, facets F and an incidence relation...">Polyhedron_3</a>&lt;<a class="el" href="classPolyhedronTraits__3.html" title="Required types and member functions for the PolyhedronTraits_3 concept. This geometric traits concept...">PolyhedronTraits_3</a>&gt;</code> can represent polyhedral surfaces as well as polyhedra. The interface is designed in such a way that it is easy to ignore border edges and work only with polyhedra.</p>
<h1><a class="anchor" id="PolyhedronExample"></a>
Example Programs</h1>
<p><a class="anchor" id="sectionPolyExamples"></a> The polyhedral surface is based on the highly flexible design of the halfedge data structure. Examples for this flexibility can be found in Section <a class="el" href="index.html#PolyhedronExtending">Extending Vertices, Halfedges, and Facets</a> and in Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/index.html#HalfedgeDSExample">Examples</a> of the chapter on the halfedge data structure. This design is not a prerequisite to understand the following examples. See also the Section <a class="el" href="index.html#sectionPolyAdvanced">sectionPolyAdvanced</a> below for some advanced examples.</p>
<h2><a class="anchor" id="PolyhedronFirstExampleUsingDefaults"></a>
First Example Using Defaults</h2>
<p>The first example instantiates a polyhedron using a kernel as traits class. It creates a tetrahedron and stores the reference to one of its halfedges in a <code>Halfedge_handle</code>. Handles, also know as <em>trivial iterators</em>, are used to keep references to halfedges, vertices, or facets for future use. There is also a <code>Halfedge_iterator</code> type for enumerating halfedges. Such an iterator type can be used wherever a handle is required. Respective <code>Halfedge_const_handle</code> and <code>Halfedge_const_iterator</code> for a constant polyhedron and similar handles and iterators with <code>Vertex_</code> and <code>Facet_</code> prefix are provided too.</p>
<p>The example continues with a test if the halfedge actually refers to a tetrahedron. This test checks the connected component referred to by the halfedge <code>h</code> and not the polyhedral surface as a whole. This examples works only on the combinatorial level of a polyhedral surface. The next example adds the geometry.</p>
<p><br />
<b>File</b> <a class="el" href="Polyhedron_2polyhedron_prog_simple_8cpp-example.html">Polyhedron/polyhedron_prog_simple.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>     Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>         Polyhedron;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Halfedge_handle        Halfedge_handle;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Polyhedron P;</div><div class="line">    Halfedge_handle h = P.<a class="code" href="classCGAL_1_1Polyhedron__3.html#a1ebc714bb6fc75a8aa105ffb241fe087">make_tetrahedron</a>();</div><div class="line">    <span class="keywordflow">if</span> ( P.is_tetrahedron(h))</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="PolyhedronExamplewithGeometryinVertices"></a>
Example with Geometry in Vertices</h2>
<p>We add geometry to the our construction of a tetrahedron. Four points are passed as arguments to the construction. This example demonstrates in addition the use of the vertex iterator and the access to the point in the vertices. Note the natural access notation <code>v-&gt;</code><a class="el" href="classCGAL_1_1Polyhedron__3_1_1Vertex.html#ab130d4d8841cd8baa500e165ddd5e21a"><code>point()</code></a>. Similarly, all information stored in a vertex, halfedge, and facet can be accessed with a member function given a handle or iterator. For example, given a halfedge handle <code>h</code> we can write <code>h-&gt;</code><a class="el" href="classCGAL_1_1Polyhedron__3_1_1Halfedge.html#a3e7b0ca74b69a5868b430f958666df27"><code>next()</code></a> to get a halfedge handle to the next halfedge, <code>h-&gt;</code><a class="el" href="classCGAL_1_1Polyhedron__3_1_1Halfedge.html#a6f1d84341f035c8ed72ef53281173fb4"><code>opposite()</code></a> for the opposite halfedge, <code>h-&gt;</code><a class="el" href="classCGAL_1_1Polyhedron__3_1_1Halfedge.html#a5d4131be8dac43edcb5f7376d2d125bd"><code>vertex()</code></a> for the incident vertex at the tip of <code>h</code>, and so on. The output of the program will be</p>
<pre class="fragment">1 0 0
0 1 0
0 0 1
0 0 0
</pre><p><br />
<b>File</b> <a class="el" href="Polyhedron_2polyhedron_prog_tetra_8cpp-example.html">Polyhedron/polyhedron_prog_tetra.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>     Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                    Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>         Polyhedron;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Vertex_iterator        Vertex_iterator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Point_3 p( 1.0, 0.0, 0.0);</div><div class="line">    Point_3 q( 0.0, 1.0, 0.0);</div><div class="line">    Point_3 r( 0.0, 0.0, 1.0);</div><div class="line">    Point_3 s( 0.0, 0.0, 0.0);</div><div class="line"></div><div class="line">    Polyhedron P;</div><div class="line">    P.make_tetrahedron( p, q, r, s);</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#ga62462cf829e614f6f2cd2cbec9a093d2">CGAL::set_ascii_mode</a>( std::cout);</div><div class="line">    <span class="keywordflow">for</span> ( Vertex_iterator v = P.vertices_begin(); v != P.vertices_end(); ++v)</div><div class="line">        std::cout &lt;&lt; v-&gt;point() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The polyhedron offers a point iterator for convenience. The above <code>for</code> loop simplifies to a single statement by using <code>std::copy</code> and the ostream iterator adaptor.</p>
<div class="fragment"><div class="line">std::copy( P.points_begin(), P.points_end(), </div><div class="line">std::ostream_iterator&lt;Point_3&gt;(std::cout,<span class="stringliteral">"\n"</span>));</div></div><!-- fragment --><h2><a class="anchor" id="PolyhedronExampleforAffineTransformation"></a>
Example for Affine Transformation</h2>
<p>An affine transformation <code>A</code> can act as a functor transforming points and a point iterator is conveniently defined for polyhedral surfaces. So, assuming we want only the point coordinates of a polyhedron <code>P</code> transformed, <code>std::transform</code> does the job in a single line.</p>
<div class="fragment"><div class="line">std::transform( P.points_begin(), P.points_end(), P.points_begin(), A);</div></div><!-- fragment --><h2><a class="anchor" id="PolyhedronExampleComputingPlaneEquations"></a>
Example Computing Plane Equations</h2>
<p>The polyhedral surface has already provisions to store a plane equation for each facet. However, it does not provide a function to compute plane equations.</p>
<p>This example computes the plane equations of a polyhedral surface. The actual computation is implemented in the <code>Plane_equation</code> functor. Depending on the arithmetic (exact/inexact) and the shape of the facets (convex/non-convex) different methods are useful. We assume here strictly convex facets and exact arithmetic. In our example a homogeneous representation with <code>int</code> coordinates is sufficient. The four plane equations of the tetrahedron are the output of the program.</p>
<p><br />
<b>File</b> <a class="el" href="Polyhedron_2polyhedron_prog_planes_8cpp-example.html">Polyhedron/polyhedron_prog_planes.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Homogeneous.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Plane_equation {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Facet&gt;</div><div class="line">    <span class="keyword">typename</span> Facet::Plane_3 operator()( Facet&amp; f) {</div><div class="line">        <span class="keyword">typename</span> Facet::Halfedge_handle h = f.halfedge();</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Facet::Plane_3  Plane;</div><div class="line">        <span class="keywordflow">return</span> Plane( h-&gt;vertex()-&gt;point(),</div><div class="line">                      h-&gt;next()-&gt;vertex()-&gt;point(),</div><div class="line">                      h-&gt;next()-&gt;next()-&gt;vertex()-&gt;point());</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous&lt;int&gt;</a>      Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>             Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Plane__3.html">Kernel::Plane_3</a>             Plane_3;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>  Polyhedron;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Point_3 p( 1, 0, 0);</div><div class="line">    Point_3 q( 0, 1, 0);</div><div class="line">    Point_3 r( 0, 0, 1);</div><div class="line">    Point_3 s( 0, 0, 0);</div><div class="line">    Polyhedron P;</div><div class="line">    P.make_tetrahedron( p, q, r, s);</div><div class="line">    std::transform( P.facets_begin(), P.facets_end(), P.planes_begin(),</div><div class="line">                    Plane_equation());</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#ga2f2176255429973ea7bf156804a53857">CGAL::set_pretty_mode</a>( std::cout);</div><div class="line">    std::copy( P.planes_begin(), P.planes_end(),</div><div class="line">               std::ostream_iterator&lt;Plane_3&gt;( std::cout, <span class="stringliteral">"\n"</span>));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="sectionPolyVector"></a>
Example with a Vector Instead of a List Representation</h2>
<p>The polyhedron class template has actually four parameters, where three of them have default values. Using the default values explicitly in our examples above for three parameter - ignoring the fourth parameter, which would be a standard allocator for container class - the definition of a polyhedron looks like:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3</a>&lt; Traits, </div><div class="line"><a class="code" href="classCGAL_1_1Polyhedron__items__3.html">CGAL::Polyhedron_items_3</a>, </div><div class="line"><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classCGAL_1_1HalfedgeDS__default.html">CGAL::HalfedgeDS_default</a>&gt; Polyhedron;</div></div><!-- fragment --><p>The <code><a class="el" href="classCGAL_1_1Polyhedron__items__3.html" title="The class Polyhedron_items_3 is a model of the PolyhedronItems_3 concept. ">Polyhedron_items_3</a></code> class contains the types used for vertices, edges, and facets. The <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classCGAL_1_1HalfedgeDS__default.html">HalfedgeDS_default</a></code> class defines the halfedge data structure used, which is a list-based representation in this case. An alternative is a vector-based representation. Using a vector provides random access for the elements in the polyhedral surface and is more space efficient, but elements cannot be deleted arbitrarily. Using a list allows arbitrary deletions, but provides only bidirectional iterators and is less space efficient. The following example creates again a tetrahedron with given points, but in a vector-based representation.</p>
<p>The vector-based representation resizes automatically if the reserved capacity is not sufficient for the new items created. Upon resizing all handles, iterators, and circulators become invalid. Their correct update in the halfedge data structure is costly, thus it is advisable to reserve enough space in advance as indicated with the alternative constructor in the comment.</p>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>Note that the polyhedron and not the underlying halfedge data structure triggers the resize operation, since the resize operation requires some preconditions, such as valid incidences, to be fulfilled that only the polyhedron can guarantee.  </p></div> 
<p><br />
<b>File</b> <a class="el" href="Polyhedron_2polyhedron_prog_vector_8cpp-example.html">Polyhedron/polyhedron_prog_vector.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                 Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3</a>&lt; Kernel,</div><div class="line">                            CGAL::Polyhedron_items_3,</div><div class="line">                            <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classCGAL_1_1HalfedgeDS__vector.html">CGAL::HalfedgeDS_vector</a>&gt;   Polyhedron;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Point_3 p( 1.0, 0.0, 0.0);</div><div class="line">    Point_3 q( 0.0, 1.0, 0.0);</div><div class="line">    Point_3 r( 0.0, 0.0, 1.0);</div><div class="line">    Point_3 s( 0.0, 0.0, 0.0);</div><div class="line"></div><div class="line">    Polyhedron P;    <span class="comment">// alternative constructor: Polyhedron P(4,12,4);</span></div><div class="line">    P.make_tetrahedron( p, q, r, s);</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#ga62462cf829e614f6f2cd2cbec9a093d2">CGAL::set_ascii_mode</a>( std::cout);</div><div class="line">    std::copy( P.points_begin(), P.points_end(),</div><div class="line">           std::ostream_iterator&lt;Point_3&gt;( std::cout, <span class="stringliteral">"\n"</span>));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="PolyhedronExamplewithCirculatorWritingObject"></a>
Example with Circulator Writing Object File Format (OFF)</h2>
<p>We create a tetrahedron and write it to <code>std::cout</code> using the Object File Format (OFF) <a class="el" href="citelist.html#CITEREF_cgal:p-gmgv16-96">[5]</a>. This example makes use of <span style="font-variant: small-caps;">STL</span> algorithms (<code>std::copy</code>, <code>std::distance</code>), <span style="font-variant: small-caps;">STL</span> <code>std::ostream_iterator</code>, and <span style="font-variant: small-caps;">CGAL</span> circulators. The polyhedral surface provides convenient circulators for the counterclockwise circular sequence of halfedges around a facet and the clockwise circular sequence of halfedges around a vertex.</p>
<p>However, the computation of the vertex index in the inner loop of the facet output is not advisable with the <code>std::distance</code> function, since it takes linear time for non random-access iterators, which leads to quadratic runtime. For better runtime the vertex index needs to be stored separately and computed once before writing the facets. It can be stored, for example, in the vertex itself or in a hash-structure. See also Section <a class="el" href="index.html#PolyhedronFile">File I/O</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Polyhedron_2polyhedron_prog_off_8cpp-example.html">Polyhedron/polyhedron_prog_off.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>               Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                              Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>                   Polyhedron;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Facet_iterator                   Facet_iterator;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Halfedge_around_facet_circulator Halfedge_facet_circulator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Point_3 p( 0.0, 0.0, 0.0);</div><div class="line">    Point_3 q( 1.0, 0.0, 0.0);</div><div class="line">    Point_3 r( 0.0, 1.0, 0.0);</div><div class="line">    Point_3 s( 0.0, 0.0, 1.0);</div><div class="line"></div><div class="line">    Polyhedron P;</div><div class="line">    P.make_tetrahedron( p, q, r, s);</div><div class="line"></div><div class="line">    <span class="comment">// Write polyhedron in Object File Format (OFF).</span></div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#ga62462cf829e614f6f2cd2cbec9a093d2">CGAL::set_ascii_mode</a>( std::cout);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"OFF"</span> &lt;&lt; std::endl &lt;&lt; P.size_of_vertices() &lt;&lt; <span class="charliteral">' '</span></div><div class="line">              &lt;&lt; P.size_of_facets() &lt;&lt; <span class="stringliteral">" 0"</span> &lt;&lt; std::endl;</div><div class="line">    std::copy( P.points_begin(), P.points_end(),</div><div class="line">               std::ostream_iterator&lt;Point_3&gt;( std::cout, <span class="stringliteral">"\n"</span>));</div><div class="line">    <span class="keywordflow">for</span> (  Facet_iterator i = P.facets_begin(); i != P.facets_end(); ++i) {</div><div class="line">        Halfedge_facet_circulator j = i-&gt;facet_begin();</div><div class="line">        <span class="comment">// Facets in polyhedral surfaces are at least triangles.</span></div><div class="line">        CGAL_assertion( <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/group__PkgHandlesAndCirculatorsFunctions.html#ga2d7bfa21e8eb046b8ae90104aa4fcce4">CGAL::circulator_size</a>(j) &gt;= 3);</div><div class="line">        std::cout &lt;&lt; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/group__PkgHandlesAndCirculatorsFunctions.html#ga2d7bfa21e8eb046b8ae90104aa4fcce4">CGAL::circulator_size</a>(j) &lt;&lt; <span class="charliteral">' '</span>;</div><div class="line">        <span class="keywordflow">do</span> {</div><div class="line">            std::cout &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; std::distance(P.vertices_begin(), j-&gt;vertex());</div><div class="line">        } <span class="keywordflow">while</span> ( ++j != i-&gt;facet_begin());</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="PolyhedronExampleUsingEulerOperatorstoBuild"></a>
Example Using Euler Operators to Build a Cube</h2>
<p>Euler operators are the natural way of modifying polyhedral surfaces. We provide a set of operations for polyhedra: <a class="el" href="classCGAL_1_1Polyhedron__3.html#a3ef41ae6c3be7f0894479f3dd4fe34d5">split_facet()</a>, <a class="el" href="classCGAL_1_1Polyhedron__3.html#a4f3e7c4e0800462026443a7ad0ca6db8"><code>join_facet()</code></a>, <a class="el" href="classCGAL_1_1Polyhedron__3.html#a2b17d7bd2045397167b00616f3b4d622"><code>split_vertex()</code></a>, <a class="el" href="classCGAL_1_1Polyhedron__3.html#a8edb13d0fb5748b20a8173bec85e7243"><code>join_vertex()</code></a>, <a class="el" href="classCGAL_1_1Polyhedron__3.html#a375a1b49bc6ad2ad5c578d7a7c45e4f5"><code>split_loop()</code></a>, and <a class="el" href="classCGAL_1_1Polyhedron__3.html#ad5a29fe94196629193da3c95e5eba5e9"><code>join_loop()</code></a>. We add further convenient operators, such as <a class="el" href="classCGAL_1_1Polyhedron__3.html#ab3269baf4b4c6ce61b86545b8fa360d2"><code>split_edge()</code></a>. However, they could be implemented using the six operators above. Furthermore, we provide more operators to work with polyhedral surfaces with border edges, for example, creating and deleting holes. We refer to the references manual for the definition and illustrative figures of the Euler operators.</p>
<p>The following example implements a function that appends a unit cube to a polyhedral surface. To keep track of the different steps during the creation of the cube a sequence of sketches might help with labels for the different handles that occur in the program code. The following Figure shows six selected steps from the creation sequence. These steps are also marked in the program code.</p>
<div class="image">
<img src="make_cube.png" alt="make_cube.png" />
</div>
 <p><br />
<b>File</b> <a class="el" href="Polyhedron_2polyhedron_prog_cube_8cpp-example.html">Polyhedron/polyhedron_prog_cube.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Poly&gt;</div><div class="line"><span class="keyword">typename</span> Poly::Halfedge_handle make_cube_3( Poly&amp; P) {</div><div class="line">    <span class="comment">// appends a cube of size [0,1]^3 to the polyhedron P.</span></div><div class="line">    CGAL_precondition( P.is_valid());</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Poly::Point_3         Point;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Poly::Halfedge_handle Halfedge_handle;</div><div class="line">    Halfedge_handle h = P.make_tetrahedron( Point( 1, 0, 0),</div><div class="line">                                            Point( 0, 0, 1),</div><div class="line">                                            Point( 0, 0, 0),</div><div class="line">                                            Point( 0, 1, 0));</div><div class="line">    Halfedge_handle g = h-&gt;next()-&gt;opposite()-&gt;next();             <span class="comment">// Fig. (a)</span></div><div class="line">    P.split_edge( h-&gt;next());</div><div class="line">    P.split_edge( g-&gt;next());</div><div class="line">    P.split_edge( g);                                              <span class="comment">// Fig. (b)</span></div><div class="line">    h-&gt;next()-&gt;vertex()-&gt;point()     = Point( 1, 0, 1);</div><div class="line">    g-&gt;next()-&gt;vertex()-&gt;point()     = Point( 0, 1, 1);</div><div class="line">    g-&gt;opposite()-&gt;vertex()-&gt;point() = Point( 1, 1, 0);            <span class="comment">// Fig. (c)</span></div><div class="line">    Halfedge_handle f = P.split_facet( g-&gt;next(),</div><div class="line">                                       g-&gt;next()-&gt;next()-&gt;next()); <span class="comment">// Fig. (d)</span></div><div class="line">    Halfedge_handle e = P.split_edge( f);</div><div class="line">    e-&gt;vertex()-&gt;point() = Point( 1, 1, 1);                        <span class="comment">// Fig. (e)</span></div><div class="line">    P.split_facet( e, f-&gt;next()-&gt;next());                          <span class="comment">// Fig. (f)</span></div><div class="line">    CGAL_postcondition( P.is_valid());</div><div class="line">    <span class="keywordflow">return</span> h;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>     Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>         Polyhedron;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Halfedge_handle        Halfedge_handle;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Polyhedron P;</div><div class="line">    Halfedge_handle h = make_cube_3( P);</div><div class="line">    <span class="keywordflow">return</span> (P.is_tetrahedron(h) ? 1 : 0);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="PolyhedronDraw"></a>
Draw a Polyhedron</h2>
<p><a class="anchor" id="ssecDrawPolyhedron"></a> A polyhedron can be visualized by calling the <code><a class="el" href="group__PkgDrawPolyhedron.html#ga3ca458ed11c9fb052476b00227d93584" title="Open a new window and draw apoly, an instance of the CGAL::Polyhedron_3 class. ">CGAL::draw()</a></code> function as shown in the following example. This function opens a new window showing the given polyhedron. The function is blocking, that is the program continues as soon as the user closes the window.</p>
<p><br />
<b>File</b> <a class="el" href="Polyhedron_2draw_polyhedron_8cpp-example.html">Polyhedron/draw_polyhedron.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Polyhedron_iostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/draw_polyhedron.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>                       Polyhedron;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  Polyhedron P;</div><div class="line">  std::ifstream in1((argc&gt;1)?argv[1]:<span class="stringliteral">"data/cross.off"</span>);</div><div class="line">  in1 &gt;&gt; P;</div><div class="line">  <a class="code" href="group__PkgDrawPolyhedron.html#ga3ca458ed11c9fb052476b00227d93584">CGAL::draw</a>(P);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>This function requires CGAL_Qt5, and is only available if the flag CGAL_USE_BASIC_VIEWER is defined at compile time.</p>
<p><a class="anchor" id="fig__fig_draw_polyhedron"></a></p><div class="image">
<img src="draw_polyhedron.png" alt="draw_polyhedron.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_draw_polyhedron">Figure 25.1</a> Result of the run of the draw_polyhedron program. A window shows the polyhedron and allows to navigate through the 3D scene.  </div>  <br />

<h1><a class="anchor" id="PolyhedronFile"></a>
File I/O</h1>
<p><a class="anchor" id="sectionPolyIO"></a> Simple file I/O for polyhedral surfaces is already provided in the library. The file I/O considers so far only the topology of the surface and its point coordinates. It ignores a possible plane equation or any user-added attributes, such as color.</p>
<p>The default file format supported in <span style="font-variant: small-caps;">CGAL</span> for output as well as for input is the Object File Format, OFF, with file extension <code>.off</code>, which is also understood by Geomview <a class="el" href="citelist.html#CITEREF_cgal:p-gmgv16-96">[5]</a>. For OFF an ASCII and a binary format exist. The format can be selected with the <span style="font-variant: small-caps;">CGAL</span> modifiers for streams, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#ga62462cf829e614f6f2cd2cbec9a093d2">set_ascii_mode()</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#gaf8eb8599079dfa427e0f34098bcc790b">set_binary_mode()</a></code> respectively. The modifier <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#ga2f2176255429973ea7bf156804a53857">set_pretty_mode()</a></code> can be used to allow for (a few) structuring comments in the output. Otherwise, the output would be free of comments. The default for writing is ASCII without comments. Both, ASCII and binary format, can be read independent of the stream setting. Since this file format is the default format, iostream operators are provided for it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Polyhedron_iostream.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolyhedronTraits_3&gt;</div><div class="line">ostream&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamOperators.html#ga525f8afc1fb75eb966517c447f1968ea">operator&lt;&lt;</a>( ostream&amp; out, </div><div class="line"><span class="keyword">const</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</a>&amp; P);</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolyhedronTraits_3&gt;</div><div class="line">istream&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamOperators.html#gae89c813a0404eae7e0901ed8f3c92915">operator&gt;&gt;</a>( istream&amp; in, </div><div class="line"><a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</a>&amp; P);</div></div><!-- fragment --><p>Additional formats supported for writing are OpenInventor (<code>.iv</code>) <a class="el" href="citelist.html#CITEREF_cgal:w-impoo-94">[7]</a>, VRML 1.0 and 2.0 (<code>.wrl</code>) <a class="el" href="citelist.html#CITEREF_cgal:bpp-vrml-95">[1]</a>, <a class="el" href="citelist.html#CITEREF_cgal:vrmls-97">[6]</a>, <a class="el" href="citelist.html#CITEREF_cgal:hw-vrml2h-96">[2]</a>, and Wavefront Advanced Visualizer object format (<code>.obj</code>). Another convenient output function writes a polyhedral surface to a Geomview process spawned from the <span style="font-variant: small-caps;">CGAL</span> program. These output functions are provided as stream operators, now acting on the stream type of the respective format.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Polyhedron_inventor_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Polyhedron_VRML_1_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Polyhedron_VRML_2_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Polyhedron_geomview_ostream.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolyhedronTraits_3&gt;</div><div class="line">Inventor_ostream&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamOperators.html#ga525f8afc1fb75eb966517c447f1968ea">operator&lt;&lt;</a>( Inventor_ostream&amp; out, </div><div class="line"><span class="keyword">const</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</a>&amp; P);</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolyhedronTraits_3&gt;</div><div class="line">VRML_1_ostream&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamOperators.html#ga525f8afc1fb75eb966517c447f1968ea">operator&lt;&lt;</a>( VRML_1_ostream&amp; out, </div><div class="line"><span class="keyword">const</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</a>&amp; P);</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolyhedronTraits_3&gt;</div><div class="line">VRML_2_ostream&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamOperators.html#ga525f8afc1fb75eb966517c447f1968ea">operator&lt;&lt;</a>( VRML_2_ostream&amp; out, </div><div class="line"><span class="keyword">const</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</a>&amp; P);</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolyhedronTraits_3&gt;</div><div class="line">Geomview_stream&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamOperators.html#ga525f8afc1fb75eb966517c447f1968ea">operator&lt;&lt;</a>( Geomview_stream&amp; out, </div><div class="line"><span class="keyword">const</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</a>&amp; P);</div></div><!-- fragment --><p>All these file formats have in common that they represent a surface as a set of facets. Each facet is a list of indices pointing into a set of vertices. Vertices are represented as coordinate triples. The file I/O for polyhedral surfaces <code><a class="el" href="classCGAL_1_1Polyhedron__3.html" title="A polyhedral surface Polyhedron_3 consists of vertices V, edges E, facets F and an incidence relation...">Polyhedron_3</a></code> imposes certain restrictions on these formats. They must represent a permissible polyhedral surface, e.g., a 2-manifold and no isolated vertices, see Section <a class="el" href="index.html#sectionPolyIntro">Introduction</a>.</p>
<p>Some example programs around the different file formats are provided in the distribution under <code>examples/Polyhedron_IO/</code> and <code>demo/Polyhedron_IO/</code>. We show an example converting OFF input into VRML 1.0 output.</p>
<p><br />
<b>File</b> <a class="el" href="Polyhedron_IO_2polyhedron2vrml_8cpp-example.html">Polyhedron_IO/polyhedron2vrml.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Polyhedron_VRML_1_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>     Polyhedron;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Polyhedron P;</div><div class="line">    std::cin &gt;&gt; P;</div><div class="line">    CGAL::VRML_1_ostream out( std::cout);</div><div class="line">    out &lt;&lt; P;</div><div class="line">    <span class="keywordflow">return</span> ( std::cin &amp;&amp; std::cout) ? 0 : 1;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="PolyhedronExtending"></a>
Extending Vertices, Halfedges, and Facets</h1>
<p><a class="anchor" id="sectionPolyExtend"></a> In Section <a class="el" href="index.html#sectionPolyVector">Example with a Vector Instead of a List Representation</a> we have seen how to change the default list representation</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3</a>&lt; Traits, </div><div class="line">CGAL::Polyhedron_items_3, </div><div class="line"><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classCGAL_1_1HalfedgeDS__default.html">CGAL::HalfedgeDS_default</a>&gt; Polyhedron;</div></div><!-- fragment --><p>to a vector based representation of the underlying halfedge data structure. Now we want to look a bit closer at the second template argument, <code><a class="el" href="classCGAL_1_1Polyhedron__items__3.html" title="The class Polyhedron_items_3 is a model of the PolyhedronItems_3 concept. ">Polyhedron_items_3</a></code>, that specifies what kind of vertex, halfedge, and facet is used. The implementation of <code><a class="el" href="classCGAL_1_1Polyhedron__items__3.html" title="The class Polyhedron_items_3 is a model of the PolyhedronItems_3 concept. ">Polyhedron_items_3</a></code> looks a bit involved with nested wrapper class templates. But ignoring this technicality, what remains are three local typedefs that define the <code>Vertex</code>, the <code>Halfedge</code>, and the <code>Face</code> for the polyhedral surface. Note that we use here <code>Face</code> instead of facet. Face is the term used for the halfedge data structure. Only the top layer of the polyhedral surface gives alias names renaming face to facet.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Polyhedron_items_3 {</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> Refs, <span class="keyword">class</span> Traits&gt;</div><div class="line"><span class="keyword">struct </span>Vertex_wrapper {</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::Point_3 <a class="code" href="classCGAL_1_1Polyhedron__items__3.html#a226909e49108b48c946e5e3a27bbd19a">Point</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classCGAL_1_1HalfedgeDS__vertex__base.html">CGAL::HalfedgeDS_vertex_base&lt;Refs, CGAL::Tag_true, Point&gt;</a> Vertex;</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> Refs, <span class="keyword">class</span> Traits&gt;</div><div class="line"><span class="keyword">struct </span>Halfedge_wrapper {</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classCGAL_1_1HalfedgeDS__halfedge__base.html">CGAL::HalfedgeDS_halfedge_base&lt;Refs&gt;</a> Halfedge;</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> Refs, <span class="keyword">class</span> Traits&gt;</div><div class="line"><span class="keyword">struct </span>Face_wrapper {</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::Plane_3 <a class="code" href="classCGAL_1_1Polyhedron__items__3.html#af54e6e98ef2970dba973e85425f06036">Plane</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classCGAL_1_1HalfedgeDS__face__base.html">CGAL::HalfedgeDS_face_base&lt;Refs, CGAL::Tag_true, Plane&gt;</a> Face;</div><div class="line">};</div><div class="line">};</div></div><!-- fragment --><p>If we look up in the reference manual the definitions of the three classes used in the typedefs, we will see the confirmation that the default polyhedron uses all supported incidences, a point in the vertex class, and a plane equation in the face class. Note how the wrapper class provides two template parameters, <code>Refs</code>, which we discuss a bit later, and <code>Traits</code>, which is the geometric traits class used by the polyhedral surface and which provides us here with the types for the point and the plane equation.</p>
<p>Using this example code we can write our own items class. Instead, we illustrate an easier way if we only want to exchange one class. We use a simpler face without the plane equation but with a color attribute added. To simplify the creation of a vertex, halfedge, or face class, it is always recommended to derive from one of the given base classes. Even if the base class would contain no data it would provide convenient type definitions. So, we derive from the base class, repeat the mandatory constructors if necessary - which is not the case for faces but would be for vertices - and add the color attribute.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Refs&gt;</div><div class="line"><span class="keyword">struct </span>My_face : <span class="keyword">public</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classCGAL_1_1HalfedgeDS__face__base.html">CGAL::HalfedgeDS_face_base</a>&lt;Refs&gt; {</div><div class="line"><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Color.html">CGAL::Color</a> color;</div><div class="line">};</div></div><!-- fragment --><p>The new items class is derived from the old items class and the wrapper containing the face typedef gets overridden. Note that the name of the wrapper and its template parameters are fixed. They cannot be changed even if, as in this example, a template parameter is not used.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>My_items : <span class="keyword">public</span> CGAL::Polyhedron_items_3 {</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Refs, <span class="keyword">class</span> Traits&gt;</div><div class="line"><span class="keyword">struct </span>Face_wrapper {</div><div class="line"><span class="keyword">typedef</span> My_face&lt;Refs&gt; Face;</div><div class="line">};</div><div class="line">};</div></div><!-- fragment --><p>When we use our new items class with the polyhedral surface, our new face class is used in the halfedge data structure and the color attribute is available in the type <code><a class="el" href="classCGAL_1_1Polyhedron__3_1_1Facet.html" title="A facet optionally stores a plane equation, and a reference to an incident halfedge that points to th...">Polyhedron_3::Facet</a></code>. However, <code><a class="el" href="classCGAL_1_1Polyhedron__3_1_1Facet.html" title="A facet optionally stores a plane equation, and a reference to an incident halfedge that points to th...">Polyhedron_3::Facet</a></code> is not the same type as our local face typedef for <code>My_face</code>, but it is derived therefrom. Thus, everything that we put in the local face type except constructors is then available in the <code>Polyhedron_::Facet</code> type. For more details, see the Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/index.html#chapterHalfedgeDS">Halfedge Data Structures</a> on the halfedge data structure design.</p>
<p>Pulling all pieces together, the full example program illustrates how easy the color attribute can be accessed once it is defined.</p>
<p><br />
<b>File</b> <a class="el" href="Polyhedron_2polyhedron_prog_color_8cpp-example.html">Polyhedron/polyhedron_prog_color.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Color.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// A face type with a color member variable.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Refs&gt;</div><div class="line"><span class="keyword">struct </span>My_face : <span class="keyword">public</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classCGAL_1_1HalfedgeDS__face__base.html">CGAL::HalfedgeDS_face_base</a>&lt;Refs&gt; {</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Color.html">CGAL::Color</a> color;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// An items type using my face.</span></div><div class="line"><span class="keyword">struct </span>My_items : <span class="keyword">public</span> CGAL::Polyhedron_items_3 {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Refs, <span class="keyword">class</span> Traits&gt;</div><div class="line">    <span class="keyword">struct </span>Face_wrapper {</div><div class="line">        <span class="keyword">typedef</span> My_face&lt;Refs&gt; Face;</div><div class="line">    };</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>        Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel, My_items&gt;</a>  Polyhedron;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Halfedge_handle           Halfedge_handle;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Polyhedron P;</div><div class="line">    Halfedge_handle h = P.<a class="code" href="classCGAL_1_1Polyhedron__3.html#a1ebc714bb6fc75a8aa105ffb241fe087">make_tetrahedron</a>();</div><div class="line">    h-&gt;facet()-&gt;color = CGAL::RED;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>We come back to the first template parameter, <code>Refs</code>, of the wrapper classes. This parameter provides us with local types that allow us to make further references between vertices, halfedges, and facets, which have not already been prepared for in the current design. These local types are <code><a class="el" href="classCGAL_1_1Polyhedron__3.html#aca51106e581d51d36bd668c819c0ac4e" title="handle to vertex. ">Polyhedron_3::Vertex_handle</a></code>, <code><a class="el" href="classCGAL_1_1Polyhedron__3.html#a5ea0a8e088c2e98a6f1312d32f0a4967" title="handle to halfedge. ">Polyhedron_3::Halfedge_handle</a></code>, <code><a class="el" href="classCGAL_1_1Polyhedron__3.html#ad44731fbb60766ae1ea8e46b69d3cbbf" title="handle to facet. ">Polyhedron_3::Facet_handle</a></code>, and there respective <code>.._const_handle</code>. We add now a new vertex reference to a face class as follows. Encapsulation and access functions could be added for a more thorough design, but we omit that here for the sake of brevity. The integration of the face class with the items class works as illustrated above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Refs&gt;</div><div class="line"><span class="keyword">struct </span>My_face : <span class="keyword">public</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classCGAL_1_1HalfedgeDS__face__base.html">CGAL::HalfedgeDS_face_base</a>&lt;Refs&gt; {</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Refs::Vertex_handle Vertex_handle;</div><div class="line">Vertex_handle vertex_ref;</div><div class="line">};</div></div><!-- fragment --><p>More advanced examples can be found in the Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/index.html#sectionHdsExamples">sectionHdsExamples</a> illustrating further the design of the halfedge data structure.</p>
<h1><a class="anchor" id="PolyhedronAdvanced"></a>
Advanced Example Programs</h1>
<p><a class="anchor" id="sectionPolyAdvanced"></a> </p>
<h2><a class="anchor" id="PolyhedronExampleCreatingaSubdivisionSurface"></a>
Example Creating a Subdivision Surface</h2>
<p>This program reads a polyhedral surface from the standard input and writes a refined polyhedral surface to the standard output. Input and output are in the Object File Format, OFF, with the common file extension <code>.off</code>, which is also understood by Geomview <a class="el" href="citelist.html#CITEREF_cgal:p-gmgv16-96">[5]</a>.</p>
<p>The refinement is a single step of the \( \sqrt{3}\)-scheme for creating a subdivision surface <a class="el" href="citelist.html#CITEREF_cgal:k-s-00">[4]</a>. Each step subdivides a facet into triangles around a new center vertex, smoothes the position of the old vertices, and flips the old edges. The program is organized along this outline. In each of these parts, the program efficiently uses the knowledge that the newly created vertices, edges, and facets have been added to the end of the sequences. The program needs additional processing memory only for the smoothing step of the old vertices.</p>
<div class="image">
<img src="subdiv_small.png" alt="subdiv_small.png" />
</div>
 <p>The above figure shows three example objects, each subdivided four times. The initial object for the left sequence is the closed surface of three unit cubes glued together to a corner. The example program shown here can handle only closed surfaces, but the extended example <code>examples/Polyhedron/polyhedron_prog_subdiv_with_boundary.cpp</code> handles surfaces with boundary. So, the middle sequence starts with the same surface where one of the facets has been removed. The boundary subdivides to a nice circle. The third sequence creates a sharp edge using a trick in the object presentation. The sharp edge is actually a hole whose vertex coordinates pinch the hole shut to form an edge. The example directory <code>examples/Polyhedron/</code> contains the OFF files used here.</p>
<p><br />
<b>File</b> <a class="el" href="Polyhedron_2polyhedron_prog_subdiv_8cpp-example.html">Polyhedron/polyhedron_prog_subdiv.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>                                     Vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>                           Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Polyhedron::Vertex                                   Vertex;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Vertex_iterator                          Vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Halfedge_handle                          Halfedge_handle;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Edge_iterator                            Edge_iterator;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Facet_iterator                           Facet_iterator;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Halfedge_around_vertex_const_circulator  HV_circulator;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::Halfedge_around_facet_circulator         HF_circulator;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> create_center_vertex( Polyhedron&amp; P, Facet_iterator f) {</div><div class="line">    Vector vec( 0.0, 0.0, 0.0);</div><div class="line">    std::size_t order = 0;</div><div class="line">    HF_circulator h = f-&gt;facet_begin();</div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">        vec = vec + ( h-&gt;vertex()-&gt;point() - <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>);</div><div class="line">        ++ order;</div><div class="line">    } <span class="keywordflow">while</span> ( ++h != f-&gt;facet_begin());</div><div class="line">    CGAL_assertion( order &gt;= 3); <span class="comment">// guaranteed by definition of polyhedron</span></div><div class="line">    Point center =  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a> + (vec / <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(order));</div><div class="line">    Halfedge_handle new_center = P.create_center_vertex( f-&gt;halfedge());</div><div class="line">    new_center-&gt;vertex()-&gt;point() = center;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Smooth_old_vertex {</div><div class="line">    Point operator()( <span class="keyword">const</span> Vertex&amp; v)<span class="keyword"> const </span>{</div><div class="line">        CGAL_precondition((<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/group__PkgHandlesAndCirculatorsFunctions.html#ga2d7bfa21e8eb046b8ae90104aa4fcce4">CGAL::circulator_size</a>( v.vertex_begin()) &amp; 1) == 0);</div><div class="line">        std::size_t degree = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/group__PkgHandlesAndCirculatorsFunctions.html#ga2d7bfa21e8eb046b8ae90104aa4fcce4">CGAL::circulator_size</a>( v.vertex_begin()) / 2;</div><div class="line">        <span class="keywordtype">double</span> alpha = ( 4.0 - 2.0 * std::cos( 2.0 * CGAL_PI / degree)) / 9.0;</div><div class="line">        Vector vec = (v.point() - <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>) * ( 1.0 - alpha);</div><div class="line">        HV_circulator h = v.vertex_begin();</div><div class="line">        <span class="keywordflow">do</span> {</div><div class="line">            vec = vec + ( h-&gt;opposite()-&gt;vertex()-&gt;point() - <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>)</div><div class="line">              * alpha / static_cast&lt;double&gt;(degree);</div><div class="line">            ++ h;</div><div class="line">            CGAL_assertion( h != v.vertex_begin()); <span class="comment">// even degree guaranteed</span></div><div class="line">            ++ h;</div><div class="line">        } <span class="keywordflow">while</span> ( h != v.vertex_begin());</div><div class="line">        <span class="keywordflow">return</span> (<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a> + vec);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga174af506cebf3def60b56a3501843864">flip_edge</a>( Polyhedron&amp; P, Halfedge_handle e) {</div><div class="line">    Halfedge_handle h = e-&gt;next();</div><div class="line">    P.join_facet( e);</div><div class="line">    P.split_facet( h, h-&gt;next()-&gt;next());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> subdiv( Polyhedron&amp; P) {</div><div class="line">    <span class="keywordflow">if</span> ( P.size_of_facets() == 0)</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    <span class="comment">// We use that new vertices/halfedges/facets are appended at the end.</span></div><div class="line">    std::size_t nv = P.size_of_vertices();</div><div class="line">    Vertex_iterator last_v = P.vertices_end();</div><div class="line">    -- last_v;  <span class="comment">// the last of the old vertices</span></div><div class="line">    Edge_iterator last_e = P.edges_end();</div><div class="line">    -- last_e;  <span class="comment">// the last of the old edges</span></div><div class="line">    Facet_iterator last_f = P.facets_end();</div><div class="line">    -- last_f;  <span class="comment">// the last of the old facets</span></div><div class="line"></div><div class="line">    Facet_iterator f = P.facets_begin();    <span class="comment">// create new center vertices</span></div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">        create_center_vertex( P, f);</div><div class="line">    } <span class="keywordflow">while</span> ( f++ != last_f);</div><div class="line"></div><div class="line">    std::vector&lt;Point&gt; pts;                    <span class="comment">// smooth the old vertices</span></div><div class="line">    pts.reserve( nv);  <span class="comment">// get intermediate space for the new points</span></div><div class="line">    ++ last_v; <span class="comment">// make it the past-the-end position again</span></div><div class="line">    std::transform( P.vertices_begin(), last_v, std::back_inserter( pts),</div><div class="line">                    Smooth_old_vertex());</div><div class="line">    std::copy( pts.begin(), pts.end(), P.points_begin());</div><div class="line"></div><div class="line">    Edge_iterator e = P.edges_begin();              <span class="comment">// flip the old edges</span></div><div class="line">    ++ last_e; <span class="comment">// make it the past-the-end position again</span></div><div class="line">    <span class="keywordflow">while</span> ( e != last_e) {</div><div class="line">        Halfedge_handle h = e;</div><div class="line">        ++e; <span class="comment">// careful, incr. before flip since flip destroys current edge</span></div><div class="line">        <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga174af506cebf3def60b56a3501843864">flip_edge</a>( P, h);</div><div class="line">    };</div><div class="line">    CGAL_postcondition( P.is_valid());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line">    Polyhedron P;</div><div class="line">    std::ifstream in1((argc&gt;1)?argv[1]:<span class="stringliteral">"data/cube.off"</span>);</div><div class="line">    in1 &gt;&gt; P;</div><div class="line">    P.normalize_border();</div><div class="line">    <span class="keywordflow">if</span> ( P.size_of_border_edges() != 0) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"The input object has border edges. Cannot subdivide."</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">        std::exit(1);</div><div class="line">    }</div><div class="line">    subdiv( P);</div><div class="line">    std::cout &lt;&lt; P;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="PolyhedronExampleUsingtheIncrementalBuilder"></a>
Example Using the Incremental Builder and Modifier Mechanism</h2>
<p>A utility class <code><a class="el" href="classCGAL_1_1Polyhedron__incremental__builder__3.html" title="The auxiliary class Polyhedron_incremental_builder_3 supports the incremental construction of polyhed...">Polyhedron_incremental_builder_3</a></code> helps in creating polyhedral surfaces from a list of points followed by a list of facets that are represented as indices into the point list. This is particularly useful for implementing file reader for common file formats. It is used here to create a triangle.</p>
<p>A modifier mechanism allows to access the internal representation of the polyhedral surface, i.e., the halfedge data structure, in a controlled manner. A modifier is basically a callback mechanism using a function object. When called, the function object receives the internal halfedge data structure as a parameter and can modify it. On return, the polyhedron can check the halfedge data structure for validity. Such a modifier object must always return with a halfedge data structure that is a valid polyhedral surface. The validity check is implemented as an expensive postcondition at the end of the <code><a class="el" href="classCGAL_1_1Polyhedron__3.html#a7d5683b471d99bff3d73a467688151c5" title="This is an advanced function. ">Polyhedron_3::delegate()</a></code> member function, i.e., it is not called by default, only when expensive checks are activated.</p>
<p>In this example, <code>Build_triangle</code> is such a function object derived from <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Miscellany.tag:../Miscellany/" href="../Miscellany/classCGAL_1_1Modifier__base.html">Modifier_base</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classHalfedgeDS.html">HalfedgeDS</a>&gt;</code>. The <code><a class="el" href="classCGAL_1_1Polyhedron__3.html#a7d5683b471d99bff3d73a467688151c5" title="This is an advanced function. ">Polyhedron_3::delegate()</a></code> member function of the polyhedron accepts this function object and calls its <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Miscellany.tag:../Miscellany/" href="../Miscellany/classCGAL_1_1Modifier__base.html#a08a0a229b834229b3d35c8fb122cb488">Modifier_base::operator()()</a></code> with a reference to its internally used halfedge data structure. Thus, this member function in <code>Build_triangle</code> can create the triangle in the halfedge data structure.</p>
<p><br />
<b>File</b> <a class="el" href="Polyhedron_2polyhedron_prog_incr_builder_8cpp-example.html">Polyhedron/polyhedron_prog_incr_builder.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_incremental_builder_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// A modifier creating a triangle with the incremental builder.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> HDS&gt;</div><div class="line"><span class="keyword">class </span>Build_triangle : <span class="keyword">public</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Miscellany.tag:../Miscellany/" href="../Miscellany/classCGAL_1_1Modifier__base.html">CGAL::Modifier_base</a>&lt;HDS&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Build_triangle() {}</div><div class="line">    <span class="keywordtype">void</span> operator()( HDS&amp; hds) {</div><div class="line">        <span class="comment">// Postcondition: hds is a valid polyhedral surface.</span></div><div class="line">        <a class="code" href="classCGAL_1_1Polyhedron__incremental__builder__3.html">CGAL::Polyhedron_incremental_builder_3&lt;HDS&gt;</a> B( hds, <span class="keyword">true</span>);</div><div class="line">        B.begin_surface( 3, 1, 6);</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> HDS::Vertex   Vertex;</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Vertex::Point Point;</div><div class="line">        B.add_vertex( Point( 0, 0, 0));</div><div class="line">        B.add_vertex( Point( 1, 0, 0));</div><div class="line">        B.add_vertex( Point( 0, 1, 0));</div><div class="line">        B.begin_facet();</div><div class="line">        B.add_vertex_to_facet( 0);</div><div class="line">        B.add_vertex_to_facet( 1);</div><div class="line">        B.add_vertex_to_facet( 2);</div><div class="line">        B.end_facet();</div><div class="line">        B.end_surface();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>     Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>         Polyhedron;</div><div class="line"><span class="keyword">typedef</span> Polyhedron::HalfedgeDS             HalfedgeDS;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Polyhedron P;</div><div class="line">    Build_triangle&lt;HalfedgeDS&gt; triangle;</div><div class="line">    P.delegate( triangle);</div><div class="line">    CGAL_assertion( P.is_triangle( P.halfedges_begin()));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:01 for CGAL 4.13 - 3D Polyhedral Surface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
