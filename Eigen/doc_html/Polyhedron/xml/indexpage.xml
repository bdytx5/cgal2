<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_3D_Polyhedral_Surfaces"/><anchor id="index_1chapterPolyhedron"/> <simplesect kind="author"><para>Lutz Kettner </para></simplesect>
</para><sect1 id="index_1sectionPolyIntro">
<title>Introduction</title>
<para>Polyhedral surfaces in three dimensions are composed of vertices, edges, facets and an incidence relationship on them. The organization beneath is a halfedge data structure, which restricts the class of representable surfaces to orientable 2-manifolds - with and without boundary. If the surface is closed we call it a <emphasis>polyhedron</emphasis>, for example, see the following model of a hammerhead:</para><para><image type="html" name="shark.png"></image>
 <image type="latex" name="shark.png"></image>
</para><para>The polyhedral surface is realized as a container class that manages vertices, halfedges, facets with their incidences, and that maintains the combinatorial integrity of them. It is based on the highly flexible design of the halfedge data structure, see the introduction in Chapter <ref refid="index_1chapterHalfedgeDS" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">Halfedge Data Structures</ref> and <ref refid="citelist_1CITEREF_k-ugpdd-99" kindref="member">[3]</ref>. However, the polyhedral surface can be used and understood without knowing the underlying design. Some of the examples in this chapter introduce also gradually into first applications of this flexibility.</para></sect1>
<sect1 id="index_1PolyhedronDefinition">
<title>Definition</title>
<para>A polyhedral surface <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">Polyhedron_3</ref>&lt;<ref refid="classPolyhedronTraits__3" kindref="compound">PolyhedronTraits_3</ref>&gt;</computeroutput> in three dimensions consists of vertices <computeroutput>V</computeroutput>, edges <computeroutput>E</computeroutput>, facets <computeroutput>F</computeroutput> and an incidence relation on them. Each edge is represented by two halfedges with opposite orientations. The incidences stored with a halfedge are illustrated in the following figure:</para><para><image type="html" name="halfedge_small.png"></image>
 <image type="latex" name="halfedge_small.png"></image>
</para><para>Vertices represent points in space. Edges are straight line segments between two endpoints. Facets are planar polygons without holes. Facets are defined by the circular sequence of halfedges along their boundary. The polyhedral surface itself can have holes (with at least two facets surrounding it since a single facet cannot have a hole). The halfedges along the boundary of a hole are called <emphasis>border halfedges</emphasis> and have no incident facet. An edge is a <emphasis>border edge</emphasis> if one of its halfedges is a border halfedge. A surface is <emphasis>closed</emphasis> if it contains no border halfedges. A closed surface is a boundary representation for polyhedra in three dimensions. The convention is that the halfedges are oriented counterclockwise around facets as seen from the outside of the polyhedron. An implication is that the halfedges are oriented clockwise around the vertices. The notion of the solid side of a facet as defined by the halfedge orientation extends to polyhedral surfaces with border edges although they do not define a closed object. If normal vectors are considered for the facets, normals point outwards (following the right-hand rule).</para><para>The strict definition can be found in <ref refid="citelist_1CITEREF_k-ugpdd-99" kindref="member">[3]</ref>. One implication of this definition is that the polyhedral surface is always an orientable and oriented 2-manifold with border edges, i.e., the neighborhood of each point on the polyhedral surface is either homeomorphic to a disc or to a half disc, except for vertices where many holes and surfaces with boundary can join. Another implication is that the smallest representable surface avoiding self intersections is a triangle (for polyhedral surfaces with border edges) or a tetrahedron (for polyhedra). Boundary representations of orientable 2-manifolds are closed under Euler operations. They are extended with operations that create or close holes in the surface.</para><para>Other intersections besides the incidence relation are not allowed. However, this is not automatically verified in the operations, since self intersections are not easy to check efficiently. <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">Polyhedron_3</ref>&lt;<ref refid="classPolyhedronTraits__3" kindref="compound">PolyhedronTraits_3</ref>&gt;</computeroutput> does only maintain the combinatorial integrity of the polyhedral surface (using Euler operations) and does not consider the coordinates of the points or any other geometric information.</para><para><computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">Polyhedron_3</ref>&lt;<ref refid="classPolyhedronTraits__3" kindref="compound">PolyhedronTraits_3</ref>&gt;</computeroutput> can represent polyhedral surfaces as well as polyhedra. The interface is designed in such a way that it is easy to ignore border edges and work only with polyhedra.</para></sect1>
<sect1 id="index_1PolyhedronExample">
<title>Example Programs</title>
<para><anchor id="index_1sectionPolyExamples"/> The polyhedral surface is based on the highly flexible design of the halfedge data structure. Examples for this flexibility can be found in Section <ref refid="index_1PolyhedronExtending" kindref="member">Extending Vertices, Halfedges, and Facets</ref> and in Section <ref refid="index_1HalfedgeDSExample" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">Examples</ref> of the chapter on the halfedge data structure. This design is not a prerequisite to understand the following examples. See also the Section <ref refid="index_1sectionPolyAdvanced" kindref="member">sectionPolyAdvanced</ref> below for some advanced examples.</para><sect2 id="index_1PolyhedronFirstExampleUsingDefaults">
<title>First Example Using Defaults</title>
<para>The first example instantiates a polyhedron using a kernel as traits class. It creates a tetrahedron and stores the reference to one of its halfedges in a <computeroutput>Halfedge_handle</computeroutput>. Handles, also know as <emphasis>trivial iterators</emphasis>, are used to keep references to halfedges, vertices, or facets for future use. There is also a <computeroutput>Halfedge_iterator</computeroutput> type for enumerating halfedges. Such an iterator type can be used wherever a handle is required. Respective <computeroutput>Halfedge_const_handle</computeroutput> and <computeroutput>Halfedge_const_iterator</computeroutput> for a constant polyhedron and similar handles and iterators with <computeroutput>Vertex_</computeroutput> and <computeroutput>Facet_</computeroutput> prefix are provided too.</para><para>The example continues with a test if the halfedge actually refers to a tetrahedron. This test checks the connected component referred to by the halfedge <computeroutput>h</computeroutput> and not the polyhedral surface as a whole. This examples works only on the combinatorial level of a polyhedral surface. The next example adds the geometry.</para><para><linebreak/>
<bold>File</bold> <ref refid="Polyhedron_2polyhedron_prog_simple_8cpp-example" kindref="compound">Polyhedron/polyhedron_prog_simple.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Halfedge_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>h<sp/>=<sp/>P.<ref refid="classCGAL_1_1Polyhedron__3_1a1ebc714bb6fc75a8aa105ffb241fe087" kindref="member">make_tetrahedron</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>P.is_tetrahedron(h))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1PolyhedronExamplewithGeometryinVertices">
<title>Example with Geometry in Vertices</title>
<para>We add geometry to the our construction of a tetrahedron. Four points are passed as arguments to the construction. This example demonstrates in addition the use of the vertex iterator and the access to the point in the vertices. Note the natural access notation <computeroutput>v-&gt;</computeroutput><ref refid="classCGAL_1_1Polyhedron__3_1_1Vertex_1ab130d4d8841cd8baa500e165ddd5e21a" kindref="member"><computeroutput>point()</computeroutput></ref>. Similarly, all information stored in a vertex, halfedge, and facet can be accessed with a member function given a handle or iterator. For example, given a halfedge handle <computeroutput>h</computeroutput> we can write <computeroutput>h-&gt;</computeroutput><ref refid="classCGAL_1_1Polyhedron__3_1_1Halfedge_1a3e7b0ca74b69a5868b430f958666df27" kindref="member"><computeroutput>next()</computeroutput></ref> to get a halfedge handle to the next halfedge, <computeroutput>h-&gt;</computeroutput><ref refid="classCGAL_1_1Polyhedron__3_1_1Halfedge_1a6f1d84341f035c8ed72ef53281173fb4" kindref="member"><computeroutput>opposite()</computeroutput></ref> for the opposite halfedge, <computeroutput>h-&gt;</computeroutput><ref refid="classCGAL_1_1Polyhedron__3_1_1Halfedge_1a5d4131be8dac43edcb5f7376d2d125bd" kindref="member"><computeroutput>vertex()</computeroutput></ref> for the incident vertex at the tip of <computeroutput>h</computeroutput>, and so on. The output of the program will be</para><para><verbatim>1 0 0
0 1 0
0 0 1
0 0 0
</verbatim></para><para><linebreak/>
<bold>File</bold> <ref refid="Polyhedron_2polyhedron_prog_tetra_8cpp-example" kindref="compound">Polyhedron/polyhedron_prog_tetra.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Vertex_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>p(<sp/>1.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>q(<sp/>0.0,<sp/>1.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>r(<sp/>0.0,<sp/>0.0,<sp/>1.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>s(<sp/>0.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.make_tetrahedron(<sp/>p,<sp/>q,<sp/>r,<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgIOstreams_1ga62462cf829e614f6f2cd2cbec9a093d2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_ascii_mode</ref>(<sp/>std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/>Vertex_iterator<sp/>v<sp/>=<sp/>P.vertices_begin();<sp/>v<sp/>!=<sp/>P.vertices_end();<sp/>++v)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>v-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The polyhedron offers a point iterator for convenience. The above <computeroutput>for</computeroutput> loop simplifies to a single statement by using <computeroutput>std::copy</computeroutput> and the ostream iterator adaptor.</para><para><programlisting><codeline><highlight class="normal">std::copy(<sp/>P.points_begin(),<sp/>P.points_end(),<sp/></highlight></codeline>
<codeline><highlight class="normal">std::ostream_iterator&lt;Point_3&gt;(std::cout,</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">));</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1PolyhedronExampleforAffineTransformation">
<title>Example for Affine Transformation</title>
<para>An affine transformation <computeroutput>A</computeroutput> can act as a functor transforming points and a point iterator is conveniently defined for polyhedral surfaces. So, assuming we want only the point coordinates of a polyhedron <computeroutput>P</computeroutput> transformed, <computeroutput>std::transform</computeroutput> does the job in a single line.</para><para><programlisting><codeline><highlight class="normal">std::transform(<sp/>P.points_begin(),<sp/>P.points_end(),<sp/>P.points_begin(),<sp/>A);</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1PolyhedronExampleComputingPlaneEquations">
<title>Example Computing Plane Equations</title>
<para>The polyhedral surface has already provisions to store a plane equation for each facet. However, it does not provide a function to compute plane equations.</para><para>This example computes the plane equations of a polyhedral surface. The actual computation is implemented in the <computeroutput>Plane_equation</computeroutput> functor. Depending on the arithmetic (exact/inexact) and the shape of the facets (convex/non-convex) different methods are useful. We assume here strictly convex facets and exact arithmetic. In our example a homogeneous representation with <computeroutput>int</computeroutput> coordinates is sufficient. The four plane equations of the tetrahedron are the output of the program.</para><para><linebreak/>
<bold>File</bold> <ref refid="Polyhedron_2polyhedron_prog_planes_8cpp-example" kindref="compound">Polyhedron/polyhedron_prog_planes.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Plane_equation<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Facet&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Facet::Plane_3<sp/>operator()(<sp/>Facet&amp;<sp/>f)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Facet::Halfedge_handle<sp/>h<sp/>=<sp/>f.halfedge();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Facet::Plane_3<sp/><sp/>Plane;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Plane(<sp/>h-&gt;vertex()-&gt;point(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h-&gt;next()-&gt;vertex()-&gt;point(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h-&gt;next()-&gt;next()-&gt;vertex()-&gt;point());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Homogeneous" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Homogeneous&lt;int&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Plane__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Plane_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Plane_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>p(<sp/>1,<sp/>0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>q(<sp/>0,<sp/>1,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>r(<sp/>0,<sp/>0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>s(<sp/>0,<sp/>0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.make_tetrahedron(<sp/>p,<sp/>q,<sp/>r,<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::transform(<sp/>P.facets_begin(),<sp/>P.facets_end(),<sp/>P.planes_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Plane_equation());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(<sp/>std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::copy(<sp/>P.planes_begin(),<sp/>P.planes_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ostream_iterator&lt;Plane_3&gt;(<sp/>std::cout,<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1sectionPolyVector">
<title>Example with a Vector Instead of a List Representation</title>
<para>The polyhedron class template has actually four parameters, where three of them have default values. Using the default values explicitly in our examples above for three parameter - ignoring the fourth parameter, which would be a standard allocator for container class - the definition of a polyhedron looks like:</para><para><programlisting><codeline><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3</ref>&lt;<sp/>Traits,<sp/></highlight></codeline>
<codeline><highlight class="normal">CGAL::Polyhedron_items_3,<sp/></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1HalfedgeDS__default" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">CGAL::HalfedgeDS_default</ref>&gt;<sp/>Polyhedron;</highlight></codeline>
</programlisting></para><para>The <computeroutput><ref refid="classCGAL_1_1Polyhedron__items__3" kindref="compound">Polyhedron_items_3</ref></computeroutput> class contains the types used for vertices, edges, and facets. The <computeroutput><ref refid="classCGAL_1_1HalfedgeDS__default" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">HalfedgeDS_default</ref></computeroutput> class defines the halfedge data structure used, which is a list-based representation in this case. An alternative is a vector-based representation. Using a vector provides random access for the elements in the polyhedral surface and is more space efficient, but elements cannot be deleted arbitrarily. Using a list allows arbitrary deletions, but provides only bidirectional iterators and is less space efficient. The following example creates again a tetrahedron with given points, but in a vector-based representation.</para><para>The vector-based representation resizes automatically if the reserved capacity is not sufficient for the new items created. Upon resizing all handles, iterators, and circulators become invalid. Their correct update in the halfedge data structure is costly, thus it is advisable to reserve enough space in advance as indicated with the alternative constructor in the comment.</para><para></para><para>Note that the polyhedron and not the underlying halfedge data structure triggers the resize operation, since the resize operation requires some preconditions, such as valid incidences, to be fulfilled that only the polyhedron can guarantee. </para><para><linebreak/>
<bold>File</bold> <ref refid="Polyhedron_2polyhedron_prog_vector_8cpp-example" kindref="compound">Polyhedron/polyhedron_prog_vector.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/HalfedgeDS_vector.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3</ref>&lt;<sp/>Kernel,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::Polyhedron_items_3,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1HalfedgeDS__vector" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">CGAL::HalfedgeDS_vector</ref>&gt;<sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>p(<sp/>1.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>q(<sp/>0.0,<sp/>1.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>r(<sp/>0.0,<sp/>0.0,<sp/>1.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>s(<sp/>0.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>P;<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>alternative<sp/>constructor:<sp/>Polyhedron<sp/>P(4,12,4);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.make_tetrahedron(<sp/>p,<sp/>q,<sp/>r,<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgIOstreams_1ga62462cf829e614f6f2cd2cbec9a093d2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_ascii_mode</ref>(<sp/>std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::copy(<sp/>P.points_begin(),<sp/>P.points_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ostream_iterator&lt;Point_3&gt;(<sp/>std::cout,<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1PolyhedronExamplewithCirculatorWritingObject">
<title>Example with Circulator Writing Object File Format (OFF)</title>
<para>We create a tetrahedron and write it to <computeroutput>std::cout</computeroutput> using the Object File Format (OFF) <ref refid="citelist_1CITEREF_cgal:p-gmgv16-96" kindref="member">[5]</ref>. This example makes use of STL algorithms (<computeroutput>std::copy</computeroutput>, <computeroutput>std::distance</computeroutput>), STL <computeroutput>std::ostream_iterator</computeroutput>, and CGAL circulators. The polyhedral surface provides convenient circulators for the counterclockwise circular sequence of halfedges around a facet and the clockwise circular sequence of halfedges around a vertex.</para><para>However, the computation of the vertex index in the inner loop of the facet output is not advisable with the <computeroutput>std::distance</computeroutput> function, since it takes linear time for non random-access iterators, which leads to quadratic runtime. For better runtime the vertex index needs to be stored separately and computed once before writing the facets. It can be stored, for example, in the vertex itself or in a hash-structure. See also Section <ref refid="index_1PolyhedronFile" kindref="member">File I/O</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Polyhedron_2polyhedron_prog_off_8cpp-example" kindref="compound">Polyhedron/polyhedron_prog_off.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Facet_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Facet_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Halfedge_around_facet_circulator<sp/>Halfedge_facet_circulator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>p(<sp/>0.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>q(<sp/>1.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>r(<sp/>0.0,<sp/>1.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_3<sp/>s(<sp/>0.0,<sp/>0.0,<sp/>1.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.make_tetrahedron(<sp/>p,<sp/>q,<sp/>r,<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>polyhedron<sp/>in<sp/>Object<sp/>File<sp/>Format<sp/>(OFF).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgIOstreams_1ga62462cf829e614f6f2cd2cbec9a093d2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_ascii_mode</ref>(<sp/>std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;OFF&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>P.size_of_vertices()<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>P.size_of_facets()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>0&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::copy(<sp/>P.points_begin(),<sp/>P.points_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ostream_iterator&lt;Point_3&gt;(<sp/>std::cout,<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/><sp/>Facet_iterator<sp/>i<sp/>=<sp/>P.facets_begin();<sp/>i<sp/>!=<sp/>P.facets_end();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_facet_circulator<sp/>j<sp/>=<sp/>i-&gt;facet_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Facets<sp/>in<sp/>polyhedral<sp/>surfaces<sp/>are<sp/>at<sp/>least<sp/>triangles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/><ref refid="group__PkgHandlesAndCirculatorsFunctions_1ga2d7bfa21e8eb046b8ae90104aa4fcce4" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circulator.tag">CGAL::circulator_size</ref>(j)<sp/>&gt;=<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/><ref refid="group__PkgHandlesAndCirculatorsFunctions_1ga2d7bfa21e8eb046b8ae90104aa4fcce4" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circulator.tag">CGAL::circulator_size</ref>(j)<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::distance(P.vertices_begin(),<sp/>j-&gt;vertex());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>++j<sp/>!=<sp/>i-&gt;facet_begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1PolyhedronExampleUsingEulerOperatorstoBuild">
<title>Example Using Euler Operators to Build a Cube</title>
<para>Euler operators are the natural way of modifying polyhedral surfaces. We provide a set of operations for polyhedra: <ref refid="classCGAL_1_1Polyhedron__3_1a3ef41ae6c3be7f0894479f3dd4fe34d5" kindref="member">split_facet()</ref>, <ref refid="classCGAL_1_1Polyhedron__3_1a4f3e7c4e0800462026443a7ad0ca6db8" kindref="member"><computeroutput>join_facet()</computeroutput></ref>, <ref refid="classCGAL_1_1Polyhedron__3_1a2b17d7bd2045397167b00616f3b4d622" kindref="member"><computeroutput>split_vertex()</computeroutput></ref>, <ref refid="classCGAL_1_1Polyhedron__3_1a8edb13d0fb5748b20a8173bec85e7243" kindref="member"><computeroutput>join_vertex()</computeroutput></ref>, <ref refid="classCGAL_1_1Polyhedron__3_1a375a1b49bc6ad2ad5c578d7a7c45e4f5" kindref="member"><computeroutput>split_loop()</computeroutput></ref>, and <ref refid="classCGAL_1_1Polyhedron__3_1ad5a29fe94196629193da3c95e5eba5e9" kindref="member"><computeroutput>join_loop()</computeroutput></ref>. We add further convenient operators, such as <ref refid="classCGAL_1_1Polyhedron__3_1ab3269baf4b4c6ce61b86545b8fa360d2" kindref="member"><computeroutput>split_edge()</computeroutput></ref>. However, they could be implemented using the six operators above. Furthermore, we provide more operators to work with polyhedral surfaces with border edges, for example, creating and deleting holes. We refer to the references manual for the definition and illustrative figures of the Euler operators.</para><para>The following example implements a function that appends a unit cube to a polyhedral surface. To keep track of the different steps during the creation of the cube a sequence of sketches might help with labels for the different handles that occur in the program code. The following Figure shows six selected steps from the creation sequence. These steps are also marked in the program code.</para><para><image type="html" name="make_cube.png"></image>
 <image type="latex" name="make_cube.png"></image>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Polyhedron_2polyhedron_prog_cube_8cpp-example" kindref="compound">Polyhedron/polyhedron_prog_cube.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Poly&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Poly::Halfedge_handle<sp/>make_cube_3(<sp/>Poly&amp;<sp/>P)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>appends<sp/>a<sp/>cube<sp/>of<sp/>size<sp/>[0,1]^3<sp/>to<sp/>the<sp/>polyhedron<sp/>P.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_precondition(<sp/>P.is_valid());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Poly::Point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Poly::Halfedge_handle<sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>h<sp/>=<sp/>P.make_tetrahedron(<sp/>Point(<sp/>1,<sp/>0,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(<sp/>0,<sp/>0,<sp/>1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(<sp/>0,<sp/>0,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(<sp/>0,<sp/>1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>g<sp/>=<sp/>h-&gt;next()-&gt;opposite()-&gt;next();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Fig.<sp/>(a)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.split_edge(<sp/>h-&gt;next());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.split_edge(<sp/>g-&gt;next());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.split_edge(<sp/>g);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Fig.<sp/>(b)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h-&gt;next()-&gt;vertex()-&gt;point()<sp/><sp/><sp/><sp/><sp/>=<sp/>Point(<sp/>1,<sp/>0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>g-&gt;next()-&gt;vertex()-&gt;point()<sp/><sp/><sp/><sp/><sp/>=<sp/>Point(<sp/>0,<sp/>1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>g-&gt;opposite()-&gt;vertex()-&gt;point()<sp/>=<sp/>Point(<sp/>1,<sp/>1,<sp/>0);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Fig.<sp/>(c)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>f<sp/>=<sp/>P.split_facet(<sp/>g-&gt;next(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>g-&gt;next()-&gt;next()-&gt;next());<sp/></highlight><highlight class="comment">//<sp/>Fig.<sp/>(d)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>e<sp/>=<sp/>P.split_edge(<sp/>f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>e-&gt;vertex()-&gt;point()<sp/>=<sp/>Point(<sp/>1,<sp/>1,<sp/>1);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Fig.<sp/>(e)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.split_facet(<sp/>e,<sp/>f-&gt;next()-&gt;next());<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Fig.<sp/>(f)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_postcondition(<sp/>P.is_valid());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>h;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Halfedge_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>h<sp/>=<sp/>make_cube_3(<sp/>P);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(P.is_tetrahedron(h)<sp/>?<sp/>1<sp/>:<sp/>0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1PolyhedronDraw">
<title>Draw a Polyhedron</title>
<para><anchor id="index_1ssecDrawPolyhedron"/> A polyhedron can be visualized by calling the <computeroutput><ref refid="group__PkgDrawPolyhedron_1ga3ca458ed11c9fb052476b00227d93584" kindref="member">CGAL::draw()</ref></computeroutput> function as shown in the following example. This function opens a new window showing the given polyhedron. The function is blocking, that is the program continues as soon as the user closes the window.</para><para><linebreak/>
<bold>File</bold> <ref refid="Polyhedron_2draw_polyhedron_8cpp-example" kindref="compound">Polyhedron/draw_polyhedron.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Polyhedron_iostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_polyhedron.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in1((argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/cross.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in1<sp/>&gt;&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgDrawPolyhedron_1ga3ca458ed11c9fb052476b00227d93584" kindref="member">CGAL::draw</ref>(P);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This function requires CGAL_Qt5, and is only available if the flag CGAL_USE_BASIC_VIEWER is defined at compile time.</para><para><anchor id="index_1fig__fig_draw_polyhedron"/><image type="html" name="draw_polyhedron.png"></image>
 <image type="latex" name="draw_polyhedron.png" width="15cm"></image>
  <ref refid="index_1fig__fig_draw_polyhedron" kindref="member">fig__fig_draw_polyhedron</ref> Result of the run of the draw_polyhedron program. A window shows the polyhedron and allows to navigate through the 3D scene.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1PolyhedronFile">
<title>File I/O</title>
<para><anchor id="index_1sectionPolyIO"/> Simple file I/O for polyhedral surfaces is already provided in the library. The file I/O considers so far only the topology of the surface and its point coordinates. It ignores a possible plane equation or any user-added attributes, such as color.</para><para>The default file format supported in CGAL for output as well as for input is the Object File Format, OFF, with file extension <computeroutput>.off</computeroutput>, which is also understood by Geomview <ref refid="citelist_1CITEREF_cgal:p-gmgv16-96" kindref="member">[5]</ref>. For OFF an ASCII and a binary format exist. The format can be selected with the CGAL modifiers for streams, <computeroutput><ref refid="group__PkgIOstreams_1ga62462cf829e614f6f2cd2cbec9a093d2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">set_ascii_mode()</ref></computeroutput> and <computeroutput><ref refid="group__PkgIOstreams_1gaf8eb8599079dfa427e0f34098bcc790b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">set_binary_mode()</ref></computeroutput> respectively. The modifier <computeroutput><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">set_pretty_mode()</ref></computeroutput> can be used to allow for (a few) structuring comments in the output. Otherwise, the output would be free of comments. The default for writing is ASCII without comments. Both, ASCII and binary format, can be read independent of the stream setting. Since this file format is the default format, iostream operators are provided for it.</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Polyhedron_iostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolyhedronTraits_3&gt;</highlight></codeline>
<codeline><highlight class="normal">ostream&amp;<sp/><ref refid="group__IOstreamOperators_1ga525f8afc1fb75eb966517c447f1968ea" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">operator&lt;&lt;</ref>(<sp/>ostream&amp;<sp/>out,<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</ref>&amp;<sp/>P);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolyhedronTraits_3&gt;</highlight></codeline>
<codeline><highlight class="normal">istream&amp;<sp/><ref refid="group__IOstreamOperators_1gae89c813a0404eae7e0901ed8f3c92915" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">operator&gt;&gt;</ref>(<sp/>istream&amp;<sp/>in,<sp/></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</ref>&amp;<sp/>P);</highlight></codeline>
</programlisting></para><para>Additional formats supported for writing are OpenInventor (<computeroutput>.iv</computeroutput>) <ref refid="citelist_1CITEREF_cgal:w-impoo-94" kindref="member">[7]</ref>, VRML 1.0 and 2.0 (<computeroutput>.wrl</computeroutput>) <ref refid="citelist_1CITEREF_cgal:bpp-vrml-95" kindref="member">[1]</ref>, <ref refid="citelist_1CITEREF_cgal:vrmls-97" kindref="member">[6]</ref>, <ref refid="citelist_1CITEREF_cgal:hw-vrml2h-96" kindref="member">[2]</ref>, and Wavefront Advanced Visualizer object format (<computeroutput>.obj</computeroutput>). Another convenient output function writes a polyhedral surface to a Geomview process spawned from the CGAL program. These output functions are provided as stream operators, now acting on the stream type of the respective format.</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Polyhedron_inventor_ostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Polyhedron_VRML_1_ostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Polyhedron_VRML_2_ostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Polyhedron_geomview_ostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolyhedronTraits_3&gt;</highlight></codeline>
<codeline><highlight class="normal">Inventor_ostream&amp;<sp/><ref refid="group__IOstreamOperators_1ga525f8afc1fb75eb966517c447f1968ea" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">operator&lt;&lt;</ref>(<sp/>Inventor_ostream&amp;<sp/>out,<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</ref>&amp;<sp/>P);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolyhedronTraits_3&gt;</highlight></codeline>
<codeline><highlight class="normal">VRML_1_ostream&amp;<sp/><ref refid="group__IOstreamOperators_1ga525f8afc1fb75eb966517c447f1968ea" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">operator&lt;&lt;</ref>(<sp/>VRML_1_ostream&amp;<sp/>out,<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</ref>&amp;<sp/>P);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolyhedronTraits_3&gt;</highlight></codeline>
<codeline><highlight class="normal">VRML_2_ostream&amp;<sp/><ref refid="group__IOstreamOperators_1ga525f8afc1fb75eb966517c447f1968ea" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">operator&lt;&lt;</ref>(<sp/>VRML_2_ostream&amp;<sp/>out,<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</ref>&amp;<sp/>P);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PolyhedronTraits_3&gt;</highlight></codeline>
<codeline><highlight class="normal">Geomview_stream&amp;<sp/><ref refid="group__IOstreamOperators_1ga525f8afc1fb75eb966517c447f1968ea" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">operator&lt;&lt;</ref>(<sp/>Geomview_stream&amp;<sp/>out,<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;</ref>&amp;<sp/>P);</highlight></codeline>
</programlisting></para><para>All these file formats have in common that they represent a surface as a set of facets. Each facet is a list of indices pointing into a set of vertices. Vertices are represented as coordinate triples. The file I/O for polyhedral surfaces <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">Polyhedron_3</ref></computeroutput> imposes certain restrictions on these formats. They must represent a permissible polyhedral surface, e.g., a 2-manifold and no isolated vertices, see Section <ref refid="index_1sectionPolyIntro" kindref="member">Introduction</ref>.</para><para>Some example programs around the different file formats are provided in the distribution under <computeroutput>examples/Polyhedron_IO/</computeroutput> and <computeroutput>demo/Polyhedron_IO/</computeroutput>. We show an example converting OFF input into VRML 1.0 output.</para><para><linebreak/>
<bold>File</bold> <ref refid="Polyhedron_IO_2polyhedron2vrml_8cpp-example" kindref="compound">Polyhedron_IO/polyhedron2vrml.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Polyhedron_VRML_1_ostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cin<sp/>&gt;&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::VRML_1_ostream<sp/>out(<sp/>std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<sp/>std::cin<sp/>&amp;&amp;<sp/>std::cout)<sp/>?<sp/>0<sp/>:<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1PolyhedronExtending">
<title>Extending Vertices, Halfedges, and Facets</title>
<para><anchor id="index_1sectionPolyExtend"/> In Section <ref refid="index_1sectionPolyVector" kindref="member">Example with a Vector Instead of a List Representation</ref> we have seen how to change the default list representation</para><para><programlisting><codeline><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3</ref>&lt;<sp/>Traits,<sp/></highlight></codeline>
<codeline><highlight class="normal">CGAL::Polyhedron_items_3,<sp/></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1HalfedgeDS__default" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">CGAL::HalfedgeDS_default</ref>&gt;<sp/>Polyhedron;</highlight></codeline>
</programlisting></para><para>to a vector based representation of the underlying halfedge data structure. Now we want to look a bit closer at the second template argument, <computeroutput><ref refid="classCGAL_1_1Polyhedron__items__3" kindref="compound">Polyhedron_items_3</ref></computeroutput>, that specifies what kind of vertex, halfedge, and facet is used. The implementation of <computeroutput><ref refid="classCGAL_1_1Polyhedron__items__3" kindref="compound">Polyhedron_items_3</ref></computeroutput> looks a bit involved with nested wrapper class templates. But ignoring this technicality, what remains are three local typedefs that define the <computeroutput>Vertex</computeroutput>, the <computeroutput>Halfedge</computeroutput>, and the <computeroutput>Face</computeroutput> for the polyhedral surface. Note that we use here <computeroutput>Face</computeroutput> instead of facet. Face is the term used for the halfedge data structure. Only the top layer of the polyhedral surface gives alias names renaming face to facet.</para><para><programlisting><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">Polyhedron_items_3<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Refs,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Traits&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Vertex_wrapper<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Traits::Point_3<sp/><ref refid="classCGAL_1_1Polyhedron__items__3_1a226909e49108b48c946e5e3a27bbd19a" kindref="member">Point</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1HalfedgeDS__vertex__base" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">CGAL::HalfedgeDS_vertex_base&lt;Refs, CGAL::Tag_true, Point&gt;</ref><sp/>Vertex;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Refs,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Traits&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Halfedge_wrapper<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1HalfedgeDS__halfedge__base" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">CGAL::HalfedgeDS_halfedge_base&lt;Refs&gt;</ref><sp/>Halfedge;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Refs,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Traits&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Face_wrapper<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Traits::Plane_3<sp/><ref refid="classCGAL_1_1Polyhedron__items__3_1af54e6e98ef2970dba973e85425f06036" kindref="member">Plane</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1HalfedgeDS__face__base" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">CGAL::HalfedgeDS_face_base&lt;Refs, CGAL::Tag_true, Plane&gt;</ref><sp/>Face;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>If we look up in the reference manual the definitions of the three classes used in the typedefs, we will see the confirmation that the default polyhedron uses all supported incidences, a point in the vertex class, and a plane equation in the face class. Note how the wrapper class provides two template parameters, <computeroutput>Refs</computeroutput>, which we discuss a bit later, and <computeroutput>Traits</computeroutput>, which is the geometric traits class used by the polyhedral surface and which provides us here with the types for the point and the plane equation.</para><para>Using this example code we can write our own items class. Instead, we illustrate an easier way if we only want to exchange one class. We use a simpler face without the plane equation but with a color attribute added. To simplify the creation of a vertex, halfedge, or face class, it is always recommended to derive from one of the given base classes. Even if the base class would contain no data it would provide convenient type definitions. So, we derive from the base class, repeat the mandatory constructors if necessary - which is not the case for faces but would be for vertices - and add the color attribute.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Refs&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">My_face<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1HalfedgeDS__face__base" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">CGAL::HalfedgeDS_face_base</ref>&lt;Refs&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Color" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::Color</ref><sp/>color;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>The new items class is derived from the old items class and the wrapper containing the face typedef gets overridden. Note that the name of the wrapper and its template parameters are fixed. They cannot be changed even if, as in this example, a template parameter is not used.</para><para><programlisting><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">My_items<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>CGAL::Polyhedron_items_3<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Refs,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Traits&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Face_wrapper<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>My_face&lt;Refs&gt;<sp/>Face;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>When we use our new items class with the polyhedral surface, our new face class is used in the halfedge data structure and the color attribute is available in the type <computeroutput><ref refid="classCGAL_1_1Polyhedron__3_1_1Facet" kindref="compound">Polyhedron_3::Facet</ref></computeroutput>. However, <computeroutput><ref refid="classCGAL_1_1Polyhedron__3_1_1Facet" kindref="compound">Polyhedron_3::Facet</ref></computeroutput> is not the same type as our local face typedef for <computeroutput>My_face</computeroutput>, but it is derived therefrom. Thus, everything that we put in the local face type except constructors is then available in the <computeroutput>Polyhedron_::Facet</computeroutput> type. For more details, see the Chapter <ref refid="index_1chapterHalfedgeDS" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">Halfedge Data Structures</ref> on the halfedge data structure design.</para><para>Pulling all pieces together, the full example program illustrates how easy the color attribute can be accessed once it is defined.</para><para><linebreak/>
<bold>File</bold> <ref refid="Polyhedron_2polyhedron_prog_color_8cpp-example" kindref="compound">Polyhedron/polyhedron_prog_color.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Color.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>face<sp/>type<sp/>with<sp/>a<sp/>color<sp/>member<sp/>variable.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Refs&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">My_face<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1HalfedgeDS__face__base" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">CGAL::HalfedgeDS_face_base</ref>&lt;Refs&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Color" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::Color</ref><sp/>color;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>An<sp/>items<sp/>type<sp/>using<sp/>my<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">My_items<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>CGAL::Polyhedron_items_3<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Refs,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Traits&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Face_wrapper<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>My_face&lt;Refs&gt;<sp/>Face;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;Kernel, My_items&gt;</ref><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Halfedge_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>h<sp/>=<sp/>P.<ref refid="classCGAL_1_1Polyhedron__3_1a1ebc714bb6fc75a8aa105ffb241fe087" kindref="member">make_tetrahedron</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h-&gt;facet()-&gt;color<sp/>=<sp/>CGAL::RED;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>We come back to the first template parameter, <computeroutput>Refs</computeroutput>, of the wrapper classes. This parameter provides us with local types that allow us to make further references between vertices, halfedges, and facets, which have not already been prepared for in the current design. These local types are <computeroutput><ref refid="classCGAL_1_1Polyhedron__3_1aca51106e581d51d36bd668c819c0ac4e" kindref="member">Polyhedron_3::Vertex_handle</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Polyhedron__3_1a5ea0a8e088c2e98a6f1312d32f0a4967" kindref="member">Polyhedron_3::Halfedge_handle</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Polyhedron__3_1ad44731fbb60766ae1ea8e46b69d3cbbf" kindref="member">Polyhedron_3::Facet_handle</ref></computeroutput>, and there respective <computeroutput>.._const_handle</computeroutput>. We add now a new vertex reference to a face class as follows. Encapsulation and access functions could be added for a more thorough design, but we omit that here for the sake of brevity. The integration of the face class with the items class works as illustrated above.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Refs&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">My_face<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1HalfedgeDS__face__base" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">CGAL::HalfedgeDS_face_base</ref>&lt;Refs&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Refs::Vertex_handle<sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal">Vertex_handle<sp/>vertex_ref;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>More advanced examples can be found in the Section <ref refid="index_1sectionHdsExamples" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">sectionHdsExamples</ref> illustrating further the design of the halfedge data structure.</para></sect1>
<sect1 id="index_1PolyhedronAdvanced">
<title>Advanced Example Programs</title>
<para><anchor id="index_1sectionPolyAdvanced"/> </para><sect2 id="index_1PolyhedronExampleCreatingaSubdivisionSurface">
<title>Example Creating a Subdivision Surface</title>
<para>This program reads a polyhedral surface from the standard input and writes a refined polyhedral surface to the standard output. Input and output are in the Object File Format, OFF, with the common file extension <computeroutput>.off</computeroutput>, which is also understood by Geomview <ref refid="citelist_1CITEREF_cgal:p-gmgv16-96" kindref="member">[5]</ref>.</para><para>The refinement is a single step of the <formula id="5">$ \sqrt{3}$</formula>-scheme for creating a subdivision surface <ref refid="citelist_1CITEREF_cgal:k-s-00" kindref="member">[4]</ref>. Each step subdivides a facet into triangles around a new center vertex, smoothes the position of the old vertices, and flips the old edges. The program is organized along this outline. In each of these parts, the program efficiently uses the knowledge that the newly created vertices, edges, and facets have been added to the end of the sequences. The program needs additional processing memory only for the smoothing step of the old vertices.</para><para><image type="html" name="subdiv_small.png"></image>
 <image type="latex" name="subdiv_small.png"></image>
</para><para>The above figure shows three example objects, each subdivided four times. The initial object for the left sequence is the closed surface of three unit cubes glued together to a corner. The example program shown here can handle only closed surfaces, but the extended example <computeroutput>examples/Polyhedron/polyhedron_prog_subdiv_with_boundary.cpp</computeroutput> handles surfaces with boundary. So, the middle sequence starts with the same surface where one of the facets has been removed. The boundary subdivides to a nice circle. The third sequence creates a sharp edge using a trick in the object presentation. The sharp edge is actually a hole whose vertex coordinates pinch the hole shut to form an edge. The example directory <computeroutput>examples/Polyhedron/</computeroutput> contains the OFF files used here.</para><para><linebreak/>
<bold>File</bold> <ref refid="Polyhedron_2polyhedron_prog_subdiv_8cpp-example" kindref="compound">Polyhedron/polyhedron_prog_subdiv.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cmath&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Vertex<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Vertex_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Halfedge_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Edge_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Edge_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Facet_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Facet_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Halfedge_around_vertex_const_circulator<sp/><sp/>HV_circulator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Halfedge_around_facet_circulator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HF_circulator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_center_vertex(<sp/>Polyhedron&amp;<sp/>P,<sp/>Facet_iterator<sp/>f)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vector<sp/>vec(<sp/>0.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::size_t<sp/>order<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>HF_circulator<sp/>h<sp/>=<sp/>f-&gt;facet_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vec<sp/>=<sp/>vec<sp/>+<sp/>(<sp/>h-&gt;vertex()-&gt;point()<sp/>-<sp/><ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ORIGIN</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++<sp/>order;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>++h<sp/>!=<sp/>f-&gt;facet_begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>order<sp/>&gt;=<sp/>3);<sp/></highlight><highlight class="comment">//<sp/>guaranteed<sp/>by<sp/>definition<sp/>of<sp/>polyhedron</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point<sp/>center<sp/>=<sp/><sp/><ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ORIGIN</ref><sp/>+<sp/>(vec<sp/>/<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">double</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(order));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>new_center<sp/>=<sp/>P.create_center_vertex(<sp/>f-&gt;halfedge());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>new_center-&gt;vertex()-&gt;point()<sp/>=<sp/>center;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Smooth_old_vertex<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point<sp/>operator()(<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Vertex&amp;<sp/>v)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL_precondition((<ref refid="group__PkgHandlesAndCirculatorsFunctions_1ga2d7bfa21e8eb046b8ae90104aa4fcce4" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circulator.tag">CGAL::circulator_size</ref>(<sp/>v.vertex_begin())<sp/>&amp;<sp/>1)<sp/>==<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::size_t<sp/>degree<sp/>=<sp/><ref refid="group__PkgHandlesAndCirculatorsFunctions_1ga2d7bfa21e8eb046b8ae90104aa4fcce4" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circulator.tag">CGAL::circulator_size</ref>(<sp/>v.vertex_begin())<sp/>/<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>alpha<sp/>=<sp/>(<sp/>4.0<sp/>-<sp/>2.0<sp/>*<sp/>std::cos(<sp/>2.0<sp/>*<sp/>CGAL_PI<sp/>/<sp/>degree))<sp/>/<sp/>9.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector<sp/>vec<sp/>=<sp/>(v.point()<sp/>-<sp/><ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ORIGIN</ref>)<sp/>*<sp/>(<sp/>1.0<sp/>-<sp/>alpha);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HV_circulator<sp/>h<sp/>=<sp/>v.vertex_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vec<sp/>=<sp/>vec<sp/>+<sp/>(<sp/>h-&gt;opposite()-&gt;vertex()-&gt;point()<sp/>-<sp/><ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ORIGIN</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>alpha<sp/>/<sp/>static_cast&lt;double&gt;(degree);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++<sp/>h;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>h<sp/>!=<sp/>v.vertex_begin());<sp/></highlight><highlight class="comment">//<sp/>even<sp/>degree<sp/>guaranteed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++<sp/>h;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>h<sp/>!=<sp/>v.vertex_begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ORIGIN</ref><sp/>+<sp/>vec);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgBGLEulerOperations_1ga174af506cebf3def60b56a3501843864" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">flip_edge</ref>(<sp/>Polyhedron&amp;<sp/>P,<sp/>Halfedge_handle<sp/>e)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>h<sp/>=<sp/>e-&gt;next();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.join_facet(<sp/>e);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.split_facet(<sp/>h,<sp/>h-&gt;next()-&gt;next());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>subdiv(<sp/>Polyhedron&amp;<sp/>P)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>P.size_of_facets()<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>that<sp/>new<sp/>vertices/halfedges/facets<sp/>are<sp/>appended<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::size_t<sp/>nv<sp/>=<sp/>P.size_of_vertices();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vertex_iterator<sp/>last_v<sp/>=<sp/>P.vertices_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>--<sp/>last_v;<sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>last<sp/>of<sp/>the<sp/>old<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Edge_iterator<sp/>last_e<sp/>=<sp/>P.edges_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>--<sp/>last_e;<sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>last<sp/>of<sp/>the<sp/>old<sp/>edges</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Facet_iterator<sp/>last_f<sp/>=<sp/>P.facets_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>--<sp/>last_f;<sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>last<sp/>of<sp/>the<sp/>old<sp/>facets</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Facet_iterator<sp/>f<sp/>=<sp/>P.facets_begin();<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>new<sp/>center<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>create_center_vertex(<sp/>P,<sp/>f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>f++<sp/>!=<sp/>last_f);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Point&gt;<sp/>pts;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>smooth<sp/>the<sp/>old<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pts.reserve(<sp/>nv);<sp/><sp/></highlight><highlight class="comment">//<sp/>get<sp/>intermediate<sp/>space<sp/>for<sp/>the<sp/>new<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++<sp/>last_v;<sp/></highlight><highlight class="comment">//<sp/>make<sp/>it<sp/>the<sp/>past-the-end<sp/>position<sp/>again</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::transform(<sp/>P.vertices_begin(),<sp/>last_v,<sp/>std::back_inserter(<sp/>pts),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Smooth_old_vertex());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::copy(<sp/>pts.begin(),<sp/>pts.end(),<sp/>P.points_begin());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Edge_iterator<sp/>e<sp/>=<sp/>P.edges_begin();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>flip<sp/>the<sp/>old<sp/>edges</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++<sp/>last_e;<sp/></highlight><highlight class="comment">//<sp/>make<sp/>it<sp/>the<sp/>past-the-end<sp/>position<sp/>again</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>e<sp/>!=<sp/>last_e)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>h<sp/>=<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++e;<sp/></highlight><highlight class="comment">//<sp/>careful,<sp/>incr.<sp/>before<sp/>flip<sp/>since<sp/>flip<sp/>destroys<sp/>current<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PkgBGLEulerOperations_1ga174af506cebf3def60b56a3501843864" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">flip_edge</ref>(<sp/>P,<sp/>h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_postcondition(<sp/>P.is_valid());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>in1((argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/cube.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in1<sp/>&gt;&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.normalize_border();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>P.size_of_border_edges()<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>input<sp/>object<sp/>has<sp/>border<sp/>edges.<sp/>Cannot<sp/>subdivide.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::exit(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subdiv(<sp/>P);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1PolyhedronExampleUsingtheIncrementalBuilder">
<title>Example Using the Incremental Builder and Modifier Mechanism</title>
<para>A utility class <computeroutput><ref refid="classCGAL_1_1Polyhedron__incremental__builder__3" kindref="compound">Polyhedron_incremental_builder_3</ref></computeroutput> helps in creating polyhedral surfaces from a list of points followed by a list of facets that are represented as indices into the point list. This is particularly useful for implementing file reader for common file formats. It is used here to create a triangle.</para><para>A modifier mechanism allows to access the internal representation of the polyhedral surface, i.e., the halfedge data structure, in a controlled manner. A modifier is basically a callback mechanism using a function object. When called, the function object receives the internal halfedge data structure as a parameter and can modify it. On return, the polyhedron can check the halfedge data structure for validity. Such a modifier object must always return with a halfedge data structure that is a valid polyhedral surface. The validity check is implemented as an expensive postcondition at the end of the <computeroutput><ref refid="classCGAL_1_1Polyhedron__3_1a7d5683b471d99bff3d73a467688151c5" kindref="member">Polyhedron_3::delegate()</ref></computeroutput> member function, i.e., it is not called by default, only when expensive checks are activated.</para><para>In this example, <computeroutput>Build_triangle</computeroutput> is such a function object derived from <computeroutput><ref refid="classCGAL_1_1Modifier__base" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Miscellany.tag">Modifier_base</ref>&lt;<ref refid="classHalfedgeDS" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/HalfedgeDS.tag">HalfedgeDS</ref>&gt;</computeroutput>. The <computeroutput><ref refid="classCGAL_1_1Polyhedron__3_1a7d5683b471d99bff3d73a467688151c5" kindref="member">Polyhedron_3::delegate()</ref></computeroutput> member function of the polyhedron accepts this function object and calls its <computeroutput><ref refid="classCGAL_1_1Modifier__base_1a08a0a229b834229b3d35c8fb122cb488" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Miscellany.tag">Modifier_base::operator()()</ref></computeroutput> with a reference to its internally used halfedge data structure. Thus, this member function in <computeroutput>Build_triangle</computeroutput> can create the triangle in the halfedge data structure.</para><para><linebreak/>
<bold>File</bold> <ref refid="Polyhedron_2polyhedron_prog_incr_builder_8cpp-example" kindref="compound">Polyhedron/polyhedron_prog_incr_builder.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_incremental_builder_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>modifier<sp/>creating<sp/>a<sp/>triangle<sp/>with<sp/>the<sp/>incremental<sp/>builder.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>HDS&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Build_triangle<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Modifier__base" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Miscellany.tag">CGAL::Modifier_base</ref>&lt;HDS&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Build_triangle()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(<sp/>HDS&amp;<sp/>hds)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Postcondition:<sp/>hds<sp/>is<sp/>a<sp/>valid<sp/>polyhedral<sp/>surface.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Polyhedron__incremental__builder__3" kindref="compound">CGAL::Polyhedron_incremental_builder_3&lt;HDS&gt;</ref><sp/>B(<sp/>hds,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B.begin_surface(<sp/>3,<sp/>1,<sp/>6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>HDS::Vertex<sp/><sp/><sp/>Vertex;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vertex::Point<sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B.add_vertex(<sp/>Point(<sp/>0,<sp/>0,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B.add_vertex(<sp/>Point(<sp/>1,<sp/>0,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B.add_vertex(<sp/>Point(<sp/>0,<sp/>1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B.begin_facet();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B.add_vertex_to_facet(<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B.add_vertex_to_facet(<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B.add_vertex_to_facet(<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B.end_facet();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B.end_surface();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound">CGAL::Polyhedron_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::HalfedgeDS<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HalfedgeDS;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Build_triangle&lt;HalfedgeDS&gt;<sp/>triangle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P.delegate(<sp/>triangle);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>P.is_triangle(<sp/>P.halfedges_begin()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
