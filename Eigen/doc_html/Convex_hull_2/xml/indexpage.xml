<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Convex_Hulls_and_Extreme_Points"/><anchor id="index_1chapconvexhull2"/> <simplesect kind="authors"><para>Susan Hert and Stefan Schirra</para></simplesect>
</para><sect1 id="index_1Convex_hull_2Introduction">
<title>Introduction</title>
<para>A subset <formula id="30">$ S \subseteq \mathbb{R}^2$</formula> is convex if for any two points <formula id="7">$ p$</formula> and <formula id="8">$ q$</formula> in the set the line segment with endpoints <formula id="7">$ p$</formula> and <formula id="8">$ q$</formula> is contained in <formula id="31">$ S$</formula>. The convex hull of a set <formula id="31">$ S$</formula> is the smallest convex set containing <formula id="31">$ S$</formula>. The convex hull of a set of points <formula id="32">$ P$</formula> is a convex polygon with vertices in <formula id="32">$ P$</formula>. A point in <formula id="32">$ P$</formula> is an extreme point (with respect to <formula id="32">$ P$</formula>) if it is a vertex of the convex hull of <formula id="32">$ P$</formula>. A set of points is said to be strongly convex if it consists of only extreme points.</para><para>This chapter describes the functions provided in CGAL for producing convex hulls in two dimensions as well as functions for checking if sets of points are strongly convex are not. There are also a number of functions described for computing particular extreme points and subsequences of hull points, such as the lower and upper hull of a set of points.</para><para><image type="html" name="saarhull.png"></image>
 <image type="latex" name="saarhull.png"></image>
</para></sect1>
<sect1 id="index_1secconvex_hull_2">
<title>Convex Hull</title>
<para>CGAL provides implementations of several classical algorithms for computing the counterclockwise sequence of extreme points for a set of points in two dimensions (<emphasis>i.e.</emphasis>, the counterclockwise sequence of points on the convex hull). The algorithms have different asymptotic running times and require slightly different sets of geometric primitives. Thus you may choose the algorithm that best fits your setting.</para><para>Each of the convex hull functions presents the same interface to the user. That is, the user provides a pair of iterators, <computeroutput>first</computeroutput> and <computeroutput>beyond</computeroutput>, an output iterator <computeroutput>result</computeroutput>, and a traits class <computeroutput>traits</computeroutput>. The points in the range [<computeroutput>first</computeroutput>, <computeroutput>beyond</computeroutput>) define the input points whose convex hull is to be computed. The counterclockwise sequence of extreme points is written to the sequence starting at position <computeroutput>result</computeroutput>, and the past-the-end iterator for the resulting set of points is returned. The traits classes for the functions specify the types of the input points and the geometric primitives that are required by the algorithms. All functions provide an interface in which this class need not be specified and defaults to types and operations defined in the kernel in which the input point type is defined.</para><para>Given a sequence of <formula id="1">$ n$</formula> input points with <formula id="3">$ h$</formula> extreme points, the function <computeroutput><ref refid="group__PkgConvexHull2Functions_1ga8241d43969ff61cb9be46811c2e9e176" kindref="member">convex_hull_2()</ref></computeroutput> uses either the output-sensitive <formula id="2">$ O(n h)$</formula> algorithm of Bykat <ref refid="citelist_1CITEREF_b-chfsp-78" kindref="member">[5]</ref> (a non-recursive version of the quickhull <ref refid="citelist_1CITEREF_bdh-qach-96" kindref="member">[4]</ref> algorithm) or the algorithm of Akl and Toussaint, which requires <formula id="0">$ O(n \log n)$</formula> time in the worst case. The algorithm chosen depends on the kind of iterator used to specify the input points. These two algorithms are also available via the functions <computeroutput><ref refid="group__PkgConvexHull2Functions_1gac13b4efbc337c7a8d5ad418521edcd4f" kindref="member">ch_bykat()</ref></computeroutput> and <computeroutput><ref refid="group__PkgConvexHull2Functions_1ga53e842c0b8490653535c00ab81bb0939" kindref="member">ch_akl_toussaint()</ref></computeroutput>, respectively. Also available are the <formula id="0">$ O(n \log n)$</formula> Graham-Andrew scan algorithm <ref refid="citelist_1CITEREF_a-aeach-79" kindref="member">[3]</ref>, <ref refid="citelist_1CITEREF_m-mdscg-84" kindref="member">[9]</ref> (<computeroutput><ref refid="group__PkgConvexHull2Functions_1gaeccc6dda2f9d3096c94a7ff84cc91a85" kindref="member">ch_graham_andrew()</ref></computeroutput>), the <formula id="2">$ O(n h)$</formula> Jarvis march algorithm <ref refid="citelist_1CITEREF_j-ichfs-73" kindref="member">[8]</ref> (<computeroutput><ref refid="group__PkgConvexHull2Functions_1ga99d0534bf096ae28a10b6844b21e7867" kindref="member">ch_jarvis()</ref></computeroutput>), and Eddy&apos;s <formula id="2">$ O(n h)$</formula> algorithm <ref refid="citelist_1CITEREF_e-nchap-77" kindref="member">[6]</ref> (<computeroutput><ref refid="group__PkgConvexHull2Functions_1gab9c9511b024795495dd6154ebf19c29c" kindref="member">ch_eddy()</ref></computeroutput>), which corresponds to the two-dimensional version of the quickhull algorithm. The linear-time algorithm of Melkman for producing the convex hull of simple polygonal chains (or polygons) is available through the function <computeroutput><ref refid="group__PkgConvexHull2Functions_1ga3bba4c83b7ac3cb9183191ea78828a65" kindref="member">ch_melkman()</ref></computeroutput>.</para></sect1>
<sect1 id="index_1Convex_hull_2Example">
<title>Example using Graham-Andrew&apos;s Algorithm</title>
<para>In the following example a convex hull is constructed from point data read from standard input using <computeroutput>Graham_Andrew</computeroutput> algorithm. The resulting convex polygon is shown at the standard output console. The same results could be achieved by substituting the function <computeroutput><ref refid="group__PkgConvexHull2Functions_1gaeccc6dda2f9d3096c94a7ff84cc91a85" kindref="member">ch_graham_andrew()</ref></computeroutput> by other functions such as <computeroutput><ref refid="group__PkgConvexHull2Functions_1gac13b4efbc337c7a8d5ad418521edcd4f" kindref="member">ch_bykat()</ref></computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Convex_hull_2_2ch_from_cin_to_cout_8cpp-example" kindref="compound">Convex_hull_2/ch_from_cin_to_cout.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/ch_graham_andrew.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga62462cf829e614f6f2cd2cbec9a093d2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_ascii_mode</ref>(std::cin);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga62462cf829e614f6f2cd2cbec9a093d2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_ascii_mode</ref>(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;<sp/>Point_2<sp/>&gt;<sp/><sp/>in_start(<sp/>std::cin<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;<sp/>Point_2<sp/>&gt;<sp/><sp/>in_end;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ostream_iterator&lt;<sp/>Point_2<sp/>&gt;<sp/><sp/>out(<sp/>std::cout,<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal"><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgConvexHull2Functions_1gaeccc6dda2f9d3096c94a7ff84cc91a85" kindref="member">CGAL::ch_graham_andrew</ref>(<sp/>in_start,<sp/>in_end,<sp/>out<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="index_1Convex_hull_2Extreme">
<title>Extreme Points and Hull Subsequences</title>
<para>In addition to the functions for producing convex hulls, there are a number of functions for computing sets and sequences of points related to the convex hull.</para><para>The functions <computeroutput><ref refid="group__PkgConvexHull2Subsequence_1gaf6e4baad67192f0cc3da273cda717297" kindref="member">lower_hull_points_2()</ref></computeroutput> and <computeroutput><ref refid="group__PkgConvexHull2Subsequence_1ga1abc268fbd7b3edfc61af2efff6f3e93" kindref="member">upper_hull_points_2()</ref></computeroutput> provide the computation of the counterclockwise sequence of extreme points on the lower hull and upper hull, respectively. The algorithm used in these functions is Andrew&apos;s variant of Graham&apos;s scan algorithm <ref refid="citelist_1CITEREF_a-aeach-79" kindref="member">[3]</ref>, <ref refid="citelist_1CITEREF_m-mdscg-84" kindref="member">[9]</ref>, which has worst-case running time of <formula id="0">$ O(n \log n)$</formula>.</para><para>There are also functions available for computing certain subsequences of the sequence of extreme points on the convex hull. The function <computeroutput><ref refid="group__PkgConvexHull2Subsequence_1gae9e0919cb50981d1f31ac242a2c4ba9d" kindref="member">ch_jarvis_march()</ref></computeroutput> generates the counterclockwise ordered subsequence of extreme points between a given pair of points and <computeroutput><ref refid="group__PkgConvexHull2Subsequence_1gafa026d25f9fee686e7a58af0ff365f86" kindref="member">ch_graham_andrew_scan()</ref></computeroutput> computes the sorted sequence of extreme points that are not left of the line defined by the first and last input points.</para><para>Finally, a set of functions (<computeroutput><ref refid="group__PkgConvexHull2Extreme_1ga3dbd516d18c626d354734f534aa8f740" kindref="member">ch_nswe_point()</ref></computeroutput>, <computeroutput><ref refid="group__PkgConvexHull2Extreme_1ga119d3f2f171cdf2d07d3a643efade08f" kindref="member">ch_ns_point()</ref></computeroutput>, <computeroutput><ref refid="group__PkgConvexHull2Extreme_1gadf9445fc0581869a195c27ca2685c3c6" kindref="member">ch_we_point()</ref></computeroutput>, <computeroutput><ref refid="group__PkgConvexHull2Extreme_1gab42b74243ff79e49f4574ddfdcdb4ed7" kindref="member">ch_n_point()</ref></computeroutput>, <computeroutput><ref refid="group__PkgConvexHull2Extreme_1gaab5a7ddae1354e025e003610d6e3cf10" kindref="member">ch_s_point()</ref></computeroutput>, <computeroutput><ref refid="group__PkgConvexHull2Extreme_1ga9add6eb0d67dacb52918da2c73e88c0a" kindref="member">ch_w_point()</ref></computeroutput>, <computeroutput><ref refid="group__PkgConvexHull2Extreme_1gac07127d740ecc491b3dc0e797c9c3252" kindref="member">ch_e_point()</ref></computeroutput>) is provided for computing extreme points of a 2D point set in the coordinate directions.</para></sect1>
<sect1 id="index_1Convex_hull_2Traits">
<title>Traits Classes</title>
<para>Each of the functions used to compute convex hulls or extreme points is parameterized by a traits class, which specifies the types and geometric primitives to be used in the computation. There are several implementations of 2D traits classes provided in the library. The class <computeroutput><ref refid="classCGAL_1_1Convex__hull__traits__2" kindref="compound">Convex_hull_traits_2</ref></computeroutput> corresponds to the default traits class that provides the types and predicates presented in the 2-dimensional CGAL kernel in which the input points lie. The class <computeroutput><ref refid="classCGAL_1_1Convex__hull__constructive__traits__2" kindref="compound">Convex_hull_constructive_traits_2</ref></computeroutput> is a second traits class based on CGAL primitives but differs from <computeroutput><ref refid="classCGAL_1_1Convex__hull__traits__2" kindref="compound">Convex_hull_traits_2</ref></computeroutput> in that some of its primitives reuse intermediate results to speed up computation.</para><para>In addition, the 2D and 3D Linear Geometric <ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref> provides three projective traits classes (<computeroutput><ref refid="classCGAL_1_1Projection__traits__xy__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_xy_3</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Projection__traits__xz__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_xz_3</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Projection__traits__yz__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_yz_3</ref></computeroutput>), which may be used to compute the convex hull of a set of three-dimensional points projected into each of the three coordinate planes.</para></sect1>
<sect1 id="index_1Convex_hull_2Convexity">
<title>Convexity Checking</title>
<para>The functions <computeroutput><ref refid="group__PkgConvexHull2Convexity_1gaf212d4568dfb6a39831c5f4ea1257b65" kindref="member">is_ccw_strongly_convex_2()</ref></computeroutput> and <computeroutput><ref refid="group__PkgConvexHull2Convexity_1ga19dcfbe04c6933232236f27e4fecf592" kindref="member">is_cw_strongly_convex_2()</ref></computeroutput> check whether a given sequence of 2D points forms a (counter)clockwise strongly convex polygon. These are used in postcondition testing of the two-dimensional convex hull functions. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
