<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Algebraic_Kernel"/><anchor id="index_1chapteralgebraickerneld"/> <simplesect kind="authors"><para>Eric Berberich, Michael Hemmer, Michael Kerber, Sylvain Lazard, Luis Pe<ntilde/>aranda, and Monique Teillaud</para></simplesect>
</para><sect1 id="index_1Algebraic_kernel_dIntroduction">
<title>Introduction</title>
<para>Real solving of polynomials is a fundamental problem with a wide application range. This package is targeted at providing black-box implementations of state-of-the-art algorithms to determine, compare, and approximate real roots of univariate polynomials and bivariate polynomial systems. Such a black-box is called an <emphasis>Algebraic <ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></emphasis>. Since this package is aimed at providing more than one implementation, the interface of the algebraic kernels is expressed in concepts. The main concepts provided by this package are the <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound">AlgebraicKernel_d_1</ref></computeroutput> for univariate polynomial systems and <computeroutput><ref refid="classAlgebraicKernel__d__2" kindref="compound">AlgebraicKernel_d_2</ref></computeroutput> for bivariate polynomial systems, the latter being a refinement of the first.</para></sect1>
<sect1 id="index_1Algebraic_kernel_dAlgebraic">
<title>Algebraic Kernel Concepts</title>
<sect2 id="index_1Algebraic_kernel_dUnivariateAlgebraicKernel">
<title>Univariate Algebraic Kernel</title>
</sect2>
<sect2 id="index_1Algebraic_kernel_dMajorTypes">
<title>Major Types</title>
<para>First of all, the univariate algebraic kernel provides construction, comparison and approximation of real roots of univariate polynomials. Thus, the major public types the <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound">AlgebraicKernel_d_1</ref></computeroutput> provides are:</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1ae49b9882d6f700d17476e00933ed20f3" kindref="member">AlgebraicKernel_d_1::Polynomial_1</ref></computeroutput> - the type representing univariate polynomials,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1a800674c4325a4c7dbc57186603fc8e3c" kindref="member">AlgebraicKernel_d_1::Coefficient</ref></computeroutput> - the coefficient type of these polynomials,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput> - the type representing real roots,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1a00c2a481bddf8a8812f517b1b81867c0" kindref="member">AlgebraicKernel_d_1::Bound</ref></computeroutput> - the type which is used to approximate these algebraic reals, in particular, it is used to represent the boundaries of isolating intervals.</para></sect2>
<sect2 id="index_1Algebraic_kernel_dConstructionofAlgebraic">
<title>Construction of Algebraic Real Numbers</title>
<para>The kernel provides two different function objects to construct an <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput>. The most general way is to use <computeroutput><ref refid="classAlgebraicKernel__d__1_1_1Isolate__1" kindref="compound">AlgebraicKernel_d_1::Isolate_1</ref></computeroutput>; The function object takes a univariate polynomial and writes all real roots into a given output iterator. It is also possible to retrieve the multiplicity of each root. The second option is to construct one particular algebraic real using <computeroutput><ref refid="classAlgebraicKernel__d__1_1a518f19a68780728a9cb63ce1f233d3a9" kindref="member">AlgebraicKernel_d_1::Construct_algebraic_real_1</ref></computeroutput>. This function object provides construction from the native int type, the coefficient type as well as the bound type. Moreover, it is possible to construct an algebraic real by giving a polynomial and either an isolating interval or the index of the root. A related function object is <computeroutput><ref refid="classAlgebraicKernel__d__1_1a4db228888900ccbe693666d8e8c5af91" kindref="member">AlgebraicKernel_d_1::Number_of_solutions_1</ref></computeroutput> computing the number of real roots of a polynomial.</para></sect2>
<sect2 id="index_1Algebraic_kernel_dComparisonandApproximation">
<title>Comparison and Approximation of Algebraic Real Numbers</title>
<para>An <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput> is model of <computeroutput><ref refid="classRealEmbeddable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">RealEmbeddable</ref></computeroutput>, for instance, it is possible to compare two algebraic reals, to determine the sign of an algebraic real or to ask for its double approximation, see also section <ref refid="index_1secRealEmbeddable" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">secRealEmbeddable</ref>. Moreover, <computeroutput><ref refid="classAlgebraicKernel__d__1_1_1Compare__1" kindref="compound">AlgebraicKernel_d_1::Compare_1</ref></computeroutput> provides comparison with int, the coefficient type and the bound type.</para><para>There are several ways to approximate an <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput>:</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1ac477a67047349405e1d2f37681ccf6a1" kindref="member">AlgebraicKernel_d_1::Approximate_absolute_1</ref></computeroutput> - provides an approximation that is better than the passed absolute error bound,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1ae8a7f0aec1bb71f15039ab2698c03033" kindref="member">AlgebraicKernel_d_1::Approximate_relative_1</ref></computeroutput> - provides an approximation that is better than the passed relative error bound,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1_1Isolate__1" kindref="compound">AlgebraicKernel_d_1::Isolate_1</ref></computeroutput> - returns an isolating interval with respect to a given univariate polynomial,</para><para>A related function object is <computeroutput><ref refid="classAlgebraicKernel__d__1_1afcab3e2cc953e64f9a72ce233efb8589" kindref="member">AlgebraicKernel_d_1::Bound_between_1</ref></computeroutput>, which computes a number that isolates two algebraic real numbers.</para></sect2>
<sect2 id="index_1Algebraic_kernel_dInterplaywithPolynomials">
<title>Interplay with Polynomials</title>
<para>It is also possible to retrieve a representing polynomial from an algebraic real using <computeroutput><ref refid="classAlgebraicKernel__d__1_1a321f08825328a48b7bf9ff7f4a40b149" kindref="member">AlgebraicKernel_d_1::Compute_polynomial_1</ref></computeroutput>, which guarantees that the algebraic real is a root of the returned polynomial. As the name already indicates, this operation may be very costly since the polynomial may not be computed yet. Moreover, it is not guaranteed that the returned polynomial is the minimal polynomial of the number. Together with <computeroutput><ref refid="classAlgebraicKernel__d__1_1_1Isolate__1" kindref="compound">AlgebraicKernel_d_1::Isolate_1</ref></computeroutput>, it is possible to retrieve the traditional representation of an algebraic real as a square free polynomial and an isolating interval.</para><para>Though the <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound">AlgebraicKernel_d_1</ref></computeroutput> does not provide arithmetic operations on <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput>, it is possible to compute the sign of a polynomial at a given algebraic real using <computeroutput><ref refid="classAlgebraicKernel__d__1_1a53c2b01c3d102eda8b92e6e403a6d79b" kindref="member">AlgebraicKernel_d_1::Sign_at_1</ref></computeroutput>. Or alternatively, just compute whether the polynomial is zero at an algebraic real number using <computeroutput>AlgebraicKernel_d_1::Is_zero_at_1</computeroutput>. Note that this operation can be significantly less expensive, in particular if the polynomial is not zero at the given algebraic real.</para></sect2>
<sect2 id="index_1Algebraic_kernel_dAuxiliaryFunctionality">
<title>Auxiliary Functionality for Polynomials</title>
<para>First of all the type <computeroutput><ref refid="classAlgebraicKernel__d__1_1ae49b9882d6f700d17476e00933ed20f3" kindref="member">AlgebraicKernel_d_1::Polynomial_1</ref></computeroutput> is required to be a model of the concept <computeroutput>Polynomial_1</computeroutput>, which is defined in the <ref refid="classCGAL_1_1Polynomial" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polynomial.tag">Polynomial</ref> package (see chapter <ref refid="index_1Chapter_Polynomial" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polynomial.tag">Chapter_Polynomial</ref>). This implies that all essential functionality is provided via <computeroutput><ref refid="classCGAL_1_1Polynomial__traits__d" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polynomial.tag">Polynomial_traits_d</ref></computeroutput>. However, the algebraic kernel also provides several function objects to handle polynomials:</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1a46259a3b5a5dbbb1565b5f5e471b714a" kindref="member">AlgebraicKernel_d_1::Is_square_free_1</ref></computeroutput> - determines whether a polynomial is square free,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1a0418a5b9fd01088731b4c2082bc17be2" kindref="member">AlgebraicKernel_d_1::Make_square_free_1</ref></computeroutput> - computes the square free part of a polynomial,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1a352fc9cab7172529a5d9e78e481d3df9" kindref="member">AlgebraicKernel_d_1::Square_free_factorize_1</ref></computeroutput> - computes a square free factorization of a polynomial,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1aa7bf3e9ccd2d87defd3eb8d500257ea6" kindref="member">AlgebraicKernel_d_1::Is_coprime_1</ref></computeroutput> - computes whether a pair of polynomials is square free,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__1_1a05c88217d056376af184469bdb032ec0" kindref="member">AlgebraicKernel_d_1::Make_coprime_1</ref></computeroutput> - decomposes two polynomials into the coprime factors and their common factor.</para><para>Though the polynomial package provides similar functionality we suggest to use the function objects provided by the kernel, since the design of the algebraic kernel allows for instance internal caching by the kernel.</para><para>Also note that <computeroutput><ref refid="classAlgebraicKernel__d__1_1a352fc9cab7172529a5d9e78e481d3df9" kindref="member">AlgebraicKernel_d_1::Square_free_factorize_1</ref></computeroutput> only computes the square free factorization up to a constant factor. This is a slight modification with respect to its counterpart in <computeroutput><ref refid="classCGAL_1_1Polynomial__traits__d" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polynomial.tag">Polynomial_traits_d</ref></computeroutput>. In this way it was possible that the concepts just require the coefficient type to be a model of <computeroutput><ref refid="classIntegralDomain" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomain</ref></computeroutput>, instead of <computeroutput><ref refid="classField" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Field</ref></computeroutput> or <computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">UniqueFactorizationDomain</ref></computeroutput>. For more details see also:</para><para><itemizedlist>
<listitem><para><ref refid="classPolynomialTraits__d_1_1SquareFreeFactorize" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polynomial.tag">PolynomialTraits_d::SquareFreeFactorize</ref></para></listitem><listitem><para><ref refid="classPolynomialTraits__d_1_1SquareFreeFactorizeUpToConstantFactor" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polynomial.tag">PolynomialTraits_d::SquareFreeFactorizeUpToConstantFactor</ref></para></listitem></itemizedlist>
</para></sect2>
<sect2 id="index_1Algebraic_kernel_dDesignRationale">
<title>Design Rationale</title>
<para>Most implementations of an <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound">AlgebraicKernel_d_1</ref></computeroutput> will represent an algebraic real number by the root of a square free polynomial and an isolating interval, that is, the number is defined as the only root of the polynomial within the interval. Usually, one will refrain from computing the minimal polynomial since the computation of the minimal polynomial is much more expensive and does not pay of. However, besides the representation by a polynomial and an isolating interval one can also imagine the representation by a polynomial and the index of the root, e.g., as the <formula id="0">$ i$</formula>th real root when enumerated from minus to plus infinity. Moreover, it may very well be that the kernel just computes an approximation of the number, whereas the representing polynomial is not computed yet. This is in particular relevant in relation to the <computeroutput><ref refid="classAlgebraicKernel__d__2" kindref="compound">AlgebraicKernel_d_2</ref></computeroutput>, where <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput> is used to represent coordinates of solutions of bivariate systems. Hence, the design does not allow a direct access to any, seemingly obvious, members of an <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput>. Instead there is, e.g., <computeroutput><ref refid="classAlgebraicKernel__d__1_1a321f08825328a48b7bf9ff7f4a40b149" kindref="member">AlgebraicKernel_d_1::Compute_polynomial_1</ref></computeroutput> which emphasizes that the requested polynomial may not be computed yet. Similarly, there is no way to directly ask for the refinement of the current isolating interval since this would impose a state to every object of an <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput>.</para></sect2>
<sect2 id="index_1Algebraic_kernel_dBivariateAlgebraicKernel">
<title>Bivariate Algebraic Kernel</title>
<para>The concept <computeroutput><ref refid="classAlgebraicKernel__d__2" kindref="compound">AlgebraicKernel_d_2</ref></computeroutput> is a refinement of <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound">AlgebraicKernel_d_1</ref></computeroutput>, that is, a model of <computeroutput><ref refid="classAlgebraicKernel__d__2" kindref="compound">AlgebraicKernel_d_2</ref></computeroutput> is also a model of <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound">AlgebraicKernel_d_1</ref></computeroutput>. Hence, the <computeroutput><ref refid="classAlgebraicKernel__d__2" kindref="compound">AlgebraicKernel_d_2</ref></computeroutput> concept is designed such that occurring names and functionalities are as similar as possible to those in the <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound">AlgebraicKernel_d_1</ref></computeroutput> concept. The following are a direct generalization of their univariate counterparts:</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1ad21d8fc065a9017ee338a1dc2f77c2e6" kindref="member">AlgebraicKernel_d_2::Polynomial_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a2b5054fdea67366f4933ecc68d2c85f9" kindref="member">AlgebraicKernel_d_2::Algebraic_real_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a9264c52566b10110e46b0ae51e9dbf78" kindref="member">AlgebraicKernel_d_2::Construct_algebraic_real_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1_1Isolate__2" kindref="compound">AlgebraicKernel_d_2::Isolate_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a6abca2e547d0099bedc3f2b3358cbce5" kindref="member">AlgebraicKernel_d_2::Is_square_free_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a5fe4302834c9519de4ddf7eb92185443" kindref="member">AlgebraicKernel_d_2::Make_square_free_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1aacbbb6fc718d6d7b29ca1f32a794af2f" kindref="member">AlgebraicKernel_d_2::Square_free_factorize_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1ace0db14584740ecb332abdc29ecf5541" kindref="member">AlgebraicKernel_d_2::Is_coprime_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1acef55065c428170c654d5465b7b56883" kindref="member">AlgebraicKernel_d_2::Make_coprime_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1_1Solve__2" kindref="compound">AlgebraicKernel_d_2::Solve_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a1945a08a3ae6ee9715746a74de193f09" kindref="member">AlgebraicKernel_d_2::Number_of_solutions_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1abfabaee89935e8164b81141eacdbf7c0" kindref="member">AlgebraicKernel_d_2::Compare_xy_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1abf51f228de0bc9397c95c43d51211a44" kindref="member">AlgebraicKernel_d_2::Sign_at_2</ref></computeroutput>,</para><para><computeroutput>AlgebraicKernel_d_2::Is_zero_at_2</computeroutput>.</para><para>For instance, <computeroutput><ref refid="classAlgebraicKernel__d__2_1_1Solve__2" kindref="compound">AlgebraicKernel_d_2::Solve_2</ref></computeroutput> provides the solution for a bivariate polynomial system. However, it is also possible to obtain the coordinates of these solutions with the additional functors:</para><para><computeroutput>AlgebraicKernel_d_2::Compute_x_2</computeroutput>,</para><para><computeroutput>AlgebraicKernel_d_2::Compute_y_2</computeroutput>.</para><para>In principal this would be sufficient generalization, since functions such as isolating, approximating algebraic real numbers could be implemented using these access functions ant the corresponding functionalities in the univariate algebraic kernel. However, one should be aware that an <computeroutput><ref refid="classAlgebraicKernel__d__2_1a2b5054fdea67366f4933ecc68d2c85f9" kindref="member">AlgebraicKernel_d_2::Algebraic_real_2</ref></computeroutput> is not necessarily represented as a pair of univariate solutions, that is, using <computeroutput>AlgebraicKernel_d_2::Compute_y_2</computeroutput> may entail considerable computations. Therefore, the concept also requires the following additional functors that may allow a model to bypass this issue:</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1afb3d27cdb52e14b5dfccaf688e678d10" kindref="member">AlgebraicKernel_d_2::Compute_polynomial_x_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a1dc81faf48c895bef14ea650fb81a958" kindref="member">AlgebraicKernel_d_2::Compute_polynomial_y_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a07c8e39c0ae4a00d680a3443447d592e" kindref="member">AlgebraicKernel_d_2::Isolate_x_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1ad80791a998a68478c715f456dbb7a5f8" kindref="member">AlgebraicKernel_d_2::Isolate_y_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a1c107b838f03cb32916006bc789712a8" kindref="member">AlgebraicKernel_d_2::Compare_x_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a44bbfed1b8f111fd874df7a0608e8a3f" kindref="member">AlgebraicKernel_d_2::Compare_y_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1abc1026203f0c9c806785048e249a5e80" kindref="member">AlgebraicKernel_d_2::Approximate_absolute_x_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a1f22a2bf902b6a510fa6418355107a02" kindref="member">AlgebraicKernel_d_2::Approximate_relative_x_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a8dea105081927c6b40896095bef7549f" kindref="member">AlgebraicKernel_d_2::Approximate_absolute_y_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1ab068f6e185775bc244c9d486acfea0ab" kindref="member">AlgebraicKernel_d_2::Approximate_relative_y_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1a1bee655b54212e7e39f2ca295fb7d6bb" kindref="member">AlgebraicKernel_d_2::Bound_between_x_2</ref></computeroutput>,</para><para><computeroutput><ref refid="classAlgebraicKernel__d__2_1afe9c5da2728c402d5a988af84554d2fa" kindref="member">AlgebraicKernel_d_2::Bound_between_y_2</ref></computeroutput>.</para></sect2>
</sect1>
<sect1 id="index_1Algebraic_kernel_dModels">
<title>Models</title>
<sect2 id="index_1Algebraic_kernel_dGenericAlgebraicKernels">
<title>Generic Algebraic Kernels</title>
<para>The package provides generic models of the univariate and bivariate algebraic kernel, namely <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound">Algebraic_kernel_d_1</ref>&lt;Coeff&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__2" kindref="compound">Algebraic_kernel_d_2</ref>&lt;Coeff&gt;</computeroutput>, respectively. Both kernels support a large set of number types as their template argument, which defines the supported coefficient type. The supported types are, for instance, <computeroutput><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpz</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput> as well as the corresponding types of LEDA and <ref refid="namespaceCORE" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CORE</ref>.</para><para>The <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound">Algebraic_kernel_d_1</ref>&lt;Coeff&gt;</computeroutput> represents an algebraic real root by a square free polynomial and an isolating interval that uniquely defines the root. The current method to isolate roots is the Bitstream Descartes method <ref refid="citelist_1CITEREF_eigenwillig-phd-08" kindref="member">[6]</ref>. The used method to refine the approximation of an algebraic real root is a slightly modified (filtered) version of the one presented in <ref refid="citelist_1CITEREF_abbott-qir-06" kindref="member">[1]</ref>. The method has quadratic convergence.</para><para><computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__2" kindref="compound">Algebraic_kernel_d_2</ref>&lt;Coeff&gt;</computeroutput> is based on an algorithm computing a geometric-topological analysis of a single curve <ref refid="citelist_1CITEREF_ekw-fast-07" kindref="member">[5]</ref> and of a pair of curves <ref refid="citelist_1CITEREF_ek-exact-08" kindref="member">[4]</ref>. The main idea behind both analyses is to compute the critical x-coordinates of curves and curve pairs by projection (resultants), and compute additional information about the critical fibers using subresultants and Sturm-Habicht sequences <ref refid="citelist_1CITEREF_grlr-sturm-habicht-98" kindref="member">[7]</ref>. With that information, the fiber at critical x-coordinates is computed by a variant of the Bitstream Descartes method. See also <ref refid="citelist_1CITEREF_kerber-phd-09" kindref="member">[8]</ref> for a comprehensive description of these techniques. Almost all functors in the class that take a <computeroutput>Polynomial_2</computeroutput> object as argument trigger such an analysis as a main computation step. For efficiency, these analyses (of single curves and curve pairs) are therefore cached internally for efficiency. For instance, computing the pairwise solutions of 10 <computeroutput>Polynomial_2</computeroutput> objects requires 10 curve analyses and 45 curve pair analyses to be computed internally.</para><para>A point <formula id="1">$ p$</formula> of type <computeroutput>Algebraic_real_2</computeroutput> is represented by its <formula id="2">$ x$</formula>-coordinate <formula id="3">$ x_0$</formula> (as described in the <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound">Algebraic_kernel_d_1</ref></computeroutput> paragraph above), an algebraic curve where <formula id="1">$ p$</formula> lies on, and an integer <formula id="0">$ i$</formula>, denoting that <formula id="1">$ p$</formula> is the <formula id="0">$ i$</formula>th point in the fiber at <formula id="3">$ x_0$</formula>, counted from the bottom (ignoring a possible vertical line at <formula id="3">$ x_0$</formula>). Note that this determines the point uniquely, but the <formula id="4">$ y$</formula>-coordinate is not stored internally in terms of an <computeroutput>Algebraic_real_1</computeroutput> object. Querying such a representation by calling <computeroutput>Compute_y_2</computeroutput> is a time-consuming step, and should be avoided for efficiency reasons if possible.</para></sect2>
<sect2 id="index_1Algebraic_kernel_dAlgebraicKernelsBasedon">
<title>Algebraic Kernels Based on RS</title>
<para>The package offers two univariate algebraic kernels that are based on the library RS <ref refid="citelist_1CITEREF_cgal:r-rs" kindref="member">[13]</ref>, namely <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__rs__gmpz__d__1" kindref="compound">Algebraic_kernel_rs_gmpz_d_1</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__rs__gmpq__d__1" kindref="compound">Algebraic_kernel_rs_gmpq_d_1</ref></computeroutput>. As the names indicate, the kernels are based on the library RS <ref refid="citelist_1CITEREF_cgal:r-rs" kindref="member">[13]</ref> and support univariate polynomials over <computeroutput><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpz</ref></computeroutput> or <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput>, respectively.</para><para>In general we encourage to use <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__rs__gmpz__d__1" kindref="compound">Algebraic_kernel_rs_gmpz_d_1</ref></computeroutput> instead of <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__rs__gmpq__d__1" kindref="compound">Algebraic_kernel_rs_gmpq_d_1</ref></computeroutput>. This is caused by the fact that the most efficient way to compute operations (such as gcd) on polynomials with rational coefficients is to use the corresponding implementation for polynomials with integer coefficients. That is, the <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__rs__gmpq__d__1" kindref="compound">Algebraic_kernel_rs_gmpq_d_1</ref></computeroutput> is slightly slower due to overhead caused by the necessary conversions. However, since this may not always be a major issue, the <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__rs__gmpq__d__1" kindref="compound">Algebraic_kernel_rs_gmpq_d_1</ref></computeroutput> is provided for convenience.</para><para>The core of both kernels is the implementation of the interval Descartes algorithm <ref refid="citelist_1CITEREF_cgal:rz-jcam-04" kindref="member">[12]</ref> of the library RS <ref refid="citelist_1CITEREF_cgal:r-rs" kindref="member">[13]</ref>, which is used to isolate the roots of the polynomial. The RS library restricts its attention to univariate integer polynomials and some substantial gain of efficiency can be made by using a kernel that does not follow the generic programming paradigm, by avoiding interfaces between layers. Specifically, working with only one number type allows to optimize some polynomial operations as well as memory handling. The implementation of these kernels make heavy use of the Mpfr <ref refid="citelist_1CITEREF_cgal:mt-mpfr" kindref="member">[11]</ref> and Mpfi <ref refid="citelist_1CITEREF_cgal:r-mpfi" kindref="member">[10]</ref> libraries, and of their CGAL interfaces, <computeroutput><ref refid="classCGAL_1_1Gmpfr" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpfr</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Gmpfi" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpfi</ref></computeroutput>. The algebraic numbers (roots of the polynomials) are represented in the two RS kernels by a <computeroutput><ref refid="classCGAL_1_1Gmpfi" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpfi</ref></computeroutput> interval and a pointer to the polynomial of which they are roots. See <ref refid="citelist_1CITEREF_cgal:lpt-wea-09" kindref="member">[9]</ref> for more details on the implementation, tests of these kernels, comparisons with other algebraic kernels and discussions about the efficiency.</para></sect2>
</sect1>
<sect1 id="index_1Algebraic_kernel_dExamples">
<title>Examples</title>
<sect2 id="index_1CGALAK1ConstructionExamples">
<title>Construction of Algebraic Real Numbers</title>
<para>The following example illustrates the construction of <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput> using <computeroutput><ref refid="classAlgebraicKernel__d__1_1a518f19a68780728a9cb63ce1f233d3a9" kindref="member">AlgebraicKernel_d_1::Construct_algebraic_real_1</ref></computeroutput>: <small><linebreak/>
<bold>File</bold> <ref refid="Algebraic_kernel_d_2Construct_algebraic_real_1_8cpp-example" kindref="compound">Algebraic_kernel_d/Construct_algebraic_real_1.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>$URL$</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>$Id$</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_MPFI<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Algebraic_kernel_d_1.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Gmpz_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Gmpz.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound">CGAL::Algebraic_kernel_d_1&lt;CGAL::Gmpz&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AK;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Polynomial_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polynomial_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Algebraic_real_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic_real_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Coefficient<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Coefficient;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Bound<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bound;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Multiplicity_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Multiplicity_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK<sp/>ak;<sp/></highlight><highlight class="comment">//<sp/>an<sp/>object<sp/>of<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Construct_algebraic_real_1<sp/>construct_algreal_1<sp/>=<sp/>ak.construct_algebraic_real_1_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construct<sp/>from<sp/>int<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>construct_algreal_1(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">(2))<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construct<sp/>from<sp/>Coefficient<sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>construct_algreal_1(Coefficient(2))<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construct<sp/>from<sp/>Bound<sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>construct_algreal_1(Bound(2))<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>x<sp/>=<sp/><ref refid="group__PkgPolynomialFunctions_1ga19a6f91ab72ba7ad5139f7c7bc759e08" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polynomial.tag">CGAL::shift</ref>(AK::Polynomial_1(1),1);<sp/></highlight><highlight class="comment">//<sp/>the<sp/>monomial<sp/>x</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construct<sp/>by<sp/>index<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>construct_algreal_1(x*x-2,1)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">to_double</ref>(construct_algreal_1(x*x-2,1))<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construct<sp/>by<sp/>isolating<sp/>interval<sp/>:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>construct_algreal_1(x*x-2,Bound(0),Bound(2))<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">to_double</ref>(construct_algreal_1(x*x-2,Bound(0),Bound(2)))<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>example<sp/>requires<sp/>CGAL<sp/>to<sp/>be<sp/>configured<sp/>with<sp/>library<sp/>MPFI.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></small></para></sect2>
<sect2 id="index_1CGALAK1Solving">
<title>Solving Univariate Polynomials</title>
<para>The following example illustrates the construction of <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput> using <computeroutput><ref refid="classAlgebraicKernel__d__1_1_1Solve__1" kindref="compound">AlgebraicKernel_d_1::Solve_1</ref></computeroutput>: <small><linebreak/>
<bold>File</bold> <ref refid="Algebraic_kernel_d_2Solve_1_8cpp-example" kindref="compound">Algebraic_kernel_d/Solve_1.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>$URL$</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>$Id$</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_MPFI<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Algebraic_kernel_d_1.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Gmpz_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Gmpz.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound">CGAL::Algebraic_kernel_d_1&lt;CGAL::Gmpz&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AK;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Polynomial_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polynomial_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Algebraic_real_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic_real_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Bound<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bound;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Multiplicity_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Multiplicity_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK<sp/>ak;<sp/></highlight><highlight class="comment">//<sp/>an<sp/>object<sp/>of<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Solve_1<sp/>solve_1<sp/>=<sp/>ak.solve_1_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>x<sp/>=<sp/><ref refid="group__PkgPolynomialFunctions_1ga19a6f91ab72ba7ad5139f7c7bc759e08" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polynomial.tag">CGAL::shift</ref>(AK::Polynomial_1(1),1);<sp/></highlight><highlight class="comment">//<sp/>the<sp/>monomial<sp/>x</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>variant<sp/>using<sp/>a<sp/>bool<sp/>indicating<sp/>a<sp/>square<sp/>free<sp/>polynomial</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>multiplicities<sp/>are<sp/>not<sp/>computed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Algebraic_real_1&gt;<sp/>roots;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>solve_1(x*x-2,</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>std::back_inserter(roots));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>roots<sp/>is<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>roots.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;First<sp/>root<sp/>should<sp/>be<sp/>-sqrt(2):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(roots[0])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Second<sp/>root<sp/>should<sp/>be<sp/>sqrt(2):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(roots[1])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>roots.clear();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>variant<sp/>for<sp/>roots<sp/>in<sp/>a<sp/>given<sp/>range<sp/>of<sp/>a<sp/>square<sp/>free<sp/>polynomial</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>solve_1((x*x-2)*(x*x-3),</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>Bound(0),Bound(10),std::back_inserter(roots));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>roots<sp/>is<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>roots.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;First<sp/>root<sp/>should<sp/>be<sp/><sp/>sqrt(2):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(roots[0])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Second<sp/>root<sp/>should<sp/>be<sp/>sqrt(3):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(roots[1])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>roots.clear();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>variant<sp/>computing<sp/>all<sp/>roots<sp/>with<sp/>multiplicities</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::pair&lt;Algebraic_real_1,Multiplicity_type&gt;<sp/>&gt;<sp/>mroots;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>solve_1((x*x-2),<sp/>std::back_inserter(mroots));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>roots<sp/>is<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>mroots.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;First<sp/>root<sp/>should<sp/>be<sp/>-sqrt(2):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(mroots[0].first)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>with<sp/>multiplicity<sp/>&quot;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>mroots[0].second<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Second<sp/>root<sp/>should<sp/>be<sp/>sqrt(2):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(mroots[1].first)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>with<sp/>multiplicity<sp/>&quot;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>mroots[1].second<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mroots.clear();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>variant<sp/>computing<sp/>roots<sp/>with<sp/>multiplicities<sp/>for<sp/>a<sp/>range</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>solve_1((x*x-2)*(x*x-3),Bound(0),Bound(10),std::back_inserter(mroots));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>roots<sp/>is<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>mroots.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;First<sp/>root<sp/>should<sp/>be<sp/><sp/>sqrt(2):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(mroots[0].first)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>with<sp/>multiplicity<sp/>&quot;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>mroots[0].second<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Second<sp/>root<sp/>should<sp/>be<sp/>sqrt(3):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(mroots[1].first)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>with<sp/>multiplicity<sp/>&quot;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>mroots[1].second<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>example<sp/>requires<sp/>CGAL<sp/>to<sp/>be<sp/>configured<sp/>with<sp/>library<sp/>MPFI.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting> </small></para></sect2>
<sect2 id="index_1CGALAK1EGCompare_1">
<title>Comparison and Approximation of Algebraic Real Numbers</title>
<para>The following example illustrates the comparison of <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput> numbers: <small><linebreak/>
<bold>File</bold> <ref refid="Algebraic_kernel_d_2Compare_1_8cpp-example" kindref="compound">Algebraic_kernel_d/Compare_1.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>$URL$</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>$Id$</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_MPFI<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Algebraic_kernel_d_1.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Gmpz_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Gmpz.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound">CGAL::Algebraic_kernel_d_1&lt;CGAL::Gmpz&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AK;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Coefficient<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Coefficient;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Polynomial_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polynomial_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Algebraic_real_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic_real_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Bound<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bound;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Bound,Bound&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Interval;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK<sp/>ak;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Construct_algebraic_real_1<sp/>construct_algebraic_real_1<sp/>=<sp/>ak.construct_algebraic_real_1_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>x<sp/>=<sp/><ref refid="group__PkgPolynomialFunctions_1ga19a6f91ab72ba7ad5139f7c7bc759e08" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polynomial.tag">CGAL::shift</ref>(AK::Polynomial_1(1),1);<sp/></highlight><highlight class="comment">//<sp/>the<sp/>monomial<sp/>x</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Algebraic_real_1<sp/>a<sp/>=<sp/>construct_algebraic_real_1(x*x-2,1);<sp/></highlight><highlight class="comment">//<sp/><sp/>sqrt(2)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Algebraic_real_1<sp/>b<sp/>=<sp/>construct_algebraic_real_1(x*x-3,1);<sp/></highlight><highlight class="comment">//<sp/><sp/>sqrt(3)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Algebraic_real_1<sp/>is<sp/>RealEmbeddable<sp/>(just<sp/>some<sp/>functions:)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;sign<sp/>of<sp/>a<sp/>is<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1gaf3d75d272a29458960987a8f248ec636" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::sign</ref>(a)<sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;double<sp/>approximation<sp/>of<sp/>a<sp/>is<sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(a)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;double<sp/>approximation<sp/>of<sp/>b<sp/>is<sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(b)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;double<sp/>lower<sp/>bound<sp/>of<sp/>a<sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1gac30124cb713e69f02816e2b91c655fa6" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_interval</ref>(a).first<sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;double<sp/>upper<sp/>bound<sp/>of<sp/>a<sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1gac30124cb713e69f02816e2b91c655fa6" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_interval</ref>(a).second<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;LessThanComparable<sp/>(a&lt;b)<sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(a&lt;b)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>use<sp/>compare_1<sp/>with<sp/>int,<sp/>Bound,<sp/>Coefficient,<sp/>Algebraic_real_1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Compare_1<sp/>compare_1<sp/>=<sp/>ak.compare_1_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>compare<sp/>with<sp/>an<sp/>int<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>compare_1(a<sp/>,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">(2))<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>compare<sp/>with<sp/>an<sp/>Coefficient<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>compare_1(a<sp/>,Coefficient(2))<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>compare<sp/>with<sp/>an<sp/>Bound<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>compare_1(a<sp/>,Bound(2))<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>compare<sp/>with<sp/>another<sp/>Algebraic_real_1:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>compare_1(a<sp/>,b)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>get<sp/>a<sp/>value<sp/>between<sp/>two<sp/>roots</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Bound_between_1<sp/>bound_between_1<sp/>=<sp/>ak.bound_between_1_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>value<sp/>between<sp/>sqrt(2)<sp/>and<sp/>sqrt(3)<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>bound_between_1(a,b)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>is<sp/>larger<sp/>than<sp/>sqrt(2)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>compare_1(bound_between_1(a,b),a)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>is<sp/>less<sp/><sp/><sp/>than<sp/>sqrt(3)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>compare_1(bound_between_1(a,b),b)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>approximate<sp/>with<sp/>relative<sp/>precision</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Approximate_relative_1<sp/>approx_r<sp/>=<sp/>ak.approximate_relative_1_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>lower<sp/>bound<sp/>of<sp/>a<sp/>with<sp/>at<sp/>least<sp/>100<sp/>bits:<sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>approx_r(a,100).first<sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>upper<sp/>bound<sp/>of<sp/>a<sp/>with<sp/>at<sp/>least<sp/>100<sp/>bits:<sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>approx_r(a,100).second<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>approximate<sp/>with<sp/>absolute<sp/>error</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Approximate_absolute_1<sp/>approx_a<sp/>=<sp/>ak.approximate_absolute_1_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>lower<sp/>bound<sp/>of<sp/>b<sp/>with<sp/>error<sp/>less<sp/>than<sp/>2^-100:<sp/><sp/><sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>approx_a(b,100).first<sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>upper<sp/>bound<sp/>of<sp/>b<sp/>with<sp/>error<sp/>less<sp/>than<sp/>2^-100:<sp/><sp/><sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>approx_a(b,100).second<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>example<sp/>requires<sp/>CGAL<sp/>to<sp/>be<sp/>configured<sp/>with<sp/>library<sp/>MPFI.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></small></para></sect2>
<sect2 id="index_1CGALAK1EGIsolate_1">
<title>Isolation of Algebraic Real Numbers with respect to roots of other polynomials</title>
<para>The following example illustrates the isolation of <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput> numbers: <small><linebreak/>
<bold>File</bold> <ref refid="Algebraic_kernel_d_2Isolate_1_8cpp-example" kindref="compound">Algebraic_kernel_d/Isolate_1.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>$URL$</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>$Id$</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_MPFI<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Algebraic_kernel_d_1.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Gmpz_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Gmpz.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound">CGAL::Algebraic_kernel_d_1&lt;CGAL::Gmpz&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AK;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Polynomial_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polynomial_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Algebraic_real_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic_real_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Coefficient<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Coefficient;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Bound<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bound;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Multiplicity_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Multiplicity_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK<sp/>ak;<sp/></highlight><highlight class="comment">//<sp/>an<sp/>object<sp/>of<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Construct_algebraic_real_1<sp/>construct_algreal_1<sp/>=<sp/>ak.construct_algebraic_real_1_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Isolate_1<sp/>isolate_1<sp/>=<sp/>ak.isolate_1_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Compute_polynomial_1<sp/>compute_polynomial_1<sp/>=<sp/>ak.compute_polynomial_1_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>construct<sp/>an<sp/>algebraic<sp/>number<sp/>from<sp/>an<sp/>integer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Algebraic_real_1<sp/>frominteger=construct_algreal_1(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">(2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construct<sp/>from<sp/>int:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>frominteger<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>constructed<sp/>algebraic<sp/>number<sp/>is<sp/>root<sp/>of<sp/>a<sp/>polynomial</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>pol=compute_polynomial_1(frominteger);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>constructed<sp/>number<sp/>is<sp/>root<sp/>of:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>pol<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>construct<sp/>an<sp/>algebraic<sp/>number<sp/>from<sp/>a<sp/>polynomial<sp/>and<sp/>an<sp/>isolating<sp/>interval</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>x<sp/>=<sp/><ref refid="group__PkgPolynomialFunctions_1ga19a6f91ab72ba7ad5139f7c7bc759e08" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polynomial.tag">CGAL::shift</ref>(AK::Polynomial_1(1),1);<sp/></highlight><highlight class="comment">//<sp/>the<sp/>monomial<sp/>x</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Algebraic_real_1<sp/>frominterval=construct_algreal_1(x*x-2,Bound(0),Bound(2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construct<sp/>from<sp/>isolating<sp/>interval:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>frominterval<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>isolate<sp/>the<sp/>second<sp/>algebraic<sp/>number<sp/>from<sp/>the<sp/>first:<sp/>this<sp/>is<sp/>to<sp/>say,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>isolating<sp/>the<sp/>second<sp/>algebraic<sp/>number<sp/>with<sp/>respect<sp/>to<sp/>the<sp/>polynomial</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>of<sp/>which<sp/>the<sp/>first<sp/>constructed<sp/>number<sp/>is<sp/>root</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::pair&lt;Bound,Bound&gt;<sp/>isolation1<sp/>=<sp/>isolate_1(frominterval,pol);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Isolating<sp/>the<sp/>second<sp/>algebraic<sp/>number<sp/>gives:<sp/>[&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>isolation1.first<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>isolation1.second<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>isolate<sp/>again<sp/>the<sp/>same<sp/>algebraic<sp/>number,<sp/>this<sp/>time<sp/>with<sp/>respect<sp/>to</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>polynomial<sp/>10*x-14<sp/>(which<sp/>has<sp/>root<sp/>1.4,<sp/>close<sp/>to<sp/>this<sp/>algebraic</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>number)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::pair&lt;Bound,Bound&gt;<sp/>isolation2<sp/>=<sp/>isolate_1(frominterval,10*x-14);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Isolating<sp/>again<sp/>the<sp/>second<sp/>algebraic<sp/>number<sp/>gives:<sp/>[&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>isolation2.first<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>isolation2.second<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>example<sp/>requires<sp/>CGAL<sp/>to<sp/>be<sp/>configured<sp/>with<sp/>library<sp/>MPFI.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></small></para></sect2>
<sect2 id="index_1CGALAK1EGSign_at_1">
<title>Interplay with Polynomials</title>
<para>The following example illustrates the sign evaluation of <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput> numbers in polynomials: <small><linebreak/>
<bold>File</bold> <ref refid="Algebraic_kernel_d_2Sign_at_1_8cpp-example" kindref="compound">Algebraic_kernel_d/Sign_at_1.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>$URL$</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>$Id$</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_MPFI<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Algebraic_kernel_d_1.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Gmpz_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Gmpz.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound">CGAL::Algebraic_kernel_d_1&lt;CGAL::Gmpz&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AK;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Polynomial_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polynomial_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Algebraic_real_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic_real_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Coefficient<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Coefficient;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Bound<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bound;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>AK::Multiplicity_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Multiplicity_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK<sp/>ak;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Solve_1<sp/>solve_1<sp/>=<sp/>ak.solve_1_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Sign_at_1<sp/>sign_at_1<sp/>=<sp/>ak.sign_at_1_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK::Is_zero_at_1<sp/>is_zero_at_1<sp/>=<sp/>ak.is_zero_at_1_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>construct<sp/>the<sp/>polynomials<sp/>p=x^2-5<sp/>and<sp/>q=x-2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>x<sp/>=<sp/><ref refid="group__PkgPolynomialFunctions_1ga19a6f91ab72ba7ad5139f7c7bc759e08" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polynomial.tag">CGAL::shift</ref>(AK::Polynomial_1(1),1);<sp/></highlight><highlight class="comment">//<sp/>the<sp/>monomial<sp/>x</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>p<sp/>=<sp/>x*x-5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Polynomial<sp/>p:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>q<sp/>=<sp/>x-2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Polynomial<sp/>q:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>q<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>find<sp/>the<sp/>roots<sp/>of<sp/>p<sp/>(it<sp/>has<sp/>two<sp/>roots)<sp/>and<sp/>q<sp/>(one<sp/>root)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Algebraic_real_1&gt;<sp/>roots_p,roots_q;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>solve_1(p,</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>std::back_inserter(roots_p));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>solve_1(q,</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>std::back_inserter(roots_q));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>evaluate<sp/>the<sp/>second<sp/>root<sp/>of<sp/>p<sp/>in<sp/>q</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sign<sp/>of<sp/>the<sp/>evaluation<sp/>of<sp/>root<sp/>2<sp/>of<sp/>p<sp/>in<sp/>q:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>sign_at_1(q,roots_p[1])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>evaluate<sp/>the<sp/>root<sp/>of<sp/>q<sp/>in<sp/>p</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sign<sp/>of<sp/>the<sp/>evaluation<sp/>of<sp/>root<sp/>1<sp/>of<sp/>q<sp/>in<sp/>p:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>sign_at_1(p,roots_q[0])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>whether<sp/>the<sp/>evaluation<sp/>of<sp/>the<sp/>first<sp/>root<sp/>of<sp/>p<sp/>in<sp/>p<sp/>is<sp/>zero</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Is<sp/>zero<sp/>the<sp/>evaluation<sp/>of<sp/>root<sp/>1<sp/>of<sp/>p<sp/>in<sp/>p?<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>is_zero_at_1(p,roots_p[0])<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>example<sp/>requires<sp/>CGAL<sp/>to<sp/>be<sp/>configured<sp/>with<sp/>library<sp/>MPFI.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></small></para></sect2>
</sect1>
<sect1 id="index_1Algebraic_kernel_dDesign">
<title>Design and Implementation History</title>
<para>This package is clearly split into a univariate and bivariate kernel. However, with respect to its history the package splits into a design part and an implementation part.</para><para>The concepts, which make up the design part, were written by Eric Berberich, Michael Hemmer, and Monique Teillaud. The design history of the package is fairly old and several ideas that influenced this package can already be found in <ref refid="citelist_1CITEREF_cgal:bhkt-risak-07" kindref="member">[3]</ref>. Since then, the initial design underwent considerable changes. For instance, it was decided that the algebraic numbers should be under the control of the algebraic kernel. On the other hand the initial support for polynomials was extended to a separate and independent package that is not restricted to a certain number of variables. Thus, the authors want to thank for all the useful feedback and ideas that was brought to them throughout the last years. In particular, they want to thank Menelaos Karavelas and Elias Tsigaridas for their initial contributions.</para><para>The two generic models where initially developed as part of the Exacus <ref refid="citelist_1CITEREF_beh-eeeafcs-05" kindref="member">[2]</ref> project. However, the models are now fully integrated into the CGAL library, since also the relevant layers of Exacus are now part of CGAL. The main authors for <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound">Algebraic_kernel_d_1</ref>&lt;Coeff&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__2" kindref="compound">Algebraic_kernel_d_2</ref>&lt;Coeff&gt;</computeroutput> are Michael Hemmer and Michael Kerber, respectively. Notwithstanding, the authors also want to emphasize the contribution of all authors of the Exacus project, particularly the contribution of Arno Eigenwillig, Sebastian Limbach and Pavel Emeliyanenko.</para><para>The two univariate kernels that interface the library RS <ref refid="citelist_1CITEREF_cgal:r-rs" kindref="member">[13]</ref> were written by Luis Pe<ntilde/>aranda and Sylvain Lazard. Both models interface the library RS <ref refid="citelist_1CITEREF_cgal:r-rs" kindref="member">[13]</ref> by Fabrice Rouillier. The authors want to thank Fabrice Rouillier and Elias Tsigaridas for strong support and many useful discussions that lead to the integration of RS. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
