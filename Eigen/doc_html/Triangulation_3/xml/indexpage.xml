<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_3D_Triangulations"/><anchor id="index_1chapterTriangulation3"/></para><para><simplesect kind="authors"><para>Cl√©ment Jamin, Sylvain Pion and Monique Teillaud</para></simplesect>
<image type="html" name="triangulation3.png"></image>
 <image type="latex" name="triangulation3.png"></image>
</para><para>The basic 3D-triangulation class of CGAL is primarily designed to represent the triangulations of a set of points <formula id="63">$ A$</formula> in <formula id="6">$ \mathbb{R}^3$</formula>. It is a partition of the convex hull of <formula id="63">$ A$</formula> into tetrahedra whose vertices are the points of <formula id="63">$ A$</formula>. Together with the unbounded cell having the convex hull boundary as its frontier, the triangulation forms a partition of <formula id="6">$ \mathbb{R}^3$</formula>. Its cells ( <formula id="64">$ 3$</formula>-faces) are such that two cells either do not intersect or share a common facet ( <formula id="65">$ 2$</formula>-face), edge ( <formula id="66">$ 1$</formula>-face) or vertex ( <formula id="67">$ 0$</formula>-face).</para><sect1 id="index_1Triangulation3secintro">
<title>Representation</title>
<para>In order to deal only with tetrahedra, which is convenient for many applications, the unbounded cell can be subdivided into tetrahedra by considering that each convex hull facet is incident to an <computeroutput>infinite cell</computeroutput> having as fourth vertex an auxiliary vertex called the <computeroutput>infinite vertex</computeroutput>. In that way, each facet is incident to exactly two cells and special cases at the boundary of the convex hull are simple to deal with.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Triangulation__3" kindref="compound">Triangulation_3</ref>&lt;<ref refid="classTriangulationTraits__3" kindref="compound">TriangulationTraits_3</ref>,<ref refid="classTriangulationDataStructure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">TriangulationDataStructure_3</ref>&gt;</computeroutput> of CGAL implements this point of view and therefore considers the triangulation of the set of points as a set of finite and infinite tetrahedra. Notice that the infinite vertex has no significant coordinates and that no geometric predicate can be applied on it.</para><para>A triangulation is a collection of vertices and cells that are linked together through incidence and adjacency relations. Each cell gives access to its four incident vertices and to its four adjacent cells. Each vertex gives access to one of its incident cells.</para><para>The four vertices of a cell are indexed with 0, 1, 2 and 3 in positive orientation, the positive orientation being defined by the orientation of the underlying Euclidean space <formula id="6">$ \mathbb{R}^3$</formula> (see <ref refid="index_1fig__Triangulation3figorient" kindref="member">fig__Triangulation3figorient</ref>). The neighbors of a cell are also indexed with 0, 1, 2, 3 in such a way that the neighbor indexed by <formula id="68">$ i$</formula> is opposite to the vertex with the same index.</para><para><anchor id="index_1fig__Triangulation3figorient"/><image type="html" name="orient.png"></image>
 <image type="latex" name="orient.png" width="15cm"></image>
  <ref refid="index_1fig__Triangulation3figorient" kindref="member">fig__Triangulation3figorient</ref> Orientation of a cell (3-dimensional case).  <linebreak/>
</para><para>As in the underlying combinatorial triangulation (see Chapter <ref refid="index_1chapterTDS3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">3D Triangulation Data Structure</ref>), edges ( <formula id="66">$ 1$</formula>-faces) and facets ( <formula id="65">$ 2$</formula>-faces) are not explicitly represented: a facet is given by a cell and an index (the facet <computeroutput>i</computeroutput> of a cell <computeroutput>c</computeroutput> is the facet of <computeroutput>c</computeroutput> that is opposite to the vertex with index <computeroutput>i</computeroutput>) and an edge is given by a cell and two indices (the edge <computeroutput>(i,j)</computeroutput> of a cell <computeroutput>c</computeroutput> is the edge whose endpoints are the vertices of <computeroutput>c</computeroutput> with indices <computeroutput>i</computeroutput> and <computeroutput>j</computeroutput>). See <ref refid="index_1fig__TDS3figrepres" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">fig__TDS3figrepres</ref>.</para><para><bold>Degenerate Dimensions</bold></para><para>The class <computeroutput><ref refid="classCGAL_1_1Triangulation__3" kindref="compound">Triangulation_3</ref></computeroutput> can also deal with triangulations whose dimension <formula id="69">$ d$</formula> is less than 3. A triangulation of a set of points in <formula id="70">$ \mathbb{R}^d$</formula> covers the whole space <formula id="70">$ \mathbb{R}^d$</formula> and consists of cells having <formula id="71">$ d+1$</formula> vertices: some of them are infinite, they are obtained by linking the additional infinite vertex to each facet of the convex hull of the points. <itemizedlist>
<listitem>
<para><emphasis>dimension 2:</emphasis> when a triangulation only contains coplanar points (which is the case when there are only three points), it consists of triangular faces. </para></listitem>
<listitem>
<para><emphasis>dimension 1:</emphasis> the triangulation contains only collinear points (which is the case when there are only two points), it consists of edges. </para></listitem>
<listitem>
<para><emphasis>dimension 0:</emphasis> the triangulation contains only one finite point. </para></listitem>
<listitem>
<para><emphasis>dimension -1:</emphasis> this is a convention to handle the case when the only vertex of the triangulation is the infinite one. </para></listitem>
</itemizedlist>
</para><para>The same cell class is used in all cases: triangular faces in 2D can be considered as degenerate cells, having only three vertices (resp. neighbors) numbered <formula id="72">$ (0,1,2)$</formula>; edges in 1D have only two vertices (resp. neighbors) numbered <formula id="67">$ 0$</formula> and <formula id="66">$ 1$</formula>.</para><para>The implicit representation of facets (resp. edges) still holds for degenerate dimensions (<emphasis>i.e.</emphasis> dimensions <formula id="73">$ &lt;3$</formula>): in dimension 2, each cell has only one facet of index 3, and 3 edges <formula id="74">$ (0,1)$</formula>, <formula id="75">$ (1,2)$</formula> and <formula id="76">$ (2,0)$</formula>; in dimension 1, each cell has one edge <formula id="74">$ (0,1)$</formula>.</para><para><bold>Validity</bold></para><para>A triangulation of <formula id="6">$ \mathbb{R}^3$</formula> is said to be <emphasis>locally valid</emphasis> iff</para><para><bold>(a)-(b)</bold> Its underlying combinatorial graph, the triangulation data structure, is <emphasis>locally valid</emphasis> (see Section <ref refid="index_1TDS3secintro" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">Introduction</ref> of Chapter <ref refid="index_1chapterTDS3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">3D Triangulation Data Structure</ref>)</para><para><bold>(c)</bold> Any cell has its vertices ordered according to positive orientation. See <ref refid="index_1fig__Triangulation3figorient" kindref="member">fig__Triangulation3figorient</ref>.</para><para>When the triangulation is degenerated into a triangulation of dimension 2, the geometric validity reduces to:</para><para><bold>(c-2D)</bold> For any two adjacent triangles <formula id="77">$ (u,v,w_1)$</formula> and <formula id="78">$ (u,v,w_2)$</formula> with common edge <formula id="79">$ (u,v)$</formula>, <formula id="80">$ w_1$</formula> and <formula id="81">$ w_2$</formula> lie on opposite sides of <formula id="79">$ (u,v)$</formula> in the plane.</para><para>When all the points are collinear, this condition becomes:</para><para><bold>(c-1D)</bold> For any two adjacent edges <formula id="79">$ (u,v)$</formula> and <formula id="82">$ (v,w)$</formula>, <formula id="83">$ u$</formula> and <formula id="84">$ w$</formula> lie on opposite sides of the common vertex <formula id="85">$ v$</formula> on the line.</para><para>The method <computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a76fa2f93b007c62d2c9d8deb09d8c5aa" kindref="member">Triangulation_3::is_valid()</ref></computeroutput> checks the local validity of a given triangulation. This does not always ensure global validity <ref refid="citelist_1CITEREF_mnssssu-cgpvg-96" kindref="member">[18]</ref>, <ref refid="citelist_1CITEREF_dlpt-ccpps-98" kindref="member">[10]</ref> but it is sufficient for practical cases.</para></sect1>
<sect1 id="index_1Triangulation_3Delaunay">
<title>Delaunay Triangulation</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">Delaunay_triangulation_3</ref></computeroutput> represents a three-dimensional Delaunay triangulation.</para><para>Delaunay triangulations have the specific <emphasis>empty sphere property</emphasis>, that is, the circumscribing sphere of each cell of such a triangulation does not contain any other vertex of the triangulation in its interior. These triangulations are uniquely defined except in degenerate cases where five points are co-spherical. Note however that the CGAL implementation computes a unique triangulation even in these cases.</para><para>This implementation is fully dynamic: it supports insertions of points, vertex removals and displacements of points.</para></sect1>
<sect1 id="index_1Triangulation3secclassRegulartriangulation">
<title>Regular Triangulation</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">Regular_triangulation_3</ref></computeroutput> implements incremental regular triangulations, also known as weighted Delaunay triangulations.</para><para>Let <formula id="7">$ {p}^{(w)}=(p,w_p), p\in\mathbb{R}^3, w_p\in\mathbb{R}$</formula> and <formula id="8">$ {z}^{(w)}=(z,w_z), z\in\mathbb{R}^3, w_z\in\mathbb{R}$</formula> be two weighted points. A weighted point <formula id="9">$ {p}^{(w)}=(p,w_p)$</formula> can also be seen as a sphere of center <formula id="4">$ p$</formula> and radius <formula id="10">$ \sqrt{w_p}$</formula>. The <emphasis>power product</emphasis> between <formula id="11">$ {p}^{(w)}$</formula> and <formula id="12">$ {z}^{(w)}$</formula> is defined as <formula id="13">\[ \Pi({p}^{(w)},{z}^{(w)}) = {\|{p-z}\|^2-w_p-w_z} \]</formula> where <formula id="14">$ \|{p-z}\|$</formula> is the Euclidean distance between <formula id="4">$ p$</formula> and <formula id="15">$ z$</formula>.</para><para>The weighted points <formula id="11">$ {p}^{(w)}$</formula> and <formula id="12">$ {z}^{(w)}$</formula> are said to be <emphasis>orthogonal</emphasis> iff <formula id="86">$ \Pi{({p}^{(w)},{z}^{(w)})} = 0$</formula> (see <ref refid="index_1fig__Triangulation3figortho" kindref="member">fig__Triangulation3figortho</ref>).</para><para><anchor id="index_1fig__Triangulation3figortho"/><image type="html" name="ortho.svg"></image>
 <image type="latex" name="ortho.svg" width="15cm"></image>
  <ref refid="index_1fig__Triangulation3figortho" kindref="member">fig__Triangulation3figortho</ref> Orthogonal weighted points (picture in 2D).  <linebreak/>
</para><para>Four weighted points have a unique common orthogonal weighted point called the <emphasis>power sphere</emphasis>. The weighted point orthogonal to three weighted points in the plane defined by these three points is called the <emphasis>power circle</emphasis>. The <emphasis>power segment</emphasis> will denote the weighted point orthogonal to two weighted points on the line defined by these two points.</para><para>Let <formula id="5">$ {S}^{(w)}$</formula> be a set of weighted points in <formula id="6">$ \mathbb{R}^3$</formula>. A sphere <formula id="12">$ {z}^{(w)}$</formula> is said to be <emphasis>regular</emphasis> if <formula id="87">$ \forall {p}^{(w)}\in{S}^{(w)}, \Pi{({p}^{(w)},{z}^{(w)})}\geq 0$</formula>.</para><para>A triangulation of <formula id="5">$ {S}^{(w)}$</formula> is <emphasis>regular</emphasis> if the power spheres of all simplices are regular.</para><para>The regular triangulation of <formula id="5">$ {S}^{(w)}$</formula> is in fact the projection onto <formula id="6">$ \mathbb{R}^3$</formula> of the convex hull of the four-dimensional points <formula id="88">$ (p,\|p-O\|^2-w_p),$</formula> for <formula id="89">$ {p}^{(w)}=(p,w_p)\in{S}^{(w)}$</formula>. Note that all points of <formula id="5">$ {S}^{(w)}$</formula> do not necessarily appear as vertices of the regular triangulation. To know more about regular triangulations, see for example <ref refid="citelist_1CITEREF_es-itfwr-96" kindref="member">[14]</ref>.</para><para>When all weights are 0, power spheres are nothing more than circumscribing spheres, and the regular triangulation is exactly the Delaunay triangulation.</para><para>The implementation of 3D regular triangulation supports insertions of weighted points, and vertex removals. Displacements are not supported in the current implementation.</para></sect1>
<sect1 id="index_1Triangulation3secdesign">
<title>Software Design</title>
<para>The main classes <computeroutput><ref refid="classCGAL_1_1Triangulation__3" kindref="compound">Triangulation_3</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">Delaunay_triangulation_3</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">Regular_triangulation_3</ref></computeroutput> are connected to each other by the derivation diagram shown in <ref refid="index_1fig__t3_derivation" kindref="member">fig__t3_derivation</ref>. This diagram also shows another class: <computeroutput><ref refid="structCGAL_1_1Triangulation__utils__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">Triangulation_utils_3</ref></computeroutput>, which provides a set of tools operating on the indices of vertices in cells.</para><para><anchor id="index_1fig__t3_derivation"/><image type="html" name="derivation.png"></image>
 <image type="latex" name="derivation.png" width="15cm"></image>
  <ref refid="index_1fig__t3_derivation" kindref="member">fig__t3_derivation</ref> Derivation diagram of the 3D triangulation classes.  <linebreak/>
</para><para>The three main classes (<computeroutput><ref refid="classCGAL_1_1Triangulation__3" kindref="compound">Triangulation_3</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">Delaunay_triangulation_3</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">Regular_triangulation_3</ref></computeroutput>) provide high-level geometric functionality such as location of a point in the triangulation <ref refid="citelist_1CITEREF_cgal:dpt-wt-02" kindref="member">[11]</ref>, insertion and possibly removal of a point <ref refid="citelist_1CITEREF_cgal:dt-pvr3d-03" kindref="member">[8]</ref>, and are responsible for the geometric validity. They are built as layers on top of a triangulation data structure, which stores their combinatorial structure. This separation between the geometry and the combinatorics is reflected in the software design by the fact that these three triangulation classes take the following template parameters :</para><para><itemizedlist>
<listitem>
<para>the <emphasis>geometric traits</emphasis> class, which provides the type of points to use as well as the elementary operations on them (predicates and constructions). The concepts for these parameters are described in more details in Section <ref refid="index_1Triangulation3secTraits" kindref="member">The Geometric Traits Parameter</ref>. </para></listitem>
<listitem>
<para>the <emphasis>triangulation data structure</emphasis> class, which stores their combinatorial structure, described in Section <ref refid="index_1TDS3secdesign" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">Software Design</ref> of Chapter <ref refid="index_1chapterTDS3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">3D Triangulation Data Structure</ref>. </para></listitem>
<listitem>
<para>the <emphasis>location policy</emphasis> tag, which is supported only by the Delaunay triangulation class, described in Section <ref refid="index_1Triangulation3seclocpol" kindref="member">The Location Policy Parameter</ref>. </para></listitem>
</itemizedlist>
</para><para>Optionally, the main Delaunay and regular triangulations algorithms (insert, remove) support multi-core shared-memory architectures to take advantage of available parallelism. For this purpose, a model of the concept <computeroutput><ref refid="classSurjectiveLockDataStructure" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">SurjectiveLockDataStructure</ref></computeroutput> can be given as fourth template parameter; it defaults to <computeroutput><ref refid="classCGAL_1_1Spatial__lock__grid__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Spatial_lock_grid_3</ref></computeroutput>. This data structure allows to lock points with coordinates (x, y, z) in a 3D domain. When a thread owns the lock on a point, no other thread can lock this point. Locking a facet (resp. a cell) boils down to locking all its 3 (resp. 4) incident vertices. See Section <ref refid="index_1Triangulation_3ParallelAlgorithms" kindref="member">Parallel Algorithms</ref> for more details.</para><sect2 id="index_1Triangulation3secTraits">
<title>The Geometric Traits Parameter</title>
<para>The first template parameter of the triangulation class <computeroutput><ref refid="classCGAL_1_1Triangulation__3" kindref="compound">Triangulation_3</ref>&lt;<ref refid="classTriangulationTraits__3" kindref="compound">TriangulationTraits_3</ref>, <ref refid="classTriangulationDataStructure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">TriangulationDataStructure_3</ref>&gt;</computeroutput> is the geometric traits class, described by the concept <computeroutput><ref refid="classTriangulationTraits__3" kindref="compound">TriangulationTraits_3</ref></computeroutput>. It must define the types of the geometric objects (points, segments, triangles and tetrahedra) forming the triangulation together with a few geometric predicates on these objects: orientation in space, orientation in case of coplanar points, order of collinear points.</para><para>In addition to the requirements described before, the geometric traits class of <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">Delaunay_triangulation_3</ref></computeroutput> must define predicates to test for the <emphasis>empty sphere property</emphasis>. It is described by the concept <computeroutput><ref refid="classDelaunayTriangulationTraits__3" kindref="compound">DelaunayTriangulationTraits_3</ref></computeroutput>, which refines <computeroutput><ref refid="classTriangulationTraits__3" kindref="compound">TriangulationTraits_3</ref></computeroutput>.</para><para>In addition to the requirements described before, the geometric traits class of <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">Regular_triangulation_3</ref></computeroutput> must define predicates to test for the <emphasis>power distances</emphasis> and orientation tests for <emphasis>power spheres</emphasis>. It is described by the concept <computeroutput><ref refid="classRegularTriangulationTraits__3" kindref="compound">RegularTriangulationTraits_3</ref></computeroutput>, which refines <computeroutput><ref refid="classTriangulationTraits__3" kindref="compound">TriangulationTraits_3</ref></computeroutput>.</para><para>All kernels provided by CGAL can all be used as models for the geometric traits parameter.</para></sect2>
<sect2 id="index_1Triangulation3sectds">
<title>The Triangulation Data Structure Parameter</title>
<para>The second template parameter of the main classes (<computeroutput><ref refid="classCGAL_1_1Triangulation__3" kindref="compound">Triangulation_3</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">Delaunay_triangulation_3</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">Regular_triangulation_3</ref></computeroutput>) is a triangulation data structure class. This class can be seen as a container for the cells and vertices maintaining incidence and adjacency relations (see Chapter <ref refid="index_1chapterTDS3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">chapterTDS3</ref>). A model of this triangulation data structure is <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">Triangulation_data_structure_3</ref></computeroutput>, and it is described by the <computeroutput><ref refid="classTriangulationDataStructure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">TriangulationDataStructure_3</ref></computeroutput> concept . This model is itself parameterized by a vertex base and a cell base classes, which gives the possibility to customize the vertices and cells used by the triangulation data structure, and hence by the geometric triangulation using it. Depending on the kind of triangulation used, the requirements on the vertex and cell base classes vary, and are expressed by various concepts, following the refinement diagram shown in <ref refid="index_1fig__T3concepthierarchy" kindref="member">fig__T3concepthierarchy</ref>.</para><para><anchor id="index_1fig__T3concepthierarchy"/><image type="html" name="concept_hierarchy.png"></image>
 <image type="latex" name="concept_hierarchy.png" width="15cm"></image>
  <ref refid="index_1fig__T3concepthierarchy" kindref="member">fig__T3concepthierarchy</ref> Concepts refinement hierarchy for the vertex and cell base classes parameters.  <linebreak/>
</para><para>A default value for the triangulation data structure parameter is provided in all the triangulation classes, so it need not be specified by the user unless he wants to use a different triangulation data structure or a different vertex or cell base class.</para></sect2>
<sect2 id="index_1Triangulation3seclocpol">
<title>The Location Policy Parameter</title>
<para>The Delaunay triangulation class supports an optional feature which maintains an additional data structure for fast point location queries. The fast location policy should be used when the user inserts points in a random order or needs to do many unrelated queries. If the user is able to give a good hint to help the point location of its queries (and its newly inserted points), then it should prefer the default policy. In such a case where good hints are provided, the default policy save some memory (few percents), and is faster. Notice that if points are not inserted one by one, but as a range, then a good hint is automatically computed using spatial sort.</para><para>Reading Section <ref refid="index_1Triangulation3seccomplexity" kindref="member">Complexity and Performance</ref> on complexity and performance can help making an informed choice for this parameter.</para><para>The point location strategy can be selected with the third template argument of <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">Delaunay_triangulation_3</ref></computeroutput>, <computeroutput>LocationPolicy</computeroutput>, which enables a fast point location data structure when set to <computeroutput>Fast_location</computeroutput>. By default, it uses <computeroutput>Compact_location</computeroutput>.</para><para>Note that you can specify the <computeroutput>LocationPolicy</computeroutput> parameter without specifying the triangulation data structure, in case you are fine with the default there. In this case, the <computeroutput>LocationPolicy</computeroutput> appears as a second parameter after the geometric traits.The mechanism used behind the scenes to allow this syntactical convenience is called <emphasis>deduced parameters</emphasis>.</para><para>The <computeroutput>Fast_location</computeroutput> policy is implemented using a hierarchy of triangulations; it changes the behavior of functions <computeroutput>locate</computeroutput>, <computeroutput>insert</computeroutput>, <computeroutput>move</computeroutput>, and <computeroutput>remove</computeroutput>. As proved in <ref refid="citelist_1CITEREF_cgal:d-dh-02" kindref="member">[12]</ref>, this structure has an optimal behavior when it is built for Delaunay triangulations.</para><para>In this setting, if you build a triangulation by iteratively inserting points, you should try to shuffle the points beforehand, as the time complexity is guaranteed only for a randomized order. For example, inserting points in lexicographic order is typically much slower. Note that this shuffling is performed internally by the constructor taking a range of points.</para><para>Prior to CGAL 3.6, this functionality was available through the <computeroutput>Triangulation_hierarchy_3</computeroutput> class, which is now deprecated.</para></sect2>
<sect2 id="index_1Triangulation_3FlexibilityoftheDesign">
<title>Flexibility of the Design</title>
<para>In order to satisfy as many uses as possible, a design has been selected that allows to exchange different parts to meet the users&apos; needs, while still re-using a maximum of the provided functionalities. We have already seen that the main triangulation classes are parameterized by a geometric traits class and a triangulation data structure (TDS), so that each of them can be interchanged with alternate implementations.</para><para>The most useful flexibility is the ability given to the user to add his own data in the vertices and cells by providing his own vertex and cell base classes to <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">Triangulation_data_structure_3</ref></computeroutput>. The <ref refid="index_1fig__T3figlayers" kindref="member">fig__T3figlayers</ref> shows in more detail the flexibility that is provided, and the place where the user can insert his own vertex and/or cell base classes.</para><para><anchor id="index_1fig__T3figlayers"/><image type="html" name="design.png"></image>
 <image type="latex" name="design.png" width="15cm"></image>
  <ref refid="index_1fig__T3figlayers" kindref="member">fig__T3figlayers</ref> Triangulation software design.  <linebreak/>
</para><para>The design of the triangulation data structure gives the possibility to store any kind of data, including handles (an entity akin to pointers) directly in the vertex and cell base classes.</para><para>To do so, there are three possibilities. The simplest one is to use the class <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__3" kindref="compound">Triangulation_vertex_base_with_info_3</ref></computeroutput>, and this approach is illustrated in a following subsection <ref refid="index_1Triangulation3secexamplescolor" kindref="member">Adding a Color</ref>. The most complicated one, and probably useless for almost all cases, is to write a vertex base class from scratch, following the documented requirements. This is mostly useless because most of the time it is enough to derive from the models that CGAL provides, and add the desired features. In this case, when the user needs to access some type that depends on the triangulation data structure (typically handles), then he should write something like:</para><para><programlisting><codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;<sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">GT,<sp/>class<sp/>Vb<sp/>=<sp/>Triangulation_vertex_base&lt;GT&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_vertex</highlight></codeline>
<codeline><highlight class="normal">:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Vb</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Point<sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Cell_handle<sp/>Cell_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>TDS2<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Rebind_TDS<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::template<sp/>Rebind_TDS&lt;TDS2&gt;::Other<sp/>Vb2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>My_vertex&lt;GT,<sp/>Vb2&gt;<sp/>Other;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">My_vertex()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal">My_vertex(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;p)<sp/>:<sp/>Vb(p)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal">My_vertex(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;p,<sp/>Cell_handle<sp/>c)<sp/>:<sp/>Vb(p,<sp/>c)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...<sp/></highlight><highlight class="comment">//<sp/>The<sp/>rest<sp/>has<sp/>not<sp/>changed</highlight></codeline>
</programlisting></para><para>The situation is exactly similar for cell base classes. Section <ref refid="index_1TDS3secdesign" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">Software Design</ref> provides more detailed information.</para></sect2>
<sect2 id="index_1Triangulation_3ParallelAlgorithms">
<title>Parallel Algorithms</title>
<para>Parallel algorithms of <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">Delaunay_triangulation_3</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">Regular_triangulation_3</ref></computeroutput> are enabled if the <computeroutput><ref refid="classTriangulationDataStructure__3_1a540c1ac639e9ac22317900eba52dc92a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">TriangulationDataStructure_3::Concurrency_tag</ref></computeroutput> type is <computeroutput><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Parallel_tag</ref></computeroutput> and a reference to a lock data structure instance is provided via the constructor or by using <computeroutput><ref refid="classCGAL_1_1Triangulation__3_1afba384e440c57f3bb0a71e4b4f7f9944" kindref="member">Triangulation_3::set_lock_data_structure</ref></computeroutput>. This data structure must be a model of the concept <computeroutput><ref refid="classSurjectiveLockDataStructure" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">SurjectiveLockDataStructure</ref></computeroutput> and can be optionally given as a template parameter of the triangulation; it defaults to <computeroutput><ref refid="classCGAL_1_1Spatial__lock__grid__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Spatial_lock_grid_3</ref></computeroutput>.</para><para>Note that the parallel Delaunay triangulation must use the default compact location policy (and not the fast one). If those conditions are fulfilled, the insertion/removal of a range of points will be performed in parallel, and the individual insert/remove operations will be optionally thread-safe.</para><para>Parallel algorithms require the program to be linked against the <ulink url="http://www.threadingbuildingblocks.org">Intel TBB library</ulink>. To control the number of threads used, the user may use the tbb::task_scheduler_init class. See the <ulink url="http://www.threadingbuildingblocks.org/documentation">TBB documentation</ulink> for more details.</para></sect2>
</sect1>
<sect1 id="index_1Triangulation3secexamples">
<title>Examples</title>
<sect2 id="index_1Triangulation_3BasicExample">
<title>Basic Example</title>
<para>This example shows the incremental construction of a 3D triangulation, the location of a point and how to perform elementary operations on indices in a cell. It uses the default parameter of the <computeroutput><ref refid="classCGAL_1_1Triangulation__3" kindref="compound">Triangulation_3</ref></computeroutput> class.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2simple_triangulation_3_8cpp-example" kindref="compound">Triangulation_3/simple_triangulation_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__3" kindref="compound">CGAL::Triangulation_3&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Cell_handle<sp/><sp/><sp/><sp/>Cell_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Vertex_handle<sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Locate_type<sp/><sp/><sp/><sp/>Locate_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>construction<sp/>from<sp/>a<sp/>list<sp/>of<sp/>points<sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point&gt;<sp/>L;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>L.push_front(Point(0,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>L.push_front(Point(1,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>L.push_front(Point(0,1,0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>T(L.begin(),<sp/>L.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation::size_type<sp/>n<sp/>=<sp/>T.number_of_vertices();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>insertion<sp/>from<sp/>a<sp/>vector<sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>V(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>V[0]<sp/>=<sp/>Point(0,0,1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>V[1]<sp/>=<sp/>Point(1,1,1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>V[2]<sp/>=<sp/>Point(2,2,2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>n<sp/>=<sp/>n<sp/>+<sp/>T.insert(V.begin(),<sp/>V.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>n<sp/>==<sp/>6<sp/>);<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>6<sp/>points<sp/>have<sp/>been<sp/>inserted</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.is_valid()<sp/>);<sp/></highlight><highlight class="comment">//<sp/>checking<sp/>validity<sp/>of<sp/>T</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Locate_type<sp/>lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>li,<sp/>lj;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p(0,0,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Cell_handle<sp/>c<sp/>=<sp/>T.locate(p,<sp/>lt,<sp/>li,<sp/>lj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>p<sp/>is<sp/>the<sp/>vertex<sp/>of<sp/>c<sp/>of<sp/>index<sp/>li<sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>lt<sp/>==<sp/>Triangulation::VERTEX<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>c-&gt;vertex(li)-&gt;point()<sp/>==<sp/>p<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v<sp/>=<sp/>c-&gt;vertex(<sp/>(li+1)&amp;3<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>v<sp/>is<sp/>another<sp/>vertex<sp/>of<sp/>c</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Cell_handle<sp/>nc<sp/>=<sp/>c-&gt;neighbor(li);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>nc<sp/>=<sp/>neighbor<sp/>of<sp/>c<sp/>opposite<sp/>to<sp/>the<sp/>vertex<sp/>associated<sp/>with<sp/>p</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>nc<sp/>must<sp/>have<sp/>vertex<sp/>v<sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nli;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>nc-&gt;has_vertex(<sp/>v,<sp/>nli<sp/>)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>nli<sp/>is<sp/>the<sp/>index<sp/>of<sp/>v<sp/>in<sp/>nc</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>oFileT(</highlight><highlight class="stringliteral">&quot;output&quot;</highlight><highlight class="normal">,std::ios::out);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>writing<sp/>file<sp/>output;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>oFileT<sp/>&lt;&lt;<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>T1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>iFileT(</highlight><highlight class="stringliteral">&quot;output&quot;</highlight><highlight class="normal">,std::ios::in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>reading<sp/>file<sp/>output;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>iFileT<sp/>&gt;&gt;<sp/>T1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T1.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T1.number_of_vertices()<sp/>==<sp/>T.number_of_vertices()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T1.number_of_cells()<sp/>==<sp/>T.number_of_cells()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Triangulation_3ChangingtheVertexBase">
<title>Changing the Vertex Base</title>
<para>The following two examples show how the user can plug his own vertex base in a triangulation. Changing the cell base is similar.</para><sect3 id="index_1Triangulation3secexamplescolor">
<title>Adding a Color</title>
<para>When the user doesn&apos;t need to add a type in a vertex which depends on the <computeroutput><ref refid="classTriangulationDataStructure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">TriangulationDataStructure_3</ref></computeroutput> (e.g. a <computeroutput>Vertex_handle</computeroutput> or <computeroutput>Cell_handle</computeroutput>), then he can use the <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__3" kindref="compound">Triangulation_vertex_base_with_info_3</ref></computeroutput> class to add his own information easily in the vertices. The example below shows how to add a <computeroutput><ref refid="classCGAL_1_1Color" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">Color</ref></computeroutput> this way.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2color_8cpp-example" kindref="compound">Triangulation_3/color.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_with_info_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Color.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__3" kindref="compound">CGAL::Triangulation_vertex_base_with_info_3&lt;CGAL::Color, K&gt;</ref><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Delaunay_triangulation_cell_base_3&lt;K&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">CGAL::Triangulation_data_structure_3&lt;Vb, Cb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">CGAL::Delaunay_triangulation_3&lt;K, Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.<ref refid="classCGAL_1_1Delaunay__triangulation__3_1a5283a16d3299df75233d954deba71600" kindref="member">insert</ref>(Point(0,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(1,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(0,1,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(0,0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(2,2,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(-1,0,1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>the<sp/>color<sp/>of<sp/>finite<sp/>vertices<sp/>of<sp/>degree<sp/>6<sp/>to<sp/>red.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay::Finite_vertices_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>T.finite_vertices_begin();<sp/>vit<sp/>!=<sp/>T.finite_vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(T.degree(vit)<sp/>==<sp/>6)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vit-&gt;info()<sp/>=<sp/>CGAL::RED;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1Triangulation_3AddingHandles">
<title>Adding Handles</title>
<para>When the user needs to add a type in a vertex which depends on the <computeroutput><ref refid="classTriangulationDataStructure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">TriangulationDataStructure_3</ref></computeroutput> (e.g. a <computeroutput>Vertex_handle</computeroutput> or <computeroutput>Cell_handle</computeroutput>), then he has to derive his own vertex base class, as the following example shows.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2adding_handles_3_8cpp-example" kindref="compound">Triangulation_3/adding_handles_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>GT,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Vb<sp/>=<sp/>CGAL::Triangulation_vertex_base_3&lt;GT&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_vertex_base</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Vb</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Vertex_handle<sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Cell_handle<sp/><sp/><sp/><sp/>Cell_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>TDS2<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Rebind_TDS<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::template<sp/>Rebind_TDS&lt;TDS2&gt;::Other<sp/><sp/>Vb2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>My_vertex_base&lt;GT,<sp/>Vb2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Other;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_base()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_base(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p)<sp/>:<sp/>Vb(p)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_base(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p,<sp/>Cell_handle<sp/>c)<sp/>:<sp/>Vb(p,<sp/>c)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>vh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Cell_handle<sp/><sp/><sp/><sp/><sp/>ch;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Delaunay_triangulation_cell_base_3&lt;K&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_3&lt;My_vertex_base&lt;K&gt;,<sp/>Cb&gt;<sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">CGAL::Delaunay_triangulation_3&lt;K, Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v0<sp/>=<sp/>T.<ref refid="classCGAL_1_1Delaunay__triangulation__3_1a5283a16d3299df75233d954deba71600" kindref="member">insert</ref>(Point(0,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v1<sp/>=<sp/>T.insert(Point(1,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v2<sp/>=<sp/>T.insert(Point(0,1,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v3<sp/>=<sp/>T.insert(Point(0,0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v4<sp/>=<sp/>T.insert(Point(2,2,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v5<sp/>=<sp/>T.insert(Point(-1,0,1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Now<sp/>we<sp/>can<sp/>link<sp/>the<sp/>vertices<sp/>as<sp/>we<sp/>like.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v0-&gt;vh<sp/>=<sp/>v1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v1-&gt;vh<sp/>=<sp/>v2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v2-&gt;vh<sp/>=<sp/>v3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v3-&gt;vh<sp/>=<sp/>v4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v4-&gt;vh<sp/>=<sp/>v5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v5-&gt;vh<sp/>=<sp/>v0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
</sect2>
<sect2 id="index_1Triangulation_3SettingInformationWhileInserting">
<title>Setting Information While Inserting a Range of Points</title>
<para>The most efficient method to insert (weighted) points in a Delaunay (or regular) triangulation is to provide an iterator range over (weighted) points to the insert function. However, an iterator range of (weighted) points does not allow to set different information to each vertex. To solve this problem, in the case the vertex type of the triangulation is a model of the concept <computeroutput><ref refid="classTriangulationVertexBaseWithInfo__3" kindref="compound">TriangulationVertexBaseWithInfo_3</ref></computeroutput> (such as <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__3" kindref="compound">Triangulation_vertex_base_with_info_3</ref></computeroutput>), we provide three examples doing the same operation: set an unsigned integer as the information of each vertex. The value of this unsigned integer is the initial order of the corresponding point given in the range.</para><sect3 id="index_1Triangulation_3UsinganIteratorOverPairs">
<title>Using an Iterator Over Pairs</title>
<para>Each point and its information are gathered into a pair. We provide the constructor of the triangulation (which is calling the <computeroutput>insert</computeroutput> function) with a range of such pairs. <linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2info_insert_with_pair_iterator_8cpp-example" kindref="compound">Triangulation_3/info_insert_with_pair_iterator.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_with_info_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__3" kindref="compound">CGAL::Triangulation_vertex_base_with_info_3&lt;unsigned, K&gt;</ref><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Delaunay_triangulation_cell_base_3&lt;K&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">CGAL::Triangulation_data_structure_3&lt;Vb, Cb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//Use<sp/>the<sp/>Fast_location<sp/>tag.<sp/>Default<sp/>or<sp/>Compact_location<sp/>works<sp/>too.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">CGAL::Delaunay_triangulation_3&lt;K, Tds, CGAL::Fast_location&gt;</ref><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;<sp/>std::pair&lt;Point,unsigned&gt;<sp/>&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(0,0,0),0)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(1,0,0),1)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(0,1,0),2)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(0,0,1),3)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(2,2,2),4)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(<sp/>std::make_pair(Point(-1,0,1),5)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>T(<sp/>points.begin(),points.end()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>T.number_of_vertices()<sp/>==<sp/>6<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>that<sp/>the<sp/>info<sp/>was<sp/>correctly<sp/>set.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay::Finite_vertices_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>T.finite_vertices_begin();<sp/>vit<sp/>!=<sp/>T.finite_vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>points[<sp/>vit-&gt;info()<sp/>].first<sp/>!=<sp/>vit-&gt;point()<sp/>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error<sp/>different<sp/>info&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>exit(EXIT_FAILURE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;OK&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1Triangulation_3UsingtheBoostZipIterator">
<title>Using the Boost Zip Iterator</title>
<para>Information and points are in separate containers. We use <ulink url="http://www.boost.org/libs/iterator/doc/index.html#specialized-adaptors"><computeroutput>boost::zip_iterator</computeroutput></ulink> to provide an iterator gathering them.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2info_insert_with_zip_iterator_8cpp-example" kindref="compound">Triangulation_3/info_insert_with_zip_iterator.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_with_info_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/iterator/zip_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__3" kindref="compound">CGAL::Triangulation_vertex_base_with_info_3&lt;unsigned, K&gt;</ref><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Delaunay_triangulation_cell_base_3&lt;K&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">CGAL::Triangulation_data_structure_3&lt;Vb, Cb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">CGAL::Delaunay_triangulation_3&lt;K, Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;unsigned&gt;<sp/>indices;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(0,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(1,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(0,1,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(0,0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(2,2,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(-1,0,1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>T(<sp/>boost::make_zip_iterator(boost::make_tuple(<sp/>points.begin(),indices.begin()<sp/>)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::make_zip_iterator(boost::make_tuple(<sp/>points.end(),indices.end()<sp/>)<sp/>)<sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>T.number_of_vertices()<sp/>==<sp/>6<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>that<sp/>the<sp/>info<sp/>was<sp/>correctly<sp/>set.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay::Finite_vertices_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>T.finite_vertices_begin();<sp/>vit<sp/>!=<sp/>T.finite_vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>points[<sp/>vit-&gt;info()<sp/>]<sp/>!=<sp/>vit-&gt;point()<sp/>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error<sp/>different<sp/>info&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>exit(EXIT_FAILURE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1Triangulation_3UsingtheBoostTransformIterator">
<title>Using the Boost Transform Iterator</title>
<para>We define a functor <computeroutput>Auto_count</computeroutput> used together with <ulink url="http://www.boost.org/libs/iterator/doc/index.html#specialized-adaptors"><computeroutput>boost::transform_iterator</computeroutput></ulink> to set the order of each point in the range. Note that this is correct because the iterator is dereferenced only once per point during the insertion. <linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2info_insert_with_transform_iterator_8cpp-example" kindref="compound">Triangulation_3/info_insert_with_transform_iterator.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_with_info_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/iterator/transform_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__3" kindref="compound">CGAL::Triangulation_vertex_base_with_info_3&lt;unsigned, K&gt;</ref><sp/><sp/><sp/><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Delaunay_triangulation_cell_base_3&lt;K&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">CGAL::Triangulation_data_structure_3&lt;Vb, Cb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">CGAL::Delaunay_triangulation_3&lt;K, Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//a<sp/>functor<sp/>that<sp/>returns<sp/>a<sp/>std::pair&lt;Point,unsigned&gt;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//the<sp/>unsigned<sp/>integer<sp/>is<sp/>incremented<sp/>at<sp/>each<sp/>call<sp/>to<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//operator()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Auto_count<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1cpp98_1_1unary__function" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp98::unary_function</ref>&lt;const<sp/>Point&amp;,std::pair&lt;Point,unsigned&gt;<sp/>&gt;{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">mutable</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Auto_count()<sp/>:<sp/>i(0){}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::pair&lt;Point,unsigned&gt;<sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_pair(p,i++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(0,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(1,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(0,1,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(0,0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(2,2,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(-1,0,1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>T(<sp/>boost::make_transform_iterator(points.begin(),Auto_count()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::make_transform_iterator(points.end(),<sp/><sp/>Auto_count()<sp/>)<sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(<sp/>T.number_of_vertices()<sp/>==<sp/>6<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>that<sp/>the<sp/>info<sp/>was<sp/>correctly<sp/>set.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay::Finite_vertices_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>T.finite_vertices_begin();<sp/>vit<sp/>!=<sp/>T.finite_vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>points[<sp/>vit-&gt;info()<sp/>]<sp/>!=<sp/>vit-&gt;point()<sp/>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error<sp/>different<sp/>info&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>exit(EXIT_FAILURE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;OK&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
</sect2>
<sect2 id="index_1Triangulation3secsimplex">
<title>The Simplex Class</title>
<para>The triangulation defines a <computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a431de9481031045367856fa156fc643f" kindref="member">Triangulation_3::Simplex</ref></computeroutput> class that represents a simplex (vertex, edge, facet or cell). This example demonstrates how simplices can be stored in a set.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2simplex_8cpp-example" kindref="compound">Triangulation_3/simplex.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;set&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__3" kindref="compound">CGAL::Triangulation_3&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Finite_vertices_iterator<sp/>Finite_vertices_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Finite_edges_iterator<sp/>Finite_edges_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Finite_facets_iterator<sp/>Finite_facets_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Finite_cells_iterator<sp/>Finite_cells_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Simplex<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Simplex;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Locate_type<sp/><sp/><sp/><sp/>Locate_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>construction<sp/>from<sp/>a<sp/>list<sp/>of<sp/>points<sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point&gt;<sp/>L;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>L.push_front(Point(0,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>L.push_front(Point(1,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>L.push_front(Point(0,1,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>L.push_front(Point(0,1,1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>T(L.begin(),<sp/>L.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::set&lt;Simplex&gt;<sp/>simplices;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Finite_vertices_iterator<sp/>vit<sp/>=<sp/>T.finite_vertices_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>simplices.insert(Simplex(vit));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Finite_cells_iterator<sp/>cit<sp/>=<sp/>T.finite_cells_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>simplices.insert(Simplex(cit));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Finite_edges_iterator<sp/>eit<sp/>=<sp/>T.finite_edges_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>simplices.insert(Simplex(*eit));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Finite_facets_iterator<sp/>fit<sp/>=<sp/>T.finite_facets_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>simplices.insert(Simplex(*fit));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::set&lt;Simplex&gt;::iterator<sp/>it<sp/>=<sp/>simplices.begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>!=<sp/>simplices.end();<sp/>it++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>it-&gt;dimension()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Triangulation3exfastlocation">
<title>Fast Point Location for Delaunay Triangulations</title>
<para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2fast_location_3_8cpp-example" kindref="compound">Triangulation_3/fast_location_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Random.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">CGAL::Delaunay_triangulation_3&lt;K, CGAL::Fast_location&gt;</ref><sp/><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>generating<sp/>points<sp/>on<sp/>a<sp/>grid.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>z=0<sp/>;<sp/>z&lt;20<sp/>;<sp/>z++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y=0<sp/>;<sp/>y&lt;20<sp/>;<sp/>y++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x=0<sp/>;<sp/>x&lt;20<sp/>;<sp/>x++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P.push_back(Point(x,y,z));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>building<sp/>their<sp/>Delaunay<sp/>triangulation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>T(P.begin(),<sp/>P.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.number_of_vertices()<sp/>==<sp/>8000<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>performing<sp/>nearest<sp/>vertex<sp/>queries<sp/>to<sp/>a<sp/>series<sp/>of<sp/>random<sp/>points,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>which<sp/>is<sp/>a<sp/>case<sp/>where<sp/>the<sp/>Fast_location<sp/>policy<sp/>is<sp/>beneficial.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;10000;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T.nearest_vertex(Point(CGAL::get_default_random().get_double(0,<sp/>20),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::get_default_random().get_double(0,<sp/>20),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::get_default_random().get_double(0,<sp/>20)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Triangulation_3FindingtheCellsinConflict">
<title>Finding the Cells in Conflict with a Point in a Delaunay Triangulation</title>
<para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2find_conflicts_3_8cpp-example" kindref="compound">Triangulation_3/find_conflicts_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">CGAL::Delaunay_triangulation_3&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Delaunay;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Cell_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cell_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Delaunay::Facet<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Facet;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Delaunay<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_sphere_3&lt;Point&gt;<sp/>rnd;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>First,<sp/>make<sp/>sure<sp/>the<sp/>triangulation<sp/>is<sp/>3D.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.<ref refid="classCGAL_1_1Delaunay__triangulation__3_1a5283a16d3299df75233d954deba71600" kindref="member">insert</ref>(Point(0,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(1,0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(0,1,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert(Point(0,0,1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(T.dimension()<sp/>==<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Inserts<sp/>100<sp/>random<sp/>points<sp/>if<sp/>and<sp/>only<sp/>if<sp/>their<sp/>insertion</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>in<sp/>the<sp/>Delaunay<sp/>tetrahedralization<sp/>conflicts<sp/>with</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>an<sp/>even<sp/>number<sp/>of<sp/>cells.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>!=<sp/>100;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point<sp/>p<sp/>=<sp/>*rnd++;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Locate<sp/>the<sp/>point</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Delaunay::Locate_type<sp/>lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>li,<sp/>lj;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Cell_handle<sp/>c<sp/>=<sp/>T.locate(p,<sp/>lt,<sp/>li,<sp/>lj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lt<sp/>==<sp/>Delaunay::VERTEX)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;<sp/></highlight><highlight class="comment">//<sp/>Point<sp/>already<sp/>exists</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>cells<sp/>that<sp/>conflict<sp/>with<sp/>p<sp/>in<sp/>a<sp/>vector<sp/>V,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>a<sp/>facet<sp/>on<sp/>the<sp/>boundary<sp/>of<sp/>this<sp/>hole<sp/>in<sp/>f.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Cell_handle&gt;<sp/>V;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Facet<sp/>f;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T.find_conflicts(p,<sp/>c,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Oneset__iterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Oneset_iterator&lt;Facet&gt;</ref>(f),<sp/></highlight><highlight class="comment">//<sp/>Get<sp/>one<sp/>boundary<sp/>facet</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(V));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Conflict<sp/>cells<sp/>in<sp/>V</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((V.size()<sp/>&amp;<sp/>1)<sp/>==<sp/>0)<sp/><sp/></highlight><highlight class="comment">//<sp/>Even<sp/>number<sp/>of<sp/>conflict<sp/>cells<sp/>?</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>T.insert_in_hole(p,<sp/>V.begin(),<sp/>V.end(),<sp/>f.first,<sp/>f.second);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Final<sp/>triangulation<sp/>has<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>T.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Triangulation_3RegularTriangulation">
<title>Regular Triangulation</title>
<sect3 id="index_1Triangulation_3RegularTriangulationDefaults">
<title>Regular Triangulation with Defaults</title>
<para>This example shows the building of a regular triangulation. In this triangulation, points have an associated weight, and some points can be hidden and do not result in vertices in the triangulation.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2regular_3_8cpp-example" kindref="compound">Triangulation_3/regular_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Regular_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Weight;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Weighted_point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Weighted_point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">CGAL::Regular_triangulation_3&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rt::Vertex_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rt::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>generate<sp/>points<sp/>on<sp/>a<sp/>3D<sp/>grid</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Weighted_point&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number_of_points<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>z=0<sp/>;<sp/>z&lt;5<sp/>;<sp/>z++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y=0<sp/>;<sp/>y&lt;5<sp/>;<sp/>y++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x=0<sp/>;<sp/>x&lt;5<sp/>;<sp/>x++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point<sp/>p(x,<sp/>y,<sp/>z);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Weight<sp/>w<sp/>=<sp/>(x+y-z*y*x)*2.0;<sp/></highlight><highlight class="comment">//<sp/>let&apos;s<sp/>say<sp/>this<sp/>is<sp/>the<sp/>weight.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P.push_back(Weighted_point(p,<sp/>w));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++number_of_points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rt<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>insert<sp/>all<sp/>points<sp/>in<sp/>a<sp/>row<sp/>(this<sp/>is<sp/>faster<sp/>than<sp/>one<sp/>insert()<sp/>at<sp/>a<sp/>time).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T.insert<sp/>(P.begin(),<sp/>P.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.dimension()<sp/>==<sp/>3<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>vertices<sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>T.number_of_vertices()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>removal<sp/>of<sp/>all<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(T.number_of_vertices()<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T.remove<sp/>(T.finite_vertices_begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>count<sp/>==<sp/>number_of_points<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1Triangulation_3RegularTriangulationInfo">
<title>Regular Triangulation with Custom Vertex</title>
<para>This example shows that one must use the class <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__vertex__base__3" kindref="compound">Regular_triangulation_vertex_base_3</ref></computeroutput> as vertex base class, if one has to specifiy the template parameter.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2regular_with_info_3_8cpp-example" kindref="compound">Triangulation_3/regular_with_info_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Regular_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Regular_triangulation_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Regular_triangulation_vertex_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_with_info_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Weight;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Weighted_point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Weighted_point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Regular_triangulation_vertex_base_3&lt;K&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vb0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__3" kindref="compound">CGAL::Triangulation_vertex_base_with_info_3&lt;int, K, Vb0&gt;</ref><sp/>Vb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Regular_triangulation_cell_base_3&lt;K&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cb;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">CGAL::Triangulation_data_structure_3&lt;Vb,Cb&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">CGAL::Regular_triangulation_3&lt;K, Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Weighted_point<sp/>wp(<ref refid="group__kernel__enums_1ga9d272a8e3a8080b851741b6d3a44afdc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::ORIGIN</ref>,1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rt<sp/>rt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rt.insert(wp);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>rt.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
</sect2>
<sect2 id="index_1Triangulation_3ParallelDelaunay">
<title>Parallel Insertion in Delaunay Triangulation</title>
<para>This example shows the parallel building of a Delaunay triangulation.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2parallel_insertion_in_delaunay_3_8cpp-example" kindref="compound">Triangulation_3/parallel_insertion_in_delaunay_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_cell_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Delaunay<sp/>T3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">CGAL::Triangulation_data_structure_3</ref>&lt;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::Triangulation_vertex_base_3&lt;K&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::Delaunay_triangulation_cell_base_3&lt;K&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref>&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">CGAL::Delaunay_triangulation_3&lt;K, Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Triangulation;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>NUM_INSERTED_POINTS<sp/>=<sp/>5000;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_cube_3&lt;Point&gt;<sp/>rnd(1.);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construction<sp/>from<sp/>a<sp/>vector<sp/>of<sp/>1,000,000<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>V;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>V.reserve(NUM_INSERTED_POINTS);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>!=<sp/>NUM_INSERTED_POINTS;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>V.push_back(*rnd++);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>locking<sp/>data-structure,<sp/>using<sp/>the<sp/>bounding-box<sp/>of<sp/>the<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation::Lock_data_structure<sp/>locking_ds(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Bbox__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Bbox_3</ref>(-1.,<sp/>-1.,<sp/>-1.,<sp/>1.,<sp/>1.,<sp/>1.),<sp/>50);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>triangulation<sp/>in<sp/>parallel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>T(V.begin(),<sp/>V.end(),<sp/>&amp;locking_ds);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(T.is_valid());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/>//CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Triangulation_3ParallelRegular">
<title>Parallel Insertion and Removal in Regular Triangulation</title>
<para>This example shows the parallel building of a regular triangulation, followed by the parallel removal of the first 100,000 vertices.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2parallel_insertion_and_removal_in_regular_3_8cpp-example" kindref="compound">Triangulation_3/parallel_insertion_and_removal_in_regular_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Regular_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Regular<sp/>T3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">CGAL::Triangulation_data_structure_3</ref>&lt;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::Regular_triangulation_vertex_base_3&lt;K&gt;,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::Regular_triangulation_cell_base_3&lt;K&gt;,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref>&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">CGAL::Regular_triangulation_3&lt;K, Tds&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rt::Bare_point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bare_point;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rt::Weighted_point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Weighted_point;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rt::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>NUM_INSERTED_POINTS<sp/>=<sp/>5000;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_cube_3&lt;Bare_point&gt;<sp/>rnd(1.);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construction<sp/>from<sp/>a<sp/>vector<sp/>of<sp/>1,000,000<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Weighted_point&gt;<sp/>V;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>V.reserve(NUM_INSERTED_POINTS);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>!=<sp/>NUM_INSERTED_POINTS;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>V.push_back(Weighted_point(*rnd++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>locking<sp/>data-structure,<sp/>using<sp/>the<sp/>bounding-box<sp/>of<sp/>the<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rt::Lock_data_structure<sp/>locking_ds(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Bbox__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Bbox_3</ref>(-1.,<sp/>-1.,<sp/>-1.,<sp/>1.,<sp/>1.,<sp/>1.),<sp/>50);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Contruct<sp/>the<sp/>triangulation<sp/>in<sp/>parallel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construction<sp/>and<sp/>insertion&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rt<sp/>rtr(V.begin(),<sp/>V.end(),<sp/>&amp;locking_ds);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(rtr.is_valid());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Remove&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>the<sp/>first<sp/>1/10<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Vertex_handle&gt;<sp/>vertices_to_remove;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rt::Finite_vertices_iterator<sp/>vit<sp/>=<sp/>rtr.finite_vertices_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0<sp/>;<sp/>i<sp/>&lt;<sp/>NUM_INSERTED_POINTS/10<sp/>;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertices_to_remove.push_back(vit++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Parallel<sp/>remove</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rtr.remove(vertices_to_remove.begin(),<sp/>vertices_to_remove.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(rtr.is_valid());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/>//CGAL_LINKED_WITH_TBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Triangulation3Draw">
<title>Draw a 3D Triangulation</title>
<para><anchor id="index_1ssecDrawT3"/> A 3D triangulation can be visualized by calling the <computeroutput><ref refid="group__PkgDrawTriangulation2_1ga5b2aa57d37e1b52c7f4a3a879fd40dfc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::draw()</ref></computeroutput> function as shown in the following example. This function opens a new window showing the given 3D triangulation. The function is blocking, that is the program continues as soon as the user closes the window.</para><para><linebreak/>
<bold>File</bold> <ref refid="Triangulation_3_2draw_triangulation_3_8cpp-example" kindref="compound">Triangulation_3/draw_triangulation_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Delaunay_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">CGAL::Delaunay_triangulation_3&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DT3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_3&lt;double,K::Point_3&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;K::Point_3&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_sphere_3&lt;K::Point_3,Creator&gt;<sp/>g(1.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__STLAlgos_1gadba21cc5c30a79519438dfe0f9264255" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::copy_n</ref>(g,<sp/>50,<sp/>std::back_inserter(points));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DT3<sp/>dt3(points.begin(),<sp/>points.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgDrawTriangulation2_1ga5b2aa57d37e1b52c7f4a3a879fd40dfc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">CGAL::draw</ref>(dt3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This function requires CGAL_Qt5, and is only available if the flag CGAL_USE_BASIC_VIEWER is defined at compile time.</para><para><anchor id="index_1fig__fig_draw_triangulation_3"/><image type="html" name="draw_triangulation_3.png"></image>
 <image type="latex" name="draw_triangulation_3.png" width="15cm"></image>
  <ref refid="index_1fig__fig_draw_triangulation_3" kindref="member">fig__fig_draw_triangulation_3</ref> Result of the run of the draw_triangulation_3 program. A window shows the 3D triangulation and allows to navigate through the 3D scene.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1Triangulation3seccomplexity">
<title>Complexity and Performance</title>
<para>In 3D, the worst case complexity of a triangulation is quadratic in the number of points. For Delaunay triangulations, this bound is reached in cases such as points equally distributed on two non-coplanar lines. However, the good news is that, in many cases, the complexity of a Delaunay triangulation is linear or close to linear in the number of points. Several articles <ref refid="citelist_1CITEREF_d-hdvdl-89" kindref="member">[13]</ref>, <ref refid="citelist_1CITEREF_e-dpssdt-02" kindref="member">[15]</ref>, <ref refid="citelist_1CITEREF_geometrica-5986i" kindref="member">[1]</ref>, <ref refid="citelist_1CITEREF_prisme-4453a" kindref="member">[2]</ref>, <ref refid="citelist_1CITEREF_prisme-abl-03" kindref="member">[3]</ref> have proved such good complexity bounds for specific point distributions, such as points distributed on surfaces under some conditions.</para><sect2 id="index_1Triangulation_3RunningTime">
<title>Running Time</title>
<para>There are several algorithms provided in this package. We will focus here on the following ones and give practical numbers on their efficiency : <itemizedlist>
<listitem>
<para>construction of a triangulation from a range of points, </para></listitem>
<listitem>
<para>location of a point (using the <computeroutput>locate</computeroutput> function), </para></listitem>
<listitem>
<para>removal of a vertex (using the <computeroutput>remove</computeroutput> function). </para></listitem>
</itemizedlist>
</para><para>We will use the following types of triangulations, using <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput> as geometric traits: <itemizedlist>
<listitem>
<para><bold>Delaunay</bold> : <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">Delaunay_triangulation_3</ref></computeroutput> </para></listitem>
<listitem>
<para><bold>Delaunay - Fast location</bold> : <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">Delaunay_triangulation_3</ref></computeroutput> with <computeroutput>Fast_location</computeroutput> </para></listitem>
<listitem>
<para><bold>Regular</bold> : <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">Regular_triangulation_3</ref></computeroutput> (default setting : memorize hidden points) </para></listitem>
<listitem>
<para><bold>Regular - No hidden points</bold> : <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">Regular_triangulation_3</ref></computeroutput> with hidden points discarded. </para></listitem>
</itemizedlist>
</para><para><ref refid="index_1fig__Triangulation3figbenchmarks" kindref="member">fig__Triangulation3figbenchmarks</ref> shows, for all these types of triangulations, the times in seconds taken to build a triangulation from a given number of points, then the average time to perform one point location in triangulations of various sizes, and the average time to perform one vertex removal (which is largely independent on the size of the triangulation).</para><para>The data sets used here are points randomly distributed in the unit cube (the coordinates are generated using the <computeroutput>drand48</computeroutput> C function). In the weighted case, the weights are all zero, which means that there are actually no hidden points during execution.</para><para>The measurements have been performed using CGAL 3.6, using the Gnu C++ compiler version 4.3.2, under Linux (Fedora 10 distribution), with the compilation options <computeroutput>-O3 -DCGAL_NDEBUG</computeroutput>. The computer used was equipped with a 64bit Intel Xeon 3GHz processor and 32GB of RAM (a recent desktop machine as of 2009).</para><para><anchor id="index_1fig__Triangulation3figbenchmarks"/><center> <table rows="20" cols="5"><row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para></para><para></para></entry><entry thead="no"><para><bold>Delaunay</bold> </para></entry><entry thead="no"><para><bold>Delaunay</bold> </para></entry><entry thead="no"><para><bold>Regular</bold> </para></entry><entry thead="no"><para><bold>Regular</bold> </para></entry></row>
<row>
<entry thead="no"><para></para><para></para></entry><entry thead="no"><para></para><para></para></entry><entry thead="no"><para><bold>Fast location</bold> </para></entry><entry thead="no"><para></para><para></para></entry><entry thead="no"><para><bold>No hidden points</bold> </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para>Construction from <formula id="90">$ 10^2$</formula> points </para></entry><entry thead="no"><para>0.00054 </para></entry><entry thead="no"><para>0.000576 </para></entry><entry thead="no"><para>0.000948 </para></entry><entry thead="no"><para>0.000955 </para></entry></row>
<row>
<entry thead="no"><para>Construction from <formula id="91">$ 10^3$</formula> points </para></entry><entry thead="no"><para>0.00724 </para></entry><entry thead="no"><para>0.00748 </para></entry><entry thead="no"><para>0.0114 </para></entry><entry thead="no"><para>0.0111 </para></entry></row>
<row>
<entry thead="no"><para>Construction from <formula id="92">$ 10^4$</formula> points </para></entry><entry thead="no"><para>0.0785 </para></entry><entry thead="no"><para>0.0838 </para></entry><entry thead="no"><para>0.122 </para></entry><entry thead="no"><para>0.117 </para></entry></row>
<row>
<entry thead="no"><para>Construction from <formula id="93">$ 10^5$</formula> points </para></entry><entry thead="no"><para>0.827 </para></entry><entry thead="no"><para>0.878 </para></entry><entry thead="no"><para>1.25 </para></entry><entry thead="no"><para>1.19 </para></entry></row>
<row>
<entry thead="no"><para>Construction from <formula id="94">$ 10^6$</formula> points </para></entry><entry thead="no"><para>8.5 </para></entry><entry thead="no"><para>9.07 </para></entry><entry thead="no"><para>12.6 </para></entry><entry thead="no"><para>12.2 </para></entry></row>
<row>
<entry thead="no"><para>Construction from <formula id="95">$ 10^7$</formula> points </para></entry><entry thead="no"><para>87.4 </para></entry><entry thead="no"><para>92.5 </para></entry><entry thead="no"><para>129 </para></entry><entry thead="no"><para>125 </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para>Point location in <formula id="90">$ 10^2$</formula> points </para></entry><entry thead="no"><para>9.93e-07 </para></entry><entry thead="no"><para>1.06e-06 </para></entry><entry thead="no"><para>7.19e-06 </para></entry><entry thead="no"><para>6.99e-06 </para></entry></row>
<row>
<entry thead="no"><para>Point location in <formula id="91">$ 10^3$</formula> points </para></entry><entry thead="no"><para>2.25e-06 </para></entry><entry thead="no"><para>1.93e-06 </para></entry><entry thead="no"><para>1.73e-05 </para></entry><entry thead="no"><para>1.76e-05 </para></entry></row>
<row>
<entry thead="no"><para>Point location in <formula id="92">$ 10^4$</formula> points </para></entry><entry thead="no"><para>4.79e-06 </para></entry><entry thead="no"><para>3.09e-06 </para></entry><entry thead="no"><para>3.96e-05 </para></entry><entry thead="no"><para>3.76e-05 </para></entry></row>
<row>
<entry thead="no"><para>Point location in <formula id="93">$ 10^5$</formula> points </para></entry><entry thead="no"><para>2.98e-05 </para></entry><entry thead="no"><para>6.12e-06 </para></entry><entry thead="no"><para>1.06e-04 </para></entry><entry thead="no"><para>1.06e-04 </para></entry></row>
<row>
<entry thead="no"><para>Point location in <formula id="94">$ 10^6$</formula> points </para></entry><entry thead="no"><para>1e-04 </para></entry><entry thead="no"><para>9.65e-06 </para></entry><entry thead="no"><para>2.7e-04 </para></entry><entry thead="no"><para>2.67e-04 </para></entry></row>
<row>
<entry thead="no"><para>Point location in <formula id="95">$ 10^7$</formula> points </para></entry><entry thead="no"><para>2.59e-04 </para></entry><entry thead="no"><para>1.33e-05 </para></entry><entry thead="no"><para>6.25e-04 </para></entry><entry thead="no"><para>6.25e-04 </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para>Vertex removal </para></entry><entry thead="no"><para>1e-04 </para></entry><entry thead="no"><para>1.03e-04 </para></entry><entry thead="no"><para>1.42e-04 </para></entry><entry thead="no"><para>1.38e-04 </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
</table>
</center>  <ref refid="index_1fig__Triangulation3figbenchmarks" kindref="member">fig__Triangulation3figbenchmarks</ref> Running times in seconds for algorithms on 3D triangulations.  <linebreak/>
</para><para>More benchmarks comparing CGAL to other software can be found in <ref refid="citelist_1CITEREF_msri52:liu-snoeyink-05" kindref="member">[17]</ref>.</para></sect2>
<sect2 id="index_1Triangulation_3ParallelPerformance">
<title>Parallel Performance</title>
<para>Figure <ref refid="index_1fig__Triangulation3figparallelspeedup" kindref="member">fig__Triangulation3figparallelspeedup</ref> shows insertion and removal speed-ups obtained using the parallel version of the triangulation algorithms of CGAL 4.5. The machine used is a PC running Windows 7 64-bits with two 6-core Intel Xeon CPU X5660 clocked at 2.80 GHz with 32GB of RAM. The program has been compiled with Microsoft Visual C++ 2012 in Release mode.</para><para><anchor id="index_1fig__Triangulation3figparallelspeedup"/><image type="html" name="DT3_parallel_benchmark.png"></image>
 <image type="latex" name="DT3_parallel_benchmark.png" width="15cm"></image>
  <ref refid="index_1fig__Triangulation3figparallelspeedup" kindref="member">fig__Triangulation3figparallelspeedup</ref> Speed-up obtained for the insertion of 1M points randomly generated inside a cube (red), and the removal of 100K of them (blue), compared to the sequential version of the algorithm.  <linebreak/>
</para></sect2>
<sect2 id="index_1Triangulation_3MemoryUsage">
<title>Memory Usage</title>
<para>We give here some indication about the memory usage of the triangulations. Those structures being intensively based on pointers, the size almost doubles on 64bit platforms compared to 32bit.</para><para>The size also depends on the size of the point type which is copied in the vertices (hence on the kernel). Obviously, any user data added to vertices and cells also affect the memory used.</para><para>More specifically, the memory space used to store a triangulation is first a function of the size of its <computeroutput>Vertex</computeroutput> and <computeroutput>Cell</computeroutput> types times their numbers (and for volumic distribution, one sees about 6.7 times more cells than vertices). However, these are stored in memory using <computeroutput><ref refid="classCGAL_1_1Compact__container" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Compact_container</ref></computeroutput>, which allocates them in lists of blocks of growing size, and this requires some additional overhead for bookkeeping. Moreover, memory is only released to the system when clearing or destroying the triangulation. This can be important for algorithms like simplifications of data sets which will produce fragmented memory usage (doing fresh copies of the data structures are one way out in such cases). The asymptotic memory overhead of <computeroutput><ref refid="classCGAL_1_1Compact__container" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Compact_container</ref></computeroutput> for its internal bookkeeping is otherwise on the order of <formula id="96">$ O(\sqrt{n})$</formula>.</para><para><ref refid="index_1fig__Triangulation3figmemory" kindref="member">fig__Triangulation3figmemory</ref> shows the number of bytes used per points, as measured empirically using <computeroutput>Memory_sizer</computeroutput> for large triangulations ( <formula id="94">$ 10^6$</formula> random points).</para><para><anchor id="index_1fig__Triangulation3figmemory"/><center> <table rows="8" cols="5"><row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para></para><para></para></entry><entry thead="no"><para><bold>Delaunay</bold> </para></entry><entry thead="no"><para><bold>Delaunay</bold> </para></entry><entry thead="no"><para><bold>Regular</bold> </para></entry><entry thead="no"><para><bold>Regular</bold> </para></entry></row>
<row>
<entry thead="no"><para></para><para></para></entry><entry thead="no"><para></para><para></para></entry><entry thead="no"><para><bold>Fast location</bold> </para></entry><entry thead="no"><para></para><para></para></entry><entry thead="no"><para><bold>No hidden points</bold> </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para>32bit </para></entry><entry thead="no"><para>274 </para></entry><entry thead="no"><para>291 </para></entry><entry thead="no"><para>336 </para></entry><entry thead="no"><para>282 </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para>64bit </para></entry><entry thead="no"><para>519 </para></entry><entry thead="no"><para>553 </para></entry><entry thead="no"><para>635 </para></entry><entry thead="no"><para>527 </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
</table>
</center>  <ref refid="index_1fig__Triangulation3figmemory" kindref="member">fig__Triangulation3figmemory</ref> Memory usage in bytes per point for large data sets.  <linebreak/>
</para></sect2>
<sect2 id="index_1Triangulation_3VariabilityDependingonthe">
<title>Variability Depending on the Data Sets and the Kernel</title>
<para>Besides the complexity of the Delaunay triangulation that varies with the distribution of the points, another critical aspect affects the efficiency : the degeneracy of the data sets. These algorithms are quite sensitive to numerical accuracy and it is important to run them using exact predicates.</para><para>Using a kernel with no exact predicates will quickly lead to crashes or infinite loops once they are executed on non-random data sets. More precisely, problems appear with data sets which contain (nearly) degenerate cases for the <computeroutput>orientation</computeroutput> and <computeroutput>side_of_oriented_sphere</computeroutput> predicates, namely when there are (nearly) coplanar or (nearly) cospherical points. This unfortunately happens often in practice with data coming from various kinds of scanners or other automatic acquisition devices.</para><para>Using an inexact kernel such as <computeroutput><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Simple_cartesian</ref>&lt;double&gt;</computeroutput> would lead to optimal performance, which is only about 30% better than <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>. The latter is strongly recommended since it takes care about potential robustness issues. The former can be used for benchmarking purposes mostly, or when you really know that your data sets won&apos;t exhibit any robustness issue.</para><para>Exact predicates take more time to compute when they hit (nearly) degenerate cases. Depending on the data set, this can have a visible impact on the overall performance of the algorithm or not.</para><para>Sometimes you need exact constructions as well, so <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput> is a must. This is the case for example when you need the <computeroutput>dual</computeroutput> functions to be exact, or when your input is stored in points of such a kernel for other reasons (because it is the output of another algorithm which has this requirement, for example). This will slow down the computations by a factor of 4 to 5 at least, and it can be much more.</para><para><ref refid="index_1fig__Triangulation3figkernelsanddatasets" kindref="member">fig__Triangulation3figkernelsanddatasets</ref> gives more detailed timings about various kernels one the following data sets : random points in a cube, random points on the surface of an ellipsoid, points scanned on the surface of a Buddha statue, points on a molecular surface, and points scanned on a dryer handle. See <ref refid="index_1fig__Triangulation3figdatasets" kindref="member">fig__Triangulation3figdatasets</ref> for pictures of the last 3 objects, which respectively illustrate volumic data, surfacic data, and data with many degenerate cases. This last data set exhibits an infinite loop with an inexact kernel, and of course we are not sure whether what is computed for the other data sets with this inexact kernel is a Delaunay triangulation. General introductory information about these robustness issues can be found in <ref refid="citelist_1CITEREF_cgta-kmpsy-08" kindref="member">[16]</ref>. More benchmarks around this issue can also be found in <ref refid="citelist_1CITEREF_cgal:dp-eegpd-03" kindref="member">[7]</ref>.</para><para><anchor id="index_1fig__Triangulation3figkernelsanddatasets"/><center> <table rows="13" cols="6"><row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para></para><para></para></entry><entry thead="no"><para><bold>Random</bold> </para></entry><entry thead="no"><para><bold>Ellipsoid</bold> </para></entry><entry thead="no"><para><bold>Buddha</bold> </para></entry><entry thead="no"><para><bold>Molecule</bold> </para></entry><entry thead="no"><para><bold>Dryer</bold> </para></entry></row>
<row>
<entry thead="no"><para></para><para></para></entry><entry thead="no"><para></para><para></para></entry><entry thead="no"><para></para><para></para></entry><entry thead="no"><para></para><para></para></entry><entry thead="no"><para></para><para></para></entry><entry thead="no"><para><bold>Handle</bold> </para></entry></row>
<row>
<entry thead="no"><para>Number of points </para></entry><entry thead="no"><para><bold>100000</bold> </para></entry><entry thead="no"><para><bold>100000</bold> </para></entry><entry thead="no"><para><bold>542548</bold> </para></entry><entry thead="no"><para><bold>525296</bold> </para></entry><entry thead="no"><para><bold>49787</bold> </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para><computeroutput><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Simple_cartesian</ref>&lt;double&gt;</computeroutput> </para></entry><entry thead="no"><para>0.69 </para></entry><entry thead="no"><para>0.627 </para></entry><entry thead="no"><para>4.21 </para></entry><entry thead="no"><para>3.8 </para></entry><entry thead="no"><para><formula id="97">$ \infty $</formula>-loop </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para><computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput> </para></entry><entry thead="no"><para>0.824 </para></entry><entry thead="no"><para>0.749 </para></entry><entry thead="no"><para>4.99 </para></entry><entry thead="no"><para>4.64 </para></entry><entry thead="no"><para>1.68 </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para><computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput> </para></entry><entry thead="no"><para>4.59 </para></entry><entry thead="no"><para>3.85 </para></entry><entry thead="no"><para>30.1 </para></entry><entry thead="no"><para>26.4 </para></entry><entry thead="no"><para>4.57 </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
<row>
<entry thead="no"><para><computeroutput><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Simple_cartesian</ref>&lt;Gmpq&gt;</computeroutput> </para></entry><entry thead="no"><para>492 </para></entry><entry thead="no"><para>534 </para></entry><entry thead="no"><para>1120 </para></entry><entry thead="no"><para>1030 </para></entry><entry thead="no"><para>75.2 </para></entry></row>
<row>
<entry thead="no"><para><hruler/>
 </para></entry></row>
</table>
</center>  <ref refid="index_1fig__Triangulation3figkernelsanddatasets" kindref="member">fig__Triangulation3figkernelsanddatasets</ref> Running times (seconds) for various kernels and data sets.  <linebreak/>
</para><para><anchor id="index_1fig__Triangulation3figdatasets"/><center> <table rows="1" cols="3"><row>
<entry thead="no"><para><image type="html" name="api1_01.png"></image>
 <image type="latex" name="api1_01.png" width="5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="b35-1.png"></image>
 <image type="latex" name="b35-1.png" width="5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="HD.png"></image>
 <image type="latex" name="HD.png" width="5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__Triangulation3figdatasets" kindref="member">fig__Triangulation3figdatasets</ref> Data sets used in the benchmark of <ref refid="index_1fig__Triangulation3figkernelsanddatasets" kindref="member">fig__Triangulation3figkernelsanddatasets</ref>.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1Triangulation_3Design">
<title>Design and Implementation History</title>
<para>Monique Teillaud started to work on the 3D triangulation packages in 1997, following the design of the 2D triangulation packages. The notions of degenerate dimensions and infinite vertex were formalized <ref refid="citelist_1CITEREF_t-tdtc-99" kindref="member">[20]</ref> and induced changes in the 2D triangulation packages. The packages were first released in CGAL 2.1. They contained basic functionalities on triangulations, Delaunay triangulations, regular triangulations.</para><para>A first version of removal of a vertex from a Delaunay triangulation was released in CGAL 2.2. However, this removal became really robust only in CGAL 2.3, after some research that allowed to deal with degenerate cases quite easily <ref refid="citelist_1CITEREF_cgal:dt-pvr3d-03" kindref="member">[8]</ref>. Andreas Fabri implemented this revised version of the removal, and a faster removal algorithm for CGAL 3.0.</para><para>The latter algorithm was proposed by Mariette Yvinec, who contributed in several ways to the package, first since she was maintaining the close 2D triangulation package and participated in many discussions, she also wrote the traits classes for regular triangulations.</para><para>In 2000, Sylvain Pion started working on these packages. He improved the efficiency of triangulations in CGAL 2.3 and 2.4 in several ways <ref refid="citelist_1CITEREF_cgal:bdpty-tc-02" kindref="member">[6]</ref> he implemented the Delaunay hierarchy <ref refid="citelist_1CITEREF_cgal:d-dh-02" kindref="member">[12]</ref> in 2.3, he improved the memory footprint in 2.4 and 3.0, he also performed work on arithmetic filters <ref refid="citelist_1CITEREF_cgal:dp-eegpd-03" kindref="member">[7]</ref> (see <computeroutput><ref refid="structCGAL_1_1Filtered__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Filtered_kernel</ref></computeroutput>) to improve the speed of triangulations. He changed the design in CGAL 3.0, allowing users to add handles in their own vertices and cells.</para><para>Olivier Devillers, co-author of preliminary versions of the CGAL 2d triangulations, participated in many discussions, in particular about the perturbations, and more concretely in the implementation of the Delaunay hierarchy.</para><para>In 2005, Christophe Delage implemented the vertex removal function for regular triangulations, using the symbolic perturbation proposed in <ref refid="citelist_1CITEREF_cgal:dt-pvrdr-06" kindref="member">[9]</ref>, which allowed to release this functionality in CGAL 3.2.</para><para>In 2006, Nico Kruithof wrote the <computeroutput><ref refid="classCGAL_1_1Triangulation__simplex__3" kindref="compound">Triangulation_simplex_3</ref></computeroutput> class that can store simplices of any dimension and improved the internal organization of the code.</para><para>As of March 2007, Christophe Delage made the iterator range insert methods and constructors use <computeroutput>spatial_sort</computeroutput> to improve efficiency.</para><para>In 2008, Camille Wormser added a few more iterators in the package that were integrated in release 3.4.</para><para>In 2009, Sylvain Pion simplified the design of the Delaunay hierarchy so that it became the simple <computeroutput>Fast_location</computeroutput> policy in release 3.6.</para><para>In 2010, Pedro de Castro and Olivier Devillers added the point displacement in release 3.7.</para><para>In 2011, Pedro de Castro and Olivier Devillers implemented in release 3.8 the structural filtering method, improving the efficiency of point location.</para><para>A new demo of this package was introduced in CGAL 3.8, coded by Fei (Sophie) Che, who was co-mentored by Manuel Caroli and Monique Teillaud in the framework of the Google Summer of Code, 2010.</para><para>In 2013, Cl√©ment Jamin added parallel algorithms (insert, remove) to the Delaunay and regular triangulations.</para><para>The authors wish to thank Lutz Kettner for inspiring discussions about the design of CGAL. Jean-Daniel Boissonnat is also acknowledged <ref refid="citelist_1CITEREF_bdty-tcgal-00" kindref="member">[5]</ref>. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
