<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classCGAL_1_1Delaunay__triangulation__3" kind="class" language="C++" prot="public">
    <compoundname>CGAL::Delaunay_triangulation_3</compoundname>
    <basecompoundref refid="classCGAL_1_1Triangulation__3" prot="public" virt="non-virtual">CGAL::Triangulation_3&lt; Traits, Delaunay_triangulation_3&lt; Traits, TDS, LP &gt;::Triangulation_data_structure, SLDS &gt;</basecompoundref>
    <includes local="no">CGAL/Delaunay_triangulation_3.h</includes>
    <templateparamlist>
      <param>
        <type>typename</type>
        <declname>Traits</declname>
        <defname>Traits</defname>
      </param>
      <param>
        <type>typename</type>
        <declname>TDS</declname>
        <defname>TDS</defname>
      </param>
      <param>
        <type>typename</type>
        <declname>LP</declname>
        <defname>LP</defname>
      </param>
      <param>
        <type>typename</type>
        <declname>SLDS</declname>
        <defname>SLDS</defname>
      </param>
    </templateparamlist>
      <sectiondef kind="user-defined">
      <header>Types</header>
      <memberdef kind="typedef" id="classCGAL_1_1Delaunay__triangulation__3_1a7086ace7dcbdea1f84fe8b5ff53e93c5" prot="public" static="no">
        <type>Traits</type>
        <definition>typedef Traits CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Geom_traits</definition>
        <argsstring></argsstring>
        <name>Geom_traits</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="75" column="1" bodyfile="CGAL/Delaunay_triangulation_3.h" bodystart="75" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Delaunay__triangulation__3_1a655f31b326e5c1dbcef70d2e17f270ff" prot="public" static="no">
        <type>TDS</type>
        <definition>typedef TDS CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Triangulation_data_structure</definition>
        <argsstring></argsstring>
        <name>Triangulation_data_structure</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="80" column="1" bodyfile="CGAL/Delaunay_triangulation_3.h" bodystart="80" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Delaunay__triangulation__3_1a2b8e91f69d68cc8396f52feda7927bc2" prot="public" static="no">
        <type>LP</type>
        <definition>typedef LP CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Location_policy</definition>
        <argsstring></argsstring>
        <name>Location_policy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="85" column="1" bodyfile="CGAL/Delaunay_triangulation_3.h" bodystart="85" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Delaunay__triangulation__3_1a2a61fe534c76315eac6dd34e877c0e33" prot="public" static="no">
        <type>SLDS</type>
        <definition>typedef SLDS CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Lock_data_structure</definition>
        <argsstring></argsstring>
        <name>Lock_data_structure</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="90" column="1" bodyfile="CGAL/Delaunay_triangulation_3.h" bodystart="90" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <description><para>In addition to those inherited, the following types are defined, for use by the construction of the Voronoi diagram: </para></description>
      <memberdef kind="typedef" id="classCGAL_1_1Delaunay__triangulation__3_1a61b4e8d8949be012f6b3c38aeccc7f1e" prot="public" static="no">
        <type>Geom_traits::Line_3</type>
        <definition>typedef Geom_traits::Line_3 CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Line</definition>
        <argsstring></argsstring>
        <name>Line</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="102" column="1" bodyfile="CGAL/Delaunay_triangulation_3.h" bodystart="102" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Delaunay__triangulation__3_1ac67b26badd4d1e87cb3ea45727a4d20c" prot="public" static="no">
        <type>Geom_traits::Ray_3</type>
        <definition>typedef Geom_traits::Ray_3 CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Ray</definition>
        <argsstring></argsstring>
        <name>Ray</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="107" column="1" bodyfile="CGAL/Delaunay_triangulation_3.h" bodystart="107" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Delaunay__triangulation__3_1a0f6fa2295ea269d6c087a881024d4d82" prot="public" static="no">
        <type>Geom_traits::Plane_3</type>
        <definition>typedef Geom_traits::Plane_3 CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Plane</definition>
        <argsstring></argsstring>
        <name>Plane</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="112" column="1" bodyfile="CGAL/Delaunay_triangulation_3.h" bodystart="112" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Delaunay__triangulation__3_1aa7c4f235ad99900dedd4710747e64d9f" prot="public" static="no">
        <type>Geom_traits::Object_3</type>
        <definition>typedef Geom_traits::Object_3 CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Object</definition>
        <argsstring></argsstring>
        <name>Object</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="117" column="1" bodyfile="CGAL/Delaunay_triangulation_3.h" bodystart="117" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Creation</header>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a27cf6ca83aed76f9753cd259bb03427f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Delaunay_triangulation_3</definition>
        <argsstring>(const Geom_traits &amp;traits=Geom_traits(), Lock_data_structure *lock_ds=NULL)</argsstring>
        <name>Delaunay_triangulation_3</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Delaunay__triangulation__3_1a7086ace7dcbdea1f84fe8b5ff53e93c5" kindref="member">Geom_traits</ref> &amp;</type>
          <declname>traits</declname>
          <defval><ref refid="classCGAL_1_1Delaunay__triangulation__3_1a7086ace7dcbdea1f84fe8b5ff53e93c5" kindref="member">Geom_traits</ref>()</defval>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Delaunay__triangulation__3_1a2a61fe534c76315eac6dd34e877c0e33" kindref="member">Lock_data_structure</ref> *</type>
          <declname>lock_ds</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Creates an empty Delaunay triangulation, possibly specifying a traits class <computeroutput>traits</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><computeroutput>lock_ds</computeroutput> is an optional pointer to the lock data structure for parallel operations. It must be provided if concurrency is enabled. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="130" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1ac505d625652b8e261cdc3c51167df4ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Delaunay_triangulation_3</definition>
        <argsstring>(const Delaunay_triangulation_3 &amp;dt1)</argsstring>
        <name>Delaunay_triangulation_3</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">Delaunay_triangulation_3</ref> &amp;</type>
          <declname>dt1</declname>
        </param>
        <briefdescription>
<para>Copy constructor. </para>        </briefdescription>
        <detaileddescription>
<para>The pointer to the lock data structure is not copied. Thus, the copy won&apos;t be concurrency-safe as long as the user has not called <computeroutput><ref refid="classCGAL_1_1Triangulation__3_1afba384e440c57f3bb0a71e4b4f7f9944" kindref="member">Triangulation_3::set_lock_data_structure()</ref></computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="138" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a8fadb72818aa6db2f75769285bde3633" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Delaunay_triangulation_3</definition>
        <argsstring>(InputIterator first, InputIterator last, const Geom_traits &amp;traits=Geom_traits(), Lock_data_structure *lock_ds=NULL)</argsstring>
        <name>Delaunay_triangulation_3</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>last</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Delaunay__triangulation__3_1a7086ace7dcbdea1f84fe8b5ff53e93c5" kindref="member">Geom_traits</ref> &amp;</type>
          <declname>traits</declname>
          <defval><ref refid="classCGAL_1_1Delaunay__triangulation__3_1a7086ace7dcbdea1f84fe8b5ff53e93c5" kindref="member">Geom_traits</ref>()</defval>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Delaunay__triangulation__3_1a2a61fe534c76315eac6dd34e877c0e33" kindref="member">Lock_data_structure</ref> *</type>
          <declname>lock_ds</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Equivalent to constructing an empty triangulation with the optional traits class argument and calling <computeroutput>insert(first,last)</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>If parallelism is enabled, the points will be inserted in parallel. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="146" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a7bd4dc9b3e75b71684711553290ad0a6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::Delaunay_triangulation_3</definition>
        <argsstring>(InputIterator first, InputIterator last, Lock_data_structure *lock_ds, const Geom_traits &amp;traits=Geom_traits())</argsstring>
        <name>Delaunay_triangulation_3</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>last</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Delaunay__triangulation__3_1a2a61fe534c76315eac6dd34e877c0e33" kindref="member">Lock_data_structure</ref> *</type>
          <declname>lock_ds</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Delaunay__triangulation__3_1a7086ace7dcbdea1f84fe8b5ff53e93c5" kindref="member">Geom_traits</ref> &amp;</type>
          <declname>traits</declname>
          <defval><ref refid="classCGAL_1_1Delaunay__triangulation__3_1a7086ace7dcbdea1f84fe8b5ff53e93c5" kindref="member">Geom_traits</ref>()</defval>
        </param>
        <briefdescription>
<para>Same as before, with last two parameters in reverse order. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="154" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Insertion</header>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a5283a16d3299df75233d954deba71600" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
        <definition>Vertex_handle CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::insert</definition>
        <argsstring>(const Point &amp;p, Cell_handle start=Cell_handle(), bool *could_lock_zone=NULL)</argsstring>
        <name>insert</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>start</declname>
          <defval><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref>()</defval>
        </param>
        <param>
          <type>bool *</type>
          <declname>could_lock_zone</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Inserts the point <computeroutput>p</computeroutput> in the triangulation and returns the corresponding vertex. </para>        </briefdescription>
        <detaileddescription>
<para>Similar to the insertion in a triangulation, but ensures in addition the empty sphere property of all the created faces. The optional argument <computeroutput>start</computeroutput> is used as a starting place for the search.</para><para>The optional argument <computeroutput>could_lock_zone</computeroutput> is used by the concurrency-safe version of the triangulation. If the pointer is not null, the insertion will try to lock all the cells of the conflict zone, i.e. all the vertices that are inside or on the boundary of the conflict zone. If it succeeds, <computeroutput>*could_lock_zone</computeroutput> is true, otherwise it is false and the return value is <ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle()</ref> (the point is not inserted). In any case, the locked cells are not unlocked by the function, leaving this choice to the user. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="178" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a74ce3ab18ea99ac623c2041e61d14155" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
        <definition>Vertex_handle CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::insert</definition>
        <argsstring>(const Point &amp;p, Vertex_handle hint, bool *could_lock_zone=NULL)</argsstring>
        <name>insert</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
          <declname>hint</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>could_lock_zone</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Same as above but uses <computeroutput>hint</computeroutput> as a starting place for the search. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="184" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a0a2340d8d34325e76bf6e33bc1aebc4f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
        <definition>Vertex_handle CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::insert</definition>
        <argsstring>(const Point &amp;p, Locate_type lt, Cell_handle loc, int li, int lj, bool *could_lock_zone=NULL)</argsstring>
        <name>insert</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1a5bea7d3470854571f97c18a675daca75" kindref="member">Locate_type</ref></type>
          <declname>lt</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>loc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>li</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lj</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>could_lock_zone</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Inserts the point <computeroutput>p</computeroutput> in the triangulation and returns the corresponding vertex. </para>        </briefdescription>
        <detaileddescription>
<para>Similar to the above <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3_1a5283a16d3299df75233d954deba71600" kindref="member">insert()</ref></computeroutput> function, but takes as additional parameter the return values of a previous location query. See description of <computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a280891e681597215a86d63399ae7464c" kindref="member">Triangulation_3::locate()</ref></computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="193" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1aa3e2b2a1f7eb7d5c458a68a3279b9baa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PointInputIterator</type>
          </param>
        </templateparamlist>
        <type>std::ptrdiff_t</type>
        <definition>std::ptrdiff_t CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::insert</definition>
        <argsstring>(PointInputIterator first, PointInputIterator last)</argsstring>
        <name>insert</name>
        <param>
          <type>PointInputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>PointInputIterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Inserts the points in the iterator range <computeroutput>[first,last)</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the number of inserted points. Note that this function is not guaranteed to insert the points following the order of <computeroutput>PointInputIterator</computeroutput>, as <computeroutput><ref refid="group__PkgSpatialSortingFunctions_1ga2f4d770272b84481f7c4c9b20b7174c7" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Spatial_sorting.tag">spatial_sort()</ref></computeroutput> is used to improve efficiency. If parallelism is enabled, the points will be inserted in parallel.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PointInputIterator</parametername>
</parameternamelist>
<parameterdescription>
<para>must be an input iterator with the value type <computeroutput>Point</computeroutput>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="209" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1ac3f567a3046efa25e775dca11c44cc8c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PointWithInfoInputIterator</type>
          </param>
        </templateparamlist>
        <type>std::ptrdiff_t</type>
        <definition>std::ptrdiff_t CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::insert</definition>
        <argsstring>(PointWithInfoInputIterator first, PointWithInfoInputIterator last)</argsstring>
        <name>insert</name>
        <param>
          <type>PointWithInfoInputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>PointWithInfoInputIterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Inserts the points in the iterator range <computeroutput>[first,last)</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the number of inserted points. Note that this function is not guaranteed to insert the points following the order of <computeroutput>PointWithInfoInputIterator</computeroutput>, as <computeroutput><ref refid="group__PkgSpatialSortingFunctions_1ga2f4d770272b84481f7c4c9b20b7174c7" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Spatial_sorting.tag">spatial_sort()</ref></computeroutput> is used to improve efficiency. If parallelism is enabled, the points will be inserted in parallel. Given a pair <computeroutput>(p,i)</computeroutput>, the vertex <computeroutput>v</computeroutput> storing <computeroutput>p</computeroutput> also stores <computeroutput>i</computeroutput>, that is <computeroutput>v.point() == p</computeroutput> and <computeroutput>v.info() == i</computeroutput>. If several pairs have the same point, only one vertex is created, and one of the objects of type <computeroutput>Vertex::Info</computeroutput> will be stored in the vertex. <simplesect kind="pre"><para><computeroutput>Vertex</computeroutput> must be model of the concept <computeroutput><ref refid="classTriangulationVertexBaseWithInfo__3" kindref="compound">TriangulationVertexBaseWithInfo_3</ref></computeroutput>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PointWithInfoInputIterator</parametername>
</parameternamelist>
<parameterdescription>
<para>must be an input iterator with the value type <computeroutput>std::pair&lt;Point,Vertex::Info&gt;</computeroutput>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="229" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Displacement</header>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1ae942d747804a847f1ebd7fb5c777f768" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
        <definition>Vertex_handle CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::move_if_no_collision</definition>
        <argsstring>(Vertex_handle v, const Point &amp;p)</argsstring>
        <name>move_if_no_collision</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
          <declname>v</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>If there is not already another vertex placed on <computeroutput>p</computeroutput>, the triangulation is modified such that the new position of vertex <computeroutput>v</computeroutput> is <computeroutput>p</computeroutput>, and <computeroutput>v</computeroutput> is returned. </para>        </briefdescription>
        <detaileddescription>
<para>Otherwise, the triangulation is not modified and the vertex at point <computeroutput>p</computeroutput> is returned. <simplesect kind="pre"><para>Vertex <computeroutput>v</computeroutput> must be finite. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="243" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a579c9609e18ee98ef8ce524823a1fa2e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
        <definition>Vertex_handle CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::move</definition>
        <argsstring>(Vertex_handle v, const Point &amp;p)</argsstring>
        <name>move</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
          <declname>v</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>If there is no collision during the move, this function is the same as <computeroutput>move_if_no_collision</computeroutput> . </para>        </briefdescription>
        <detaileddescription>
<para>Otherwise, <computeroutput>v</computeroutput> is removed and the vertex at point <computeroutput>p</computeroutput> is returned. <simplesect kind="pre"><para>Vertex <computeroutput>v</computeroutput> must be finite. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="251" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Removal</header>
      <description><para>When a vertex <computeroutput>v</computeroutput> is removed from a triangulation, all the cells incident to <computeroutput>v</computeroutput> must be removed, and the polyhedral region consisting of all the tetrahedra that are incident to <computeroutput>v</computeroutput> must be re-triangulated.</para><para>So, the problem reduces to triangulating a polyhedral region, while preserving its boundary, or to compute a constrained* triangulation. This is known to be sometimes impossible: the Sch<oumlaut/>nhardt polyhedron cannot be triangulated <ref refid="citelist_1CITEREF_cgal:s-cgehd-98" kindref="member">[19]</ref>. However, when dealing with Delaunay triangulations, the case of such polyhedra that cannot be re-triangulated cannot happen, so CGAL proposes a vertex removal.</para><para>If,due to some point removals, the size of the Delaunay triangulation decreases drastically, it might be interesting to defragment the <computeroutput><ref refid="classCGAL_1_1Compact__container" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Compact_container</ref></computeroutput> (used by the <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">Triangulation_data_structure_3</ref></computeroutput>). </para></description>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a5f6dd6960f4e0c61d935d6ac7c730e97" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::remove</definition>
        <argsstring>(Vertex_handle v)</argsstring>
        <name>remove</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Removes the vertex <computeroutput>v</computeroutput> from the triangulation. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><computeroutput>v</computeroutput> is a finite vertex of the triangulation. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="279" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a8ee5fbed77f873b000b0e2d3ab6c6582" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::remove</definition>
        <argsstring>(Vertex_handle v, bool *could_lock_zone)</argsstring>
        <name>remove</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
          <declname>v</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>could_lock_zone</declname>
        </param>
        <briefdescription>
<para>Removes the vertex <computeroutput>v</computeroutput> from the triangulation. </para>        </briefdescription>
        <detaileddescription>
<para>This function is concurrency-safe if the triangulation is concurrency-safe. It will first try to lock all the cells adjacent to <computeroutput>v</computeroutput>. If it succeeds, <computeroutput>*could_lock_zone</computeroutput> is true, otherwise it is false (and the point is not removed). In any case, the locked cells are not unlocked by the function, leaving this choice to the user.</para><para>This function will try to remove <computeroutput>v</computeroutput> only if the removal does not decrease the dimension.</para><para>The return value is only meaningful if <computeroutput>*could_lock_zone</computeroutput> is <computeroutput>true</computeroutput>:<itemizedlist>
<listitem><para>returns true if the vertex was removed</para></listitem><listitem><para>returns false if the vertex wasn&apos;t removed since it would decrease the dimension.</para></listitem></itemizedlist>
</para><para><simplesect kind="pre"><para><computeroutput>v</computeroutput> is a finite vertex of the triangulation. </para></simplesect>
<simplesect kind="pre"><para><computeroutput>dt</computeroutput>.<computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a80ba1634c96f534d18d2d2420f65561f" kindref="member">dimension()</ref></computeroutput> <formula id="2">$ =3$</formula>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="302" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1aa7b25857cf36948e81f8276f9cd0c88e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::remove</definition>
        <argsstring>(InputIterator first, InputIterator beyond)</argsstring>
        <name>remove</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>beyond</declname>
        </param>
        <briefdescription>
<para>Removes the vertices specified by the iterator range <computeroutput>[first, beyond)</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The number of vertices removed is returned. If parallelism is enabled, the points will be removed in parallel. Note that if at some step, the triangulation dimension becomes lower than 3, the removal of the remaining points will go on sequentially.</para><para><simplesect kind="pre"><para>(i) all vertices of the range are finite vertices of the triangulation; and (ii) no vertices are repeated in the range.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>must be an input iterator with value type <computeroutput>Vertex_handle</computeroutput>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="316" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a9f83bb6a1d1c7d030498a23d53b5719e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::remove_cluster</definition>
        <argsstring>(InputIterator first, InputIterator beyond)</argsstring>
        <name>remove_cluster</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>beyond</declname>
        </param>
        <briefdescription>
<para>This function has exactly the same result and the same preconditions as <computeroutput>remove(first, beyond)</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The difference is in the implementation and efficiency. This version does not re-triangulate the hole after each point removal but only after removing all vertices. This is more efficient if (and only if) the removed points are organized in a small number of connected components of the Delaunay triangulation. Another difference is that there is no parallel version of this function.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>must be an input iterator with value type <computeroutput>Vertex_handle</computeroutput>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="328" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Queries</header>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1ace0836b01cf6b8e4dbb6f83f9fd3ba0e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__kernel__enums_1gaf6030e89dadcc1f45369b0cdc5d9e111" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Bounded_side</ref></type>
        <definition>Bounded_side CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::side_of_sphere</definition>
        <argsstring>(Cell_handle c, const Point &amp;p) const</argsstring>
        <name>side_of_sphere</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Returns a value indicating on which side of the circumscribed sphere of <computeroutput>c</computeroutput> the point <computeroutput>p</computeroutput> lies. </para>        </briefdescription>
        <detaileddescription>
<para>More precisely, it returns:</para><para><itemizedlist>
<listitem><para><computeroutput>ON_BOUNDED_SIDE</computeroutput> if <computeroutput>p</computeroutput> is inside the sphere. For an infinite cell this means that <computeroutput>p</computeroutput> lies strictly either in the half space limited by its finite facet and not containing any other point of the triangulation, or in the interior of the disk circumscribing the <emphasis>finite</emphasis> facet.</para></listitem><listitem><para><computeroutput>ON_BOUNDARY</computeroutput> if p on the boundary of the sphere. For an infinite cell this means that <computeroutput>p</computeroutput> lies on the circle circumscribing the <emphasis>finite</emphasis> facet.</para></listitem><listitem><para><computeroutput>ON_UNBOUNDED_SIDE</computeroutput> if <computeroutput>p</computeroutput> lies outside the sphere. For an infinite cell this means that <computeroutput>p</computeroutput> does not satisfy either of the two previous conditions. <simplesect kind="pre"><para><computeroutput>dt</computeroutput>.<computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a80ba1634c96f534d18d2d2420f65561f" kindref="member">dimension()</ref></computeroutput> <formula id="2">$ =3$</formula>. </para></simplesect>
</para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="356" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a53e4b68dbad8d4ec4f96a6c1b2ad3b66" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__kernel__enums_1gaf6030e89dadcc1f45369b0cdc5d9e111" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Bounded_side</ref></type>
        <definition>Bounded_side CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::side_of_circle</definition>
        <argsstring>(const Facet &amp;f, const Point &amp;p) const</argsstring>
        <name>side_of_circle</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1aa100228164b0cf78d5c2b1009c2df258" kindref="member">Facet</ref> &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Returns a value indicating on which side of the circumscribed circle of <computeroutput>f</computeroutput> the point <computeroutput>p</computeroutput> lies. </para>        </briefdescription>
        <detaileddescription>
<para>More precisely, it returns:</para><para><itemizedlist>
<listitem><para>in dimension 3:</para></listitem><listitem><para>For a finite facet, <computeroutput>ON_BOUNDARY</computeroutput> if <computeroutput>p</computeroutput> lies on the circle, <computeroutput>ON_UNBOUNDED_SIDE</computeroutput> when it lies in the exterior of the disk, <computeroutput>ON_BOUNDED_SIDE</computeroutput> when it lies in its interior.</para></listitem><listitem><para>For an infinite facet, it considers the plane defined by the finite facet of the same cell, and does the same as in dimension 2 in this plane.</para></listitem><listitem><para>in dimension 2:</para></listitem><listitem><para>For a finite facet, <computeroutput>ON_BOUNDARY</computeroutput> if <computeroutput>p</computeroutput> lies on the circle, <computeroutput>ON_UNBOUNDED_SIDE</computeroutput> when it lies in the exterior of the disk, <computeroutput>ON_BOUNDED_SIDE</computeroutput> when it lies in its interior.</para></listitem><listitem><para>For an infinite facet, <computeroutput>ON_BOUNDARY</computeroutput> if the point lies on the finite edge of <computeroutput>f</computeroutput> (endpoints included), <computeroutput>ON_BOUNDED_SIDE</computeroutput> for a point in the open half plane defined by <computeroutput>f</computeroutput> and not containing any other point of the triangulation, <computeroutput>ON_UNBOUNDED_SIDE</computeroutput> elsewhere. <simplesect kind="pre"><para><computeroutput>dt</computeroutput>.<computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a80ba1634c96f534d18d2d2420f65561f" kindref="member">dimension()</ref></computeroutput> <formula id="3">$ \geq2$</formula> and in dimension 3, <computeroutput>p</computeroutput> is coplanar with <computeroutput>f</computeroutput>. </para></simplesect>
</para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="386" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a444d028c149bebcbf41b08aa9cd83e15" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__kernel__enums_1gaf6030e89dadcc1f45369b0cdc5d9e111" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Bounded_side</ref></type>
        <definition>Bounded_side CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::side_of_circle</definition>
        <argsstring>(Cell_handle c, int i, const Point &amp;p)</argsstring>
        <name>side_of_circle</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Same as the previous method for facet <computeroutput>i</computeroutput> of cell <computeroutput>c</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="392" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1ad1c7e6a808a671bb8efbe046c4bc5a70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
        <definition>Vertex_handle CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::nearest_vertex</definition>
        <argsstring>(const Point &amp;p, Cell_handle c=Cell_handle())</argsstring>
        <name>nearest_vertex</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
          <defval><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref>()</defval>
        </param>
        <briefdescription>
<para>Returns any nearest vertex to the point <computeroutput>p</computeroutput>, or the default constructed handle if the triangulation is empty. </para>        </briefdescription>
        <detaileddescription>
<para>The optional argument <computeroutput>c</computeroutput> is a hint specifying where to start the search. <simplesect kind="pre"><para><computeroutput>c</computeroutput> is a cell of <computeroutput>dt</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="401" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a97a3cc3b18cfc23458a809a9e1116f06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Triangulation__3_1a1ba56e37b3a5acb1ba49a56d9d101a19" kindref="member">Vertex_handle</ref></type>
        <definition>Vertex_handle CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::nearest_vertex_in_cell</definition>
        <argsstring>(const Point &amp;p, Cell_handle c)</argsstring>
        <name>nearest_vertex_in_cell</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Returns the vertex of the cell <computeroutput>c</computeroutput> that is nearest to <formula id="4">$ p$</formula>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="407" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <description><para>A point <computeroutput>p</computeroutput> is said to be in conflict with a cell <computeroutput>c</computeroutput> in dimension 3 (resp. a facet <computeroutput>f</computeroutput> in dimension 2) iff <computeroutput>dt.side_of_sphere(c, p)</computeroutput> (resp. <computeroutput>dt.side_of_circle(f, p)</computeroutput>) returns <computeroutput>ON_BOUNDED_SIDE</computeroutput>.</para><para>The set of cells (resp. facets in dimension 2) which are in conflict with <computeroutput>p</computeroutput> is connected, and it forms a hole. </para></description>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a16f8135a2fed6f90b3633de91997fbec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIteratorBoundaryFacets</type>
          </param>
          <param>
            <type>class OutputIteratorCells</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; OutputIteratorBoundaryFacets, OutputIteratorCells &gt;</type>
        <definition>std::pair&lt;OutputIteratorBoundaryFacets, OutputIteratorCells&gt; CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::find_conflicts</definition>
        <argsstring>(const Point &amp;p, Cell_handle c, OutputIteratorBoundaryFacets bfit, OutputIteratorCells cit, bool *could_lock_zone=NULL)</argsstring>
        <name>find_conflicts</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type>OutputIteratorBoundaryFacets</type>
          <declname>bfit</declname>
        </param>
        <param>
          <type>OutputIteratorCells</type>
          <declname>cit</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>could_lock_zone</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Computes the conflict hole induced by <computeroutput>p</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The starting cell (resp. facet) <computeroutput>c</computeroutput> must be in conflict. Then this function returns respectively in the output iterators:</para><para><itemizedlist>
<listitem><para><computeroutput>cit</computeroutput>: the cells (resp. facets) in conflict.</para></listitem><listitem><para><computeroutput>bfit</computeroutput>: the facets (resp. edges) on the boundary, that is, the facets (resp. edges) <computeroutput>(t, i)</computeroutput> where the cell (resp. facet) <computeroutput>t</computeroutput> is in conflict, but <computeroutput>t-&gt;neighbor(i)</computeroutput> is not.</para></listitem><listitem><para><computeroutput>could_lock_zone</computeroutput>: The optional argument <computeroutput>could_lock_zone</computeroutput> is used by the concurrency-safe version of the triangulation. If the pointer is not null, the algorithm will try to lock all the cells of the conflict zone, i.e. all the vertices that are inside or on the boundary of the conflict zone (as a result, the boundary cells become partially locked). If it succeeds, <computeroutput>*could_lock_zone</computeroutput> is true, otherwise it is false (and the returned conflict zone is only partial). In any case, the locked cells are not unlocked by the function, leaving this choice to the user.</para></listitem></itemizedlist>
</para><para>This function can be used in conjunction with <computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a4b298ac4b2d8585dec9e436bb9e65ff0" kindref="member">insert_in_hole()</ref></computeroutput> in order to decide the insertion of a point after seeing which elements of the triangulation are affected. Returns the pair composed of the resulting output iterators. <simplesect kind="pre"><para><computeroutput>dt</computeroutput>.<computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a80ba1634c96f534d18d2d2420f65561f" kindref="member">dimension()</ref></computeroutput> <formula id="3">$ \geq2$</formula>, and <computeroutput>c</computeroutput> is in conflict with <computeroutput>p</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="448" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a3fbf4cc1417acdeb38acb3080aa109ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIteratorBoundaryFacets</type>
          </param>
          <param>
            <type>class OutputIteratorCells</type>
          </param>
          <param>
            <type>class OutputIteratorInternalFacets</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Triple" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Triple</ref>&lt; OutputIteratorBoundaryFacets, OutputIteratorCells, OutputIteratorInternalFacets &gt;</type>
        <definition>Triple&lt;OutputIteratorBoundaryFacets, OutputIteratorCells, OutputIteratorInternalFacets&gt; CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::find_conflicts</definition>
        <argsstring>(const Point &amp;p, Cell_handle c, OutputIteratorBoundaryFacets bfit, OutputIteratorCells cit, OutputIteratorInternalFacets ifit, bool *could_lock_zone=NULL)</argsstring>
        <name>find_conflicts</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type>OutputIteratorBoundaryFacets</type>
          <declname>bfit</declname>
        </param>
        <param>
          <type>OutputIteratorCells</type>
          <declname>cit</declname>
        </param>
        <param>
          <type>OutputIteratorInternalFacets</type>
          <declname>ifit</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>could_lock_zone</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Same as the other <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3_1a16f8135a2fed6f90b3633de91997fbec" kindref="member">find_conflicts()</ref></computeroutput> function, except that it also computes the internal facets, i.e. the facets common to two cells which are in conflict with <computeroutput>p</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>Then this function returns respectively in the output iterators:</para><para><itemizedlist>
<listitem><para><computeroutput>cit</computeroutput>: the cells (resp. facets) in conflict.</para></listitem><listitem><para><computeroutput>bfit</computeroutput>: the facets (resp. edges) on the boundary, that is, the facets (resp. edges) <computeroutput>(t, i)</computeroutput> where the cell (resp. facet) <computeroutput>t</computeroutput> is in conflict, but <computeroutput>t-&gt;neighbor(i)</computeroutput> is not.</para></listitem><listitem><para><computeroutput>ifit</computeroutput>: the facets (resp. edges) inside the hole, that is, delimiting two cells (resp facets) in conflict.</para></listitem><listitem><para><computeroutput>could_lock_zone</computeroutput>: The optional argument <computeroutput>could_lock_zone</computeroutput> is used by the concurrency-safe version of the triangulation. If the pointer is not null, the algorithm will try to lock all the cells of the conflict zone, i.e. all the vertices that are inside or on the boundary of the conflict zone (as a result, the boundary cells become partially locked). If it succeeds, <computeroutput>*could_lock_zone</computeroutput> is true, otherwise it is false (and the returned conflict zone is only partial). In any case, the locked cells are not unlocked by the function, leaving this choice to the user.</para></listitem></itemizedlist>
</para><para>Returns the <computeroutput><ref refid="classCGAL_1_1Triple" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Triple</ref></computeroutput> composed of the resulting output iterators. <simplesect kind="pre"><para><computeroutput>dt</computeroutput>.<computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a80ba1634c96f534d18d2d2420f65561f" kindref="member">dimension()</ref></computeroutput> <formula id="3">$ \geq2$</formula>, and <computeroutput>c</computeroutput> is in conflict with <computeroutput>p</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="485" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1ae05bed5daa28805e3fecb6f153d3984c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::vertices_in_conflict</definition>
        <argsstring>(const Point &amp;p, Cell_handle c, OutputIterator res)</argsstring>
        <name>vertices_in_conflict</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>res</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000001"><xreftitle>Deprecated</xreftitle><xrefdescription><para>This function is renamed <computeroutput>vertices_on_conflict_zone_boundary</computeroutput> since CGAL-3.8.</para></xrefdescription></xrefsect></para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="496" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a74c53ed98bbbce2d98f9a89c783645d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::vertices_on_conflict_zone_boundary</definition>
        <argsstring>(const Point &amp;p, Cell_handle c, OutputIterator res)</argsstring>
        <name>vertices_on_conflict_zone_boundary</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>res</declname>
        </param>
        <briefdescription>
<para>Similar to <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3_1a16f8135a2fed6f90b3633de91997fbec" kindref="member">find_conflicts()</ref></computeroutput>, but reports the vertices which are on the boundary of the conflict hole of <computeroutput>p</computeroutput>, in the output iterator <computeroutput>res</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the resulting output iterator. <simplesect kind="pre"><para><computeroutput>dt</computeroutput>.<computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a80ba1634c96f534d18d2d2420f65561f" kindref="member">dimension()</ref></computeroutput> <formula id="3">$ \geq2$</formula>, and <computeroutput>c</computeroutput> is in conflict with <computeroutput>p</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="507" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <description><para>A face (cell, facet or edge) is said to be a Gabriel face iff its smallest circumscribing sphere do not enclose any vertex of the triangulation.</para><para>Any Gabriel face belongs to the Delaunay triangulation, but the reciprocal is not true. The following member functions test the Gabriel property of Delaunay faces. </para></description>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a187a8c96166ce8258bd2cc731367fcd3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::is_Gabriel</definition>
        <argsstring>(Cell_handle c, int i)</argsstring>
        <name>is_Gabriel</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="519" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a953bfb5f115aeb33efbba6a81fde4f74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::is_Gabriel</definition>
        <argsstring>(Cell_handle c, int i, int j)</argsstring>
        <name>is_Gabriel</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>j</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="524" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a37839e8e20ca0b9ad3c09ea914bbd969" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::is_Gabriel</definition>
        <argsstring>(const Facet &amp;f)</argsstring>
        <name>is_Gabriel</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1aa100228164b0cf78d5c2b1009c2df258" kindref="member">Facet</ref> &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="529" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1abb4dbf0d248a402308f76625f1a56d8a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::is_Gabriel</definition>
        <argsstring>(const Edge &amp;e)</argsstring>
        <name>is_Gabriel</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Triangulation__3_1a0f355dbb38cf631f24d4df8abd7a942f" kindref="member">Edge</ref> &amp;</type>
          <declname>e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="534" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Voronoi Diagram</header>
      <description><para>CGAL offers several functionalities to display the Voronoi diagram of a set of points in 3D.</para><para>Note that the user should use a kernel with exact constructions in order to guarantee the computation of the Voronoi diagram (as opposed to computing the triangulation only, which requires only exact predicates). </para></description>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a884486a709825b8b6e60e12bba12565f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Triangulation__3_1a064de663ce02121ba3f0f4223547e064" kindref="member">Point</ref></type>
        <definition>Point CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::dual</definition>
        <argsstring>(Cell_handle c) const</argsstring>
        <name>dual</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Returns the circumcenter of the four vertices of c. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><computeroutput>dt</computeroutput>.<computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a80ba1634c96f534d18d2d2420f65561f" kindref="member">dimension()</ref></computeroutput> <formula id="2">$ =3$</formula> and <computeroutput>c</computeroutput> is not infinite. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="547" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a40ebe001c6f2c93c8548b5c1b39f9c23" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Delaunay__triangulation__3_1aa7c4f235ad99900dedd4710747e64d9f" kindref="member">Object</ref></type>
        <definition>Object CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::dual</definition>
        <argsstring>(Facet f) const</argsstring>
        <name>dual</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1aa100228164b0cf78d5c2b1009c2df258" kindref="member">Facet</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Returns the dual of facet <computeroutput>f</computeroutput>, which is. </para>        </briefdescription>
        <detaileddescription>
<para>in dimension 3: either a segment, if the two cells incident to <computeroutput>f</computeroutput> are finite, or a ray, if one of them is infinite;</para><para>in dimension 2: a point. <simplesect kind="pre"><para><computeroutput>dt</computeroutput>.<computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a80ba1634c96f534d18d2d2420f65561f" kindref="member">dimension()</ref></computeroutput> <formula id="3">$ \geq2$</formula> and <computeroutput>f</computeroutput> is not infinite. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="558" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1aadb2d4b16cd667dc825b7fc928268ad2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Delaunay__triangulation__3_1aa7c4f235ad99900dedd4710747e64d9f" kindref="member">Object</ref></type>
        <definition>Object CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::dual</definition>
        <argsstring>(Cell_handle c, int i) const</argsstring>
        <name>dual</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>same as the previous method for facet <computeroutput>(c,i)</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="563" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1acfd6b7eda707eb0921172de7699db4fb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Delaunay__triangulation__3_1a61b4e8d8949be012f6b3c38aeccc7f1e" kindref="member">Line</ref></type>
        <definition>Line CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::dual_support</definition>
        <argsstring>(Cell_handle c, int i) const</argsstring>
        <name>dual_support</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>returns the line supporting the dual of the facet. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><computeroutput>dt</computeroutput>.<computeroutput><ref refid="classCGAL_1_1Triangulation__3_1a80ba1634c96f534d18d2d2420f65561f" kindref="member">dimension()</ref></computeroutput> <formula id="3">$ \geq2$</formula> and <computeroutput>f</computeroutput> is not infinite. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="569" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a5942b55dddff54923b0eae939a975c93" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Stream</type>
          </param>
        </templateparamlist>
        <type>Stream &amp;</type>
        <definition>Stream&amp; CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::draw_dual</definition>
        <argsstring>(Stream &amp;os)</argsstring>
        <name>draw_dual</name>
        <param>
          <type>Stream &amp;</type>
          <declname>os</declname>
        </param>
        <briefdescription>
<para>Sends the set of duals to all the facets of <computeroutput>dt</computeroutput> into <computeroutput>os</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="574" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Checking</header>
      <description><para>These methods are mainly a debugging help for the users of advanced features. </para></description>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a96bba56ced4df414f88a5bd4a392a198" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::is_valid</definition>
        <argsstring>(bool verbose=false) const</argsstring>
        <name>is_valid</name>
        <param>
          <type>bool</type>
          <declname>verbose</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Checks the combinatorial validity of the triangulation and the validity of its geometric embedding (see Section <ref refid="index_1Triangulation3secintro" kindref="member">Representation</ref>). </para>        </briefdescription>
        <detaileddescription>
<para>Also checks that all the circumscribing spheres (resp. circles in dimension 2) of cells (resp. facets in dimension 2) are empty. When <computeroutput>verbose</computeroutput> is set to true, messages describing the first invalidity encountered are printed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="593" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Delaunay__triangulation__3_1a129799fd5949cb0d5c24c33c0ec58210" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;::is_valid</definition>
        <argsstring>(Cell_handle c, bool verbose=false) const</argsstring>
        <name>is_valid</name>
        <param>
          <type><ref refid="classCGAL_1_1Triangulation__3_1ac076eb6ecdeeeb2b5bf678a21b3d23ee" kindref="member">Cell_handle</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>verbose</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>This is a function for debugging purpose. </para>        </briefdescription>
        <detaileddescription>
<para></para><para>Checks the combinatorial and geometric validity of the cell (see Section <ref refid="index_1Triangulation3secintro" kindref="member">Representation</ref>). Also checks that the circumscribing sphere (resp. circle in dimension 2) of cells (resp. facet in dimension 2) is empty.</para><para>When <computeroutput>verbose</computeroutput> is set to true, messages are printed to give a precise indication of the kind of invalidity encountered.  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Delaunay_triangulation_3.h" line="609" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>The class <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound">Delaunay_triangulation_3</ref></computeroutput> represents a three-dimensional Delaunay triangulation. </para>    </briefdescription>
    <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Traits</parametername>
</parameternamelist>
<parameterdescription>
<para>is the geometric traits class and must be a model of <computeroutput><ref refid="classDelaunayTriangulationTraits__3" kindref="compound">DelaunayTriangulationTraits_3</ref></computeroutput>.</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TDS</parametername>
</parameternamelist>
<parameterdescription>
<para>is the triangulation data structure and must be a model of <computeroutput><ref refid="classTriangulationDataStructure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">TriangulationDataStructure_3</ref></computeroutput>. <computeroutput><ref refid="structCGAL_1_1Default" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Default</ref></computeroutput> may be used, with default type <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag">Triangulation_data_structure_3</ref>&lt;<ref refid="classCGAL_1_1Triangulation__vertex__base__3" kindref="compound">Triangulation_vertex_base_3</ref>&lt;Traits&gt;, <ref refid="classCGAL_1_1Delaunay__triangulation__cell__base__3" kindref="compound">Delaunay_triangulation_cell_base_3</ref>&lt;Traits&gt; &gt;</computeroutput>. Any custom type can be used instead of <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__3" kindref="compound">Triangulation_vertex_base_3</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__cell__base__3" kindref="compound">Delaunay_triangulation_cell_base_3</ref></computeroutput>, provided that they are models of the concepts <computeroutput><ref refid="classTriangulationVertexBase__3" kindref="compound">TriangulationVertexBase_3</ref></computeroutput> and <computeroutput><ref refid="classDelaunayTriangulationCellBase__3" kindref="compound">DelaunayTriangulationCellBase_3</ref></computeroutput>, respectively.</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>LP</parametername>
</parameternamelist>
<parameterdescription>
<para>is a tag which must be a <computeroutput><ref refid="structCGAL_1_1Location__policy" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Location_policy</ref>&lt;Tag&gt;</computeroutput>: either <computeroutput><ref refid="group__PkgStlExtensionUtilities_1ga8f61a2b71f265bad92d78ae606afc830" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Fast_location</ref></computeroutput> or <computeroutput><ref refid="group__PkgStlExtensionUtilities_1ga96bf435aef680d59e1bcb722239222dd" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Compact_location</ref></computeroutput>. <computeroutput><ref refid="group__PkgStlExtensionUtilities_1ga8f61a2b71f265bad92d78ae606afc830" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Fast_location</ref></computeroutput> offers faster ( <formula id="0">$ O(\log n)$</formula> time) point location, which can be beneficial when performing point locations or random point insertions (with no good location hint) in large data sets. It is currently implemented using an additional triangulation hierarchy data structure <ref refid="citelist_1CITEREF_cgal:d-dh-02" kindref="member">[12]</ref>. The default is <computeroutput><ref refid="group__PkgStlExtensionUtilities_1ga96bf435aef680d59e1bcb722239222dd" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Compact_location</ref></computeroutput>, which saves memory (3-5%) by avoiding the need for this separate data structure, and point location is then performed roughly in <formula id="1">$ O(n^{1/3})$</formula> time. If the triangulation is parallel (see user manual), the default compact location policy must be used. Note that this argument can also come in second position, which can be useful when the default value for the <computeroutput>TDS</computeroutput> parameter is satisfactory (this is achieved using so-called deduced parameters). Note that this argument replaces the functionality provided before CGAL 3.6 by <computeroutput>Triangulation_hierarchy_3</computeroutput>. An example of use can be found in the user manual <ref refid="index_1Triangulation3exfastlocation" kindref="member">Fast Point Location for Delaunay Triangulations</ref>.</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SLDS</parametername>
</parameternamelist>
<parameterdescription>
<para>is an optional parameter to specify the type of the spatial lock data structure. It must be a model of the <computeroutput><ref refid="classSurjectiveLockDataStructure" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">SurjectiveLockDataStructure</ref></computeroutput> concept, with <computeroutput><ref refid="classCGAL_1_1Object" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Object</ref></computeroutput> being a <computeroutput>Point</computeroutput> (as defined below). It is only used if the triangulation data structure used is concurrency-safe (i.e. when <computeroutput>TDS::Concurrency_tag</computeroutput> is <computeroutput><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref></computeroutput>). The default value is <computeroutput><ref refid="classCGAL_1_1Spatial__lock__grid__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Spatial_lock_grid_3</ref>&lt;Tag_priority_blocking&gt;</computeroutput> if the triangulation data structure is concurrency-safe, and <computeroutput>void</computeroutput> otherwise. In order to use concurrent operations, the user must provide a reference to a <computeroutput><ref refid="classSurjectiveLockDataStructure" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">SurjectiveLockDataStructure</ref></computeroutput> instance via the constructor or <computeroutput><ref refid="classCGAL_1_1Triangulation__3_1afba384e440c57f3bb0a71e4b4f7f9944" kindref="member">Triangulation_3::set_lock_data_structure()</ref></computeroutput>.</para></parameterdescription>
</parameteritem>
</parameterlist>
If <computeroutput>TDS::Concurrency_tag</computeroutput> is <computeroutput><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Parallel_tag</ref></computeroutput>, some operations, such as insertion/removal of a range of points, are performed in parallel. See the documentation of the operations for more details.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Triangulation__3" kindref="compound">CGAL::Triangulation_3</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound">CGAL::Regular_triangulation_3</ref></computeroutput> </para></simplesect>
</para>    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>CGAL::Triangulation_3&lt; Traits, Delaunay_triangulation_3&lt; Traits, TDS, LP &gt;::Triangulation_data_structure, SLDS &gt;</label>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="3" relation="template-instance">
          <edgelabel>&lt; Traits, Delaunay_triangulation_3&lt; Traits, TDS, LP &gt;::Triangulation_data_structure, SLDS &gt;</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>CGAL::Triangulation_3&lt; Traits, TDS, SLDS &gt;</label>
        <link refid="classCGAL_1_1Triangulation__3"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="0">
        <label>CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;</label>
        <link refid="classCGAL_1_1Delaunay__triangulation__3"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>CGAL::Triangulation_utils_3</label>
        <link refid="structCGAL_1_1Triangulation__utils__3" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="5">
        <label>CGAL::Triangulation_3&lt; Traits, Delaunay_triangulation_3&lt; Traits, TDS, LP &gt;::Triangulation_data_structure, SLDS &gt;</label>
        <childnode refid="6" relation="public-inheritance">
        </childnode>
        <childnode refid="7" relation="template-instance">
          <edgelabel>&lt; Traits, Delaunay_triangulation_3&lt; Traits, TDS, LP &gt;::Triangulation_data_structure, SLDS &gt;</edgelabel>
        </childnode>
      </node>
      <node id="7">
        <label>CGAL::Triangulation_3&lt; Traits, TDS, SLDS &gt;</label>
        <link refid="classCGAL_1_1Triangulation__3"/>
        <childnode refid="6" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>CGAL::Delaunay_triangulation_3&lt; Traits, TDS, LP, SLDS &gt;</label>
        <link refid="classCGAL_1_1Delaunay__triangulation__3"/>
        <childnode refid="5" relation="public-inheritance">
        </childnode>
      </node>
      <node id="6">
        <label>CGAL::Triangulation_utils_3</label>
        <link refid="structCGAL_1_1Triangulation__utils__3" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/TDS_3.tag"/>
      </node>
    </collaborationgraph>
    <location file="CGAL/Delaunay_triangulation_3.h" line="65" column="1" bodyfile="CGAL/Delaunay_triangulation_3.h" bodystart="60" bodyend="613"/>
    <listofallmembers>
      <member refid="structCGAL_1_1Triangulation__utils__3_1a3e483dd7b1e45dd3bcce3dbc7f94bd70" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>ccw</name></member>
      <member refid="structCGAL_1_1Triangulation__utils__3_1a39b8813b2f15dcb4446ff42b5c100529" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>cw</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a27cf6ca83aed76f9753cd259bb03427f" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Delaunay_triangulation_3</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1ac505d625652b8e261cdc3c51167df4ab" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Delaunay_triangulation_3</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a8fadb72818aa6db2f75769285bde3633" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Delaunay_triangulation_3</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a7bd4dc9b3e75b71684711553290ad0a6" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Delaunay_triangulation_3</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a5942b55dddff54923b0eae939a975c93" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>draw_dual</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a884486a709825b8b6e60e12bba12565f" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>dual</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a40ebe001c6f2c93c8548b5c1b39f9c23" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>dual</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1aadb2d4b16cd667dc825b7fc928268ad2" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>dual</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1acfd6b7eda707eb0921172de7699db4fb" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>dual_support</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a16f8135a2fed6f90b3633de91997fbec" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>find_conflicts</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a3fbf4cc1417acdeb38acb3080aa109ea" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>find_conflicts</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a7086ace7dcbdea1f84fe8b5ff53e93c5" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Geom_traits</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a5283a16d3299df75233d954deba71600" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>insert</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a74ce3ab18ea99ac623c2041e61d14155" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>insert</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a0a2340d8d34325e76bf6e33bc1aebc4f" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>insert</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1aa3e2b2a1f7eb7d5c458a68a3279b9baa" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>insert</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1ac3f567a3046efa25e775dca11c44cc8c" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>insert</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a187a8c96166ce8258bd2cc731367fcd3" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>is_Gabriel</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a953bfb5f115aeb33efbba6a81fde4f74" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>is_Gabriel</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a37839e8e20ca0b9ad3c09ea914bbd969" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>is_Gabriel</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1abb4dbf0d248a402308f76625f1a56d8a" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>is_Gabriel</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a96bba56ced4df414f88a5bd4a392a198" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>is_valid</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a129799fd5949cb0d5c24c33c0ec58210" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>is_valid</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a61b4e8d8949be012f6b3c38aeccc7f1e" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Line</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a2b8e91f69d68cc8396f52feda7927bc2" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Location_policy</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a2a61fe534c76315eac6dd34e877c0e33" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Lock_data_structure</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a579c9609e18ee98ef8ce524823a1fa2e" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>move</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1ae942d747804a847f1ebd7fb5c777f768" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>move_if_no_collision</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1ad1c7e6a808a671bb8efbe046c4bc5a70" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>nearest_vertex</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a97a3cc3b18cfc23458a809a9e1116f06" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>nearest_vertex_in_cell</name></member>
      <member refid="structCGAL_1_1Triangulation__utils__3_1a54bf42467e28dcbea13bfd022ef49217" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>next_around_edge</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1aa7c4f235ad99900dedd4710747e64d9f" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Object</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a0f6fa2295ea269d6c087a881024d4d82" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Plane</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1ac67b26badd4d1e87cb3ea45727a4d20c" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Ray</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a5f6dd6960f4e0c61d935d6ac7c730e97" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>remove</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a8ee5fbed77f873b000b0e2d3ab6c6582" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>remove</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1aa7b25857cf36948e81f8276f9cd0c88e" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>remove</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a9f83bb6a1d1c7d030498a23d53b5719e" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>remove_cluster</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a53e4b68dbad8d4ec4f96a6c1b2ad3b66" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>side_of_circle</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a444d028c149bebcbf41b08aa9cd83e15" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>side_of_circle</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1ace0836b01cf6b8e4dbb6f83f9fd3ba0e" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>side_of_sphere</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a655f31b326e5c1dbcef70d2e17f270ff" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>Triangulation_data_structure</name></member>
      <member refid="structCGAL_1_1Triangulation__utils__3_1a71288c8c2833f954a73090336ed60054" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>vertex_triple_index</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1ae05bed5daa28805e3fecb6f153d3984c" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>vertices_in_conflict</name></member>
      <member refid="classCGAL_1_1Delaunay__triangulation__3_1a74c53ed98bbbce2d98f9a89c783645d3" prot="public" virt="non-virtual"><scope>CGAL::Delaunay_triangulation_3</scope><name>vertices_on_conflict_zone_boundary</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
