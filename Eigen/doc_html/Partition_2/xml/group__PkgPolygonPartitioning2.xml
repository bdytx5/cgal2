<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="group__PkgPolygonPartitioning2" kind="group">
    <compoundname>PkgPolygonPartitioning2</compoundname>
    <title>2D Polygon Partitioning Reference</title>
    <innerclass refid="classCGAL_1_1Partition__is__valid__traits__2" prot="public">CGAL::Partition_is_valid_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Partition__traits__2" prot="public">CGAL::Partition_traits_2</innerclass>
    <innergroup refid="group__PkgPolygonPartitioning2Concepts">Concepts</innergroup>
    <innergroup refid="group__PkgPolygonPartitioning2FunctionObjectConcepts">Function Object Concepts</innergroup>
    <innergroup refid="group__PkgPolygonPartitioning2FunctionObjectClasses">Function Object Classes</innergroup>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PkgPolygonPartitioning2_1gae795b8beb8626322c448706e20a8ac9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::is_y_monotone_2</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const Traits &amp;traits)</argsstring>
        <name>is_y_monotone_2</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>determines if the sequence of points in the range [<computeroutput>first</computeroutput>, <computeroutput>beyond</computeroutput>) defines a <formula id="0">$ y$</formula>-monotone polygon or not. </para>        </briefdescription>
        <detaileddescription>
<para>If so, the function returns <computeroutput>true</computeroutput>, otherwise it returns <computeroutput>false</computeroutput>.</para><para><bold>Requires</bold><linebreak/>
</para><para><itemizedlist>
<listitem><para><computeroutput>Traits</computeroutput> is a model of the concept <computeroutput><ref refid="classIsYMonotoneTraits__2" kindref="compound">IsYMonotoneTraits_2</ref></computeroutput>.</para></listitem><listitem><para><computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Point_2</computeroutput>.</para></listitem></itemizedlist>
</para><para>The default traits class <computeroutput>Default_traits</computeroutput> is the kernel in which the type <computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput> is defined.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Is__y__monotone__2" kindref="compound">CGAL::Is_y_monotone_2</ref>&lt;Traits&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">CGAL::y_monotone_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaaf27de7c6e366901d744e6bc32e2a8a1" kindref="member">CGAL::y_monotone_partition_is_valid_2()</ref></computeroutput></para></simplesect>
<bold>Implementation</bold><linebreak/>
</para><para>This function requires <formula id="1">$ O(n)$</formula> time for a polygon with <formula id="2">$ n$</formula> vertices.</para><para><bold>Example</bold><linebreak/>
</para><para>The following program computes a <formula id="0">$ y$</formula>-monotone partitioning of a polygon using the default traits class and stores the partition polygons in the list <computeroutput>partition_polys</computeroutput>. It then asserts that each of the partition polygons is, in fact, a <formula id="0">$ y$</formula>-monotone polygon and that the partition is valid. (Note that the assertions are superfluous unless the postcondition checking done by <computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">y_monotone_partition_2()</ref></computeroutput> has been turned off during compilation.)</para><para><linebreak/>
<bold>File</bold> <ref refid="Partition_2_2y_monotone_partition_2_8cpp-example" kindref="compound">Partition_2/y_monotone_partition_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Partition_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/partition_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/random_polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">CGAL::Partition_traits_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::list&lt;Polygon_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_list;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;int, Point_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_square_2&lt;Point_2,<sp/>Creator&gt;<sp/><sp/><sp/>Point_generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>make_polygon(Polygon_2&amp;<sp/>polygon)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(391,<sp/>374));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(240,<sp/>431));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(252,<sp/>340));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(374,<sp/>320));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(289,<sp/>214));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(134,<sp/>390));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(<sp/>68,<sp/>186));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(154,<sp/>259));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(161,<sp/>107));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(435,<sp/>108));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(208,<sp/>148));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(295,<sp/>160));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(421,<sp/>212));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(441,<sp/>303));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Polygon_2<sp/><sp/><sp/><sp/>polygon;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Polygon_list<sp/>partition_polys;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/>CGAL::random_polygon_2(50,<sp/>std::back_inserter(polygon),</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_generator(100));</highlight></codeline>
<codeline><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>make_polygon(polygon);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">CGAL::y_monotone_partition_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(partition_polys));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::list&lt;Polygon_2&gt;::const_iterator<sp/><sp/><sp/>poly_it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(poly_it<sp/>=<sp/>partition_polys.begin();<sp/>poly_it<sp/>!=<sp/>partition_polys.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>poly_it++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>assert(<ref refid="group__PkgPolygonPartitioning2_1gae795b8beb8626322c448706e20a8ac9b" kindref="member">CGAL::is_y_monotone_2</ref>((*poly_it).vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*poly_it).vertices_end()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>assert(<ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">CGAL::partition_is_valid_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.end()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/is_y_monotone_2.h" line="44" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgPolygonPartitioning2_1gab9cf8c2b097fd562da09dd23d0c74edf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
          <param>
            <type>class <ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::approx_convex_partition_2</definition>
        <argsstring>(InputIterator first, InputIterator beyond, OutputIterator result, const Traits &amp;traits=Default_traits)</argsstring>
        <name>approx_convex_partition_2</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>beyond</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>result</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
          <defval>Default_traits</defval>
        </param>
        <briefdescription>
<para>computes a partition of the polygon defined by the points in the range [<computeroutput>first</computeroutput>, <computeroutput>beyond</computeroutput>) into convex polygons. </para>        </briefdescription>
        <detaileddescription>
<para>The counterclockwise-oriented partition polygons are written to the sequence starting at position <computeroutput>result</computeroutput>. The past-the-end iterator for the resulting sequence of polygons is returned.</para><para>The number of convex polygons produced is no more than four times the minimal number.</para><para><simplesect kind="pre"><para>The points in the range [<computeroutput>first</computeroutput>, <computeroutput>beyond</computeroutput>) define a simple counterclockwise-oriented polygon.</para></simplesect>
<bold>Requirements</bold><linebreak/>
</para><para><orderedlist>
<listitem>
<para><computeroutput>Traits</computeroutput> is a model of the concept <computeroutput><ref refid="classPartitionTraits__2" kindref="compound">PartitionTraits_2</ref></computeroutput> and, for the purposes of checking the postcondition that the partition produced is valid, it should also be a model of the concept <computeroutput><ref refid="classConvexPartitionIsValidTraits__2" kindref="compound">ConvexPartitionIsValidTraits_2</ref></computeroutput>. </para></listitem>
<listitem>
<para><computeroutput>std::iterator_traits&lt;<ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Polygon_2</computeroutput>. </para></listitem>
<listitem>
<para><computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Point_2</computeroutput>, which should also be the type of the points stored in an object of type <computeroutput>Traits::Polygon_2</computeroutput>. </para></listitem>
<listitem>
<para>Points in the range <computeroutput>[first, beyond)</computeroutput> must define a simple polygon whose vertices are oriented counterclockwise. </para></listitem>
</orderedlist>
</para><para>The default traits class <computeroutput>Default_traits</computeroutput> is <computeroutput><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">Partition_traits_2</ref></computeroutput>, with the representation type determined by <computeroutput>std::iterator_traits&lt;InputIterator1&gt;::value_type</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga9d234240af69b14694923824fc8fca12" kindref="member">CGAL::convex_partition_is_valid_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga68139e1ee98dffa8f72cb295881f4647" kindref="member">CGAL::greene_approx_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga3ca9fb1f363f9f792bfbbeca65ad5cc5" kindref="member">CGAL::optimal_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">CGAL::partition_is_valid_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Partition__is__valid__traits__2" kindref="compound">CGAL::Partition_is_valid_traits_2</ref>&lt;Traits, <ref refid="classPolygonIsValid" kindref="compound">PolygonIsValid</ref>&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">CGAL::y_monotone_partition_2()</ref></computeroutput></para></simplesect>
<bold>Implementation</bold><linebreak/>
</para><para>This function implements the algorithm of Hertel and Mehlhorn <ref refid="citelist_1CITEREF_hm-ftsp-83" kindref="member">[3]</ref> and is based on the class <computeroutput><ref refid="classCGAL_1_1Constrained__triangulation__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_2.tag">Constrained_triangulation_2</ref></computeroutput>. Given a triangulation of the polygon, the function requires <formula id="1">$ O(n)$</formula> time and space for a polygon with <formula id="2">$ n$</formula> vertices.</para><para><bold>Example</bold><linebreak/>
</para><para>The following program computes an approximately optimal convex partitioning of a polygon using the default traits class and stores the partition polygons in the list <computeroutput>partition_polys</computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Partition_2_2approx_convex_partition_2_8cpp-example" kindref="compound">Partition_2/approx_convex_partition_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Partition_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/partition_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/random_polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">CGAL::Partition_traits_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2_1abfdae92fbbf75d1076a711498bcfd8c5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2::Vertex_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::list&lt;Polygon_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_list;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;int, Point_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_square_2&lt;Point_2,<sp/>Creator&gt;<sp/><sp/><sp/>Point_generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>make_polygon(Polygon_2&amp;<sp/>polygon)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(391,<sp/>374));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(240,<sp/>431));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(252,<sp/>340));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(374,<sp/>320));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(289,<sp/>214));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(134,<sp/>390));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(<sp/>68,<sp/>186));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(154,<sp/>259));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(161,<sp/>107));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(435,<sp/>108));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(208,<sp/>148));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(295,<sp/>160));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(421,<sp/>212));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(441,<sp/>303));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Polygon_2<sp/><sp/><sp/><sp/>polygon;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Polygon_list<sp/>partition_polys;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/>CGAL::random_polygon_2(50,<sp/>std::back_inserter(polygon),</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_generator(100));</highlight></codeline>
<codeline><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>make_polygon(polygon);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><ref refid="group__PkgPolygonPartitioning2_1gab9cf8c2b097fd562da09dd23d0c74edf" kindref="member">CGAL::approx_convex_partition_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(partition_polys));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>assert(<ref refid="group__PkgPolygonPartitioning2_1ga9d234240af69b14694923824fc8fca12" kindref="member">CGAL::convex_partition_is_valid_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.end()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/partition_2.h" line="63" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgPolygonPartitioning2_1ga68139e1ee98dffa8f72cb295881f4647" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
          <param>
            <type>class <ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::greene_approx_convex_partition_2</definition>
        <argsstring>(InputIterator first, InputIterator beyond, OutputIterator result, const Traits &amp;traits=Default_traits)</argsstring>
        <name>greene_approx_convex_partition_2</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>beyond</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>result</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
          <defval>Default_traits</defval>
        </param>
        <briefdescription>
<para>computes a partition of the polygon defined by the points in the range [<computeroutput>first</computeroutput>, <computeroutput>beyond</computeroutput>) into convex polygons. </para>        </briefdescription>
        <detaileddescription>
<para>The counterclockwise-oriented partition polygons are written to the sequence starting at position <computeroutput>result</computeroutput>. The number of convex polygons produced is no more than four times the minimal number. The past-the-end iterator for the resulting sequence of polygons is returned.</para><para><simplesect kind="pre"><para>The points in the range [<computeroutput>first</computeroutput>, <computeroutput>beyond</computeroutput>) define a simple, counterclockwise-oriented polygon.</para></simplesect>
<bold>Requirements</bold><linebreak/>
</para><para><orderedlist>
<listitem>
<para><computeroutput>Traits</computeroutput> is a model of the concepts <computeroutput><ref refid="classPartitionTraits__2" kindref="compound">PartitionTraits_2</ref></computeroutput> and <computeroutput><ref refid="classYMonotonePartitionTraits__2" kindref="compound">YMonotonePartitionTraits_2</ref></computeroutput>. For the purpose of checking the validity of the <formula id="0">$ y$</formula>-monotone partition produced as a preprocessing step for the convex partitioning, it must also be a model of <computeroutput><ref refid="classYMonotonePartitionIsValidTraits__2" kindref="compound">YMonotonePartitionIsValidTraits_2</ref></computeroutput>. For the purpose of checking the postcondition that the convex partition is valid, <computeroutput>Traits</computeroutput> must also be a model of <computeroutput><ref refid="classConvexPartitionIsValidTraits__2" kindref="compound">ConvexPartitionIsValidTraits_2</ref></computeroutput>. </para></listitem>
<listitem>
<para><computeroutput>std::iterator_traits&lt;<ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref>&gt;::value_type</computeroutput> is equivalent to <computeroutput>Traits::Polygon_2</computeroutput>. </para></listitem>
<listitem>
<para><computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput> is equivalent to <computeroutput>Traits::Point_2</computeroutput>, which should also be equivalent to the type of the points stored in an object of type <computeroutput>Traits::Polygon_2</computeroutput>. </para></listitem>
</orderedlist>
</para><para>The default traits class <computeroutput>Default_traits</computeroutput> is <computeroutput><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">Partition_traits_2</ref></computeroutput>, with the representation type determined by <computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gab9cf8c2b097fd562da09dd23d0c74edf" kindref="member">CGAL::approx_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga9d234240af69b14694923824fc8fca12" kindref="member">CGAL::convex_partition_is_valid_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga3ca9fb1f363f9f792bfbbeca65ad5cc5" kindref="member">CGAL::optimal_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">CGAL::partition_is_valid_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">CGAL::y_monotone_partition_2()</ref></computeroutput></para></simplesect>
<bold>Implementation</bold><linebreak/>
</para><para>This function implements the approximation algorithm of Greene <ref refid="citelist_1CITEREF_g-dpcp-83" kindref="member">[2]</ref> and requires <formula id="3">$ O(n \log n)$</formula> time and <formula id="1">$ O(n)$</formula> space to produce a convex partitioning given a <formula id="0">$ y$</formula>-monotone partitioning of a polygon with <formula id="2">$ n$</formula> vertices. The function <computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">y_monotone_partition_2()</ref></computeroutput> is used to produce the monotone partition.</para><para><bold>Example</bold><linebreak/>
</para><para>The following program computes an approximately optimal convex partitioning of a polygon using the default traits class and stores the partition polygons in the list <computeroutput>partition_polys</computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Partition_2_2greene_approx_convex_partition_2_8cpp-example" kindref="compound">Partition_2/greene_approx_convex_partition_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Partition_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/partition_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/random_polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">CGAL::Partition_traits_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2_1abfdae92fbbf75d1076a711498bcfd8c5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2::Vertex_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::list&lt;Polygon_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_list;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;int, Point_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_square_2&lt;<sp/>Point_2,<sp/>Creator<sp/>&gt;<sp/>Point_generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>make_polygon(Polygon_2&amp;<sp/>polygon)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(391,<sp/>374));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(240,<sp/>431));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(252,<sp/>340));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(374,<sp/>320));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(289,<sp/>214));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(134,<sp/>390));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(<sp/>68,<sp/>186));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(154,<sp/>259));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(161,<sp/>107));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(435,<sp/>108));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(208,<sp/>148));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(295,<sp/>160));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(421,<sp/>212));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(441,<sp/>303));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Polygon_2<sp/><sp/><sp/><sp/>polygon;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Polygon_list<sp/>partition_polys;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/>CGAL::random_polygon_2(50,<sp/>std::back_inserter(polygon),</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_generator(100));</highlight></codeline>
<codeline><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>make_polygon(polygon);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><ref refid="group__PkgPolygonPartitioning2_1ga68139e1ee98dffa8f72cb295881f4647" kindref="member">CGAL::greene_approx_convex_partition_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(partition_polys),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>assert(<ref refid="group__PkgPolygonPartitioning2_1ga9d234240af69b14694923824fc8fca12" kindref="member">CGAL::convex_partition_is_valid_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_traits));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/partition_2.h" line="137" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgPolygonPartitioning2_1ga3ca9fb1f363f9f792bfbbeca65ad5cc5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
          <param>
            <type>class <ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::optimal_convex_partition_2</definition>
        <argsstring>(InputIterator first, InputIterator beyond, OutputIterator result, const Traits &amp;traits=Default_traits)</argsstring>
        <name>optimal_convex_partition_2</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>beyond</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>result</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
          <defval>Default_traits</defval>
        </param>
        <briefdescription>
<para>computes a partition of the polygon defined by the points in the range [<computeroutput>first</computeroutput>, <computeroutput>beyond</computeroutput>) into convex polygons. </para>        </briefdescription>
        <detaileddescription>
<para>The counterclockwise-oriented partition polygons are written to the sequence starting at position <computeroutput>result</computeroutput>. The number of convex polygons produced is minimal. The past-the-end iterator for the resulting sequence of polygons is returned.</para><para><simplesect kind="pre"><para>The points in the range [<computeroutput>first</computeroutput>, <computeroutput>beyond</computeroutput>) define a simple, counterclockwise-oriented polygon.</para></simplesect>
<bold>Requirements</bold><linebreak/>
</para><para><orderedlist>
<listitem>
<para><computeroutput>Traits</computeroutput> is a model of the concept <computeroutput><ref refid="classOptimalConvexPartitionTraits__2" kindref="compound">OptimalConvexPartitionTraits_2</ref></computeroutput>. For the purposes of checking the postcondition that the partition is valid, <computeroutput>Traits</computeroutput> should also be a model of <computeroutput><ref refid="classConvexPartitionIsValidTraits__2" kindref="compound">ConvexPartitionIsValidTraits_2</ref></computeroutput>.</para><para></para></listitem>
<listitem>
<para><computeroutput>std::iterator_traits&lt;<ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Polygon_2</computeroutput>. </para></listitem>
<listitem>
<para><computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Point_2</computeroutput>, which should also be the type of the points stored in an object of type <computeroutput>Traits::Polygon_2</computeroutput>. </para></listitem>
</orderedlist>
</para><para>The default traits class <computeroutput>Default_traits</computeroutput> is <computeroutput><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">Partition_traits_2</ref></computeroutput>, with the representation type determined by <computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gab9cf8c2b097fd562da09dd23d0c74edf" kindref="member">CGAL::approx_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga9d234240af69b14694923824fc8fca12" kindref="member">CGAL::convex_partition_is_valid_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga68139e1ee98dffa8f72cb295881f4647" kindref="member">CGAL::greene_approx_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">CGAL::partition_is_valid_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Partition__is__valid__traits__2" kindref="compound">CGAL::Partition_is_valid_traits_2</ref>&lt;Traits, <ref refid="classPolygonIsValid" kindref="compound">PolygonIsValid</ref>&gt;</computeroutput></para></simplesect>
<bold>Implementation</bold><linebreak/>
</para><para>This function implements the dynamic programming algorithm of Greene <ref refid="citelist_1CITEREF_g-dpcp-83" kindref="member">[2]</ref>, which requires <formula id="4">$ O(n^4)$</formula> time and <formula id="5">$ O(n^3)$</formula> space to produce a partitioning of a polygon with <formula id="2">$ n$</formula> vertices.</para><para><bold>Example</bold><linebreak/>
</para><para>The following program computes an optimal convex partitioning of a polygon using the default traits class and stores the partition polygons in the list <computeroutput>partition_polys</computeroutput>. It then asserts that the partition produced is valid. The traits class used for testing the validity is derived from the traits class used to produce the partition with the function object class <computeroutput><ref refid="classCGAL_1_1Is__convex__2" kindref="compound">Is_convex_2</ref></computeroutput> used to define the required <computeroutput>Is_valid</computeroutput> type. (Note that this assertion is superfluous unless the postcondition checking for <computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga3ca9fb1f363f9f792bfbbeca65ad5cc5" kindref="member">optimal_convex_partition_2()</ref></computeroutput> has been turned off.)</para><para><linebreak/>
<bold>File</bold> <ref refid="Partition_2_2optimal_convex_partition_2_8cpp-example" kindref="compound">Partition_2/optimal_convex_partition_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Partition_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Partition_is_valid_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/polygon_function_objects.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/partition_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/random_polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">CGAL::Partition_traits_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Is__convex__2" kindref="compound">CGAL::Is_convex_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Is_convex_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polygon_2::Vertex_const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::list&lt;Polygon_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_list;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Partition__is__valid__traits__2" kindref="compound">CGAL::Partition_is_valid_traits_2&lt;Traits, Is_convex_2&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Validity_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;int, Point_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_square_2&lt;Point_2,<sp/>Creator&gt;<sp/><sp/><sp/>Point_generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>make_polygon(Polygon_2&amp;<sp/>polygon)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(391,<sp/>374));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(240,<sp/>431));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(252,<sp/>340));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(374,<sp/>320));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(289,<sp/>214));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(134,<sp/>390));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(<sp/>68,<sp/>186));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(154,<sp/>259));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(161,<sp/>107));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(435,<sp/>108));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(208,<sp/>148));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(295,<sp/>160));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(421,<sp/>212));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(441,<sp/>303));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Polygon_list<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Validity_traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/>validity_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/>CGAL::random_polygon_2(50,<sp/>std::back_inserter(polygon),</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_generator(100));</highlight></codeline>
<codeline><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>make_polygon(polygon);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><ref refid="group__PkgPolygonPartitioning2_1ga3ca9fb1f363f9f792bfbbeca65ad5cc5" kindref="member">CGAL::optimal_convex_partition_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(partition_polys),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>assert(<ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">CGAL::partition_is_valid_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>validity_traits));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/partition_2.h" line="211" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
          <param>
            <type>class <ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::y_monotone_partition_2</definition>
        <argsstring>(InputIterator first, InputIterator beyond, OutputIterator result, const Traits &amp;traits=Default_traits)</argsstring>
        <name>y_monotone_partition_2</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>beyond</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>result</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
          <defval>Default_traits</defval>
        </param>
        <briefdescription>
<para>computes a partition of the polygon defined by the points in the range [<computeroutput>first</computeroutput>, <computeroutput>beyond</computeroutput>) into <formula id="0">$ y$</formula>-monotone polygons. </para>        </briefdescription>
        <detaileddescription>
<para>The counterclockwise-oriented partition polygons are written to the sequence starting at position <computeroutput>result</computeroutput>. The past-the-end iterator for the resulting sequence of polygons is returned.</para><para><simplesect kind="pre"><para>The points in the range [<computeroutput>first</computeroutput>, <computeroutput>beyond</computeroutput>) define a simple, counterclockwise-oriented polygon.</para></simplesect>
<bold>Requirements</bold><linebreak/>
</para><para><orderedlist>
<listitem>
<para><computeroutput>Traits</computeroutput> is a model of the concept <computeroutput><ref refid="classYMonotonePartitionTraits__2" kindref="compound">YMonotonePartitionTraits_2</ref></computeroutput> and, for the purposes of checking the postcondition that the partition is valid, it should also be a model of <computeroutput><ref refid="classYMonotonePartitionIsValidTraits__2" kindref="compound">YMonotonePartitionIsValidTraits_2</ref></computeroutput>. </para></listitem>
<listitem>
<para><computeroutput>std::iterator_traits&lt;<ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Polygon_2</computeroutput>. </para></listitem>
<listitem>
<para><computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Point_2</computeroutput>, which should also be the type of the points stored in an object of type <computeroutput>Traits::Polygon_2</computeroutput>. </para></listitem>
</orderedlist>
</para><para>The default traits class <computeroutput>Default_traits</computeroutput> is <computeroutput><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">Partition_traits_2</ref></computeroutput>, with the representation type determined by <computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gab9cf8c2b097fd562da09dd23d0c74edf" kindref="member">CGAL::approx_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga68139e1ee98dffa8f72cb295881f4647" kindref="member">CGAL::greene_approx_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga3ca9fb1f363f9f792bfbbeca65ad5cc5" kindref="member">CGAL::optimal_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">CGAL::partition_is_valid_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaaf27de7c6e366901d744e6bc32e2a8a1" kindref="member">CGAL::y_monotone_partition_is_valid_2()</ref></computeroutput></para></simplesect>
<bold>Implementation</bold><linebreak/>
</para><para>This function implements the algorithm presented by de Berg <emphasis>et al.</emphasis> <ref refid="citelist_1CITEREF_bkos-cgaa-97" kindref="member">[1]</ref> which requires <formula id="3">$ O(n \log n)$</formula> time and <formula id="1">$ O(n)$</formula> space for a polygon with <formula id="2">$ n$</formula> vertices.</para><para><bold>Example</bold><linebreak/>
</para><para>The following program computes a <formula id="0">$ y$</formula>-monotone partitioning of a polygon using the default traits class and stores the partition polygons in the list <computeroutput>partition_polys</computeroutput>. It then asserts that each partition polygon produced is, in fact, <formula id="0">$ y$</formula>-monotone and that the partition is valid. (Note that these assertions are superfluous unless the postcondition checking for <computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">y_monotone_partition_2()</ref></computeroutput> has been turned off.)</para><para><linebreak/>
<bold>File</bold> <ref refid="Partition_2_2y_monotone_partition_2_8cpp-example" kindref="compound">Partition_2/y_monotone_partition_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Partition_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/partition_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/random_polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">CGAL::Partition_traits_2&lt;K&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::list&lt;Polygon_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_list;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;int, Point_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_square_2&lt;Point_2,<sp/>Creator&gt;<sp/><sp/><sp/>Point_generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>make_polygon(Polygon_2&amp;<sp/>polygon)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(391,<sp/>374));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(240,<sp/>431));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(252,<sp/>340));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(374,<sp/>320));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(289,<sp/>214));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(134,<sp/>390));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(<sp/>68,<sp/>186));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(154,<sp/>259));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(161,<sp/>107));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(435,<sp/>108));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(208,<sp/>148));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(295,<sp/>160));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(421,<sp/>212));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>polygon.push_back(Point_2(441,<sp/>303));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Polygon_2<sp/><sp/><sp/><sp/>polygon;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Polygon_list<sp/>partition_polys;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/>CGAL::random_polygon_2(50,<sp/>std::back_inserter(polygon),</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_generator(100));</highlight></codeline>
<codeline><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>make_polygon(polygon);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">CGAL::y_monotone_partition_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(partition_polys));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>std::list&lt;Polygon_2&gt;::const_iterator<sp/><sp/><sp/>poly_it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(poly_it<sp/>=<sp/>partition_polys.begin();<sp/>poly_it<sp/>!=<sp/>partition_polys.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>poly_it++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>assert(<ref refid="group__PkgPolygonPartitioning2_1gae795b8beb8626322c448706e20a8ac9b" kindref="member">CGAL::is_y_monotone_2</ref>((*poly_it).vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*poly_it).vertices_end()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>assert(<ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">CGAL::partition_is_valid_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.end()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/partition_2.h" line="276" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgPolygonPartitioning2_1ga9d234240af69b14694923824fc8fca12" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
          <param>
            <type>class <ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::convex_partition_is_valid_2</definition>
        <argsstring>(InputIterator point_first, InputIterator point_beyond, ForwardIterator poly_first, ForwardIterator poly_beyond, const Traits &amp;traits=Default_traits)</argsstring>
        <name>convex_partition_is_valid_2</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>point_first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>point_beyond</declname>
        </param>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>poly_first</declname>
        </param>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>poly_beyond</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
          <defval>Default_traits</defval>
        </param>
        <briefdescription>
<para>determines if the polygons in the range [<computeroutput>poly_first</computeroutput>, <computeroutput>poly_beyond</computeroutput>) define a valid convex partition of the polygon defined by the points in the range [<computeroutput>point_first</computeroutput>, <computeroutput>point_beyond</computeroutput>). </para>        </briefdescription>
        <detaileddescription>
<para>A convex partition is valid if the polygons do not overlap, the union of the polygons is the same as the original polygon given by the sequence of points, and if each partition polygon is convex. The function returns <computeroutput>true</computeroutput> iff the partition is valid and otherwise returns <computeroutput>false</computeroutput>.</para><para><simplesect kind="pre"><para>The points in the range [<computeroutput>point_first</computeroutput>, <computeroutput>point_beyond</computeroutput>) define a simple, counterclockwise-oriented polygon.</para></simplesect>
<bold>Requires</bold><linebreak/>
</para><para><itemizedlist>
<listitem><para><computeroutput>Traits</computeroutput> is a model of the concept <computeroutput><ref refid="classConvexPartitionIsValidTraits__2" kindref="compound">ConvexPartitionIsValidTraits_2</ref></computeroutput>.</para></listitem><listitem><para><computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Point_2</computeroutput>, which should also be the type of the points stored in an object of type <computeroutput>Traits::Polygon_2</computeroutput>.</para></listitem><listitem><para><computeroutput>std::iterator_traits&lt;<ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Polygon_2</computeroutput>.</para></listitem></itemizedlist>
</para><para>The default traits class <computeroutput>Default_traits</computeroutput> is <computeroutput><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">Partition_traits_2</ref></computeroutput>, with the representation type determined by <computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gab9cf8c2b097fd562da09dd23d0c74edf" kindref="member">CGAL::approx_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga68139e1ee98dffa8f72cb295881f4647" kindref="member">CGAL::greene_approx_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga3ca9fb1f363f9f792bfbbeca65ad5cc5" kindref="member">CGAL::optimal_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">CGAL::partition_is_valid_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput>CGAL::is_convex_2()</computeroutput></para></simplesect>
<bold>Implementation</bold><linebreak/>
</para><para>This function calls <computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">partition_is_valid_2()</ref></computeroutput> using the function object <computeroutput><ref refid="classCGAL_1_1Is__convex__2" kindref="compound">Is_convex_2</ref></computeroutput> to determine the convexity of each partition polygon. Thus the time required by this function is <formula id="6">$ O(n \log n + e \log e)$</formula> where <formula id="2">$ n$</formula> is the total number of vertices in the partition polygons and <formula id="7">$ e$</formula> the total number of edges.</para><para><bold>Example</bold><linebreak/>
</para><para>See the example presented with the function <computeroutput><ref refid="group__PkgPolygonPartitioning2_1gab9cf8c2b097fd562da09dd23d0c74edf" kindref="member">approx_convex_partition_2()</ref></computeroutput> for an illustration of the use of this function. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/partition_is_valid_2.h" line="57" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
          <param>
            <type>class <ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::partition_is_valid_2</definition>
        <argsstring>(InputIterator point_first, InputIterator point_beyond, ForwardIterator poly_first, ForwardIterator poly_beyond, const Traits &amp;traits=Default_traits)</argsstring>
        <name>partition_is_valid_2</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>point_first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>point_beyond</declname>
        </param>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>poly_first</declname>
        </param>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>poly_beyond</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
          <defval>Default_traits</defval>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff the polygons in the range [<computeroutput>poly_first</computeroutput>, <computeroutput>poly_beyond</computeroutput>) define a valid partition of the polygon defined by the points in the range [<computeroutput>point_first</computeroutput>, <computeroutput>point_beyond</computeroutput>) and <computeroutput>false</computeroutput> otherwise. </para>        </briefdescription>
        <detaileddescription>
<para>A valid partition is one in which the polygons are nonoverlapping and the union of the polygons is the same as the original polygon. Each polygon must also satisfy the property tested by <computeroutput>Traits::Is_valid()</computeroutput>.</para><para><simplesect kind="pre"><para>Points in the range [<computeroutput>point_first</computeroutput>, <computeroutput>point_beyond</computeroutput>) define a simple, counterclockwise-oriented polygon.</para></simplesect>
<bold>Requires</bold><linebreak/>
</para><para><itemizedlist>
<listitem><para><computeroutput>Traits</computeroutput> is a model of the concept <computeroutput><ref refid="classPartitionIsValidTraits__2" kindref="compound">PartitionIsValidTraits_2</ref></computeroutput> and the concept defining the requirements for the validity test implemented by <computeroutput>Traits::Is_valid()</computeroutput>.</para></listitem><listitem><para><computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Point_2</computeroutput>, which should also be the type of the points stored in an object of type <computeroutput>Traits::Polygon_2</computeroutput>.</para></listitem><listitem><para><computeroutput>std::iterator_traits&lt;<ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Polygon_2</computeroutput>.</para></listitem></itemizedlist>
</para><para>The default traits class <computeroutput>Default_traits</computeroutput> is <computeroutput><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">Partition_traits_2</ref></computeroutput>, with the representation type determined by <computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gab9cf8c2b097fd562da09dd23d0c74edf" kindref="member">CGAL::approx_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga68139e1ee98dffa8f72cb295881f4647" kindref="member">CGAL::greene_approx_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gae795b8beb8626322c448706e20a8ac9b" kindref="member">CGAL::is_y_monotone_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga3ca9fb1f363f9f792bfbbeca65ad5cc5" kindref="member">CGAL::optimal_convex_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Partition__is__valid__traits__2" kindref="compound">CGAL::Partition_is_valid_traits_2</ref>&lt;Traits, <ref refid="classPolygonIsValid" kindref="compound">PolygonIsValid</ref>&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">CGAL::y_monotone_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput>CGAL::is_convex_2()</computeroutput></para></simplesect>
<bold>Implementation</bold><linebreak/>
</para><para>This function requires <formula id="8">$ O(n \log n + e \log e + \Sigma_{i=1}^p m_i)$</formula> where <formula id="2">$ n$</formula> is the total number of vertices of the <formula id="9">$ p$</formula> partition polygons, <formula id="7">$ e$</formula> is the total number of edges of the partition polygons and <formula id="10">$ m_i$</formula> is the time required by <computeroutput>Traits::Is_valid()</computeroutput> to test if partition polygon <formula id="11">$ p_i$</formula> is valid.</para><para><bold>Example</bold><linebreak/>
</para><para>See the example presented with the function <computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga3ca9fb1f363f9f792bfbbeca65ad5cc5" kindref="member">optimal_convex_partition_2()</ref></computeroutput> for an illustration of the use of this function. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/partition_is_valid_2.h" line="119" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgPolygonPartitioning2_1gaaf27de7c6e366901d744e6bc32e2a8a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
          <param>
            <type>class <ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::y_monotone_partition_is_valid_2</definition>
        <argsstring>(InputIterator point_first, InputIterator point_beyond, ForwardIterator poly_first, ForwardIterator poly_beyond, const Traits &amp;traits=Default_traits)</argsstring>
        <name>y_monotone_partition_is_valid_2</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>point_first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>point_beyond</declname>
        </param>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>poly_first</declname>
        </param>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>poly_beyond</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
          <defval>Default_traits</defval>
        </param>
        <briefdescription>
<para>determines if the polygons in the range [<computeroutput>poly_first</computeroutput>, <computeroutput>poly_beyond</computeroutput>) define a valid <formula id="0">$ y$</formula>-monotone partition of the simple, counterclockwise-oriented polygon represented by the points in the range [<computeroutput>point_first</computeroutput>, <computeroutput>point_beyond</computeroutput>). </para>        </briefdescription>
        <detaileddescription>
<para>A valid partition is one in which the polygons are nonoverlapping and the union of the polygons is the same as the original polygon and each polygon is <formula id="0">$ y$</formula>-monotone</para><para><simplesect kind="pre"><para>P The function returns <computeroutput>true</computeroutput> iff the partition is valid and otherwise returns false.</para></simplesect>
<bold>Requires</bold><linebreak/>
</para><para><itemizedlist>
<listitem><para><computeroutput>Traits</computeroutput> is a model of the concept <computeroutput><ref refid="classYMonotonePartitionIsValidTraits__2" kindref="compound">YMonotonePartitionIsValidTraits_2</ref></computeroutput>.</para></listitem><listitem><para><computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Point_2</computeroutput>, which should also be the type of the points stored in an object of type <computeroutput>Traits::Polygon_2</computeroutput>.</para></listitem><listitem><para><computeroutput>std::iterator_traits&lt;<ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref>&gt;::value_type</computeroutput> should be <computeroutput>Traits::Polygon_2</computeroutput>.</para></listitem></itemizedlist>
</para><para>The default traits class <computeroutput>Default_traits</computeroutput> is <computeroutput><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">Partition_traits_2</ref></computeroutput>, with the representation type determined by <computeroutput>std::iterator_traits&lt;<ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref>&gt;::value_type</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">CGAL::y_monotone_partition_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gae795b8beb8626322c448706e20a8ac9b" kindref="member">CGAL::is_y_monotone_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">CGAL::partition_is_valid_2()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Partition__is__valid__traits__2" kindref="compound">CGAL::Partition_is_valid_traits_2</ref>&lt;Traits, <ref refid="classPolygonIsValid" kindref="compound">PolygonIsValid</ref>&gt;</computeroutput></para></simplesect>
<bold>Implementation</bold><linebreak/>
</para><para>This function uses the function <computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">partition_is_valid_2()</ref></computeroutput> together with the function object <computeroutput><ref refid="classCGAL_1_1Is__y__monotone__2" kindref="compound">Is_y_monotone_2</ref></computeroutput> to determine if each polygon is <formula id="0">$ y$</formula>-monotone or not. Thus the time required is <formula id="6">$ O(n \log n + e \log e)$</formula> where <formula id="2">$ n$</formula> is the total number of vertices of the partition polygons and <formula id="7">$ e$</formula> is the total number of edges.</para><para><bold>Example</bold><linebreak/>
</para><para>See the example presented with the function <computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">y_monotone_partition_2()</ref></computeroutput> for an illustration of the use of this function. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/partition_is_valid_2.h" line="178" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para> <image type="html" name="Partition_2-teaser-small.png"></image>
   Susan Hert This package provides functions for partitioning polygons in monotone or convex polygons. The algorithms can produce results with the minimal number of polygons, as well as approximations which have no more than four times the optimal number of convex pieces but they differ in their runtime complexities. <linebreak/>
   <bold>Introduced in:</bold> CGAL 2.3<linebreak/>
 <bold>BibTeX:</bold> <ulink url="../Manual/how_to_cite_cgal.html#cgal:h-pp2-18b">cgal:h-pp2-18b</ulink><linebreak/>
 <bold>License:</bold> <ref refid="preliminaries_1licensesGPL" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">GPL</ref> <linebreak/>
 <bold>Windows Demos:</bold> <ulink url="https://www.cgal.org/demo/4.13/partition_2.zip">2D Polygon Partition</ulink>, <ulink url="https://www.cgal.org/demo/4.13/polygon.zip">Operations on Polygons</ulink><linebreak/>
<bold>Common Demo Dlls:</bold> <ulink url="https://www.cgal.org/demo/4.13/CGAL-demoDLLs.zip">dlls</ulink><linebreak/>
 </para><para><heading level="2">Definitions</heading>
</para><para>A <emphasis>partition</emphasis> of a polygon is a set of polygons such that the interiors of the polygons do not intersect and the union of the polygons is equal to the interior of the original polygon. Functions are available for partitioning planar polygons into two types of subpolygons (<computeroutput>y</computeroutput>-monotone polygons and convex polygons).</para><para>The function that produces a <computeroutput>y</computeroutput>-monotone partitioning is based on the algorithm presented in <ref refid="citelist_1CITEREF_bkos-cgaa-97" kindref="member">[1]</ref> which requires <formula id="26">$ O(n \log n) $</formula> time and <formula id="27">$ O(n) $</formula> space for a polygon with <formula id="28">$ n $</formula> vertices and guarantees nothing about the number of polygons produced with respect to the optimal number Three functions are provided for producing convex partitions. Two of these functions produce approximately optimal partitions and one results in an optimal partition, where <emphasis>optimal</emphasis> is defined in terms of the number of partition polygons. The two functions that implement approximation algorithms are guaranteed to produce no more than four times the optimal number of convex pieces. The optimal partitioning function provides an implementation of Greene&apos;s dynamic programming algorithm <ref refid="citelist_1CITEREF_g-dpcp-83" kindref="member">[2]</ref>, which requires <formula id="29">$ O(n^4) $</formula> time and <formula id="30">$ O(n^3) $</formula> space to produce a convex partitioning. One of the approximation algorithms is also due to Greene <ref refid="citelist_1CITEREF_g-dpcp-83" kindref="member">[2]</ref> and requires <formula id="26">$ O(n \log n) $</formula> time and <formula id="27">$ O(n) $</formula> space to produce a convex partitioning given a <computeroutput>y</computeroutput>-monotone partitioning. The other approximation algorithm is a result of Hertel and Mehlhorn <ref refid="citelist_1CITEREF_hm-ftsp-83" kindref="member">[3]</ref>, which requires <formula id="27">$ O(n) $</formula> time and space to produce a convex partitioning from a triangulation of a polygon. Each of the partitioning functions uses a traits class to supply the primitive types and predicates used by the algorithms.</para><para><heading level="2">Assertions</heading>
</para><para>The assertion flags for this package use <computeroutput>PARTITION</computeroutput> in their names (<emphasis>e.g.</emphasis>, <computeroutput>CGAL_PARTITION_NO_POSTCONDITIONS</computeroutput>). The precondition checks for the planar polygon partitioning functions are: counterclockwise ordering of the input vertices and simplicity of the polygon these vertices represent.</para><para>The postcondition checks are: simplicity, counterclockwise orientation, and convexity (or <formula id="0">$ y$</formula>-monotonicity) of the partition polygons and validity of the partition (<emphasis>i.e.</emphasis>, the partition polygons are nonoverlapping and the union of these polygons is the same as the original polygon).</para><para></para><para><heading level="2">Concepts</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classConvexPartitionIsValidTraits__2" kindref="compound">ConvexPartitionIsValidTraits_2</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classIsYMonotoneTraits__2" kindref="compound">IsYMonotoneTraits_2</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classOptimalConvexPartitionTraits__2" kindref="compound">OptimalConvexPartitionTraits_2</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classPartitionTraits__2" kindref="compound">PartitionTraits_2</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classPartitionIsValidTraits__2" kindref="compound">PartitionIsValidTraits_2</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classYMonotonePartitionIsValidTraits__2" kindref="compound">YMonotonePartitionIsValidTraits_2</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classYMonotonePartitionTraits__2" kindref="compound">YMonotonePartitionTraits_2</ref></computeroutput></para></listitem></itemizedlist>
</para><para><heading level="2">Function Object Concepts</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classPolygonIsValid" kindref="compound">PolygonIsValid</ref></computeroutput></para></listitem></itemizedlist>
</para><para><heading level="2">Classes</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Partition__is__valid__traits__2" kindref="compound">CGAL::Partition_is_valid_traits_2</ref>&lt;Traits, <ref refid="classPolygonIsValid" kindref="compound">PolygonIsValid</ref>&gt;</computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">CGAL::Partition_traits_2</ref>&lt;R&gt;</computeroutput></para></listitem></itemizedlist>
</para><para><heading level="2">Function Object Classes</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Is__convex__2" kindref="compound">CGAL::Is_convex_2</ref>&lt;Traits&gt;</computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Is__vacuously__valid" kindref="compound">CGAL::Is_vacuously_valid</ref>&lt;Traits&gt;</computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Is__y__monotone__2" kindref="compound">CGAL::Is_y_monotone_2</ref>&lt;Traits&gt;</computeroutput></para></listitem></itemizedlist>
</para><para><heading level="2">Functions</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gab9cf8c2b097fd562da09dd23d0c74edf" kindref="member">CGAL::approx_convex_partition_2()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga9d234240af69b14694923824fc8fca12" kindref="member">CGAL::convex_partition_is_valid_2()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga68139e1ee98dffa8f72cb295881f4647" kindref="member">CGAL::greene_approx_convex_partition_2()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gae795b8beb8626322c448706e20a8ac9b" kindref="member">CGAL::is_y_monotone_2()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga3ca9fb1f363f9f792bfbbeca65ad5cc5" kindref="member">CGAL::optimal_convex_partition_2()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">CGAL::partition_is_valid_2()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">CGAL::y_monotone_partition_2()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgPolygonPartitioning2_1gaaf27de7c6e366901d744e6bc32e2a8a1" kindref="member">CGAL::y_monotone_partition_is_valid_2()</ref></computeroutput> </para></listitem></itemizedlist>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
