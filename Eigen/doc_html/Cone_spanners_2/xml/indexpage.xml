<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_ConeBasedSpanners"/>  <simplesect kind="author"><para>Weisheng Si, Quincy Tse and Frédérik Paradis</para></simplesect>
</para><sect1 id="index_1sec_CBS_Introduction">
<title>Introduction</title>
<para>This chapter describes the package for constructing two kinds of cone-based spanners: <emphasis>Yao graph</emphasis> and <emphasis>Theta graph</emphasis>, given a set of vertices on the plane and the directions of cone boundaries. Both exact and inexact constructions are supported. In exact construction, the cone boundaries are calculated using roots of polynomials, which achieves the exactness by avoiding using <formula id="0">$ \pi $</formula> in the computation. In inexact construction, the cone boundaries are calculated with a floating point approximation of <formula id="0">$ \pi $</formula> value and is still accurate enough for most applications. Moreover, for visualization purpose, this chapter describes a global function that, given a constructed graph as input, can generate the data and script files for <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink> to plot that graph.</para></sect1>
<sect1 id="index_1sec_CBS_mydefinitions">
<title>Definitions</title>
<para>This section gives detailed definitions of Yao graph and Theta graph, which are followed in our implementation. In particular, because this package supports constructing Yao graph and Theta graph exactly, we need to be clear on which cone a cone boundary belongs to. The definitions presented here clarify on this.</para><para>Given a set <formula id="1">$V$</formula> of vertices on the plane, the directed Yao Graph with an integer parameter <formula id="2">$k (k &gt; 1)$</formula> on <formula id="1">$V$</formula> is obtained as follows. For each vertex <formula id="3">$u \in V$</formula>, starting from a given direction (e.g., the direction of positive <formula id="4">$x$</formula>-axis), draw <formula id="5">$k$</formula> equally-spaced rays <formula id="6">$l_0$</formula>, <formula id="7">$l_1$</formula>, ..., <formula id="8">$l_{k-1}$</formula> originating from <formula id="9">$u$</formula> in counterclockwise order (see <ref refid="index_1fig__f-y5" kindref="member">fig__f-y5</ref> (a)). These rays divide the plane into <formula id="5">$k$</formula> cones of angle <formula id="10">$2\pi/k$</formula>, denoted by <formula id="11">$ c(u, 0), c(u, 1), ..., c(u, k-1)$</formula> respectively in counterclockwise order. To avoid overlapping at boundaries, it is stipulated here that the area of <formula id="12">$ c(u, i)$</formula>, where <formula id="13">$ i=0, \ldots, k-1$</formula>, includes the ray <formula id="14">$l_{i}$</formula> but excludes the ray <formula id="15">$l_{(i+1)\% k}$</formula>. In each cone of <formula id="9">$u$</formula>, draw a directed edge from <formula id="9">$u$</formula> to its closest vertex by Euclidean distance in that cone. Ties are broken arbitrarily. These directed edges will form the edge set of the directed Yao graph on <formula id="1">$V$</formula>. The undirected Yao Graph on <formula id="1">$V$</formula> is obtained by ignoring the directions of the edges. Note that if both edge <formula id="16">$uv$</formula> and <formula id="17">$vu$</formula> are in the directed Yao graph, only one edge <formula id="16">$uv$</formula> exists in the undirected Yao graph. <ref refid="index_1fig__f-y5" kindref="member">fig__f-y5</ref> (b) gives an example of Yao graph with <formula id="18">$k=5$</formula>.</para><para><anchor id="index_1fig__f-y5"/><image type="html" name="Example-Y5.jpg"></image>
 <image type="latex" name="Example-Y5.jpg" width="15cm"></image>
  <ref refid="index_1fig__f-y5" kindref="member">fig__f-y5</ref> Cones and an example of Yao Graph with <formula id="18">$k=5$</formula>.  <linebreak/>
</para><para>Similar to Yao graph, the directed or undirected Theta Graph is also obtained by letting each vertex <formula id="3">$u \in V$</formula> select a <emphasis>closest</emphasis> vertex in each of its cones to have an edge. The only difference is that <emphasis>closest</emphasis> in Theta Graph means the smallest projection distance onto the bisector of that cone, not the direct Euclidean distance. For instance, in <ref refid="index_1fig__f-theta" kindref="member">fig__f-theta</ref>, vertex <formula id="9">$u$</formula>&apos;s <emphasis>closest</emphasis> vertex will be vertex <formula id="19">$b$</formula>.</para><para><anchor id="index_1fig__f-theta"/><image type="html" name="BisectorInThetaGraph.jpg"></image>
 <image type="latex" name="BisectorInThetaGraph.jpg" width="15cm"></image>
  <ref refid="index_1fig__f-theta" kindref="member">fig__f-theta</ref> The bisector in a cone of a Theta Graph.  <linebreak/>
</para><para>Variants of Yao graph and Theta graph are Half Yao graph and Half Theta graph. The difference is that only the edges in the even or odd cones are drawn. For instance, in the even case of the Theta graph with <formula id="20">$k=6$</formula>, only the edges in the cones <formula id="21">$c(u, 0)$</formula>, <formula id="22">$c(u, 2)$</formula>, and <formula id="23">$c(u, 4)$</formula> are drawn.</para></sect1>
<sect1 id="index_1sec_CBS_design">
<title>Software Design</title>
<para>This package provides the following template functors:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Compute__cone__boundaries__2" kindref="compound">Compute_cone_boundaries_2</ref></computeroutput>: The functor for computing the directions of cone boundaries given a cone number and an initial direction.</para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">Construct_theta_graph_2</ref></computeroutput>: The functor for constructing Theta graphs given a set of vertices on the plane.</para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Construct__yao__graph__2" kindref="compound">Construct_yao_graph_2</ref></computeroutput>: The functor for constructing Yao graphs given a set of vertices on the plane.</para></listitem></itemizedlist>
</para><para>In addition to these functors, for visualizing the constructed graphs, this package provides a global function called <computeroutput><ref refid="group__PkgConeBasedSpanners_1ga54c3d6e9cf8a8f9c6330a32b496a03ce" kindref="member">CGAL::gnuplot_output_2()</ref></computeroutput> to output a <computeroutput>boost::adjacency_list</computeroutput> data structure to <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink> data and script files. Below, we detail the design and the usage of the above functors and function.</para><sect2 id="index_1subsec_CBS_cone">
<title>Computing Cone Boundaries</title>
<para>The functor <computeroutput><ref refid="classCGAL_1_1Compute__cone__boundaries__2" kindref="compound">Compute_cone_boundaries_2</ref></computeroutput> has the following definition.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Traits&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Compute_cone_boundaries_2;</highlight></codeline>
</programlisting></para><para>The template parameter <computeroutput>Traits</computeroutput> determines whether the cone boundaries are computed exactly or inexactly. If this parameter is <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__root__of" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel_with_root_of</ref></computeroutput>, the computation will be done exactly; if this parameter is <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>, the computation will be done inexactly. The exact computation is implemented based on the fact that when the cone angle <formula id="24">$ \theta $</formula> is in the form of <formula id="25">$ 2\pi / n $</formula>, where <formula id="26">$ n $</formula> is a positive integer, <formula id="27">$ \sin(\theta) $</formula> and <formula id="28">$ \cos(\theta) $</formula> can be represented exactly by roots of polynomials, thus avoiding using <formula id="0">$ \pi $</formula> in the computation. The exact computation requires the number type of either <computeroutput><ref refid="classCORE_1_1Expr" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CORE::Expr</ref></computeroutput> or <computeroutput><ref refid="classleda__real" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">leda_real</ref></computeroutput>. In inexact computation, the cone angle <formula id="24">$ \theta $</formula> is simply calculated as <formula id="29">$ 2\pi/k $</formula>, where <formula id="30">$ k $</formula> is the number of cones and <formula id="0">$ \pi $</formula> takes the value of the constant <computeroutput>CGAL_PI=3.14159265358979323846</computeroutput>. Then, the <formula id="27">$ \sin(\theta) $</formula> and <formula id="28">$ \cos(\theta) $</formula> are calculated. While the inexact computation is done by the general functor definition, the exact computation is done by a specialization of this functor.</para><para>This functor is currently used by the functors <computeroutput><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">Construct_theta_graph_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Construct__yao__graph__2" kindref="compound">Construct_yao_graph_2</ref></computeroutput> in constructing Theta and Yao graphs. This functor can also be used in other applications where the plane needs to be divided into equally-angled cones. For how to use this functor to compute cone boundaries in writing an application, please refer to Section <ref refid="index_1sec_CBS_examples" kindref="member">Examples</ref>.</para></sect2>
<sect2 id="index_1subsec_CBS_theta">
<title>Constructing a Theta Graph</title>
<para>The functor <computeroutput><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">Construct_theta_graph_2</ref></computeroutput> has the following definition</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Traits,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Graph&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Construct_theta_graph_2;</highlight></codeline>
</programlisting></para><para>Similar to the functor <computeroutput><ref refid="classCGAL_1_1Compute__cone__boundaries__2" kindref="compound">Compute_cone_boundaries_2</ref></computeroutput>, the template parameter <computeroutput>Traits</computeroutput> determines whether the Theta graph will constructed exactly or inexactly. The template parameter <computeroutput>Graph</computeroutput> specifies the graph type used to store the constructed graph. Our package requires it to be <ulink url="https://www.boost.org/libs/graph/doc/adjacency_list.html">boost::adjacency_list</ulink> from the Boost Graph Library (BGL). The advantage of using <computeroutput>boost::adjacency_list</computeroutput> is that it provides convenience to the further processing of the constructed graphs, since BGL includes most common graph algorithms. Note that BGL altogether provides two template classes for representing graphs: <computeroutput>boost::adjacency_list</computeroutput> and <computeroutput>boost::adjacency_matrix</computeroutput>, with the former suitable for sparse graphs and the latter suitable for dense graphs. While cone-based spanners are sparse graphs and the interfaces provided by <computeroutput>boost::adjacency_list</computeroutput> and <computeroutput>boost::adjacency_matrix</computeroutput> are different, our package only supports <computeroutput>boost::adjacency_list</computeroutput>.</para><para>Note that there are seven template parameters for <computeroutput>boost::adjacency_list</computeroutput> in BGL: <computeroutput>OutEdgeList</computeroutput>, <computeroutput>VertexList</computeroutput>, <computeroutput>Directed</computeroutput>, <computeroutput>VertexProperties</computeroutput>, <computeroutput>EdgeProperties</computeroutput>, <computeroutput>GraphProperties</computeroutput>, <computeroutput>EdgeList</computeroutput>, of which we require <computeroutput>VertexProperties</computeroutput> to be <computeroutput>Traits::Point_2</computeroutput>, and other parameters can be chosen freely. Also note that, here we pass <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> directly as <ulink url="https://www.boost.org/doc/libs/release/libs/graph/doc/bundles.html"><emphasis>bundled properties</emphasis></ulink> to <computeroutput>boost::adjacency_list</computeroutput>, because this makes our implementation more straightforward than using a property map. If you want more properties other than <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> for vertices, you can still construct external properties by using property maps.</para><para>In constructing Theta graphs, this functor uses the algorithm from Chapter 4 of the book by Narasimhan and Smid <ref refid="citelist_1CITEREF_cgal:ns-gsn-07" kindref="member">[2]</ref>. Basically, it is a sweep line algorithm and uses a balanced search tree to store the vertices that have already been scanned. It has the complexity of <formula id="31">$O(n \log n)$</formula>, where <formula id="32">$n$</formula> is the number of vertices in the plane. This complexity has been proved to be optimal.</para><para>For more details on how to use this <computeroutput><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">Construct_theta_graph_2</ref></computeroutput> functor to write an application to build Theta graphs, please refer to Section <ref refid="index_1sec_CBS_examples" kindref="member">Examples</ref>.</para></sect2>
<sect2 id="index_1subsec_CBS_yao">
<title>Constructing a Yao Graph</title>
<para>The functor <computeroutput><ref refid="classCGAL_1_1Construct__yao__graph__2" kindref="compound">Construct_yao_graph_2</ref></computeroutput> has a similar definition as <computeroutput><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">Construct_theta_graph_2</ref></computeroutput>.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Traits,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Graph&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Construct_yao_graph_2;</highlight></codeline>
</programlisting></para><para>The way of using these two template parameters is the same as that of <computeroutput><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">Construct_theta_graph_2</ref></computeroutput>, so please refer to the previous subsection for the details. We note here that construction algorithm for Yao graph is a slight adaptation of the algorithm for constructing Theta graph, having a complexity of <formula id="33">$O(n^2)$</formula>. The increase of complexity in this adaptation is because in constructing Theta graph, the searching of the &apos;closest&apos; node by projection distance can be done by a balanced search tree, but in constructing Yao graph, the searching of the &apos;closest&apos; node by Euclidean distance cannot be done by a balanced search tree.</para><para>Note that an optimal algorithm for constructing Yao graph with a complexity of <formula id="31">$O(n \log n)$</formula> is described in <ref refid="citelist_1CITEREF_cgal:cht-oacov-90" kindref="member">[1]</ref>. However, this algorithm is much more complex to implement than the current algorithm implemented, and it can hardly reuse the codes for constructing Theta graphs, so it is not implemented in this package right now.</para></sect2>
<sect2 id="index_1subsec_CBS_gnuplot">
<title>Gnuplot Output</title>
<para>This package also implements a template function <computeroutput><ref refid="group__PkgConeBasedSpanners_1ga54c3d6e9cf8a8f9c6330a32b496a03ce" kindref="member">CGAL::gnuplot_output_2()</ref></computeroutput>, which reads a <computeroutput>boost::adjacency_list</computeroutput> object and generate two files used by <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink> to visualize the graph stored in the <computeroutput>boost::adjacency_list</computeroutput> object. This template function has the following definition:</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Graph_&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__PkgConeBasedSpanners_1ga54c3d6e9cf8a8f9c6330a32b496a03ce" kindref="member">gnuplot_output_2</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Graph_&amp;<sp/>g,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>prefix);</highlight></codeline>
</programlisting></para><para>The template parameter <computeroutput>Graph_</computeroutput> specifies the type of the graph to be plotted. For this function to work, the graph type must be <computeroutput>boost::adjacency_list</computeroutput> with <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> as the <computeroutput>VertexProperties</computeroutput>. As for the two arguments to the function, <computeroutput>g</computeroutput> gives the graph to be plotted, and <computeroutput>prefix</computeroutput> gives the prefix for the names of the files generated by the function. Specifically, this function will generate the following two files:<itemizedlist>
<listitem><para>A data file named <computeroutput>prefix.v</computeroutput> that contains the <formula id="34">$(x, y)$</formula>-coordinates of each vertex. To be read by <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink>, the <formula id="34">$(x, y)$</formula>-coordinates are written into the data file with decimal format, no matter which number type is used in the CGAL kernel. This is achieved by calling <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">to_double()</ref></computeroutput> on <formula id="4">$x$</formula> or <formula id="35">$y$</formula> coordinate before outputting them.</para></listitem><listitem><para>A <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink> script file named <computeroutput>prefix.plt</computeroutput> to be loaded by <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink> to plot the set of vertices and the set of edges. The set of vertices is read from the above data file and the set of edges are included in the script file with the syntax <computeroutput>set arrow from x1, y1 to x2, y2</computeroutput>.</para></listitem></itemizedlist>
</para><para>For details on how to use this function to generate <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink> files, please refer to Section <ref refid="index_1sec_CBS_examples" kindref="member">Examples</ref>.</para></sect2>
</sect1>
<sect1 id="index_1sec_CBS_examples">
<title>Examples</title>
<sect2 id="index_1CBS_coneboundaries">
<title>Computing Cone Boundaries Exactly or Inexactly</title>
<para>The following example shows how to compute the directions of the cone boundaries exactly given the cone number and the initial direction. This example basically consists of the following steps:</para><para><orderedlist>
<listitem><para>Define <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__root__of" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel_with_root_of</ref></computeroutput> as the kernel type to compute the cone boundaries exactly.</para></listitem><listitem><para>Construct a <computeroutput><ref refid="classCGAL_1_1Compute__cone__boundaries__2" kindref="compound">Compute_cone_boundaries_2</ref></computeroutput> object named <computeroutput>cones</computeroutput> with the above kernel as the template parameter. Note that since the functor <computeroutput><ref refid="classCGAL_1_1Compute__cone__boundaries__2" kindref="compound">Compute_cone_boundaries_2</ref></computeroutput> has no member variables but member types and functions, its constructor needs no arguments.</para></listitem><listitem><para>Initialize a vector of <computeroutput><ref refid="classCGAL_1_1Direction__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Direction_2</ref></computeroutput> named <computeroutput>rays</computeroutput> to store the computed results.</para></listitem><listitem><para>Use <computeroutput>cones</computeroutput> to compute the cone boundaries by passing the cone number, the initial direction and the beginning iterator of <computeroutput>rays</computeroutput> to it.</para></listitem><listitem><para>Output the computed results.</para></listitem></orderedlist>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Cone_spanners_2_2compute_cones_8cpp-example" kindref="compound">Cone_spanners_2/compute_cones.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iterator&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel_with_root_of.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Compute_cone_boundaries_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>select<sp/>the<sp/>kernel<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__root__of" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel_with_root_of</ref><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Direction__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Direction_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Direction_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&lt;<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Usage:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>argv[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&lt;no.<sp/>of<sp/>cones&gt;<sp/>[&lt;direction-x&gt;<sp/>&lt;direction-y&gt;]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>atoi(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(k&lt;2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>number<sp/>of<sp/>cones<sp/>should<sp/>be<sp/>larger<sp/>than<sp/>1!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Direction_2<sp/>initial_direction;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>==<sp/>2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>initial_direction<sp/>=<sp/>Direction_2(1,<sp/>0);<sp/><sp/></highlight><highlight class="comment">//<sp/>default<sp/>initial_direction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>==<sp/>4)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>initial_direction<sp/>=<sp/>Direction_2(atof(argv[2]),<sp/>atof(argv[3]));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Usage:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>argv[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&lt;no.<sp/>of<sp/>cones&gt;<sp/>[&lt;direction-x&gt;<sp/>&lt;direction-y&gt;]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>construct<sp/>the<sp/>functor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Compute__cone__boundaries__2" kindref="compound">CGAL::Compute_cone_boundaries_2&lt;Kernel&gt;</ref><sp/>cones;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>the<sp/>vector<sp/>rays<sp/>to<sp/>store<sp/>the<sp/>results</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Direction_2&gt;<sp/>rays(k);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>the<sp/>cone<sp/>boundaries<sp/>and<sp/>store<sp/>them<sp/>in<sp/>rays</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cones(k,<sp/>initial_direction,<sp/>rays.begin());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>display<sp/>the<sp/>computed<sp/>rays,<sp/>starting<sp/>from<sp/>the<sp/>initial<sp/>direction,<sp/>ccw<sp/>order</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;k;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Ray<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>rays[i]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Note that, in this example, for any k&lt;=28, the computation can be done successfully; for any k&gt;28, the computation cannot be completed because <computeroutput><ref refid="classCORE_1_1Expr" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CORE::Expr</ref></computeroutput>, which we use as the number type for the exact kernel, exceeds its limit. It seems that k&lt;=28 will suffice for most applications. Also, if inexact computation is used, the computation will be successful for any k&gt;1, and much quicker than exact computation. We also note here that we don&apos;t experiment with <computeroutput><ref refid="classleda__real" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">leda_real</ref></computeroutput>.</para><para>As a final note, to compute the cone boundaries inexactly, just define the <computeroutput><ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> to be <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput> in the above example.</para></sect2>
<sect2 id="index_1CBS_construction">
<title>Constructing Graphs Exactly or Inexactly and Generating Gnuplot Files</title>
<para>The following example shows how to construct Theta graphs exactly and generate <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink> files. This example basically consists of the following steps:<orderedlist>
<listitem><para>Define <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__root__of" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel_with_root_of</ref></computeroutput> as the kernel type to construct the graph exactly.</para></listitem><listitem><para>Define the graph type to store the constructed graph.</para></listitem><listitem><para>Construct a <computeroutput><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">Construct_theta_graph_2</ref></computeroutput> object named <computeroutput>theta</computeroutput> with the number of cones and the initial direction as constructor arguments.</para></listitem><listitem><para>Construct a graph object <computeroutput>g</computeroutput> to store the constructed graph.</para></listitem><listitem><para>Use <computeroutput>theta</computeroutput> to construct the Theta graph by passing the input vertices and <computeroutput>g</computeroutput> to it.</para></listitem><listitem><para>Generate <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink> files for plotting the construct graph.</para></listitem></orderedlist>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Cone_spanners_2_2theta_io_8cpp-example" kindref="compound">Cone_spanners_2/theta_io.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iterator&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/lexical_cast.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel_with_root_of.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Construct_theta_graph_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/gnuplot_output_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>select<sp/>the<sp/>kernel<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__root__of" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel_with_root_of</ref><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Direction__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Direction_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Direction_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Note:<sp/>due<sp/>to<sp/>a<sp/>bug<sp/>in<sp/>the<sp/>boost<sp/>library,<sp/>using<sp/>a<sp/>directed<sp/>graph</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>will<sp/>cause<sp/>a<sp/>compilation<sp/>error<sp/>with<sp/>g++<sp/>and<sp/>clang++<sp/>when<sp/>using<sp/>c++11<sp/>standard.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>See<sp/>http://lists.boost.org/Archives/boost/2016/05/229458.php.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>define<sp/>the<sp/>graph<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::adjacency_list&lt;boost::listS,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::vecS,</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifdef<sp/>CGAL_CXX11</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::undirectedS,</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::directedS,</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&gt;<sp/>Graph;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&lt;<sp/>3)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Usage:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>argv[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&lt;no.<sp/>of<sp/>cones&gt;<sp/>&lt;input<sp/>filename&gt;<sp/>[&lt;direction-x&gt;<sp/>&lt;direction-y&gt;]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>atoi(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(k&lt;2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>number<sp/>of<sp/>cones<sp/>should<sp/>be<sp/>larger<sp/>than<sp/>1!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>open<sp/>the<sp/>file<sp/>containing<sp/>the<sp/>vertex<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>inf(argv[2]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!inf)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Cannot<sp/>open<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>argv[2]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Direction_2<sp/>initial_direction;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>==<sp/>3)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>initial_direction<sp/>=<sp/>Direction_2(1,<sp/>0);<sp/><sp/></highlight><highlight class="comment">//<sp/>default<sp/>initial_direction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>==<sp/>5)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>initial_direction<sp/>=<sp/>Direction_2(atof(argv[3]),<sp/>atof(argv[4]));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Usage:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>argv[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&lt;no.<sp/>of<sp/>cones&gt;<sp/>&lt;input<sp/>filename&gt;<sp/>[&lt;direction-x&gt;<sp/>&lt;direction-y&gt;]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>iterators<sp/>for<sp/>reading<sp/>the<sp/>vertex<sp/>list<sp/>file</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;Point_2&gt;<sp/>input_begin(<sp/>inf<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;Point_2&gt;<sp/>input_end;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>initialize<sp/>the<sp/>functor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">CGAL::Construct_theta_graph_2&lt;Kernel, Graph&gt;</ref><sp/>theta(k,<sp/>initial_direction);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>adjacency_list<sp/>object</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Graph<sp/>g;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>construct<sp/>the<sp/>theta<sp/>graph<sp/>on<sp/>the<sp/>vertex<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>theta(input_begin,<sp/>input_end,<sp/>g);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>obtain<sp/>the<sp/>number<sp/>of<sp/>vertices<sp/>in<sp/>the<sp/>constructed<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::graph_traits&lt;Graph&gt;::vertices_size_type<sp/>n<sp/>=<sp/>boost::num_vertices(g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>generate<sp/>gnuplot<sp/>files<sp/>for<sp/>plotting<sp/>this<sp/>graph</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>file_prefix<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;t&quot;</highlight><highlight class="normal"><sp/>+<sp/>boost::lexical_cast&lt;std::string&gt;(k)<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;n&quot;</highlight><highlight class="normal"><sp/>+<sp/>boost::lexical_cast&lt;std::string&gt;(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgConeBasedSpanners_1ga54c3d6e9cf8a8f9c6330a32b496a03ce" kindref="member">CGAL::gnuplot_output_2</ref>(g,<sp/>file_prefix);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>To construct Theta graphs inexactly, just define the <computeroutput><ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> to be <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput> in the above example. And the way of constructing Yao graphs exactly or inexactly is the same as that of constructing Theta graphs, just replacing the functor <computeroutput><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">Construct_theta_graph_2</ref></computeroutput> by the functor <computeroutput><ref refid="classCGAL_1_1Construct__yao__graph__2" kindref="compound">Construct_yao_graph_2</ref></computeroutput>.</para><para>Note that, for Theta graph, the <computeroutput><ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> defined must support the <computeroutput>CGAL::sqrt()</computeroutput> operation. This is required by the <computeroutput><ref refid="group__bisector__grp_1ga2ba217aec13a36b8171d110feda3a058" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">bisector()</ref></computeroutput> function, which is used to calculate the angle bisector of a cone. For instance, the compiler will complain if <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput> (not supporting <computeroutput>CGAL::sqrt()</computeroutput>) is defined as the kernel, but <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput> will be fine since it supports <computeroutput>CAL::sqrt()</computeroutput>. For Yao graph, there is no such restriction, since its construction does not need <computeroutput>CGAL::sqrt()</computeroutput>.</para><para>Also note that when using g++ or clang++ compilers with the c++11 standard, using a directed graph will cause a compilation error due to a <ulink url="http://lists.boost.org/Archives/boost/2016/05/229458.php">bug</ulink> in the boost library. As a workaround you can use a undirected graph instead.</para><para>After compiling <computeroutput>theta_io.cpp</computeroutput>, execute the executable <computeroutput>theta_io</computeroutput> to construct a Theta graph with 4 cones on a set of 20 vertices (which is given in the file <computeroutput>data/n20.cin</computeroutput>):</para><para><programlisting><codeline><highlight class="normal">$<sp/>./theta_io<sp/><sp/>4<sp/><sp/>data/n20.cin</highlight></codeline>
</programlisting></para><para>The following two files will be generated for <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink>:<itemizedlist>
<listitem><para><computeroutput>t4n20.v</computeroutput>: This file contains the <formula id="34">$(x, y)$</formula>-coordinates of the 20 vertices.</para></listitem><listitem><para><computeroutput>t4n20.plt</computeroutput>: This is the script to be loaded by <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink>. It will read <computeroutput>t4n20.v</computeroutput> to plot the vertices. It will also plot all the edges, which are included in this script itself.</para></listitem></itemizedlist>
</para><para><ref refid="index_1fig__f-t4" kindref="member">fig__f-t4</ref> shows the Theta graph plotted when the above <computeroutput>t4n20.plt</computeroutput> is loaded by <ulink url="http://www.gnuplot.info"><computeroutput>Gnuplot</computeroutput></ulink>.</para><para><anchor id="index_1fig__f-t4"/><image type="html" name="t4n20.jpg"></image>
 <image type="latex" name="t4n20.jpg" width="15cm"></image>
  <ref refid="index_1fig__f-t4" kindref="member">fig__f-t4</ref> A directed Theta graph of 20 vertices with <formula id="36">$k=4$</formula>.  <linebreak/>
</para></sect2>
<sect2 id="index_1CBS_half">
<title>Constructing Half Theta or Yao Graphs</title>
<para>By default, the functors <computeroutput><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">Construct_theta_graph_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Construct__yao__graph__2" kindref="compound">Construct_yao_graph_2</ref></computeroutput> construct full Theta and Yao graphs. They also provide a way to compute Half Theta and Yao graphs. As mentioned in Section <ref refid="index_1sec_CBS_mydefinitions" kindref="member">Definitions</ref>, only the edges for the odd or even cones are added to the graph in an Half Theta and Yao graph. To do so, the constructor of the functors provides a parameter of type <computeroutput>Cones_selected</computeroutput> which is a enumeration that contains the following possible values: <computeroutput>ALL_CONES</computeroutput>, <computeroutput>EVEN_CONES</computeroutput> and <computeroutput>ODD_CONES</computeroutput>. Users should include the <computeroutput>CGAL/Cone_spanners_enum_2.h</computeroutput> header file to use these enum values. The following are the examples on the functor constructions for Half Theta and Yao Graphs.</para><para><programlisting><codeline><highlight class="comment">//<sp/>Construct<sp/>an<sp/>Half<sp/>Theta<sp/>graph<sp/>with<sp/>the<sp/>edges<sp/>only<sp/>in<sp/>the<sp/>even<sp/>cones.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">CGAL::Construct_theta_graph_2&lt;Kernel, Graph&gt;</ref><sp/>theta(k,<sp/>Direction_2(1,0),<sp/><ref refid="group__PkgConeBasedSpanners_1gga4ecf90e8006c4dee00a21e67bd716462adaa1313a3edaf237069a99cf1bd121fb" kindref="member">CGAL::EVEN_CONES</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>Half<sp/>Theta<sp/>graph<sp/>with<sp/>the<sp/>edges<sp/>only<sp/>in<sp/>the<sp/>odd<sp/>cones.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">CGAL::Construct_theta_graph_2&lt;Kernel, Graph&gt;</ref><sp/>theta(k,<sp/>Direction_2(1,0),<sp/><ref refid="group__PkgConeBasedSpanners_1gga4ecf90e8006c4dee00a21e67bd716462aca05aa91e12ae9e65e5865f93b25eefe" kindref="member">CGAL::ODD_CONES</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>Half<sp/>Yao<sp/>graph<sp/>with<sp/>the<sp/>edges<sp/>only<sp/>in<sp/>the<sp/>even<sp/>cones.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Construct__yao__graph__2" kindref="compound">CGAL::Construct_yao_graph_2&lt;Kernel, Graph&gt;</ref><sp/>yao(k,<sp/>Direction_2(1,0),<sp/><ref refid="group__PkgConeBasedSpanners_1gga4ecf90e8006c4dee00a21e67bd716462adaa1313a3edaf237069a99cf1bd121fb" kindref="member">CGAL::EVEN_CONES</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>Half<sp/>Yao<sp/>graph<sp/>with<sp/>the<sp/>edges<sp/>only<sp/>in<sp/>the<sp/>odd<sp/>cones.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Construct__yao__graph__2" kindref="compound">CGAL::Construct_yao_graph_2&lt;Kernel, Graph&gt;</ref><sp/>yao(k,<sp/>Direction_2(1,0),<sp/><ref refid="group__PkgConeBasedSpanners_1gga4ecf90e8006c4dee00a21e67bd716462aca05aa91e12ae9e65e5865f93b25eefe" kindref="member">CGAL::ODD_CONES</ref>);</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1CBS_diff_exact">
<title>Exact Construction Can Make a Difference</title>
<para>This subsection gives an example vertex set on which the exact construction provided in this package can produce the correct Theta graph while the inexact construction cannot.</para><para>This vertex set, given in the file <computeroutput>examples/data/n9.cin</computeroutput>, consists of 9 vertices with the following <formula id="34">$(x, y)$</formula>-coordinates: <programlisting><codeline><highlight class="normal">0.000000<sp/><sp/>0.000000</highlight></codeline>
<codeline><highlight class="normal">0.000000<sp/><sp/>1.000000</highlight></codeline>
<codeline><highlight class="normal">0.000000<sp/><sp/>2.000000</highlight></codeline>
<codeline><highlight class="normal">1.000000<sp/><sp/>0.000000</highlight></codeline>
<codeline><highlight class="normal">1.000000<sp/><sp/>1.000000</highlight></codeline>
<codeline><highlight class="normal">1.000000<sp/><sp/>2.000000</highlight></codeline>
<codeline><highlight class="normal">2.000000<sp/><sp/>0.000000</highlight></codeline>
<codeline><highlight class="normal">2.000000<sp/><sp/>1.000000</highlight></codeline>
<codeline><highlight class="normal">2.000000<sp/><sp/>2.000000</highlight></codeline>
</programlisting></para><para>If we construct the directed Theta graph on this vertex set with <formula id="36">$k=4$</formula> and its cone boundaries on the <formula id="4">$x$</formula> and <formula id="35">$y$</formula> axis, the exact construction will produce the Theta graph shown in <ref refid="index_1fig__f-t4n9exact" kindref="member">fig__f-t4n9exact</ref>. Based on our definition on Theta graph presented in the Section <ref refid="index_1sec_CBS_mydefinitions" kindref="member">Definitions</ref>, we can verify that the Theta graph in <ref refid="index_1fig__f-t4n9exact" kindref="member">fig__f-t4n9exact</ref> is correctly constructed.</para><para><anchor id="index_1fig__f-t4n9exact"/><image type="html" name="t4n9exact.jpg"></image>
 <image type="latex" name="t4n9exact.jpg" width="15cm"></image>
  <ref refid="index_1fig__f-t4n9exact" kindref="member">fig__f-t4n9exact</ref> The correct Theta graph produced by the exact construction.  <linebreak/>
</para><para>On the other hand, the inexact construction will produce the Theta graph depicted in <ref refid="index_1fig__f-t4n9inexact" kindref="member">fig__f-t4n9inexact</ref>. We can see that this Theta graph is not constructed correctly, since the inexact construction will make wrong decisions on whether those vertices on the cone boundaries belong to a certain cone.</para><para><anchor id="index_1fig__f-t4n9inexact"/><image type="html" name="t4n9inexact.jpg"></image>
 <image type="latex" name="t4n9inexact.jpg" width="15cm"></image>
  <ref refid="index_1fig__f-t4n9inexact" kindref="member">fig__f-t4n9inexact</ref> The incorrect Theta graph produced by the inexact construction.  <linebreak/>
</para><para>This example demonstrates that the exact construction capability provided by this package can be very valuable if it is a strict requirement that graphs be constructed correctly.</para></sect2>
<sect2 id="index_1CBS_using_BGL">
<title>Using BGL Algorithms</title>
<para>The following example, &apos;dijkstra_theta.cpp&apos;, shows how to call algorithms from BGL to do further processing after the graphs are constructed. Since the constructed Theta or Yao graphs are stored in the class <computeroutput>boost::adjacency_list</computeroutput>, it is convenient to apply BGL algorithms into the constructed graphs. Specifically, this example constructs a Theta graph first and then calculates the shortest paths on this graph by calling the Dijkstra&apos;s algorithm from BGL. It mainly consists of the following steps:</para><para><orderedlist>
<listitem><para>Define <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput> as the kernel type to construct the graph inexactly.</para></listitem><listitem><para>Define a structure named <computeroutput>Edge_property</computeroutput> for storing the Euclidean length of each edge, which is needed by the Dijkstra&apos;s algorithm.</para></listitem><listitem><para>Define the graph type to store the constructed graph, passing <computeroutput>Edge_property</computeroutput> as a template parameter to the graph type <computeroutput>boost::adjacency_list</computeroutput>.</para></listitem><listitem><para>Construct a <computeroutput><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">Construct_theta_graph_2</ref></computeroutput> object named <computeroutput>theta</computeroutput>.</para></listitem><listitem><para>Construct a graph object <computeroutput>g</computeroutput> to store the constructed graph.</para></listitem><listitem><para>Use <computeroutput>theta</computeroutput> to construct the Theta graph by passing the input vertices and <computeroutput>g</computeroutput> to it.</para></listitem><listitem><para>After <computeroutput>g</computeroutput> is constructed, calculate the Euclidean length of each edge in <computeroutput>g</computeroutput>.</para></listitem><listitem><para>Calculate the shortest distances from <computeroutput>v0</computeroutput> to other vertices by calling the function <computeroutput>dijkstra_shortest_paths()</computeroutput> from BGL.</para></listitem></orderedlist>
</para><para><linebreak/>
<bold>File</bold> <ref refid="Cone_spanners_2_2dijkstra_theta_8cpp-example" kindref="compound">Cone_spanners_2/dijkstra_theta.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iterator&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Construct_theta_graph_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/graph_traits.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/adjacency_list.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/property_map/property_map.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/dijkstra_shortest_paths.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>select<sp/>the<sp/>kernel<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Direction__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Direction_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Direction_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*<sp/>define<sp/>the<sp/>struct<sp/>for<sp/>edge<sp/>property<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Edge_property<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">/*<sp/>record<sp/>the<sp/>Euclidean<sp/>length<sp/>of<sp/>the<sp/>edge<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>euclidean_length;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>define<sp/>the<sp/>Graph<sp/>(e.g.,<sp/>to<sp/>be<sp/>undirected,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>and<sp/>to<sp/>use<sp/>Edge_property<sp/>as<sp/>the<sp/>edge<sp/>property,<sp/>etc.)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::adjacency_list&lt;boost::listS,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::vecS,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::undirectedS,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Edge_property&gt;<sp/><sp/>Graph;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>!=<sp/>3)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Usage:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>argv[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&lt;no.<sp/>of<sp/>cones&gt;<sp/>&lt;input<sp/>filename&gt;&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>atoi(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(k&lt;2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>number<sp/>of<sp/>cones<sp/>should<sp/>be<sp/>larger<sp/>than<sp/>1!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>open<sp/>the<sp/>file<sp/>containing<sp/>the<sp/>vertex<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>inf(argv[2]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!inf)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Cannot<sp/>open<sp/>file<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>argv[1]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>iterators<sp/>for<sp/>reading<sp/>the<sp/>vertex<sp/>list<sp/>file</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;<sp/>Point_2<sp/>&gt;<sp/>input_begin(<sp/>inf<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;<sp/>Point_2<sp/>&gt;<sp/>input_end;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>initialize<sp/>the<sp/>functor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>the<sp/>initial<sp/>direction<sp/>is<sp/>omitted,<sp/>the<sp/>x-axis<sp/>will<sp/>be<sp/>used</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Construct__theta__graph__2" kindref="compound">CGAL::Construct_theta_graph_2&lt;Kernel, Graph&gt;</ref><sp/>theta(k);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>adjacency_list<sp/>object</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Graph<sp/>g;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>construct<sp/>the<sp/>theta<sp/>graph<sp/>on<sp/>the<sp/>vertex<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>theta(input_begin,<sp/>input_end,<sp/>g);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>select<sp/>a<sp/>source<sp/>vertex<sp/>for<sp/>dijkstra&apos;s<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::graph_traits&lt;Graph&gt;::vertex_descriptor<sp/>v0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v0<sp/>=<sp/>vertex(0,<sp/>g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>source<sp/>vertex<sp/>is:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>g[v0]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>index<sp/>of<sp/>source<sp/>vertex<sp/>is:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>v0<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>calculating<sp/>edge<sp/>length<sp/>in<sp/>Euclidean<sp/>distance<sp/>and<sp/>store<sp/>them<sp/>in<sp/>the<sp/>edge<sp/>property</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::graph_traits&lt;Graph&gt;::edge_iterator<sp/>ei,<sp/>ei_end;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(boost::tie(ei,<sp/>ei_end)<sp/>=<sp/>edges(g);<sp/>ei<sp/>!=<sp/>ei_end;<sp/>++ei)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::graph_traits&lt;Graph&gt;::edge_descriptor<sp/>e<sp/>=<sp/>*ei;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::graph_traits&lt;Graph&gt;::vertex_descriptor<sp/><sp/>u<sp/>=<sp/>source(e,<sp/>g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::graph_traits&lt;Graph&gt;::vertex_descriptor<sp/><sp/>v<sp/>=<sp/>target(e,<sp/>g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_2&amp;<sp/>pu<sp/>=<sp/>g[u];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_2&amp;<sp/>pv<sp/>=<sp/>g[v];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dist<sp/>=<sp/><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::sqrt</ref>(<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(<ref refid="group__squared__distance__grp_1ga1ff73525660a052564d33fbdd61a4f71" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::squared_distance</ref>(pu,pv))<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>g[e].euclidean_length<sp/>=<sp/>dist;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Edge<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>g[u]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>g[v]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dist<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>calculating<sp/>the<sp/>distances<sp/>from<sp/>v0<sp/>to<sp/>other<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::graph_traits&lt;Graph&gt;::vertices_size_type<sp/>n<sp/>=<sp/>num_vertices(g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>vector<sp/>for<sp/>storing<sp/>the<sp/>results</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;double&gt;<sp/>distances(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Calling<sp/>the<sp/>Dijkstra&apos;s<sp/>algorithm<sp/>implementation<sp/>from<sp/>boost.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::dijkstra_shortest_paths(g,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::weight_map(</highlight><highlight class="keyword">get</highlight><highlight class="normal">(&amp;Edge_property::euclidean_length,<sp/>g)).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>distance_map(CGAL::make_property_map(distances))<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;distances<sp/>are:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;distances[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>distances[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>(x,y)=&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>g[vertex(i,<sp/>g)];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>at<sp/>Vertex<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
