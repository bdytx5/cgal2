<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Cone_spanners_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Cone-Based Spanners: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Cone-Based Spanners
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_ConeBasedSpanners"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Weisheng Si, Quincy Tse and Frédérik Paradis</dd></dl>
<h1><a class="anchor" id="sec_CBS_Introduction"></a>
Introduction</h1>
<p>This chapter describes the package for constructing two kinds of cone-based spanners: <em>Yao graph</em> and <em>Theta graph</em>, given a set of vertices on the plane and the directions of cone boundaries. Both exact and inexact constructions are supported. In exact construction, the cone boundaries are calculated using roots of polynomials, which achieves the exactness by avoiding using \( \pi \) in the computation. In inexact construction, the cone boundaries are calculated with a floating point approximation of \( \pi \) value and is still accurate enough for most applications. Moreover, for visualization purpose, this chapter describes a global function that, given a constructed graph as input, can generate the data and script files for <a href="http://www.gnuplot.info"><code>Gnuplot</code></a> to plot that graph.</p>
<h1><a class="anchor" id="sec_CBS_mydefinitions"></a>
Definitions</h1>
<p>This section gives detailed definitions of Yao graph and Theta graph, which are followed in our implementation. In particular, because this package supports constructing Yao graph and Theta graph exactly, we need to be clear on which cone a cone boundary belongs to. The definitions presented here clarify on this.</p>
<p>Given a set \(V\) of vertices on the plane, the directed Yao Graph with an integer parameter \(k (k &gt; 1)\) on \(V\) is obtained as follows. For each vertex \(u \in V\), starting from a given direction (e.g., the direction of positive \(x\)-axis), draw \(k\) equally-spaced rays \(l_0\), \(l_1\), ..., \(l_{k-1}\) originating from \(u\) in counterclockwise order (see <a class="el" href="index.html#fig__f-y5">Figure 93.1</a> (a)). These rays divide the plane into \(k\) cones of angle \(2\pi/k\), denoted by \( c(u, 0), c(u, 1), ..., c(u, k-1)\) respectively in counterclockwise order. To avoid overlapping at boundaries, it is stipulated here that the area of \( c(u, i)\), where \( i=0, \ldots, k-1\), includes the ray \(l_{i}\) but excludes the ray \(l_{(i+1)\% k}\). In each cone of \(u\), draw a directed edge from \(u\) to its closest vertex by Euclidean distance in that cone. Ties are broken arbitrarily. These directed edges will form the edge set of the directed Yao graph on \(V\). The undirected Yao Graph on \(V\) is obtained by ignoring the directions of the edges. Note that if both edge \(uv\) and \(vu\) are in the directed Yao graph, only one edge \(uv\) exists in the undirected Yao graph. <a class="el" href="index.html#fig__f-y5">Figure 93.1</a> (b) gives an example of Yao graph with \(k=5\).</p>
<p><a class="anchor" id="fig__f-y5"></a></p><div class="image">
<img src="Example-Y5.jpg" alt="Example-Y5.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__f-y5">Figure 93.1</a> Cones and an example of Yao Graph with \(k=5\).  </div>  <br />

<p>Similar to Yao graph, the directed or undirected Theta Graph is also obtained by letting each vertex \(u \in V\) select a <em>closest</em> vertex in each of its cones to have an edge. The only difference is that <em>closest</em> in Theta Graph means the smallest projection distance onto the bisector of that cone, not the direct Euclidean distance. For instance, in <a class="el" href="index.html#fig__f-theta">Figure 93.2</a>, vertex \(u\)'s <em>closest</em> vertex will be vertex \(b\).</p>
<p><a class="anchor" id="fig__f-theta"></a></p><div class="image">
<img src="BisectorInThetaGraph.jpg" alt="BisectorInThetaGraph.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__f-theta">Figure 93.2</a> The bisector in a cone of a Theta Graph.  </div>  <br />

<p>Variants of Yao graph and Theta graph are Half Yao graph and Half Theta graph. The difference is that only the edges in the even or odd cones are drawn. For instance, in the even case of the Theta graph with \(k=6\), only the edges in the cones \(c(u, 0)\), \(c(u, 2)\), and \(c(u, 4)\) are drawn.</p>
<h1><a class="anchor" id="sec_CBS_design"></a>
Software Design</h1>
<p>This package provides the following template functors:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Compute__cone__boundaries__2.html" title="The functor for computing the directions of cone boundaries with a given cone number and a given init...">Compute_cone_boundaries_2</a></code>: The functor for computing the directions of cone boundaries given a cone number and an initial direction.</li>
<li><code><a class="el" href="classCGAL_1_1Construct__theta__graph__2.html" title="A template functor for constructing Theta graphs with a given set of 2D points and a given initial di...">Construct_theta_graph_2</a></code>: The functor for constructing Theta graphs given a set of vertices on the plane.</li>
<li><code><a class="el" href="classCGAL_1_1Construct__yao__graph__2.html" title="A template functor for constructing Yao graphs with a given set of 2D points and a given initial dire...">Construct_yao_graph_2</a></code>: The functor for constructing Yao graphs given a set of vertices on the plane.</li>
</ul>
<p>In addition to these functors, for visualizing the constructed graphs, this package provides a global function called <code><a class="el" href="group__PkgConeBasedSpanners.html#ga54c3d6e9cf8a8f9c6330a32b496a03ce" title="Output a set of files used by Gnuplot to plot g. ">CGAL::gnuplot_output_2()</a></code> to output a <code>boost::adjacency_list</code> data structure to <a href="http://www.gnuplot.info"><code>Gnuplot</code></a> data and script files. Below, we detail the design and the usage of the above functors and function.</p>
<h2><a class="anchor" id="subsec_CBS_cone"></a>
Computing Cone Boundaries</h2>
<p>The functor <code><a class="el" href="classCGAL_1_1Compute__cone__boundaries__2.html" title="The functor for computing the directions of cone boundaries with a given cone number and a given init...">Compute_cone_boundaries_2</a></code> has the following definition.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Traits&gt;</div><div class="line"><span class="keyword">class </span>Compute_cone_boundaries_2;</div></div><!-- fragment --><p>The template parameter <code>Traits</code> determines whether the cone boundaries are computed exactly or inexactly. If this parameter is <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__root__of.html">Exact_predicates_exact_constructions_kernel_with_root_of</a></code>, the computation will be done exactly; if this parameter is <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">Exact_predicates_inexact_constructions_kernel</a></code>, the computation will be done inexactly. The exact computation is implemented based on the fact that when the cone angle \( \theta \) is in the form of \( 2\pi / n \), where \( n \) is a positive integer, \( \sin(\theta) \) and \( \cos(\theta) \) can be represented exactly by roots of polynomials, thus avoiding using \( \pi \) in the computation. The exact computation requires the number type of either <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCORE_1_1Expr.html">CORE::Expr</a></code> or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__real.html">leda_real</a></code>. In inexact computation, the cone angle \( \theta \) is simply calculated as \( 2\pi/k \), where \( k \) is the number of cones and \( \pi \) takes the value of the constant <code>CGAL_PI=3.14159265358979323846</code>. Then, the \( \sin(\theta) \) and \( \cos(\theta) \) are calculated. While the inexact computation is done by the general functor definition, the exact computation is done by a specialization of this functor.</p>
<p>This functor is currently used by the functors <code><a class="el" href="classCGAL_1_1Construct__theta__graph__2.html" title="A template functor for constructing Theta graphs with a given set of 2D points and a given initial di...">Construct_theta_graph_2</a></code> and <code><a class="el" href="classCGAL_1_1Construct__yao__graph__2.html" title="A template functor for constructing Yao graphs with a given set of 2D points and a given initial dire...">Construct_yao_graph_2</a></code> in constructing Theta and Yao graphs. This functor can also be used in other applications where the plane needs to be divided into equally-angled cones. For how to use this functor to compute cone boundaries in writing an application, please refer to Section <a class="el" href="index.html#sec_CBS_examples">Examples</a>.</p>
<h2><a class="anchor" id="subsec_CBS_theta"></a>
Constructing a Theta Graph</h2>
<p>The functor <code><a class="el" href="classCGAL_1_1Construct__theta__graph__2.html" title="A template functor for constructing Theta graphs with a given set of 2D points and a given initial di...">Construct_theta_graph_2</a></code> has the following definition</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Traits, <span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class </span>Construct_theta_graph_2;</div></div><!-- fragment --><p>Similar to the functor <code><a class="el" href="classCGAL_1_1Compute__cone__boundaries__2.html" title="The functor for computing the directions of cone boundaries with a given cone number and a given init...">Compute_cone_boundaries_2</a></code>, the template parameter <code>Traits</code> determines whether the Theta graph will constructed exactly or inexactly. The template parameter <code>Graph</code> specifies the graph type used to store the constructed graph. Our package requires it to be <a href="https://www.boost.org/libs/graph/doc/adjacency_list.html">boost::adjacency_list</a> from the Boost Graph Library (BGL). The advantage of using <code>boost::adjacency_list</code> is that it provides convenience to the further processing of the constructed graphs, since BGL includes most common graph algorithms. Note that BGL altogether provides two template classes for representing graphs: <code>boost::adjacency_list</code> and <code>boost::adjacency_matrix</code>, with the former suitable for sparse graphs and the latter suitable for dense graphs. While cone-based spanners are sparse graphs and the interfaces provided by <code>boost::adjacency_list</code> and <code>boost::adjacency_matrix</code> are different, our package only supports <code>boost::adjacency_list</code>.</p>
<p>Note that there are seven template parameters for <code>boost::adjacency_list</code> in BGL: <code>OutEdgeList</code>, <code>VertexList</code>, <code>Directed</code>, <code>VertexProperties</code>, <code>EdgeProperties</code>, <code>GraphProperties</code>, <code>EdgeList</code>, of which we require <code>VertexProperties</code> to be <code>Traits::Point_2</code>, and other parameters can be chosen freely. Also note that, here we pass <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> directly as <a href="https://www.boost.org/doc/libs/release/libs/graph/doc/bundles.html"><em>bundled properties</em></a> to <code>boost::adjacency_list</code>, because this makes our implementation more straightforward than using a property map. If you want more properties other than <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> for vertices, you can still construct external properties by using property maps.</p>
<p>In constructing Theta graphs, this functor uses the algorithm from Chapter 4 of the book by Narasimhan and Smid <a class="el" href="citelist.html#CITEREF_cgal:ns-gsn-07">[2]</a>. Basically, it is a sweep line algorithm and uses a balanced search tree to store the vertices that have already been scanned. It has the complexity of \(O(n \log n)\), where \(n\) is the number of vertices in the plane. This complexity has been proved to be optimal.</p>
<p>For more details on how to use this <code><a class="el" href="classCGAL_1_1Construct__theta__graph__2.html" title="A template functor for constructing Theta graphs with a given set of 2D points and a given initial di...">Construct_theta_graph_2</a></code> functor to write an application to build Theta graphs, please refer to Section <a class="el" href="index.html#sec_CBS_examples">Examples</a>.</p>
<h2><a class="anchor" id="subsec_CBS_yao"></a>
Constructing a Yao Graph</h2>
<p>The functor <code><a class="el" href="classCGAL_1_1Construct__yao__graph__2.html" title="A template functor for constructing Yao graphs with a given set of 2D points and a given initial dire...">Construct_yao_graph_2</a></code> has a similar definition as <code><a class="el" href="classCGAL_1_1Construct__theta__graph__2.html" title="A template functor for constructing Theta graphs with a given set of 2D points and a given initial di...">Construct_theta_graph_2</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Traits, <span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class </span>Construct_yao_graph_2;</div></div><!-- fragment --><p>The way of using these two template parameters is the same as that of <code><a class="el" href="classCGAL_1_1Construct__theta__graph__2.html" title="A template functor for constructing Theta graphs with a given set of 2D points and a given initial di...">Construct_theta_graph_2</a></code>, so please refer to the previous subsection for the details. We note here that construction algorithm for Yao graph is a slight adaptation of the algorithm for constructing Theta graph, having a complexity of \(O(n^2)\). The increase of complexity in this adaptation is because in constructing Theta graph, the searching of the 'closest' node by projection distance can be done by a balanced search tree, but in constructing Yao graph, the searching of the 'closest' node by Euclidean distance cannot be done by a balanced search tree.</p>
<p>Note that an optimal algorithm for constructing Yao graph with a complexity of \(O(n \log n)\) is described in <a class="el" href="citelist.html#CITEREF_cgal:cht-oacov-90">[1]</a>. However, this algorithm is much more complex to implement than the current algorithm implemented, and it can hardly reuse the codes for constructing Theta graphs, so it is not implemented in this package right now.</p>
<h2><a class="anchor" id="subsec_CBS_gnuplot"></a>
Gnuplot Output</h2>
<p>This package also implements a template function <code><a class="el" href="group__PkgConeBasedSpanners.html#ga54c3d6e9cf8a8f9c6330a32b496a03ce" title="Output a set of files used by Gnuplot to plot g. ">CGAL::gnuplot_output_2()</a></code>, which reads a <code>boost::adjacency_list</code> object and generate two files used by <a href="http://www.gnuplot.info"><code>Gnuplot</code></a> to visualize the graph stored in the <code>boost::adjacency_list</code> object. This template function has the following definition:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph_&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgConeBasedSpanners.html#ga54c3d6e9cf8a8f9c6330a32b496a03ce">gnuplot_output_2</a>(<span class="keyword">const</span> Graph_&amp; g, <span class="keyword">const</span> std::string&amp; prefix);</div></div><!-- fragment --><p>The template parameter <code>Graph_</code> specifies the type of the graph to be plotted. For this function to work, the graph type must be <code>boost::adjacency_list</code> with <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> as the <code>VertexProperties</code>. As for the two arguments to the function, <code>g</code> gives the graph to be plotted, and <code>prefix</code> gives the prefix for the names of the files generated by the function. Specifically, this function will generate the following two files:</p><ul>
<li>A data file named <code>prefix.v</code> that contains the \((x, y)\)-coordinates of each vertex. To be read by <a href="http://www.gnuplot.info"><code>Gnuplot</code></a>, the \((x, y)\)-coordinates are written into the data file with decimal format, no matter which number type is used in the <span style="font-variant: small-caps;">CGAL</span> kernel. This is achieved by calling <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#ga1f1bcd74fce34fd532445590bbda5cd5">to_double()</a></code> on \(x\) or \(y\) coordinate before outputting them.</li>
<li>A <a href="http://www.gnuplot.info"><code>Gnuplot</code></a> script file named <code>prefix.plt</code> to be loaded by <a href="http://www.gnuplot.info"><code>Gnuplot</code></a> to plot the set of vertices and the set of edges. The set of vertices is read from the above data file and the set of edges are included in the script file with the syntax <code>set arrow from x1, y1 to x2, y2</code>.</li>
</ul>
<p>For details on how to use this function to generate <a href="http://www.gnuplot.info"><code>Gnuplot</code></a> files, please refer to Section <a class="el" href="index.html#sec_CBS_examples">Examples</a>.</p>
<h1><a class="anchor" id="sec_CBS_examples"></a>
Examples</h1>
<h2><a class="anchor" id="CBS_coneboundaries"></a>
Computing Cone Boundaries Exactly or Inexactly</h2>
<p>The following example shows how to compute the directions of the cone boundaries exactly given the cone number and the initial direction. This example basically consists of the following steps:</p>
<ol type="1">
<li>Define <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__root__of.html">Exact_predicates_exact_constructions_kernel_with_root_of</a></code> as the kernel type to compute the cone boundaries exactly.</li>
<li>Construct a <code><a class="el" href="classCGAL_1_1Compute__cone__boundaries__2.html" title="The functor for computing the directions of cone boundaries with a given cone number and a given init...">Compute_cone_boundaries_2</a></code> object named <code>cones</code> with the above kernel as the template parameter. Note that since the functor <code><a class="el" href="classCGAL_1_1Compute__cone__boundaries__2.html" title="The functor for computing the directions of cone boundaries with a given cone number and a given init...">Compute_cone_boundaries_2</a></code> has no member variables but member types and functions, its constructor needs no arguments.</li>
<li>Initialize a vector of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Direction__2.html">Direction_2</a></code> named <code>rays</code> to store the computed results.</li>
<li>Use <code>cones</code> to compute the cone boundaries by passing the cone number, the initial direction and the beginning iterator of <code>rays</code> to it.</li>
<li>Output the computed results.</li>
</ol>
<p><br />
<b>File</b> <a class="el" href="Cone_spanners_2_2compute_cones_8cpp-example.html">Cone_spanners_2/compute_cones.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel_with_root_of.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Compute_cone_boundaries_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// select the kernel type</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__root__of.html">CGAL::Exact_predicates_exact_constructions_kernel_with_root_of</a>   <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                   Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Direction__2.html">Kernel::Direction_2</a>               Direction_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &lt; 2) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" &lt;no. of cones&gt; [&lt;direction-x&gt; &lt;direction-y&gt;]"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = atoi(argv[1]);</div><div class="line">  <span class="keywordflow">if</span> (k&lt;2) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The number of cones should be larger than 1!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  Direction_2 initial_direction;</div><div class="line">  <span class="keywordflow">if</span> (argc == 2)</div><div class="line">    initial_direction = Direction_2(1, 0);  <span class="comment">// default initial_direction</span></div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argc == 4)</div><div class="line">    initial_direction = Direction_2(atof(argv[2]), atof(argv[3]));</div><div class="line">  <span class="keywordflow">else</span> {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" &lt;no. of cones&gt; [&lt;direction-x&gt; &lt;direction-y&gt;]"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// construct the functor</span></div><div class="line">  <a class="code" href="classCGAL_1_1Compute__cone__boundaries__2.html">CGAL::Compute_cone_boundaries_2&lt;Kernel&gt;</a> cones;</div><div class="line">  <span class="comment">// create the vector rays to store the results</span></div><div class="line">  std::vector&lt;Direction_2&gt; rays(k);</div><div class="line">  <span class="comment">// compute the cone boundaries and store them in rays</span></div><div class="line">  cones(k, initial_direction, rays.begin());</div><div class="line"></div><div class="line">  <span class="comment">// display the computed rays, starting from the initial direction, ccw order</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;k; i++)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Ray "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; rays[i] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Note that, in this example, for any k&lt;=28, the computation can be done successfully; for any k&gt;28, the computation cannot be completed because <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCORE_1_1Expr.html">CORE::Expr</a></code>, which we use as the number type for the exact kernel, exceeds its limit. It seems that k&lt;=28 will suffice for most applications. Also, if inexact computation is used, the computation will be successful for any k&gt;1, and much quicker than exact computation. We also note here that we don't experiment with <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__real.html">leda_real</a></code>.</p>
<p>As a final note, to compute the cone boundaries inexactly, just define the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> to be <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">Exact_predicates_inexact_constructions_kernel</a></code> in the above example.</p>
<h2><a class="anchor" id="CBS_construction"></a>
Constructing Graphs Exactly or Inexactly and Generating Gnuplot Files</h2>
<p>The following example shows how to construct Theta graphs exactly and generate <a href="http://www.gnuplot.info"><code>Gnuplot</code></a> files. This example basically consists of the following steps:</p><ol type="1">
<li>Define <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__root__of.html">Exact_predicates_exact_constructions_kernel_with_root_of</a></code> as the kernel type to construct the graph exactly.</li>
<li>Define the graph type to store the constructed graph.</li>
<li>Construct a <code><a class="el" href="classCGAL_1_1Construct__theta__graph__2.html" title="A template functor for constructing Theta graphs with a given set of 2D points and a given initial di...">Construct_theta_graph_2</a></code> object named <code>theta</code> with the number of cones and the initial direction as constructor arguments.</li>
<li>Construct a graph object <code>g</code> to store the constructed graph.</li>
<li>Use <code>theta</code> to construct the Theta graph by passing the input vertices and <code>g</code> to it.</li>
<li>Generate <a href="http://www.gnuplot.info"><code>Gnuplot</code></a> files for plotting the construct graph.</li>
</ol>
<p><br />
<b>File</b> <a class="el" href="Cone_spanners_2_2theta_io_8cpp-example.html">Cone_spanners_2/theta_io.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel_with_root_of.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Construct_theta_graph_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/gnuplot_output_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// select the kernel type</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__root__of.html">CGAL::Exact_predicates_exact_constructions_kernel_with_root_of</a>   <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                   Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Direction__2.html">Kernel::Direction_2</a>               Direction_2;</div><div class="line"><span class="comment">/* Note: due to a bug in the boost library, using a directed graph</span></div><div class="line"><span class="comment"> * will cause a compilation error with g++ and clang++ when using c++11 standard.</span></div><div class="line"><span class="comment"> * See http://lists.boost.org/Archives/boost/2016/05/229458.php.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">// define the graph type</span></div><div class="line"><span class="keyword">typedef</span> boost::adjacency_list&lt;boost::listS,</div><div class="line">                              boost::vecS,</div><div class="line"><span class="preprocessor">                              #ifdef CGAL_CXX11</span></div><div class="line">                              boost::undirectedS,</div><div class="line"><span class="preprocessor">                              #else</span></div><div class="line">                              boost::directedS,</div><div class="line"><span class="preprocessor">                              #endif</span></div><div class="line">                              Point_2</div><div class="line">                             &gt; Graph;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (argc &lt; 3) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" &lt;no. of cones&gt; &lt;input filename&gt; [&lt;direction-x&gt; &lt;direction-y&gt;]"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = atoi(argv[1]);</div><div class="line">  <span class="keywordflow">if</span> (k&lt;2) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The number of cones should be larger than 1!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// open the file containing the vertex list</span></div><div class="line">  std::ifstream inf(argv[2]);</div><div class="line">  <span class="keywordflow">if</span> (!inf) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Cannot open file "</span> &lt;&lt; argv[2] &lt;&lt; <span class="stringliteral">"!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  Direction_2 initial_direction;</div><div class="line">  <span class="keywordflow">if</span> (argc == 3)</div><div class="line">    initial_direction = Direction_2(1, 0);  <span class="comment">// default initial_direction</span></div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argc == 5)</div><div class="line">    initial_direction = Direction_2(atof(argv[3]), atof(argv[4]));</div><div class="line">  <span class="keywordflow">else</span> {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" &lt;no. of cones&gt; &lt;input filename&gt; [&lt;direction-x&gt; &lt;direction-y&gt;]"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// iterators for reading the vertex list file</span></div><div class="line">  std::istream_iterator&lt;Point_2&gt; input_begin( inf );</div><div class="line">  std::istream_iterator&lt;Point_2&gt; input_end;</div><div class="line"></div><div class="line">  <span class="comment">// initialize the functor</span></div><div class="line">  <a class="code" href="classCGAL_1_1Construct__theta__graph__2.html">CGAL::Construct_theta_graph_2&lt;Kernel, Graph&gt;</a> theta(k, initial_direction);</div><div class="line">  <span class="comment">// create an adjacency_list object</span></div><div class="line">  Graph g;</div><div class="line">  <span class="comment">// construct the theta graph on the vertex list</span></div><div class="line">  theta(input_begin, input_end, g);</div><div class="line"></div><div class="line">  <span class="comment">// obtain the number of vertices in the constructed graph</span></div><div class="line">  boost::graph_traits&lt;Graph&gt;::vertices_size_type n = boost::num_vertices(g);</div><div class="line">  <span class="comment">// generate gnuplot files for plotting this graph</span></div><div class="line">  std::string file_prefix = <span class="stringliteral">"t"</span> + boost::lexical_cast&lt;std::string&gt;(k) + <span class="stringliteral">"n"</span> + boost::lexical_cast&lt;std::string&gt;(n);</div><div class="line">  <a class="code" href="group__PkgConeBasedSpanners.html#ga54c3d6e9cf8a8f9c6330a32b496a03ce">CGAL::gnuplot_output_2</a>(g, file_prefix);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>To construct Theta graphs inexactly, just define the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> to be <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">Exact_predicates_inexact_constructions_kernel</a></code> in the above example. And the way of constructing Yao graphs exactly or inexactly is the same as that of constructing Theta graphs, just replacing the functor <code><a class="el" href="classCGAL_1_1Construct__theta__graph__2.html" title="A template functor for constructing Theta graphs with a given set of 2D points and a given initial di...">Construct_theta_graph_2</a></code> by the functor <code><a class="el" href="classCGAL_1_1Construct__yao__graph__2.html" title="A template functor for constructing Yao graphs with a given set of 2D points and a given initial dire...">Construct_yao_graph_2</a></code>.</p>
<p>Note that, for Theta graph, the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> defined must support the <code>CGAL::sqrt()</code> operation. This is required by the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__bisector__grp.html#ga2ba217aec13a36b8171d110feda3a058">bisector()</a></code> function, which is used to calculate the angle bisector of a cone. For instance, the compiler will complain if <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">Exact_predicates_exact_constructions_kernel</a></code> (not supporting <code>CGAL::sqrt()</code>) is defined as the kernel, but <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">Exact_predicates_inexact_constructions_kernel</a></code> will be fine since it supports <code>CAL::sqrt()</code>. For Yao graph, there is no such restriction, since its construction does not need <code>CGAL::sqrt()</code>.</p>
<p>Also note that when using g++ or clang++ compilers with the c++11 standard, using a directed graph will cause a compilation error due to a <a href="http://lists.boost.org/Archives/boost/2016/05/229458.php">bug</a> in the boost library. As a workaround you can use a undirected graph instead.</p>
<p>After compiling <code>theta_io.cpp</code>, execute the executable <code>theta_io</code> to construct a Theta graph with 4 cones on a set of 20 vertices (which is given in the file <code>data/n20.cin</code>):</p>
<div class="fragment"><div class="line">$ ./theta_io  4  data/n20.cin</div></div><!-- fragment --><p>The following two files will be generated for <a href="http://www.gnuplot.info"><code>Gnuplot</code></a>:</p><ul>
<li><code>t4n20.v</code>: This file contains the \((x, y)\)-coordinates of the 20 vertices.</li>
<li><code>t4n20.plt</code>: This is the script to be loaded by <a href="http://www.gnuplot.info"><code>Gnuplot</code></a>. It will read <code>t4n20.v</code> to plot the vertices. It will also plot all the edges, which are included in this script itself.</li>
</ul>
<p><a class="el" href="index.html#fig__f-t4">Figure 93.3</a> shows the Theta graph plotted when the above <code>t4n20.plt</code> is loaded by <a href="http://www.gnuplot.info"><code>Gnuplot</code></a>.</p>
<p><a class="anchor" id="fig__f-t4"></a></p><div class="image">
<img src="t4n20.jpg" alt="t4n20.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__f-t4">Figure 93.3</a> A directed Theta graph of 20 vertices with \(k=4\).  </div>  <br />

<h2><a class="anchor" id="CBS_half"></a>
Constructing Half Theta or Yao Graphs</h2>
<p>By default, the functors <code><a class="el" href="classCGAL_1_1Construct__theta__graph__2.html" title="A template functor for constructing Theta graphs with a given set of 2D points and a given initial di...">Construct_theta_graph_2</a></code> and <code><a class="el" href="classCGAL_1_1Construct__yao__graph__2.html" title="A template functor for constructing Yao graphs with a given set of 2D points and a given initial dire...">Construct_yao_graph_2</a></code> construct full Theta and Yao graphs. They also provide a way to compute Half Theta and Yao graphs. As mentioned in Section <a class="el" href="index.html#sec_CBS_mydefinitions">Definitions</a>, only the edges for the odd or even cones are added to the graph in an Half Theta and Yao graph. To do so, the constructor of the functors provides a parameter of type <code>Cones_selected</code> which is a enumeration that contains the following possible values: <code>ALL_CONES</code>, <code>EVEN_CONES</code> and <code>ODD_CONES</code>. Users should include the <code>CGAL/Cone_spanners_enum_2.h</code> header file to use these enum values. The following are the examples on the functor constructions for Half Theta and Yao Graphs.</p>
<div class="fragment"><div class="line"><span class="comment">// Construct an Half Theta graph with the edges only in the even cones.</span></div><div class="line"><a class="code" href="classCGAL_1_1Construct__theta__graph__2.html">CGAL::Construct_theta_graph_2&lt;Kernel, Graph&gt;</a> theta(k, Direction_2(1,0), <a class="code" href="group__PkgConeBasedSpanners.html#gga4ecf90e8006c4dee00a21e67bd716462adaa1313a3edaf237069a99cf1bd121fb">CGAL::EVEN_CONES</a>);</div><div class="line"></div><div class="line"><span class="comment">// Construct an Half Theta graph with the edges only in the odd cones.</span></div><div class="line"><a class="code" href="classCGAL_1_1Construct__theta__graph__2.html">CGAL::Construct_theta_graph_2&lt;Kernel, Graph&gt;</a> theta(k, Direction_2(1,0), <a class="code" href="group__PkgConeBasedSpanners.html#gga4ecf90e8006c4dee00a21e67bd716462aca05aa91e12ae9e65e5865f93b25eefe">CGAL::ODD_CONES</a>);</div><div class="line"></div><div class="line"><span class="comment">// Construct an Half Yao graph with the edges only in the even cones.</span></div><div class="line"><a class="code" href="classCGAL_1_1Construct__yao__graph__2.html">CGAL::Construct_yao_graph_2&lt;Kernel, Graph&gt;</a> yao(k, Direction_2(1,0), <a class="code" href="group__PkgConeBasedSpanners.html#gga4ecf90e8006c4dee00a21e67bd716462adaa1313a3edaf237069a99cf1bd121fb">CGAL::EVEN_CONES</a>);</div><div class="line"></div><div class="line"><span class="comment">// Construct an Half Yao graph with the edges only in the odd cones.</span></div><div class="line"><a class="code" href="classCGAL_1_1Construct__yao__graph__2.html">CGAL::Construct_yao_graph_2&lt;Kernel, Graph&gt;</a> yao(k, Direction_2(1,0), <a class="code" href="group__PkgConeBasedSpanners.html#gga4ecf90e8006c4dee00a21e67bd716462aca05aa91e12ae9e65e5865f93b25eefe">CGAL::ODD_CONES</a>);</div></div><!-- fragment --><h2><a class="anchor" id="CBS_diff_exact"></a>
Exact Construction Can Make a Difference</h2>
<p>This subsection gives an example vertex set on which the exact construction provided in this package can produce the correct Theta graph while the inexact construction cannot.</p>
<p>This vertex set, given in the file <code>examples/data/n9.cin</code>, consists of 9 vertices with the following \((x, y)\)-coordinates: </p><div class="fragment"><div class="line">0.000000  0.000000</div><div class="line">0.000000  1.000000</div><div class="line">0.000000  2.000000</div><div class="line">1.000000  0.000000</div><div class="line">1.000000  1.000000</div><div class="line">1.000000  2.000000</div><div class="line">2.000000  0.000000</div><div class="line">2.000000  1.000000</div><div class="line">2.000000  2.000000</div></div><!-- fragment --><p>If we construct the directed Theta graph on this vertex set with \(k=4\) and its cone boundaries on the \(x\) and \(y\) axis, the exact construction will produce the Theta graph shown in <a class="el" href="index.html#fig__f-t4n9exact">Figure 93.4</a>. Based on our definition on Theta graph presented in the Section <a class="el" href="index.html#sec_CBS_mydefinitions">Definitions</a>, we can verify that the Theta graph in <a class="el" href="index.html#fig__f-t4n9exact">Figure 93.4</a> is correctly constructed.</p>
<p><a class="anchor" id="fig__f-t4n9exact"></a></p><div class="image">
<img src="t4n9exact.jpg" alt="t4n9exact.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__f-t4n9exact">Figure 93.4</a> The correct Theta graph produced by the exact construction.  </div>  <br />

<p>On the other hand, the inexact construction will produce the Theta graph depicted in <a class="el" href="index.html#fig__f-t4n9inexact">Figure 93.5</a>. We can see that this Theta graph is not constructed correctly, since the inexact construction will make wrong decisions on whether those vertices on the cone boundaries belong to a certain cone.</p>
<p><a class="anchor" id="fig__f-t4n9inexact"></a></p><div class="image">
<img src="t4n9inexact.jpg" alt="t4n9inexact.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__f-t4n9inexact">Figure 93.5</a> The incorrect Theta graph produced by the inexact construction.  </div>  <br />

<p>This example demonstrates that the exact construction capability provided by this package can be very valuable if it is a strict requirement that graphs be constructed correctly.</p>
<h2><a class="anchor" id="CBS_using_BGL"></a>
Using BGL Algorithms</h2>
<p>The following example, 'dijkstra_theta.cpp', shows how to call algorithms from BGL to do further processing after the graphs are constructed. Since the constructed Theta or Yao graphs are stored in the class <code>boost::adjacency_list</code>, it is convenient to apply BGL algorithms into the constructed graphs. Specifically, this example constructs a Theta graph first and then calculates the shortest paths on this graph by calling the Dijkstra's algorithm from BGL. It mainly consists of the following steps:</p>
<ol type="1">
<li>Define <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">Exact_predicates_inexact_constructions_kernel</a></code> as the kernel type to construct the graph inexactly.</li>
<li>Define a structure named <code>Edge_property</code> for storing the Euclidean length of each edge, which is needed by the Dijkstra's algorithm.</li>
<li>Define the graph type to store the constructed graph, passing <code>Edge_property</code> as a template parameter to the graph type <code>boost::adjacency_list</code>.</li>
<li>Construct a <code><a class="el" href="classCGAL_1_1Construct__theta__graph__2.html" title="A template functor for constructing Theta graphs with a given set of 2D points and a given initial di...">Construct_theta_graph_2</a></code> object named <code>theta</code>.</li>
<li>Construct a graph object <code>g</code> to store the constructed graph.</li>
<li>Use <code>theta</code> to construct the Theta graph by passing the input vertices and <code>g</code> to it.</li>
<li>After <code>g</code> is constructed, calculate the Euclidean length of each edge in <code>g</code>.</li>
<li>Calculate the shortest distances from <code>v0</code> to other vertices by calling the function <code>dijkstra_shortest_paths()</code> from BGL.</li>
</ol>
<p><br />
<b>File</b> <a class="el" href="Cone_spanners_2_2dijkstra_theta_8cpp-example.html">Cone_spanners_2/dijkstra_theta.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Construct_theta_graph_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/graph_traits.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/property_map/property_map.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// select the kernel type</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                   Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Direction__2.html">Kernel::Direction_2</a>               Direction_2;</div><div class="line"></div><div class="line"><span class="comment">/* define the struct for edge property */</span></div><div class="line"><span class="keyword">struct </span>Edge_property {</div><div class="line">  <span class="comment">/* record the Euclidean length of the edge */</span></div><div class="line">  <span class="keywordtype">double</span> euclidean_length;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// define the Graph (e.g., to be undirected,</span></div><div class="line"><span class="comment">// and to use Edge_property as the edge property, etc.)</span></div><div class="line"><span class="keyword">typedef</span> boost::adjacency_list&lt;boost::listS,</div><div class="line">                              boost::vecS,</div><div class="line">                              boost::undirectedS,</div><div class="line">                              Point_2,</div><div class="line">                              Edge_property&gt;  Graph;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)</div><div class="line">{</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc != 3) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" &lt;no. of cones&gt; &lt;input filename&gt;"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = atoi(argv[1]);</div><div class="line">  <span class="keywordflow">if</span> (k&lt;2) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The number of cones should be larger than 1!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  <span class="comment">// open the file containing the vertex list</span></div><div class="line">  std::ifstream inf(argv[2]);</div><div class="line">  <span class="keywordflow">if</span> (!inf) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Cannot open file "</span> &lt;&lt; argv[1] &lt;&lt; <span class="stringliteral">"!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// iterators for reading the vertex list file</span></div><div class="line">  std::istream_iterator&lt; Point_2 &gt; input_begin( inf );</div><div class="line">  std::istream_iterator&lt; Point_2 &gt; input_end;</div><div class="line"></div><div class="line">  <span class="comment">// initialize the functor</span></div><div class="line">  <span class="comment">// If the initial direction is omitted, the x-axis will be used</span></div><div class="line">  <a class="code" href="classCGAL_1_1Construct__theta__graph__2.html">CGAL::Construct_theta_graph_2&lt;Kernel, Graph&gt;</a> theta(k);</div><div class="line">  <span class="comment">// create an adjacency_list object</span></div><div class="line">  Graph g;</div><div class="line">  <span class="comment">// construct the theta graph on the vertex list</span></div><div class="line">  theta(input_begin, input_end, g);</div><div class="line"></div><div class="line">  <span class="comment">// select a source vertex for dijkstra's algorithm</span></div><div class="line">  boost::graph_traits&lt;Graph&gt;::vertex_descriptor v0;</div><div class="line">  v0 = vertex(0, g);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The source vertex is: "</span> &lt;&lt; g[v0] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The index of source vertex is: "</span> &lt;&lt; v0 &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// calculating edge length in Euclidean distance and store them in the edge property</span></div><div class="line">  boost::graph_traits&lt;Graph&gt;::edge_iterator ei, ei_end;</div><div class="line">  <span class="keywordflow">for</span> (boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei) {</div><div class="line">    boost::graph_traits&lt;Graph&gt;::edge_descriptor e = *ei;</div><div class="line">    boost::graph_traits&lt;Graph&gt;::vertex_descriptor  u = source(e, g);</div><div class="line">    boost::graph_traits&lt;Graph&gt;::vertex_descriptor  v = target(e, g);</div><div class="line">    <span class="keyword">const</span> Point_2&amp; pu = g[u];</div><div class="line">    <span class="keyword">const</span> Point_2&amp; pv = g[v];</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> dist = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#gab922269072ee9ee99ba8c541418b2e11">CGAL::sqrt</a>( <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a>(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a>(pu,pv)) );</div><div class="line">    g[e].euclidean_length = dist;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Edge ("</span> &lt;&lt; g[u] &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; g[v] &lt;&lt; <span class="stringliteral">"): "</span> &lt;&lt; dist &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// calculating the distances from v0 to other vertices</span></div><div class="line">  boost::graph_traits&lt;Graph&gt;::vertices_size_type n = num_vertices(g);</div><div class="line">  <span class="comment">// vector for storing the results</span></div><div class="line">  std::vector&lt;double&gt; distances(n);</div><div class="line">  <span class="comment">// Calling the Dijkstra's algorithm implementation from boost.</span></div><div class="line">  boost::dijkstra_shortest_paths(g,</div><div class="line">                                 v0,</div><div class="line">                                 boost::weight_map(<span class="keyword">get</span>(&amp;Edge_property::euclidean_length, g)).</div><div class="line">                                 distance_map(CGAL::make_property_map(distances)) );</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"distances are:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; n; ++i) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"distances["</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">"] = "</span> &lt;&lt; distances[i] &lt;&lt; <span class="stringliteral">", (x,y)="</span> &lt;&lt; g[vertex(i, g)];</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" at Vertex "</span> &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:58 for CGAL 4.13 - Cone-Based Spanners by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
