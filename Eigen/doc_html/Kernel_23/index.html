<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Kernel_23/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D and 3D Linear Geometry Kernel: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D and 3D Linear Geometry Kernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_and_3D_Geometry_Kernel"></a><a class="anchor" id="chapterkernel23"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Hervé Brönnimann, Andreas Fabri, Geert-Jan Giezeman, Susan Hert, Michael Hoffmann, Lutz Kettner, Sylvain Pion, and Stefan Schirra</dd></dl>
<h1><a class="anchor" id="kernel_intro"></a>
Introduction</h1>
<p><span style="font-variant: small-caps;">CGAL</span>, the <em>Computational Geometry Algorithms Library</em>, is written in <span style="font-variant: small-caps;">C++</span> and consists of three major parts. The first part is the kernel, which consists of constant-size non-modifiable geometric primitive objects and operations on these objects. The objects are represented both as stand-alone classes that are parameterized by a representation class, which specifies the underlying number types used for calculations and as members of the kernel classes, which allows for more flexibility and adaptability of the kernel. The second part is a collection of basic geometric data structures and algorithms, which are parameterized by traits classes that define the interface between the data structure or algorithm and the primitives they use. In many cases, the kernel classes provided in <span style="font-variant: small-caps;">CGAL</span> can be used as traits classes for these data structures and algorithms. The third part of the library consists of non-geometric support facilities, such as circulators, random sources, I/O support for debugging and for interfacing <span style="font-variant: small-caps;">CGAL</span> to various visualization tools.</p>
<p>This part of the reference manual covers the kernel. The kernel contains objects of constant size, such as point, vector, direction, line, ray, segment, triangle, iso-oriented rectangle and tetrahedron. With each type comes a set of functions which can be applied to an object of this type. You will typically find access functions (e.g. to the coordinates of a point), tests of the position of a point relative to the object, a function returning the bounding box, the length, or the area of an object, and so on. The <span style="font-variant: small-caps;">CGAL</span> kernel further contains basic operations such as affine transformations, detection and computation of intersections, and distance computations.</p>
<h2><a class="anchor" id="Kernel_23Robustness"></a>
Robustness</h2>
<p>The correctness proof of nearly all geometric algorithms presented in theory papers assumes exact computation with real numbers. This leads to a fundamental problem with the implementation of geometric algorithms. Naively, often the exact real arithmetic is replaced by inexact floating-point arithmetic in the implementation. This often leads to acceptable results for many input data. However, even for the implementation of the simplest geometric algorithms this simplification occasionally does not work. Rounding errors introduced by an inaccurate arithmetic may lead to inconsistent decisions, causing unexpected failures for some correct input data. There are many approaches to this problem, one of them is to compute exactly (compute so accurate that all decisions made by the algorithm are exact) which is possible in many cases but more expensive than standard floating-point arithmetic. C. M. Hoffmann <a class="el" href="citelist.html#CITEREF_h-gsm-89">[3]</a>, <a class="el" href="citelist.html#CITEREF_h-pargc-89">[2]</a> illustrates some of the problems arising in the implementation of geometric algorithms and discusses some approaches to solve them. A more recent overview is given in <a class="el" href="citelist.html#CITEREF_s-rpigc-00">[5]</a>. The exact computation paradigm is discussed by Yap and Dubé <a class="el" href="citelist.html#CITEREF_yd-ecp-95">[6]</a> and Yap <a class="el" href="citelist.html#CITEREF_y-tegc-97">[7]</a>.</p>
<p>In <span style="font-variant: small-caps;">CGAL</span> you can choose the underlying number types and arithmetic. You can use different types of arithmetic simultaneously and the choice can be easily changed, e.g. for testing. So you can choose between implementations with fast but occasionally inexact arithmetic and implementations guaranteeing exact computation and exact results. Of course you have to pay for the exactness in terms of execution time and storage space. See the dedicated chapter for more details on number types and their capabilities and performance.</p>
<h1><a class="anchor" id="kernel_rep"></a>
Kernel Representations</h1>
<p>Our object of study is the \( d\)-dimensional affine Euclidean space. Here we are mainly concerned with cases \( d=2\) and \( d=3\). Objects in that space are sets of points. A common way to represent the points is the use of Cartesian coordinates, which assumes a reference frame (an origin and \( d\) orthogonal axes). In that framework, a point is represented by a \( d\)-tuple \( (c_0,c_1,\ldots,c_{d-1})\), and so are vectors in the underlying linear space. Each point is represented uniquely by such Cartesian coordinates. Another way to represent points is by homogeneous coordinates. In that framework, a point is represented by a \( (d+1)\)-tuple \( (h_0,h_1,\ldots,h_d)\). Via the formulae \( c_i = h_i/h_d\), the corresponding point with Cartesian coordinates \( (c_0,c_1,\ldots,c_{d-1})\) can be computed. Note that homogeneous coordinates are not unique. For \( \lambda\ne 0\), the tuples \( (h_0,h_1,\ldots,h_d)\) and \( (\lambda\cdot h_0,\lambda\cdot h_1,\ldots,\lambda\cdot h_d)\) represent the same point. For a point with Cartesian coordinates \( (c_0,c_1,\ldots,c_{d-1})\) a possible homogeneous representation is \( (c_0,c_1,\ldots,c_{d-1},1)\). Homogeneous coordinates in fact allow to represent objects in a more general space, the projective space \( \mathbb{P}^d\). In <span style="font-variant: small-caps;">CGAL</span> we do not compute in projective geometry. Rather, we use homogeneous coordinates to avoid division operations, since the additional coordinate can serve as a common denominator.</p>
<h2><a class="anchor" id="Kernel_23GenericityThroughParameterization"></a>
Genericity Through Parameterization</h2>
<p>Almost all the kernel objects (and the corresponding functions) are templates with a parameter that allows the user to choose the representation of the kernel objects. A type that is used as an argument for this parameter must fulfill certain requirements on syntax and semantics. The list of requirements defines an abstract kernel concept. For all kernel objects types, the types <code>CGAL::Type&lt;<a class="el" href="classKernel.html" title="The concept of a kernel is defined by a set of requirements on the provision of certain types and acc...">Kernel</a>&gt;</code> and <code>Kernel::Type</code> are identical.</p>
<p><span style="font-variant: small-caps;">CGAL</span> offers four families of concrete models for the concept <a class="el" href="classKernel.html" title="The concept of a kernel is defined by a set of requirements on the provision of certain types and acc...">Kernel</a>, two based on the Cartesian representation of points and two based on the homogeneous representation of points. The interface of the kernel objects is designed such that it works well with both Cartesian and homogeneous representation. For example, points in 2D have a constructor with three arguments as well (the three homogeneous coordinates of the point). The common interfaces parameterized with a kernel class allow one to develop code independent of the chosen representation. We said "families" of models, because both families are parameterized too. A user can choose the number type used to represent the coordinates.</p>
<p>For reasons that will become evident later, a kernel class provides two typenames for number types, namely <code><a class="el" href="classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd" title="a model of FieldNumberType ">Kernel::FT</a></code> and <code><a class="el" href="classKernel.html#aacd6ff704fc864440c40993a40210f6b" title="a model of RingNumberType ">Kernel::RT</a></code>. The type <code><a class="el" href="classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd" title="a model of FieldNumberType ">Kernel::FT</a></code> must fulfill the requirements on what is called a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> in <span style="font-variant: small-caps;">CGAL</span>. This roughly means that <code><a class="el" href="classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd" title="a model of FieldNumberType ">Kernel::FT</a></code> is a type for which operations \( +\), \( -\), \( *\) and \( /\) are defined with semantics (approximately) corresponding to those of a field in a mathematical sense. Note that, strictly speaking, the built-in type <code>int</code> does not fulfill the requirements on a field type, since <code>int</code>s correspond to elements of a ring rather than a field, especially operation \( /\) is not the inverse of \( *\). The requirements on the type <code><a class="el" href="classKernel.html#aacd6ff704fc864440c40993a40210f6b" title="a model of RingNumberType ">Kernel::RT</a></code> are weaker. This type must fulfill the requirements on what is called a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a></code> in <span style="font-variant: small-caps;">CGAL</span>. This roughly means that <code><a class="el" href="classKernel.html#aacd6ff704fc864440c40993a40210f6b" title="a model of RingNumberType ">Kernel::RT</a></code> is a type for which operations \( +\), \( -\), \( *\) are defined with semantics (approximately) corresponding to those of a ring in a mathematical sense.</p>
<h2><a class="anchor" id="Kernel_23CartesianKernels"></a>
Cartesian Kernels</h2>
<p>With <code><a class="el" href="structCGAL_1_1Cartesian.html" title="A model for Kernel that uses Cartesian coordinates to represent the geometric objects. ">Cartesian</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>&gt;</code> you can choose a Cartesian representation of coordinates. When you choose Cartesian representation you have to declare at the same time the type of the coordinates. A number type used with the <code><a class="el" href="structCGAL_1_1Cartesian.html" title="A model for Kernel that uses Cartesian coordinates to represent the geometric objects. ">Cartesian</a></code> representation class should be a <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a> as described above. As mentioned above, the built-in type <code>int</code> is not a <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>. However, for some computations with Cartesian representation, no division operation is needed, i.e., a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a></code> is sufficient in this case. With <code><a class="el" href="structCGAL_1_1Cartesian.html" title="A model for Kernel that uses Cartesian coordinates to represent the geometric objects. ">Cartesian</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>&gt;</code>, both <a class="el" href="structCGAL_1_1Cartesian.html#a8cb4bfb5620f0972f846f002db57f67e">Cartesian&lt;FieldNumberType&gt;::FT</a> and <a class="el" href="structCGAL_1_1Cartesian.html#a4669cacde64b5fe6f7a35f4844c58398">Cartesian&lt;FieldNumberType&gt;::RT</a> are mapped to <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code>.</p>
<p><code><a class="el" href="structCGAL_1_1Cartesian.html" title="A model for Kernel that uses Cartesian coordinates to represent the geometric objects. ">Cartesian</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>&gt;</code> uses reference counting internally to save copying costs. <span style="font-variant: small-caps;">CGAL</span> also provides <code><a class="el" href="structCGAL_1_1Simple__cartesian.html" title="A model for a Kernel using Cartesian coordinates to represent the geometric objects. ">Simple_cartesian</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>&gt;</code>, a kernel that uses Cartesian representation but no reference counting. Debugging is easier with <code><a class="el" href="structCGAL_1_1Simple__cartesian.html" title="A model for a Kernel using Cartesian coordinates to represent the geometric objects. ">Simple_cartesian</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>&gt;</code>, since the coordinates are stored within the class and hence direct access to the coordinates is possible. Depending on the algorithm, it can also be slightly more or less efficient than <code><a class="el" href="structCGAL_1_1Cartesian.html" title="A model for Kernel that uses Cartesian coordinates to represent the geometric objects. ">Cartesian</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>&gt;</code>. Again, in <code><a class="el" href="structCGAL_1_1Simple__cartesian.html" title="A model for a Kernel using Cartesian coordinates to represent the geometric objects. ">Simple_cartesian</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a>&gt;</code> both <a class="el" href="structCGAL_1_1Simple__cartesian.html#a7c21b43a7da612194bd57c927f80ebc3">Simple_cartesian&lt;FieldNumberType&gt;::FT </a> and <a class="el" href="structCGAL_1_1Simple__cartesian.html#a33d4df5a291b37d25476b6f35c1d1bf9">Simple_cartesian&lt;FieldNumberType&gt;::RT </a> are mapped to <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code>.</p>
<h2><a class="anchor" id="Kernel_23HomogeneousKernels"></a>
Homogeneous Kernels</h2>
<p>Homogeneous coordinates permit to avoid division operations in numerical computations, since the additional coordinate can serve as a common denominator. Avoiding divisions can be useful for exact geometric computation. With <code><a class="el" href="structCGAL_1_1Homogeneous.html" title="A model for a Kernel using homogeneous coordinates to represent the geometric objects. ">Homogeneous</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code> you can choose a homogeneous representation for the coordinates of the kernel objects. As for the Cartesian representation, one has to declare the type used to store the coordinates. Since the homogeneous representation does not use divisions, the number type associated with a homogeneous representation class must be a model for the weaker concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a></code> only. However, some operations provided by this kernel involve divisions, for example computing squared distances or Cartesian coordinates. To keep the requirements on the number type parameter of <code><a class="el" href="structCGAL_1_1Homogeneous.html" title="A model for a Kernel using homogeneous coordinates to represent the geometric objects. ">Homogeneous</a></code> low, the number type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code> is used for operations that require divisions. This number type can be viewed as an adaptor which turns a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a></code> into a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code>. It maintains numbers as quotients, i.e., a numerator and a denominator. With <code><a class="el" href="structCGAL_1_1Homogeneous.html" title="A model for a Kernel using homogeneous coordinates to represent the geometric objects. ">Homogeneous</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code>, <a class="el" href="structCGAL_1_1Homogeneous.html#a002a92b6c4048842b3bf528f3c4bacf7">Homogeneous&lt;RingNumberType&gt;::FT </a> is equal to <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code>, while <a class="el" href="structCGAL_1_1Homogeneous.html#a79110268c6cc705967095874abe53e6d">Homogeneous&lt;RingNumberType&gt;::RT</a> is equal to <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a></code>.</p>
<p><code><a class="el" href="structCGAL_1_1Homogeneous.html" title="A model for a Kernel using homogeneous coordinates to represent the geometric objects. ">Homogeneous</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code> uses reference counting internally to save copying costs. <span style="font-variant: small-caps;">CGAL</span> also provides <code><a class="el" href="structCGAL_1_1Simple__homogeneous.html" title="A model for a Kernel using homogeneous coordinates to represent the geometric objects. ">Simple_homogeneous</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code>, a kernel that uses homogeneous representation but no reference counting. Debugging is easier with <code><a class="el" href="structCGAL_1_1Simple__homogeneous.html" title="A model for a Kernel using homogeneous coordinates to represent the geometric objects. ">Simple_homogeneous</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code>, since the coordinates are stored within the class and hence direct access to the coordinates is possible. Depending on the algorithm, it can also be slightly more or less efficient than <code><a class="el" href="structCGAL_1_1Homogeneous.html" title="A model for a Kernel using homogeneous coordinates to represent the geometric objects. ">Homogeneous</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code>. Again, in <code><a class="el" href="structCGAL_1_1Simple__homogeneous.html" title="A model for a Kernel using homogeneous coordinates to represent the geometric objects. ">Simple_homogeneous</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code> the type <a class="el" href="structCGAL_1_1Simple__homogeneous.html#a3437428a4684ec9298cbf3b63f2fa560">Simple_homogeneous&lt;RingNumberType&gt;::FT </a> is equal to <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a>&gt;</code> while <a class="el" href="structCGAL_1_1Simple__homogeneous.html#a7cd6934f5eef128a6368f9ec3bfee0ba">Simple_homogeneous&lt;RingNumberType&gt;::RT </a> is equal to <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a></code>.</p>
<h2><a class="anchor" id="Kernel_23NamingConventions"></a>
Naming Conventions</h2>
<p>The use of kernel classes not only avoids problems, it also makes all <span style="font-variant: small-caps;">CGAL</span> classes very uniform. They always consist of: </p><ol>
<li>
<p class="startli">The <em>capitalized base name</em> of the geometric object, such as <code>Point</code>, <code>Segment</code>, or <code>Triangle</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">An <em>underscore</em> followed by the <em>dimension</em> of the object, for example \( \_2\), \( \_3\), or \( \_d\).</p>
<p class="endli"></p>
</li>
<li>
A <em>kernel class</em> as parameter, which itself is parameterized with a number type, such as <code><a class="el" href="structCGAL_1_1Cartesian.html" title="A model for Kernel that uses Cartesian coordinates to represent the geometric objects. ">Cartesian</a>&lt;double&gt;</code> or <code><a class="el" href="structCGAL_1_1Homogeneous.html" title="A model for a Kernel using homogeneous coordinates to represent the geometric objects. ">Homogeneous</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__integer.html">leda_integer</a>&gt;</code>. </li>
</ol>
<h2><a class="anchor" id="Kernel_23KernelasaTraitsClass"></a>
Kernel as a Traits Class</h2>
<p>Algorithms and data structures in the basic library of <span style="font-variant: small-caps;">CGAL</span> are parameterized by a traits class that subsumes the objects on which the algorithm or data structure operates as well as the operations to do so. For most of the algorithms and data structures in the basic library you can use a kernel as a traits class. For some algorithms you even do not have to specify the kernel; it is detected automatically using the types of the geometric objects passed to the algorithm. In some other cases, the algorithms or data structures needs more than is provided by the kernel concept. In these cases, a kernel can not be used as a traits class.</p>
<h2><a class="anchor" id="Kernel_23ChoosingaKernelandPredefinedKernels"></a>
Choosing a Kernel and Predefined Kernels</h2>
<p>If you start with integral Cartesian coordinates, many geometric computations will involve integral numerical values only. Especially, this is true for geometric computations that evaluate only predicates, which are tantamount to determinant computations. Examples are triangulation of point sets and convex hull computation. In this case, the Cartesian representation is probably the first choice, even with a ring type. You might use limited precision integer types like <code>int</code> or <code>long</code>, use <code>double</code> to present your integers (they have more bits in their mantissa than an <code>int</code> and overflow nicely), or an arbitrary precision integer type like the wrapper <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">Gmpz</a></code> for the GMP integers, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__integer.html">leda_integer</a></code>, or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">MP_Float</a></code>. Note, that unless you use an arbitrary precision ring type, incorrect results might arise due to overflow.</p>
<p>If new points are to be constructed, for example the intersection point of two lines, computation of Cartesian coordinates usually involves divisions. Hence, one needs to use a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> with Cartesian representation, or alternatively, switch to homogeneous representation. The type <code>double</code> is a - though imprecise - model for <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code>. You can also put any <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a></code> into the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a></code> adaptor to get a field type which then can be put into <code><a class="el" href="structCGAL_1_1Cartesian.html" title="A model for Kernel that uses Cartesian coordinates to represent the geometric objects. ">Cartesian</a></code>. But using homogeneous representation on the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classRingNumberType.html">RingNumberType</a></code> is usually the better option. Other valid <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code>s are <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__rational.html">leda_rational</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__real.html">leda_real</a></code>.</p>
<p>If it is crucial for you that the computation is reliable, the right choice is probably a number type that guarantees exact computation. The <code><a class="el" href="structCGAL_1_1Filtered__kernel.html" title="Filtered_kernel is a kernel that uses a filtering technique based on interval arithmetic form to achi...">Filtered_kernel</a></code> provides a way to apply filtering techniques <a class="el" href="citelist.html#CITEREF_cgal:bbp-iayed-01">[1]</a> to achieve a kernel with exact and efficient predicates. Still other people will prefer the built-in type <code>double</code>, because they need speed and can live with approximate results, or even algorithms that, from time to time, crash or compute incorrect results due to accumulated rounding errors.</p>
<h3><a class="anchor" id="Kernel_23PredefinedKernels"></a>
Predefined Kernels</h3>
<p>For the user's convenience, <span style="font-variant: small-caps;">CGAL</span> provides 3 typedefs to generally useful kernels.</p>
<ul>
<li>
They are all Cartesian kernels. </li>
<li>
They all support constructions of points from <code>double</code> Cartesian coordinates. </li>
<li>
All these 5 kernels provide exact geometric predicates. </li>
<li>
They handle geometric constructions differently: <ul>
<li>
<code><a class="el" href="classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html" title="A typedef to a kernel which has the following properties: ">Exact_predicates_inexact_constructions_kernel</a></code>: provides exact geometric predicates, but geometric constructions may be inexact due to round-off errors. It is however enough for many <span style="font-variant: small-caps;">CGAL</span> algorithms, and faster than the kernels with exact constructions below. </li>
<li>
<code><a class="el" href="classCGAL_1_1Exact__predicates__exact__constructions__kernel.html" title="A typedef to a kernel which has the following properties: ">Exact_predicates_exact_constructions_kernel</a></code>: provides exact geometric constructions, in addition to exact geometric predicates. </li>
<li>
<code><a class="el" href="classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__sqrt.html" title="A typedef to a kernel which has the following properties: ">Exact_predicates_exact_constructions_kernel_with_sqrt</a></code>: same as <code><a class="el" href="classCGAL_1_1Exact__predicates__exact__constructions__kernel.html" title="A typedef to a kernel which has the following properties: ">Exact_predicates_exact_constructions_kernel</a></code>, but the number type is a model of concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldWithSqrt.html">FieldWithSqrt</a></code>. <span class="footnote">Currently it requires having either LEDA or <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/namespaceCORE.html">CORE</a> installed.</span>. </li>
<li>
<code><a class="el" href="classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__kth__root.html" title="A typedef to a kernel which has the following properties: ">Exact_predicates_exact_constructions_kernel_with_kth_root</a></code> same as <code><a class="el" href="classCGAL_1_1Exact__predicates__exact__constructions__kernel.html" title="A typedef to a kernel which has the following properties: ">Exact_predicates_exact_constructions_kernel</a></code>, but the number type is a model of concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldWithKthRoot.html">FieldWithKthRoot</a></code>. <span class="footnote">Currently it requires having either LEDA or <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/namespaceCORE.html">CORE</a> installed.</span>. </li>
<li>
<code><a class="el" href="classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__root__of.html" title="A typedef to a kernel which has the following properties: ">Exact_predicates_exact_constructions_kernel_with_root_of</a></code>: same as <code><a class="el" href="classCGAL_1_1Exact__predicates__exact__constructions__kernel.html" title="A typedef to a kernel which has the following properties: ">Exact_predicates_exact_constructions_kernel</a></code>, but the number type is a model of concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/classFieldWithRootOf.html">FieldWithRootOf</a></code>. <span class="footnote">Currently it requires having either LEDA or <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/namespaceCORE.html">CORE</a> installed.</span>. </li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="Kernel_23Kernel"></a>
Kernel Geometry</h1>
<h2><a class="anchor" id="Kernel_23PointsandVectors"></a>
Points and Vectors</h2>
<p>In <span style="font-variant: small-caps;">CGAL</span> we strictly distinguish between points, vectors and directions. A <em>point</em> is a point in the Euclidean space \( \E^d\), a <em>vector</em> is the difference of two points \( p_2\), \( p_1\) and denotes the direction and the distance from \( p_1\) to \( p_2\) in the vector space \( \mathbb{R}^d\), and a <em>direction</em> is a vector where we forget about its length. They are different mathematical concepts. For example, they behave different under affine transformations and an addition of two points is meaningless in affine geometry. By putting them in different classes we not only get cleaner code, but also type checking by the compiler which avoids ambiguous expressions. Hence, it pays twice to make this distinction.</p>
<p><span style="font-variant: small-caps;">CGAL</span> defines a symbolic constant <a class="el" href="group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a> of type <code><a class="el" href="classCGAL_1_1Origin.html" title="CGAL defines a symbolic constant ORIGIN which denotes the point at the origin. ">Origin</a></code> which denotes the point at the origin. This constant is used in the conversion between points and vectors. Subtracting it from a point \( p\) results in the locus vector of \( p\).</p>
<div class="fragment"><div class="line">Cartesian&lt;double&gt;::Point_2 p(1.0, 1.0), q;</div><div class="line">Cartesian&lt;double&gt;::Vector_2 v;</div><div class="line">v = p - <a class="code" href="group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a>;</div><div class="line">q = ORIGIN + v; </div><div class="line">assert( p == q );</div></div><!-- fragment --><p>In order to obtain the point corresponding to a vector \( v\) you simply have to add \( v\) to <a class="el" href="group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a>. If you want to determine the point \( q\) in the middle between two points \( p_1\) and \( p_2\), you can write<span class="footnote">you might call <code>midpoint(p_1,p_2)</code> instead.</span></p>
<div class="fragment"><div class="line">q = p_1 + (p_2 - p_1) / 2.0;</div></div><!-- fragment --><p>Note that these constructions do not involve any performance overhead for the conversion with the currently available representation classes.</p>
<h2><a class="anchor" id="Kernel_23KernelObjects"></a>
Kernel Objects</h2>
<p>Besides points (<code><a class="el" href="classKernel_1_1Point__2.html" title="A type representing points in two dimensions. ">Kernel::Point_2</a></code>, <code><a class="el" href="classKernel_1_1Point__3.html" title="A type representing points in three dimensions. ">Kernel::Point_3</a></code>), vectors (<code><a class="el" href="classKernel_1_1Vector__2.html" title="A type representing vectors in two dimensions. ">Kernel::Vector_2</a></code>, <code><a class="el" href="classKernel_1_1Vector__3.html" title="A type representing vectors in three dimensions. ">Kernel::Vector_3</a></code>), and directions (<code><a class="el" href="classKernel_1_1Direction__2.html" title="A type representing directions in two dimensions. ">Kernel::Direction_2</a></code>, <code><a class="el" href="classKernel_1_1Direction__3.html" title="A type representing directions in three dimensions. ">Kernel::Direction_3</a></code>), <span style="font-variant: small-caps;">CGAL</span> provides lines, rays, segments, planes, triangles, tetrahedra, iso-rectangles, iso-cuboids, circles and spheres.</p>
<p>Lines (<code><a class="el" href="classKernel_1_1Line__2.html" title="A type representing straight lines (and halfspaces) in two dimensions. ">Kernel::Line_2</a></code>, <code><a class="el" href="classKernel_1_1Line__3.html" title="A type representing straight lines in three dimensions. ">Kernel::Line_3</a></code>) in <span style="font-variant: small-caps;">CGAL</span> are oriented. In two-dimensional space, they induce a partition of the plane into a positive side and a negative side. Any two points on a line induce an orientation of this line. A ray (<code><a class="el" href="classKernel_1_1Ray__2.html" title="A type representing rays in two dimensions. ">Kernel::Ray_2</a></code>, <code><a class="el" href="classKernel_1_1Ray__3.html" title="A type representing rays in three dimensions. ">Kernel::Ray_3</a></code>) is semi-infinite interval on a line, and this line is oriented from the finite endpoint of this interval towards any other point in this interval. A segment (<code><a class="el" href="classKernel_1_1Segment__2.html" title="A type representing segments in two dimensions. ">Kernel::Segment_2</a></code>, <code><a class="el" href="classKernel_1_1Segment__3.html" title="A type representing segments in three dimensions. ">Kernel::Segment_3</a></code>) is a bounded interval on a directed line, and the endpoints are ordered so that they induce the same direction as that of the line.</p>
<p>Planes are affine subspaces of dimension two in \( \E^3\), passing through three points, or a point and a line, ray, or segment. <span style="font-variant: small-caps;">CGAL</span> provides a correspondence between any plane in the ambient space \( \E^3\) and the embedding of \( \E^2\) in that space. Just like lines, planes are oriented and partition space into a positive side and a negative side. In <span style="font-variant: small-caps;">CGAL</span>, there are no special classes for half-spaces. Half-spaces in 2D and 3D are supposed to be represented by oriented lines and planes, respectively.</p>
<p>Concerning polygons and polyhedra, the kernel provides triangles, iso-oriented rectangles, iso-oriented cuboids and tetrahedra. More complex polygons<span class="footnote">Any sequence of points can be seen as a (not necessary simple) polygon or polyline. This view is used frequently in the basic library as well.</span> and polyhedra or polyhedral surfaces can be obtained from the basic library (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">Polygon_2</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code>), so they are not part of the kernel. As with any Jordan curves, triangles, iso-oriented rectangles and circles separate the plane into two regions, one bounded and one unbounded.</p>
<h2><a class="anchor" id="Kernel_23OrientationandRelativePosition"></a>
Orientation and Relative Position</h2>
<p>Geometric objects in <span style="font-variant: small-caps;">CGAL</span> have member functions that test the position of a point relative to the object. Full dimensional objects and their boundaries are represented by the same type, e.g. half-spaces and hyperplanes are not distinguished, neither are balls and spheres and discs and circles. Such objects split the ambient space into two full-dimensional parts, a bounded part and an unbounded part (e.g. circles), or two unbounded parts (e.g. hyperplanes). By default these objects are oriented, i.e., one of the resulting parts is called the positive side, the other one is called the negative side. Both of these may be unbounded.</p>
<p>These objects have a member function <code>oriented_side()</code> that determines whether a test point is on the positive side, the negative side, or on the oriented boundary. These function returns a value of type <code>Oriented_side</code>.</p>
<p>Those objects that split the space in a bounded and an unbounded part, have a member function <code>bounded_side()</code> with return type <code>Bounded_side</code>.</p>
<p>If an object is lower dimensional, e.g. a triangle in three-dimensional space or a segment in two-dimensional space, there is only a test whether a point belongs to the object or not. This member function, which takes a point as an argument and returns a Boolean value, is called <code>has_on()</code>.</p>
<h1><a class="anchor" id="Kernel_23Predicates"></a>
Predicates and Constructions</h1>
<h2><a class="anchor" id="Kernel_23Predicates_1"></a>
Predicates</h2>
<p>Predicates are at the heart of a geometry kernel. They are basic units for the composition of geometric algorithms and encapsulate decisions. Hence their correctness is crucial for the control flow and hence for the correctness of an implementation of a geometric algorithm. <span style="font-variant: small-caps;">CGAL</span> uses the term predicate in a generalized sense. Not only components returning a Boolean value are called predicates but also components returning an enumeration type like a <code>Comparison_result</code> or an <code>Orientation</code>. We say components, because predicates are implemented both as functions and function objects (provided by a kernel class).</p>
<p><span style="font-variant: small-caps;">CGAL</span> provides predicates for the orientation of point sets (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga140039774b89a338321c36e14732b787">orientation()</a></code>, <code><a class="el" href="group__left__turn__grp.html#ga54cc2a847df7133bee7fd61c7b236dcc" title="returns true iff p, q, and r form a left turn. ">left_turn()</a></code>, <code><a class="el" href="group__right__turn__grp.html#ga0ad6e42d5e16269b43122503521f447a" title="returns true iff p, q, and r form a right turn. ">right_turn()</a></code>, <code><a class="el" href="group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b" title="returns true, iff p, q, and r are collinear. ">collinear()</a></code>, <code><a class="el" href="group__coplanar__grp.html#ga79b3b4bcb01bf81048486dfd59a22c63" title="returns true, if p, q, r, and s are coplanar. ">coplanar()</a></code>), for comparing points according to some given order, especially for comparing Cartesian coordinates (e.g. <code><a class="el" href="group__lexicographically__xy__smaller__grp.html#gab4ac1479fab3f0e58debc845316a52e7" title="returns true iff p is lexicographically smaller than q with respect to  order. ">lexicographically_xy_smaller()</a></code>), in-circle and in-sphere tests, and predicates to compare distances.</p>
<h2><a class="anchor" id="Kernel_23Constructions"></a>
Constructions</h2>
<p>Functions and function objects that generate objects that are neither of type <code>bool</code> nor enum types are called constructions. Constructions involve computation of new numerical values and may be imprecise due to rounding errors unless a kernel with an exact number type is used.</p>
<p>Affine transformations (<code>Kernel::Aff_transformation_2</code>, <code>Kernel::Aff_transformation_3</code>) allow to generate new object instances under arbitrary affine transformations. These transformations include translations, rotations (in 2D only) and scaling. Most of the geometric objects in a kernel have a member function <code>transform(Aff_transformation t)</code> which applies the transformation to the object instance.</p>
<p><span style="font-variant: small-caps;">CGAL</span> also provides a set of functions that detect or compute the intersection between objects of the 2D kernel, and many objects in the 3D kernel, and functions to calculate their squared distance. Moreover, some member functions of kernel objects are constructions.</p>
<p>So there are routines that compute the square of the Euclidean distance, but no routines that compute the distance itself. Why? First of all, the two values can be derived from each other quite easily (by taking the square root or taking the square). So, supplying only the one and not the other is only a minor inconvenience for the user. Second, often either value can be used. This is for example the case when (squared) distances are compared. Third, the library wants to stimulate the use of the squared distance instead of the distance. The squared distance can be computed in more cases and the computation is cheaper. We do this by not providing the perhaps more natural routine, The problem of a distance routine is that it needs the <code>sqrt</code> operation. This has two drawbacks: </p><ul>
<li>
The <code>sqrt</code> operation can be costly. Even if it is not very costly for a specific number type and platform, avoiding it is always cheaper. </li>
<li>
There are number types on which no <code>sqrt</code> operation is defined, especially integer types and rationals. </li>
</ul>
<h2><a class="anchor" id="Kernel_23VariantReturnValues"></a>
Intersections and Variant Return Types</h2>
<p>Some functions, for example <a class="el" href="group__intersection__linear__grp.html"><code>intersection()</code></a>, can return different types of objects. To achieve this in a type-safe way <span style="font-variant: small-caps;">CGAL</span> uses return values of type <code>boost::optional&lt; boost::variant&lt; T... &gt; &gt;</code> were <code>T...</code> is a list of all possible resulting geometric objects. The exact result type of an intersection can be determined through the metafunction <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1cpp11_1_1result__of.html">cpp11::result_of</a>&lt;<a class="el" href="classKernel_1_1Intersect__2.html">Kernel::Intersect_2(Type1, Type2)</a>&gt;</code> or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1cpp11_1_1result__of.html">cpp11::result_of</a>&lt;<a class="el" href="classKernel_1_1Intersect__3.html">Kernel::Intersect_3(Type1, Type2)</a>&gt;</code>, where <code>Type1</code> and <code>Type2</code> are the types of the objects used in the intersection computation.</p>
<h2>Example </h2>
<p>In the following example, <code>result_of</code> is used to query the type of the return value for the intersection computation:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> Cartesian&lt;double&gt; K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2 Point_2;</div><div class="line"><span class="keyword">typedef</span> K::Segment_2 Segment_2;</div><div class="line"></div><div class="line">Segment_2 segment_1, segment_2;</div><div class="line"></div><div class="line">std::cin &gt;&gt; segment_1 &gt;&gt; segment_2;</div><div class="line"></div><div class="line"> </div><div class="line"><span class="comment">/* C++11 */</span></div><div class="line"><span class="comment">// auto v = intersection(segment_1, segment_2);</span></div><div class="line"></div><div class="line"><span class="comment">/* C++03 */</span></div><div class="line"><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1cpp11_1_1result__of.html#a0116f3bad73d2c51520c134dffbf1449">cpp11::result_of&lt;K::Intersect_2(Segment_2, Segment_2)&gt;::type</a></div><div class="line">v = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(segment_1, segment_2); </div><div class="line"><span class="keywordflow">if</span>(v) {</div><div class="line">  <span class="comment">/* not empty */</span></div><div class="line">  <span class="keywordflow">if</span> (<span class="keyword">const</span> Point_2 *p = boost::get&lt;Point_2&gt;(&amp;*v) ) {</div><div class="line">    <span class="comment">/* do something with *p */</span></div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <span class="keyword">const</span> Segment_2 *s = boost::get&lt;Segment_2&gt;(&amp;*v);</div><div class="line">    <span class="comment">/* do something with *s */</span></div><div class="line">  }</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">  <span class="comment">/* empty intersection */</span></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Kernel_23ConstructivePredicates"></a>
Constructive Predicates</h2>
<p>For testing where a point <code>p</code> lies with respect to a plane defined by three points <code>q</code>, <code>r</code> and <code>s</code>, one may be tempted to construct the plane <code><a class="el" href="classKernel_1_1Plane__3.html" title="A type representing planes (and half-spaces) in three dimensions. ">Kernel::Plane_3(q,r,s)</a></code> and use the method <code>oriented_side(p)</code>. This may pay off if many tests with respect to the plane are made. Nevertheless, unless the number type is exact, the constructed plane is only approximated, and round-off errors may lead <code>oriented_side(p)</code> to return an orientation which is different from the real orientation of <code>p</code>, <code>q</code>, <code>r</code>, and <code>s</code>.</p>
<p>In <span style="font-variant: small-caps;">CGAL</span>, we provide predicates in which such geometric decisions are made directly with a reference to the input points <code>p</code>, <code>q</code>, <code>r</code>, <code>s</code>, without an intermediary object like a plane. For the above test, the recommended way to get the result is to use <code>orientation(p,q,r,s)</code>. For exact number types, the situation is different. If several tests are to be made with the same plane, it pays off to construct the plane and to use <code>oriented_side(p)</code>.</p>
<h1><a class="anchor" id="sectionextensiblekernel"></a>
Extensible Kernel</h1>
<p>This manual section describe how users can plug user defined geometric classes in existing <span style="font-variant: small-caps;">CGAL</span> kernels. This is best illustrated by an example.</p>
<h2><a class="anchor" id="Kernel_23Introduction"></a>
Introduction</h2>
<p><span style="font-variant: small-caps;">CGAL</span> defines the concept of a geometry kernel. Such a kernel provides types, construction objects and generalized predicates. Most implementations of Computational Geometry algorithms and data structures in the basic library of <span style="font-variant: small-caps;">CGAL</span> were done in a way that classes or functions can be parametrized with a geometric traits class.</p>
<p>In most cases this geometric traits class must be a model of the <span style="font-variant: small-caps;">CGAL</span> geometry kernel concept (but there are some exceptions).</p>
<h2><a class="anchor" id="Kernel_23AnExtensiveExample"></a>
An Extensive Example</h2>
<p>Assume we have the following point class, where the coordinates are stored in an array of <code>doubles</code>, where we have another data member <code>color</code>, which shows up in the constructor.</p>
<p><br />
<b>File</b> <a class="el" href="Kernel_23_2MyPointC2_8h-example.html">Kernel_23/MyPointC2.h</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef MY_POINTC2_H</span></div><div class="line"><span class="preprocessor">#define MY_POINTC2_H</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Origin.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Bbox_2.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyPointC2 {</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> vec[2];</div><div class="line">  <span class="keywordtype">int</span> col;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  MyPointC2()</div><div class="line">    : col(0)</div><div class="line">  {</div><div class="line">    *vec = 0;</div><div class="line">    *(vec+1) = 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  MyPointC2(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keywordtype">int</span> c = 0)</div><div class="line">    : col(c)</div><div class="line">  {</div><div class="line">    *vec = x;</div><div class="line">    *(vec+1) = y;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; x()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> *vec; }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; y()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *(vec+1); }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> &amp; x() { <span class="keywordflow">return</span> *vec; }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>&amp; y() { <span class="keywordflow">return</span> *(vec+1); }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> color()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> col; }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span>&amp; color() { <span class="keywordflow">return</span> col; }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> MyPointC2 &amp;p)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> ( *vec == *(p.vec) )  &amp;&amp; ( *(vec+1) == *(p.vec + 1) &amp;&amp; ( col == p.col) );</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> MyPointC2 &amp;p)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">      <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == p);</div><div class="line">  }</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // MY_POINTC2_H</span></div></div><!-- fragment --><p>As said earlier the class is pretty minimalistic, for example it has no <code>bbox()</code> method. One might assume that a basic library algorithm which computes a bounding box (e.g, to compute the bounding box of a polygon), will not compile. Luckily it will, because it does not use of member functions of geometric objects, but it makes use of the functor <code><a class="el" href="classKernel.html#a9e2c3a6f5add4668ef1001899189ff6b" title="a model of Kernel::ConstructBbox_2 ">Kernel::Construct_bbox_2</a></code>.</p>
<p>To make the right thing happen with <code>MyPointC2</code> we have to provide the following functor.</p>
<p><br />
<b>File</b> <a class="el" href="Kernel_23_2MyConstruct_bbox_2_8h-example.html">Kernel_23/MyConstruct_bbox_2.h</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef MYCONSTRUCT_BBOX_2_H</span></div><div class="line"><span class="preprocessor">#define MYCONSTRUCT_BBOX_2_H</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ConstructBbox_2&gt;</div><div class="line"><span class="keyword">class </span>MyConstruct_bbox_2 : <span class="keyword">public</span> ConstructBbox_2 {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> ConstructBbox_2::operator();</div><div class="line"></div><div class="line">  <a class="code" href="classCGAL_1_1Bbox__2.html">CGAL::Bbox_2</a> operator()(<span class="keyword">const</span> MyPointC2&amp; p)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classCGAL_1_1Bbox__2.html">CGAL::Bbox_2</a>(p.x(), p.y(), p.x(), p.y());</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif //MYCONSTRUCT_BBOX_2_H</span></div></div><!-- fragment --><p>Things are similar for random access to the Cartesian coordinates of a point. As the coordinates are stored in an array of <code>doubles</code> we can use <code>double*</code> as random access iterator.</p>
<p><br />
<b>File</b> <a class="el" href="Kernel_23_2MyConstruct_coord_iterator_8h-example.html">Kernel_23/MyConstruct_coord_iterator.h</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef MYCONSTRUCT_COORD_ITERATOR_H</span></div><div class="line"><span class="preprocessor">#define MYCONSTRUCT_COORD_ITERATOR_H</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyConstruct_coord_iterator {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>* operator()(<span class="keyword">const</span> MyPointC2&amp; p)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> &amp;p.x();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>* operator()(<span class="keyword">const</span> MyPointC2&amp; p, <span class="keywordtype">int</span>)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>* pyptr = &amp;p.y();</div><div class="line">    pyptr++;</div><div class="line">    <span class="keywordflow">return</span> pyptr;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif //MYCONSTRUCT_COORD_ITERATOR_H</span></div></div><!-- fragment --><p>The last functor we have to provide is the one which constructs points. That is you are not forced to add the constructor with the <code><a class="el" href="classCGAL_1_1Origin.html" title="CGAL defines a symbolic constant ORIGIN which denotes the point at the origin. ">Origin</a></code> as parameter to your class, nor the constructor with homogeneous coordinates. The functor is a kind of glue layer between the <span style="font-variant: small-caps;">CGAL</span> algorithms and your class.</p>
<p><br />
<b>File</b> <a class="el" href="Kernel_23_2MyConstruct_point_2_8h-example.html">Kernel_23/MyConstruct_point_2.h</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef MYCONSTRUCT_POINT_2_H</span></div><div class="line"><span class="preprocessor">#define MYCONSTRUCT_POINT_2_H</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> OldK&gt;</div><div class="line"><span class="keyword">class </span>MyConstruct_point_2</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> K::RT         RT;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> K::Point_2    Point_2;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> K::Line_2     Line_2;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Point_2::Rep  Rep;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> Point_2                result_type;</div><div class="line"></div><div class="line">  <span class="comment">// Note : the CGAL::Return_base_tag is really internal CGAL stuff.</span></div><div class="line">  <span class="comment">// Unfortunately it is needed for optimizing away copy-constructions,</span></div><div class="line">  <span class="comment">// due to current lack of delegating constructors in the C++ standard.</span></div><div class="line">  Rep <span class="comment">// Point_2</span></div><div class="line">  operator()(CGAL::Return_base_tag, <a class="code" href="classCGAL_1_1Origin.html">CGAL::Origin</a> o)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> Rep(o); }</div><div class="line"></div><div class="line">  Rep <span class="comment">// Point_2</span></div><div class="line">  operator()(CGAL::Return_base_tag, <span class="keyword">const</span> RT&amp; x, <span class="keyword">const</span> RT&amp; y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> Rep(x, y); }</div><div class="line"></div><div class="line">  Rep <span class="comment">// Point_2</span></div><div class="line">  operator()(CGAL::Return_base_tag, <span class="keyword">const</span> RT&amp; x, <span class="keyword">const</span> RT&amp; y, <span class="keyword">const</span> RT&amp; w)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> Rep(x, y, w); }</div><div class="line"></div><div class="line">  Point_2</div><div class="line">  operator()(<span class="keyword">const</span> <a class="code" href="classCGAL_1_1Origin.html">CGAL::Origin</a>&amp;)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> MyPointC2(0, 0, 0); }</div><div class="line"></div><div class="line">  Point_2</div><div class="line">  operator()(<span class="keyword">const</span> RT&amp; x, <span class="keyword">const</span> RT&amp; y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> MyPointC2(x, y, 0);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Point_2&amp;</div><div class="line">  operator()(<span class="keyword">const</span> Point_2 &amp; p)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> p;</div><div class="line">  }</div><div class="line"></div><div class="line">  Point_2</div><div class="line">  operator()(<span class="keyword">const</span> Line_2&amp; l)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">typename</span> OldK::Construct_point_2 base_operator;</div><div class="line">    Point_2 p = base_operator(l);</div><div class="line">    <span class="keywordflow">return</span> p;</div><div class="line">  }</div><div class="line"></div><div class="line">  Point_2</div><div class="line">  operator()(<span class="keyword">const</span> Line_2&amp; l, <span class="keywordtype">int</span> i)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">typename</span> OldK::Construct_point_2 base_operator;</div><div class="line">    <span class="keywordflow">return</span> base_operator(l, i);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// We need this one, as such a functor is in the Filtered_kernel</span></div><div class="line">  Point_2</div><div class="line">  operator()(<span class="keyword">const</span> RT&amp; x, <span class="keyword">const</span> RT&amp; y, <span class="keyword">const</span> RT&amp; w)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span>(w != 1){</div><div class="line">      <span class="keywordflow">return</span> MyPointC2(x/w, y/w, 0);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      <span class="keywordflow">return</span> MyPointC2(x,y, 0);</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif //MYCONSTRUCT_POINT_2_H</span></div></div><!-- fragment --><p>Now we are ready to put the puzzle together. We won't explain it in detail, but you see that there are <code>typedefs</code> to the new point class and the functors. All the other types are inherited.</p>
<p><br />
<b>File</b> <a class="el" href="Kernel_23_2MyKernel_8h-example.html">Kernel_23/MyKernel.h</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef MYKERNEL_H</span></div><div class="line"><span class="preprocessor">#define MYKERNEL_H</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include "MyPointC2.h"</span></div><div class="line"><span class="preprocessor">#include "MySegmentC2.h"</span></div><div class="line"><span class="preprocessor">#include "MyConstruct_bbox_2.h"</span></div><div class="line"><span class="preprocessor">#include "MyConstruct_coord_iterator.h"</span></div><div class="line"><span class="preprocessor">#include "MyConstruct_point_2.h"</span></div><div class="line"></div><div class="line"><span class="comment">// K_ is the new kernel, and K_Base is the old kernel</span></div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> K_, <span class="keyword">typename</span> K_Base &gt;</div><div class="line"><span class="keyword">class </span>MyCartesian_base</div><div class="line">  : <span class="keyword">public</span> K_Base::template Base&lt;K_&gt;::Type</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> K_Base::template Base&lt;K_&gt;::Type   OldK;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> K_                                <a class="code" href="namespaceKernel.html">Kernel</a>;</div><div class="line">  <span class="keyword">typedef</span> MyPointC2                         Point_2;</div><div class="line">  <span class="keyword">typedef</span> MySegmentC2&lt;Kernel&gt;               Segment_2;</div><div class="line">  <span class="keyword">typedef</span> MyConstruct_point_2&lt;Kernel, OldK&gt;       Construct_point_2;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">double</span>*                     Cartesian_const_iterator_2;</div><div class="line">  <span class="keyword">typedef</span> MyConstruct_coord_iterator        Construct_cartesian_const_iterator_2;</div><div class="line">  <span class="keyword">typedef</span> MyConstruct_bbox_2&lt;typename OldK::Construct_bbox_2&gt;</div><div class="line">                                            Construct_bbox_2;</div><div class="line"></div><div class="line">  Construct_point_2</div><div class="line">  construct_point_2_object()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> Construct_point_2(); }</div><div class="line"></div><div class="line">  Construct_bbox_2</div><div class="line">  construct_bbox_2_object()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> Construct_bbox_2(); }</div><div class="line"></div><div class="line">  Construct_cartesian_const_iterator_2</div><div class="line">  construct_cartesian_const_iterator_2_object()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> Construct_cartesian_const_iterator_2(); }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt; <span class="keyword">typename</span> Kernel2 &gt;</div><div class="line">  <span class="keyword">struct </span>Base { <span class="keyword">typedef</span> MyCartesian_base&lt;Kernel2, K_Base&gt;  Type; };</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> FT_ &gt;</div><div class="line"><span class="keyword">struct </span>MyKernel</div><div class="line">  : <span class="keyword">public</span> CGAL::Type_equality_wrapper&lt;</div><div class="line">                MyCartesian_base&lt;MyKernel&lt;FT_&gt;, CGAL::Cartesian&lt;FT_&gt; &gt;,</div><div class="line">                MyKernel&lt;FT_&gt; &gt;</div><div class="line">{};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // MYKERNEL_H</span></div></div><!-- fragment --><p>Finally, we give an example how this new kernel can be used. Predicates and constructions work with the new point, they can be a used to construct segments and triangles with, and data structures from the Basic Library, as the Delaunay triangulation work with them.</p>
<p>The kernel itself can be made robust by plugging it in the <code><a class="el" href="structCGAL_1_1Filtered__kernel.html" title="Filtered_kernel is a kernel that uses a filtering technique based on interval arithmetic form to achi...">Filtered_kernel</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Kernel_23_2MyKernel_8cpp-example.html">Kernel_23/MyKernel.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Filtered_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/squared_distance_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include "MyKernel.h"</span></div><div class="line"><span class="preprocessor">#include "MyPointC2_iostream.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> MyKernel&lt;double&gt;                   MK;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Filtered__kernel__adaptor.html">CGAL::Filtered_kernel_adaptor&lt;MK&gt;</a>  K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K&gt;</a>  Delaunay_triangulation_2;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> K::Point_2         Point;</div><div class="line"><span class="keyword">typedef</span> K::Segment_2       Segment;</div><div class="line"><span class="keyword">typedef</span> K::Ray_2           Ray;</div><div class="line"><span class="keyword">typedef</span> K::Line_2          Line;</div><div class="line"><span class="keyword">typedef</span> K::Triangle_2      Triangle;</div><div class="line"><span class="keyword">typedef</span> K::Iso_rectangle_2 Iso_rectangle;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> RED= 1;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> BLACK=2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Point a(0,0), b(1,0), c(1,1), d(0,1);</div><div class="line">  a.color()=RED;</div><div class="line">  b.color()=BLACK;</div><div class="line">  d.color()=RED;</div><div class="line"></div><div class="line">  Delaunay_triangulation_2 dt;</div><div class="line">  dt.insert(a);</div><div class="line"></div><div class="line">  K::Orientation_2 <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga140039774b89a338321c36e14732b787">orientation</a>;</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga140039774b89a338321c36e14732b787">orientation</a>(a,b,c);</div><div class="line"></div><div class="line">  Point p(1,2), q;</div><div class="line">  p.color() = RED;</div><div class="line">  q.color() = BLACK;</div><div class="line">  std::cout &lt;&lt; p &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  K::Compute_squared_distance_2 <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga433853179f3d0e0d2b7929723b584517">squared_distance</a>;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"squared_distance(a, b) == "</span></div><div class="line">            &lt;&lt; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga433853179f3d0e0d2b7929723b584517">squared_distance</a>(a, b) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Segment s1(p,q), s2(a, c);</div><div class="line"></div><div class="line">  K::Construct_midpoint_2 construct_midpoint_2;</div><div class="line"></div><div class="line">  Point mp = construct_midpoint_2(p,q);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"midpoint("</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">" , "</span> &lt;&lt; q &lt;&lt; <span class="stringliteral">") == "</span> &lt;&lt; mp &lt;&lt; std::endl;</div><div class="line">  assert(s1.source().color() == RED);</div><div class="line"></div><div class="line"></div><div class="line">  K::Intersect_2 <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::cpp11::result_of&lt;K::Intersect_2(Segment, Segment)&gt;::type</a> </div><div class="line">    intersect = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(s1, s2);</div><div class="line"></div><div class="line">  K::Construct_cartesian_const_iterator_2 construct_it;</div><div class="line">  K::Cartesian_const_iterator_2  cit = construct_it(a);</div><div class="line">  assert(*cit == a.x());</div><div class="line"></div><div class="line">  cit = construct_it(a,0);</div><div class="line"></div><div class="line">  cit--;</div><div class="line">  assert(*cit == a.y());</div><div class="line"></div><div class="line">  Line l1(a,b), l2(p, q);</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(l1, l2);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(s1, l1);</div><div class="line"></div><div class="line">  Ray r1(d,b), r2(d,c);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(r1, r2);</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(r1, l1);</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga433853179f3d0e0d2b7929723b584517">squared_distance</a>(r1, r2);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga433853179f3d0e0d2b7929723b584517">squared_distance</a>(r1, l2);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga433853179f3d0e0d2b7929723b584517">squared_distance</a>(r1, s2);</div><div class="line"></div><div class="line">  Triangle t1(a,b,c), t2(a,c,d);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(t1, t2);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(t1, l1);</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(t1, s1);</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(t1, r1);</div><div class="line"></div><div class="line">  Iso_rectangle i1(a,c), i2(d,p);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(i1, i2);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(i1, s1);</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(i1, r1);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/group__PkgKernelDFunctions.html#ga0aa3e8b6bdf1bff509f8e2672ef194d1">intersection</a>(i1, l1);</div><div class="line"></div><div class="line">  t1.orientation();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; s1.source() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; t1.bbox() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"done"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Kernel_23Limitations"></a>
Limitations</h2>
<p>The point class must have member functions <code>x()</code> and <code>y()</code> (and <code>z()</code> for the 3d point). We will probably introduce function objects that take care of coordinate access.</p>
<p>As we enforce type equality between <code>MyKernel::Point_2</code> and <code><a class="el" href="classCGAL_1_1Point__2.html" title="An object p of the class Point_2 is a point in the two-dimensional Euclidean plane ...">Point_2</a>&lt;MyKernel&gt;</code>, the constructor with the color as third argument is not available.</p>
<h1><a class="anchor" id="sectionprojectiontraits"></a>
Projection Traits Classes</h1>
<p>It is sometimes useful to apply 2D algorithms to the projection of 3D points on a plane. Examples are triangulated terrains, which are points with elevation, or surface reconstruction from parallel slices, where one wants to check the simplicity or orientation of polygons.</p>
<p>For this purpose <span style="font-variant: small-caps;">CGAL</span> provides several projection traits classes, which are a model of traits class concepts of 2D triangulations, 2D polygon and 2D convex hull traits classes. The projection traits classes are listed in the "Is Model Of" sections of the concepts.</p>
<h1><a class="anchor" id="Kernel_23Design"></a>
Design and Implementation History</h1>
<p>At a meeting at Utrecht University in January 1995, Olivier Devillers, Andreas Fabri, Wolfgang Freiseisen, Geert-Jan Giezeman, Mark Overmars, Stefan Schirra, Otfried Schwarzkopf (now Otfried Cheong), and Sven Schönherr discussed the foundations of the <span style="font-variant: small-caps;">CGAL</span> kernel. Many design and software engineering issues were addressed, e.g. naming conventions, coupling of classes (flat versus deep class hierarchy), memory allocation, programming conventions, mutability of atomic objects, points and vectors, storing additional information, orthogonality of operations on the kernel objects, viewing non-constant-size objects like polygons as dynamic data structures (and hence not as part of the (innermost) kernel).</p>
<p>The people attending the meeting delegated the compilation of a draft specification to Stefan Schirra. The resulting draft specification was intentionally modeled on <span style="font-variant: small-caps;">CGAL</span>'s precursors <span style="font-variant: small-caps;">C++gal</span> and <span style="font-variant: small-caps;">Plageo</span> as well as on the geometric part of <span style="font-variant: small-caps;">LEDA</span>. The specification already featured coexistence of Cartesian and homogeneous representation of point/vector data and parameterization by number type(s). During the discussion of the draft a kernel design group was formed. The members of this group were Andreas Fabri, Geert-Jan Giezeman, Lutz Kettner, Stefan Schirra, and Sven Schönherr. The work of the kernel design group led to significant changes and improvements of the original design, e.g. the strong separation between points and vectors. Probably the most important enhancement was the design of a common superstructure for the previously uncoupled Cartesian and homogeneous representations. One can say, that the kernel was designed by this group. The kernel was later revised based on suggestions by Hervé Brönnimann, Bernd Gärtner, Michael Hoffmann, and Lutz Kettner.</p>
<p>A first version of the kernel was internally made available at the beginning of the <span style="font-variant: small-caps;">CGAL</span>-project (<span class="textsc">esprit ltr iv</span> project number 21957). Since then many more people contributed to the evolution of the kernel through discussions on the <span style="font-variant: small-caps;">CGAL</span> mailing lists. The implementation based on Cartesian representation was (initially) provided by Andreas Fabri, the homogeneous representation (initially) by Stefan Schirra. Intersection and distance computations were implemented by Geert-Jan Giezeman. Further work has been done by Susan Hert on the overall maintenance of the kernel. Philippe Guigue has provided efficient intersection tests for 3D triangles. Andreas Fabri, Michael Hoffmann and Sylvain Pion have improved the support for the extensibility and adaptability of the kernel. Pedro Machado Manhães de Castro and Monique Teillaud introduced 3D circles. In 2010, Pierre Alliez, Stéphane Tayeb and Camille Wormser added intersection constructions for 3D triangles and efficient intersection tests for bounding boxes.</p>
<h2><a class="anchor" id="Kernel_23Acknowledgment"></a>
Acknowledgment</h2>
<p>This work was supported by the Graduiertenkolleg 'Algorithmische Diskrete Mathematik', under grant DFG We 1265/2-1, and by ESPRIT IV Long Term Research Projects No. 21957 (CGAL) and No. 28155 (GALIA). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:03 for CGAL 4.13 - 2D and 3D Linear Geometry Kernel by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
