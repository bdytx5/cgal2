<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classCGAL_1_1Aff__transformation__2" kind="class" language="C++" prot="public">
    <compoundname>CGAL::Aff_transformation_2</compoundname>
    <includes local="no">CGAL/Aff_transformation_2.h</includes>
    <templateparamlist>
      <param>
        <type>typename <ref refid="classKernel" kindref="compound">Kernel</ref></type>
      </param>
    </templateparamlist>
      <sectiondef kind="user-defined">
      <header>Creation</header>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a47f305715cb75778048ea7329b5c02dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Aff_transformation_2&lt; Kernel &gt;::Aff_transformation_2</definition>
        <argsstring>(const Identity_transformation &amp;)</argsstring>
        <name>Aff_transformation_2</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Identity__transformation" kindref="compound">Identity_transformation</ref> &amp;</type>
        </param>
        <briefdescription>
<para>introduces an identity transformation. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="94" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1ab97331ea55f685c17b4447a4184835f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Aff_transformation_2&lt; Kernel &gt;::Aff_transformation_2</definition>
        <argsstring>(const Translation, const Vector_2&lt; Kernel &gt; &amp;v)</argsstring>
        <name>Aff_transformation_2</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Translation" kindref="compound">Translation</ref></type>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Vector__2" kindref="compound">Vector_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>introduces a translation by a vector <computeroutput>v</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="99" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a5cc6631b0ed023470ccfc9e37e5272fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Aff_transformation_2&lt; Kernel &gt;::Aff_transformation_2</definition>
        <argsstring>(const Rotation, const Direction_2&lt; Kernel &gt; &amp;d, const Kernel::RT &amp;num, const Kernel::RT &amp;den=RT(1))</argsstring>
        <name>Aff_transformation_2</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Rotation" kindref="compound">Rotation</ref></type>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Direction__2" kindref="compound">Direction_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>num</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>den</declname>
          <defval>RT(1)</defval>
        </param>
        <briefdescription>
<para>approximates the rotation over the angle indicated by direction <computeroutput>d</computeroutput>, such that the differences between the sines and cosines of the rotation given by d and the approximating rotation are at most <formula id="6">$ num/den$</formula> each. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><formula id="7">$ num/den&gt;0$</formula> and <formula id="8">$ d != 0$</formula>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="109" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a56a137e059bc71662485093c1bcd04c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Aff_transformation_2&lt; Kernel &gt;::Aff_transformation_2</definition>
        <argsstring>(const Rotation, const Kernel::RT &amp;sine_rho, const Kernel::RT &amp;cosine_rho, const Kernel::RT &amp;hw=RT(1))</argsstring>
        <name>Aff_transformation_2</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Rotation" kindref="compound">Rotation</ref></type>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>sine_rho</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>cosine_rho</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>hw</declname>
          <defval>RT(1)</defval>
        </param>
        <briefdescription>
<para>introduces a rotation by the angle <computeroutput>rho</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><formula id="9">$ sine\_rho^2 + cosine\_rho^2 == hw^2$</formula>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="118" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1adcdac26dc822f15053218abd7f706c1d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Aff_transformation_2&lt; Kernel &gt;::Aff_transformation_2</definition>
        <argsstring>(const Scaling, const Kernel::RT &amp;s, const Kernel::RT &amp;hw=RT(1))</argsstring>
        <name>Aff_transformation_2</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Scaling" kindref="compound">Scaling</ref></type>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>hw</declname>
          <defval>RT(1)</defval>
        </param>
        <briefdescription>
<para>introduces a scaling by a scale factor <formula id="10">$ s/hw$</formula>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="126" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1ad0a7c3e145a0f9e073c0fb5a1ee9973c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Aff_transformation_2&lt; Kernel &gt;::Aff_transformation_2</definition>
        <argsstring>(const Kernel::RT &amp;m00, const Kernel::RT &amp;m01, const Kernel::RT &amp;m02, const Kernel::RT &amp;m10, const Kernel::RT &amp;m11, const Kernel::RT &amp;m12, const Kernel::RT &amp;hw=RT(1))</argsstring>
        <name>Aff_transformation_2</name>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>m00</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>m01</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>m02</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>m10</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>m11</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>m12</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>hw</declname>
          <defval>RT(1)</defval>
        </param>
        <briefdescription>
<para>introduces a general affine transformation in the <formula id="11">$3 \times 3$</formula> matrix form <formula id="12">$ \small \mbox{\( \left(\begin{array}{ccc} m_{00} &amp; m_{01} &amp; m_{02}\\ m_{10} &amp; m_{11} &amp; m_{12}\\ 0 &amp; 0 &amp; hw \end{array}\right) \)} $</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>The sub-matrix <formula id="13">$1\over hw$</formula> <formula id="14">$\small \mbox{\( \left(\begin{array}{cc} m_{00} &amp; m_{01}\\ m_{10} &amp; m_{11} \end{array}\right) \) } $</formula> contains the scaling and rotation information, the vector <formula id="15">$ \small \left( \begin{array}{c} m_{02}\\ m_{12} \end{array} \right) $</formula> contains the translational part of the transformation. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="158" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a6381959cec20a2652bf8f7bdf8a29295" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Aff_transformation_2&lt; Kernel &gt;::Aff_transformation_2</definition>
        <argsstring>(const Kernel::RT &amp;m00, const Kernel::RT &amp;m01, const Kernel::RT &amp;m10, const Kernel::RT &amp;m11, const Kernel::RT &amp;hw=RT(1))</argsstring>
        <name>Aff_transformation_2</name>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>m00</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>m01</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>m10</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>m11</declname>
        </param>
        <param>
          <type>const <ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref> &amp;</type>
          <declname>hw</declname>
          <defval>RT(1)</defval>
        </param>
        <briefdescription>
<para>introduces a general linear transformation <formula id="16">$\small \mbox{\(\left(\begin{array}{ccc} m_{00} &amp; m_{01} &amp; 0\\ m_{10} &amp; m_{11} &amp; 0\\ 0 &amp; 0 &amp; hw \end{array}\right)\)}$</formula> i.e. there is no translational part. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="172" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Operations</header>
      <description><para>The main thing to do with transformations is to apply them on geometric objects.</para><para>Each class <computeroutput>Class_2&lt;<ref refid="classKernel" kindref="compound">Kernel</ref>&gt;</computeroutput> representing a geometric object has a member function: <programlisting><codeline><highlight class="normal">Class_2&lt;Kernel&gt;<sp/>transform(Aff_transformation_2&lt;Kernel&gt;<sp/>t).</highlight></codeline>
</programlisting></para><para>The transformation classes provide a member function <computeroutput><ref refid="classCGAL_1_1Aff__transformation__2_1af7b4f99e5d3d20c4e4520c0e9308d355" kindref="member">transform()</ref></computeroutput> for points, vectors, directions, and lines. The same functionality is also available through <computeroutput>operator()</computeroutput> overloads. </para></description>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1af7b4f99e5d3d20c4e4520c0e9308d355" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Point__2" kindref="compound">Point_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Point_2&lt;Kernel&gt; CGAL::Aff_transformation_2&lt; Kernel &gt;::transform</definition>
        <argsstring>(const Point_2&lt; Kernel &gt; &amp;p) const</argsstring>
        <name>transform</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Point__2" kindref="compound">Point_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="198" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a497909ddc5be38155e1731734f7275ba" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Vector__2" kindref="compound">Vector_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Vector_2&lt;Kernel&gt; CGAL::Aff_transformation_2&lt; Kernel &gt;::transform</definition>
        <argsstring>(const Vector_2&lt; Kernel &gt; &amp;p) const</argsstring>
        <name>transform</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Vector__2" kindref="compound">Vector_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="203" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1ab68a8e41abfecccd58ea7c7843b341df" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Direction__2" kindref="compound">Direction_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Direction_2&lt;Kernel&gt; CGAL::Aff_transformation_2&lt; Kernel &gt;::transform</definition>
        <argsstring>(const Direction_2&lt; Kernel &gt; &amp;p) const</argsstring>
        <name>transform</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Direction__2" kindref="compound">Direction_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="208" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a3956d862d18214919dc3db08bcee2871" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Line__2" kindref="compound">Line_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Line_2&lt;Kernel&gt; CGAL::Aff_transformation_2&lt; Kernel &gt;::transform</definition>
        <argsstring>(const Line_2&lt; Kernel &gt; &amp;p) const</argsstring>
        <name>transform</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Line__2" kindref="compound">Line_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="213" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1ac414633f55cbdf3819b8a39fd782f18a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Point__2" kindref="compound">Point_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Point_2&lt;Kernel&gt; CGAL::Aff_transformation_2&lt; Kernel &gt;::operator()</definition>
        <argsstring>(const Point_2&lt; Kernel &gt; &amp;p) const</argsstring>
        <name>operator()</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Point__2" kindref="compound">Point_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="218" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1aead7b672b513c50a453c1df41e7e84c8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Vector__2" kindref="compound">Vector_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Vector_2&lt;Kernel&gt; CGAL::Aff_transformation_2&lt; Kernel &gt;::operator()</definition>
        <argsstring>(const Vector_2&lt; Kernel &gt; &amp;p) const</argsstring>
        <name>operator()</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Vector__2" kindref="compound">Vector_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="223" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1abf5de2c777ef5630c07ea6f3d604150d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Direction__2" kindref="compound">Direction_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Direction_2&lt;Kernel&gt; CGAL::Aff_transformation_2&lt; Kernel &gt;::operator()</definition>
        <argsstring>(const Direction_2&lt; Kernel &gt; &amp;p) const</argsstring>
        <name>operator()</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Direction__2" kindref="compound">Direction_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="228" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a03683c3c58333de263c21d7107e213e4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Line__2" kindref="compound">Line_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Line_2&lt;Kernel&gt; CGAL::Aff_transformation_2&lt; Kernel &gt;::operator()</definition>
        <argsstring>(const Line_2&lt; Kernel &gt; &amp;p) const</argsstring>
        <name>operator()</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Line__2" kindref="compound">Line_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="233" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Miscellaneous</header>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a53692a313d28a7397daa4f83235a8ee5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Aff__transformation__2" kindref="compound">Aff_transformation_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Aff_transformation_2&lt;Kernel&gt; CGAL::Aff_transformation_2&lt; Kernel &gt;::operator*</definition>
        <argsstring>(const Aff_transformation_2&lt; Kernel &gt; &amp;s) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Aff__transformation__2" kindref="compound">Aff_transformation_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>composes two affine transformations. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="243" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a0dd4e7d36ff988cae2914dfa6325e602" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Aff__transformation__2" kindref="compound">Aff_transformation_2</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Aff_transformation_2&lt;Kernel&gt; CGAL::Aff_transformation_2&lt; Kernel &gt;::inverse</definition>
        <argsstring>() const</argsstring>
        <name>inverse</name>
        <briefdescription>
<para>gives the inverse transformation. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="248" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1aed27613015c192b02f52237d1c3bb699" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Aff_transformation_2&lt; Kernel &gt;::is_even</definition>
        <argsstring>() const</argsstring>
        <name>is_even</name>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, if the transformation is not reflecting, i.e. the determinant of the involved linear transformation is non-negative. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="255" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a25e1947fe04411ddf9ecf71197879cc5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Aff_transformation_2&lt; Kernel &gt;::is_odd</definition>
        <argsstring>() const</argsstring>
        <name>is_odd</name>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput>, if the transformation is reflecting. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="260" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Matrix Entry Access</header>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a954879511402f4e462ff1f9c0f646f6a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classKernel_1a55e83f5a9f8ca43588b02ae8256a8fbd" kindref="member">Kernel::FT</ref></type>
        <definition>Kernel::FT CGAL::Aff_transformation_2&lt; Kernel &gt;::cartesian</definition>
        <argsstring>(int i, int j) const</argsstring>
        <name>cartesian</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>j</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="270" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a7073d7799b1d81f5562b95312d10e0c9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classKernel_1a55e83f5a9f8ca43588b02ae8256a8fbd" kindref="member">Kernel::FT</ref></type>
        <definition>Kernel::FT CGAL::Aff_transformation_2&lt; Kernel &gt;::m</definition>
        <argsstring>(int i, int j) const</argsstring>
        <name>m</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>j</declname>
        </param>
        <briefdescription>
<para>returns entry <formula id="17">$ m_{ij}$</formula> in a matrix representation in which <formula id="18">$ m_{22}$</formula> is 1. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="275" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1ac4aabbbdb97f2cd2aefb5a3fd750c13b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref></type>
        <definition>Kernel::RT CGAL::Aff_transformation_2&lt; Kernel &gt;::homogeneous</definition>
        <argsstring>(int i, int j) const</argsstring>
        <name>homogeneous</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>j</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="280" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Aff__transformation__2_1a00485abf34793a3afc991d0d98f03762" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref></type>
        <definition>Kernel::RT CGAL::Aff_transformation_2&lt; Kernel &gt;::hm</definition>
        <argsstring>(int i, int j) const</argsstring>
        <name>hm</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>j</declname>
        </param>
        <briefdescription>
<para>returns entry <formula id="17">$ m_{ij}$</formula> in some fixed matrix representation. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Aff_transformation_2.h" line="285" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>The class <computeroutput><ref refid="classCGAL_1_1Aff__transformation__2" kindref="compound">Aff_transformation_2</ref></computeroutput> represents two-dimensional affine transformations. </para>    </briefdescription>
    <detaileddescription>
<para>The general form of an affine transformation is based on a homogeneous representation of points. Thereby all transformations can be realized by matrix multiplications.</para><para>Multiplying the transformation matrix by a scalar does not change the represented transformation. Therefore, any transformation represented by a matrix with rational entries can be represented by a transformation matrix with integer entries as well. (Multiply the matrix with the common denominator of the rational entries.) Hence, it is sufficient to use the number type <computeroutput><ref refid="classKernel_1aacd6ff704fc864440c40993a40210f6b" kindref="member">Kernel::RT</ref></computeroutput> to represent the entries of the transformation matrix.</para><para>CGAL offers several specialized affine transformations. Different constructors are provided to create them. They are parameterized with a symbolic name to denote the transformation type, followed by additional parameters. The symbolic name tags solve ambiguities in the function overloading and they make the code more readable, i.e., what type of transformation is created.</para><para>Since two-dimensional points have three homogeneous coordinates, we have a <formula id="0">$ 3\times 3$</formula> matrix <formula id="1">$ {(m_{ij})}_{i,\,j=0\ldots 2}$</formula>.</para><para>If the homogeneous representations are normalized (the homogenizing coordinate is 1), then the upper left <formula id="2">$ 2\times 2$</formula> matrix realizes linear transformations. In the matrix form of a translation, the translation vector <formula id="3">$ (v_0,\,v_1,\,1)$</formula> appears in the last column of the matrix. The entries <formula id="4">$ m_{20}$</formula> and <formula id="5">$ m_{21}$</formula> are always zero and therefore do not appear in the constructors.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Identity__transformation" kindref="compound">Identity_transformation</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Rotation" kindref="compound">Rotation</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Scaling" kindref="compound">Scaling</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Translation" kindref="compound">Translation</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__rational__rotation__approximation__grp" kindref="compound">CGAL::rational_rotation_approximation()</ref></computeroutput></para></simplesect>
<bold>Example</bold><linebreak/>
</para><para><programlisting><codeline><highlight class="normal">typedef<sp/>Cartesian&lt;double&gt;<sp/>K;<sp/></highlight></codeline>
<codeline><highlight class="normal">typedef<sp/>Aff_transformation_2&lt;K&gt;<sp/>Transformation;<sp/></highlight></codeline>
<codeline><highlight class="normal">typedef<sp/>Point_2&lt;K&gt;<sp/>Point;<sp/></highlight></codeline>
<codeline><highlight class="normal">typedef<sp/>Vector_2&lt;K&gt;<sp/>Vector;<sp/></highlight></codeline>
<codeline><highlight class="normal">typedef<sp/>Direction_2&lt;K&gt;<sp/>Direction;<sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Transformation<sp/>rotate(ROTATION,<sp/>sin(pi),<sp/>cos(pi));<sp/></highlight></codeline>
<codeline><highlight class="normal">Transformation<sp/>rational_rotate(ROTATION,Direction(1,1),<sp/>1,<sp/>100);<sp/></highlight></codeline>
<codeline><highlight class="normal">Transformation<sp/>translate(TRANSLATION,<sp/>Vector(-2,<sp/>0));<sp/></highlight></codeline>
<codeline><highlight class="normal">Transformation<sp/>scale(SCALING,<sp/>3);<sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Point<sp/>q(0,<sp/>1);<sp/></highlight></codeline>
<codeline><highlight class="normal">q<sp/>=<sp/>rational_rotate(q);<sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Point<sp/>p(1,<sp/>1);<sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">p<sp/>=<sp/>rotate(p);<sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">p<sp/>=<sp/>translate(p);<sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">p<sp/>=<sp/>scale(p);<sp/></highlight></codeline>
</programlisting></para><para>The same would have been achieved with</para><para><programlisting><codeline><highlight class="normal">Transformation<sp/>transform<sp/>=<sp/>scale<sp/>*<sp/>(translate<sp/>*<sp/>rotate);<sp/></highlight></codeline>
<codeline><highlight class="normal">p<sp/>=<sp/>transform(Point(1.0,<sp/>1.0));<sp/></highlight></codeline>
</programlisting></para><para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Aff__transformation__3" kindref="compound">CGAL::Aff_transformation_3</ref>&lt;<ref refid="classKernel" kindref="compound">Kernel</ref>&gt;</computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Identity__transformation" kindref="compound">CGAL::Identity_transformation</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Reflection" kindref="compound">CGAL::Reflection</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Rotation" kindref="compound">CGAL::Rotation</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Scaling" kindref="compound">CGAL::Scaling</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Translation" kindref="compound">CGAL::Translation</ref></computeroutput> </para></simplesect>
</para>    </detaileddescription>
    <location file="CGAL/Aff_transformation_2.h" line="85" column="1" bodyfile="CGAL/Aff_transformation_2.h" bodystart="85" bodyend="289"/>
    <listofallmembers>
      <member refid="classCGAL_1_1Aff__transformation__2_1a47f305715cb75778048ea7329b5c02dc" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>Aff_transformation_2</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1ab97331ea55f685c17b4447a4184835f0" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>Aff_transformation_2</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a5cc6631b0ed023470ccfc9e37e5272fb" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>Aff_transformation_2</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a56a137e059bc71662485093c1bcd04c8" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>Aff_transformation_2</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1adcdac26dc822f15053218abd7f706c1d" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>Aff_transformation_2</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1ad0a7c3e145a0f9e073c0fb5a1ee9973c" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>Aff_transformation_2</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a6381959cec20a2652bf8f7bdf8a29295" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>Aff_transformation_2</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a954879511402f4e462ff1f9c0f646f6a" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>cartesian</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a00485abf34793a3afc991d0d98f03762" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>hm</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1ac4aabbbdb97f2cd2aefb5a3fd750c13b" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>homogeneous</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a0dd4e7d36ff988cae2914dfa6325e602" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>inverse</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1aed27613015c192b02f52237d1c3bb699" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>is_even</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a25e1947fe04411ddf9ecf71197879cc5" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>is_odd</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a7073d7799b1d81f5562b95312d10e0c9" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>m</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1ac414633f55cbdf3819b8a39fd782f18a" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>operator()</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1aead7b672b513c50a453c1df41e7e84c8" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>operator()</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1abf5de2c777ef5630c07ea6f3d604150d" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>operator()</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a03683c3c58333de263c21d7107e213e4" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>operator()</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a53692a313d28a7397daa4f83235a8ee5" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>operator*</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1af7b4f99e5d3d20c4e4520c0e9308d355" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>transform</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a497909ddc5be38155e1731734f7275ba" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>transform</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1ab68a8e41abfecccd58ea7c7843b341df" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>transform</name></member>
      <member refid="classCGAL_1_1Aff__transformation__2_1a3956d862d18214919dc3db08bcee2871" prot="public" virt="non-virtual"><scope>CGAL::Aff_transformation_2</scope><name>transform</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
