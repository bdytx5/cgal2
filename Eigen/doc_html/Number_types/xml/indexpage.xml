<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Number_Types"/><anchor id="index_1Numbertype"/>  <simplesect kind="authors"><para>Michael Hemmer, Susan Hert, Sylvain Pion, and Stefan Schirra</para></simplesect>
</para><sect1 id="index_1Number_typesIntroduction">
<title>Introduction</title>
<para>This chapter gives an overview of the number types supported by CGAL. Number types must fulfill certain syntactical and semantic requirements, such that they can be successfully used in CGAL code. In general they are expected to be a model of an algebraic structure concepts and in case they model a subring of the real numbers they are also a model of <computeroutput><ref refid="classRealEmbeddable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">RealEmbeddable</ref></computeroutput>. For an overview of the algebraic structure concepts see Section <ref refid="group__PkgAlgebraicFoundations" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Algebraic Foundations Reference</ref>.</para></sect1>
<sect1 id="index_1Number_typesBuilt">
<title>Built-in Number Types</title>
<para>The built-in number types <computeroutput>float</computeroutput>, <computeroutput>double</computeroutput> and <computeroutput>long double</computeroutput> have the required arithmetic and comparison operators. They lack some required routines though which are automatically included by CGAL. The functions can be found in the header files <computeroutput><ref refid="int_8h" kindref="compound">CGAL/int.h</ref></computeroutput>, <computeroutput><ref refid="float_8h" kindref="compound">CGAL/float.h</ref></computeroutput>, <computeroutput><ref refid="double_8h" kindref="compound">CGAL/double.h</ref></computeroutput> and <computeroutput><ref refid="long__long_8h" kindref="compound">CGAL/long_long.h</ref></computeroutput>.</para><para>All built-in number types of C++ can represent a discrete (bounded) subset of the rational numbers only. We assume that the floating-point arithmetic of your machine follows Ieee floating-point standard. Since the floating-point culture has much more infrastructural support (hardware, language definition and compiler) than exact computation, it is very efficient. Like with all number types with finite precision representation which are used as approximations to the infinite ranges of integers or real numbers, the built-in number types are inherently potentially inexact. Be aware of this if you decide to use the efficient built-in number types: you have to cope with numerical problems. For example, you can compute the intersection point of two lines and then check whether this point lies on the two lines. With floating point arithmetic, roundoff errors may cause the answer of the check to be <computeroutput>false</computeroutput>. With the built-in integer types overflow might occur.</para></sect1>
<sect1 id="index_1Number_typesCGAL">
<title>Number Types Provided by CGAL</title>
<para><anchor id="index_1cgalnt"/> CGAL provides several number types that can be used for exact computation. These include the <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound">Quotient</ref></computeroutput> class that can be used to create, for example, a number type that behaves like a rational number when parameterized with a number type which can represent integers.</para><para>The number type <computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound">MP_Float</ref></computeroutput> is able to represent multi-precision floating point values, a generalization of integers scaled by a (potentially negative) power of 2. It allows to deal with ring operations over floating-point values with requiring rational numbers. By plugging it in <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound">Quotient</ref></computeroutput>, one obtains rational numbers. Note that <computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound">MP_Float</ref></computeroutput> may not be as efficient as the integer types provided by Gmp or LEDA, but it has the advantage to make more parts of CGAL independent on these external libraries for handling robustness issues.</para><para>The templated number type <computeroutput><ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound">Lazy_exact_nt</ref>&lt;NT&gt;</computeroutput> is able to represent any number that <computeroutput>NT</computeroutput> is able to represent, but because it first tries to use an approximate value to perform computations it can be faster than <computeroutput>NT</computeroutput>.</para><para>A number type for doing interval arithmetic, <computeroutput><ref refid="classCGAL_1_1Interval__nt" kindref="compound">Interval_nt</ref></computeroutput>, is provided. This number type helps in doing arithmetic filtering in many places such as <computeroutput><ref refid="classCGAL_1_1Filtered__predicate" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Filtered_predicate</ref></computeroutput>.</para><para><computeroutput><ref refid="classCGAL_1_1Sqrt__extension" kindref="compound">Sqrt_extension</ref></computeroutput> is a number type that allows to represent algebraic numbers of degree 2 as well as nested forms. A generic function <computeroutput><ref refid="group__nt__ralgebraic_1ga4cb90aeebfe5ff7cf7eef83ae2f09918" kindref="member">make_root_of_2()</ref></computeroutput> allows to build this type generically.</para><para>A debugging helper <computeroutput><ref refid="classCGAL_1_1Number__type__checker" kindref="compound">Number_type_checker</ref>&lt;NT1,NT2,Comparator&gt;</computeroutput> is also provided which allows to compare the behavior of operations over two number types.</para></sect1>
<sect1 id="index_1Number_typesGMP">
<title>Number Types Provided by GMP</title>
<para><anchor id="index_1gmpnt"/> CGAL provides wrapper classes for number types defined in the Gnu Multiple Precision arithmetic library <ref refid="citelist_1CITEREF_g-ggmpa" kindref="member">[2]</ref>. The file <computeroutput><ref refid="Gmpz_8h" kindref="compound">CGAL/Gmpz.h</ref></computeroutput> provides the class <computeroutput><ref refid="classCGAL_1_1Gmpz" kindref="compound">Gmpz</ref></computeroutput>, a wrapper class for the arbitrary-precision integer type <computeroutput>mpz_t</computeroutput>, which is compliant with the CGAL number type requirements. The file <computeroutput><ref refid="Gmpq_8h" kindref="compound">CGAL/Gmpq.h</ref></computeroutput> provides the class <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound">Gmpq</ref></computeroutput>, a wrapper class for the arbitrary-precision rational type <computeroutput>mpq_t</computeroutput>, which is compliant with the CGAL number type requirements.</para><para>The file <computeroutput><ref refid="Gmpzf_8h" kindref="compound">CGAL/Gmpzf.h</ref></computeroutput> provides the class <computeroutput><ref refid="classCGAL_1_1Gmpzf" kindref="compound">Gmpzf</ref></computeroutput>, an exact arbitrary-precision floating-point type. Hence, It does not support operators like <computeroutput>/</computeroutput> to guarantee exactness of the operations. The arithmetic operations on this type are restricted to <computeroutput>+</computeroutput>, <computeroutput>-</computeroutput>, <computeroutput>*</computeroutput> and <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga59e55b9e023c50ddb15c89fae4b68387" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">integral_division()</ref></computeroutput>. On some platforms, the file <computeroutput><ref refid="Mpzf_8h" kindref="compound">CGAL/Mpzf.h</ref></computeroutput> provides the class <computeroutput><ref refid="structCGAL_1_1Mpzf" kindref="compound">Mpzf</ref></computeroutput>, a faster alternative to <computeroutput><ref refid="classCGAL_1_1Gmpzf" kindref="compound">Gmpzf</ref></computeroutput> that doesn&apos;t support <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga59e55b9e023c50ddb15c89fae4b68387" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">integral_division()</ref></computeroutput>.</para><para>The file <computeroutput><ref refid="Gmpfr_8h" kindref="compound">CGAL/Gmpfr.h</ref></computeroutput> provides the class <computeroutput><ref refid="classCGAL_1_1Gmpfr" kindref="compound">Gmpfr</ref></computeroutput>, a fixed-precision floating-point number type. Since the precision (number of bits used to represent the mantissa of the number) is fixed for each object, the result of each operation is rounded when necessary. Though not necessary at first, the user will take full advantage of this number type by understanding the ideas behind floating-point arithmetic, such as precision and rounding, and understanding the flags set by this library after each operation. For more details, the reader should refer to <ref refid="citelist_1CITEREF_cgal:mt-mpfr" kindref="member">[5]</ref> and the <computeroutput><ref refid="classCGAL_1_1Gmpfr" kindref="compound">Gmpfr</ref></computeroutput> reference manual.</para><para>In addition, it is possible to directly use the C++ number types provided by Gmp : <computeroutput><ref refid="classmpz__class" kindref="compound">mpz_class</ref></computeroutput>, <computeroutput><ref refid="classmpq__class" kindref="compound">mpq_class</ref></computeroutput> (note that support for <computeroutput>mpf_class</computeroutput> is incomplete). The file <computeroutput><ref refid="gmpxx_8h" kindref="compound">CGAL/gmpxx.h</ref></computeroutput> provides the necessary functions to make these classes compliant to the CGAL number type requirements.</para><para>To use these classes, Gmp and Mpfr must be installed.</para></sect1>
<sect1 id="index_1Number_typesLEDA">
<title>Number Types Provided by LEDA</title>
<para><anchor id="index_1ledant"/> LEDA provides number types that can be used for exact computation with both <ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref> and homogeneous representations. If you are using homogeneous representation with the built-in integer types <computeroutput>short</computeroutput>, <computeroutput>int</computeroutput>, and <computeroutput>long</computeroutput> as ring type, exactness of computations can be guaranteed only if your input data come from a sufficiently small integral range and the depth of the computations is sufficiently small. LEDA provides the number type <computeroutput><ref refid="classleda__integer" kindref="compound">leda_integer</ref></computeroutput> for integers of arbitrary length. (Of course the length is somehow bounded by the resources of your computer.) It can be used as ring type in homogeneous kernels and leads to exact computation as long as all intermediate results are rational. For the same kind of problems, <ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref> representation with number type <computeroutput><ref refid="classleda__rational" kindref="compound">leda_rational</ref></computeroutput> leads to exact computation as well. The number type <computeroutput><ref refid="classleda__bigfloat" kindref="compound">leda_bigfloat</ref></computeroutput> in LEDA is a variable precision floating-point type. Rounding mode and precision (i.e. mantissa length) of <computeroutput><ref refid="classleda__bigfloat" kindref="compound">leda_bigfloat</ref></computeroutput> can be set.</para><para>The most sophisticated number type in LEDA is the number type called <computeroutput><ref refid="classleda__real" kindref="compound">leda_real</ref></computeroutput>. Like in Pascal, where the name <computeroutput>real</computeroutput> is used for floating-point numbers, the name <computeroutput><ref refid="classleda__real" kindref="compound">leda_real</ref></computeroutput> does not describe the number type precisely, but intentionally. <computeroutput><ref refid="classleda__real" kindref="compound">leda_real</ref></computeroutput> is a subset of real algebraic numbers. Any integer is <computeroutput><ref refid="classleda__real" kindref="compound">leda_real</ref></computeroutput> and <computeroutput><ref refid="classleda__real" kindref="compound">leda_real</ref></computeroutput> is closed under the operations <formula id="85">$ +,-,*,/$</formula> and <formula id="86">$ k$</formula>-th root computation. For LEDA version 5.0 and or later <computeroutput><ref refid="classleda__real" kindref="compound">leda_real</ref></computeroutput> is also able to represent real roots of polynomials. <computeroutput><ref refid="classleda__real" kindref="compound">leda_real</ref></computeroutput>s guarantee that all comparisons between expressions involving <computeroutput><ref refid="classleda__real" kindref="compound">leda_real</ref></computeroutput> produce the exact result.</para><para>The files <computeroutput><ref refid="leda__integer_8h" kindref="compound">CGAL/leda_integer.h</ref></computeroutput>, <computeroutput><ref refid="leda__rational_8h" kindref="compound">CGAL/leda_rational.h</ref></computeroutput>, <computeroutput><ref refid="leda__bigfloat_8h" kindref="compound">CGAL/leda_bigfloat.h</ref></computeroutput> and <computeroutput><ref refid="leda__real_8h" kindref="compound">CGAL/leda_real.h</ref></computeroutput> provide the necessary functions to make these classes compliant to the CGAL number type requirements.</para></sect1>
<sect1 id="index_1Number_typesCORE">
<title>Number Types Provided by CORE</title>
<para><anchor id="index_1corent"/> In principle Core <ref refid="citelist_1CITEREF_klpy-clp-99" kindref="member">[3]</ref> provides the same set of number types as LEDA. The type <computeroutput><ref refid="classCORE_1_1BigInt" kindref="compound">CORE::BigInt</ref></computeroutput> represent integers and <computeroutput><ref refid="classCORE_1_1BigRat" kindref="compound">CORE::BigRat</ref></computeroutput> represent rationals of arbitrary length. The number type <computeroutput><ref refid="classCORE_1_1BigFloat" kindref="compound">CORE::BigFloat</ref></computeroutput> is a variable precision floating-point type. It is also possible to interpret it as an interval type, since it also carries the error of a computed value. As for LEDA, the most sophisticated number type in Core is <computeroutput><ref refid="classCORE_1_1Expr" kindref="compound">CORE::Expr</ref></computeroutput>, which is in its functionality equivalent to <computeroutput><ref refid="classleda__real" kindref="compound">leda_real</ref></computeroutput>.</para></sect1>
<sect1 id="index_1Number_typesInterval">
<title>Interval Arithmetic</title>
<para>Interval arithmetic is very important for geometric programming. It is a fundamental tool for filtering predicates. For many problems, intervals of machine double-precision numbers are sufficient, but it is not always enough. For example, one approach for determining the sign of an expression is to evaluate its sign using interval arithmetic and to repeatedly increase the precision of the bounds of the intervals until either the interval does not contain zero or its width is less than the separation bound of the polynomial.</para><para>For intervals of machine double-precision numbers, CGAL provides the class <computeroutput><ref refid="classCGAL_1_1Interval__nt" kindref="compound">Interval_nt</ref></computeroutput>. For intervals of floating-point arbitrary-precision numbers, CGAL provides the class <computeroutput><ref refid="classCGAL_1_1Gmpfi" kindref="compound">Gmpfi</ref></computeroutput>.</para><para>Endpoints of <computeroutput><ref refid="classCGAL_1_1Gmpfi" kindref="compound">Gmpfi</ref></computeroutput> intervals are represented as <computeroutput><ref refid="classCGAL_1_1Gmpfr" kindref="compound">Gmpfr</ref></computeroutput> numbers. Each interval has an associated <emphasis>precision</emphasis>, which is the maximum precision (number of bits used to represent the mantissa) of its endpoints. The result of the operations is guaranteed to be always contained in the returned interval. Since the interval arithmetic is implemented on top of <computeroutput><ref refid="classCGAL_1_1Gmpfr" kindref="compound">Gmpfr</ref></computeroutput>, the global flags are inherited from the <computeroutput><ref refid="classCGAL_1_1Gmpfr" kindref="compound">Gmpfr</ref></computeroutput> interface. See <ref refid="citelist_1CITEREF_cgal:r-mpfi" kindref="member">[4]</ref> and the <computeroutput><ref refid="classCGAL_1_1Gmpfi" kindref="compound">Gmpfi</ref></computeroutput> reference manual for details.</para><para>To use the <computeroutput><ref refid="classCGAL_1_1Gmpfi" kindref="compound">Gmpfi</ref></computeroutput> class, Mpfi must be installed.</para></sect1>
<sect1 id="index_1Number_typesUser">
<title>User-supplied Number Types</title>
<para>In order to use your own number type it must be a model of the according algebraic structure concept, in particular you must provide a specialization of <computeroutput><ref refid="classCGAL_1_1Algebraic__structure__traits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Algebraic_structure_traits</ref></computeroutput> and also of <computeroutput><ref refid="classCGAL_1_1Real__embeddable__traits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Real_embeddable_traits</ref></computeroutput> in case it is a sub ring of the real numbers. If you even want to provide a related ensemble of number types you should also provide specializations for <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Coercion_traits</ref></computeroutput> in order to reflect their interoperability.</para></sect1>
<sect1 id="index_1Number_typesDesign">
<title>Design and Implementation History</title>
<para>This package was naturally one of the first packages implemented in CGAL. It initially contained the <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound">Quotient</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Gmpz" kindref="compound">Gmpz</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound">Gmpq</ref></computeroutput> classes, together with the interfaces to the number types provided by LEDA, which were implemented by Stefan Schirra and Andreas Fabri.</para><para>Later, around 1998-2002, Sylvain Pion implemented <computeroutput><ref refid="classCGAL_1_1Interval__nt" kindref="compound">Interval_nt</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound">MP_Float</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound">Lazy_exact_nt</ref></computeroutput>, together with the interfaces to the <computeroutput><ref refid="classmpz__class" kindref="compound">mpz_class</ref></computeroutput> and <computeroutput><ref refid="classmpq__class" kindref="compound">mpq_class</ref></computeroutput> types from Gmp.</para><para>Number type concepts were then refined, notably by Lutz Kettner and Susan Hert, who also contributed utility algorithms.</para><para>The work on concepts was further extended within the Exacus project, and was finally contributed to CGAL by Michael Hemmer in 2006, as what is now the separate package <ref refid="index_1Chapter_Algebraic_Foundations" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">Algebraic Foundations</ref>, together with a rewritten interface to operations on number types.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Sqrt__extension" kindref="compound">Sqrt_extension</ref></computeroutput> was contributed by Michael Hemmer and Ron Wein around 2006. In 2010 it went through a considerable reinvestigation by S<eacute/>bastien Loriot, Michael Hemmer, and Monique Teillaud. As a result it got further improved and now replaces several similar types such as <computeroutput>Root_of_2</computeroutput>, which had been contributed by Pedro M. M. de Castro, Sylvain Pion and Monique Teillaud, and is deprecated since CGAL-3.8.</para><para>In 2008-2010, Bernd G<aumlaut/>rtner added the <computeroutput><ref refid="classCGAL_1_1Gmpzf" kindref="compound">Gmpzf</ref></computeroutput> class, while Luis Pe<ntilde/>aranda and Sylvain Lazard contributed the <computeroutput><ref refid="classCGAL_1_1Gmpfi" kindref="compound">Gmpfi</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Gmpfr" kindref="compound">Gmpfr</ref></computeroutput> classes. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
