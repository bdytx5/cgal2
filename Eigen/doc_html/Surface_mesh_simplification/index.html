<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Surface_mesh_simplification/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Triangulated Surface Mesh Simplification: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Triangulated Surface Mesh Simplification
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Triangulated_Surface_Mesh_Simplification"></a>  </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Fernando Cacciola</dd></dl>
<div class="image">
<img src="Illustration-Simplification-ALL.jpg" alt="Illustration-Simplification-ALL.jpg" />
</div>
 <h1><a class="anchor" id="Surface_mesh_simplificationIntroduction"></a>
Introduction</h1>
<p>Surface mesh simplification is the process of reducing the number of faces used in a surface mesh while keeping the overall shape, volume and boundaries preserved as much as possible. It is the opposite of subdivision.</p>
<p>The algorithm presented here can simplify any <em>oriented 2-manifold surface</em>, with any number of connected components, with or without boundaries (border or holes) and handles (arbitrary genus), using a method known as <em>edge collapse</em>. Roughly speaking, the method consists of iteratively replacing an edge with a single vertex, removing 2 triangles per collapse.</p>
<p>Edges are collapsed according to a priority given by a user-supplied <em>cost</em> function, and the coordinates of the replacing vertex are determined by another user-supplied <em>placement</em> function. The algorithm terminates when a user-supplied <em>stop predicate</em> is met, such as reaching the desired number of edges.</p>
<p>The algorithm implemented here is generic in the sense that it does not require the surface mesh to be of a particular type but to be a model of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classHalfedgeListGraph.html">HalfedgeListGraph</a></code> concepts.</p>
<p>The design is <a href="http://en.wikipedia.org/wiki/Policy-based_design"><em>policy-based</em></a> (<a href="http://en.wikipedia.org/wiki/Policy-based_design"><code>http://en.wikipedia.org/wiki/Policy-based_design</code></a>), meaning that you can customize some aspects of the process by passing a set of <em>policy objects</em>. Each policy object specifies a particular aspect of the algorithm, such as how edges are selected and where the replacement vertex is placed. All policies have a sensible default. Furthermore, the API uses the so-called <code>named-parameters</code> technique which allows you to pass only the relevant parameters, in any order, omitting those parameters whose default is appropriate.</p>
<h1><a class="anchor" id="Surface_mesh_simplificationOverview"></a>
Overview of the Simplification Process</h1>
<p>The free function that implements the simplification algorithm takes not only the surface mesh and the desired stop predicate but a number of additional parameters which control and monitor the simplification process. This section briefly describes the process in order to set the background for the discussion of the parameters to the algorithm.</p>
<p>There are two slightly different "edge" collapse operations. One is known as <em>edge-collapse</em> while the other is known as <em>halfedge-collapse</em>. Given an edge <code>e</code> joining vertices <code>w</code> and <code>v</code>, the edge-collapse operation replaces <code>e</code>,<code>w</code> and <code>v</code> for a new vertex <code>r</code>, while the halfedge-collapse operation pulls <code>v</code> into <code>w</code>, eliminating <code>e</code> and leaving <code>w</code> in place. In both cases the operation removes the edge <code>e</code> along with the 2 triangles adjacent to it.</p>
<p>This package uses the halfedge-collapse operation, which is implemented by removing, additionally, 1 vertex (<code>v</code>) and 2 edges, one per adjacent triangle. It optionally moves the remaining vertex (<code>w</code>) into a new position, called <em>placement</em>, in which case the net effect is the same as in the edge-collapse operation.</p>
<p>Naturally, the surface mesh that results from an edge collapse deviates from the initial surface mesh by some amount, and since the goal of simplification is to reduce the number of triangles while retaining the overall look of the surface mesh as much as possible, it is necessary to measure such a deviation. Some methods attempt to measure the total deviation from the initial surface mesh to the completely simplified surface mesh, for example, by tracking an accumulated error while keeping a history of the simplification changes. Other methods, like the one implemented in this package, attempt to measure only the <em>cost</em> of each individual edge collapse (the local deviation introduced by a single simplification step) and plan the entire process as a sequence of steps of increasing cost.</p>
<p>Global error tracking methods produce highly accurate simplifications but take up a lot of additional space. Cost-driven methods, like the one in this package, produce slightly less accurate simplifications but take up much less additional space, even none in some cases.</p>
<p>The cost-driven method implemented in this package is mainly based on <a class="el" href="citelist.html#CITEREF_cgal:lt-fmeps-98">[4]</a>, <a class="el" href="citelist.html#CITEREF_cgal:lt-ems-99">[5]</a>, with contributions from <a class="el" href="citelist.html#CITEREF_hddms-mo-93">[3]</a>, <a class="el" href="citelist.html#CITEREF_gh-ssqem-97">[2]</a> and <a class="el" href="citelist.html#CITEREF_degn-tpec-98">[1]</a>.</p>
<p>The algorithm proceeds in two stages. In the first stage, called <em>collection stage</em>, an initial <em>collapse cost</em> is assigned to each and every edge in the surface mesh. Then in the second stage, called <em>collapsing stage</em>, edges are processed in order of increasing cost. Some processed edges are collapsed while some are just discarded. Collapsed edges are replaced by a vertex and the collapse cost of all the edges now incident on the replacement vertex is recalculated, affecting the order of the remaining unprocessed edges.</p>
<p>Not all edges selected for processing are collapsed. A processed edge can be discarded right away, without being collapsed, if it does not satisfy certain topological and geometric conditions.</p>
<p>The algorithm presented in <a class="el" href="citelist.html#CITEREF_gh-ssqem-97">[2]</a> contracts (collapses) arbitrary vertex pairs and not only edges by considering certain vertex pairs as forming a pseudo-edge and proceeding to collapse both edges and pseudo-edges in the same way as in <a class="el" href="citelist.html#CITEREF_cgal:lt-fmeps-98">[4]</a>, <a class="el" href="citelist.html#CITEREF_cgal:lt-ems-99">[5]</a> ( which is the algorithm implemented here). However, contracting an arbitrary vertex-pair may result in a non-manifold surface mesh, but the current state of this package can only deal with manifold surface meshes, thus, it can only collapse edges. That is, this package cannot be used as a framework for vertex contraction.</p>
<h1><a class="anchor" id="Surface_mesh_simplificationCost"></a>
Cost Strategy</h1>
<p>The specific way in which the collapse cost and vertex placement is calculated is called the <em>cost strategy</em>. The user can choose different strategies in the form of policies and related parameters, passed to the algorithm.</p>
<p>The current version of the package provides a set of policies implementing two strategies: the Lindstrom-Turk strategy, which is the default, and a strategy consisting of an edge-length cost with an optional midpoint placement (much faster but less accurate).</p>
<h2><a class="anchor" id="SurfaceMeshSimplificationLindstromTurkStrategy"></a>
Lindstrom-Turk Cost and Placement Strategy</h2>
<p>The main characteristic of the strategy presented in <a class="el" href="citelist.html#CITEREF_cgal:lt-fmeps-98">[4]</a>, <a class="el" href="citelist.html#CITEREF_cgal:lt-ems-99">[5]</a> is that the simplified surface mesh is not compared at each step with the original surface mesh (or the surface mesh at a previous step) so there is no need to keep extra information, such as the original surface mesh or a history of the local changes. Hence the name <em>memoryless</em> simplification.</p>
<p>At each step, all remaining edges are potential candidates for collapsing and the one with the lowest cost is selected.</p>
<p>The cost of collapsing an edge is given by the position chosen for the vertex that replaces it.</p>
<p>The replacement vertex position is computed as the solution to a system of 3 linearly-independent linear equality constraints. Each constraint is obtained by minimizing a quadratic objective function subject to the previously computed constraints.</p>
<p>There are several possible candidate constraints and each is considered in order of importance. A candidate constraint might be <em>incompatible</em> with the previously accepted constraints, in which case it is rejected and the next constraint is considered.</p>
<p>Once 3 constraints have been accepted, the system is solved for the vertex position.</p>
<p>The first constraints considered preserves the shape of the surface mesh boundaries (in case the edge profile has boundary edges). The next constraints preserve the total volume of the surface mesh. The next constraints, if needed, optimize the local changes in volume and boundary shape. Lastly, if a constraint is still needed (because the ones previously computed were incompatible), a third (and last) constraint is added to favor equilateral triangles over elongated triangles.</p>
<p>The cost is then a weighted sum of the shape, volume and boundary optimization terms, where the user specifies the unit <em>weighting unit factor</em> for each term.</p>
<p>The local changes are computed independently for each edge using only the triangles currently adjacent to it at the time when the edge is about to be collapsed, that is, after all previous collapses. Thus, the transitive path of minimal local changes yields at the end a global change reasonably close to the absolute minimum.</p>
<h2><a class="anchor" id="Surface_mesh_simplificationCostStrategyPolicies"></a>
Cost Strategy Policies</h2>
<p>The cost strategy used by the algorithm is selected by means of two policies: <code><a class="el" href="classGetPlacement.html" title="The concept GetPlacement describes the requirements for the policy function object which gets the col...">GetPlacement</a></code> and <code><a class="el" href="classGetCost.html" title="The concept GetCost describes the requirements for the policy function object which gets the collapse...">GetCost</a></code>.</p>
<p>The <code><a class="el" href="classGetPlacement.html" title="The concept GetPlacement describes the requirements for the policy function object which gets the col...">GetPlacement</a></code> policy is called to compute the new position for the remaining vertex after the halfedge-collapse. It returns an optional value, which can be absent, in which case the remaining vertex is kept in its place.</p>
<p>The <code><a class="el" href="classGetCost.html" title="The concept GetCost describes the requirements for the policy function object which gets the collapse...">GetCost</a></code> policy is called to compute the cost of collapsing an edge. This policy uses the placement to compute the cost (which is an error measure) and determines the ordering of the edges.</p>
<p>The algorithm maintains an internal data structure (a mutable priority queue) which allows each edge to be processed in increasing cost order. Such a data structure requires some per-edge additional information, such as the edge's cost. If the record of per-edge additional information occupies N bytes of storage, simplifying a surface mesh of 1 million edges (a normal size) requires 1 million times N bytes of additional storage. Thus, to minimize the amount of additional memory required to simplify a surface mesh only the cost is attached to each edge and nothing else.</p>
<p>But this is a trade-off: the cost of a collapse is a function of the placement (the new position chosen for the remaining vertex) so before <code><a class="el" href="classGetCost.html" title="The concept GetCost describes the requirements for the policy function object which gets the collapse...">GetCost</a></code> is called for each and every edge, <code><a class="el" href="classGetPlacement.html" title="The concept GetPlacement describes the requirements for the policy function object which gets the col...">GetPlacement</a></code> must also be called to obtain the placement parameter to the cost function. But that placement, which is a 3D Point, is not attached to each and every edge since that would easily <em>triple</em> the additional storage requirement.</p>
<p>On the one hand, this dramatically saves on memory but on the other hand is a processing waste because when an edge is effectively collapsed, <code><a class="el" href="classGetPlacement.html" title="The concept GetPlacement describes the requirements for the policy function object which gets the col...">GetPlacement</a></code> must be called <em>again</em> to know were to move the remaining vertex.</p>
<p>Earlier prototypes shown that attaching the placement to the edge, thus avoiding one redundant call to the placement function after the edge collapsed, has little impact on the total running time. This is because the cost of an each edge is not just computed once but changes several times during the process so the placement function must be called several times just as well. Caching the placement can only avoid the very last call, when the edge is collapsed, but not all the previous calls which are needed because the placement (and cost) changes.</p>
<h1><a class="anchor" id="Surface_mesh_simplificationAPI"></a>
API</h1>
<h2><a class="anchor" id="Surface_mesh_simplificationAPIOverview"></a>
API Overview</h2>
<p>Since the algorithm is free from robustness issues there is no need for exact predicates nor constructions and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">Simple_cartesian</a>&lt;double&gt;</code> can be used safely. <span class="footnote">In the current version, 3.3, the LindstromTurk policies are not implemented for homogeneous coordinates, so a Cartesian kernel must be used.</span></p>
<p>The simplification algorithm is implemented as the free template function <code><a class="el" href="group__PkgSurfaceMeshSimplification.html#ga5f51d0ea2897f3c22e870279cfb4bd41" title="Simplifies surface_mesh in-place by collapsing edges, and returns the number of edges effectively rem...">Surface_mesh_simplification::edge_collapse()</a></code>. The function has two mandatory and several optional parameters.</p>
<h2><a class="anchor" id="Surface_mesh_simplificationMandatoryParameters"></a>
Mandatory Parameters</h2>
<p>There are two main parameters to the algorithm: the surface mesh to be simplified (in-place) and the stop predicate.</p>
<p>The surface mesh to simplify must be a model of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classHalfedgeListGraph.html">HalfedgeListGraph</a></code> concepts.</p>
<p>The stop predicate is called after each edge is selected for processing, <em>before</em> it is classified as collapsible or not (thus before it is collapsed). If the stop predicate returns <code>true</code> the algorithm terminates.</p>
<h2><a class="anchor" id="Surface_mesh_simplificationOptionalNamed"></a>
Optional Named Parameters</h2>
<p>The notion of <em>named parameters</em> was also introduced in the <span class="textsc">Bgl</span>. You can read about it in <a class="el" href="citelist.html#CITEREF_cgal:sll-bgl-02">[6]</a> or the following site: <a href="http://www.boost.org/libs/graph/doc/bgl_named_params.html"><code>http://www.boost.org/libs/graph/doc/bgl_named_params.html</code></a>. Named parameters allow the user to specify only those parameters which are really needed, by name, making the parameter ordering unimportant.</p>
<p>Say there is a function <code>f()</code> that takes 3 parameters called <code>name</code>, <code>age</code> and <code>gender</code>, and you have variables <code>n,a and g</code> to pass as parameters to that function. Without named parameters, you would call it like this: <code>f(n,a,g)</code>, but with named parameters, you call it like this: <code>f(name(n).age(a).gender(g))</code>.</p>
<p>That is, you give each parameter a name by wrapping it into a function whose name matches that of the parameter. The entire list of named parameters is really a composition of function calls separated by a dot ( \( .\)). Thus, if the function takes a mix of mandatory and named parameters, you use a comma to separate the last non-named parameter from the first named parameters, like this:</p>
<p><code>f(non_named_par0, non_named_pa1, name(n).age(a).gender(g))</code></p>
<p>When you use named parameters, the ordering is irrelevant, so this: <code>f(name(n).age(a).gender(g))</code> is equivalent to this: <code>f(age(a).gender(g).name(n))</code>, and you can just omit any named parameter that has a default value.</p>
<h2><a class="anchor" id="Surface_mesh_simplificationSampleCall"></a>
Sample Call</h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">surface_mesh                  : the surface_mesh to simplify</span></div><div class="line"><span class="comment">stop_predicate                : policy indicating when the simplification must finish </span></div><div class="line"><span class="comment">vertex_index_map(vimap)       : property-map giving each vertex a unique integer index </span></div><div class="line"><span class="comment">edge_index_map(eimap)         : property-map giving each edge a unique integer index </span></div><div class="line"><span class="comment">edge_is_constrained_map(ebmap): property-map specifying whether an edge is a constrained edge or not </span></div><div class="line"><span class="comment">get_cost(cf)                  : function object computing the cost of a collapse </span></div><div class="line"><span class="comment">get_placement(pf)             : function object computing the placement for the remaining vertex </span></div><div class="line"><span class="comment">visitor(vis)                  : function object tracking the simplification process </span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> r = <a class="code" href="group__PkgSurfaceMeshSimplification.html#ga5f51d0ea2897f3c22e870279cfb4bd41">edge_collapse</a>(surface_mesh</div><div class="line">                     ,stop_predicate</div><div class="line">                     ,vertex_index_map(vimap)</div><div class="line">                       .edge_index_map(eimap)</div><div class="line">                       .edge_is_border_map(ebmap)</div><div class="line">                       .get_cost(cf)</div><div class="line">                       .get_placement(pf)</div><div class="line">                       .visitor(vis)</div><div class="line">                     );</div></div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_simplificationExamples"></a>
Examples</h2>
<h2><a class="anchor" id="Surface_mesh_simplificationExampleUsinga"></a>
Example Using a Default Polyhedron</h2>
<p>The following example illustrates the simplest of the cases. It uses an ordinary polyhedron and only one of the optional parameters. The unspecified cost strategy defaults to Lindstrom-Turk. <br />
<b>File</b> <a class="el" href="Surface_mesh_simplification_2edge_collapse_polyhedron_8cpp-example.html">Surface_mesh_simplification/edge_collapse_polyhedron.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Simplification function</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/edge_collapse.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Stop-condition policy</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Count_stop_predicate.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Edge_length_cost.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Midpoint_placement.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a> Surface_mesh; </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SMS = <a class="code" href="namespaceCGAL_1_1Surface__mesh__simplification.html">CGAL::Surface_mesh_simplification</a> ;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) </div><div class="line">{</div><div class="line">  Surface_mesh surface_mesh;</div><div class="line">  </div><div class="line">  std::ifstream is(argv[1]) ; is &gt;&gt; surface_mesh ;</div><div class="line">  <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(surface_mesh)){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Input geometry is not triangulated."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// This is a stop predicate (defines when the algorithm terminates).</span></div><div class="line">  <span class="comment">// In this example, the simplification stops when the number of undirected edges</span></div><div class="line">  <span class="comment">// left in the surface mesh drops below the specified number (1000)</span></div><div class="line">  SMS::Count_stop_predicate&lt;Surface_mesh&gt; stop(1000);</div><div class="line">     </div><div class="line">  <span class="comment">// This the actual call to the simplification algorithm.</span></div><div class="line">  <span class="comment">// The surface mesh and stop conditions are mandatory arguments.</span></div><div class="line">  <span class="comment">// The index maps are needed because the vertices and edges</span></div><div class="line">  <span class="comment">// of this surface mesh lack an "id()" field.</span></div><div class="line">  <span class="keywordtype">int</span> r = <a class="code" href="group__PkgSurfaceMeshSimplification.html#ga5f51d0ea2897f3c22e870279cfb4bd41">SMS::edge_collapse</a></div><div class="line">            (surface_mesh</div><div class="line">            ,stop</div><div class="line">             ,CGAL::parameters::vertex_index_map(<span class="keyword">get</span>(CGAL::vertex_external_index,surface_mesh)) </div><div class="line">                               .halfedge_index_map  (<span class="keyword">get</span>(CGAL::halfedge_external_index  ,surface_mesh)) </div><div class="line">                               .get_cost (SMS::Edge_length_cost &lt;Surface_mesh&gt;())</div><div class="line">                               .get_placement(SMS::Midpoint_placement&lt;Surface_mesh&gt;())</div><div class="line">            );</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nFinished...\n"</span> &lt;&lt; r &lt;&lt; <span class="stringliteral">" edges removed.\n"</span> </div><div class="line">            &lt;&lt; (surface_mesh.size_of_halfedges()/2) &lt;&lt; <span class="stringliteral">" final edges.\n"</span> ;</div><div class="line">        </div><div class="line">  std::ofstream os( argc &gt; 2 ? argv[2] : <span class="stringliteral">"out.off"</span> ) ; os &lt;&lt; surface_mesh ;</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS ;      </div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_simplificationExampleUsingan"></a>
Example Using an Enriched Polyhedron</h2>
<p>The following example is equivalent to the previous example but using an enriched polyhedron whose halfedges support an <code>id</code> field to store the edge index needed by the algorithm. It also shows how to explicitly specify a cost strategy (other than the default) and how to use a visitor object to track the simplification process.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_simplification_2edge_collapse_enriched_polyhedron_8cpp-example.html">Surface_mesh_simplification/edge_collapse_enriched_polyhedron.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Simplification function</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/edge_collapse.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Visitor base</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Edge_collapse_visitor_base.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Extended polyhedron items which include an id() field</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Stop-condition policy</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Count_ratio_stop_predicate.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Non-default cost and placement policies</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Midpoint_and_length.h&gt;</span> </div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point ;</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Setup an enriched polyhedron type which stores an id() field in the items</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel,CGAL::Polyhedron_items_with_id_3&gt;</a> Surface_mesh; </div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Surface_mesh::Halfedge_handle Halfedge_handle ;</div><div class="line"><span class="keyword">typedef</span> Surface_mesh::Vertex_handle   Vertex_handle ;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SMS = <a class="code" href="namespaceCGAL_1_1Surface__mesh__simplification.html">CGAL::Surface_mesh_simplification</a> ;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> SMS::Edge_profile&lt;Surface_mesh&gt; Profile ;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// The following is a Visitor that keeps track of the simplification process.</span></div><div class="line"><span class="comment">// In this example the progress is printed real-time and a few statistics are</span></div><div class="line"><span class="comment">// recorded (and printed in the end).</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">struct </span>Stats</div><div class="line">{</div><div class="line">  Stats() </div><div class="line">    : collected(0)</div><div class="line">    , processed(0)</div><div class="line">    , collapsed(0)</div><div class="line">    , non_collapsable(0)</div><div class="line">    , cost_uncomputable(0) </div><div class="line">    , placement_uncomputable(0) </div><div class="line">  {} </div><div class="line">  </div><div class="line">  std::size_t collected ;</div><div class="line">  std::size_t processed ;</div><div class="line">  std::size_t collapsed ;</div><div class="line">  std::size_t non_collapsable ;</div><div class="line">  std::size_t cost_uncomputable  ;</div><div class="line">  std::size_t placement_uncomputable ; </div><div class="line">} ;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>My_visitor : SMS::Edge_collapse_visitor_base&lt;Surface_mesh&gt;</div><div class="line">{</div><div class="line">  My_visitor( Stats* s) : stats(s){} </div><div class="line"></div><div class="line">  <span class="comment">// Called during the collecting phase for each edge collected.</span></div><div class="line">  <span class="keywordtype">void</span> OnCollected( Profile <span class="keyword">const</span>&amp;, boost::optional&lt;double&gt; <span class="keyword">const</span>&amp; )</div><div class="line">  {</div><div class="line">    ++ stats-&gt;collected ;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"\rEdges collected: "</span> &lt;&lt; stats-&gt;collected &lt;&lt; std::flush ;</div><div class="line">  }                </div><div class="line">  </div><div class="line">  <span class="comment">// Called during the processing phase for each edge selected.</span></div><div class="line">  <span class="comment">// If cost is absent the edge won't be collapsed.</span></div><div class="line">  <span class="keywordtype">void</span> OnSelected(Profile <span class="keyword">const</span>&amp;          </div><div class="line">                 ,boost::optional&lt;double&gt; cost</div><div class="line">                 ,std::size_t             initial</div><div class="line">                 ,std::size_t             current</div><div class="line">                 )</div><div class="line">  {</div><div class="line">    ++ stats-&gt;processed ;</div><div class="line">    <span class="keywordflow">if</span> ( !cost )</div><div class="line">      ++ stats-&gt;cost_uncomputable ;</div><div class="line">      </div><div class="line">    <span class="keywordflow">if</span> ( current == initial )</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; std::flush ;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"\r"</span> &lt;&lt; current &lt;&lt; std::flush ;</div><div class="line">  }                </div><div class="line">  </div><div class="line">  <span class="comment">// Called during the processing phase for each edge being collapsed.</span></div><div class="line">  <span class="comment">// If placement is absent the edge is left uncollapsed.</span></div><div class="line">  <span class="keywordtype">void</span> OnCollapsing(Profile <span class="keyword">const</span>&amp;          </div><div class="line">                   ,boost::optional&lt;Point&gt;  placement</div><div class="line">                   )</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> ( !placement )</div><div class="line">      ++ stats-&gt;placement_uncomputable ;</div><div class="line">  }                </div><div class="line">  </div><div class="line">  <span class="comment">// Called for each edge which failed the so called link-condition,</span></div><div class="line">  <span class="comment">// that is, which cannot be collapsed because doing so would</span></div><div class="line">  <span class="comment">// turn the surface mesh into a non-manifold.</span></div><div class="line">  <span class="keywordtype">void</span> OnNonCollapsable( Profile <span class="keyword">const</span>&amp; )</div><div class="line">  {</div><div class="line">    ++ stats-&gt;non_collapsable;</div><div class="line">  }                </div><div class="line">  </div><div class="line">  <span class="comment">// Called AFTER each edge has been collapsed</span></div><div class="line">  <span class="keywordtype">void</span> OnCollapsed( Profile <span class="keyword">const</span>&amp;, Vertex_handle )</div><div class="line">  {</div><div class="line">    ++ stats-&gt;collapsed;</div><div class="line">  }                </div><div class="line">  </div><div class="line">  Stats* stats ;</div><div class="line">} ;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) </div><div class="line">{</div><div class="line">  Surface_mesh surface_mesh; </div><div class="line">  </div><div class="line">  std::ifstream is(argv[1]) ; is &gt;&gt; surface_mesh ;</div><div class="line">  <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(surface_mesh)){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Input geometry is not triangulated."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// The items in this polyhedron have an "id()" field </span></div><div class="line">  <span class="comment">// which the default index maps used in the algorithm</span></div><div class="line">  <span class="comment">// need to get the index of a vertex/edge.</span></div><div class="line">  <span class="comment">// However, the Polyhedron_3 class doesn't assign any value to</span></div><div class="line">  <span class="comment">// this id(), so we must do it here:</span></div><div class="line">  <span class="keywordtype">int</span> index = 0 ;</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span>( Surface_mesh::Halfedge_iterator eb = surface_mesh.halfedges_begin()</div><div class="line">     , ee = surface_mesh.halfedges_end()</div><div class="line">     ; eb != ee</div><div class="line">     ; ++ eb</div><div class="line">     ) </div><div class="line">    eb-&gt;id() = index++;</div><div class="line"></div><div class="line">  index = 0 ;</div><div class="line">  <span class="keywordflow">for</span>( Surface_mesh::Vertex_iterator vb = surface_mesh.vertices_begin()</div><div class="line">     , ve = surface_mesh.vertices_end()</div><div class="line">     ; vb != ve</div><div class="line">     ; ++ vb</div><div class="line">     ) </div><div class="line">    vb-&gt;id() = index++;</div><div class="line">    </div><div class="line">  <span class="comment">// In this example, the simplification stops when the number of undirected edges</span></div><div class="line">  <span class="comment">// drops below 10% of the initial count</span></div><div class="line">  SMS::Count_ratio_stop_predicate&lt;Surface_mesh&gt; stop(0.1);</div><div class="line"> </div><div class="line">  Stats stats ;</div><div class="line">  </div><div class="line">  My_visitor vis(&amp;stats) ;</div><div class="line">    </div><div class="line">  <span class="comment">// The index maps are not explicitelty passed as in the previous</span></div><div class="line">  <span class="comment">// example because the surface mesh items have a proper id() field.</span></div><div class="line">  <span class="comment">// On the other hand, we pass here explicit cost and placement</span></div><div class="line">  <span class="comment">// function which differ from the default policies, ommited in</span></div><div class="line">  <span class="comment">// the previous example.</span></div><div class="line">  <span class="keywordtype">int</span> r = <a class="code" href="group__PkgSurfaceMeshSimplification.html#ga5f51d0ea2897f3c22e870279cfb4bd41">SMS::edge_collapse</a></div><div class="line">           (surface_mesh</div><div class="line">           ,stop</div><div class="line">            ,CGAL::parameters::get_cost     (SMS::Edge_length_cost  &lt;Surface_mesh&gt;())</div><div class="line">                              .get_placement(SMS::Midpoint_placement&lt;Surface_mesh&gt;())</div><div class="line">                              .visitor      (vis)</div><div class="line">           );</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nEdges collected: "</span>  &lt;&lt; stats.collected</div><div class="line">            &lt;&lt; <span class="stringliteral">"\nEdges proccessed: "</span> &lt;&lt; stats.processed</div><div class="line">            &lt;&lt; <span class="stringliteral">"\nEdges collapsed: "</span>  &lt;&lt; stats.collapsed</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"\nEdges not collapsed due to topological constraints: "</span>  &lt;&lt; stats.non_collapsable</div><div class="line">            &lt;&lt; <span class="stringliteral">"\nEdge not collapsed due to cost computation constraints: "</span>  &lt;&lt; stats.cost_uncomputable </div><div class="line">            &lt;&lt; <span class="stringliteral">"\nEdge not collapsed due to placement computation constraints: "</span> &lt;&lt; stats.placement_uncomputable </div><div class="line">            &lt;&lt; std::endl ; </div><div class="line">            </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nFinished...\n"</span> &lt;&lt; r &lt;&lt; <span class="stringliteral">" edges removed.\n"</span> </div><div class="line">            &lt;&lt; (surface_mesh.size_of_halfedges()/2) &lt;&lt; <span class="stringliteral">" final edges.\n"</span> ;</div><div class="line">        </div><div class="line">  std::ofstream os( argc &gt; 2 ? argv[2] : <span class="stringliteral">"out.off"</span> ) ; os &lt;&lt; surface_mesh ;</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS ;      </div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_simplificationExampleOpenMesh"></a>
Example for Simplification of OpenMesh</h2>
<p>The following example shows how the mesh simplification package can be applied on a mesh data structure which is not part of <span style="font-variant: small-caps;">CGAL</span>, but a model of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceGraph.html">FaceGraph</a></code>.</p>
<p>What is particular in this example is the property map that allows to associate 3D <span style="font-variant: small-caps;">CGAL</span> points to the vertices.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_simplification_2edge_collapse_OpenMesh_8cpp-example.html">Surface_mesh_simplification/edge_collapse_OpenMesh.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/PolyMesh_ArrayKernelT.hh&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_PolyMesh_ArrayKernelT.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Simplification function</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/edge_collapse.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Count_stop_predicate.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Edge_length_cost.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Midpoint_placement.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> OpenMesh::PolyMesh_ArrayKernelT&lt;<span class="comment">/* MyTraits*/</span>&gt; Surface_mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::edge_descriptor edge_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::edge_iterator edge_iterator;</div><div class="line"></div><div class="line"><span class="keyword">class </span>Constrained_edge_map</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> boost::read_write_property_map_tag    category;</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">bool</span>                                  value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">bool</span>                                  reference;</div><div class="line">  <span class="keyword">typedef</span> edge_descriptor                       key_type;</div><div class="line"></div><div class="line">  Constrained_edge_map(Surface_mesh&amp; sm)</div><div class="line">    : sm_(sm)</div><div class="line">  {</div><div class="line">    sm_.add_property(constraint);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">inline</span> <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> Constrained_edge_map&amp; em, key_type e)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">bool</span> b = em.sm_.property(em.constraint,em.sm_.edge_handle(e.idx())); </div><div class="line">    <span class="keywordflow">return</span> b;</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">void</span> put(<span class="keyword">const</span> Constrained_edge_map&amp; em, key_type e, value_type b)</div><div class="line">  {</div><div class="line">    em.sm_.property(em.constraint,em.sm_.edge_handle(e.idx())) = b;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Surface_mesh&amp; sm_;</div><div class="line">  OpenMesh::EPropHandleT&lt;bool&gt; constraint;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SMS = <a class="code" href="namespaceCGAL_1_1Surface__mesh__simplification.html">CGAL::Surface_mesh_simplification</a> ;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) </div><div class="line">{</div><div class="line">  Surface_mesh surface_mesh;</div><div class="line">  Constrained_edge_map constraints_map(surface_mesh);</div><div class="line">  <span class="keywordflow">if</span> (argc==2)</div><div class="line">    OpenMesh::IO::read_mesh(surface_mesh, argv[1]);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    OpenMesh::IO::read_mesh(surface_mesh, <span class="stringliteral">"cube.off"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(surface_mesh)){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Input geometry is not triangulated."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// For the pupose of the example we mark 10 edges as constrained edges</span></div><div class="line">  edge_iterator b,e;</div><div class="line">  <span class="keywordtype">int</span> count=0;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(b,e) = edges(surface_mesh); b!= e; ++b){</div><div class="line">      put(constraints_map,*b,(count++ &lt;100));</div><div class="line">  }</div><div class="line">  <span class="comment">// This is a stop predicate (defines when the algorithm terminates).</span></div><div class="line">  <span class="comment">// In this example, the simplification stops when the number of undirected edges</span></div><div class="line">  <span class="comment">// left in the surface mesh drops below the specified number (1000)</span></div><div class="line">  SMS::Count_stop_predicate&lt;Surface_mesh&gt; stop(0);</div><div class="line">     </div><div class="line">  <span class="comment">// This the actual call to the simplification algorithm.</span></div><div class="line">  <span class="comment">// The surface mesh and stop conditions are mandatory arguments.</span></div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> r = <a class="code" href="group__PkgSurfaceMeshSimplification.html#ga5f51d0ea2897f3c22e870279cfb4bd41">SMS::edge_collapse</a></div><div class="line">            (surface_mesh</div><div class="line">            ,stop</div><div class="line">             ,CGAL::parameters::halfedge_index_map  (<span class="keyword">get</span>(CGAL::halfedge_index  ,surface_mesh)) </div><div class="line">                               .vertex_point_map(<span class="keyword">get</span>(boost::vertex_point, surface_mesh))</div><div class="line">                               .edge_is_constrained_map(constraints_map) </div><div class="line">             );</div><div class="line">  </div><div class="line">  surface_mesh.garbage_collection();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nFinished...\n"</span> &lt;&lt; r &lt;&lt; <span class="stringliteral">" edges removed.\n"</span> </div><div class="line">            &lt;&lt; num_edges(surface_mesh) &lt;&lt; <span class="stringliteral">" final edges.\n"</span> ;</div><div class="line">        </div><div class="line">   OpenMesh::IO::write_mesh(surface_mesh, <span class="stringliteral">"out.off"</span>);</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_simplificationExamplewithedges"></a>
Example with Edges Marked as Non-Removable</h2>
<p>The following example shows how to use the optional named parameter <code>edge_is_constrained_map</code> to prevent edges from being removed. Edges marked as constrained are guaranteed to be in the final surface mesh. However, the vertices of the constrained edges may change and the placement may change the points. The wrapper <code><a class="el" href="classCGAL_1_1Surface__mesh__simplification_1_1Constrained__placement.html" title="The class Constrained_placement is a model for the GetPlacement concept provided the template paramet...">CGAL::Surface_mesh_simplification::Constrained_placement</a></code> guarantees that these points are not changed.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_simplification_2edge_collapse_constrained_border_polyhedron_8cpp-example.html">Surface_mesh_simplification/edge_collapse_constrained_border_polyhedron.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Simplification function</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/edge_collapse.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Midpoint placement policy</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Midpoint_placement.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//Placement wrapper</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Constrained_placement.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Stop-condition policy</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Count_stop_predicate.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a> Surface_mesh;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SMS = <a class="code" href="namespaceCGAL_1_1Surface__mesh__simplification.html">CGAL::Surface_mesh_simplification</a> ;</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// BGL property map which indicates whether an edge is marked as non-removable</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">struct </span>Border_is_constrained_edge_map{</div><div class="line">  <span class="keyword">const</span> Surface_mesh* sm_ptr;</div><div class="line">  <span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::edge_descriptor key_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">bool</span> value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type reference;</div><div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag category;</div><div class="line"></div><div class="line">  Border_is_constrained_edge_map(<span class="keyword">const</span> Surface_mesh&amp; sm)</div><div class="line">    : sm_ptr(&amp;sm)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">friend</span> <span class="keywordtype">bool</span> <span class="keyword">get</span>(Border_is_constrained_edge_map m, <span class="keyword">const</span> key_type&amp; edge) {</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">CGAL::is_border</a>(edge, *m.sm_ptr);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Placement class</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">typedef</span> SMS::Constrained_placement&lt;SMS::Midpoint_placement&lt;Surface_mesh&gt;,</div><div class="line">                                   Border_is_constrained_edge_map &gt; Placement;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div><div class="line">{</div><div class="line">  Surface_mesh surface_mesh;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc!=2){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" input.off\n"</span>;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ifstream is(argv[1]);</div><div class="line">  <span class="keywordflow">if</span>(!is){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Filename provided is invalid\n"</span>;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  is &gt;&gt; surface_mesh  ;</div><div class="line">  <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(surface_mesh)){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Input geometry is not triangulated."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// map used to check that constrained_edges and the points of its vertices</span></div><div class="line">  <span class="comment">// are preserved at the end of the simplification</span></div><div class="line">  std::map&lt;Surface_mesh::Halfedge_handle,std::pair&lt;Point_3, Point_3&gt; &gt;constrained_edges;</div><div class="line">  std::size_t nb_border_edges=0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Surface_mesh::Halfedge_iterator hit=surface_mesh.halfedges_begin(),</div><div class="line">                                       hit_end=surface_mesh.halfedges_end();</div><div class="line">                                       hit!=hit_end; ++hit )</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> ( hit-&gt;is_border() ){</div><div class="line">      constrained_edges[hit]=std::make_pair( hit-&gt;opposite()-&gt;vertex()-&gt;point(),</div><div class="line">                                             hit-&gt;vertex()-&gt;point() );</div><div class="line">      ++nb_border_edges;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Contract the surface mesh as much as possible</span></div><div class="line">  SMS::Count_stop_predicate&lt;Surface_mesh&gt; stop(0);</div><div class="line"></div><div class="line">  Border_is_constrained_edge_map bem(surface_mesh);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// This the actual call to the simplification algorithm.</span></div><div class="line">  <span class="comment">// The surface mesh and stop conditions are mandatory arguments.</span></div><div class="line">  <span class="comment">// The index maps are needed because the vertices and edges</span></div><div class="line">  <span class="comment">// of this surface mesh lack an "id()" field.</span></div><div class="line">  <span class="keywordtype">int</span> r = <a class="code" href="group__PkgSurfaceMeshSimplification.html#ga5f51d0ea2897f3c22e870279cfb4bd41">SMS::edge_collapse</a></div><div class="line">            (surface_mesh</div><div class="line">            ,stop</div><div class="line">             ,CGAL::parameters::vertex_index_map(<span class="keyword">get</span>(CGAL::vertex_external_index,surface_mesh))</div><div class="line">                               .halfedge_index_map  (<span class="keyword">get</span>(CGAL::halfedge_external_index  ,surface_mesh))</div><div class="line">                               .edge_is_constrained_map(bem)</div><div class="line">                               .get_placement(Placement(bem))</div><div class="line">            );</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nFinished...\n"</span> &lt;&lt; r &lt;&lt; <span class="stringliteral">" edges removed.\n"</span></div><div class="line">            &lt;&lt; (surface_mesh.size_of_halfedges()/2) &lt;&lt; <span class="stringliteral">" final edges.\n"</span> ;</div><div class="line"></div><div class="line">  std::ofstream os( argc &gt; 2 ? argv[2] : <span class="stringliteral">"out.off"</span> ) ; os &lt;&lt; surface_mesh ;</div><div class="line"></div><div class="line">  <span class="comment">// now check!</span></div><div class="line">  <span class="keywordflow">for</span> (Surface_mesh::Halfedge_iterator hit=surface_mesh.halfedges_begin(),</div><div class="line">                                       hit_end=surface_mesh.halfedges_end();</div><div class="line">                                       hit!=hit_end; ++hit )</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (hit-&gt;is_border()){</div><div class="line">      --nb_border_edges;</div><div class="line">      assert( constrained_edges[hit] ==</div><div class="line">              std::make_pair( hit-&gt;opposite()-&gt;vertex()-&gt;point(),</div><div class="line">                              hit-&gt;vertex()-&gt;point() ) );</div><div class="line">    }</div><div class="line">  }</div><div class="line">  assert( nb_border_edges==0 );</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS ;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_simplificationExamplewithBoundedNormal"></a>
Example with Bounded Change of Face Normals</h2>
<p>The surface mesh simplification does not guarantee that the resulting surface has no self intersections. Even the rather trivial mesh shown in <a class="el" href="index.html#fig__SMS-selfintersection">Figure 64.1</a> results in a self intersection when one edge is collapsed using the Lindstrom-Turk method.</p>
<p><a class="anchor" id="fig__SMS-selfintersection"></a></p><div class="image">
<img src="SMS-selfintersection.png" alt="SMS-selfintersection.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__SMS-selfintersection">Figure 64.1</a> Simple mesh before and after the collapse of edge <code>v-w</code> into vertex <code>w</code>. While the normals of <code>f1</code> and <code>f2</code> are almost equal, they are opposed after the edge collapse.  </div>  <br />

<p>The class <code><a class="el" href="classCGAL_1_1Surface__mesh__simplification_1_1Bounded__normal__change__placement.html" title="The class Bounded_normal_change_placement is a model for the GetPlacement concept which serves as a f...">Surface_mesh_simplification::Bounded_normal_change_placement</a></code> is a placement that checks if another placement would invert the normal of a face around the stars of the two vertices of an edge that is candidate for an edge collapse. It then rejects this placement by returning <code>boost::none</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_simplification_2edge_collapse_bounded_normal_change_8cpp-example.html">Surface_mesh_simplification/edge_collapse_bounded_normal_change.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Simplification function</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/edge_collapse.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Stop-condition policy</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Count_stop_predicate.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/LindstromTurk_cost.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/LindstromTurk_placement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Bounded_normal_change_placement.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a> Surface_mesh; </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>SMS = <a class="code" href="namespaceCGAL_1_1Surface__mesh__simplification.html">CGAL::Surface_mesh_simplification</a> ;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) </div><div class="line">{</div><div class="line">  Surface_mesh surface_mesh;</div><div class="line"></div><div class="line">  std::ifstream is(argc &gt; 1 ? argv[1] : <span class="stringliteral">"data/fold.off"</span>) ; is &gt;&gt; surface_mesh ;</div><div class="line"></div><div class="line">  <span class="comment">// This is a stop predicate (defines when the algorithm terminates).</span></div><div class="line">  <span class="comment">// In this example, the simplification stops when the number of undirected edges</span></div><div class="line">  <span class="comment">// left in the surface mesh drops below the specified number (1000)</span></div><div class="line">  SMS::Count_stop_predicate&lt;Surface_mesh&gt; stop(num_halfedges(surface_mesh)/2 - 1);</div><div class="line">     </div><div class="line"><span class="keyword">typedef</span> SMS::Bounded_normal_change_placement&lt;SMS::LindstromTurk_placement&lt;Surface_mesh&gt; &gt; Placement;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// This the actual call to the simplification algorithm.</span></div><div class="line">  <span class="comment">// The surface mesh and stop conditions are mandatory arguments.</span></div><div class="line">  <span class="comment">// The index maps are needed because the vertices and edges</span></div><div class="line">  <span class="comment">// of this surface mesh lack an "id()" field.</span></div><div class="line">  <a class="code" href="group__PkgSurfaceMeshSimplification.html#ga5f51d0ea2897f3c22e870279cfb4bd41">SMS::edge_collapse</a>( surface_mesh,</div><div class="line">                      stop,</div><div class="line">                      CGAL::parameters::vertex_index_map(<span class="keyword">get</span>(CGAL::vertex_external_index,surface_mesh))</div><div class="line">                        .halfedge_index_map  (<span class="keyword">get</span>(CGAL::halfedge_external_index  ,surface_mesh))</div><div class="line">                        .get_cost (SMS::LindstromTurk_cost&lt;Surface_mesh&gt;())</div><div class="line">                        .get_placement(Placement())</div><div class="line">                      );</div><div class="line"></div><div class="line">  std::ofstream os( argc &gt; 2 ? argv[2] : <span class="stringliteral">"out.off"</span> ) ; os &lt;&lt; surface_mesh ;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0 ;      </div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:06 for CGAL 4.13 - Triangulated Surface Mesh Simplification by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
