<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Surface_mesh/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Surface Mesh: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Surface Mesh
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_3D_Surface_mesh"></a><a class="anchor" id="chapterSurface_mesh"></a> </p><dl class="section author"><dt>Author</dt><dd>Mario Botsch, Daniel Sieger, Philipp Moeller and Andreas Fabri  <div id="autotoc" class="toc"></div> </dd></dl>
<div class="image">
<img src="clown_fish.jpg" alt="clown_fish.jpg" />
</div>
<p>The class <code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> is an implementation of a halfedge data structure and can be used to represent a polyhedral surface. It is an alternative to the <span style="font-variant: small-caps;">CGAL</span> packages <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgHDSSummary">Halfedge Data Structures</a> and <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPolyhedronSummary">3D Polyhedral Surface</a>. The main difference is that it is indexed based and not pointer based. Additionally, the mechanism for adding information to vertices, halfedges, edges, and faces is much simpler and is done at runtime and not at compile time.</p>
<p>Because the data structure uses integer indices as descriptors for vertices, halfedges, edges and faces it has a lower memory footprint than a 64-bit pointer based version. As the indices are contiguous, they can be used as index into vectors which store properties.</p>
<p>When elements are removed, they are only marked as removed, and a garbage collection function must be called to really remove them.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> can be used through its class member functions as well as through the BGL API as described in the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBGLSummary">CGAL and the Boost Graph Library</a>, as it is a model of the concepts <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code>. Therefore it is possible to apply the algorithms of the packages <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplificationSummary">Triangulated Surface Mesh Simplification</a>, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceSegmentationSummary">Triangulated Surface Mesh Segmentation</a>, and <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshDeformationSummary">Triangulated Surface Mesh Deformation</a> on a surface mesh.</p>
<h1><a class="anchor" id="sectionSurfaceMeshUsage"></a>
Usage</h1>
<p>The main class <code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> provides four nested classes that represent the basic elements of the halfedge data structure:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Surface__mesh_1_1Vertex__index.html" title="This class represents a vertex. ">Surface_mesh::Vertex_index</a></code></li>
<li><code><a class="el" href="classCGAL_1_1Surface__mesh_1_1Halfedge__index.html" title="This class represents a halfedge. ">Surface_mesh::Halfedge_index</a></code></li>
<li><code><a class="el" href="classCGAL_1_1Surface__mesh_1_1Face__index.html" title="This class represents a face. ">Surface_mesh::Face_index</a></code></li>
<li><code><a class="el" href="classCGAL_1_1Surface__mesh_1_1Edge__index.html" title="This class represents an edge. ">Surface_mesh::Edge_index</a></code></li>
</ul>
<p>These types are just wrappers for an integer and their main purpose is to guarantee type safety. They are default constructible, which yields an <em>invalid</em> element. New elements can be added and removed to the <code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> through a set of low-level functions which do not maintain connectivity. One exception is <code><a class="el" href="classCGAL_1_1Surface__mesh.html#a3bbb4fcc69d61f1bd816a255b2251f74" title="adds a new face, and resizes face properties if necessary. ">Surface_mesh::add_face()</a></code>, which tries to add a new face to the mesh (defined by a sequence of vertices), and fails if the operation is not topologically valid.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> Surface_mesh&lt;Point&gt; Mesh;</div><div class="line">Mesh m;</div><div class="line">Mesh::Vertex_index u = m.add_vertex(Point(0,1,0));</div><div class="line">Mesh::Vertex_index v = m.add_vertex(Point(0,0,0));</div><div class="line">Mesh::Vertex_index w = m.add_vertex(Point(1,0,0));</div><div class="line">m.add_face(u, v, w);</div></div><!-- fragment --><p>As <code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> is index-based <a class="el" href="classCGAL_1_1Surface__mesh_1_1Vertex__index.html">Vertex_index</a>, <a class="el" href="classCGAL_1_1Surface__mesh_1_1Halfedge__index.html">Halfedge_index</a>, <a class="el" href="classCGAL_1_1Surface__mesh_1_1Edge__index.html">Edge_index</a>, and <a class="el" href="classCGAL_1_1Surface__mesh_1_1Face__index.html">Face_index</a> do not have member functions to access connectivity or properties. The functions of the <code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> instance from which they were created must be used to obtain this information.</p>
<h1><a class="anchor" id="sectionSurfaceMeshConnectivity"></a>
Connectivity</h1>
<p>A surface mesh is an edge-centered data structure capable of maintaining incidence information of vertices, edges, and faces. Each edge is represented by two halfedges with opposite orientation. Each halfedge stores a reference to an incident face and to an incident vertex. Additionally, it stores a reference to the next and previous halfedge incident to its incident face. For each face and each vertex an incident halfedge is stored. Halfedges do not store the index of the opposite halfedge, as <code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> stores opposite halfedges consecutively in memory.</p>
<p>The following figure illustrates the functions which allow to navigate in a surface mesh: <code><a class="el" href="classCGAL_1_1Surface__mesh.html#aa7db4bc6d4c063059072b2f1a4609c0e" title="returns the opposite halfedge of h. Note that there is no function set_opposite(). ">Surface_mesh::opposite()</a></code>, <code><a class="el" href="classCGAL_1_1Surface__mesh.html#aa1cc5db58c2a463d6e7dff79c8f01eda" title="returns the next halfedge within the incident face. ">Surface_mesh::next()</a></code>, <code><a class="el" href="classCGAL_1_1Surface__mesh.html#a59417a612605ec242f066bd9a1e28185" title="returns the previous halfedge within the incident face. ">Surface_mesh::prev()</a></code>, <code><a class="el" href="classCGAL_1_1Surface__mesh.html#a1039dd1e0b038b526ddebe477e67f531" title="returns the vertex the halfedge h points to. ">Surface_mesh::target()</a></code>, and <code><a class="el" href="classCGAL_1_1Surface__mesh.html#a33419ae03fc4d9a8c28367dbe1241a21" title="returns the face incident to halfedge h. ">Surface_mesh::face()</a></code>. Additionally, the functions <code><a class="el" href="classCGAL_1_1Surface__mesh.html#aabd478481f32d6539ac3e1db5ee65e36" title="returns an incoming halfedge of vertex v. If v is a border vertex this will be a border halfedge...">Surface_mesh::halfedge()</a></code> allows to obtain the halfedge associated to a vertex and to a face. Alternatively, one may use the free functions with the same names defined in the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBGLSummary">CGAL and the Boost Graph Library</a>.</p>
<p><a class="anchor" id="fig__FigSurfaceMeshConnectivity"></a></p><div class="image">
<object type="image/svg+xml" data="connectivity.svg">connectivity.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__FigSurfaceMeshConnectivity">Figure 27.1</a> Connectivity of halfedges and vertices in a surface mesh seen from outside.  </div>  <br />

<p><a class="anchor" id="SurfaceMeshOrientation"></a>The halfedges incident to a face form a cycle. Depending on from which side we look at the surface, the sequence of halfedges appears to be oriented <em>clockwise</em> or <em>counterclockwise</em>. When in this manual we speak about the orientation of a traversal then we look at the surface such that the halfedges around a face are oriented counterclockwise, as illustrated in <a class="el" href="index.html#fig__FigSurfaceMeshConnectivity">Figure 27.1</a></p>
<p>The connectivity does not allow to represent faces with holes.</p>
<h1><a class="anchor" id="sectionSurfaceMesh_iterators"></a>
Ranges and Iterators</h1>
<p><code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> provides iterator ranges to enumerate all vertices, halfedges, edges, and faces. It provides member functions returning ranges of elements which are compatible with the <a href="https://www.boost.org/libs/range/doc/html/index.html">Boost.Range</a> library.</p>
<h2><a class="anchor" id="iterators_example"></a>
Example</h2>
<p>The following example shows how to obtain the iterator type from a range, alternatives for obtaining the begin and end iterator, and alternatives for range-based loops.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_2sm_iterators_8cpp-example.html">Surface_mesh/sm_iterators.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a> Mesh;</div><div class="line"><span class="keyword">typedef</span> Mesh::Vertex_index vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> Mesh::Face_index face_descriptor;</div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Mesh m;</div><div class="line"></div><div class="line">  <span class="comment">// u            x</span></div><div class="line">  <span class="comment">// +------------+</span></div><div class="line">  <span class="comment">// |            |</span></div><div class="line">  <span class="comment">// |            |</span></div><div class="line">  <span class="comment">// |      f     |</span></div><div class="line">  <span class="comment">// |            |</span></div><div class="line">  <span class="comment">// |            |</span></div><div class="line">  <span class="comment">// +------------+</span></div><div class="line">  <span class="comment">// v            w</span></div><div class="line"></div><div class="line">  <span class="comment">// Add the points as vertices</span></div><div class="line">  vertex_descriptor u = m.<a class="code" href="classCGAL_1_1Surface__mesh.html#a6f899386b0667edc64cfae79cc93386e">add_vertex</a>(K::Point_3(0,1,0));</div><div class="line">  vertex_descriptor v = m.add_vertex(K::Point_3(0,0,0));</div><div class="line">  vertex_descriptor w = m.add_vertex(K::Point_3(1,0,0));</div><div class="line">  vertex_descriptor x = m.add_vertex(K::Point_3(1,1,0));</div><div class="line"></div><div class="line">  <span class="comment">/* face_descriptor f = */</span> m.add_face(u,v,w,x);</div><div class="line"></div><div class="line">  { </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"all vertices "</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// The vertex iterator type is a nested type of the Vertex_range</span></div><div class="line">    Mesh::Vertex_range::iterator  vb, ve;</div><div class="line"></div><div class="line">    Mesh::Vertex_range r = m.vertices();</div><div class="line">    <span class="comment">// The iterators can be accessed through the C++ range API</span></div><div class="line">    vb = r.begin(); </div><div class="line">    ve = r.end();</div><div class="line">    <span class="comment">// or the boost Range API</span></div><div class="line">    vb = boost::begin(r);</div><div class="line">    ve = boost::end(r);</div><div class="line"></div><div class="line">    <span class="comment">// or with boost::tie, as the CGAL range derives from std::pair</span></div><div class="line">    <span class="keywordflow">for</span>(boost::tie(vb, ve) = m.vertices(); vb != ve; ++vb){</div><div class="line">            std::cout &lt;&lt; *vb &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// Instead of the classical for loop one can use</span></div><div class="line">    <span class="comment">// the boost macro for a range</span></div><div class="line">    BOOST_FOREACH(vertex_descriptor vd, m.vertices()){</div><div class="line">      std::cout &lt;&lt; vd &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// or the C++11 for loop. Note that there is a ':' and not a ',' as in BOOST_FOREACH </span></div><div class="line"><span class="preprocessor">    #ifndef CGAL_CFG_NO_CPP0X_RANGE_BASED_FOR</span></div><div class="line">    <span class="keywordflow">for</span>(vertex_descriptor vd : m.vertices()){</div><div class="line">      std::cout &lt;&lt; vd &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line">    </div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="sectionSurfaceMesh_circulators"></a>
Circulators</h1>
<p>Circulators around faces and around vertices are provided as class templates in the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBGLSummary">CGAL and the Boost Graph Library</a>.</p>
<p>Circulators around faces basically call <code><a class="el" href="classCGAL_1_1Surface__mesh.html#aa1cc5db58c2a463d6e7dff79c8f01eda" title="returns the next halfedge within the incident face. ">Surface_mesh::next()</a></code> in order to go from halfedge to halfedge counterclockwise around the face, and when dereferenced return the halfedge or the incident vertex or the opposite face.</p>
<ul>
<li><code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Halfedge__around__face__circulator.html">CGAL::Halfedge_around_face_circulator</a>&lt;Mesh&gt;</code></li>
<li><code>CGAL::Vertex_around_face_circulator&lt;Mesh&gt;</code></li>
<li><code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Face__around__face__circulator.html">CGAL::Face_around_face_circulator</a>&lt;Mesh&gt;</code></li>
</ul>
<p>Circulators around the target vertex of an edge basically call <code>Surface_mesh::opposite(Surface_mesh::next())</code> in order to go from halfedge to halfedge clockwise around the same target vertex.</p>
<ul>
<li><code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Halfedge__around__target__circulator.html">CGAL::Halfedge_around_target_circulator</a>&lt;Mesh&gt;</code></li>
<li><code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Vertex__around__target__circulator.html">CGAL::Vertex_around_target_circulator</a>&lt;Mesh&gt;</code></li>
<li><code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Face__around__target__circulator.html">CGAL::Face_around_target_circulator</a>&lt;Mesh&gt;</code></li>
</ul>
<p>All circulators model <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/classBidirectionalCirculator.html">BidirectionalCirculator</a></code>. In addition to that they also support a conversion to <code>bool</code> for more convenient checking of emptiness.</p>
<h2><a class="anchor" id="circulators_example"></a>
Example</h2>
<p>The following example shows how to enumerate the vertices around the target of a given halfedge. The second loop shows that each of these circulator types comes with an equivalent iterator and a free function to create an iterator range.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_2sm_circulators_8cpp-example.html">Surface_mesh/sm_circulators.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a> Mesh;</div><div class="line"><span class="keyword">typedef</span> Mesh::Vertex_index vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> Mesh::Face_index face_descriptor;</div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Mesh m;</div><div class="line"></div><div class="line">  <span class="comment">// u            x</span></div><div class="line">  <span class="comment">// +------------+</span></div><div class="line">  <span class="comment">// |            |</span></div><div class="line">  <span class="comment">// |            |</span></div><div class="line">  <span class="comment">// |      f     |</span></div><div class="line">  <span class="comment">// |            |</span></div><div class="line">  <span class="comment">// |            |</span></div><div class="line">  <span class="comment">// +------------+</span></div><div class="line">  <span class="comment">// v            w</span></div><div class="line"></div><div class="line">  <span class="comment">// Add the points as vertices</span></div><div class="line">  vertex_descriptor u = m.<a class="code" href="classCGAL_1_1Surface__mesh.html#a6f899386b0667edc64cfae79cc93386e">add_vertex</a>(K::Point_3(0,1,0));</div><div class="line">  vertex_descriptor v = m.add_vertex(K::Point_3(0,0,0));</div><div class="line">  vertex_descriptor w = m.add_vertex(K::Point_3(1,0,0));</div><div class="line">  vertex_descriptor x = m.add_vertex(K::Point_3(1,1,0));</div><div class="line"></div><div class="line">  face_descriptor f = m.add_face(u,v,w,x);</div><div class="line"> </div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"vertices around vertex "</span> &lt;&lt; v &lt;&lt; std::endl;</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Vertex__around__target__circulator.html">CGAL::Vertex_around_target_circulator&lt;Mesh&gt;</a> vbegin(m.halfedge(v),m), done(vbegin);</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">      std::cout &lt;&lt; *vbegin++ &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">while</span>(vbegin != done);</div><div class="line">  }</div><div class="line">   </div><div class="line">  { </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"vertices around face "</span> &lt;&lt; f &lt;&lt; std::endl;</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Vertex__around__face__iterator.html">CGAL::Vertex_around_face_iterator&lt;Mesh&gt;</a> vbegin, vend;</div><div class="line">    <span class="keywordflow">for</span>(boost::tie(vbegin, vend) = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga7746cb7b28520877375dfff6ec7bd32c">vertices_around_face</a>(m.halfedge(f), m);</div><div class="line">        vbegin != vend; </div><div class="line">        ++vbegin){</div><div class="line">      std::cout &lt;&lt; *vbegin &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// or the same again, but directly with a range based loop</span></div><div class="line">  BOOST_FOREACH(vertex_descriptor vd,<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga7746cb7b28520877375dfff6ec7bd32c">vertices_around_face</a>(m.halfedge(f), m)){</div><div class="line">    std::cout &lt;&lt; vd &lt;&lt; std::endl;</div><div class="line">  } </div><div class="line">    </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="sectionSurfaceMesh_properties"></a>
Properties</h1>
<p><code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> provides a mechanism to specify new properties for vertices, halfedges, edges, and faces at run-time. Each property is identified by a string and its key type. All the values of a given property are stored as consecutive blocks of memory. References to properties are invalidated whenever new elements of the key type are added to the data-structure or when the function <code><a class="el" href="classCGAL_1_1Surface__mesh.html#aea69dbef8122b1acf050c19063f935f2" title="really removes vertices, halfedges, edges, and faces which are marked removed. ">Surface_mesh::collect_garbage()</a></code> is performed. Properties of an element will continue to exist after the element has been deleted. Trying to access a property through an invalidated element will result in undefined behavior.</p>
<p>One property is maintained by default, namely <code>"v:point"</code>. The value of this property has to be supplied when adding a new point to the data structure via <code><a class="el" href="classCGAL_1_1Surface__mesh.html#a6f899386b0667edc64cfae79cc93386e" title="adds a new vertex, and resizes vertex properties if necessary. ">Surface_mesh::add_vertex()</a></code>. The property can be directly accessed using <code><a class="el" href="classCGAL_1_1Surface__mesh.html#a0887ce92d0d65bcd1128c313bc9d2d07">Surface_mesh::points()</a></code> or <code><a class="el" href="classCGAL_1_1Surface__mesh.html#aaf6c8f0ab1ccc8a7b8b07de618aca2f8" title="returns the point associated to vertex v. ">Surface_mesh::point(Surface_mesh::Vertex_index v)</a></code>.</p>
<p>When an element is removed, it is only marked as removed, and it gets really removed when <code><a class="el" href="classCGAL_1_1Surface__mesh.html#aea69dbef8122b1acf050c19063f935f2" title="really removes vertices, halfedges, edges, and faces which are marked removed. ">Surface_mesh::collect_garbage()</a></code> is called. Garbage collection will also really remove the properties of these elements.</p>
<p>The connectivity is also stored in properties, namely the properties named "v:connectivity", "h:connectivity", and "f:connectivity". It is quite similar for the marker of deleted element, where we have "v:removed", "e:removed", and "f:removed".</p>
<h2><a class="anchor" id="properties_example"></a>
Example</h2>
<p>This example shows how to use the most common features of the property system.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_2sm_properties_8cpp-example.html">Surface_mesh/sm_properties.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a> Mesh;</div><div class="line"><span class="keyword">typedef</span> Mesh::Vertex_index vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> Mesh::Face_index face_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"></div><div class="line">  Mesh m;</div><div class="line">  vertex_descriptor v0 = m.<a class="code" href="classCGAL_1_1Surface__mesh.html#a6f899386b0667edc64cfae79cc93386e">add_vertex</a>(K::Point_3(0,2,0));</div><div class="line">  vertex_descriptor v1 = m.add_vertex(K::Point_3(2,2,0));</div><div class="line">  vertex_descriptor v2 = m.add_vertex(K::Point_3(0,0,0));</div><div class="line">  vertex_descriptor v3 = m.add_vertex(K::Point_3(2,0,0));</div><div class="line">  vertex_descriptor v4 = m.add_vertex(K::Point_3(1,1,0));</div><div class="line">  m.add_face(v3, v1, v4);</div><div class="line">  m.add_face(v0, v4, v1);</div><div class="line">  m.add_face(v0, v2, v4);</div><div class="line">  m.add_face(v2, v3, v4);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// give each vertex a name, the default is empty</span></div><div class="line">  Mesh::Property_map&lt;vertex_descriptor,std::string&gt; name;</div><div class="line">  <span class="keywordtype">bool</span> created;</div><div class="line">  boost::tie(name, created) = m.add_property_map&lt;vertex_descriptor,std::string&gt;(<span class="stringliteral">"v:name"</span>,<span class="stringliteral">""</span>);</div><div class="line">  assert(created);</div><div class="line">  <span class="comment">// add some names to the vertices</span></div><div class="line">  name[v0] = <span class="stringliteral">"hello"</span>;</div><div class="line">  name[v2] = <span class="stringliteral">"world"</span>;</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="comment">// You get an existing property, and created will be false</span></div><div class="line">    Mesh::Property_map&lt;vertex_descriptor,std::string&gt; name;</div><div class="line">    <span class="keywordtype">bool</span> created;</div><div class="line">    boost::tie(name, created) = m.add_property_map&lt;vertex_descriptor,std::string&gt;(<span class="stringliteral">"v:name"</span>, <span class="stringliteral">""</span>);</div><div class="line">    assert(! created);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//  You can't get a property that does not exist</span></div><div class="line">  Mesh::Property_map&lt;face_descriptor,std::string&gt; gnus;</div><div class="line">  <span class="keywordtype">bool</span> found;</div><div class="line">  boost::tie(gnus, found) = m.property_map&lt;face_descriptor,std::string&gt;(<span class="stringliteral">"v:gnus"</span>);</div><div class="line">  assert(! found);</div><div class="line"></div><div class="line">  <span class="comment">// retrieve the point property for which exists a convenience function</span></div><div class="line">  Mesh::Property_map&lt;vertex_descriptor, K::Point_3&gt; location = m.points();</div><div class="line">  BOOST_FOREACH( vertex_descriptor vd, m.vertices()) { </div><div class="line">    std::cout &lt;&lt; name[vd] &lt;&lt; <span class="stringliteral">" @ "</span> &lt;&lt; location[vd] &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; props = m.properties&lt;vertex_descriptor&gt;();</div><div class="line">  BOOST_FOREACH(std::string p, props){</div><div class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="comment">// delete the string property again</span></div><div class="line">  m.remove_property_map(name);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="sectionSurfaceMesh_borders"></a>
Borders</h1>
<p>A halfedge stores a reference to a face, its incident face. A halfedge <code>h</code> is on the border, if it has no incident face, that is if <code>sm.face(h) == <a class="el" href="classCGAL_1_1Surface__mesh.html#ab88a9b19157845d6f9881c4ab77c79d6" title="returns Face_index(std::numeric_limits&lt;size_type&gt;::max()). ">Surface_mesh::null_face()</a></code>. An edge is on the border, if any of its halfedges is on the border. A vertex is on the border, if any of its incident halfedges is on the border.</p>
<p>A vertex has only one associated halfedge. If the user takes care that the associated halfedge is a border halfedge, in case the vertex is on the border, there is no need to look at all incident halfedges in the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">is_border()</a></code> function for vertices. In order to only check if the associated halfedge is on the border the function <code><a class="el" href="classCGAL_1_1Surface__mesh.html#a587a5b95dab4077e28b4b6db8d947f1b" title="returns whether v is a border vertex.  &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; With the defaul...">Surface_mesh::is_border</a>(Vertex_index v, bool check_all_incident_halfedges = true)</code> must be called with <code>check_all_incident_halfedges = false</code>.</p>
<p>The user is in charge to correctly set the halfedge associated to a vertex after having applied an operation that might invalidate this property. The functions <code><a class="el" href="classCGAL_1_1Surface__mesh.html#acfb375fa2902b1f0c4cf1ff00b9eb9d8" title="iterates over the incident halfedges and sets the incident halfedge associated to vertex v to a borde...">Surface_mesh::set_vertex_halfedge_to_border_halfedge(Vertex_index v)</a></code>, <code><a class="el" href="classCGAL_1_1Surface__mesh.html#ae7e7430b67351edd3b43767d50e2eeb5" title="applies set_vertex_halfedge_to_border_halfedge(Vertex_index) on all vertices around the face associat...">Surface_mesh::set_vertex_halfedge_to_border_halfedge(Halfedge_index h)</a></code>, and <code><a class="el" href="classCGAL_1_1Surface__mesh.html#a71e4ba8bbb19ea91f010b13b6df8f1b1" title="applies set_vertex_halfedge_to_border_halfedge(Vertex_index) on all vertices of the surface mesh...">Surface_mesh::set_vertex_halfedge_to_border_halfedge()</a></code> enable to set the border halfedge for a single vertex <code>v</code>, for all vertices on the boundary of the face of <code>h</code>, and for all vertices of the surface mesh, respectively.</p>
<h1><a class="anchor" id="sectionSurfaceMesh_BGL"></a>
Surface Mesh and the BGL API</h1>
<p>The class <code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> is a model of the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code> defined in the Boost Graph Library. This enables to apply algorithms such as <a href="https://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html">Dijkstra shortest path</a>, or <a href="https://www.boost.org/libs/graph/doc/kruskal_min_spanning_tree.html">Kruskal minimum spanning tree</a> directly on a surface mesh.</p>
<p>The types and free functions of the BGL API have each a similar type or member function, for example </p><table class="doxtable">
<tr>
<th align="left">BGL </th><th align="left">Surface_mesh </th><th align="left">Remark  </th></tr>
<tr>
<td align="left"><code>boost::graph_traits&lt;G&gt;::vertex_descriptor</code> </td><td align="left"><code><a class="el" href="classCGAL_1_1Surface__mesh_1_1Vertex__index.html" title="This class represents a vertex. ">Surface_mesh::Vertex_index</a></code> </td><td align="left"></td></tr>
<tr>
<td align="left"><code>boost::graph_traits&lt;G&gt;::edge_descriptor</code> </td><td align="left"><code><a class="el" href="classCGAL_1_1Surface__mesh_1_1Edge__index.html" title="This class represents an edge. ">Surface_mesh::Edge_index</a></code> </td><td align="left"></td></tr>
<tr>
<td align="left"><code>vertices(const G&amp; g)</code> </td><td align="left"><code>sm.vertices()</code> </td><td align="left"></td></tr>
<tr>
<td align="left"><code>edges(const G&amp; g)</code> </td><td align="left"><code>sm.edges()</code> </td><td align="left"></td></tr>
<tr>
<td align="left"><code>vd = source(ed,g)</code> </td><td align="left"><code>vd = sm.source(ed)</code> </td><td align="left"></td></tr>
<tr>
<td align="left">na </td><td align="left"><code>n = sm.number_of_vertices()</code> </td><td align="left">counts non-deleted vertices and has no BGL equivalent </td></tr>
<tr>
<td align="left"><code>n = num_vertices(g)</code> </td><td align="left"><code>n = sm.number_of_vertices() + sm.number_of_removed_vertices()</code> </td><td align="left">counts used and deleted vertices in order to have an upper bound on the largest vertex index used </td></tr>
</table>
<p>It would be nicer to return the number of vertices without taking removed vertices into account, but this would interact badly with the underlying vertex/edge index mappings. The index mapping would no longer fall in the range <code>[0,num_vertices(g))</code> which is assumed in many of the algorithms.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> is also a model of the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> defined in the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBGLSummary">CGAL and the Boost Graph Library</a>. This and similar concepts like <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classHalfedgeGraph.html">HalfedgeGraph</a></code> refine the graph concepts of the BGL by introducing the notion of halfedges and faces, as well as cycles of halfedges around faces and around vertices. Again, there are similar types and functions, for example:</p>
<table class="doxtable">
<tr>
<th align="left">BGL </th><th align="left">Surface_mesh  </th></tr>
<tr>
<td align="left"><code>boost::graph_traits&lt;G&gt;::halfedge_descriptor</code> </td><td align="left"><code><a class="el" href="classCGAL_1_1Surface__mesh_1_1Halfedge__index.html" title="This class represents a halfedge. ">Surface_mesh::Halfedge_index</a></code> </td></tr>
<tr>
<td align="left"><code>boost::graph_traits&lt;G&gt;::face_descriptor</code> </td><td align="left"><code><a class="el" href="classCGAL_1_1Surface__mesh_1_1Face__index.html" title="This class represents a face. ">Surface_mesh::Face_index</a></code> </td></tr>
<tr>
<td align="left"><code>halfedges(const G&amp; g)</code> </td><td align="left"><code>sm.halfedges()</code> </td></tr>
<tr>
<td align="left"><code>faces(const G&amp; g)</code> </td><td align="left"><code>sm.faces()</code> </td></tr>
<tr>
<td align="left"><code>hd = next(hd, g)</code> </td><td align="left"><code>hd = sm.next(hd)</code> </td></tr>
<tr>
<td align="left"><code>hd = prev(hd, g)</code> </td><td align="left"><code>hd = sm.prev(hd)</code> </td></tr>
<tr>
<td align="left"><code>hd = opposite(hd,g)</code> </td><td align="left"><code>hd = sm.opposite(hd)</code> </td></tr>
<tr>
<td align="left"><code>hd = halfedge(vd,g)</code> </td><td align="left"><code>hd = sm.halfedge(vd)</code> </td></tr>
<tr>
<td align="left">etc. </td><td align="left"></td></tr>
</table>
<p>The BGL API described in the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBGLSummary">CGAL and the Boost Graph Library</a> enables us to write geometric algorithms operating on surface meshes, that work for any model of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceGraph.html">FaceGraph</a></code>, or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>. That is surface mesh simplification, deformation, or segmentation algorithms work for <code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code>.</p>
<p>BGL algorithms use property maps in order to associate information to vertices and edges. One important property is the index, an integer between <code>0</code> and <code>num_vertices(g)</code> for the vertices of a graph <code>g</code>. This allows algorithms to create a vector of the approriate size in order to store per vertex information. For example a Boolean for storing if a vertex has already been visited during a graph traversal.</p>
<p>The BGL way of retrieving the vertex index property map of a graph <code>g</code> is <code>vipm = get(boost::vertex_index, g)</code>, and <code>get(vipm, vd)</code> in order then to retrieve the index for a vertex descriptor <code>vd</code>, and it is <code>get(vertex_index, g, vd)</code> to obtain the vertex index directly.</p>
<h2><a class="anchor" id="SubsectionSurfaceMeshBglExample"></a>
Example</h2>
<p>The first example shows that we can apply Kruskal's minimum spanning tree algorithm directly on a surface mesh.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_2sm_kruskal_8cpp-example.html">Surface_mesh/sm_kruskal.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/kruskal_min_spanning_tree.hpp&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                            Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_iterator   vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::edge_descriptor   edge_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">kruskal(<span class="keyword">const</span> Mesh&amp; sm)</div><div class="line">{</div><div class="line">   <span class="comment">// We use the default edge weight which is the squared length of the edge</span></div><div class="line"></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line"></div><div class="line">  boost::kruskal_minimum_spanning_tree(sm, </div><div class="line">                                       std::back_inserter(mst));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"  appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"    material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"    geometry\n"</span></div><div class="line">    <span class="stringliteral">"    IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"      coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"        point [ \n"</span>;</div><div class="line"></div><div class="line">  vertex_iterator vb,ve;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb, ve) = vertices(sm); vb!=ve; ++vb){</div><div class="line">    std::cout &lt;&lt;  <span class="stringliteral">"        "</span> &lt;&lt; sm.point(*vb) &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"        ]\n"</span></div><div class="line">               <span class="stringliteral">"     }\n"</span></div><div class="line">    <span class="stringliteral">"      coordIndex [\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::list&lt;edge_descriptor&gt;::iterator it = mst.begin(); it != mst.end(); ++it)</div><div class="line">  {</div><div class="line">    edge_descriptor e = *it ;</div><div class="line">    vertex_descriptor s = source(e,sm);</div><div class="line">    vertex_descriptor t = target(e,sm);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; s &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; t &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"  }#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>,<span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  Mesh sm;</div><div class="line">  std::ifstream input(argv[1]);</div><div class="line">  input &gt;&gt; sm;</div><div class="line"></div><div class="line">  kruskal(sm);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The second example shows how we can use property maps for algorithms such as Prim's minimum spanning tree. The algorithm internally also uses a <em>vertex index property map</em> calling <code>get(boost::vertex_index_t,sm)</code>. For the class <code><a class="el" href="classCGAL_1_1Surface__mesh.html" title="This class is a data structure that can be used as halfedge data structure or polyhedral surface...">Surface_mesh</a></code> this boils down to an identity function as vertices <em>are</em> indices.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_2sm_bgl_8cpp-example.html">Surface_mesh/sm_bgl.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// workaround a bug in Boost-1.54</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/prim_minimum_spanning_tree.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                            Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> <span class="comment">/* argc */</span>, <span class="keywordtype">char</span>* argv[]) </div><div class="line">{</div><div class="line">  Mesh sm;</div><div class="line">  std::ifstream in(argv[1]);</div><div class="line">  in &gt;&gt; sm;</div><div class="line">  Mesh::Property_map&lt;vertex_descriptor,vertex_descriptor&gt; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#ga6c5d40930db429775066babac7c35d7f">predecessor</a>;</div><div class="line">  predecessor = sm.add_property_map&lt;vertex_descriptor,vertex_descriptor&gt;(<span class="stringliteral">"v:predecessor"</span>).first;</div><div class="line"></div><div class="line">  boost::prim_minimum_spanning_tree(sm, predecessor, boost::root_vertex(*vertices(sm).first));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"DirectionalLight {\n"</span></div><div class="line">    <span class="stringliteral">"direction 0 -1 0\n"</span></div><div class="line">    <span class="stringliteral">"}\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"  appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"    material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"    geometry\n"</span></div><div class="line">    <span class="stringliteral">"    IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"      coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"        point [ \n"</span>;</div><div class="line"></div><div class="line">  BOOST_FOREACH(vertex_descriptor vd, vertices(sm)){</div><div class="line">    std::cout &lt;&lt;  <span class="stringliteral">"        "</span> &lt;&lt; sm.point(vd) &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"        ]\n"</span></div><div class="line">    <span class="stringliteral">"     }\n"</span></div><div class="line">    <span class="stringliteral">"      coordIndex [\n"</span>; </div><div class="line">  BOOST_FOREACH(vertex_descriptor vd, vertices(sm)){</div><div class="line">    <span class="keywordflow">if</span>(predecessor[vd]!=vd){</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; std::size_t(vd) &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; std::size_t(predecessor[vd]) &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"  }#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line"></div><div class="line">  sm.remove_property_map(predecessor);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="sectionSurfaceMesh_memory"></a>
Memory Managment</h1>
<p>Memory management is semi-automatic. Memory grows as more elements are added to the structure but does not shrink when elements are removed.</p>
<p>When you add elements and the capacity of the underlying vector is exhausted, the vector reallocates memory. As descriptors are basically indices, they refer to the same element after a reallocation.</p>
<p>When you remove an element it is only marked as removed. Internally it is put in a free list, and when you add elements to the surface mesh, they are taken from the free list in case it is not empty.</p>
<p>For all elements we offer a function to obtain the number of used elements, as well as the number of used and removed elements. For vertices the functions are <code><a class="el" href="classCGAL_1_1Surface__mesh.html#a10ba0d4fbb6ffaf0be57c5a088cc922b" title="returns the number of vertices in the mesh. ">Surface_mesh::number_of_vertices()</a></code> and <code><a class="el" href="classCGAL_1_1Surface__mesh.html#ad63086c1d200cf3e34a5182d24fb699e" title="returns the number of vertices in the mesh which are marked removed. ">Surface_mesh::number_of_removed_vertices()</a></code>, respectively. The first function is slightly different from the free function <code>num_vertices(const G&amp;)</code> of the BGL package. As BGL style algorithms use the indices of elements to access data in temporary vectors of size <code>num_vertices()</code> this function must return a number larger than the largest index of the elements.</p>
<p>Iterators such as <code>Surface_mesh::Vertex_iterator</code> only enumerate elements that are not marked as deleted.</p>
<p>To really shrink the used memory, <code><a class="el" href="classCGAL_1_1Surface__mesh.html#aea69dbef8122b1acf050c19063f935f2" title="really removes vertices, halfedges, edges, and faces which are marked removed. ">Surface_mesh::collect_garbage()</a></code> must be called. Garbage collection also compacts the properties associated with the surface mesh.</p>
<p>Note however that by garbage collecting elements get new indices. In case you keep vertex descriptors they are most probably no longer refering to the right vertices.</p>
<h2><a class="anchor" id="SubsectionSurfaceMeshMemoryManagementExample"></a>
Example</h2>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_2sm_memory_8cpp-example.html">Surface_mesh/sm_memory.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a> Mesh;</div><div class="line"><span class="keyword">typedef</span> Mesh::Vertex_index vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Mesh m;</div><div class="line">  Mesh::Vertex_index u;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; 5; ++i){</div><div class="line">    Mesh::Vertex_index v = m.<a class="code" href="classCGAL_1_1Surface__mesh.html#a6f899386b0667edc64cfae79cc93386e">add_vertex</a>(K::Point_3(0,0,i+1));  </div><div class="line">    <span class="keywordflow">if</span>(i==2) u=v;</div><div class="line">  }</div><div class="line"></div><div class="line">  m.remove_vertex(u);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"After insertion of 5 vertices and removal of the 3. vertex\n"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"# vertices  / # vertices + # removed vertices = "</span> </div><div class="line">            &lt;&lt; m.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">" / "</span> &lt;&lt; m.number_of_vertices() + m.number_of_removed_vertices() &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Iterate over vertices\n"</span>;</div><div class="line">  {</div><div class="line">    BOOST_FOREACH(vertex_descriptor vd, m.vertices()){</div><div class="line">      std::cout &lt;&lt; m.point(vd) &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="comment">// The status of being used or removed is stored in a property map</span></div><div class="line">  Mesh::Property_map&lt;Mesh::Vertex_index,bool&gt; removed</div><div class="line">    = m.property_map&lt;Mesh::Vertex_index,<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">"v:removed"</span>).first;</div><div class="line"> </div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nIterate over vertices and deleted vertices\n"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"# vertices / # vertices + # removed vertices = "</span> </div><div class="line">            &lt;&lt; m.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">" / "</span> &lt;&lt; m.number_of_vertices() + m.number_of_removed_vertices() &lt;&lt; std::endl;</div><div class="line">    {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0, end = m.number_of_vertices() + m.number_of_removed_vertices();</div><div class="line">    <span class="keywordflow">for</span>( ; i &lt; end; ++i) {</div><div class="line">      vertex_descriptor vh(i);</div><div class="line">      assert(m.is_removed(vh) == removed[vh]);</div><div class="line">      std::cout &lt;&lt; m.point(vh) &lt;&lt; ((m.is_removed(vh)) ? <span class="stringliteral">"  R\n"</span> : <span class="stringliteral">"\n"</span>);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  m.collect_garbage();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nAfter garbage collection\n"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"# vertices / # vertices + # removed vertices = "</span></div><div class="line">            &lt;&lt; m.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">" / "</span> &lt;&lt; m.number_of_vertices() + m.number_of_removed_vertices() &lt;&lt; std::endl;</div><div class="line">  </div><div class="line"> {</div><div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0, end = m.number_of_vertices() + m.number_of_removed_vertices();</div><div class="line">    <span class="keywordflow">for</span>( ; i &lt; end; ++i) {</div><div class="line">      vertex_descriptor vh(i);</div><div class="line">      std::cout &lt;&lt; m.point(vh) &lt;&lt; ((m.is_removed(vh)) ? <span class="stringliteral">"  R\n"</span> : <span class="stringliteral">"\n"</span>);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="SurfaceMeshDraw"></a>
Draw a Surface Mesh</h1>
<p><a class="anchor" id="ssecDrawSurfaceMesh"></a> A surface mesh can be visualized by calling the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/group__PkgDrawPolyhedron.html#ga3ca458ed11c9fb052476b00227d93584">CGAL::draw()</a></code> function as shown in the following example. This function opens a new window showing the given surface mesh. The function is blocking, that is the program continues as soon as the user closes the window.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_2draw_surface_mesh_8cpp-example.html">Surface_mesh/draw_surface_mesh.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/draw_surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                            Mesh;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  Mesh sm1;</div><div class="line">  std::ifstream in1((argc&gt;1)?argv[1]:<span class="stringliteral">"data/triangle.off"</span>);</div><div class="line">  in1 &gt;&gt; sm1;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/group__PkgDrawPolyhedron.html#ga3ca458ed11c9fb052476b00227d93584">CGAL::draw</a>(sm1);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>This function requires CGAL_Qt5, and is only available if the flag CGAL_USE_BASIC_VIEWER is defined at compile time.</p>
<p><a class="anchor" id="fig__fig_draw_surface_mesh"></a></p><div class="image">
<img src="draw_surface_mesh.png" alt="draw_surface_mesh.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_draw_surface_mesh">Figure 27.2</a> Result of the run of the draw_surface_mesh program. A window shows the surface mesh and allows to navigate through the 3D scene.  </div>  <br />

<h1><a class="anchor" id="sectionSurfaceMeshImplementation"></a>
Implementation Details</h1>
<p>As integer type for the indices we have chosen <code>boost::uint32_t</code>. On 64 bit operating systems they take only half the size of a pointer. They still allow to have meshes with 2 billion elements.</p>
<p>We use <code>std::vector</code> for storing properties. So by accessing the adress of the 0th element of a property map you can access the underlying raw array. This may be useful, for example for passing an array of points to OpenGL.</p>
<p>We use a <em>freelist</em> for removed elements. This mean when a vertex gets removed and later <code>add_vertex</code> is called, the memory of the removed element is reused. This especially means that the n'th inserted element has not necessarily the index <code>n-1</code>, and when iterating over elements they will not be enumerated in the insertion order.</p>
<h1><a class="anchor" id="sectionSurfaceMeshHistory"></a>
Implementation History</h1>
<p>This package is derived from an early version of Daniel Sieger and Mario Botsch package <a href="http://graphics.uni-bielefeld.de/publications/imr11/"><em>Surface_mesh</em></a> <a class="el" href="citelist.html#CITEREF_sieger2011design">[1]</a>, which is inspired from the design of <a href="www.openmesh.org">OpenMesh</a> and the <span style="font-variant: small-caps;">CGAL</span> package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPolyhedronSummary">3D Polyhedral Surface</a>.</p>
<p>Philipp Moeller and Andreas Fabri worked on the code so that iterators fulfill the requirements of the <span style="font-variant: small-caps;">STL</span> iterator concepts, and changed the API so that it becomes a model of the concepts <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> of the package <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBGLSummary">CGAL and the Boost Graph Library</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:43 for CGAL 4.13 - Surface Mesh by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
