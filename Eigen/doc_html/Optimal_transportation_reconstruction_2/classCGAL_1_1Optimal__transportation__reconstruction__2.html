<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Optimal_transportation_reconstruction_2/classCGAL_1_1Optimal__transportation__reconstruction__2.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Optimal Transportation Curve Reconstruction: CGAL::Optimal_transportation_reconstruction_2&lt; Traits, PointPMap, MassPMap &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Optimal Transportation Curve Reconstruction
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classCGAL_1_1Optimal__transportation__reconstruction__2.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Optimal__transportation__reconstruction__2-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CGAL::Optimal_transportation_reconstruction_2&lt; Traits, PointPMap, MassPMap &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgOptimalTransportationReconstruction2.html">Optimal Transportation Curve Reconstruction Reference</a> » <a class="el" href="group__PkgOptimalTransportationReconstruction2Classes.html">Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Optimal_transportation_reconstruction_2.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><h3>template&lt;class Traits, class PointPMap = boost::typed_identity_property_map &lt;typename Traits::Point_2&gt;, class MassPMap = boost::static_property_map &lt;typename Traits::FT&gt;&gt;<br />
class CGAL::Optimal_transportation_reconstruction_2&lt; Traits, PointPMap, MassPMap &gt;</h3>

<p>This class provides a means to reconstruct a 1-dimensional shape from a set of 2D points with masses. </p>
<p>The algorithm computes an initial 2D Delaunay triangulation from the input points, and performs a simplification of the triangulation by performing half edge collapses, edge flips and vertex relocations.</p>
<p>The edges are either processed in the order imposed by an priority queue, or in an order based on random selection of edge collapse operators. As the exhaustive priority queue guarantees a higher quality it is the default. The user can switch to the other method, for example for an initial simplification round, by calling <code><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#afd9b7e1ac33076cce2a7027c8857e511" title="If sample_size == 0, the simplification is performed using an exhaustive priority queue...">set_random_sample_size()</a></code>.</p>
<p>By default edge flip operators are applied to ensure that every edge of the triangulation are candidate to be collapsed, while preserving a valid embedding of the triangulation. This option can be disabled by calling <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#ad491547e673dcbde076d68018e56ea8f"><code>set_use_flip(false)</code></a> to reduce the running times.</p>
<p>By default the vertices are not relocated after each half edge collapse. This option can be changed by setting the number of vertex relocation steps performed between two edge collapse operators.</p>
<p>The simplification is performed by calling either <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a4da6cbf9c758cd7e04cd281f8bbd4960"><code>run_until(n)</code></a> or <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#af2f0f6e6b52b27e5f558b14f3f670c71"><code>run(steps)</code></a>. The former simplifies the triangulation until n points remain, while the latter stops after <code>steps</code> edge collapse operators have been performed. Furthermore, we can relocate the vertices by calling <code><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#aec29a3302616e3b9975d4f3290af95e0" title="Since noise and missing data may prevent the reconstructed shape to have sharp corners well located...">relocate_all_points()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>a model of the concept <code><a class="el" href="classOptimalTransportationReconstructionTraits__2.html" title="The concept OptimalTransportationReconstructionTraits_2 describes the requirements for the traits cla...">OptimalTransportationReconstructionTraits_2</a></code>.</td></tr>
    <tr><td class="paramname">PointPMap</td><td>a model of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with value type <code>Traits::Point_2</code>. Defaults to <a href="https://www.boost.org/doc/libs/release/libs/property_map/doc/identity_property_map.html"><code>boost::typed_identity_property_map&lt;Traits::Point_2&gt;</code></a> (for the case the input is points without mass).</td></tr>
    <tr><td class="paramname">MassPMap</td><td>a model of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with value type <code>Traits::FT</code> Defaults to <a href="https://www.boost.org/doc/libs/release/libs/property_map/doc/static_property_map.html"><code>boost::static_property_map&lt;Traits::FT&gt;</code></a> (for the case the input is points without mass). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Optimal_transportation_reconstruction_2_2otr2_indexed_output_example_8cpp-example.html#_a1">Optimal_transportation_reconstruction_2/otr2_indexed_output_example.cpp</a>, <a class="el" href="Optimal_transportation_reconstruction_2_2otr2_list_output_example_8cpp-example.html#_a1">Optimal_transportation_reconstruction_2/otr2_list_output_example.cpp</a>, <a class="el" href="Optimal_transportation_reconstruction_2_2otr2_mass_example_8cpp-example.html#_a1">Optimal_transportation_reconstruction_2/otr2_mass_example.cpp</a>, <a class="el" href="Optimal_transportation_reconstruction_2_2otr2_simplest_example_8cpp-example.html#_a1">Optimal_transportation_reconstruction_2/otr2_simplest_example.cpp</a>, and <a class="el" href="Optimal_transportation_reconstruction_2_2otr2_simplest_example_with_tolerance_8cpp-example.html#_a1">Optimal_transportation_reconstruction_2/otr2_simplest_example_with_tolerance.cpp</a>.</dd>
</dl></div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Types</h2></td></tr>
<tr class="memitem:a5a6558881ec7202b16384318605bb3c3"><td class="memItemLeft" align="right" valign="top"><a id="a5a6558881ec7202b16384318605bb3c3"></a>
typedef Traits::FT </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a5a6558881ec7202b16384318605bb3c3">FT</a></td></tr>
<tr class="memdesc:a5a6558881ec7202b16384318605bb3c3"><td class="mdescLeft"> </td><td class="mdescRight">Number type. <br /></td></tr>
<tr class="separator:a5a6558881ec7202b16384318605bb3c3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8cbbcfc431de3be57cdc3cf986521dc1"><td class="memItemLeft" align="right" valign="top"><a id="a8cbbcfc431de3be57cdc3cf986521dc1"></a>
typedef Traits::Point_2 </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a8cbbcfc431de3be57cdc3cf986521dc1">Point</a></td></tr>
<tr class="memdesc:a8cbbcfc431de3be57cdc3cf986521dc1"><td class="mdescLeft"> </td><td class="mdescRight">Point type. <br /></td></tr>
<tr class="separator:a8cbbcfc431de3be57cdc3cf986521dc1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac7070d263cfc0776e18c6e2ac1a5e651"><td class="memItemLeft" align="right" valign="top"><a id="ac7070d263cfc0776e18c6e2ac1a5e651"></a>
typedef Traits::Segment_2 </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#ac7070d263cfc0776e18c6e2ac1a5e651">Segment</a></td></tr>
<tr class="memdesc:ac7070d263cfc0776e18c6e2ac1a5e651"><td class="mdescLeft"> </td><td class="mdescRight">Segment type. <br /></td></tr>
<tr class="separator:ac7070d263cfc0776e18c6e2ac1a5e651"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Initialization</h2></td></tr>
<tr class="memitem:a6d945a9ddf0faa394e4d15e2e3e7b831"><td class="memTemplParams" colspan="2">template&lt;class InputRange &gt; </td></tr>
<tr class="memitem:a6d945a9ddf0faa394e4d15e2e3e7b831"><td class="memTemplItemLeft" align="right" valign="top"> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a6d945a9ddf0faa394e4d15e2e3e7b831">Optimal_transportation_reconstruction_2</a> (const InputRange &amp;input_range, PointPMap point_map=PointPMap(), MassPMap mass_map=MassPMap(1), std::size_t sample_size=0, bool use_flip=true, unsigned int relocation=2, int verbose=0, Traits traits=Traits())</td></tr>
<tr class="memdesc:a6d945a9ddf0faa394e4d15e2e3e7b831"><td class="mdescLeft"> </td><td class="mdescRight">Constructor of the optimal transportation reconstruction class.  <a href="#a6d945a9ddf0faa394e4d15e2e3e7b831">More...</a><br /></td></tr>
<tr class="separator:a6d945a9ddf0faa394e4d15e2e3e7b831"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Settting Parameters</h2></td></tr>
<tr class="memitem:afd9b7e1ac33076cce2a7027c8857e511"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#afd9b7e1ac33076cce2a7027c8857e511">set_random_sample_size</a> (std::size_t sample_size)</td></tr>
<tr class="memdesc:afd9b7e1ac33076cce2a7027c8857e511"><td class="mdescLeft"> </td><td class="mdescRight">If <code>sample_size == 0</code>, the simplification is performed using an exhaustive priority queue.  <a href="#afd9b7e1ac33076cce2a7027c8857e511">More...</a><br /></td></tr>
<tr class="separator:afd9b7e1ac33076cce2a7027c8857e511"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a28260d575a16a1e351381016692ee14f"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a28260d575a16a1e351381016692ee14f">set_verbose</a> (int verbose)</td></tr>
<tr class="memdesc:a28260d575a16a1e351381016692ee14f"><td class="mdescLeft"> </td><td class="mdescRight">Determines how much console output the algorithm generates.  <a href="#a28260d575a16a1e351381016692ee14f">More...</a><br /></td></tr>
<tr class="separator:a28260d575a16a1e351381016692ee14f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad491547e673dcbde076d68018e56ea8f"><td class="memItemLeft" align="right" valign="top"><a id="ad491547e673dcbde076d68018e56ea8f"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#ad491547e673dcbde076d68018e56ea8f">set_use_flip</a> (const bool use_flip)</td></tr>
<tr class="memdesc:ad491547e673dcbde076d68018e56ea8f"><td class="mdescLeft"> </td><td class="mdescRight">The use_flip parameter determines whether the edge flipping procedure is used for the half-edge collapse. <br /></td></tr>
<tr class="separator:ad491547e673dcbde076d68018e56ea8f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a124dba5f9ea1fd561df35e499936679d"><td class="memItemLeft" align="right" valign="top"><a id="a124dba5f9ea1fd561df35e499936679d"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a124dba5f9ea1fd561df35e499936679d">set_relocation</a> (unsigned int relocation)</td></tr>
<tr class="memdesc:a124dba5f9ea1fd561df35e499936679d"><td class="mdescLeft"> </td><td class="mdescRight">Sets the number of vertex relocations that are performed between two edge collapses. <br /></td></tr>
<tr class="separator:a124dba5f9ea1fd561df35e499936679d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9d13bdd2e76d4503e049728ee006e357"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a9d13bdd2e76d4503e049728ee006e357">set_relevance</a> (const <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a5a6558881ec7202b16384318605bb3c3">FT</a> relevance)</td></tr>
<tr class="separator:a9d13bdd2e76d4503e049728ee006e357"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Simplification</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6bd183b4f9d04a2737f170e01d2e63fe"></a>You can freely mix calls of the following functions. </p>
</td></tr>
<tr class="memitem:a4da6cbf9c758cd7e04cd281f8bbd4960"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a4da6cbf9c758cd7e04cd281f8bbd4960">run_until</a> (std::size_t np)</td></tr>
<tr class="memdesc:a4da6cbf9c758cd7e04cd281f8bbd4960"><td class="mdescLeft"> </td><td class="mdescRight">Computes a shape consisting of <code>np</code> points, reconstructing the input points.  <a href="#a4da6cbf9c758cd7e04cd281f8bbd4960">More...</a><br /></td></tr>
<tr class="separator:a4da6cbf9c758cd7e04cd281f8bbd4960"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af2f0f6e6b52b27e5f558b14f3f670c71"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#af2f0f6e6b52b27e5f558b14f3f670c71">run</a> (const unsigned steps)</td></tr>
<tr class="memdesc:af2f0f6e6b52b27e5f558b14f3f670c71"><td class="mdescLeft"> </td><td class="mdescRight">Computes a shape, reconstructing the input, by performing <code>steps</code> edge collapse operators on the output simplex.  <a href="#af2f0f6e6b52b27e5f558b14f3f670c71">More...</a><br /></td></tr>
<tr class="separator:af2f0f6e6b52b27e5f558b14f3f670c71"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ada2cdd4244c0005d0527acdb68cb02cb"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#ada2cdd4244c0005d0527acdb68cb02cb">run_under_wasserstein_tolerance</a> (const <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a5a6558881ec7202b16384318605bb3c3">FT</a> tolerance)</td></tr>
<tr class="memdesc:ada2cdd4244c0005d0527acdb68cb02cb"><td class="mdescLeft"> </td><td class="mdescRight">Computes a shape, reconstructing the input, by performing edge collapse operators on the output simplex until the user-defined tolerance is reached.  <a href="#ada2cdd4244c0005d0527acdb68cb02cb">More...</a><br /></td></tr>
<tr class="separator:ada2cdd4244c0005d0527acdb68cb02cb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aec29a3302616e3b9975d4f3290af95e0"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#aec29a3302616e3b9975d4f3290af95e0">relocate_all_points</a> ()</td></tr>
<tr class="memdesc:aec29a3302616e3b9975d4f3290af95e0"><td class="mdescLeft"> </td><td class="mdescRight">Since noise and missing data may prevent the reconstructed shape to have sharp corners well located, the algorithm offers the possibility to automatically relocate points after each edge collapse.  <a href="#aec29a3302616e3b9975d4f3290af95e0">More...</a><br /></td></tr>
<tr class="separator:aec29a3302616e3b9975d4f3290af95e0"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group" id="member-group"></a>
Output</h2></td></tr>
<tr class="memitem:a9eb72be2035c41a456164ada3a3f2f89"><td class="memTemplParams" colspan="2">template&lt;typename PointOutputIterator , typename IndexOutputIterator , typename IndexPairOutputIterator &gt; </td></tr>
<tr class="memitem:a9eb72be2035c41a456164ada3a3f2f89"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1cpp11_1_1tuple.html">CGAL::cpp11::tuple</a>&lt; PointOutputIterator, IndexOutputIterator, IndexPairOutputIterator &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a9eb72be2035c41a456164ada3a3f2f89">indexed_output</a> (PointOutputIterator points, IndexOutputIterator isolated_points, IndexPairOutputIterator segments) const</td></tr>
<tr class="memdesc:a9eb72be2035c41a456164ada3a3f2f89"><td class="mdescLeft"> </td><td class="mdescRight">Writes the points and segments of the output simplex in an indexed format into output iterators.  <a href="#a9eb72be2035c41a456164ada3a3f2f89">More...</a><br /></td></tr>
<tr class="separator:a9eb72be2035c41a456164ada3a3f2f89"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad94fc673df480c8b2076ae542fdd0e04"><td class="memTemplParams" colspan="2">template&lt;class PointOutputIterator , class SegmentOutputIterator &gt; </td></tr>
<tr class="memitem:ad94fc673df480c8b2076ae542fdd0e04"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#ad94fc673df480c8b2076ae542fdd0e04">list_output</a> (PointOutputIterator v_it, SegmentOutputIterator e_it) const</td></tr>
<tr class="memdesc:ad94fc673df480c8b2076ae542fdd0e04"><td class="mdescLeft"> </td><td class="mdescRight">Returns the solid edges and vertices present after the reconstruction process finished.  <a href="#ad94fc673df480c8b2076ae542fdd0e04">More...</a><br /></td></tr>
<tr class="separator:ad94fc673df480c8b2076ae542fdd0e04"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6d945a9ddf0faa394e4d15e2e3e7b831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d945a9ddf0faa394e4d15e2e3e7b831">◆ </a></span>Optimal_transportation_reconstruction_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class PointPMap  = boost::typed_identity_property_map &lt;typename Traits::Point_2&gt;, class MassPMap  = boost::static_property_map &lt;typename Traits::FT&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">CGAL::Optimal_transportation_reconstruction_2</a>&lt; Traits, PointPMap, MassPMap &gt;::<a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">Optimal_transportation_reconstruction_2</a> </td>
          <td>(</td>
          <td class="paramtype">const InputRange &amp; </td>
          <td class="paramname"><em>input_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointPMap </td>
          <td class="paramname"><em>point_map</em> = <code>PointPMap()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MassPMap </td>
          <td class="paramname"><em>mass_map</em> = <code>MassPMap(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t </td>
          <td class="paramname"><em>sample_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>use_flip</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int </td>
          <td class="paramname"><em>relocation</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits </td>
          <td class="paramname"><em>traits</em> = <code>Traits()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the optimal transportation reconstruction class. </p>
<p>It builds an initial simplicial complex for a given range of point-mass pairs.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputRange</td><td>is a model of <code>Range</code> with forward iterators, providing input points and point masses through the <code>PointPMap</code> and <code>MassPMap</code> property maps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_range</td><td>Range of input data. </td></tr>
    <tr><td class="paramname">point_map</td><td>A <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> used to access the input points. </td></tr>
    <tr><td class="paramname">mass_map</td><td>A <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> used to access the input points' masses. </td></tr>
    <tr><td class="paramname">sample_size</td><td>If <code>sample_size != 0</code>, the size of the random sample which replaces the exhaustive priority queue. </td></tr>
    <tr><td class="paramname">use_flip</td><td>If <code>true</code> the edge flipping procedure is used to ensure that every edge can be made collapsible. </td></tr>
    <tr><td class="paramname">relocation</td><td>The number of point relocations that are performed between two edge collapses. </td></tr>
    <tr><td class="paramname">verbose</td><td>Controls how much console output is produced by the algorithm. The values are 0, 1, or &gt; 1. </td></tr>
    <tr><td class="paramname">traits</td><td>The traits class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9eb72be2035c41a456164ada3a3f2f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb72be2035c41a456164ada3a3f2f89">◆ </a></span>indexed_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class PointPMap  = boost::typed_identity_property_map &lt;typename Traits::Point_2&gt;, class MassPMap  = boost::static_property_map &lt;typename Traits::FT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename PointOutputIterator , typename IndexOutputIterator , typename IndexPairOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1cpp11_1_1tuple.html">CGAL::cpp11::tuple</a>&lt; PointOutputIterator, IndexOutputIterator, IndexPairOutputIterator&gt; <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">CGAL::Optimal_transportation_reconstruction_2</a>&lt; Traits, PointPMap, MassPMap &gt;::indexed_output </td>
          <td>(</td>
          <td class="paramtype">PointOutputIterator </td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexOutputIterator </td>
          <td class="paramname"><em>isolated_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexPairOutputIterator </td>
          <td class="paramname"><em>segments</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the points and segments of the output simplex in an indexed format into output iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointOutputIterator</td><td>An output iterator with value type <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a8cbbcfc431de3be57cdc3cf986521dc1">Point </a>. </td></tr>
    <tr><td class="paramname">IndexOutputIterator</td><td>An output iterator with value type <code>std::size_t</code>. </td></tr>
    <tr><td class="paramname">IndexPairOutputIterator</td><td>An output iterator with value type <code>std::pair&lt;std::size_t, std::size_t&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The output iterator for all points. </td></tr>
    <tr><td class="paramname">isolated_points</td><td>The output iterator for the indices of isolated points. </td></tr>
    <tr><td class="paramname">segments</td><td>The output iterator for the pairs of segment indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad94fc673df480c8b2076ae542fdd0e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94fc673df480c8b2076ae542fdd0e04">◆ </a></span>list_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class PointPMap  = boost::typed_identity_property_map &lt;typename Traits::Point_2&gt;, class MassPMap  = boost::static_property_map &lt;typename Traits::FT&gt;&gt; </div>
<div class="memtemplate">
template&lt;class PointOutputIterator , class SegmentOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">CGAL::Optimal_transportation_reconstruction_2</a>&lt; Traits, PointPMap, MassPMap &gt;::list_output </td>
          <td>(</td>
          <td class="paramtype">PointOutputIterator </td>
          <td class="paramname"><em>v_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SegmentOutputIterator </td>
          <td class="paramname"><em>e_it</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the solid edges and vertices present after the reconstruction process finished. </p>
<p>It takes two output iterators, one for storing the isolated points and one for storing the edges of the reconstructed shape.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointOutputIterator</td><td>An output iterator with value type <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a8cbbcfc431de3be57cdc3cf986521dc1">Point </a>. </td></tr>
    <tr><td class="paramname">SegmentOutputIterator</td><td>An output iterator with value type <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#ac7070d263cfc0776e18c6e2ac1a5e651">Segment </a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec29a3302616e3b9975d4f3290af95e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec29a3302616e3b9975d4f3290af95e0">◆ </a></span>relocate_all_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class PointPMap  = boost::typed_identity_property_map &lt;typename Traits::Point_2&gt;, class MassPMap  = boost::static_property_map &lt;typename Traits::FT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">CGAL::Optimal_transportation_reconstruction_2</a>&lt; Traits, PointPMap, MassPMap &gt;::relocate_all_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Since noise and missing data may prevent the reconstructed shape to have sharp corners well located, the algorithm offers the possibility to automatically relocate points after each edge collapse. </p>
<p>The new location of the points is chosen such that the fitting of the output segments to the input points is improved. </p>

</div>
</div>
<a id="af2f0f6e6b52b27e5f558b14f3f670c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f0f6e6b52b27e5f558b14f3f670c71">◆ </a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class PointPMap  = boost::typed_identity_property_map &lt;typename Traits::Point_2&gt;, class MassPMap  = boost::static_property_map &lt;typename Traits::FT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">CGAL::Optimal_transportation_reconstruction_2</a>&lt; Traits, PointPMap, MassPMap &gt;::run </td>
          <td>(</td>
          <td class="paramtype">const unsigned </td>
          <td class="paramname"><em>steps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a shape, reconstructing the input, by performing <code>steps</code> edge collapse operators on the output simplex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">steps</td><td>The number of edge collapse operators to be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the required number of steps was performed, <code>false</code> if the algorithm was prematurely ended because no more edge collapse was possible. </dd></dl>

</div>
</div>
<a id="ada2cdd4244c0005d0527acdb68cb02cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2cdd4244c0005d0527acdb68cb02cb">◆ </a></span>run_under_wasserstein_tolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class PointPMap  = boost::typed_identity_property_map &lt;typename Traits::Point_2&gt;, class MassPMap  = boost::static_property_map &lt;typename Traits::FT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">CGAL::Optimal_transportation_reconstruction_2</a>&lt; Traits, PointPMap, MassPMap &gt;::run_under_wasserstein_tolerance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a5a6558881ec7202b16384318605bb3c3">FT</a> </td>
          <td class="paramname"><em>tolerance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a shape, reconstructing the input, by performing edge collapse operators on the output simplex until the user-defined tolerance is reached. </p>
<dl class="section note"><dt>Note</dt><dd>The tolerance is given in the sense of the Wasserstein distance. It is <em>not</em> a Hausdorff tolerance: it does not mean that the distance between the input samples and the output polyline is guaranteed to be less than <code>tolerance</code>. It means that the square root of transport cost per mass (homogeneous to a distance) is at most <code>tolerance</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>Tolerance on the Wasserstein distance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4da6cbf9c758cd7e04cd281f8bbd4960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da6cbf9c758cd7e04cd281f8bbd4960">◆ </a></span>run_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class PointPMap  = boost::typed_identity_property_map &lt;typename Traits::Point_2&gt;, class MassPMap  = boost::static_property_map &lt;typename Traits::FT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">CGAL::Optimal_transportation_reconstruction_2</a>&lt; Traits, PointPMap, MassPMap &gt;::run_until </td>
          <td>(</td>
          <td class="paramtype">std::size_t </td>
          <td class="paramname"><em>np</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a shape consisting of <code>np</code> points, reconstructing the input points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">np</td><td>The number of points which will be present in the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the number of points <code>np</code> was reached, <code>false</code> if the algorithm was prematurely ended because no more edge collapse was possible. </dd></dl>

</div>
</div>
<a id="afd9b7e1ac33076cce2a7027c8857e511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9b7e1ac33076cce2a7027c8857e511">◆ </a></span>set_random_sample_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class PointPMap  = boost::typed_identity_property_map &lt;typename Traits::Point_2&gt;, class MassPMap  = boost::static_property_map &lt;typename Traits::FT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">CGAL::Optimal_transportation_reconstruction_2</a>&lt; Traits, PointPMap, MassPMap &gt;::set_random_sample_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t </td>
          <td class="paramname"><em>sample_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>sample_size == 0</code>, the simplification is performed using an exhaustive priority queue. </p>
<p>If <code>sample_size</code> is stricly positive the simplification is performed using a multiple choice approach, ie, a best-choice selection in a random sample of edge collapse operators, of size <code>sample_size</code>. A typical value for the sample size is 15, but this value must be enlarged when targeting a very coarse simplification. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample_size</td><td>If <code>sample_size != 0</code>, the size of the random sample replaces the priority queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d13bdd2e76d4503e049728ee006e357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d13bdd2e76d4503e049728ee006e357">◆ </a></span>set_relevance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class PointPMap  = boost::typed_identity_property_map &lt;typename Traits::Point_2&gt;, class MassPMap  = boost::static_property_map &lt;typename Traits::FT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">CGAL::Optimal_transportation_reconstruction_2</a>&lt; Traits, PointPMap, MassPMap &gt;::set_relevance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html#a5a6558881ec7202b16384318605bb3c3">FT</a> </td>
          <td class="paramname"><em>relevance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relevance</td><td>The relevance threshold used for filtering the edges. An edge is relevant from the approximation point of view if it is long, covers a large mass (or equivalently the number of points when all masses are equal), and has a small transport cost. This notion is defined as \( m(e) * |e|^2 / cost(e) \), where \( m(e) \) denotes the mass of the points approximated by the edge, \( |e| \) denotes the edge length and \( cost(e) \) its approximation error. As the cost is defined by mass time squared distance the relevance is unitless.</td></tr>
  </table>
  </dd>
</dl>
<p>The default value is 1, so that all edges receiving some mass are considered relevant. Setting a large relevance value is used to get robustness to a large amount of outliers. </p>

</div>
</div>
<a id="a28260d575a16a1e351381016692ee14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28260d575a16a1e351381016692ee14f">◆ </a></span>set_verbose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class PointPMap  = boost::typed_identity_property_map &lt;typename Traits::Point_2&gt;, class MassPMap  = boost::static_property_map &lt;typename Traits::FT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">CGAL::Optimal_transportation_reconstruction_2</a>&lt; Traits, PointPMap, MassPMap &gt;::set_verbose </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines how much console output the algorithm generates. </p>
<p>If set to a value larger than 0 details about the reconstruction process are written to <code>std::cerr</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>The verbosity level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><a class="el" href="classCGAL_1_1Optimal__transportation__reconstruction__2.html">Optimal_transportation_reconstruction_2</a></li>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:53 for CGAL 4.13 - Optimal Transportation Curve Reconstruction by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>



</html>
