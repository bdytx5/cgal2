<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Handles_Ranges_and_Circulators"/><anchor id="index_1chapterCirculators"/>  <simplesect kind="authors"><para>Olivier Devillers, Lutz Kettner, Sylvain Pion, Michael Seel, and Mariette Yvinec</para></simplesect>
</para><sect1 id="index_1CirculatorHandles">
<title>Handles</title>
<para>Most data structures in CGAL use the concept of <computeroutput><ref refid="classHandle" kindref="compound">Handle</ref></computeroutput> in their user interface to refer to the elements they store. This concept describes what is sometimes called a trivial iterator. A <computeroutput><ref refid="classHandle" kindref="compound">Handle</ref></computeroutput> is akeen to a pointer to an object providing the dereference operator <computeroutput>operator*()</computeroutput> and member access <computeroutput>operator-&gt;()</computeroutput> but no increment or decrement operators like iterators. A <computeroutput><ref refid="classHandle" kindref="compound">Handle</ref></computeroutput> is intended to be used whenever the referenced object is not part of a logical sequence.</para><para><bold>Model for a handle</bold> A simple pointer <computeroutput>T*</computeroutput>, an iterator or a circulator with value type <computeroutput>T</computeroutput>, are also handles.</para></sect1>
<sect1 id="index_1CirculatorRanges">
<title>Ranges</title>
<para>Most data structures in CGAL use the concept of an iterator range. The <computeroutput><ref refid="classRange" kindref="compound">Range</ref></computeroutput> and <computeroutput><ref refid="classConstRange" kindref="compound">ConstRange</ref></computeroutput> concepts encapsulate the access to the first and the past-the-end iterators of an iterator range. STL containers are models of <computeroutput><ref refid="classRange" kindref="compound">Range</ref></computeroutput>. The Boost.Range library provides good support around this concept as well.</para></sect1>
<sect1 id="index_1circulatorsCirculators">
<title>Circulators</title>
<para>An introduction to the concept of circulators is given here. A couple of adaptors are presented that convert between iterators and circulators. Some useful functions for circulators follow. This chapter concludes with a discussion of the design decisions taken. For the full description of the circulator requirements, the provided base classes, the circulator tags, and the support for generic algorithms that work for iterators as well as for circulators please refer to the reference pages. Note that circulators are not part of STL, but of CGAL.</para><sect2 id="index_1sectionIntroduction">
<title>Introduction</title>
<para>The concept of iterators in STL is tailored for linear sequences <ref refid="citelist_1CITEREF_cgal:ansi-is14882-98" kindref="member">[1]</ref>, <ref refid="citelist_1CITEREF_cgal:ms-strg-96" kindref="member">[2]</ref>. In contrast, circular sequences occur naturally in many combinatorial and geometric structures. Examples are polyhedral surfaces and planar maps, where the edges emanating from a vertex or the edges around a facet form a circular sequence.</para><para>Since circular sequences do not allow for efficient iterators, we have introduced the new concept of <emphasis>circulators</emphasis>. They share most of the requirements of iterators, while the main difference is the lack of a past-the-end position in the sequence. Appropriate adaptors are provided between iterators and circulators to integrate circulators smoothly into the framework of STL. An example of a generic <computeroutput>contains</computeroutput> function illustrates the use of circulators. As usual for circular structures, a <computeroutput>do</computeroutput>-<computeroutput>while</computeroutput> loop is preferable, such that for the specific input, <computeroutput>c == d</computeroutput>, all elements in the sequence are reached.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Circulator,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>contains(<sp/>Circulator<sp/>c,<sp/>Circulator<sp/>d,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(c<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(*c<sp/>==<sp/>value)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(++c<sp/>!=<sp/>d);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Three circulator categories are defined: forward, bidirectional and random-access circulators. Given a circulator <computeroutput>c</computeroutput>, the operation <computeroutput>*c</computeroutput> denotes the item the circulator refers to. The operation <computeroutput>++c</computeroutput> advances the circulator by one item and <computeroutput>-c</computeroutput> steps a bidirectional circulator one item backwards. For random-access circulators <computeroutput>c+n</computeroutput> advances the circulator <computeroutput>n</computeroutput> steps. Two circulators can be compared for equality.</para><para>Circulators have a different notion of reachability and ranges than iterators. A circulator <computeroutput>d</computeroutput> is called <emphasis>reachable</emphasis> from a circulator <computeroutput>c</computeroutput> if <computeroutput>c</computeroutput> can be made equal to <computeroutput>d</computeroutput> with finitely many applications of the operator <computeroutput>++</computeroutput>. Due to the circularity of the sequence this is always true if both circulators refer to items of the same sequence. In particular, <computeroutput>c</computeroutput> is always reachable from <computeroutput>c</computeroutput>. Given two circulators <computeroutput>c</computeroutput> and <computeroutput>d</computeroutput>, the range <computeroutput>[c,d)</computeroutput> denotes all circulators obtained by starting with <computeroutput>c</computeroutput> and advancing <computeroutput>c</computeroutput> until <computeroutput>d</computeroutput> is reached, but does not include <computeroutput>d</computeroutput>, for <computeroutput>d != c</computeroutput>. So far it is the same range definition as for iterators. The difference lies in the use of <computeroutput>[c,c)</computeroutput> to denote all items in the circular sequence, whereas for an iterator <computeroutput>i</computeroutput> the range <computeroutput>[i,i)</computeroutput> denotes the empty range. As long as <computeroutput>c != d</computeroutput> the range <computeroutput>[c,d)</computeroutput> behaves like an iterator range and could be used in STL algorithms. For circulators however, an additional test <computeroutput>c == NULL</computeroutput> is required that returns true if and only if the circular sequence is empty. As for C++, we recommend the use of 0 instead of <computeroutput>NULL</computeroutput>.</para><para>Besides the conceptual cleanness, the main reason for inventing a new concept with a similar intent as iterators is efficiency. An iterator is supposed to be a light-weight object - merely a pointer and a single indirection to advance the iterator. Although iterators could be written for circular sequences, we do not know of an efficient solution. The missing past-the-end situation in circular sequences can be solved with an arbitrary sentinel in the cyclic order, but this would destroy the natural symmetry in the structure (which is in itself a bad idea) and additional bookkeeping in the items and checking in the iterator advance method reduces efficiency. Another solution may use more bookkeeping in the iterator, e.g. with a start item, a current item, and a kind of winding-number that is zero for the <computeroutput>begin()</computeroutput>-iterator and one for the past-the-end situationThis is currently implemented as the adaptor class which provides a pair of iterators for a given circulator.. We have introduced the concept of circulators that allows light-weight implementations and the CGAL support library provides adaptor classes that convert between iterators and circulators (with the corresponding penalty in efficiency), so as to integrate this new concept into the framework of STL.</para><para>A serious design problem is the slight change of the semantic for circulator ranges as compared to iterator ranges. Since this semantic is defined by the intuitive operators <computeroutput>++</computeroutput> and <computeroutput>==</computeroutput>, which we would like to keep for circulators as well, circulator ranges can be used in STL algorithms. This is in itself a useful feature, if there would not be the definition of a full range <computeroutput>[c, c)</computeroutput> that an STL algorithm will treat as an empty range. However, the likelihood of a mistake may be overestimated, since for a container <computeroutput>C</computeroutput> supporting circulators there is no <computeroutput>end()</computeroutput> member function, and an expression such as <computeroutput>std::sort( C.begin(), C.end())</computeroutput> will fail. It is easy to distinguish iterators and circulators at compile time, which allows for generic algorithms supporting both as arguments. It is also possible to protect algorithms against inappropriate arguments using the same technique, see the reference pages for circulators, specifically the <computeroutput><ref refid="group__PkgHandlesAndCirculatorsAssert_1ga28a51d41a222f90c19b75bc6f5e1155f" kindref="member">Assert_iterator()</ref></computeroutput> and <computeroutput><ref refid="group__PkgHandlesAndCirculatorsFunctions_1gaf4e8c8285d91a1d8acd582191da0f255" kindref="member">is_empty_range()</ref></computeroutput> functions.</para><para><anchor id="index_1sectionCirculatorWarning"/><simplesect kind="attention"><para>Please note that the definition of a range is different from that of iterators. An interface of a data structure must declare whether it works with iterators, circulators, or both. STL algorithms always specify only iterators in their interfaces. A range <computeroutput>[c, d)</computeroutput> of circulators used in an interface for iterators will work as expected as long as <computeroutput>c != d</computeroutput>. A range <computeroutput>[c, c)</computeroutput> will be interpreted as the empty range like for iterators, which is different than the full range that it should denote for circulators.</para></simplesect>
</para></sect2>
<sect2 id="index_1sectionCirculatorAdaptor">
<title>Adaptors Between Iterators and Circulators</title>
<para>Algorithms working on iterator ranges can not be applied to circulator ranges in full generality, only to subranges as pointed out in the previous section. The following adaptors convert circulators to iterators and vice versa (with the unavoidable space and time penalty) to reestablish this generality.</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Container__from__circulator" kindref="compound">Container_from_circulator</ref></computeroutput> is a container-like class with iterators built from a circulator</para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Circulator__from__iterator" kindref="compound">Circulator_from_iterator</ref></computeroutput> is a circulator over a range of two iterators</para></listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Circulator__from__container" kindref="compound">Circulator_from_container</ref></computeroutput> is a circulator for a container</para></listitem></itemizedlist>
</para><para>The following example applies the generic <computeroutput>std::reverse()</computeroutput> algorithm from STL to a sequence given by a bidirectional circulator <computeroutput>c</computeroutput>. It uses the <computeroutput><ref refid="classCGAL_1_1Container__from__circulator" kindref="compound">Container_from_circulator</ref></computeroutput> adaptor.</para><para><programlisting><codeline><highlight class="normal">Circulator<sp/>c;<sp/></highlight><highlight class="comment">//<sp/>c<sp/>must<sp/>be<sp/>at<sp/>least<sp/>bidirectional.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classCGAL_1_1Container__from__circulator" kindref="compound">CGAL::Container_from_circulator&lt;Circulator&gt;</ref><sp/>container(c);</highlight></codeline>
<codeline><highlight class="normal">std::reverse(<sp/>container.begin(),<sp/>container.end());</highlight></codeline>
</programlisting></para><para>Another example defines a circulator <computeroutput>c</computeroutput> for a vector of <computeroutput>int</computeroutput>&apos;s. However, since there are no elements in the vector, the circulator denotes an empty sequence. If there were elements in the vector, the circulator would implement a random access modulus the size of the sequence.</para><para><programlisting><codeline><highlight class="normal">std::vector&lt;int&gt;<sp/>v;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Circulator__from__iterator" kindref="compound">CGAL::Circulator_from_iterator&lt; std::vector&lt;int&gt;::iterator</ref><sp/>&gt;<sp/>Circulator;</highlight></codeline>
<codeline><highlight class="normal">Circulator<sp/>c(<sp/>v.begin(),<sp/>v.end());</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1sectionCirculatorFunctions">
<title>Functions on Circulators</title>
<para>Several functions deal with circulators and circulator ranges. The type <computeroutput>C</computeroutput> denotes a circulator. The type <computeroutput>IC</computeroutput> denotes either a circulator or an iterator. More on algorithms that work with circulators as well with iterators can be found in the reference pages.</para><para><programlisting><codeline><highlight class="normal">C<sp/>c,<sp/>d;</highlight></codeline>
<codeline><highlight class="normal">IC<sp/>ic1,<sp/>ic2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__PkgHandlesAndCirculatorsFunctions_1ga2d7bfa21e8eb046b8ae90104aa4fcce4" kindref="member">circulator_size</ref>(c);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>size<sp/>of<sp/>the<sp/>sequence<sp/>reachable<sp/>by<sp/>c</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__PkgHandlesAndCirculatorsFunctions_1gaa7e7be37f74469fd362a65b9263f290f" kindref="member">circulator_distance</ref>(c,<sp/>d);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>number<sp/>of<sp/>elements<sp/>in<sp/>the<sp/>range<sp/>[c,<sp/>d)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__PkgHandlesAndCirculatorsFunctions_1ga2607becefb150be4f7d1f2b9e82b6da0" kindref="member">iterator_distance</ref>(ic1,<sp/>ic2);<sp/></highlight><highlight class="comment">//<sp/>number<sp/>of<sp/>elements<sp/>in<sp/>the<sp/>range<sp/>[ic2,<sp/>ic1)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__PkgHandlesAndCirculatorsFunctions_1gaf4e8c8285d91a1d8acd582191da0f255" kindref="member">is_empty_range</ref>(ic1,<sp/>ic2);<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>test<sp/>the<sp/>range<sp/>[ic2,<sp/>ic1)<sp/>for<sp/>emptiness</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
