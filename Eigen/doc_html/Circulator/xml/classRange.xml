<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classRange" kind="class" language="C++" prot="public">
    <compoundname>Range</compoundname>
    <includes local="no">Concepts/Range.h</includes>
      <sectiondef kind="user-defined">
      <header>Types</header>
      <memberdef kind="typedef" id="classRange_1afc35da2db23057eab50b33b8bf7425bc" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type Range::const_iterator</definition>
        <argsstring></argsstring>
        <name>const_iterator</name>
        <briefdescription>
<para>The constant iterator type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Range.h" line="48" column="1" bodyfile="Concepts/Range.h" bodystart="48" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classRange_1a9f096a55af89e52e34c591219d87d4fb" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type Range::iterator</definition>
        <argsstring></argsstring>
        <name>iterator</name>
        <briefdescription>
<para>The iterator type. </para>        </briefdescription>
        <detaileddescription>
<para>It must be convertible to <computeroutput>const_iterator</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Range.h" line="53" column="1" bodyfile="Concepts/Range.h" bodystart="53" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classRange_1a16092b154a168a420a2a7f752577d885" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type Range::size_type</definition>
        <argsstring></argsstring>
        <name>size_type</name>
        <briefdescription>
<para>An unsigned integral type that can represent the size of a range. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Range.h" line="59" column="1" bodyfile="Concepts/Range.h" bodystart="59" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Member functions</header>
      <memberdef kind="function" id="classRange_1aa22e9ddb32d1b526e7a2052bb1b636a0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classRange_1afc35da2db23057eab50b33b8bf7425bc" kindref="member">const_iterator</ref></type>
        <definition>const_iterator Range::begin</definition>
        <argsstring>() const</argsstring>
        <name>begin</name>
        <briefdescription>
<para>returns the const iterator pointing to the first element. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Range.h" line="69" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classRange_1a0751f26452ef60d21a0aeca5a47e9f22" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classRange_1afc35da2db23057eab50b33b8bf7425bc" kindref="member">const_iterator</ref></type>
        <definition>const_iterator Range::end</definition>
        <argsstring>() const</argsstring>
        <name>end</name>
        <briefdescription>
<para>returns the past-the-end const iterator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Range.h" line="74" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classRange_1afa60203f471c5b39e5d73c1abfed49bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classRange_1a9f096a55af89e52e34c591219d87d4fb" kindref="member">iterator</ref></type>
        <definition>iterator Range::begin</definition>
        <argsstring>()</argsstring>
        <name>begin</name>
        <briefdescription>
<para>returns the iterator pointing to the first element. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Range.h" line="79" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classRange_1a0af084ddd778771dbf33c197566d6ef5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classRange_1a9f096a55af89e52e34c591219d87d4fb" kindref="member">iterator</ref></type>
        <definition>iterator Range::end</definition>
        <argsstring>()</argsstring>
        <name>end</name>
        <briefdescription>
<para>returns the past-the-end iterator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Range.h" line="84" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classRange_1a603f42e862d92fda8adae117d9782522" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classRange_1a16092b154a168a420a2a7f752577d885" kindref="member">size_type</ref></type>
        <definition>size_type Range::size</definition>
        <argsstring>() const</argsstring>
        <name>size</name>
        <briefdescription>
<para>returns the size of the range. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Range.h" line="89" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classRange_1af44fb9e22c3e06dd7a68d49547553f97" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Range::empty</definition>
        <argsstring>() const</argsstring>
        <name>empty</name>
        <briefdescription>
<para>returns whether the range is empty. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/Range.h" line="94" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>CGAL and the STL heavily use the concepts of iterators and iterator ranges to describe linear sequences of elements, and algorithms operating on these. </para>    </briefdescription>
    <detaileddescription>
<para> The <computeroutput><ref refid="classRange" kindref="compound">Range</ref></computeroutput> concept aims at encapsulating an iterator range, by providing access to the first and past-the-end iterators of a range. The advantage is that the syntax for passing ranges is much more concise than passing two arguments separately.</para><para>Ranges come in different categories depending on the category of their iterator : mutable or constant (modifiability of the elements pointed to), and forward, bidirectional or random-access. The category can be queried using <computeroutput>std::iterator_traits</computeroutput> and the corresponding iterator type. Note that the concepts <computeroutput><ref refid="classRange" kindref="compound">Range</ref></computeroutput> and <computeroutput><ref refid="classConstRange" kindref="compound">ConstRange</ref></computeroutput> do not require anything on the category or the value type of the iterator. It must be precised in the documentation of any model of these concepts. For example, in the case of a vector of points, one would say: <emphasis>This type is a model of <computeroutput><ref refid="classRange" kindref="compound">Range</ref></computeroutput> concept, its iterator type is random-access and its value type is <computeroutput>Point</computeroutput></emphasis>.</para><para>Boost also offers the <ulink url="http://www.boost.org/libs/range/">Boost.Range library</ulink> which provides good support for ranges.</para><para>Finally, let us note that ranges, in general (especially in template context) need to be passed and returned by (const) reference for efficiency. This is a difference with iterators which are typically passed by value.</para><para><xrefsect id="refines_1_refines000004"><xreftitle>Refines</xreftitle><xrefdescription><para><computeroutput><ref refid="classConstRange" kindref="compound">ConstRange</ref></computeroutput> </para><para>Boost&apos;s <ref refid="classRange" kindref="compound">Range</ref> concept </para></xrefdescription></xrefsect></para><para><xrefsect id="hasModels_1_hasModels000004"><xreftitle>Has Models</xreftitle><xrefdescription><para>STL containers </para></xrefdescription></xrefsect></para>    </detaileddescription>
    <location file="Concepts/Range.h" line="39" column="1" bodyfile="Concepts/Range.h" bodystart="39" bodyend="98"/>
    <listofallmembers>
      <member refid="classRange_1aa22e9ddb32d1b526e7a2052bb1b636a0" prot="public" virt="non-virtual"><scope>Range</scope><name>begin</name></member>
      <member refid="classRange_1afa60203f471c5b39e5d73c1abfed49bd" prot="public" virt="non-virtual"><scope>Range</scope><name>begin</name></member>
      <member refid="classRange_1afc35da2db23057eab50b33b8bf7425bc" prot="public" virt="non-virtual"><scope>Range</scope><name>const_iterator</name></member>
      <member refid="classRange_1af44fb9e22c3e06dd7a68d49547553f97" prot="public" virt="non-virtual"><scope>Range</scope><name>empty</name></member>
      <member refid="classRange_1a0751f26452ef60d21a0aeca5a47e9f22" prot="public" virt="non-virtual"><scope>Range</scope><name>end</name></member>
      <member refid="classRange_1a0af084ddd778771dbf33c197566d6ef5" prot="public" virt="non-virtual"><scope>Range</scope><name>end</name></member>
      <member refid="classRange_1a9f096a55af89e52e34c591219d87d4fb" prot="public" virt="non-virtual"><scope>Range</scope><name>iterator</name></member>
      <member refid="classRange_1a603f42e862d92fda8adae117d9782522" prot="public" virt="non-virtual"><scope>Range</scope><name>size</name></member>
      <member refid="classRange_1a16092b154a168a420a2a7f752577d885" prot="public" virt="non-virtual"><scope>Range</scope><name>size_type</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
