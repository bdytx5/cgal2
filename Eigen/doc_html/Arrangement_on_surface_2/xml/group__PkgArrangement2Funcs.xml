<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="group__PkgArrangement2Funcs" kind="group">
    <compoundname>PkgArrangement2Funcs</compoundname>
    <title>Free Functions</title>
    <innergroup refid="group__PkgArrangement2Insert">CGAL::insert()</innergroup>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1ga339cdba93f54001be303595689002396" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class GeomTraitsA</type>
          </param>
          <param>
            <type>class GeomTraitsB</type>
          </param>
          <param>
            <type>class GeomTraitsRes</type>
          </param>
          <param>
            <type>class TopTraitsA</type>
          </param>
          <param>
            <type>class TopTraitsB</type>
          </param>
          <param>
            <type>class TopTraitsRes</type>
          </param>
          <param>
            <type>class <ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::overlay</definition>
        <argsstring>(const Arrangement_2&lt; GeomTraitsA, TopTraitsA &gt; &amp;arr1, const Arrangement_2&lt; GeomTraitsB, TopTraitsB &gt; &amp;arr2, Arrangement_2&lt; GeomTraitsRes, TopTraitsRes &gt; &amp;arr_res, OverlayTraits &amp;ovl_tr)</argsstring>
        <name>overlay</name>
        <param>
          <type>const Arrangement_2&lt; GeomTraitsA, TopTraitsA &gt; &amp;</type>
          <declname>arr1</declname>
        </param>
        <param>
          <type>const Arrangement_2&lt; GeomTraitsB, TopTraitsB &gt; &amp;</type>
          <declname>arr2</declname>
        </param>
        <param>
          <type>Arrangement_2&lt; GeomTraitsRes, TopTraitsRes &gt; &amp;</type>
          <declname>arr_res</declname>
        </param>
        <param>
          <type><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref> &amp;</type>
          <declname>ovl_tr</declname>
        </param>
        <briefdescription>
<para>Computes the overlay of two arrangements <computeroutput>arr1</computeroutput> and <computeroutput>arr2</computeroutput>, and sets the output arrangement <computeroutput>res</computeroutput> to represent the overlaid arrangement. </para>        </briefdescription>
        <detaileddescription>
<para>Computes the overlay of two input arrangement objects, and returns the overlaid arrangement. All three arrangements can be instantiated with different geometric traits classes and different Dcel classes (encapsulated in the various topology-traits classes). The geometry traits of the resulting arrangement is used to construct the resulting arrangement. This means that all the types (e.g., <computeroutput>Traits::Point_2</computeroutput>, <computeroutput>Traits::Curve_2</computeroutput>, and <computeroutput>Traits::Point_2</computeroutput>) of both input arrangements have to be convertible to the types in the resulting arrangement. A given overlay-traits object is used to properly construct the overlaid Dcel that represents the resulting arrangement.</para><para><simplesect kind="pre"><para><computeroutput>res</computeroutput> does not refer to either <computeroutput>arr1</computeroutput> or <computeroutput>arr2</computeroutput> (that is, &quot;self overlay&quot; is not supported).</para></simplesect>
<simplesect kind="pre"><para>The overlay-traits object <computeroutput>ovl_tr</computeroutput> must model the <computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> concept, which is able to construct records of the <computeroutput>ResDcel</computeroutput> class on the basis of the <computeroutput>Dcel1</computeroutput> and <computeroutput>Dcel2</computeroutput> records that induce them.</para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_overlay_2.h" line="32" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1gaddb9e44b14b27e4cf0c7bb26b27d8518" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel1</type>
          </param>
          <param>
            <type>typename Dcel2</type>
          </param>
          <param>
            <type>typename ResDcel</type>
          </param>
          <param>
            <type>typename <ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::overlay</definition>
        <argsstring>(const Arrangement_with_history_2&lt; Traits, Dcel1 &gt; &amp;arr1, const Arrangement_with_history_2&lt; Traits, Dcel2 &gt; &amp;arr2, Arrangement_with_history_2&lt; Traits, ResDcel &gt; &amp;res, OverlayTraits &amp;ovl_tr)</argsstring>
        <name>overlay</name>
        <param>
          <type>const Arrangement_with_history_2&lt; Traits, Dcel1 &gt; &amp;</type>
          <declname>arr1</declname>
        </param>
        <param>
          <type>const Arrangement_with_history_2&lt; Traits, Dcel2 &gt; &amp;</type>
          <declname>arr2</declname>
        </param>
        <param>
          <type>Arrangement_with_history_2&lt; Traits, ResDcel &gt; &amp;</type>
          <declname>res</declname>
        </param>
        <param>
          <type><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref> &amp;</type>
          <declname>ovl_tr</declname>
        </param>
        <briefdescription>
<para>Computes the overlay of two arrangements with history <computeroutput>arr1</computeroutput> and <computeroutput>arr2</computeroutput>, and sets the output arrangement with history <computeroutput>res</computeroutput> to represent the overlaid arrangement. </para>        </briefdescription>
        <detaileddescription>
<para>The function also constructs a consolidated set of curves that induce <computeroutput>res</computeroutput>.</para><para>Computes the overlay of two input arrangement objects, and returns the overlaid arrangement. All three arrangements can be instantiated with different geometric traits classes and different Dcel classes (encapsulated in the various topology-traits classes). The geometry traits of the resulting arrangement is used to construct the resulting arrangement. This means that all the types (e.g., <computeroutput>Traits::Point_2</computeroutput>, <computeroutput>Traits::Curve_2</computeroutput>, and <computeroutput>Traits::Point_2</computeroutput>) of both input arrangements have to be convertible to the types in the resulting arrangement. A given overlay-traits object is used to properly construct the overlaid Dcel that represents the resulting arrangement.</para><para><simplesect kind="pre"><para><computeroutput>res</computeroutput> does not refer to either <computeroutput>arr1</computeroutput> or <computeroutput>arr2</computeroutput> (that is, &quot;self overlay&quot; is not supported).</para></simplesect>
<simplesect kind="pre"><para>The overlay-traits object <computeroutput>ovl_tr</computeroutput> must model the <computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> concept, which is able to construct records of the <computeroutput>ResDcel</computeroutput> class on the basis of the <computeroutput>Dcel1</computeroutput> and <computeroutput>Dcel2</computeroutput> records that induce them.</para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_overlay_2.h" line="67" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1gae20b2917f6de15db9bf025f83abf8e89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename <ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::decompose</definition>
        <argsstring>(const Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, OutputIterator oi)</argsstring>
        <name>decompose</name>
        <param>
          <type>const Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>oi</declname>
        </param>
        <briefdescription>
<para>Produces the symbolic vertical decomposition of a given arrangement, performing a batched vertical ray-shooting query from all arrangement vertices, such that every vertex is associated with a pair of objects, one corresponds to the arrangement feature that lies below it, and the other corresponds to the feature that lies above it. </para>        </briefdescription>
        <detaileddescription>
<para>The output of this function can be readily used for inserting vertical walls and physically decomposing the arrangement into pseudo-trapezoids. To do this, it is convenient to process the vertices in an ascending <formula id="13">$ xy$</formula>-lexicographic order. The visible objects are therefore returned through an output iterator, which pairs each finite arrangement vertex with the two features it &quot;sees&quot;, such that the vertices are given in ascending <formula id="13">$ xy$</formula>-lexicographic order.</para><para>Produces the symbolic vertical decomposition of the <computeroutput>arr</computeroutput> arrangement. More precisely, it performs a batched vertical ray-shooting query from all arrangement vertices, such that every vertex is associated with a pair of objects, one corresponding to the arrangement feature that lies below it, while the other corresponds to the feature that lies above it. The query results are returned through the output iterator, which pairs each finite arrangement vertex with a pair of <computeroutput><ref refid="classCGAL_1_1Object" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Object</ref></computeroutput>s, the first represents the feature below the vertex, and the second represents the feature that lies above it. Each <computeroutput><ref refid="classCGAL_1_1Object" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Object</ref></computeroutput> may be one of the following: <itemizedlist>
<listitem>
<para><computeroutput>Halfedge_const_handle</computeroutput>, if the vertex is located above (or below) an edge. The given halfedge is always directed from right to left. In case there is no concrete edge below (or above) the vertex, and the arrangement is unbounded, then the object returned is a <emphasis>fictitious</emphasis> halfedge. </para></listitem>
<listitem>
<para><computeroutput>Face_const_handle</computeroutput>, in case there is no edge below (or above) the vertex, and the arrangement is bounded. </para></listitem>
<listitem>
<para><computeroutput>Vertex_const_handle</computeroutput>, in case the vertex is located vertically above (or below) another arrangement vertex. </para></listitem>
<listitem>
<para>An empty object, in case the vertex is the top end-vertex of a vertical edge, we define there is no feature below it. Similarly, if it is the bottom end-vertex of a vertical edge, we define that there is no feature above it. </para></listitem>
</itemizedlist>
The function returns a past-the-end iterator for its output sequence.</para><para><bold>Requirements</bold><linebreak/>
</para><para><computeroutput>OutputIterator::value_type</computeroutput> must be <computeroutput>pair&lt;Arrangement_2::Vertex_const_handle, pair&lt;<ref refid="classCGAL_1_1Object" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Object</ref>, <ref refid="classCGAL_1_1Object" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Object</ref>&gt; &gt;</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_vertical_decomposition_2.h" line="53" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1gab3d781b13fdf51ca9579ad13c2a32620" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class GeomTraits</type>
          </param>
          <param>
            <type>class TopTraits</type>
          </param>
          <param>
            <type>class Curve</type>
          </param>
          <param>
            <type>class PointLocation</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::do_intersect</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeomTraits, TopTraits &gt; &amp;arr, const Curve &amp;c, const PointLocation &amp;pl)</argsstring>
        <name>do_intersect</name>
        <param>
          <type>Arrangement_on_surface_2&lt; GeomTraits, TopTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const Curve &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
        </param>
        <briefdescription>
<para>Checks if a given curve or <formula id="2">$ x$</formula>-monotone curve intersects an existing arrangement&apos;s edges or vertices. </para>        </briefdescription>
        <detaileddescription>
<para>If the give curve is not an <formula id="2">$ x$</formula>-monotone curve then the function subdivides the given curve into <formula id="2">$ x$</formula>-monotone subcurves and isolated vertices . Each subcurve is in turn checked for intersection. The function uses the zone algorithm to check if the curve intersects the arrangement. First, the curve&apos;s left endpoint is located. Then, its zone is computed starting from its left endpoint location. The zone computation terminates when an intersection with an arrangement&apos;s edge/vertex is found or when the right endpoint is reached.</para><para>A given point-location object is used for locating the left endpoint of the given curve in the existing arrangement. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt; &gt;</computeroutput>.</para><para>Checks if the given curve or <formula id="2">$ x$</formula>-monotone curve <computeroutput>c</computeroutput> intersects edges or vertices of the existing arrangement <computeroutput>arr</computeroutput>. <simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para></simplesect>
<bold>Requirements</bold><linebreak/>
</para><para><itemizedlist>
<listitem>
<para>If <computeroutput>c</computeroutput> is <formula id="2">$ x$</formula>-monotone then the instantiated <computeroutput>GeomTraits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. If <computeroutput>c</computeroutput> is a curve then the instantiated <computeroutput>GeomTraits</computeroutput> class must model the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept. That is, it should define the <computeroutput>Curve_2</computeroutput> type, and support its subdivision into <formula id="2">$ x$</formula>-monotone subcurves (and perhaps isolated points). </para></listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para></listitem>
</itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="1108" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type>Arrangement_2&lt; Traits, Dcel &gt;::Halfedge_handle</type>
        <definition>Arrangement_2&lt;Traits,Dcel&gt;::Halfedge_handle CGAL::insert_non_intersecting_curve</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::X_monotone_curve_2 &amp;xc, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert_non_intersecting_curve</name>
        <param>
          <type>Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::X_monotone_curve_2 &amp;</type>
          <declname>xc</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts a given <formula id="2">$ x$</formula>-monotone curve into a given arrangement, where the interior of the given curve is disjoint from all existing arrangement vertices and edges. </para>        </briefdescription>
        <detaileddescription>
<para>Under this assumption, it is possible to locate the endpoints of the given curve in the arrangement, and use one of the specialized insertion member-functions of the arrangement according to the results. The insertion operations creates a single new edge, that is, two twin halfedges, and the function returns a handle for the one directed lexicographically in increasing order (from left to right).</para><para>A given point-location object is used for answering the two point-location queries on the given curve endpoints. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt; &gt;</computeroutput>.</para><para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para></simplesect>
<bold>Requirements</bold><linebreak/>
</para><para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the restricted <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, as no intersections are computed. </para></listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput> must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para></listitem>
</itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="1146" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1gad4aa37a4e938747028690579fb703d67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert_non_intersecting_curves</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, InputIterator first, InputIterator last)</argsstring>
        <name>insert_non_intersecting_curves</name>
        <param>
          <type>Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Inserts a set of <formula id="2">$ x$</formula>-monotone curves in a given range into a given arrangement. </para>        </briefdescription>
        <detaileddescription>
<para>The insertion is performed in an aggregated manner, using the sweep-line algorithm. The input curves should be pairwise disjoint in their interior and pairwise interior-disjoint from all existing arrangement vertices and edges.</para><para><bold>Requirements</bold><linebreak/>
</para><para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, as no intersections are computed. </para></listitem>
<listitem>
<para><computeroutput>InputIterator::value_type</computeroutput> must be <computeroutput>Traits::X_monotone_curve_2</computeroutput> </para></listitem>
</itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="1170" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1ga13c103c1cea5249ca37ce7e0be4d97e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type>Arrangement_2&lt; Traits, Dcel &gt;::Vertex_handle</type>
        <definition>Arrangement_2&lt;Traits,Dcel&gt;::Vertex_handle CGAL::insert_point</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::Point_2 &amp;p, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert_point</name>
        <param>
          <type>Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts a given point into a given arrangement. </para>        </briefdescription>
        <detaileddescription>
<para>It uses a given point-location object to locate the given point in the given arrangement. If the point conincides with an existing vertex, there is nothing left to do; if it lies on an edge, the edge is split at the point. Otherwise, the point is contained inside a face, and is inserted as an isolated vertex inside this face. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt; &gt;</computeroutput>. In either case, the function returns a handle for the vertex associated with the point.</para><para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para></simplesect>
<bold>Requirements</bold><linebreak/>
</para><para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, and support the splitting functionality. </para></listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para></listitem>
</itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="1207" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1gabcb9bc6c5859edf3fbc1390e60e32a17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::is_valid</definition>
        <argsstring>(const Arrangement_2&lt; Traits, Dcel &gt; &amp;arr)</argsstring>
        <name>is_valid</name>
        <param>
          <type>const Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <briefdescription>
<para>Checks the validity of a given arrangement. </para>        </briefdescription>
        <detaileddescription>
<para>Invokes the member function <computeroutput><ref refid="group__PkgArrangement2Funcs_1gabcb9bc6c5859edf3fbc1390e60e32a17" kindref="member">arr.is_valid()</ref></computeroutput> to verify the topological correctness of the arrangement. Then it performs additional validity tests. It checks that all <formula id="2">$ x$</formula>-monotone curves associated with arrangement edges are pairwise disjoint in their interior. Then it makes sure that all holes and all isolated vertices are located within the proper arrangement faces. Note that the test carried out by this function may take a considerable amount of time; it is recommended to be used only for debugging purposes.</para><para><bold>Requirements</bold><linebreak/>
</para><para>The instantiated traits class must model the concept <computeroutput>ArranagmentXMonotoneTraits_2</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="1233" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1ga324fdf8354e7812fe0e1c0e5ac14196c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>Arrangement_2&lt; Traits, Dcel &gt;::Face_handle</type>
        <definition>Arrangement_2&lt;Traits,Dcel&gt;::Face_handle CGAL::remove_edge</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, typename Arrangement_2&lt; Traits, Dcel &gt;::Halfedge_handle e)</argsstring>
        <name>remove_edge</name>
        <param>
          <type>Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename Arrangement_2&lt; Traits, Dcel &gt;::Halfedge_handle</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. </para>        </briefdescription>
        <detaileddescription>
<para>Once the edge is removed, if the vertices associated with its endpoints become isolated, they are removed as well. The call <computeroutput>remove_edge(arr, e)</computeroutput> is equivalent to the call <computeroutput>arr.remove_edge (e, true, true)</computeroutput>. However, this free function requires that <computeroutput>Traits</computeroutput> be a model of the refined concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>, which requires merge operations on <formula id="2">$ x$</formula>-monotone curves. If one of the end-vertices of the given edge becomes redundant after the edge is removed (see <computeroutput><ref refid="group__PkgArrangement2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">remove_vertex()</ref></computeroutput> for the definition of a redundant vertex), it is removed, and its incident edges are merged. If the edge-removal operation causes two faces to merge, the merged face is returned. Otherwise, the face to which the edge was incident before the removal is returned.</para><para><bold>Requirements</bold><linebreak/>
</para><para><itemizedlist>
<listitem>
<para>The instantiated traits class must model the concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>. </para></listitem>
</itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="1264" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::remove_vertex</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, typename Arrangement_2&lt; Traits, Dcel &gt;::Vertex_handle v)</argsstring>
        <name>remove_vertex</name>
        <param>
          <type>Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename Arrangement_2&lt; Traits, Dcel &gt;::Vertex_handle</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Attempts to removed a given vertex from a given arrangement. </para>        </briefdescription>
        <detaileddescription>
<para>The vertex can be removed if it is either an isolated vertex, (and has no incident edge,) or if it is a <emphasis>redundant</emphasis> vertex. That is, it has exactly two incident edges, whose associated curves can be merged to form a single <formula id="2">$ x$</formula>-monotone curve. The function returns a boolean value that indicates whether it succeeded removing the vertex from the arrangement.</para><para><bold>Requirements</bold><linebreak/>
</para><para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept and support the merging functionality. </para></listitem>
</itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="1290" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1ga49aa156968945f5533a2b5d9897ca659" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class GeomTraits</type>
          </param>
          <param>
            <type>class TopTraits</type>
          </param>
          <param>
            <type>class <ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          </param>
          <param>
            <type>class PointLocation</type>
          </param>
        </templateparamlist>
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::zone</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeomTraits, TopTraits &gt; &amp;arr, const typename GeomTraits::X_monotone_curve_2 &amp;c, OutputIterator oi, const PointLocation &amp;pl)</argsstring>
        <name>zone</name>
        <param>
          <type>Arrangement_on_surface_2&lt; GeomTraits, TopTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename GeomTraits::X_monotone_curve_2 &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>oi</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
        </param>
        <briefdescription>
<para>Compute the zone of the given <formula id="2">$ x$</formula>-monotone curve in the existing arrangement. </para>        </briefdescription>
        <detaileddescription>
<para>Meaning, it output the arrangement&apos;s vertices, edges and faces that the <formula id="2">$ x$</formula>-monotone curve intersects. The order of the objects is the order that they are discovered when traversing the <formula id="2">$ x$</formula>-monotone curve from left to right.</para><para>A given point-location object is used for answering point-location queries during the insertion process. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt; &gt;</computeroutput>.</para><para>Compute the zone of the given <formula id="2">$ x$</formula>-monotone curve <computeroutput>c</computeroutput> in the arrangement <computeroutput>arr</computeroutput>. <simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para></simplesect>
<bold>Requirements</bold><linebreak/>
</para><para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>GeomTraits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. </para></listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para></listitem>
</itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="1323" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangement2Funcs_1ga9a27533ff4ade0c60978812e517b89d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Traits</type>
          </param>
          <param>
            <type>class Dcel</type>
          </param>
        </templateparamlist>
        <type>Size</type>
        <definition>Size CGAL::remove_curve</definition>
        <argsstring>(Arrangement_with_history_2&lt; Traits, Dcel &gt; &amp;arr, typename Arrangement_with_history_2&lt; Traits, Dcel &gt;::Curve_handle ch)</argsstring>
        <name>remove_curve</name>
        <param>
          <type>Arrangement_with_history_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename Arrangement_with_history_2&lt; Traits, Dcel &gt;::Curve_handle</type>
          <declname>ch</declname>
        </param>
        <briefdescription>
<para>Removes a given curve from a given arrangement. </para>        </briefdescription>
        <detaileddescription>
<para>The curve is specified by its handle <computeroutput>ch</computeroutput>, from the arrangement <computeroutput>arr</computeroutput>, by deleting all the edges it induces. The function returns the number of deleted edges. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_with_history_2.h" line="321" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
