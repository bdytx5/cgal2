<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Arrangements"/><anchor id="index_1chapterArrangement_on_surface_2"/></para><para><simplesect kind="authors"><para>Ron Wein, Eric Berberich, Efi Fogel, Dan Halperin, Michael Hemmer, Oren Salzman, and Baruch Zukerman</para></simplesect>
</para><sect1 id="index_1arr_secintro">
<title>Introduction</title>
<para>Given a set <formula id="0">$ \cal C$</formula> of planar curves, the <emphasis>arrangement</emphasis> <formula id="1">$ \cal A(\cal C)$</formula> is the subdivision of the plane into zero-dimensional, one-dimensional and two-dimensional cells, called <emphasis>vertices</emphasis>, <emphasis>edges</emphasis> and <emphasis>faces</emphasis>, respectively induced by the curves in <formula id="0">$ \cal C$</formula>. Arrangements are ubiquitous in the computational-geometry literature and have many applications; see, e.g., <ref refid="citelist_1CITEREF_as-aa-00" kindref="member">[1]</ref>, <ref refid="citelist_1CITEREF_cgal:h-a-04" kindref="member">[5]</ref>.</para><para>The curves in <formula id="0">$ \cal C$</formula> can intersect each other (a single curve may also be self-intersecting or may be comprised of several disconnected branches) and are not necessarily <formula id="2">$ x$</formula>-monotone.A continuous planar curve <formula id="3">$ C$</formula> is <emphasis> <formula id="2">$ x$</formula>-monotone</emphasis> if every vertical line intersects it at most once. For example, a non-vertical line segment is always <formula id="2">$ x$</formula>-monotone and so is the graph of any continuous function <formula id="4">$ y = f(x)$</formula>. For convenience, we treat vertical line segments as <emphasis>weakly <formula id="2">$ x$</formula>-monotone</emphasis>, as there exists a single vertical line that overlaps them. A circle of radius <formula id="5">$ r$</formula> centered at <formula id="6">$ (x_0, y_0)$</formula> is not <formula id="2">$ x$</formula>-monotone, as the vertical line <formula id="7">$ x = x_0$</formula> intersects it at <formula id="8">$ (x_0, y_0 - r)$</formula> and at <formula id="9">$ (x_0, y_0 + r)$</formula>. We construct a collection <formula id="10">$ \cal C&apos;&apos;$</formula> of <formula id="2">$ x$</formula>-monotone subcurves that are pairwise disjoint in their interiors in two steps as follows. First, we decompose each curve in <formula id="0">$ \cal C$</formula> into maximal <formula id="2">$ x$</formula>-monotone subcurves (and possibly isolated points), obtaining the collection <formula id="11">$ \cal C&apos;$</formula>. Note that an <formula id="2">$ x$</formula>-monotone curve cannot be self-intersecting. Then, we decompose each curve in <formula id="11">$ \cal C&apos;$</formula> into maximal connected subcurves not intersecting any other curve (or point) in <formula id="11">$ \cal C&apos;$</formula>. The collection <formula id="10">$ \cal C&apos;&apos;$</formula> may also contain isolated points, if the curves of <formula id="0">$ \cal C$</formula> contain such points. The arrangement induced by the collection <formula id="10">$ \cal C&apos;&apos;$</formula> can be conveniently embedded as a planar graph, whose vertices are associated with curve endpoints or with isolated points, and whose edges are associated with subcurves. It is easy to see that <formula id="12">$ \cal A(\cal C) = \cal A(\cal C&apos;&apos;)$</formula>. This graph can be represented using a <emphasis>doubly-connected edge list</emphasis> data-structure (Dcel for short), which consists of containers of vertices, edges and faces and maintains the incidence relations among these objects.</para><para>The main idea behind the Dcel data-structure is to represent each edge using a pair of directed <emphasis>halfedges</emphasis>, one going from the <formula id="13">$ xy$</formula>-lexicographically smaller (left) endpoint of the curve toward its the <formula id="13">$ xy$</formula>-lexicographically larger (right) endpoint, and the other, known as its <emphasis>twin</emphasis> halfedge, going in the opposite direction. As each halfedge is directed, we say it has a <emphasis>source</emphasis> vertex and a <emphasis>target</emphasis> vertex. Halfedges are used to separate faces, and to connect vertices (with the exception of <emphasis>isolated vertices</emphasis>, which are unconnected).</para><para>If a vertex <formula id="14">$ v$</formula> is the target of a halfedge <formula id="15">$ e$</formula>, we say that <formula id="14">$ v$</formula> and <formula id="15">$ e$</formula> are <emphasis>incident</emphasis> to each other. The halfedges incident to a vertex <formula id="14">$ v$</formula> form a circular list oriented in a clockwise order around this vertex. (An isolated vertex has no incident halfedges.)</para><para>Each halfedge <formula id="15">$ e$</formula> stores a pointer to its <emphasis>incident face</emphasis>, which is the face lying to its left. Moreover, every halfedge is followed by another halfedge sharing the same incident face, such that the target vertex of the halfedge is the same as the source vertex of the next halfedge. The halfedges are therefore connected in circular lists, and form chains, such that all edges of a chain are incident to the same face and wind along its boundary. We call such a chain a <emphasis>connected component of the boundary</emphasis> (or <emphasis>CCB</emphasis> for short).</para><para>The unique CCB of halfedges winding in a counterclockwise orientation along a face boundary is referred to as the <emphasis>outer CCB</emphasis> of the face. For the time being let us consider only arrangements of bounded curves, such that exactly one unbounded face exists in every arrangement. The unbounded face does not have an outer boundary. Any other connected component of the boundary of the face is called a <emphasis>hole</emphasis> (or <emphasis>inner CCB</emphasis>), and can be represented as a circular chain of halfedges winding in a clockwise orientation around it. Note that a hole does not necessarily correspond to a single face, as it may have no area, or alternatively it may consist of several connected faces. Every face can have several holes contained in its interior (or no holes at all). In addition, every face may contain isolated vertices in its interior. See <ref refid="index_1fig__arr_figseg_dcel" kindref="member">fig__arr_figseg_dcel</ref> for an illustration of the various Dcel features. For more details on the Dcel data structure see <ref refid="citelist_1CITEREF_bkos-cgaa-00" kindref="member">[3]</ref> Chapter 2.</para><para><anchor id="index_1fig__arr_figseg_dcel"/><image type="html" name="arr_segs.png"></image>
 <image type="latex" name="arr_segs.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figseg_dcel" kindref="member">fig__arr_figseg_dcel</ref> An arrangement of interior-disjoint line segments with some of the Dcel records that represent it. The unbounded face <formula id="16">$ f_0$</formula> has a single connected component that forms a hole inside it, and this hole is comprised if several faces. The half-edge <formula id="15">$ e$</formula> is directed from its source vertex <formula id="17">$ v_1$</formula> to its target vertex <formula id="18">$ v_2$</formula>. This edge, together with its twin <formula id="19">$ e&apos;$</formula>, correspond to a line segment that connects the points associated with <formula id="17">$ v_1$</formula> and <formula id="18">$ v_2$</formula> and separates the face <formula id="20">$ f_1$</formula> from <formula id="21">$ f_2$</formula>. The predecessor <formula id="22">$ e_{\rm prev}$</formula> and successor <formula id="23">$ e_{\rm next}$</formula> of <formula id="15">$ e$</formula> are part of the chain that form the outer boundary of the face <formula id="21">$ f_2$</formula>. The face <formula id="20">$ f_1$</formula> has a more complicated structure as it contains two holes in its interior: One hole consists of two adjacent faces <formula id="24">$ f_3$</formula> and <formula id="25">$ f_4$</formula>, while the other hole is comprised of two edges. <formula id="20">$ f_1$</formula> also contains two isolated vertices <formula id="26">$ u_1$</formula> and <formula id="27">$ u_2$</formula> in its interior.  <linebreak/>
</para><para>The <formula id="2">$ x$</formula>-monotone curves of an arrangement are embedded in an rectangular two-dimensional area called the parameter space.The term parameter space stems from a major extension the arrangement package is going through to support arrangements embedded on certain two-dimensional parametric surfaces in three-dimensions (or higher). The parameter space is defined as <formula id="28">$ X \times Y$</formula>, where <formula id="29">$ X$</formula> and <formula id="30">$ Y$</formula> are open, half-open, or closed intervals with endpoints in the compactified real line <formula id="31">$ \mathbb{R} \cup \{-\infty,+\infty\}$</formula>. Let <formula id="32">$ b_l$</formula>, <formula id="33">$ b_r$</formula>, <formula id="34">$ b_b$</formula>, and <formula id="35">$ b_t$</formula> denote the endpoints of <formula id="29">$ X$</formula> and <formula id="30">$ Y$</formula>, respectively. We typically refer to these values as the left, right, bottom, and top sides of the boundary of the parameter space. If the parameter space is, for example, the entire compactified plane, which is currently the only option supported by the package, <formula id="36">$ b_l = b_b = -\infty$</formula> and <formula id="37">$ b_r = b_t = +\infty$</formula>.</para><para>The rest of this chapter is organized as follows: In Section <ref refid="index_1arr_secarr_class" kindref="member">The Main Arrangement Class</ref> we review in detail the interface of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class-template, which is the central component in the arrangement package. In Section <ref refid="index_1arr_secqueries" kindref="member">Issuing Queries on an Arrangement</ref> we show how queries on an arrangement can be issued. In Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions in the Arrangement Package</ref> we review some important free (global) functions that operate on arrangements, the most important ones being the free insertion-functions. Section <ref refid="index_1arr_sectraits" kindref="member">Traits Classes</ref> contains detailed descriptions of the various geometric traits classes included in the arrangement package. Using these traits classes it is possible to construct arrangements of different families of curves. In Section <ref refid="index_1arr_secnotif" kindref="member">The Notification Mechanism</ref> we review the notification mechanism that allows external classes to keep track of the changes that an arrangement instance goes through. Section <ref refid="index_1arr_secex_dcel" kindref="member">Extending the DCEL</ref> explains how to extend the Dcel records, to store extra data with them, and to efficiently update this data. In Section <ref refid="index_1arr_secoverlay" kindref="member">Overlaying Arrangements</ref> we introduce the fundamental operation of overlaying two arrangements. Section <ref refid="index_1arr_secarr_with_hist" kindref="member">Storing the Curve History</ref> describes the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> class-template that extends the arrangement by storing additional history records with its curves. Finally, in Section <ref refid="index_1arr_secio" kindref="member">Input/Output Streams</ref> we review the arrangement input/output functions.</para></sect1>
<sect1 id="index_1arr_secarr_class">
<title>The Main Arrangement Class</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> is the main class in the arrangement package. It is used to represent planar arrangements and it provides the interface needed to construct them, traverse them, and maintain them. An arrangement is defined by a geometric <emphasis>traits</emphasis> class that determines the family of planar curves that form the arrangement, and a Dcel class, which represents the <emphasis>topological structure</emphasis> of the planar subdivision. It supplies a minimal set of geometric operations (predicates and constructions) required to construct and maintain the arrangement and to operate on it.</para><para>The design of the arrangement package is guided by the need to separate between the representation of the arrangements and the various geometric algorithms that operate on them, and by the need to separate between the topological and geometric aspects of the planar subdivision. The separation is exhibited by the two template parameters of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> template: <itemizedlist>
<listitem>
<para>The <computeroutput>Traits</computeroutput> template-parameter should be instantiated with a model of the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept and optionally additional geometry traits concepts. A model of the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept defines the types of <formula id="2">$ x$</formula>-monotone curves and two-dimensional points, namely <computeroutput>X_monotone_curve_2</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput>, respectively, and supports basic geometric predicates on them.</para><para>In the first sections of this chapter we always use <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> as our traits class, to construct arrangements of line segments. However, the arrangement package contains several other traits classes that can handle other types of curves, such as polylines (continuous piecewise-linear curves), conic arcs, and arcs of rational functions. We exemplify the usage of these traits classes in Section <ref refid="index_1arr_sectraits" kindref="member">Traits Classes</ref>. </para></listitem>
<listitem>
<para>The <computeroutput>Dcel</computeroutput> template-parameter should be instantiated with a class that is a model of the <computeroutput><ref refid="classArrangementDcel" kindref="compound">ArrangementDcel</ref></computeroutput> concept. The value of this parameter is <computeroutput><ref refid="classCGAL_1_1Arr__default__dcel" kindref="compound">Arr_default_dcel</ref>&lt;Traits&gt;</computeroutput> by default. However, in many applications it is necessary to extend the Dcel features; see Section <ref refid="index_1arr_secex_dcel" kindref="member">Extending the DCEL</ref> for further explanations and examples. </para></listitem>
</itemizedlist>
</para><sect2 id="index_1Arrangement_on_surface_2ASimpleProgram">
<title>A Simple Program</title>
<para><image type="html" name="triangle.png"></image>
 <image type="latex" name="triangle.png"></image>
</para><para>The simple program listed below constructs a planar map of three line segments forming a triangle. The constructed arrangement is instantiated with the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> traits class to handle segments only. The resulting arrangement consists of two faces, a bounded triangular face and the unbounded face. The program is not very useful as it is, since it ends immediately after the arrangement is constructed. We give more enhanced examples in the rest of this chapter.</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="MP__Float_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/MP_Float.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Quotient_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Quotient.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Quotient&lt;CGAL::MP_Float&gt;</ref><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/>cv[3];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>p1<sp/>(0,<sp/>0),<sp/>p2<sp/>(0,<sp/>4),<sp/>p3<sp/>(4,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cv[0]<sp/>=<sp/>Segment_2<sp/>(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cv[1]<sp/>=<sp/>Segment_2<sp/>(p2,<sp/>p3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cv[2]<sp/>=<sp/>Segment_2<sp/>(p3,<sp/>p1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref><sp/>(arr,<sp/>&amp;cv[0],<sp/>&amp;cv[3]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssectraverse">
<title>Traversing the Arrangement</title>
<para>The simplest and most fundamental arrangement operations are the various traversal methods, which allow users to systematically go over the relevant features of the arrangement at hand.</para><para>As mentioned above, the arrangement is represented as a Dcel, which stores three containers of vertices, halfedges and faces. Thus, the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class supplies iterators for these containers. For example, the methods <computeroutput>vertices_begin()</computeroutput> and <computeroutput>vertices_end()</computeroutput> return <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1ac4a88fd2ca22b490454e4f425005e5c4" kindref="member">Arrangement_2::Vertex_iterator</ref></computeroutput> objects that define the valid range of arrangement vertices. The value type of this iterator is <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1_1Vertex" kindref="compound">Arrangement_2::Vertex</ref></computeroutput>. Moreover, the vertex-iterator type is equivalent to <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a7dac3eed2224beadf3658495bc671c49" kindref="member">Arrangement_2::Vertex_handle</ref></computeroutput>, which serves as a pointer to a vertex. As we show next, all functions related to arrangement features accept handle types as input parameters and return handle types as their output.</para><para>In addition to the iterators for arrangement vertices, halfedges and faces, the arrangement class also provides <computeroutput>edges_begin()</computeroutput> and <computeroutput>edges_end()</computeroutput> that return <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a9b3a4b116e66f66bcd69215fa3f513f9" kindref="member">Arrangement_2::Edge_iterator</ref></computeroutput> objects for traversing the arrangement edges. Note that the value type of this iterator is <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1_1Halfedge" kindref="compound">Arrangement_2::Halfedge</ref></computeroutput>, representing one of the twin halfedges that represent the edge.</para><para>All iterator, circulatorA <emphasis>circulator</emphasis> is used to traverse a circular list, such as the list of halfedges incident to a vertex - see below. and handle types also have non-mutable (<emphasis>const</emphasis>) counterparts. These non-mutable iterators are useful to traverse an arrangement without changing it. For example, the arrangement has a non-constant member function called <computeroutput>vertices_begin()</computeroutput> that returns a <computeroutput>Vertex_iterator</computeroutput> object and another const member function that returns a <computeroutput>Vertex_const_iterator</computeroutput> object. In fact, all methods listed in this section that return an iterator, a circulator or a handle have non-mutable counterparts. It should be noted that, for example, <computeroutput>Vertex_handle</computeroutput> can be readily converted into a <computeroutput>Vertex_const_handle</computeroutput>, but not vice-verse.</para><para>Conversion of a non-mutable handle to a corresponding mutable handle are nevertheless possible, and can be performed using the static function <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a11be9c67d85886e197306dc47abab37a" kindref="member">Arrangement_2::non_const_handle()</ref></computeroutput> (see, e.g., Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>). There are three variant of this function, one for each type of handle.</para></sect2>
<sect2 id="index_1arr_sssectr_vertex">
<title>Traversal Methods for an Arrangement Vertex</title>
<para>A vertex is always associated with a geometric entity, namely with a <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> object, which can be obtained by the <computeroutput>point()</computeroutput> method of the <computeroutput>Vertex</computeroutput> class nested within <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput>.</para><para>The <computeroutput>is_isolated()</computeroutput> method determines whether a vertex is isolated or not. Recall that the halfedges incident to a non-isolated vertex, namely the halfedges that share a common target vertex, form a circular list around this vertex. The <computeroutput>incident_halfedges()</computeroutput> method returns a circulator of type <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a1490b8301d182e9d46e0c4e45cff6aa9" kindref="member">Arrangement_2::Halfedge_around_vertex_circulator</ref></computeroutput> that enables the traversal of this circular list in a clockwise direction. The value type of this circulator is <computeroutput>Halfedge</computeroutput>.</para><para>The following function prints all the neighbors of a given arrangement vertex (assuming that the <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> type can be inserted into the standard output using the <computeroutput>&lt;&lt;</computeroutput> operator). The arrangement type is the same as in the simple example above.</para><para><programlisting><codeline><highlight class="normal">void<sp/>print_neighboring_vertices<sp/>(Arrangement_2::Vertex_const_handle<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(v-&gt;is_isolated())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;The<sp/>vertex<sp/>(&quot;<sp/>&lt;&lt;<sp/>v-&gt;point()<sp/>&lt;&lt;<sp/>&quot;)<sp/>is<sp/>isolated&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Halfedge_around_vertex_const_circulator<sp/>first,<sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>first<sp/>=<sp/>curr<sp/>=<sp/>v-&gt;incident_halfedges();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;The<sp/>neighbors<sp/>of<sp/>the<sp/>vertex<sp/>(&quot;<sp/>&lt;&lt;<sp/>v-&gt;point()<sp/>&lt;&lt;<sp/>&quot;)<sp/>are:&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>do<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Note<sp/>that<sp/>the<sp/>current<sp/>halfedge<sp/>is<sp/>directed<sp/>from<sp/>u<sp/>to<sp/>v:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arrangement_2::Vertex_const_handle<sp/>u<sp/>=<sp/>curr-&gt;source();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;<sp/>(&quot;<sp/>&lt;&lt;<sp/>u-&gt;point()<sp/>&lt;&lt;<sp/>&quot;)&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>while<sp/>(++curr<sp/>!=<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>In case of an isolated vertex, it is possible to obtain the face that contains this vertex using the <computeroutput>face()</computeroutput> method.</para></sect2>
<sect2 id="index_1arr_sssectr_halfedge">
<title>Traversal Methods for an Arrangement Halfedge</title>
<para>Each arrangement edge, realized as a pair of twin halfedges, is associated with an <computeroutput>X_monotone_curve_2</computeroutput> object, which can be obtained by the <computeroutput>curve()</computeroutput> method of the <computeroutput>Halfedge</computeroutput> class nested in the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class.</para><para>The <computeroutput>source()</computeroutput> and <computeroutput>target()</computeroutput> methods return handles to the halfedge source and target vertices respectively. We can obtain a handle to the twin halfedge using the <computeroutput>twin()</computeroutput> method. From the definition of halfedges, it follows that if <computeroutput>he</computeroutput> is a halfedge handle, then: <itemizedlist>
<listitem>
<para><computeroutput>he-&gt;curve()</computeroutput> is equivalent to <computeroutput>he-&gt;twin()-&gt;curve()</computeroutput>, </para></listitem>
<listitem>
<para><computeroutput>he-&gt;source()</computeroutput> is equivalent to <computeroutput>he-&gt;twin()-&gt;target()</computeroutput>, and </para></listitem>
<listitem>
<para><computeroutput>he-&gt;target()</computeroutput> is equivalent to <computeroutput>he-&gt;twin()-&gt;source()</computeroutput>. </para></listitem>
</itemizedlist>
</para><para>Every halfedge has an incident face that lies to its left, which can be obtained by the <computeroutput>face()</computeroutput> method. Recall that a halfedge is always one link in a connected chain of halfedges that share the same incident face, known as a <emphasis>CCB</emphasis>. The <computeroutput><ref refid="group__STLAlgos_1ga6c3790809028471b1eacccb0d714d040" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">prev()</ref></computeroutput> and <computeroutput><ref refid="group__STLAlgos_1gad4dbc8daf3c0e2201f4972eb9eea404d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">next()</ref></computeroutput> methods return handles to the previous and next halfedges in the CCB respectively.</para><para>As the CCB is a circular list of halfedges, it is only natural to traverse it using a circulator. The <computeroutput>ccb()</computeroutput> method returns a <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1ab4a594c193ca09a672dbe2fcafa090e9" kindref="member">Arrangement_2::Ccb_halfedge_circulator</ref></computeroutput> object for the halfedges along the CCB.</para><para>The function <computeroutput>print_ccb()</computeroutput> listed below prints all <formula id="2">$ x$</formula>-monotone curves along a given CCB (assuming that the <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> and the <computeroutput>X_monotone_curve_2</computeroutput> types can be inserted into the standard output using the <computeroutput>&lt;&lt;</computeroutput> operator).</para><para><programlisting><codeline><highlight class="normal">void<sp/>print_ccb<sp/>(Arrangement_2::Ccb_halfedge_const_circulator<sp/>circ)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ccb_halfedge_const_circulator<sp/>curr<sp/>=<sp/>circ;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;(&quot;<sp/>&lt;&lt;<sp/>curr-&gt;source()-&gt;point()<sp/>&lt;&lt;<sp/>&quot;)&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>do<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arrangement_2::Halfedge_const_handle<sp/>he<sp/>=<sp/>curr-&gt;handle();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;<sp/>[&quot;<sp/>&lt;&lt;<sp/>he-&gt;curve()<sp/>&lt;&lt;<sp/>&quot;]<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;(&quot;<sp/>&lt;&lt;<sp/>he-&gt;target()-&gt;point()<sp/>&lt;&lt;<sp/>&quot;)&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>while<sp/>(++curr<sp/>!=<sp/>circ);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_sssectr_face">
<title>Traversal Methods for an Arrangement Face</title>
<para>An arrangement of bounded curves always has a single unbounded face. The function <computeroutput>unbounded_face()</computeroutput> returns a handle to this face. (Note that an empty arrangement contains nothing <emphasis>but</emphasis> the unbounded face.)</para><para>Given a <computeroutput>Face</computeroutput> object, we can use the <computeroutput>is_unbounded()</computeroutput> method to determine whether it is unbounded. Bounded faces have an outer CCB, and the <computeroutput>outer_ccb()</computeroutput> method returns a circulator for the halfedges along this CCB. Note that the halfedges along this CCB wind in a counterclockwise orientation around the outer boundary of the face.</para><para>A face can also contain disconnected components in its interior, namely holes and isolated vertices: <itemizedlist>
<listitem>
<para>The <computeroutput>holes_begin()</computeroutput> and <computeroutput>holes_end()</computeroutput> methods return <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a13420f4fd95338b0384ff309f3a15153" kindref="member">Arrangement_2::Hole_iterator</ref></computeroutput> iterators that define the range of holes inside the face. The value type of this iterator is <computeroutput>Ccb_halfedge_circulator</computeroutput>, defining the CCB that winds in a clockwise orientation around a hole. </para></listitem>
<listitem>
<para>The <computeroutput>isolated_vertices_begin()</computeroutput> and <computeroutput>isolated_vertices_end()</computeroutput> methods return <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a1e0b89ad746d728e06ed8b62640d3d20" kindref="member">Arrangement_2::Isolated_vertex_iterator</ref></computeroutput> iterators that define the range of isolated vertices inside the face. The value type of this iterator is <computeroutput>Vertex</computeroutput>. </para></listitem>
</itemizedlist>
</para><para>The function <computeroutput>print_face()</computeroutput> listed below prints the outer and inner boundaries of a given face, using the function <computeroutput>print_ccb()</computeroutput>, which was introduced in the previous subsection.</para><para><programlisting><codeline><highlight class="normal">void<sp/>print_face<sp/>(Arrangement_2::Face_const_handle<sp/>f)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Print<sp/>the<sp/>outer<sp/>boundary.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(f-&gt;is_unbounded())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;Unbounded<sp/>face.<sp/>&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;Outer<sp/>boundary:<sp/>&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_ccb<sp/>(f-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Print<sp/>the<sp/>boundary<sp/>of<sp/>each<sp/>of<sp/>the<sp/>holes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Hole_const_iterator<sp/>hi;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>index<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(hi<sp/>=<sp/>f-&gt;holes_begin();<sp/>hi<sp/>!=<sp/>f-&gt;holes_end();<sp/>++hi,<sp/>++index)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;<sp/>Hole<sp/>#&quot;<sp/>&lt;&lt;<sp/>index<sp/>&lt;&lt;<sp/>&quot;:<sp/>&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_ccb<sp/>(*hi);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Print<sp/>the<sp/>isolated<sp/>vertices.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Isolated_vertex_const_iterator<sp/>iv;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(iv<sp/>=<sp/>f-&gt;isolated_vertices_begin(),<sp/>index<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iv<sp/>!=<sp/>f-&gt;isolated_vertices_end();<sp/>++iv,<sp/>++index){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;<sp/>Isolated<sp/>vertex<sp/>#&quot;<sp/>&lt;&lt;<sp/>index<sp/>&lt;&lt;<sp/>&quot;:<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;(&quot;<sp/>&lt;&lt;<sp/>iv-&gt;point()<sp/>&lt;&lt;<sp/>&quot;)&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_sssectr_ex">
<title>Additional Example</title>
<para>The function listed below prints the current setting of a given arrangement. This concludes the preview of the various traversal methods.The file <computeroutput>arr_print.h</computeroutput>, which can be found under the examples folder, includes this function and the rest of the functions listed in this section. Over there they are written in a more generic fashion, where the arrangement type serves as a template parameter for these functions, so different instantiations of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> template can be provided to the same function templates.</para><para><programlisting><codeline><highlight class="normal">void<sp/>print_arrangement<sp/>(const<sp/>Arrangement_2&amp;<sp/>arr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Print<sp/>the<sp/>arrangement<sp/>vertices.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_const_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>arr.number_of_vertices()<sp/>&lt;&lt;<sp/>&quot;<sp/>vertices:&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;(&quot;<sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/>&quot;)&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(vit-&gt;is_isolated())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;<sp/>-<sp/>Isolated.&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;<sp/>-<sp/>degree<sp/>&quot;<sp/>&lt;&lt;<sp/>vit-&gt;degree()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Print<sp/>the<sp/>arrangement<sp/>edges.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Edge_const_iterator<sp/>eit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/>&lt;&lt;<sp/>&quot;<sp/>edges:&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;[&quot;<sp/>&lt;&lt;<sp/>eit-&gt;curve()<sp/>&lt;&lt;<sp/>&quot;]&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Print<sp/>the<sp/>arrangement<sp/>faces.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_const_iterator<sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>&quot;<sp/>faces:&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_face<sp/>(fit);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssecmodify">
<title>Modifying the Arrangement</title>
<para>In this section we review the various member functions of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class that allow users to modify the topological structure of the arrangement by introducing new edges or vertices, modifying them, or removing them.</para><para>The arrangement member-functions that insert new curves into the arrangement, thus enabling the construction of a planar subdivision, are rather specialized, as they require a-priori knowledge on the location of the inserted curve. Indeed, for most purposes it is more convenient to construct an arrangement using the free (global) insertion-functions.</para></sect2>
<sect2 id="index_1arr_sssecmf_insert_cv">
<title>Inserting Non-Intersecting x-Monotone Curves</title>
<para>The most important functions that allow users to modify the arrangement, and perhaps the most frequently used ones, are the specialized insertion functions of <formula id="2">$ x$</formula>-monotone curves whose interior is disjoint from any other curve in the existing arrangement and do not contain any vertex of the arrangement. In addition, these function require that the location of the curve in the arrangement is known.</para><para>The motivation behind these rather harsh restrictions on the nature of the inserted curves is the decoupling of the topological arrangement representation from the various algorithms that operate on it. While the insertion of an <formula id="2">$ x$</formula>-monotone curve whose interior is disjoint from all existing arrangement features is quite straightforward (as we show next), inserting curves that intersect with the curves already inserted into the arrangement is much more complicated and requires the application of non-trivial geometric algorithms. These insertion operations are therefore implemented as free functions that operate on the arrangement and the inserted curve(s); see Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions in the Arrangement Package</ref> for more details and examples. You may skip to Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions in the Arrangement Package</ref>, and return to this subsection at a later point in time.</para><para><anchor id="index_1fig__arr_figex_1"/><image type="html" name="insert.png"></image>
 <image type="latex" name="insert.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_1" kindref="member">fig__arr_figex_1</ref> The various specialized insertion procedures. The inserted <formula id="2">$ x$</formula>-monotone curve is drawn with a light dashed line, surrounded by two solid arrows that represent the pair of twin half-edges added to the Dcel. Existing vertices are shown as black dots while new vertices are shown as light dots. Existing half-edges that are affected by the insertion operations are drawn as dashed arrows. (a) Inserting a curve as a new hole inside the face <formula id="38">$ f$</formula>. (b) Inserting a curve from an existing vertex <formula id="39">$ u$</formula> that corresponds to one of its endpoints. (c) Inserting an <formula id="2">$ x$</formula>-monotone curve whose endpoints are the already existing vertices <formula id="26">$ u_1$</formula> and <formula id="27">$ u_2$</formula>. In our case, the new pair of half-edges close a new face <formula id="40">$ f&apos;$</formula>, where the hole <formula id="41">$ h_1$</formula>, which used to belong to <formula id="38">$ f$</formula>, now becomes an enclave in this new face.  <linebreak/>
</para><para>When an <formula id="2">$ x$</formula>-monotone curve is inserted into an existing arrangement, such that the interior of this curve is disjoint from any arrangement feature, only the following three scenarios are possible, depending on the status of the endpoints of the inserted subcurve:</para><para><orderedlist>
<listitem>
<para>In case both curve endpoints do not correspond to any existing arrangement vertex we have to create two new vertices corresponding to the curve endpoints and connect them using a pair of twin halfedges. This halfedge pair initiates a new hole inside the face that contains the curve in its interior. </para></listitem>
<listitem>
<para>If exactly one endpoint corresponds to an existing arrangement vertex (we distinguish between a vertex that corresponds to the left endpoint of the inserted curve and a vertex corresponding to its right endpoint), we have to create a new vertex that corresponds to the other endpoint of the curve and to connect the two vertices by a pair of twin halfedges that form an &quot;antenna&quot; emanating from the boundary of an existing connected component (note that if the existing vertex used to be isolated, this operation is actually equivalent to forming a new hole inside the face that contains this vertex). </para></listitem>
<listitem>
<para>If both endpoints correspond to existing arrangement vertices, we connect these vertices using a pair of twin halfedges. (If one or both vertices are isolated this case reduces to one of the two previous cases respectively.) The two following subcases may occur: <itemizedlist>
<listitem>
<para>Two disconnected components are merged into a single connected component (as is the case with the segment <formula id="42">$s_1$</formula> in the figure to the left). </para></listitem>
<listitem>
<para>A new face is created, a face that splits from an existing arrangement face. In this case we also have to examine the holes and isolated vertices in the existing face and move the relevant ones inside the new face (as is the case with the segment <formula id="43">$s_2$</formula> in the figure to the left). </para></listitem>
</itemizedlist>
</para></listitem>
</orderedlist>
</para><para><image type="html" name="connect_comp.png"></image>
 <image type="latex" name="connect_comp.png"></image>
</para><para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class offers insertion functions named <computeroutput>insert_in_face_interior()</computeroutput>, <computeroutput>insert_from_left_vertex()</computeroutput>, <computeroutput>insert_from_right_vertex()</computeroutput> and <computeroutput>insert_at_vertices()</computeroutput> that perform the special insertion procedures listed above. The first function accepts an <formula id="2">$ x$</formula>-monotone curve <formula id="44">$ c$</formula> and an arrangement face <formula id="38">$ f$</formula> that contains this curve in its interior. The other functions accept an <formula id="2">$ x$</formula>-monotone curve <formula id="44">$ c$</formula> and handles to the existing vertices that correspond to the curve endpoint(s). Each of the four functions returns a handle to one of the twin halfedges that have been created, where: <itemizedlist>
<listitem>
<para><computeroutput>insert_in_face_interior(c, f)</computeroutput> returns a halfedge directed from the vertex corresponding to the left endpoint of <computeroutput>c</computeroutput> toward the vertex corresponding to its right endpoint. </para></listitem>
<listitem>
<para><computeroutput>insert_from_left_vertex(c, v)</computeroutput> and <computeroutput>insert_from_right_vertex(c, v)</computeroutput> returns a halfedge whose source is the vertex <formula id="14">$ v$</formula> that and whose target is the new vertex that has just been created. </para></listitem>
<listitem>
<para><computeroutput>insert_at_vertices(c, v1, v2)</computeroutput> returns a halfedge directed from <formula id="17">$ v_1$</formula> to <formula id="18">$ v_2$</formula>. </para></listitem>
</itemizedlist>
</para><para><anchor id="index_1fig__arr_figex_2"/><image type="html" name="ex_1.png"></image>
 <image type="latex" name="ex_1.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_2" kindref="member">fig__arr_figex_2</ref> The arrangement of the line segments <formula id="45">$ s_1, \ldots, s_5$</formula> constructed in <computeroutput>edge_insertion.cpp</computeroutput>. The arrows mark the direction of the halfedges returned from the various insertion functions.  <linebreak/>
</para><para>The following program demonstrates the usage of the four insertion functions. It creates an arrangement of five line segments, as depicted in <ref refid="index_1fig__arr_figex_1" kindref="member">fig__arr_figex_1</ref>.Notice that in all figures in the rest of this chapter the coordinate axes are drawn only for illustrative purposes and are <emphasis>not</emphasis> part of the arrangement. As the arrangement is very simple, we use the simple <ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref> kernel of CGAL with integer coordinates for the segment endpoints. We also use the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> class that enables the efficient maintenance of arrangements of line segments; see more details on this traits class in Section <ref refid="index_1arr_sectraits" kindref="member">Traits Classes</ref>. This example, as many others in this chapter, uses some print-utility functions from the file <computeroutput>print_arr.h</computeroutput>; these functions are also listed in Section <ref refid="index_1arr_ssectraverse" kindref="member">Traversing the Arrangement</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2edge_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/edge_insertion.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>using<sp/>the<sp/>simple<sp/>edge-insertion<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1a7dac3eed2224beadf3658495bc671c49" kindref="member">Arrangement_2::Vertex_handle</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member">Arrangement_2::Halfedge_handle</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s1(Point_2(1,<sp/>3),<sp/>Point_2(3,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s2(Point_2(3,<sp/>5),<sp/>Point_2(5,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s3(Point_2(5,<sp/>3),<sp/>Point_2(3,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s4(Point_2(3,<sp/>1),<sp/>Point_2(1,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s5(Point_2(1,<sp/>3),<sp/>Point_2(5,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e1<sp/>=<sp/>arr.insert_in_face_interior(s1,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v1<sp/>=<sp/>e1-&gt;source();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v2<sp/>=<sp/>e1-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e2<sp/>=<sp/>arr.insert_from_left_vertex(s2,<sp/>v2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v3<sp/>=<sp/>e2-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e3<sp/>=<sp/>arr.insert_from_right_vertex(s3,<sp/>v3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v4<sp/>=<sp/>e3-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s4,<sp/>v4,<sp/>v1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s5,<sp/>v1,<sp/>v3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Observe that the first line segment is inserted in the interior of the unbounded face. The other line segments are inserted using the vertices created by the insertion of previous segments. The resulting arrangement consists of three faces, where the two bounded faces form together a hole in the unbounded face.</para></sect2>
<sect2 id="index_1arr_sssecmf_iso_verts">
<title>Manipulating Isolated Vertices</title>
<para>Isolated points are in general simpler geometric entities than curves and indeed the member functions that manipulate them are easier to understand.</para><para>The function <computeroutput>insert_in_face_interior(p, f)</computeroutput> inserts an isolated point <formula id="46">$ p$</formula>, located in the interior of a given face <formula id="38">$ f$</formula>, into the arrangement and returns a handle to the arrangement vertex it has created and associated with <formula id="46">$ p$</formula>. Naturally, this function has a precondition that <formula id="46">$ p$</formula> is really an isolated point, namely it does not coincide with any existing arrangement vertex and does not lie on any edge. As mentioned in Section <ref refid="index_1arr_ssectraverse" kindref="member">Traversing the Arrangement</ref>, it is possible to obtain the face containing an isolated vertex handle <formula id="14">$ v$</formula> by calling <computeroutput>v-&gt;face()</computeroutput>.</para><para>The function <computeroutput>remove_isolated_vertex(v)</computeroutput> receives a handle to an isolated vertex and removes it from the arrangement.</para><para><anchor id="index_1fig__arr_figex_3"/><image type="html" name="ex_2.png"></image>
 <image type="latex" name="ex_2.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_3" kindref="member">fig__arr_figex_3</ref> An arrangement of line segments containing three isolated vertices, as constructed in <computeroutput>isolated_vertices.cpp</computeroutput>. The vertices <formula id="27">$ u_2$</formula> and <formula id="47">$ u_3$</formula> are eventually removed from the arrangement.  <linebreak/>
</para><para>The following program demonstrates the usage of the arrangement member-functions for manipulating isolated vertices. It first inserts three isolated vertices located inside the unbounded face, then it inserts four line segments that form a rectangular hole inside the unbounded face (see <ref refid="index_1fig__arr_figex_2" kindref="member">fig__arr_figex_2</ref> for an illustration). Finally, it traverses the vertices and removes those isolated vertices that are still contained in the unbounded face ( <formula id="27">$ u_2$</formula> and <formula id="47">$ u_3$</formula> in this case):</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2isolated_vertices_8cpp-example" kindref="compound">Arrangement_on_surface_2/isolated_vertices.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>with<sp/>isolated<sp/>vertices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_inexact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>isolated<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_handle<sp/>uf<sp/>=<sp/>arr.unbounded_face();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_in_face_interior(Point(3,<sp/>3),<sp/>uf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_in_face_interior(Point(1,<sp/>5),<sp/>uf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_in_face_interior(Point(5,<sp/>5),<sp/>uf);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>four<sp/>segments<sp/>that<sp/>form<sp/>a<sp/>square-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p1(1,<sp/>3),<sp/>p2(3,<sp/>5),<sp/>p3(5,<sp/>3),<sp/>p4(3,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s1(p1,<sp/>p2),<sp/>s2(p2,<sp/>p3),<sp/>s3(p3,<sp/>p4),<sp/>s4(p4,<sp/>p1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e1<sp/>=<sp/>arr.insert_in_face_interior(s1,<sp/>uf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v1<sp/>=<sp/>e1-&gt;source();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v2<sp/>=<sp/>e1-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e2<sp/>=<sp/>arr.insert_from_left_vertex(s2,<sp/>v2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v3<sp/>=<sp/>e2-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e3<sp/>=<sp/>arr.insert_from_right_vertex(s3,<sp/>v3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v4<sp/>=<sp/>e3-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s4,<sp/>v4,<sp/>v1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>the<sp/>isolated<sp/>vertices<sp/>located<sp/>in<sp/>the<sp/>unbounded<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement::Vertex_iterator<sp/>curr,<sp/>next<sp/>=<sp/>arr.vertices_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(curr<sp/>=<sp/>next++;<sp/>curr<sp/>!=<sp/>arr.vertices_end();<sp/>curr<sp/>=<sp/>next++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Keep<sp/>an<sp/>iterator<sp/>to<sp/>the<sp/>next<sp/>vertex,<sp/>as<sp/>curr<sp/>might<sp/>be<sp/>deleted.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(curr-&gt;is_isolated()<sp/>&amp;&amp;<sp/>curr-&gt;face()<sp/>==<sp/>uf)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>arr.remove_isolated_vertex(curr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_sssecmf_halfedges">
<title>Manipulating Halfedges</title>
<para>In the previous subsection we showed how to introduce new isolated vertices in the arrangement. But how does one create a vertex that lies on an existing arrangement edge (more precisely, on an <formula id="2">$ x$</formula>-monotone curve that is associated with an arrangement edge)?</para><para>It should be noted that such an operation involves the splitting of a curve at a given point in its interior, while the traits class used by <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> does not necessarily have the ability to perform such a split operation. However, if users have the ability to split an <formula id="2">$ x$</formula>-monotone curve into two at a given point <formula id="46">$ p$</formula> (this is usually the case when employing a more sophisticated traits class; see Section <ref refid="index_1arr_sectraits" kindref="member">Traits Classes</ref> for more details) they can use the <computeroutput>split_edge(e, c1, c2)</computeroutput> function, were <formula id="48">$ c_1$</formula> and <formula id="49">$ c_2$</formula> are the two subcurves resulting from splitting the <formula id="2">$ x$</formula>-monotone curve associated with the halfedge <formula id="15">$ e$</formula> at some point (call it <formula id="46">$ p$</formula>) in its interior. The function splits the halfedge pair into two pairs, both incident to a new vertex <formula id="14">$ v$</formula> associated with <formula id="46">$ p$</formula>, and returns a handle to a halfedge whose source equals <formula id="15">$ e$</formula>&apos;s source vertex and whose target is the new vertex <formula id="14">$ v$</formula>.</para><para>The reverse operation is also possible. Suppose that we have a vertex <formula id="14">$ v$</formula> of degree <formula id="50">$ 2$</formula>, whose two incident halfedges, <formula id="51">$ e_1$</formula> and <formula id="52">$ e_2$</formula>, are associated with the curves <formula id="48">$ c_1$</formula> and <formula id="49">$ c_2$</formula>. Suppose further that it is possible to merge these two curves into a single continuous <formula id="2">$ x$</formula>-monotone curve <formula id="44">$ c$</formula>. Calling <computeroutput>merge_edge(e1, e2, c)</computeroutput> will merge the two edges into a single edge associated with the curve <formula id="44">$ c$</formula>, essentially removing the vertex <formula id="14">$ v$</formula> from the arrangement.</para><para>Finally, the function <computeroutput>remove_edge(e)</computeroutput> removes the edge <formula id="15">$ e$</formula> from the arrangement. Note that this operation is the reverse of an insertion operation, so it may cause a connected component to split into two, or two faces to merge into one, or a hole to disappear. By default, if the removal of <computeroutput>e</computeroutput> causes one of its end-vertices to become isolated, we remove this vertex as well. However, users can control this behavior and choose to keep the isolated vertices by supplying additional Boolean flags to <computeroutput><ref refid="group__PkgArrangement2Funcs_1ga324fdf8354e7812fe0e1c0e5ac14196c" kindref="member">remove_edge()</ref></computeroutput> indicating whether the source and the target vertices are to be removed should they become isolated.</para><para><anchor id="index_1fig__arr_figex_4"/><image type="html" name="ex_3.png"></image>
 <image type="latex" name="ex_3.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_4" kindref="member">fig__arr_figex_4</ref> An arrangement of line segments as constructed in <computeroutput>edge_manipulation.cpp</computeroutput>. Note that the edges <formula id="53">$ e_7$</formula> and <formula id="54">$ e_8$</formula> and the vertices <formula id="55">$ w_1$</formula> and <formula id="56">$ w_2$</formula>, introduced in step (b) are eventually removed in step (c).  <linebreak/>
</para><para>In the following example program we show how the edge-manipulation functions can be used. The program works in three steps, as demonstrated in <ref refid="index_1fig__arr_figex_3" kindref="member">fig__arr_figex_3</ref>. Note that here we still stick to integer coordinates, but as we work on a larger scale we use an unbounded integer number-type (in this case, the <computeroutput><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpz</ref></computeroutput> type taken from the Gmp library) instead of the built-in <computeroutput>int</computeroutput> type.As a rule of thumb, one can use a bounded integer type for representing line segments whose coordinates are bounded by <formula id="57">$ \lfloor\sqrt[3]{M}\rfloor$</formula>, where <formula id="58">$ M$</formula> is the maximal representable integer value. This guarantees that no overflows occur in the computations carried out by the traits class, hence all traits-class predicates always return correct results. In case the Gmp library is not installed (as indicated by the <computeroutput>CGAL_USE_GMP</computeroutput> flag defined in <computeroutput>CGAL/basic.h</computeroutput>), we use <computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref></computeroutput>, a number-type included in CGAL&apos;s support library that is capable of storing floating-point numbers with unbounded mantissa. We also use the standard <ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref> kernel of CGAL as our kernel. This is recommended when the kernel is instantiated with a more complex number type, as we demonstrate in other examples in this chapter.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2edge_manipulation_8cpp-example" kindref="compound">Arrangement_on_surface_2/edge_manipulation.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Using<sp/>the<sp/>edge-manipulation<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1a7dac3eed2224beadf3658495bc671c49" kindref="member">Arrangement_2::Vertex_handle</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member">Arrangement_2::Halfedge_handle</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Step(a)<sp/>-<sp/>construct<sp/>a<sp/>triangular<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s1(Point_2(667,<sp/>1000),<sp/>Point_2(4000,<sp/>5000));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s2(Point_2(4000,<sp/>0),<sp/>Point_2(4000,<sp/>5000));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s3(Point_2(667,<sp/>1000),<sp/>Point_2(4000,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e1<sp/>=<sp/>arr.insert_in_face_interior(s1,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v1<sp/>=<sp/>e1-&gt;source();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v2<sp/>=<sp/>e1-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e2<sp/>=<sp/>arr.insert_from_right_vertex(s2,<sp/>v2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v3<sp/>=<sp/>e2-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s3,<sp/>v3,<sp/>v1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Step<sp/>(b)<sp/>-<sp/>create<sp/>additional<sp/>two<sp/>faces<sp/>inside<sp/>the<sp/>triangle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p1(4000,<sp/>3666),<sp/>p2(4000,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s4(Point_2(4000,<sp/>5000),<sp/>p1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s5(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s6(Point_2(4000,<sp/>0),<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e4<sp/>=<sp/>arr.split_edge(e2,<sp/>s4,<sp/>Segment_2(Point_2(4000,<sp/>0),<sp/>p1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>w1<sp/>=<sp/>e4-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e5<sp/>=<sp/>arr.split_edge(e4-&gt;next(),<sp/>s5,<sp/>s6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>w2<sp/>=<sp/>e5-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e6<sp/>=<sp/>e5-&gt;next();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s7(p1,<sp/>Point_2(3000,<sp/>2666));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s8(p2,<sp/>Point_2(3000,<sp/>1333));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s9(Point_2(3000,<sp/>2666),<sp/>Point_2(2000,<sp/>1666));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s10(Point_2(3000,<sp/>1333),<sp/>Point_2(2000,<sp/>1666));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s11(Point_2(3000,<sp/>1333),<sp/>Point_2(3000,<sp/>2666));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e7<sp/>=<sp/>arr.insert_from_right_vertex(s7,<sp/>w1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v4<sp/>=<sp/>e7-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e8<sp/>=<sp/>arr.insert_from_right_vertex(s8,<sp/>w2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v5<sp/>=<sp/>e8-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v6<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>arr.insert_in_face_interior(Point_2(2000,<sp/>1666),<sp/>e8-&gt;face());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s9,<sp/>v4,<sp/>v6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s10,<sp/>v5,<sp/>v6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s11,<sp/>v4,<sp/>v5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Step(c)<sp/>-<sp/>remove<sp/>and<sp/>merge<sp/>faces<sp/>to<sp/>form<sp/>a<sp/>single<sp/>hole<sp/>in<sp/>the<sp/>traingle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.remove_edge(e7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.remove_edge(e8);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>e5<sp/>=<sp/>arr.merge_edge(e5,<sp/>e6,<sp/>Segment_2(e5-&gt;source()-&gt;point(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>e6-&gt;target()-&gt;point()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>e2<sp/>=<sp/>arr.merge_edge(e4,<sp/>e5,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Note how we use the halfedge handles returned from <computeroutput><ref refid="group__PkgBGLEulerOperations_1ga8a7629a2a0659ca059081eae8cedca3d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">split_edge()</ref></computeroutput> and <computeroutput>merge_edge()</computeroutput>. Also note the insertion of the isolated vertex <formula id="59">$ v_6$</formula> located inside the triangular face (the incident face of <formula id="53">$ e_7$</formula>). This vertex seizes from being isolated, as it is gets connected to other vertices.</para><para>In this context, we should mention the two member functions <computeroutput>modify_vertex(v, p)</computeroutput>, which sets <formula id="46">$ p$</formula> to be the point associated with the vertex <formula id="14">$ v$</formula>, and <computeroutput>modify_edge(e, c)</computeroutput>, which sets <formula id="44">$ c$</formula> to be the <formula id="2">$ x$</formula>-monotone curve associated with the halfedge <formula id="15">$ e$</formula>. These functions have preconditions that <formula id="46">$ p$</formula> is geometrically equivalent to <computeroutput>v-&gt;point()</computeroutput> and <formula id="44">$ c$</formula> is equivalent to <computeroutput>e-&gt;curve()</computeroutput> (i.e., the two curves have the same graph), respectively, to avoid the invalidation of the geometric structure of the arrangement. At a first glance it may seen as these two functions are of little use. However, we should keep in mind that there may be extraneous data (probably non-geometric) associated with the point objects or with the curve objects, as defined by the traits class. With these two functions we can modify this data; see more details in Section <ref refid="index_1arr_sectraits" kindref="member">Traits Classes</ref>.</para><para>In addition, we can use these functions to replace a geometric object (a point or a curve) with an equivalent object that has a more compact representation. For example, we can replace the point <formula id="60">$ (\frac{20}{40}, \frac{99}{33})$</formula> associated with some vertex <formula id="14">$ v$</formula>, by <formula id="61">$ (\frac{1}{2}, 3)$</formula>.</para></sect2>
<sect2 id="index_1arr_sssecadv_insert">
<title>Advanced Insertion Functions</title>
<para><image type="html" name="pred_around_vertex.png"></image>
 <image type="latex" name="pred_around_vertex.png"></image>
</para><para></para><para>Assume that the specialized insertion function <computeroutput>insert_from_left_vertex(c,v)</computeroutput> is invoked for a curve <formula id="44">$ c$</formula>, whose left endpoint is already associated with a non-isolated vertex <formula id="14">$ v$</formula>. Namely, <formula id="14">$ v$</formula> has already several incident halfedges. It is necessary in this case to locate the exact place for the new halfedge mapped to the inserted new curve <formula id="44">$ c$</formula> in the circular list of halfedges incident to <formula id="14">$ v$</formula>. More precisely, it is sufficient to locate one of the halfedges <computeroutput>pred</computeroutput> directed toward <formula id="14">$ v$</formula> such that <formula id="44">$ c$</formula> is located between <computeroutput>pred</computeroutput> and <computeroutput>pred-&gt;<ref refid="group__STLAlgos_1gad4dbc8daf3c0e2201f4972eb9eea404d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">next()</ref></computeroutput> in clockwise order around <formula id="14">$ v$</formula>, in order to complete the insertion (see <ref refid="index_1fig__arr_figex_1" kindref="member">fig__arr_figex_1</ref> for an illustration). This may take <formula id="62">$ O(d)$</formula> time where <formula id="63">$ d$</formula> is the degree of the vertex. However, if the halfedge <computeroutput>pred</computeroutput> is known in advance, the insertion can be carried out in constant time.</para><para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class provides the advanced versions of the specialized insertion functions for a curve <formula id="44">$ c$</formula> - namely we have <computeroutput>insert_from_left_vertex(c,pred)</computeroutput> and <computeroutput>insert_from_right_vertex(c,pred)</computeroutput> that accept a halfedge <computeroutput>pred</computeroutput> as specified above, instead of a vertex <formula id="14">$ v$</formula>. These functions are more efficient, as they take constant time and do not perform any geometric operations. Thus, they should be used when the halfedge <computeroutput>pred</computeroutput> is known. In case that the vertex <formula id="14">$ v$</formula> is isolated or that the predecessor halfedge for the new inserted curve is not known, the simpler versions of these insertion functions should be used.</para><para>Similarly, there exist two overrides of the <computeroutput>insert_at_vertices()</computeroutput> function: One that accept the two predecessor halfedges around the two vertices <formula id="17">$ v_1$</formula> and <formula id="18">$ v_2$</formula> that correspond to the curve endpoints, and one that accepts a handle for one vertex and a predecessor halfedge around the other vertex.</para><para><anchor id="index_1fig__arr_figex_5"/><image type="html" name="ex_4.png"></image>
 <image type="latex" name="ex_4.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_5" kindref="member">fig__arr_figex_5</ref> An arrangement of line segments, as constructed in <computeroutput>special_edge_insertion.cpp</computeroutput>. Note that <formula id="64">$ p_0$</formula> is initially inserted as an isolated point and later on connected to the other four vertices.  <linebreak/>
</para><para>The following program shows how to construct the arrangement depicted in <ref refid="index_1fig__arr_figex_4" kindref="member">fig__arr_figex_4</ref> using the specialized insertion functions that accept predecessor halfedges:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2special_edge_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/special_edge_insertion.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>using<sp/>the<sp/>specialized<sp/>edge-insertion<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_inexact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p0(3,<sp/>3),<sp/>p1(1,<sp/>3),<sp/>p2(3,<sp/>5),<sp/>p3(5,<sp/>3),<sp/>p4(3,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s1(p1,<sp/>p2),<sp/>s2(p2,<sp/>p3),<sp/>s3(p3,<sp/>p4),<sp/>s4(p4,<sp/>p1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s5(p1,<sp/>p0),<sp/>s6(p0,<sp/>p3),<sp/>s7(p4,<sp/>p0),<sp/>s8(p0,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/><sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v0<sp/>=<sp/>arr.insert_in_face_interior(p0,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e1<sp/>=<sp/>arr.insert_in_face_interior(s1,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e2<sp/>=<sp/>arr.insert_from_left_vertex(s2,<sp/>e1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e3<sp/>=<sp/>arr.insert_from_right_vertex(s3,<sp/>e2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e4<sp/>=<sp/>arr.insert_at_vertices(s4,<sp/>e3,<sp/>e1-&gt;twin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e5<sp/>=<sp/>arr.insert_at_vertices(s5,<sp/>e1-&gt;twin(),<sp/>v0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e6<sp/>=<sp/>arr.insert_at_vertices(s6,<sp/>e5,<sp/>e3-&gt;twin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s7,<sp/>e4-&gt;twin(),<sp/>e6-&gt;twin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s8,<sp/>e5,<sp/>e2-&gt;twin());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>It is possible to perform even more refined operations on an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> instance given specific topological information. As most of these operations are very fragile and perform no precondition testing on their input in order to gain efficiency, they are not included in the public interface of the arrangement class. Instead, the <computeroutput><ref refid="classCGAL_1_1Arr__accessor" kindref="compound">Arr_accessor</ref>&lt;Arrangement&gt;</computeroutput> class allows access to these internal arrangement operations - see more details in the Reference Manual. </para></sect2>
</sect1>
<sect1 id="index_1arr_secqueries">
<title>Issuing Queries on an Arrangement</title>
<para>One of the most important query types defined on arrangements is the <emphasis>point-location</emphasis> query: Given a point, find the arrangement cell that contains it. Typically, the result of a point-location query is one of the arrangement faces, but in degenerate situations the query point can be located on an edge or it may coincide with a vertex.</para><para>Point-location queries are common in many applications, and also play an important role in the incremental construction of arrangements (and more specifically in the free insertion-functions described in Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions in the Arrangement Package</ref>). Therefore, it is crucial to have the ability to answer such queries effectively.</para><sect2 id="index_1arr_ssecpl">
<title>Point-Location Queries</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template does not support point-location queries directly, as the arrangement representation is decoupled from the geometric algorithms that operate on it. The <emphasis>2D Arrangements</emphasis> package includes a set of classe templates that are capable of answering such queries; all are models of the concept <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput>. Each model employs a different algorithm or <emphasis>strategy</emphasis> for answering queries. A model of this concept must define the <computeroutput><ref refid="group__PkgArrangement2PointLocation_1ga81a8e48ebfc5a10a040f3b7d94a4c97d" kindref="member">locate()</ref></computeroutput> member function, which accepts an input query-point and returns an object that represents the arrangement cell that contains this point. This object is is type <computeroutput><ref refid="structCGAL_1_1Arr__point__location__result" kindref="compound">Arr_point_location_result</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;::Type</computeroutput><mdash/>a discriminated union container of the bounded types <computeroutput>Vertex_const_handle</computeroutput>, <computeroutput>Halfedge_const_handle</computeroutput>, or <computeroutput>Face_const_handle</computeroutput>. Depending on whether the query point is located inside a face, on an edge, or on a vertex, the appropriate handle can be obtained with <emphasis>value retrieval</emphasis> by <computeroutput>boost::get</computeroutput> as demonstrated in the example below.</para><para>Note that the handles returned by the <computeroutput><ref refid="group__PkgArrangement2PointLocation_1ga81a8e48ebfc5a10a040f3b7d94a4c97d" kindref="member">locate()</ref></computeroutput> functions are non-mutable (<computeroutput>const</computeroutput>). If necessary, such handles may be cast to mutable handles using the <computeroutput>non_const_handle()</computeroutput> methods <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a11be9c67d85886e197306dc47abab37a" kindref="member">Arrangement_2::non_const_handle()</ref></computeroutput> provided by the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class.</para><para>An object <computeroutput>pl</computeroutput> of any point-location class must be attached to an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> object <computeroutput>arr</computeroutput> before it is used to answer point-location queries on <computeroutput>arr</computeroutput>. This attachment can be performed when <computeroutput>pl</computeroutput> is constructed or at a later time using the <computeroutput>pl.init(arr)</computeroutput> call.</para><para>The function template listed below accepts a point-location object, the type of which is a model of the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept, and a query point. The function template issues a point-location query for the given point, and prints out the result. It is defined in the header file <computeroutput>point_location_utils.h</computeroutput>.</para><para><anchor id="index_1lst_pl"/><programlisting><codeline><highlight class="normal">template<sp/>&lt;typename<sp/>PointLocation&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>locate_point(const<sp/>PointLocation&amp;<sp/>pl,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>typename<sp/>PointLocation::Arrangement_2::Point_2&amp;<sp/>q)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>PointLocation<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_location;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>typename<sp/>Point_location::Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typename<sp/>CGAL::Arr_point_location_result&lt;Arrangement_2&gt;::Type<sp/>obj<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pl.locate(q);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Print<sp/>the<sp/>result.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_point_location&lt;Arrangement_2&gt;(q,<sp/>obj);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The function template <computeroutput>locate_point()</computeroutput> calls an instance of the function template <computeroutput>print_point_location()</computeroutput>, which inserts the result of the query into the standard output-stream. It is listed below, and defined in the header file <computeroutput>point_location_utils.h</computeroutput>. Observe how the function <computeroutput>boost::get()</computeroutput> is used to cast the resulting object into a handle to an arrangement feature. The point-location object <computeroutput>pl</computeroutput> is assumed to be already attached to an arrangement.</para><para><programlisting><codeline><highlight class="normal">template<sp/>&lt;typename<sp/>Arrangement_&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">print_point_location</highlight></codeline>
<codeline><highlight class="normal">(const<sp/>typename<sp/>PointLocation::Arrangement_2::Point_2&amp;<sp/>q</highlight></codeline>
<codeline><highlight class="normal"><sp/>typename<sp/>CGAL::Arr_point_location_result&lt;Arrangement_&gt;::Type<sp/>obj)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>Arrangement_<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>typename<sp/>Arrangement_2::Vertex_const_handle<sp/><sp/><sp/>Vertex_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>typename<sp/>Arrangement_2::Halfedge_const_handle<sp/>Halfedge_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>typename<sp/>Arrangement_2::Face_const_handle<sp/><sp/><sp/><sp/><sp/>Face_const_handle;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Vertex_const_handle*<sp/><sp/><sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Halfedge_const_handle*<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Face_const_handle*<sp/><sp/><sp/><sp/><sp/>f;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;The<sp/>point<sp/>(&quot;<sp/>&lt;&lt;<sp/>q<sp/>&lt;&lt;<sp/>&quot;)<sp/>is<sp/>located<sp/>&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(f<sp/>=<sp/>boost::get&lt;Face_const_handle&gt;(&amp;obj))<sp/>//<sp/>located<sp/>inside<sp/>a<sp/>face</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;inside<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>(((*f)-&gt;is_unbounded())<sp/>?<sp/>&quot;the<sp/>unbounded&quot;<sp/>:<sp/>&quot;a<sp/>bounded&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;<sp/>face.&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>else<sp/>if<sp/>(e<sp/>=<sp/>boost::get&lt;Halfedge_const_handle&gt;(&amp;obj))<sp/>//<sp/>located<sp/>on<sp/>an<sp/>edge</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;on<sp/>an<sp/>edge:<sp/>&quot;<sp/>&lt;&lt;<sp/>(*e)-&gt;curve()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>else<sp/>if<sp/>(v<sp/>=<sp/>boost::get&lt;Vertex_const_handle&gt;(&amp;obj))<sp/>//<sp/>located<sp/>on<sp/>a<sp/>vertex</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;on<sp/>&quot;<sp/>&lt;&lt;<sp/>(((*v)-&gt;is_isolated())<sp/>?<sp/>&quot;an<sp/>isolated&quot;<sp/>:<sp/>&quot;a&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;<sp/>vertex:<sp/>&quot;<sp/>&lt;&lt;<sp/>(*v)-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>else<sp/>CGAL_error_msg(&quot;Invalid<sp/>object.&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_sssecpl_strat">
<title>Choosing a Point-Location Strategy</title>
<para>Each of the various point-location class templates employs a different algorithm or <emphasis>strategy</emphasis>The term <emphasis>strategy</emphasis> is borrowed from the design-pattern taxonomy <ref refid="citelist_1CITEREF_cgal:ghjv-dpero-95" kindref="member">[4]</ref>, Chapter 5. A <emphasis>strategy</emphasis> provides the means to define a family of algorithms, each implemented by a separate class. All classes that implement the various algorithms are made interchangeable, letting the algorithm in use vary according to the user choice. for answering queries: <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__naive__point__location" kindref="compound">Arr_naive_point_location</ref>&lt;Arrangement&gt;</computeroutput> employs the <emphasis>naive</emphasis> strategy. It locates the query point naively, exhaustively scanning all arrangement cells.</para><para></para></listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;Arrangement&gt;</computeroutput> employs the <emphasis>walk-along-a-line</emphasis> (or <emphasis>walk</emphasis> for short) strategy. It simulates a traversal, in reverse order, along an imaginary vertical ray emanating from the query point. It starts from the unbounded face of the arrangement and moves downward toward the query point until it locates the arrangement cell containing it.</para><para></para></listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__landmarks__point__location" kindref="compound">Arr_landmarks_point_location</ref>&lt;Arrangement,Generator&gt;</computeroutput> uses a set of <emphasis>landmark</emphasis> points, the location of which in the arrangement is known. It employs the <emphasis>landmark</emphasis> strategy. Given a query point, it uses a nearest-neighbor search-structure (a Kd-tree is used by default) to find the nearest landmark, and then traverses the straight-line segment connecting this landmark to the query point.</para><para>There are various ways to select the landmark set in the arrangement. The selection is governed by the <computeroutput>Generator</computeroutput> template parameter. The default generator class, namely <computeroutput>Arr_landmarks_vertices_generator</computeroutput>, selects all the vertices of the attached arrangement as landmarks. Additional generators that select the set in other ways, such as by sampling random points or choosing points on a grid, are also available; see the Reference Manual for more details.</para><para>The landmark strategy requires that the type of the attached arrangement be an instance of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template, where the <computeroutput>Traits</computeroutput> parameter is substituted with a geometry-traits class that models the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept, which refines the basic <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept; see Section <ref refid="index_1arr_sssectr_lanmarks_concept" kindref="member">The Landmarks Concept</ref> for details. Most traits classes included in the <emphasis>2D Arrangement</emphasis> package are models of this refined concept.</para><para></para></listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__trapezoid__ric__point__location" kindref="compound">Arr_trapezoid_ric_point_location</ref>&lt;Arrangement&gt;</computeroutput> implements an improved variant of Mulmuley&apos;s point-location algorithm <ref refid="citelist_1CITEREF_m-fppa-90" kindref="member">[8]</ref>; see also <ref refid="citelist_1CITEREF_bkos-cgaa-00" kindref="member">[3]</ref>, Chapter 6. The (expected) query-time is logarithmic. The arrangement faces are decomposed into simpler cells each of constant complexity, known as <emphasis>pseudo-trapezoids</emphasis>, and a search structure (a directed acyclic graph) is constructed on top of these cells, facilitating the search of the pseudo trapezoid (hence the arrangement cell) containing a query point in expected logarithmic time. The trapezoidal map and the search structure are built by a randomized incremental construction algorithm (RIC).</para><para></para></listitem>
</itemizedlist>
</para><para>The first two strategies do not require any extra data. The class templates that implement them store a pointer to an arrangement object and operate directly on it. Attaching such point-location objects to an existing arrangement has virtually no running-time cost at all, but the query time is linear in the size of the arrangement (the performance of the walk strategy is much better in practice, but its worst-case performance is linear). Using these strategies is therefore recommended only when a relatively small number of point-location queries are issued by the application, or when the arrangement is constantly changing (That is, changes in the arrangement structure are more frequent than point-location queries).</para><para>On the other hand, the landmarks and the trapezoid RIC strategies require auxiliary data structures on top of the arrangement, which they need to construct once they are attached to an arrangement object and need to keep up-to-date as this arrangement changes. The data structure needed by the landmarks strategy can be constructed in <formula id="65">$ O(N \log N) $</formula> time, where <formula id="66">$ N $</formula> is the overall number of edges in the arrangement, but the constant hidden in the <formula id="67">$ O() $</formula> notation for the trapezoidal map RIC strategy is much larger. Thus, construction needed by the landmark algorithm is in practice significantly faster than the construction needed by the trapezoidal map RIC strategy. In addition, although both resulting data structures are asymptotically linear in size, using a Kd-tree as the nearest-neighbor search-structure that the landmark algorithm stores significantly reduces memory consumption. The trapezoidal map RIC algorithm has expected logarithmic query time, while the query time for the landmark strategy may be as large as linear. In practice however, the query times of both strategies are competitive. For a detailed experimental comparison see <ref refid="citelist_1CITEREF_cgal:hh-eplca-05" kindref="member">[6]</ref>.</para><para>Updating the auxiliary data structures of the trapezoidal map RIC algorithm is done very efficiently. On the other hand, updating the nearest-neighbor search-structure of the landmark algorithm may consume more time when the arrangement changes frequently, especially when a Kd-tree is used, as it must be rebuilt each time the arrangement changes. It is therefore recommended that the <computeroutput><ref refid="classCGAL_1_1Arr__landmarks__point__location" kindref="compound">Arr_landmarks_point_location</ref></computeroutput> class template be used when the application frequently issues point-location queries on an arrangement that only seldom changes. If the arrangement is more dynamic and is frequently going through changes, the <computeroutput><ref refid="classCGAL_1_1Arr__trapezoid__ric__point__location" kindref="compound">Arr_trapezoid_ric_point_location</ref></computeroutput> class template should be the selected point-location strategy.</para></sect2>
<sect2 id="index_1arr_sssecpl_ex">
<title>An Example</title>
<para><anchor id="index_1fig__arr_figex_8"/><image type="html" name="ex_5.png"></image>
 <image type="latex" name="ex_5.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_8" kindref="member">fig__arr_figex_8</ref> The arrangement of line segments, as constructed in <computeroutput>point_location_example.cpp</computeroutput>, <computeroutput>vertical_ray_shooting.cpp</computeroutput>, and <computeroutput>batched_point_location.cpp</computeroutput>. The arrangement vertices are drawn as small discs, while the query points <formula id="68">$ q_1, \ldots, q_6$</formula> are marked with crosses.  <linebreak/>
</para><para>The program listed below constructs a simple arrangement of five line segments that form a pentagonal face, with a single isolated vertex in its interior, as depicted in <ref refid="index_1fig__arr_figex_5" kindref="member">fig__arr_figex_5</ref>. Notice that we use the same arrangement structure in the next three example programs. The arrangement construction is performed by the function <computeroutput>construct_segment_arr()</computeroutput> defined in the header file <computeroutput>point_location_utils.h</computeroutput>. (Its listing is omitted here.) The program employs the naive and the landmark strategies to issue several point-location queries on this arrangement.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2point_location_example_8cpp-example" kindref="compound">Arrangement_on_surface_2/point_location_example.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Answering<sp/>point-location<sp/>queries.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_naive_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_landmarks_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;point_location_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__naive__point__location" kindref="compound">CGAL::Arr_naive_point_location&lt;Arrangement_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Naive_pl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__landmarks__point__location" kindref="compound">CGAL::Arr_landmarks_point_location&lt;Arrangement_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Landmarks_pl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Naive_pl<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>naive_pl(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_segments_arr(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>some<sp/>point-location<sp/>queries<sp/>using<sp/>the<sp/>naive<sp/>strategy.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>point_location_query<sp/>(naive_pl,<sp/>Point_2(1,<sp/>4));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>point_location_query<sp/>(naive_pl,<sp/>Point_2(4,<sp/>3));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>point_location_query<sp/>(naive_pl,<sp/>Point_2(6,<sp/>3));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Attach<sp/>the<sp/>landmarks<sp/>object<sp/>to<sp/>the<sp/>arrangement<sp/>and<sp/>perform<sp/>queries.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Landmarks_pl<sp/>landmarks_pl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>landmarks_pl.attach(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>point_location_query<sp/>(landmarks_pl,<sp/>Point_2(3,<sp/>2));<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q4</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>point_location_query<sp/>(landmarks_pl,<sp/>Point_2(5,<sp/>2));<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q5</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>point_location_query<sp/>(landmarks_pl,<sp/>Point_2(1,<sp/>0));<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q6</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Note that the program uses the <computeroutput>locate_point()</computeroutput> function template to locate a point and nicely print the result of each query; see <ref refid="index_1lst_pl" kindref="member">here</ref>.</para></sect2>
<sect2 id="index_1arr_ssecray_shoot">
<title>Vertical Ray Shooting</title>
<para>Another important query issued on arrangements is the vertical ray-shooting query: Given a query point, which arrangement feature do we encounter by a vertical ray shot upward (or downward) from this point? In the general case the ray hits an edge, but it is possible that it hits a vertex, or that the arrangement does not have any vertex or edge lying directly above (or below) the query point.</para><para>All point-location classes listed in the previous section are also models of the <computeroutput><ref refid="classArrangementVerticalRayShoot__2" kindref="compound">ArrangementVerticalRayShoot_2</ref></computeroutput> concept. That is, they all have member functions called <computeroutput>ray_shoot_up(q)</computeroutput> and <computeroutput>ray_shoot_down(q)</computeroutput> that accept a query point <computeroutput>q</computeroutput>. These functions output an object of type type <computeroutput><ref refid="structCGAL_1_1Arr__point__location__result" kindref="compound">Arr_point_location_result</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;::Type</computeroutput><mdash/>a discriminated union container of the bounded types <computeroutput>Vertex_const_handle</computeroutput>, <computeroutput>Halfedge_const_handle</computeroutput>, or <computeroutput>Face_const_handle</computeroutput>. The latter type is used for the unbounded face of the arrangement, in case there is no edge or vertex lying directly above (or below) <computeroutput>q</computeroutput>.</para><para>The function template <computeroutput>vertical_ray_shooting_query()</computeroutput> listed below accepts a vertical ray-shooting object, the type of which models the <computeroutput><ref refid="classArrangementVerticalRayShoot__2" kindref="compound">ArrangementVerticalRayShoot_2</ref></computeroutput> concept. It exports the result of the upward vertical ray-shooting operation from a given query point to the standard output-stream. The ray-shooting object <computeroutput>vrs</computeroutput> is assumed to be already attached to an arrangement. The function template is defined in the header file `point_location_utils.h.</para><para><programlisting><codeline><highlight class="normal">template<sp/>&lt;typename<sp/>RayShoot&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>shoot_vertical_ray(const<sp/>RayShoot&amp;<sp/>vrs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>typename<sp/>RayShoot::Arrangement_2::Point_2&amp;<sp/>q)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>RayShoot<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertical_ray_shooting;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Perform<sp/>the<sp/>point-location<sp/>query.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typename<sp/>Vertical_ray_shooting::result_type<sp/>obj<sp/>=<sp/>vrs.ray_shoot_up(q);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Print<sp/>the<sp/>result.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>typename<sp/>Vertical_ray_shooting::Arrangement_2<sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>typename<sp/>Arrangement_2::Vertex_const_handle<sp/><sp/><sp/>Vertex_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>typename<sp/>Arrangement_2::Halfedge_const_handle<sp/>Halfedge_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>typename<sp/>Arrangement_2::Face_const_handle<sp/><sp/><sp/><sp/><sp/>Face_const_handle;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Vertex_const_handle*<sp/><sp/><sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Halfedge_const_handle*<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Face_const_handle*<sp/><sp/><sp/><sp/><sp/>f;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;Shooting<sp/>up<sp/>from<sp/>(&quot;<sp/>&lt;&lt;<sp/>q<sp/>&lt;&lt;<sp/>&quot;)<sp/>:<sp/>&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(v<sp/>=<sp/>boost::get&lt;Vertex_const_handle&gt;(&amp;obj))<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>we<sp/>hit<sp/>a<sp/>vertex</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;hit<sp/>&quot;<sp/>&lt;&lt;<sp/>(((*v)-&gt;is_isolated())<sp/>?<sp/>&quot;an<sp/>isolated&quot;<sp/>:<sp/>&quot;a&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;<sp/>vertex:<sp/>&quot;<sp/>&lt;&lt;<sp/>(*v)-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>else<sp/>if<sp/>(e<sp/>=<sp/>boost::get&lt;Halfedge_const_handle&gt;(&amp;obj))<sp/><sp/>//<sp/>we<sp/>hit<sp/>an<sp/>edge</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;hit<sp/>an<sp/>edge:<sp/>&quot;<sp/>&lt;&lt;<sp/>(*e)-&gt;curve()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>else<sp/>if<sp/>(f<sp/>=<sp/>boost::get&lt;Face_const_handle&gt;(&amp;obj))<sp/>\{<sp/><sp/><sp/><sp/>//<sp/>we<sp/>hit<sp/>nothing</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion((*f)-&gt;is_unbounded());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;hit<sp/>nothing.&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>else<sp/>CGAL_error();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The program below uses the function template listed above to perform vertical ray-shooting queries on an arrangement. The arrangement and the query points are exactly the same as in <computeroutput>point_location.cpp</computeroutput>; see <ref refid="index_1fig__arr_figex_5" kindref="member">fig__arr_figex_5</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2vertical_ray_shooting_8cpp-example" kindref="compound">Arrangement_on_surface_2/vertical_ray_shooting.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Answering<sp/>vertical<sp/>ray-shooting<sp/>queries.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="MP__Float_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/MP_Float.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_walk_along_line_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_trapezoid_ric_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;point_location_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::MP_Float</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">CGAL::Arr_walk_along_line_point_location&lt;Arrangement_2&gt;</ref><sp/>Walk_pl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__trapezoid__ric__point__location" kindref="compound">CGAL::Arr_trapezoid_ric_point_location&lt;Arrangement_2&gt;</ref><sp/><sp/><sp/>Trap_pl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Walk_pl<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>walk_pl<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Trap_pl<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>trap_pl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_segments_arr<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>some<sp/>vertical<sp/>ray-shooting<sp/>queries<sp/>using<sp/>the<sp/>walk<sp/>strategy.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>q1<sp/>(1,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>q2<sp/>(4,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>q3<sp/>(6,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertical_ray_shooting_query<sp/>(walk_pl,<sp/>q1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertical_ray_shooting_query<sp/>(walk_pl,<sp/>q2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertical_ray_shooting_query<sp/>(walk_pl,<sp/>q3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Attach<sp/>the<sp/>trapezoid-RIC<sp/>object<sp/>to<sp/>the<sp/>arrangement<sp/>and<sp/>perform<sp/>queries.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>q4<sp/>(3,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>q5<sp/>(5,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>q6<sp/>(1,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>trap_pl.attach<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertical_ray_shooting_query<sp/>(trap_pl,<sp/>q4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertical_ray_shooting_query<sp/>(trap_pl,<sp/>q5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vertical_ray_shooting_query<sp/>(trap_pl,<sp/>q6);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The number type we use in this example is CGAL&apos;s built-in <computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref></computeroutput> type, which is a floating-point number with an unbounded mantissa and a 32-bit exponent. It supports construction from an integer or from a machine <computeroutput>float</computeroutput> or <computeroutput>double</computeroutput> and performs additions, subtractions and multiplications in an exact number.</para></sect2>
<sect2 id="index_1arr_ssecbatched_pl">
<title>Batched Point-Location</title>
<para>Suppose that at a given moment our application has to issue a relatively large number <formula id="69">$ m$</formula> of point-location queries on a specific arrangement object. Naturally, It is possible to define a point-location object and use it to issue separate queries on the arrangement. However, as explained in Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref> choosing a simple point-location strategy (either the naive or the walk strategy) means inefficient queries, while the more sophisticated strategies need to construct auxiliary structures that incur considerable overhead in running time.</para><para>Alternatively, the <emphasis>2D Arrangement</emphasis> package includes a free <computeroutput><ref refid="group__PkgArrangement2PointLocation_1ga81a8e48ebfc5a10a040f3b7d94a4c97d" kindref="member">locate()</ref></computeroutput> function that accepts an arrangement and a range of query points as its input and sweeps through the arrangement to locate all query points in one pass. The function outputs the query results as pairs, where each pair consists of a query point and a discriminated union container, which represents the cell containing the point; see Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>. The output pairs are sorted in increasing $xy$-lexicographical order of the query point.</para><para>The batched point-location operation is carried out by sweeping the arrangement. Thus, it takes <formula id="70">$ O((m+N)\log{(m+N)}) $</formula> time, where <formula id="66">$ N $</formula> is the number of edges in the arrangement. Issuing separate queries exploiting a point-location strategy with logarithmic query time per query, such as the trapezoidal map RIC strategy (see Section <ref refid="index_1arr_sssecpl_strat" kindref="member">Choosing a Point-Location Strategy</ref>), is asymptotically more efficient. However, experiments show that when the number <formula id="71">$ m $</formula> of point-location queries is of the same order of magnitude as <formula id="72">$ N$</formula>, the batched point-location operation is more efficient in practice. One of the reasons for the inferior performance of the alternative (asymptotically faster) procedures is the necessity to construct and maintain complex additional data structures.</para><para>The program below issues a batched point-location query, which is essentially equivalent to the six separate queries performed in <computeroutput>point_location_example.cpp</computeroutput>; see Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2batched_point_location_8cpp-example" kindref="compound">Arrangement_on_surface_2/batched_point_location.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Answering<sp/>a<sp/>batched<sp/>point-location<sp/>query.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_batched_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;point_location_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Arr__point__location__result" kindref="compound">CGAL::Arr_point_location_result&lt;Arrangement&gt;</ref><sp/><sp/><sp/><sp/>Point_location_result;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Point,<sp/>Point_location_result::Type&gt;<sp/><sp/><sp/>Query_result;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arrangement::Vertex_const_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arrangement::Halfedge_const_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arrangement::Face_const_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_segments_arr(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>a<sp/>batched<sp/>point-location<sp/>query.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(1,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(4,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(6,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(3,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(5,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point(1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Query_result&gt;<sp/>results;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2PointLocation_1ga81a8e48ebfc5a10a040f3b7d94a4c97d" kindref="member">locate</ref>(arr,<sp/>points.begin(),<sp/>points.end(),<sp/>std::back_inserter(results));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>results.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Query_result&gt;::const_iterator<sp/>it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(it<sp/>=<sp/>results.begin();<sp/>it<sp/>!=<sp/>results.end();<sp/>++it)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>point<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>it-&gt;first<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>is<sp/>located<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Face_const_handle*<sp/>f<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::get&lt;Face_const_handle&gt;(&amp;(it-&gt;second)))<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>inside<sp/>a<sp/>face</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;inside<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>(((*f)-&gt;is_unbounded())<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;the<sp/>unbounded&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;a<sp/>bounded&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>face.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Halfedge_const_handle*<sp/>e<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::get&lt;Halfedge_const_handle&gt;(&amp;(it-&gt;second)))<sp/></highlight><highlight class="comment">//<sp/>on<sp/>an<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;on<sp/>an<sp/>edge:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(*e)-&gt;curve()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Vertex_const_handle*<sp/>v<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::get&lt;Vertex_const_handle&gt;(&amp;(it-&gt;second)))<sp/><sp/></highlight><highlight class="comment">//<sp/>on<sp/>a<sp/>vertex</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;on<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>(((*v)-&gt;is_isolated())<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;an<sp/>isolated&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertex:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(*v)-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1arr_secgl_funcs">
<title>Free Functions in the Arrangement Package</title>
<para>In Section <ref refid="index_1arr_secarr_class" kindref="member">The Main Arrangement Class</ref> we reviewed in details the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class, which represents two-dimensional subdivisions induced by planar curves, and mentioned that its interface is minimal in the sense that the member functions hardly perform any geometric algorithms and are mainly used for maintaining the topological structure of the subdivision. In this section we explain how to utilize the free (global) functions that operate on arrangements. The implementation of these operations typically require non-trivial geometric algorithms or load some extra requirements on the traits class.</para><sect2 id="index_1arr_ssecinc_insert">
<title>Incremental Insertion Functions</title>
</sect2>
<sect2 id="index_1arr_sssecinsert_non_x">
<title>Inserting Non-Intersecting Curves</title>
<para>In Section <ref refid="index_1arr_secarr_class" kindref="member">The Main Arrangement Class</ref> we explained how to construct arrangements of <formula id="2">$ x$</formula>-monotone curves that are pairwise disjoint in their interior, when the location of the segment endpoints in the arrangement is known. Here we relax this constraint, and allow the location of the inserted <formula id="2">$ x$</formula>-monotone curve endpoints to be arbitrary, as it may be unknown at the time of insertion. We retain, for the moment, the requirement that the interior of the inserted curve is disjoint from all existing arrangement edges and vertices.</para><para>The free function <computeroutput>insert_non_intersecting_curve(arr, c, pl)</computeroutput> inserts the <formula id="2">$ x$</formula>-monotone curve <formula id="44">$ c$</formula> into the arrangement <computeroutput>arr</computeroutput>, with the precondition that the interior of <formula id="44">$ c$</formula> is disjoint from all <computeroutput>arr</computeroutput>&apos;s existing edges and vertices. The third argument <computeroutput>pl</computeroutput> is a point-location object attached to the arrangement, which is used for performing the insertion. It locates both curve endpoints in the arrangement, where each endpoint is expected to either coincide with an existing vertex or lie inside a face. It is possible to invoke one of the specialized insertion functions (see Section <ref refid="index_1arr_secarr_class" kindref="member">The Main Arrangement Class</ref>), based on the query results, and insert <formula id="44">$ c$</formula> at its proper position.The <computeroutput><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve()</ref></computeroutput> function, as all other functions reviewed in this section, is a function template, parameterized by an arrangement class and a point-location class (a model of the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept). The insertion operation thus hardly requires any geometric operations on top on the ones needed to answer the point-location queries. Moreover, it is sufficient that the arrangement class is instantiated with a traits class that models the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept (or the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept, if the landmark point-location strategy is used), which does not have to support the computation of intersection points between curves.</para><para>The variant <computeroutput>insert_non_intersecting_curve(arr, c)</computeroutput> is also available. Instead of accepting a user-defined point-location object, it defines a local instance of the walk point-location class and uses it to insert the curve.</para></sect2>
<sect2 id="index_1arr_sssecinsert_x_mon">
<title>Inserting x-Monotone Curves</title>
<para>The <computeroutput><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve()</ref></computeroutput> function is very efficient, but its preconditions on the input curves are still rather restricting. Let us assume that the arrangement is instantiated with a traits class that models the refined <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept and supports intersection computations (see Section <ref refid="index_1arr_sectraits" kindref="member">Traits Classes</ref> for the exact details). Given an <formula id="2">$ x$</formula>-monotone curve, it is sufficient to locate its left endpoint in the arrangement and to trace its <emphasis>zone</emphasis>, namely the set of arrangement features crossing the curve, until the right endpoint is reached. Each time the new curve <formula id="44">$ c$</formula> crosses an existing vertex or an edge, the curve is split into subcurves (in the latter case, we have to split the curve associated with the existing halfedge as well) and associate new edges with the resulting subcurves. Recall that an edge is represented by a pair of twin halfedges, so we split it into two halfedge pairs.</para><para>The free function <computeroutput>insert(arr, c, pl)</computeroutput> performs this insertion operation. It accepts an <formula id="2">$ x$</formula>-monotone curve <formula id="44">$ c$</formula>, which may intersect some of the curves already in the arrangement <computeroutput>arr</computeroutput>, and inserts it into the arrangement by computing its zone. Users may supply a point-location object <computeroutput>pl</computeroutput>, or use the default walk point-location strategy (namely, the variant <computeroutput>insert(arr, c)</computeroutput> is also available). The running-time of this insertion function is proportional to the complexity of the zone of the curve <formula id="44">$ c$</formula>.</para><para></para><para>In some cases users may have a prior knowledge of the location of the left endpoint of the <formula id="2">$ x$</formula>-monotone curve <computeroutput>c</computeroutput> they wish to insert, so they can perform the insertion without issuing any point-location queries. This can be done by calling <computeroutput>insert(arr, c, obj)</computeroutput>, where <computeroutput>obj</computeroutput> is an object represents the location of <computeroutput>c</computeroutput>&apos;s left endpoint in the arrangement - namely it wraps a <computeroutput>Vertex_const_handle</computeroutput>, a <computeroutput>Halfedge_const_handle</computeroutput> or a <computeroutput>Face_const_handle</computeroutput> (see also Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>). </para></sect2>
<sect2 id="index_1arr_sssecinsert_gen">
<title>Inserting General Curves</title>
<para>So far all our examples were of arrangements of line segments, where the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> template was instantiated with the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> class. In this case, the fact that <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> accepts an <formula id="2">$ x$</formula>-monotone curve does not seem to be a restriction, as all line segments are <formula id="2">$ x$</formula>-monotone (note that we consider vertical line segments to be <emphasis>weakly</emphasis> <formula id="2">$ x$</formula>-monotone).</para><para>Suppose that we construct an arrangement of circles. A circle is obviously not <formula id="2">$ x$</formula>-monotone, so we cannot insert it in the same way we inserted <formula id="2">$ x$</formula>-monotone curves. Note that a key operation performed by <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> is to locate the left endpoint of the curve in the arrangement. A circle, however, does not have any endpoints! However, it is possible to subdivide each circle into two <formula id="2">$ x$</formula>-monotone circular arcs (its upper half and its lower half) and to insert each <formula id="2">$ x$</formula>-monotone arc separately.</para><para>The free function <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> also supports general curve and not necessarily <formula id="2">$ x$</formula>-monotone curves. In this case it requires that the traits class used by the arrangement <computeroutput>arr</computeroutput> to be a model of the concept <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput>, which refines the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. It has to define an additional <computeroutput>Curve_2</computeroutput> type (which may differ from the <computeroutput>X_monotone_curve_2</computeroutput> type), and support the subdivision of curves of this new type into <formula id="2">$ x$</formula>-monotone curves (see the exact details in Section <ref refid="index_1arr_sectraits" kindref="member">Traits Classes</ref>). The <computeroutput>insert(arr, c, pl)</computeroutput> function performs the insertion of the curve <formula id="44">$ c$</formula>, which does not need to be <formula id="2">$ x$</formula>-monotone, into the arrangement by subdividing it (if needed) into <formula id="2">$ x$</formula>-monotone subcurves and inserting each one separately. Users may supply a point-location object <computeroutput>pl</computeroutput>, or use the default walk point-location strategy by calling <computeroutput>insert(arr, c)</computeroutput>.</para></sect2>
<sect2 id="index_1arr_sssecinsert_point">
<title>Inserting Points</title>
<para>The arrangement class enables us to insert a point as an isolated vertex in a given face. The free function <computeroutput>insert_point(arr, p, pl)</computeroutput> inserts a vertex into <computeroutput>arr</computeroutput> that corresponds to the point <computeroutput>p</computeroutput> at an arbitrary location. It uses the point-location object <computeroutput>pl</computeroutput> to locate the point in the arrangement (by default, the walk point-location strategy is used), and acts according to the result as follows: <itemizedlist>
<listitem>
<para>If <computeroutput>p</computeroutput> is located inside a face, it is inserted as an isolated vertex inside this face. </para></listitem>
<listitem>
<para>If <computeroutput>p</computeroutput> lies on an edge, the edge is split to create a vertex associated with <computeroutput>p</computeroutput>. </para></listitem>
<listitem>
<para>Otherwise, <computeroutput>p</computeroutput> coincides with an existing vertex and we are done. </para></listitem>
</itemizedlist>
In all cases, the function returns a handle to the vertex associated with <computeroutput>p</computeroutput>.</para><para>The arrangement <computeroutput>arr</computeroutput> should be instantiated with a traits class that models the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept, as the insertion operation may involve splitting curves.</para></sect2>
<sect2 id="index_1arr_sssecinsert_ex">
<title>An Example</title>
<para><anchor id="index_1fig__arr_figex_10"/><image type="html" name="ex_8.png"></image>
 <image type="latex" name="ex_8.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_10" kindref="member">fig__arr_figex_10</ref> An arrangement of five intersecting line segments, as constructed in <computeroutput>incremental_insertion.cpp</computeroutput> and <computeroutput>aggregated_insertion.cpp</computeroutput>. The segment endpoints are marked by black disks and the arrangement vertices that correspond to intersection points are marked by circles. The query point <formula id="73">$ q$</formula> is marked with a cross and the face that contains it is shaded.  <linebreak/>
</para><para>The program below constructs an arrangement of intersecting line-segments. We know that <formula id="74">$ s_1$</formula> and <formula id="75">$ s_2$</formula> do not intersect, so we use <computeroutput><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve()</ref></computeroutput> to insert them into the empty arrangement. The rest of the segments are inserted using <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput>. The resulting arrangement consists of <formula id="76">$ 13$</formula> vertices, <formula id="77">$ 16$</formula> edges, and <formula id="78">$ 5$</formula> faces, as can be seen in <ref refid="index_1fig__arr_figex_8" kindref="member">fig__arr_figex_8</ref>.</para><para>In the earlier examples, all arrangement vertices corresponded to segment endpoints. In this example we have additional vertices that correspond to intersection points between two segments. The coordinates of these intersection points are rational numbers, if the input coordinates are rational (or integer). Therefore, the <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;int&gt;</computeroutput> number type is used to represent the coordinates:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2incremental_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/incremental_insertion.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Using<sp/>the<sp/>global<sp/>incremental<sp/>insertion<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Quotient_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Quotient.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_walk_along_line_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Quotient&lt;int&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">CGAL::Arr_walk_along_line_point_location&lt;Arrangement_2&gt;</ref><sp/>Walk_pl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>of<sp/>five<sp/>intersecting<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Walk_pl<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pl(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s1(Point_2(1,<sp/>0),<sp/>Point_2(2,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s2(Point_2(5,<sp/>0),<sp/>Point_2(5,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s3(Point_2(1,<sp/>0),<sp/>Point_2(5,<sp/>3));<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s4(Point_2(0,<sp/>2),<sp/>Point_2(6,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s5(Point_2(3,<sp/>0),<sp/>Point_2(5,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>s1,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>s2,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s3,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s4,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s5,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>size<sp/>of<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>a<sp/>point-location<sp/>query<sp/>on<sp/>the<sp/>resulting<sp/>arrangement<sp/>and<sp/>print</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>boundary<sp/>of<sp/>the<sp/>face<sp/>that<sp/>contains<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>q(4,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Walk_pl::result_type<sp/>obj<sp/>=<sp/>pl.locate(q);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Face_const_handle<sp/><sp/>f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion_code(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>success<sp/>=)<sp/><ref refid="namespaceCGAL" kindref="compound">CGAL</ref>::assign(f,<sp/>obj);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(success);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacestd" kindref="compound">std</ref>::cout<sp/>&lt;&lt;<sp/>&quot;The<sp/>query<sp/>point<sp/>(&quot;<sp/>&lt;&lt;<sp/>q<sp/>&lt;&lt;<sp/>&quot;)<sp/>is<sp/>located<sp/>in:<sp/>&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_face&lt;Arrangement_2&gt;(f);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssseczone">
<title>Other Zone Related Functions</title>
<para>In this section we have described so far free functions that insert curves and points to a given arrangement. Now we will describe functions that don&apos;t insert curves or points to an arrangement nor do they change the arrangement, but they are closely related to the incremental insertion functions as they also use the zone algorithm.</para><para>The free function <computeroutput><ref refid="group__do__intersect__linear__grp_1ga9514a218a097ac392d21775368d3dd0d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">do_intersect()</ref></computeroutput> checks if a given curve or <formula id="2">$ x$</formula>-monotone curve intersects an existing arrangement&apos;s edges or vertices. If the give curve is not an <formula id="2">$ x$</formula>-monotone curve then the function subdivides the given curve into <formula id="2">$ x$</formula>-monotone subcurves and isolated vertices . Each subcurve is in turn checked for intersection. The function uses the zone algorithm to check if the curve intersects the arrangement. First, the curve&apos;s left endpoint is located. Then, its zone is computed starting from its left endpoint location. The zone computation terminates when an intersection with an arrangement&apos;s edge/vertex is found or when the right endpoint is reached. A given point-location object is used for locating the left endpoint of the given curve in the existing arrangement. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref></computeroutput>. If the given curve is <formula id="2">$ x$</formula>-monotone then the traits class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. If the curve is not <formula id="2">$ x$</formula>-monotone curve then the traits class must model the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept.</para><para>The <computeroutput><ref refid="group__PkgArrangement2Funcs_1ga49aa156968945f5533a2b5d9897ca659" kindref="member">zone()</ref></computeroutput> function computes the zone of a given <formula id="2">$ x$</formula>-monotone curve in a given arrangement. Meaning, it outputs all the arrangement&apos;s elements (vertices, edges and faces) that the <formula id="2">$ x$</formula>-monotone curve intersects in the order that they are discovered when traversing the <formula id="2">$ x$</formula>-monotone curve from left to right. The function uses a given point-location object to locate the left endpoint of the given <formula id="2">$ x$</formula>-monotone curve. By default, the function uses the &quot;walk along line&quot; point-location strategy. The function requires that the traits class will model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept.</para></sect2>
<sect2 id="index_1arr_ssecagg_insert">
<title>Aggregated Insertion Functions</title>
<para>Let us assume that we have to insert a set of <formula id="69">$ m$</formula> input curves into an arrangement. It is possible to do this incrementally, inserting the curves one by one, as shown in the previous section. However, the arrangement package provides three free functions that aggregately insert a range of curves into an arrangement: <itemizedlist>
<listitem>
<para><computeroutput>insert_non_intersecting_curves(arr, begin, end)</computeroutput> inserts a range of <formula id="2">$ x$</formula>-monotone curves given by the input iterators <computeroutput>[begin, end)</computeroutput> into an arrangement <computeroutput>arr</computeroutput>. The <formula id="2">$ x$</formula>-monotone curves should be pairwise disjoint in their interior and also interior-disjoint from all existing edges and vertices of <computeroutput>arr</computeroutput>. </para></listitem>
<listitem>
<para><computeroutput>insert(arr, begin, end)</computeroutput> inserts a range of general (not necessarily <formula id="2">$ x$</formula>-monotone) curves of type <computeroutput>Curve_2</computeroutput> or <computeroutput>X_monotone_curve_2</computeroutput> that may intersect one another, given by the input iterators <computeroutput>[begin, end)</computeroutput>, into the arrangement <computeroutput>arr</computeroutput>. </para></listitem>
</itemizedlist>
</para><para>We distinguish between two cases: (i) The given arrangement <computeroutput>arr</computeroutput> is empty (has only an unbounded face), so we have to construct it from scratch. (ii) We have to insert <formula id="69">$ m$</formula> input curves to a non-empty arrangement <computeroutput>arr</computeroutput>.</para><para>In the first case, we sweep over the input curves, compute their intersection points and construct the Dcel that represents their planar arrangement. This process is performed in <formula id="79">$ O\left((m + k)\log m\right)$</formula> time, where <formula id="80">$ k$</formula> is the total number of intersection points. The running time is asymptotically better than the time needed for incremental insertion, if the arrangement is relatively sparse (when <formula id="80">$ k$</formula> is bounded by <formula id="81">$ \frac{m^2}{\log m}$</formula>), but in practice it is recommended to use this aggregated construction process even for dense arrangements, since the sweep-line algorithm needs less geometric operations compared to the incremental insertion algorithms and hence typically runs much faster in practice.</para><para>Another important advantage the aggregated insertion functions have is that they do not issue point-location queries. Thus, no point-location object needs to be attached to the arrangement. As explained in Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>, there is a trade-off between construction time and query time in each of the point-location strategies, which affects the running times of the incremental insertion process. Naturally, this trade-off is irrelevant in case of aggregated insertion as above.</para><para>The example below shows how to construct the arrangement of line segments depicted in <ref refid="index_1fig__arr_figex_8" kindref="member">fig__arr_figex_8</ref> and built incrementally in <computeroutput>incremental_insertion.cpp</computeroutput>, as shown in the previous section. We use the aggregated insertion function <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> as we deal with line segments. Note that no point-location object needs to be defined and attached to the arrangement:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2aggregated_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/aggregated_insertion.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Using<sp/>the<sp/>global<sp/>aggregated<sp/>insertion<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Quotient_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Quotient.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Quotient&lt;int&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>of<sp/>five<sp/>intersecting<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Segment_2&gt;<sp/>segments;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back(Segment_2(Point_2(1,<sp/>0),<sp/>Point_2(2,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back(Segment_2(Point_2(5,<sp/>0),<sp/>Point_2(5,<sp/>5)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back(Segment_2(Point_2(1,<sp/>0),<sp/>Point_2(5,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back(Segment_2(Point_2(0,<sp/>2),<sp/>Point_2(6,<sp/>0)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segments.push_back(Segment_2(Point_2(3,<sp/>0),<sp/>Point_2(5,<sp/>5)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>segments.begin(),<sp/>segments.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>size<sp/>of<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>In case we have to insert a set of <formula id="69">$ m$</formula> curves into an existing arrangement, where we denote the number of edges in the arrangement by <formula id="72">$ N$</formula>. As a rule of thumb, if <formula id="82">$ m = o(\sqrt{N})$</formula>, we insert the curves one by one. For larger input sets, we use the aggregated insertion procedures.</para><para><anchor id="index_1fig__arr_figex_unb1"/><image type="html" name="ex_10.png"></image>
 <image type="latex" name="ex_10.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_unb1" kindref="member">fig__arr_figex_unb1</ref> An arrangement of intersecting line segments, as constructed in <computeroutput>global_insertion.cpp</computeroutput>. The segments of <formula id="83">$ {\mathcal S}_1$</formula> are drawn in solid lines and the segments of <formula id="84">$ {\mathcal S}_2$</formula> are drawn in dark dashed lines. Note that the segment <formula id="85">$ s$</formula> (light dashed line) overlaps one of the segments in <formula id="83">$ {\mathcal S}_1$</formula>.  <linebreak/>
</para><para>In the example below we aggregately construct an arrangement of a set <formula id="83">$ {\mathcal S}_1$</formula> containing five line segments. Then we insert a single segment using the incremental insertion function. Finally, we add a set <formula id="84">$ {\mathcal S}_2$</formula> with five more line segments in an aggregated fashion. Notice that the line segments of <formula id="83">$ {\mathcal S}_1$</formula> are pairwise interior-disjoint, so we use <computeroutput><ref refid="group__PkgArrangement2Funcs_1gad4aa37a4e938747028690579fb703d67" kindref="member">insert_non_intersecting_curves()</ref></computeroutput>. <formula id="84">$ {\mathcal S}_2$</formula> also contain pairwise interior-disjoint segments, but as they intersect the existing arrangement, we have to use <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> to insert them. Also note that the single segment <formula id="85">$ s$</formula> we insert incrementally overlaps an existing arrangement edge:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2global_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/global_insertion.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Using<sp/>the<sp/>global<sp/>insertion<sp/>functions<sp/>(incremental<sp/>and<sp/>aggregated).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Quotient_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Quotient.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="MP__Float_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/MP_Float.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_naive_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Quotient&lt;CGAL::MP_Float&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__naive__point__location" kindref="compound">CGAL::Arr_naive_point_location&lt;Arrangement_2&gt;</ref><sp/>Naive_pl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>of<sp/>five<sp/>intersecting<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S1<sp/>[5];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S1[0]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(1,<sp/>2.5),<sp/>Point_2<sp/>(4,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S1[1]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(1,<sp/>2.5),<sp/>Point_2<sp/>(6,<sp/>2.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S1[2]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(1,<sp/>2.5),<sp/>Point_2<sp/>(4,<sp/>0));<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S1[3]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(4,<sp/>5),<sp/>Point_2<sp/>(6,<sp/>2.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S1[4]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(4,<sp/>0),<sp/>Point_2<sp/>(6,<sp/>2.5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad4aa37a4e938747028690579fb703d67" kindref="member">insert_non_intersecting_curves</ref><sp/>(arr,<sp/>S1,<sp/>S1<sp/>+<sp/>5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>an<sp/>incremental<sp/>insertion<sp/>of<sp/>a<sp/>single<sp/>overlapping<sp/>segment.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Naive_pl<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pl<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(0,<sp/>2.5),<sp/>Point_2<sp/>(4,<sp/>2.5)),<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Aggregately<sp/>insert<sp/>an<sp/>additional<sp/>set<sp/>of<sp/>five<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S2<sp/>[5];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S2[0]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(0,<sp/>4),<sp/>Point_2<sp/>(6,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S2[1]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(0,<sp/>3),<sp/>Point_2<sp/>(6,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S2[2]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(0,<sp/>2),<sp/>Point_2<sp/>(6,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S2[3]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(0,<sp/>1),<sp/>Point_2<sp/>(6,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S2[4]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(6,<sp/>1),<sp/>Point_2<sp/>(6,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>S2,<sp/>S2<sp/>+<sp/>5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>size<sp/>of<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The number type used in the example above, <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;<ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref>&gt;</computeroutput>, is comprised of a numerator and a denominator of type <computeroutput><ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref></computeroutput>, namely floating-point numbers with unbounded mantissa. This number type is therefore capable of exactly computing the intersection points as long as the segment endpoints are given as floating-point numbers.</para></sect2>
<sect2 id="index_1arr_ssecgl_remove">
<title>Removing Vertices and Edges</title>
<para>The free functions <computeroutput><ref refid="group__PkgArrangement2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">remove_vertex()</ref></computeroutput> and <computeroutput><ref refid="group__PkgArrangement2Funcs_1ga324fdf8354e7812fe0e1c0e5ac14196c" kindref="member">remove_edge()</ref></computeroutput> handle the removal of vertices and edges from an arrangement. The difference between these functions and the member functions of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> template having the same name is that they allow the merger of two curves associated with adjacent edges to form a single edge. Thus, they require that the traits class that instantiates the arrangement instance is a model of the refined <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept (see Section <ref refid="index_1arr_sectraits" kindref="member">Traits Classes</ref>).</para><para>The function <computeroutput>remove_vertex(arr, v)</computeroutput> removes the vertex <computeroutput>v</computeroutput> from the given arrangement <computeroutput>arr</computeroutput>, where <computeroutput>v</computeroutput> is either an isolated vertex or is a <emphasis>redundant</emphasis> vertex - namely, it has exactly two incident edges that are associated with two curves that can be merged to form a single <formula id="2">$ x$</formula>-monotone curve. If neither of the two cases apply, the function returns an indication that it has failed to remove the vertex.</para><para>The function <computeroutput>remove_edge(arr, e)</computeroutput> removes the edge <computeroutput>e</computeroutput> from the arrangement by simply calling <computeroutput>arr.remove_edge(e)</computeroutput> (see Section <ref refid="index_1arr_ssecmodify" kindref="member">Modifying the Arrangement</ref>). In addition, if either of the end vertices of <computeroutput>e</computeroutput> becomes isolated or redundant after the removal of the edge, it is removed as well.</para><para><image type="html" name="h_shape.png"></image>
 <image type="latex" name="h_shape.png"></image>
</para><para>The following example demonstrates the usage of the free removal functions. In creates an arrangement of four line segment forming an H-shape with a double horizontal line. Then it removes the two horizontal edges and clears all redundant vertices, such that the final arrangement consists of just two edges associated with the vertical line segments:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2global_removal_8cpp-example" kindref="compound">Arrangement_on_surface_2/global_removal.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Using<sp/>the<sp/>global<sp/>removal<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_linear_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_naive_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1a7dac3eed2224beadf3658495bc671c49" kindref="member">Arrangement_2::Vertex_handle</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member">Arrangement_2::Halfedge_handle</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__naive__point__location" kindref="compound">CGAL::Arr_naive_point_location&lt;Arrangement_2&gt;</ref><sp/>Naive_pl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>arrangement<sp/>of<sp/>four<sp/>line<sp/>segments<sp/>forming<sp/>an<sp/>H-shape:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s1<sp/>(Point_2(1,<sp/>3),<sp/>Point_2(4,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e1<sp/>=<sp/>arr.insert_in_face_interior<sp/>(s1,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>s2<sp/>(Point_2(1,<sp/>4),<sp/>Point_2(4,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e2<sp/>=<sp/>arr.insert_in_face_interior<sp/>(s2,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment_2(Point_2(1,<sp/>1),<sp/>Point_2(1,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment_2(Point_2(4,<sp/>1),<sp/>Point_2(4,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>initial<sp/>arrangement:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>e1<sp/>and<sp/>its<sp/>incident<sp/>vertices<sp/>using<sp/>the<sp/>function<sp/>remove_edge().</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/>v1<sp/>=<sp/>e1-&gt;source(),<sp/>v2<sp/>=<sp/>e1-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.remove_edge(e1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">remove_vertex</ref>(arr,<sp/>v1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">remove_vertex</ref>(arr,<sp/>v2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>e2<sp/>using<sp/>the<sp/>free<sp/>remove_edge()<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1ga324fdf8354e7812fe0e1c0e5ac14196c" kindref="member">remove_edge</ref><sp/>(arr,<sp/>e2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>final<sp/>arrangement:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1arr_secunbounded">
<title>Arrangements of Unbounded Curves</title>
<para>Previous sections dealt only with arrangements of line segments, namely of bounded curves. Such arrangements always have one unbounded face that contains all other arrangement features. This section explains how to construct arrangements of unbounded curves, such as lines and rays.</para><sect2 id="index_1arr_ssecunb_basic">
<title>Basic Manipulation and Traversal Methods</title>
<para>Consider the arrangement induced by the two lines <formula id="86">$ y = x$</formula> and <formula id="87">$ y = -x$</formula>. These two lines intersect at the origin, such that the arrangement contains a single vertex <formula id="88">$ v = (0,0)$</formula>, with four infinite rays emanating from it. Each ray corresponds to an arrangement edge, and these edges subdivide the plane into four unbounded faces. Consider a halfedge pair that represents one of the edges. The source vertex of one of these halfedges is <formula id="14">$ v$</formula> and its target is at infinity, while the other has its source at infinity and <formula id="14">$ v$</formula> is its target.</para><para>If <computeroutput>e</computeroutput> is an object of the nested type <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1_1Halfedge" kindref="compound">Arrangement_2::Halfedge</ref></computeroutput>, then the predicates <computeroutput>e.source_at_infinity()</computeroutput> and <computeroutput>e.target_at_infinity()</computeroutput> indicate whether the halfedge represents a curve with an infinite end. In general there is no need to access the source (or the target) of a halfedge if it lies at infinity, since this vertex is not associated with any valid point. Similarly, calling <computeroutput>arr.number_of_vertices()</computeroutput> for an arrangement object <computeroutput>arr</computeroutput> counts only the vertices associated with finite points, and ignores vertices at infinity (and the range <computeroutput>[vertices_begin(), vertices_end())</computeroutput> contains only finite vertices). The method <computeroutput>arr.number_of_vertices_at_infinity()</computeroutput> counts the number of vertices at infinity.</para><para>As mentioned above, arrangements of unbounded curves usually have more than one unbounded face. The function <computeroutput>arr.number_of_unbounded_faces()</computeroutput> returns the number of unbounded arrangement faces (Thus, <computeroutput>arr.number_of_faces() - arr.number_of_unbounded_faces()</computeroutput> is the number of bounded faces). The functions <computeroutput>arr.unbounded_faces_begin()</computeroutput> and <computeroutput>arr.unbounded_faces_end()</computeroutput> return iterators of type <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1ae2ea7ee0fc95f9b49fe2c090e43ed0bc" kindref="member">Arrangement_2::Unbounded_face_iterator</ref></computeroutput> that specify the range of unbounded faces. Naturally, the value-type of this iterator is <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1_1Face" kindref="compound">Arrangement_2::Face</ref></computeroutput>.</para><para>The specialized insertion functions listed in Section <ref refid="index_1arr_sssecmf_insert_cv" kindref="member">Inserting Non-Intersecting x-Monotone Curves</ref> can also be used for inserting <formula id="2">$ x$</formula>-monotone unbounded curves, provided that they are interior-disjoint from any subcurve that already exists in the arrangement. For example, if you wish to insert a ray <formula id="5">$ r$</formula> emanating from <formula id="89">$ (0,0)$</formula> in the direction of <formula id="90">$ (1,0)$</formula>, to the arrangement of <formula id="87">$ y = -x$</formula> and <formula id="86">$ y = x$</formula>, you can use the function <computeroutput>arr.insert_from_left_vertex()</computeroutput>, as the left endpoint of <formula id="5">$ r$</formula> is already associated with an arrangement vertex. Other edge-manipulation functions can also be applied on edges associated with unbounded curves.</para><para><anchor id="index_1fig__arr_figunb_dcel"/><image type="html" name="ex_unb1.png"></image>
 <image type="latex" name="ex_unb1.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figunb_dcel" kindref="member">fig__arr_figunb_dcel</ref> An arrangement of unbounded linear objects, as constructed in unbounded_non_intersecting.cpp.  <linebreak/>
</para><para>The following example demonstrates the use of the insertion function for pairwise interior-disjoint unbounded curves. In this example we use the traits class <computeroutput><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">Arr_linear_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> to instantiate the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> template. This traits class is capable of representing line segments as well as unbounded linear curves (namely lines and rays). Observe that objects of the type <computeroutput>X_monotone_curve_2</computeroutput> defined by this traits class are constructible from <computeroutput><ref refid="classCGAL_1_1Line__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Line_2</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Ray__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Ray_2</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Segment_2</ref></computeroutput> objects, as defined in the instantiated kernel.</para><para>The first three curves are inserted using the special insertion functions for <formula id="2">$ x$</formula>-monotone curves whose location in the arrangement is known. Notice that inserting an unbounded curve in the interior of an unbounded face, or from an existing vertex that represents the bounded end of the curve, may cause an unbounded face to split (this is never the case when inserting a bounded curve - compare with Section <ref refid="index_1arr_sssecmf_insert_cv" kindref="member">Inserting Non-Intersecting x-Monotone Curves</ref>). Then, three additional rays are inserted incrementally, using the insertion function for <formula id="2">$ x$</formula>-monotone curves whose interior is disjoint from all arrangement features. Finally, the program prints the size of the arrangement (compare to the illustration in <ref refid="index_1fig__arr_figex_unb1" kindref="member">fig__arr_figex_unb1</ref>) and the outer boundaries of its six unbounded faces:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2unbounded_non_intersecting_8cpp-example" kindref="compound">Arrangement_on_surface_2/unbounded_non_intersecting.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>unbounded<sp/>linear<sp/>objects<sp/>using<sp/>the<sp/>insertion</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>function<sp/>for<sp/>non-intersecting<sp/>curves.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_linear_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Ray_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ray_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Line_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Line_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1a7dac3eed2224beadf3658495bc671c49" kindref="member">Arrangement_2::Vertex_handle</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member">Arrangement_2::Halfedge_handle</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>line<sp/>in<sp/>the<sp/>(currently<sp/>single)<sp/>unbounded<sp/>face<sp/>of<sp/>the<sp/>arrangement,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>then<sp/>split<sp/>it<sp/>into<sp/>two<sp/>at<sp/>(0,0).<sp/>Assign<sp/>v<sp/>to<sp/>be<sp/>the<sp/>split<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>c1<sp/>=<sp/>Line_2<sp/>(Point_2<sp/>(-1,<sp/>0),<sp/>Point_2<sp/>(1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/><sp/><sp/><sp/>e1<sp/>=<sp/>arr.insert_in_face_interior<sp/>(c1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>c1_left<sp/>=<sp/>Ray_2<sp/>(Point_2<sp/>(0,<sp/>0),<sp/>Point_2<sp/>(-1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>c1_right<sp/>=<sp/>Ray_2<sp/>(Point_2<sp/>(0,<sp/>0),<sp/>Point_2<sp/>(1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>e1<sp/>=<sp/>arr.split_edge<sp/>(e1,<sp/>c1_left,<sp/>c1_right);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/>v<sp/>=<sp/>e1-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(!<sp/>v-&gt;is_at_open_boundary());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>two<sp/>more<sp/>rays<sp/>using<sp/>the<sp/>specialized<sp/>insertion<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>c2<sp/>=<sp/>Ray_2<sp/>(Point_2<sp/>(0,<sp/>0),<sp/>Point_2<sp/>(-1,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>c3<sp/>=<sp/>Ray_2<sp/>(Point_2<sp/>(0,<sp/>0),<sp/>Point_2<sp/>(1,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_from_right_vertex<sp/>(c2,<sp/>v);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_from_left_vertex<sp/>(c3,<sp/>v);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>three<sp/>more<sp/>interior-disjoint<sp/>rays.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>c4<sp/>=<sp/>Ray_2<sp/>(Point_2<sp/>(0,<sp/>-1),<sp/>Point_2<sp/>(-2,<sp/>-2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>c5<sp/>=<sp/>Ray_2<sp/>(Point_2<sp/>(0,<sp/>-1),<sp/>Point_2<sp/>(2,<sp/>-2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>c6<sp/>=<sp/>Ray_2<sp/>(Point_2<sp/>(0,<sp/>0),<sp/>Point_2<sp/>(0,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>c4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>c5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>c6);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>out<sp/>the<sp/>size<sp/>of<sp/>the<sp/>resulting<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(plus<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices_at_infinity()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>at<sp/>infinity)&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_unbounded_faces()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>unbounded)&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>outer<sp/>CCBs<sp/>of<sp/>the<sp/>unbounded<sp/>faces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Face_const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Ccb_halfedge_const_circulator<sp/><sp/>first,<sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Halfedge_const_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>he;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>k<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit,<sp/>k++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>fit-&gt;is_unbounded())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Face<sp/>no.<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>curr<sp/>=<sp/>first<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>curr-&gt;source()-&gt;is_at_open_boundary())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>curr-&gt;source()-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>he<sp/>=<sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>he-&gt;is_fictitious())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>he-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/><sp/><sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>[<sp/>...<sp/>]<sp/><sp/><sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>he-&gt;target()-&gt;is_at_open_boundary())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>he-&gt;target()-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(curr<sp/>!=<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssecunb_global">
<title>Free Functions</title>
<para>In principle, all queries and operations that relate to arrangements of bounded curves can also be applied to arrangements of unbounded curves. For example, it is possible to issue point-location and vertical ray-shooting queries (see also Section <ref refid="index_1arr_secqueries" kindref="member">Issuing Queries on an Arrangement</ref>) on arrangements of lines, where the only restriction is that the query point has finite coordinates.Currently, all point-location strategies except the trapezoidal RIC point-location strategy are capable of handling arrangements of unbounded curves.</para><para>In the following example we show how an arrangement of unbounded lines is utilized to solve the following problem: Given a set of points, does the set contain at least three collinear points? In this example a set of input points is read from a file. The file <computeroutput>points.dat</computeroutput> is used by default. It contains definitions of <formula id="91">$ 100$</formula> points randomly selected on the grid <formula id="92">$ [-10000,10000]\times[-10000,10000]$</formula>. We construct an arrangement of the dual lines, where the line <formula id="93">$ p^{*}$</formula> dual to the point <formula id="94">$ p = (p_x, p_y)$</formula> is given by the equation <formula id="95">$ y = p_x*x - p_y$</formula>, and check whether three (or more) of the dual lines intersect at a common point, by searching for a (dual) vertex, whose degree is greater than <formula id="96">$ 4$</formula>. If such a vertex exists, then there are at least three dual lines that intersect at a common point, which implies that there are at least three collinear points.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2dual_lines_8cpp-example" kindref="compound">Arrangement_on_surface_2/dual_lines.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Checking<sp/>whether<sp/>there<sp/>are<sp/>three<sp/>collinear<sp/>points<sp/>in<sp/>a<sp/>given<sp/>input<sp/>set</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>using<sp/>the<sp/>arrangement<sp/>of<sp/>the<sp/>dual<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_linear_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Line_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Line_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>points.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;points.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>points<sp/>from<sp/>the<sp/>file,<sp/>and<sp/>construct<sp/>their<sp/>dual<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>input<sp/>file<sp/>format<sp/>should<sp/>be<sp/>(all<sp/>coordinate<sp/>values<sp/>are<sp/>integers):</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>number<sp/>of<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;x_1&gt;<sp/>&lt;y_1&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>point<sp/>#1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;x_2&gt;<sp/>&lt;y_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>point<sp/>#2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;x_n&gt;<sp/>&lt;y_n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>point<sp/>#n.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;X_monotone_curve_2&gt;<sp/>dual_lines;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.resize(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>n;<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>px,<sp/>py;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>px<sp/>&gt;&gt;<sp/>py;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points[k]<sp/>=<sp/>Point_2(px,<sp/>py);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>line<sp/>dual<sp/>to<sp/>the<sp/>point<sp/>(p_x,<sp/>p_y)<sp/>is<sp/>y<sp/>=<sp/>p_x*x<sp/>-<sp/>p_y,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>or:<sp/>p_x*x<sp/>-<sp/>y<sp/>-<sp/>p_y<sp/>=<sp/>0:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dual_lines.push_back(Line_2(<ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(px),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(-1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(-py)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>dual<sp/>arrangement<sp/>by<sp/>aggregately<sp/>inserting<sp/>the<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>dual_lines.begin(),<sp/>dual_lines.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>dual<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(+<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices_at_infinity()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>at<sp/>infinity)&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_unbounded_faces()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>unbounded)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Look<sp/>for<sp/>a<sp/>vertex<sp/>whose<sp/>degree<sp/>is<sp/>greater<sp/>than<sp/>4.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Vertex_const_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>found_collinear<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vit-&gt;degree()<sp/>&gt;<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>found_collinear<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(found_collinear)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Found<sp/>at<sp/>least<sp/>three<sp/>collinear<sp/>points<sp/>in<sp/>the<sp/>input<sp/>set.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;No<sp/>three<sp/>collinear<sp/>points<sp/>are<sp/>found<sp/>in<sp/>the<sp/>input<sp/>set.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Pick<sp/>two<sp/>points<sp/>from<sp/>the<sp/>input<sp/>set,<sp/>compute<sp/>their<sp/>midpoint<sp/>and<sp/>insert</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>its<sp/>dual<sp/>line<sp/>into<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Kernel<sp/>ker;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k1<sp/>=<sp/>std::rand()<sp/>%<sp/>n,<sp/>k2<sp/>=<sp/>(k1<sp/>+<sp/>1)<sp/>%<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>p_mid<sp/>=<sp/>ker.construct_midpoint_2_object()(points[k1],<sp/>points[k2]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>dual_p_mid<sp/>=<sp/>Line_2(<ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(p_mid.x()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(-1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__nt__cgal_1ga0849ff44771b19582218ebdfa5614f64" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Exact_rational</ref>(-p_mid.y()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>dual_p_mid);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Make<sp/>sure<sp/>that<sp/>we<sp/>now<sp/>have<sp/>three<sp/>collinear<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>found_collinear<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vit-&gt;degree()<sp/>&gt;<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>found_collinear<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(found_collinear);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Note that there are no three collinear points among the points defined in the input file <computeroutput>points.dat</computeroutput>. In the second part of the example the existence of collinearity is forced and verified as follows. A line dual to the midpoint of two randomly selected points is introduced, and inserted into the arrangement. This operation is followed by a test that verifies that a vertex of degree greater than <formula id="96">$ 4$</formula> exists. This implied that collinearity indeed exists as explained above.</para></sect2>
<sect2 id="index_1arr_ssecunb_rep">
<title>Representation of Unbounded Arrangements</title>
<para></para><para><anchor id="index_1fig__typenormal"/><image type="html" name="unb_dcel.png"></image>
 <image type="latex" name="unb_dcel.png" width="15cm"></image>
  <ref refid="index_1fig__typenormal" kindref="member">fig__typenormal</ref> A Dcel representing an arrangement of four lines. Halfedges are drawn as thin arrows. The vertices <formula id="97">$ v_1, \ldots, v_8$</formula> lie at infinity, and are not associated with valid points. The halfedges that connect them are fictitious, and are not associated with concrete curves. The face denoted <formula id="16">$ f_0$</formula> (lightly shaded) is the fictitious &quot;unbounded face&quot; which lies outside the bounding rectangle (dashed) that bounds the actual arrangement. The four fictitious vertices <formula id="98">$ v_{\rm bl}, v_{\rm tl}, v_{\rm br}$</formula> and <formula id="99">$ v_{\rm tr}$</formula> represent the four corners of the bounding rectangle.  <linebreak/>
</para><para>Given a set <formula id="0">$ \cal C$</formula> of unbounded curves, a simple approach for representing the arrangement induced by <formula id="0">$ \cal C$</formula> would be to clip the unbounded curves using an axis-parallel rectangle that contains all finite curve endpoints and intersection points between curves in <formula id="0">$ \cal C$</formula>. This process would result in a set <formula id="0">$ \cal C$</formula> of bounded curves (line segments if <formula id="0">$ \cal C$</formula> contains lines and rays), and it would be straightforward to compute the arrangement induced by this set. However, we would like to operate directly on the unbounded curves without having to preprocess them. Therefore, we use an implicit bounding rectangle embedded in the Dcel structure. <ref refid="index_1fig__arr_figunb_dcel" kindref="member">fig__arr_figunb_dcel</ref> shows the arrangement of four lines that subdivide the plane into eight unbounded faces and two bounded ones. Notice that in this case the unbounded faces have outer boundaries, and the halfedges along these outer CCBs are drawn as arrows. The bounding rectangle is drawn with a dashed line. The vertices <formula id="100">$ v_1,v_2,\ldots,v_8$</formula>, which represent the unbounded ends of the four lines, and lie on the bounding rectangle, actually exist at infinity, and the halfedges connecting them are <emphasis>fictitious</emphasis>, and represent portions of the bounding rectangle. Note that the outer CCBs of the unbounded faces contain fictitious halfedges. The twins of these halfedges form together one connected component that corresponds to the entire bounding rectangle, which forms a single hole in a face <formula id="16">$ f_0$</formula>. We say that <formula id="16">$ f_0$</formula> is <emphasis>fictitious</emphasis>, as it does not correspond to a real two-dimensional cell of the arrangement.</para><para>Observe that there are four extra vertices at infinity that do not lie on any curve; they are denoted as <formula id="98">$ v_{\rm bl}, v_{\rm tl}, v_{\rm br}$</formula>, and <formula id="99">$ v_{\rm tr}$</formula>, and represent the bottom-left, top-left, bottom-right, and top-right corners of the bounding rectangle, respectively. Similarly, there are fictitious halfedges that lie on the top, the bottom, the left, or the right edge of the bounding rectangle. When the arrangement is empty, there are exactly four pairs of fictitious halfedges, that divide the plane into two faces, namely a fictitious face lying outside of the bounding rectangle and a single unbounded face bounded by the bounding rectangle.</para><para>Summarizing the above, there are four types of arrangement vertices, which differ from one another by their location with respect to the bounding bounding rectangle: <orderedlist>
<listitem>
<para>A vertex, associated with a point in <formula id="101">$ \mathbb{R}^2$</formula> whose coordinates are bounded. Such a vertex always lies inside the bounding rectangle. </para></listitem>
<listitem>
<para><anchor id="index_1typeunbounded"/>A vertex that represents an unbounded end of an <formula id="2">$ x$</formula>-monotone curve that is defined at <formula id="102">$ x = -\infty$</formula> or at <formula id="103">$ x = \infty$</formula>. In case of a horizontal line or a curve with a horizontal asymptote, the <formula id="104">$ y$</formula>-coordinate of the curve end may be finite (see for example the vertices <formula id="18">$ v_2$</formula> and <formula id="105">$ v_7$</formula> in <ref refid="index_1fig__arr_figunb_dcel" kindref="member">fig__arr_figunb_dcel</ref>), but in general the curve end also goes to <formula id="106">$ y = \pm\infty$</formula> (see for instance the vertices <formula id="17">$ v_1$</formula>, <formula id="107">$ v_3$</formula>, <formula id="59">$ v_6$</formula> and <formula id="108">$ v_8$</formula> in <ref refid="index_1fig__arr_figunb_dcel" kindref="member">fig__arr_figunb_dcel</ref>). For our convenience, we will always take a &quot;tall&quot; enough bounding rectangle and treat such vertices as lying on either the left or right rectangle edges (that is, if a curve is defined at <formula id="102">$ x = -\infty$</formula>, its left end will be represented by a vertex on the left edge of the bounding rectangle, and if it is defined at <formula id="103">$ x = \infty$</formula>, its right end will be represented by a vertex of the right edge). </para></listitem>
<listitem>
<para>A<anchor id="index_1typeunboundedvertical"/>vertex that represent the unbounded end of a vertical line or of a curve with a vertical asymptote (finite <formula id="2">$ x$</formula>-coordinate and an unbounded <formula id="104">$ y$</formula>-coordinate). Such a vertex always lies on one of the horizontal edges of the bounding rectangle (either the bottom one if <formula id="109">$ y = -\infty$</formula>, or the top one if <formula id="110">$ y = \infty$</formula>). The vertices <formula id="111">$ v_4$</formula> and <formula id="112">$ v_5$</formula> in <ref refid="index_1fig__arr_figunb_dcel" kindref="member">fig__arr_figunb_dcel</ref> are of this type. </para></listitem>
<listitem>
<para>The<anchor id="index_1typefictitious"/>fictitious vertices that represent the four corners of the bounding bounding rectangle. </para></listitem>
</orderedlist>
</para><para>A vertex (at infinity) of Type <ref refid="index_1typeunbounded" kindref="member">typeunbounded</ref> or Type <ref refid="index_1typeunboundedvertical" kindref="member">typeunboundedvertical</ref> above always has three incident edges: one concrete edge that is associated with an unbounded portion of an <formula id="2">$ x$</formula>-monotone curve, and two fictitious edges connecting the vertex to its neighboring vertices at infinity. Fictitious vertices (of type 4 above) have exactly two incident edges. See Section <ref refid="index_1arr_sectraits" kindref="member">Traits Classes</ref> on how the traits-class interface helps imposing the fact that we never have more than one curve incident to any true vertex at infinity.</para><para>The nested types defined in the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class support the following methods, in addition to the ones listed in Section <ref refid="index_1arr_ssectraverse" kindref="member">Traversing the Arrangement</ref> : <itemizedlist>
<listitem>
<para>The <computeroutput>Vertex</computeroutput> class provides three-valued predicates <computeroutput>parameter_space_in_x()</computeroutput> and <computeroutput>parameter_space_in_y()</computeroutput>, which return the location of the geometric embedding of the vertex in the parameter space. In particular, the former returns <computeroutput>ARR_LEFT_BOUNDARY</computeroutput>, <computeroutput>ARR_INTERIOR</computeroutput>, or <computeroutput>ARR_RIGHT_BOUNDARY</computeroutput>, and the latter returns <computeroutput>ARR_BOTTOM_BOUNDARY</computeroutput>, <computeroutput>ARR_INTERIOR</computeroutput>, or <computeroutput>ARR_TOP_BOUNDARY</computeroutput>. As the package currently supports only the case where the parameter space is the compactified plane, the former returns <computeroutput>ARR_INTERIOR</computeroutput> if the <formula id="2">$ x$</formula>-coordinate associated with the vertex is finite, <computeroutput>ARR_LEFT_BOUNDARY</computeroutput> if it is <formula id="113">$ -\infty$</formula>, and <computeroutput>ARR_RIGHT_BOUNDARY</computeroutput> if it is <formula id="114">$ \infty$</formula>. The latter returns <computeroutput>ARR_INTERIOR</computeroutput> if the <formula id="104">$ y$</formula>-coordinate associated with the vertex is finite, <computeroutput>ARR_BOTTOM_BOUNDARY</computeroutput> if it is <formula id="113">$ -\infty$</formula>, and <computeroutput>ARR_TOP_BOUNDARY</computeroutput> if it is <formula id="114">$ \infty$</formula>. The Boolean predicate <computeroutput>is_at_open_boundary()</computeroutput> is also provided. You can access the point associated with a vertex only if it is not a vertex at an open boundary (recall that a vertex at an open boundary is not associated with a <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> object). </para></listitem>
<listitem>
<para>The nested <computeroutput>Halfedge</computeroutput> class provides the Boolean predicate <computeroutput>is_fictitious()</computeroutput>. The <formula id="2">$ x$</formula>-monotone curve associated with a halfedge can be accessed by the <computeroutput>curve()</computeroutput> method only if the halfedge is not fictitious. </para></listitem>
<listitem>
<para>The nested <computeroutput>Face</computeroutput> class provides the Boolean predicate <computeroutput>f.is_fictitious()</computeroutput>. The method <computeroutput>outer_ccb()</computeroutput> has the precondition that the face is not fictitious. Note that non-fictitious unbounded faces always have valid CCBs (although this CCB may comprise only fictitious halfedge in case the arrangement contains only bounded curves). </para></listitem>
</itemizedlist>
</para><para>The method <computeroutput>arr.number_of_edges()</computeroutput> does not count the number of fictitious edges, (which is always <computeroutput>arr.number_of_vertices_at_infinity() + 4</computeroutput>), and the iterators returned by <computeroutput>arr.edges_begin()</computeroutput> and <computeroutput>arr.edges_end()</computeroutput> specify a range of non-fictitious edges. Similarly, <computeroutput>arr.number_of_faces()</computeroutput> does not count the fictitious face. However, the <computeroutput>Ccb_halfedge_circulator</computeroutput> of the outer boundary of an unbounded face or the <computeroutput>Halfegde_around_vertex_circulator</computeroutput> of a vertex at infinity do traverse fictitious halfedges. For example, it is possible to traverse the outer boundaries of the unbounded arrangement edges using the following procedure:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Unbounded_face_const_iterator<sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Ccb_halfedge_const_circulator<sp/>first,<sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Halfedge_const_handle<sp/>he;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>k<sp/>=<sp/>1;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(fit<sp/>=<sp/>arr.unbounded_faces_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fit<sp/>!=<sp/>arr.unbounded_faces_end();<sp/>++fit,<sp/>k++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;Unbounded<sp/>face<sp/>no.<sp/>&quot;<sp/>&lt;&lt;<sp/>k<sp/>&lt;&lt;<sp/>&quot;:<sp/>&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>curr<sp/>=<sp/>first<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!<sp/>curr-&gt;source()-&gt;is_at_infinity())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;(&quot;<sp/>&lt;&lt;<sp/>curr-&gt;source()-&gt;point()<sp/>&lt;&lt;<sp/>&quot;)&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>do<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>he<sp/>=<sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!<sp/>he-&gt;is_fictitious())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;<sp/>[&quot;<sp/>&lt;&lt;<sp/>he-&gt;curve()<sp/>&lt;&lt;<sp/>&quot;]<sp/>&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;<sp/>[<sp/>...<sp/>]<sp/>&quot;;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!<sp/>he-&gt;target()-&gt;is_at_infinity())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;(&quot;<sp/>&lt;&lt;<sp/>he-&gt;target()-&gt;point()<sp/>&lt;&lt;<sp/>&quot;)&quot;;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>while<sp/>(curr<sp/>!=<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
<sect1 id="index_1arr_sectraits">
<title>Traits Classes</title>
<para>As mentioned in the introduction of this chapter, the traits class encapsulates the definitions of the geometric entities and implements the geometric predicates and constructions needed by the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class and by its peripheral algorithms. We also mention throughout the chapter that there are different levels of requirements from the traits class, namely the traits class can model different concept refinement-levels.</para><sect2 id="index_1arr_sssectr_concepts">
<title>The Hierarchy of Traits-Class Concepts</title>
</sect2>
<sect2 id="index_1arr_sssectr_basic_concept">
<title>The Basic Concept</title>
<para>A model of the basic concept, <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput>, needs to define the types <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> and <computeroutput>X_monotone_curve_2</computeroutput>, where objects of the first type are the geometric mapping of arrangement vertices, and objects of the latter type are the geometric mapping of edges. Such a model has to support in addition the following set of operations: <variablelist>
<varlistentry><term><bold><computeroutput>Compare_x_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Compares the <formula id="2">$ x$</formula>-coordinates of two points. </para></listitem>
<varlistentry><term><bold><computeroutput>Compare_xy_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Compares two points lexicographically, by their <formula id="2">$ x$</formula>-coordinates and then (in case of equality) by their <formula id="104">$ y$</formula>-coordinates. </para></listitem>
<varlistentry><term><bold><computeroutput>Construct_min_vertex_2</computeroutput>,<computeroutput>Construct_max_vertex_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Returns the left endpoint (similarly, the right endpoint) of an <formula id="2">$ x$</formula>-monotone curve. </para></listitem>
<varlistentry><term><bold><computeroutput>Compare_y_at_x_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Given an <formula id="2">$ x$</formula>-monotone curve <formula id="44">$ c$</formula> and a point <formula id="46">$ p$</formula> that lies in its <formula id="2">$ x$</formula>-range, this predicate determines whether <formula id="46">$ p$</formula> lies below, above or on <formula id="44">$ c$</formula>. </para></listitem>
<varlistentry><term><bold><computeroutput>Compare_y_at_x_right_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Given two <formula id="2">$ x$</formula>-monotone curves <formula id="48">$ c_1$</formula> and <formula id="49">$ c_2$</formula> that share a common left endpoint <formula id="46">$ p$</formula>, this predicate determines whether <formula id="48">$ c_1$</formula> lies above or under <formula id="49">$ c_2$</formula> immediately to the right of <formula id="46">$ p$</formula>, or whether the two curves coincide there. </para></listitem>
<varlistentry><term><bold><computeroutput>Equal_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Checks two points and two curves for equality (two curves are equal if their graph is the same). </para></listitem>
<varlistentry><term><bold><computeroutput>Is_vertical_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Determines whether an <formula id="2">$ x$</formula>-monotone curve is vertical. </para></listitem>
</variablelist>
</para><para>Each model of the concept <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> needs to define a tag named <computeroutput>Has_left_category</computeroutput>. It determines whether the traits class supports the following predicate: <variablelist>
<varlistentry><term><bold><computeroutput>Compare_y_at_x_left_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Given two <formula id="2">$ x$</formula>-monotone curves <formula id="48">$ c_1$</formula> and <formula id="49">$ c_2$</formula> that share a common right endpoint <formula id="46">$ p$</formula>, this predicate determines whether <formula id="48">$ c_1$</formula> lies above or under <formula id="49">$ c_2$</formula> immediately to the left of <formula id="46">$ p$</formula>, or whether the two curves coincide there. </para></listitem>
</variablelist>
This predicate is optional, as it can be answered using the other traits-class primitives, and we wish to alleviate the need to implement an extra method that is not absolutely necessary. However, as implementing the predicate directly may prove to be more efficient, the traits-class implementer may choose to provide it.</para><para>The basic set of predicates is sufficient for constructing arrangements of <formula id="2">$ x$</formula>-monotone curves that do not reach or approach the boundary of the parameter space. The nature of the input curves, i.e., whether some of them are expected to reach or approach the left, right, bottom, or top side of the boundary of the parameter space, must be conveyed by the traits class. This is done through the definition of four additional nested types, namely <computeroutput>Left_side_category</computeroutput>, <computeroutput>Right_side_category</computeroutput>, <computeroutput>Bottom_side_category</computeroutput>, and <computeroutput>Top_side_category</computeroutput>. Each of those types must be convertible to the type <computeroutput><ref refid="structCGAL_1_1Arr__oblivious__side__tag" kindref="compound">Arr_oblivious_side_tag</ref></computeroutput> for the class to be a model of the concept <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput>.</para></sect2>
<sect2 id="index_1arr_sssectr_lanmarks_concept">
<title>The Landmarks Concept</title>
<para>The type of an arrangement associated with the landmark point-location strategy (see Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>) must be an instance of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template, where the <computeroutput>Traits</computeroutput> parameter is substituted with a model of the concept <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput>. (Naturally, it can also model either the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept or the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept.) The <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept refines the two concepts <computeroutput><ref refid="classArrangementApproximateTraits__2" kindref="compound">ArrangementApproximateTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput>. Each of these two concepts, in turn, refines the concept <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput>.</para><para>A model of the <computeroutput><ref refid="classArrangementApproximateTraits__2" kindref="compound">ArrangementApproximateTraits_2</ref></computeroutput> concept must define a fixed precision number type (typically the double-precision floating-point <computeroutput>double</computeroutput>) and support the additional below (in addition to fulfilling the requirements listed by the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept). <variablelist>
<varlistentry><term><bold><computeroutput>Approximate_2</computeroutput>:</bold> </term></varlistentry>
<listitem><para>Given a point <computeroutput>p</computeroutput>, approximate the <formula id="2">$ x$</formula> and <formula id="104">$ y$</formula>-coordinates of <computeroutput>p</computeroutput> using the fixed precision number type. We use this operation for approximate computations<mdash/>there are certain operations in the search for the location of the point that need not be exact and we can perform them faster than other operations. </para></listitem>
</variablelist>
</para><para>A model of the <computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput> concept support the operation below (in addition to fulfilling the requirements listed by the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept). <variablelist>
<varlistentry><term><bold><computeroutput>Construct_x_monotone_curve_2</computeroutput>:</bold> </term></varlistentry>
<listitem><para>Given two points <formula id="115">$ p_1$</formula> and <formula id="116">$ p_2$</formula>, this predicate constructs an <formula id="2">$ x$</formula>-monotone curve connecting <formula id="115">$ p_1$</formula> and <formula id="116">$ p_2$</formula>. </para></listitem>
</variablelist>
</para></sect2>
<sect2 id="index_1arr_sssectr_xmon_concept">
<title>Supporting Intersecting x-Monotone Curves</title>
<para>A traits class that models the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept, which refines the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, has to support the following functions: <variablelist>
<varlistentry><term><bold><computeroutput>Intersection_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Computes all intersection points and overlapping sections of two given <formula id="2">$ x$</formula>-monotone curves. If possible, computes also the multiplicity of each intersection point.If the two curves intersect at a point <formula id="46">$ p$</formula> but have different tangents, <formula id="46">$ p$</formula> is of multiplicity 1. If the tangents are also equal but the their curvatures are not the same, <formula id="46">$ p$</formula> is of multiplicity 2, etc. Knowing the multiplicity of an intersection point is not required, but it can speed up the arrangement construction. </para></listitem>
<varlistentry><term><bold><computeroutput>Split_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Splits an <formula id="2">$ x$</formula>-monotone curve <formula id="44">$ c$</formula> into two subcurves at a point <formula id="46">$ p$</formula> lying in the interior of <formula id="44">$ c$</formula>. </para></listitem>
<varlistentry><term><bold><computeroutput>Are_mergeable_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Given two <formula id="2">$ x$</formula>-monotone curve <formula id="48">$ c_1$</formula> and <formula id="49">$ c_2$</formula> that share a common endpoint, this predicate determines whether <formula id="48">$ c_1$</formula> and <formula id="49">$ c_2$</formula> are <emphasis>mergeable</emphasis>, that is, whether they can be merged to form a single continuous <formula id="2">$ x$</formula>-monotone curve of the type supported by the traits class. </para></listitem>
<varlistentry><term><bold><computeroutput>Merge_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Merges two mergeable <formula id="2">$ x$</formula>-monotone curves. </para></listitem>
</variablelist>
Using a model of the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>, it is possible to construct arrangements of sets of <formula id="2">$ x$</formula>-monotone curves (and points) that may intersect one another.</para></sect2>
<sect2 id="index_1arr_sssectr_full_concept">
<title>Supporting Arbitrary Curves</title>
<para>The concept <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> refines the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept by adding the notion of a general, not necessarily <formula id="2">$ x$</formula>-monotone (and not necessarily continuous) curve. A model of this concept must define the <computeroutput>Curve_2</computeroutput> type and support the subdivision of a curve into a set of continuous <formula id="2">$ x$</formula>-monotone curves and isolated points using the predicate <computeroutput>Make_x_monotone_2</computeroutput>. For example, the curve <formula id="117">$ C:\ (x^2 + y^2)(x^2 + y^2 - 1) = 0$</formula> is the unit circle (the loci of all points for which <formula id="118">$ x^2 + y^2 = 1$</formula>) with the origin <formula id="89">$ (0,0)$</formula> as a singular point in its interior. <formula id="3">$ C$</formula> should therefore be divided into two circular arcs (the upper part and the lower part of the unit circle) and a single isolated point.</para><para>Note that the refined model <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> is required only when using the free <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> functions (see Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions in the Arrangement Package</ref>), which accept a <computeroutput>Curve_2</computeroutput> object in the incremental version, or a range of <computeroutput>Curve_2</computeroutput> objects in the aggregated version. In all other cases it is sufficient to use a model of the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept.</para></sect2>
<sect2 id="index_1Arrangement_on_surface_2SupportingUnbounded">
<title>Supporting Unbounded Curves</title>
<para>An arrangement that supports unbounded <formula id="2">$ x$</formula>-monotone curves maintains an implicit bounding rectangle in the Dcel structure; see Section <ref refid="index_1arr_ssecunb_rep" kindref="member">Representation of Unbounded Arrangements</ref>. The unbounded ends of vertical rays, vertical lines, and curves with vertical asymptotes are represented by vertices that lie on the bottom or top sides of this bounding rectangle. These vertices are not associated with points, but are associated with (finite) <formula id="2">$ x$</formula>-coordinates. The unbounded ends of all other curves are represented by vertices that lie on the left or right sides of this bounding rectangle. These vertices are not associated with points either. Edges connect these vertices and the four vertices that represents the corners of this bounding rectangle to form the rectangle.</para><para>Several predicates are required to handle <formula id="2">$ x$</formula>-monotone curves that approach infinity and thus approach the boundary of the parameter space. These predicates are sufficient to handle not only curves embedded in an unbounded parameter space, but also curves embedded in a bounded parameter space with open boundaries. Let <formula id="32">$ b_l$</formula> and <formula id="33">$ b_r$</formula> denote the <formula id="2">$ x$</formula>-coordinates of the left and right boundaries of the parameter space, respectively. Let <formula id="34">$ b_b$</formula> and <formula id="35">$ b_t$</formula> denote the <formula id="104">$ y$</formula>-coordinates of the bottom and top boundaries of the parameter space, respectively. Recall that currently the general code of the arrangement only supports the case where the parameter space is the entire compactified plane, thus <formula id="36">$ b_l = b_b = -\infty$</formula> and <formula id="37">$ b_r = b_t = +\infty$</formula>. Nonetheless, when the parameter space is bounded, it is the exact geometric embedding of the implicit bounding rectangle. In the following we assume that an <formula id="2">$ x$</formula> monotone curve <formula id="3">$ C$</formula> can be considered as a parametric curve <formula id="119">$ C(t) = (X(t),Y(t))$</formula> defined over a closed, open, or half open interval with endpoints <formula id="120">$ 0$</formula> and <formula id="121">$ 1$</formula>.</para><para>Models of the concept <computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput> handle curves that approach the boundary of the parameter space. This concept refines the concept <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput>. The arrangement template instantiated with a traits class that models this concept can handle curves that are unbounded in any direction. If some curves inserted into an arrangement object are expected to be unbounded, namely, there exists <formula id="122">$ d \in \{0,1\}$</formula> such that <formula id="123">$ \lim_{t \rightarrow d}X(t) = \pm\infty$</formula> or <formula id="124">$ \lim_{t \rightarrow d}y(t) = \pm\infty$</formula> holds for at least one input curve <formula id="119">$ C(t) = (X(t),Y(t))$</formula>, the arrangement template must be instantiated with a model of the <computeroutput>ArrangementOpenBoundaryTraits</computeroutput> concept.We intend to enhance the arrangement template to handle curves confined to a bounded yet open parameter space. A curve that reaches the boundary of the parameter space in this case is bounded and open.</para><para>All the four types <computeroutput>Left_side_category</computeroutput>, <computeroutput>Right_side_category</computeroutput>, <computeroutput>Bottom_side_category</computeroutput>, and <computeroutput>Top_side_category</computeroutput> nested in a model of the concept <computeroutput>ArrangementOpenBoundaryTraits</computeroutput> must be convertible to <computeroutput><ref refid="structCGAL_1_1Arr__open__side__tag" kindref="compound">Arr_open_side_tag</ref></computeroutput>.The tags <computeroutput><ref refid="structCGAL_1_1Arr__oblivious__side__tag" kindref="compound">Arr_oblivious_side_tag</ref></computeroutput> and <computeroutput><ref refid="structCGAL_1_1Arr__open__side__tag" kindref="compound">Arr_open_side_tag</ref></computeroutput> are only two out of a larger number of options for the side categories included in major extension the code is going through. For example, the <computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">Arr_rational_function_traits_2</ref></computeroutput> traits-model supports unbounded curves; see Section <ref refid="index_1arr_ssectr_ratfunc" kindref="member">A Traits Class for Arcs of Rational Functions</ref>. Thus, all four nested types are defined as <computeroutput><ref refid="structCGAL_1_1Arr__open__side__tag" kindref="compound">Arr_open_side_tag</ref></computeroutput>. Adversely, all four types nested in the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> traits-model (see Section <ref refid="index_1arr_ssectr_segs" kindref="member">Traits Classes for Line Segments and Linear Objects</ref>) are defined as <computeroutput><ref refid="structCGAL_1_1Arr__oblivious__side__tag" kindref="compound">Arr_oblivious_side_tag</ref></computeroutput>, as segments are always bounded.We intend to introduce more concepts that require only a subset of the categories to be convertible to <computeroutput><ref refid="structCGAL_1_1Arr__open__side__tag" kindref="compound">Arr_open_side_tag</ref></computeroutput>.</para><para>A model of the concept <computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput> must provide the additional predicates listed below. <formula id="2">$ x$</formula>-coordinates and <formula id="104">$ y$</formula>-coordinates are differently handled. This asymmetry is brought on by the various algorithms applied to arrangements, the input and output arguments of which are <formula id="2">$ x$</formula>-monotone curves. Indeed, all curves maintained by any arrangement are continuous weakly <formula id="2">$ x$</formula>-monotone curves. A non <formula id="2">$ x$</formula>-monotone curve is divided into <formula id="2">$ x$</formula>-monotone sub curves (and perhaps points) before it is inserted into an arrangement. This asymmetry is also reflected in the additional predicates listed below.</para><para><variablelist>
<varlistentry><term><bold><computeroutput>Parameter_space_in_x_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Given a parametric <formula id="2">$ x$</formula>-monotone curve <formula id="119">$ C(t) = (X(t),Y(t))$</formula> and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value <formula id="122">$ d \in \{0,1\}$</formula>, this predicate determines the location of the curve end along the <formula id="2">$ x$</formula>-dimension. Formally, the predicate determines whether <formula id="125">$ \lim_{t \rightarrow d} X(t)$</formula> evaluates to <formula id="32">$ b_l$</formula>, <formula id="33">$ b_r$</formula>, or a value in between. </para></listitem>
<varlistentry><term><bold><computeroutput>Compare_y_near_boundary_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Given two <formula id="2">$ x$</formula>-monotone curves <formula id="126">$ C_1$</formula> and <formula id="127">$ C_2$</formula> and an enumerator <formula id="128">$ i$</formula> that specifies either the minimum ends or the maximum ends of the two curves, this predicate compares the <formula id="104">$ y$</formula>-coordinates of the curves near their respective ends. That is, the predicate compares the <formula id="104">$ y$</formula>-coordinates of the vertical projection of a point <formula id="46">$ p$</formula> onto <formula id="126">$ C_1$</formula> and onto <formula id="127">$ C_2$</formula>. If the enumerator <formula id="128">$ i$</formula> specifies the minimum ends, the curves must approach the left boundary-side. In this case <formula id="46">$ p$</formula> is located far to the left, such that the result is invariant under a translation of <formula id="46">$ p$</formula> farther to the left. If <formula id="128">$ i$</formula> specifies the maximum ends, the curves must approach the right boundary-side. In that case <formula id="46">$ p$</formula> is located far to the right in a similar manner. </para></listitem>
<varlistentry><term><bold><computeroutput>Parameter_space_in_y_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Given a parametric <formula id="2">$ x$</formula>-monotone curve <formula id="119">$ C(t) = (X(t),Y(t))$</formula> and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value <formula id="122">$ d \in \{0,1\}$</formula>, this predicate determines the location of the curve end along the <formula id="104">$ y$</formula>-dimension. Formally, the predicate determines whether <formula id="129">$ \lim_{t \rightarrow d} Y(t)$</formula> evaluates to <formula id="34">$ b_b$</formula>, <formula id="35">$ b_t$</formula>, or a value in between. </para></listitem>
<varlistentry><term><bold><computeroutput>Compare_x_at_limit_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Two versions of this predicate are provided: (i) Given a point <formula id="46">$ p$</formula>, a parametric <formula id="2">$ x$</formula>-monotone curve <formula id="119">$ C(t) = (X(t),Y(t))$</formula>, and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value <formula id="122">$ d \in \{0,1\}$</formula>, this predicate compares the <formula id="2">$ x$</formula>-coordinate of <formula id="46">$ p$</formula> and <formula id="125">$ \lim_{t \rightarrow d} X(t)$</formula>. If the parameter space is unbounded, a precondition assures that <formula id="3">$ C$</formula> has a vertical asymptote at its <formula id="63">$ d$</formula>-end; that is <formula id="125">$ \lim_{t \rightarrow d} X(t)$</formula> is finite. (ii) Given two parametric <formula id="2">$ x$</formula>-monotone curves <formula id="130">$ C_1(t) = (X_1(t),Y_1(t))$</formula> and <formula id="131">$ C_2(t) = (X_2(t),Y_2(t))$</formula> and two enumerators that specify either the minimum end or the maximum end of each curve, and thus map to parameter values <formula id="132">$ d_1\in \{0,1\}$</formula> and <formula id="133">$ d_2 \in \{0,1\}$</formula> for <formula id="126">$ C_1$</formula> and for <formula id="127">$ C_2$</formula>, respectively, this predicate compares <formula id="134">$ \lim_{t \rightarrow d_1} X_1(t)$</formula> and <formula id="135">$ \lim_{t \rightarrow d_2} X_2(t)$</formula>. If the parameter space is unbounded, a precondition assures that <formula id="126">$ C_1$</formula> and <formula id="127">$ C_2$</formula> have vertical asymptote at their respective ends; that is <formula id="134">$ \lim_{t \rightarrow d_1} X_1(t)$</formula> and <formula id="135">$ \lim_{t \rightarrow d_2} X_2(t)$</formula> are finite. </para></listitem>
<varlistentry><term><bold><computeroutput>Compare_x_near_limit_2</computeroutput>:</bold></term></varlistentry>
<listitem><para>Given two <formula id="2">$ x$</formula>-monotone curves <formula id="126">$ C_1$</formula> and <formula id="127">$ C_2$</formula> and an enumerator <formula id="128">$ i$</formula> that specifies either the minimum ends or the maximum ends of the two curves, this predicate compares the <formula id="2">$ x$</formula>-coordinates of the curves near their respective ends. That is, the predicate compares the <formula id="2">$ x$</formula>-coordinates of the horizontal projection of a point <formula id="46">$ p$</formula> onto <formula id="126">$ C_1$</formula> and onto <formula id="127">$ C_2$</formula>. If the parameter space is unbounded, a precondition assures that <formula id="126">$ C_1$</formula> and <formula id="127">$ C_2$</formula> have vertical asymptote at their respective ends. Furthermore, both curves approach the same boundary-side, either the bottom or the top, at their respective ends. If both curves approach the bottom boundary-side, <formula id="46">$ p$</formula> is located far to the bottom, such that the result is invariant under a translation of <formula id="46">$ p$</formula> farther to the bottom. If both curves approach the top boundary-side, <formula id="46">$ p$</formula> is located far to the top in a similar manner. Another precondition assures that the <formula id="2">$ x$</formula>-coordinates of the limits of the curves at their respective ends are equal. That is, the predicate <computeroutput>Compare_x_at_limit_2</computeroutput> applied to <formula id="126">$ C_1$</formula>, <formula id="127">$ C_2$</formula>, and <formula id="128">$ i$</formula> evaluates to <computeroutput>EQUAL</computeroutput>. </para></listitem>
</variablelist>
</para><para>In the rest of this section we review the traits classes included in the public distribution of CGAL, that handle line segments, polylines, conic arcs, rational functions, and arcs of B<eacute/>zier and algebraic curves. The last subsection overviews decorators for geometric traits classes distributed with CGAL, which extend other geometric traits-class by attaching auxiliary data with the geometric objects.</para></sect2>
<sect2 id="index_1arr_ssectr_segs">
<title>Traits Classes for Line Segments and Linear Objects</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class used so far in most example programs in this chapter is a model of the concepts <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput>, and <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>; the later enables Boolean set operations. It is parameterized by a geometric kernel and uses the <computeroutput><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref></computeroutput> type as it point type. However, neither the <computeroutput>Curve_2</computeroutput> nor the <computeroutput>X_monotone_curve_2</computeroutput> types are identical to the <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> type. A kernel segment is typically represented by its two endpoints, and these may have a large bit-size representation, if the segment is intersected and split several times (in comparison with the representation of its original endpoints). The large representation may significantly slow down the various traits-class operations involving such a segment. In contrast, the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> represents a segment using its supporting line and the two endpoints, such that most computations are performed on the supporting line, which never changes as the segment is split. It also caches some additional information with the segment to speed up various predicates. An <computeroutput>X_monotone_curve_2</computeroutput> object can still be constructed from two endpoints or from a kernel segment. Moreover, an <computeroutput>X_monotone_curve_2</computeroutput> instance can also be casted or assigned to a <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> object. The two types are thus fully convertible to one another.</para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class is very efficient for maintaining arrangements of a large number of intersecting line segments, especially if it is instantiated with the appropriate geometric kernel. Using <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput> as the kernel type, which is the default, is generally a good choice; the coordinates of the segment endpoints are represented as exact rational numbers, and this ensures the robustness and correctness of any computation.Many of the example programs in the rest of the chapter include a header file named <computeroutput>arr_rational_nt.h</computeroutput>, which defines a type named <computeroutput>Number_type</computeroutput> as either <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput> or <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;<ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref>&gt;</computeroutput>, depending on whether Gmp is installed or not.</para><para>An instance of the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template can be very efficient for constructing arrangements induced by line segments with a large number of intersections. Efficiency is affected by the substituted geometric kernel. Using <computeroutput><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref>&lt;<ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref>&gt;</computeroutput> as the kernel type is in general not a bad choice; the coordinates of the segment endpoints are represented as multi-precision rational-numbers, and this ensures the correctness of all computations regardless of the input. Computations on multi-precision number types, such as <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput>, typically take longer than computations on machine-precision floating-point. However, in almost all cases it is possible to expedite the computation using numerical filtering; see <computeroutput>Kernel_2</computeroutput> and <computeroutput>Kernel_3</computeroutput>. If the input set of line segments do not have degeneracies; namely, no two segments in the set share a common endpoint, and no three segments intersect at a common point, or at least, degeneracies exist but their number is relatively small, then filtered computation incurs only negligible overhead compared to floating-point arithmetic, which is error-prone. Indeed, in almost all examples and applications given in this manual, a predefined filtered kernel is used to instantiate the line-segment traits class, namely <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput>. Furthermore, this kernel is used as a default kernel in case the user did not provide one.</para><para><anchor id="index_1fig__arr_figpredef_kernels"/><center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="fan_grids.png"></image>
 <image type="latex" name="fan_grids.png" width="7.5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="Europe.png"></image>
 <image type="latex" name="Europe.png" width="7.5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__arr_figpredef_kernels" kindref="member">fig__arr_figpredef_kernels</ref> (a) An arrangement of <formula id="136">$ 104$</formula> line segments from the input file <computeroutput>fan_grids.dat</computeroutput>. (b) An arrangement of more than <formula id="137">$ 3000$</formula> interior disjoint line segments, defined in the input file <computeroutput>Europe.dat</computeroutput>.  <linebreak/>
</para><para>In the following example we use the predefined <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput> for instantiating our segment-traits class. This kernel use interval arithmetic to filter the exact computations. The program reads a set of line segments with integer coordinates from a file and computes their arrangement. By default it opens the <computeroutput>fan_grids.dat</computeroutput> input-file, located in the examples folder, which contains <formula id="136">$ 104$</formula> line segments that form four &quot;fan-like&quot; grids and induce a dense arrangement, as illustrated in <ref refid="index_1fig__arr_figpredef_kernels" kindref="member">fig__arr_figpredef_kernels</ref> (a):</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2predefined_kernel_8cpp-example" kindref="compound">Arrangement_on_surface_2/predefined_kernel.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangements<sp/>of<sp/>intersecting<sp/>line<sp/>segments<sp/>using<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>predefined<sp/>kernel<sp/>with<sp/>exact<sp/>constructions<sp/>and<sp/>exact<sp/>predicates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>fan_grids.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;fan_grids.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/><sp/><sp/><sp/><sp/>in_file<sp/>(filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>segments<sp/>from<sp/>the<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>input<sp/>file<sp/>format<sp/>should<sp/>be<sp/>(all<sp/>coordinate<sp/>values<sp/>are<sp/>integers):</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>number<sp/>of<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;sx_1&gt;<sp/>&lt;sy_1&gt;<sp/><sp/>&lt;tx_1&gt;<sp/>&lt;ty_1&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>source<sp/>and<sp/>target<sp/>of<sp/>segment<sp/>#1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;sx_2&gt;<sp/>&lt;sy_2&gt;<sp/><sp/>&lt;tx_2&gt;<sp/>&lt;ty_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>source<sp/>and<sp/>target<sp/>of<sp/>segment<sp/>#2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;sx_n&gt;<sp/>&lt;sy_n&gt;<sp/><sp/>&lt;tx_n&gt;<sp/>&lt;ty_n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>source<sp/>and<sp/>target<sp/>of<sp/>segment<sp/>#n.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Segment_2&gt;<sp/><sp/>segments;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>sx,<sp/>sy,<sp/>tx,<sp/>ty;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>sx<sp/>&gt;&gt;<sp/>sy<sp/>&gt;&gt;<sp/>tx<sp/>&gt;&gt;<sp/>ty;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>segments.push_back<sp/>(Segment_2<sp/>(Point_2<sp/>(Number_type(sx),<sp/>Number_type(sy)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(Number_type(tx),<sp/>Number_type(ty))));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>by<sp/>aggregately<sp/>inserting<sp/>all<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Timer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Performing<sp/>aggregated<sp/>insertion<sp/>of<sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>segments.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>segments.begin(),<sp/>segments.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.stop();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>dimensions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construction<sp/>took<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>timer.time()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The arrangement package also offers a simpler alternative segment-traits class. The traits class <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__basic__traits__2" kindref="compound">Arr_non_caching_segment_basic_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> models the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept. It uses <computeroutput><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref></computeroutput> as its point type and <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> as its <formula id="2">$ x$</formula>-monotone curve type. As this traits class does not support intersecting and splitting segments, the kernel representation is sufficient. It is still less efficient than <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> for constructing arrangements of pairwise disjoint line segments in many cases, as it performs no caching at all, but using this traits class may be preferable as it reduces the memory consumption a bit, since no extra data is stored with the line segments.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">Arr_non_caching_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> inherits from <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__basic__traits__2" kindref="compound">Arr_non_caching_segment_basic_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> and extends it to be a model of the concepts <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput>,and <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>. It may thus be used to construct arrangement of intersecting line segments, but as explained above, for efficiency reasons it is recommended to use it only when the arrangement is very sparse and contains hardly any intersection points.</para><para>In the following example we read an input file containing a set of line segments that are pairwise disjoint in their interior. As the segments do not intersect, no new points are constructed and we can instantiate the <computeroutput>Arr_non_caching_segment_traits_basic_2&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class-template with the predefined <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>. Note that we use the <computeroutput><ref refid="group__PkgArrangement2Funcs_1gad4aa37a4e938747028690579fb703d67" kindref="member">insert_non_intersecting_curves()</ref></computeroutput> function to construct the arrangement. By default, the example opens the <computeroutput>Europe.dat</computeroutput> input-file, located in the examples folder, which contains more than <formula id="137">$ 3000$</formula> line segments with floating-point coordinates that form the map of Europe, as depicted in <ref refid="index_1fig__arr_figpredef_kernels" kindref="member">fig__arr_figpredef_kernels</ref> (b):</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2predefined_kernel_non_intersecting_8cpp-example" kindref="compound">Arrangement_on_surface_2/predefined_kernel_non_intersecting.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>non-intersecting<sp/>line<sp/>segments<sp/>using<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>predefined<sp/>kernel<sp/>with<sp/>exact<sp/>predicates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_non_caching_segment_basic_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Kernel::FT</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__non__caching__segment__basic__traits__2" kindref="compound">CGAL::Arr_non_caching_segment_basic_traits_2&lt;Kernel&gt;</ref><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Europe.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;Europe.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/><sp/><sp/><sp/><sp/>in_file<sp/>(filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>segments<sp/>from<sp/>the<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>input<sp/>file<sp/>format<sp/>should<sp/>be<sp/>(all<sp/>coordinate<sp/>values<sp/>are<sp/>double</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>precision<sp/>floating-point<sp/>numbers):</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>number<sp/>of<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;sx_1&gt;<sp/>&lt;sy_1&gt;<sp/><sp/>&lt;tx_1&gt;<sp/>&lt;ty_1&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>source<sp/>and<sp/>target<sp/>of<sp/>segment<sp/>#1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;sx_2&gt;<sp/>&lt;sy_2&gt;<sp/><sp/>&lt;tx_2&gt;<sp/>&lt;ty_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>source<sp/>and<sp/>target<sp/>of<sp/>segment<sp/>#2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;sx_n&gt;<sp/>&lt;sy_n&gt;<sp/><sp/>&lt;tx_n&gt;<sp/>&lt;ty_n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>source<sp/>and<sp/>target<sp/>of<sp/>segment<sp/>#n.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Segment_2&gt;<sp/><sp/>segments;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>sx,<sp/>sy,<sp/>tx,<sp/>ty;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>sx<sp/>&gt;&gt;<sp/>sy<sp/>&gt;&gt;<sp/>tx<sp/>&gt;&gt;<sp/>ty;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>segments.push_back<sp/>(Segment_2<sp/>(Point_2<sp/>(Number_type(sx),<sp/>Number_type(sy)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(Number_type(tx),<sp/>Number_type(ty))));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>by<sp/>aggregately<sp/>inserting<sp/>all<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Timer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Performing<sp/>aggregated<sp/>insertion<sp/>of<sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>segments.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad4aa37a4e938747028690579fb703d67" kindref="member">insert_non_intersecting_curves</ref><sp/>(arr,<sp/>segments.begin(),<sp/>segments.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.stop();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>dimensions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construction<sp/>took<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>timer.time()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">Arr_linear_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class used for demonstrating the construction of arrangements of unbounded curves is capable of handling bounded and unbounded linear objects, namely lines, rays and line segments. It is parameterized by a geometric kernel and such that its nested <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> type is the same as the kernel point. The <computeroutput>Curve_2</computeroutput> (and <computeroutput>X_monotone_curve_2</computeroutput>) type it defines is constructible from a <computeroutput><ref refid="classKernel_1_1Line__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Line_2</ref></computeroutput>, a <computeroutput><ref refid="classKernel_1_1Ray__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Ray_2</ref></computeroutput> or from a <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> object. Just like the default segment-traits class, the linear-traits class also use caching techniques to speed up its predicates and constructions.</para></sect2>
<sect2 id="index_1arr_ssectr_polylines">
<title>The Polyline and Polycurve Traits Classes</title>
<para>Polylines are continuous piecewise linear curves. Polylines are of particular interest, as they can be used to approximate more complex curves in the plane. At the same time they are easier to handle in comparison to higher-degree algebraic curves, as rational arithmetic is sufficient to carry out computations on polylines, and to construct arrangements of polylines in an exact and robust manner.</para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref>&lt;SubcurveTraits_2&gt;</computeroutput> class template handles polylines. It models the concepts <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput>, and <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>. The type that substitutes the template parameter <computeroutput>SubcurveTraits_2</computeroutput> when <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref>&lt;SubcurveTraits_2&gt;</computeroutput> is instantiated must be a geometry-traits class that models the following concepts:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput>,</para></listitem><listitem><para><computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>,</para></listitem><listitem><para><computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput>.</para></listitem></itemizedlist>
</para><para>We refer to the type that substitutes the template parameter <computeroutput>SubcurveTraits_2</computeroutput> as the <emphasis>subcurve traits</emphasis> hereafter. If, in addition, the subcurve traits also models the concept <computeroutput><ref refid="classArrangementApproximateTraits__2" kindref="compound">ArrangementApproximateTraits_2</ref></computeroutput> then the instantiated <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref>&lt;SubcurveTraits&gt;</computeroutput> type models the concept <computeroutput><ref refid="classArrangementApproximateTraits__2" kindref="compound">ArrangementApproximateTraits_2</ref></computeroutput> as well. (By definition, modeling the concepts <computeroutput><ref refid="classArrangementApproximateTraits__2" kindref="compound">ArrangementApproximateTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput> implies modeling the concept <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput>.) The same holds for the <computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput> concept as well. Modeling the <computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput> concept implies that the subcurve traits must support the construction of a unique ( <formula id="138">$x$</formula>-monotone) segment given two input points. Roughly speaking, it means that each operation defined by the subcurve traits must handle linear curves.</para><para>An instance of the polyline traits class-template inherits its nested point type, i.e., <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput>, from the subcurve traits, and defines the nested types <computeroutput>Curve_2</computeroutput> and <computeroutput>X_monotone_curve_2</computeroutput>, which are used to represent polylines and <formula id="138">$x$</formula>-monotone polylines, respectively. A polyline of the nested type <computeroutput>Curve_2</computeroutput> is stored as a vector of <computeroutput>SubcurveTraits_2::Curve_2</computeroutput> objects, and an <formula id="138">$x$</formula>-monotone polyline of the nested type <computeroutput>X_monotone_curve_2</computeroutput> is stored as a vector of <computeroutput>SubcurveTraits_2::X_monotone_curve_2</computeroutput> objects. The nested <computeroutput>X_monotone_curve_2</computeroutput> type inherits from the nested type <computeroutput>Curve_2</computeroutput>. By default, <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> is used as the subcurve traits (in case where the <computeroutput>SubcurveTraits_2</computeroutput> parameter is omitted). In this case the nested types <computeroutput>SubcurveTraits_2::Curve_2</computeroutput> and <computeroutput>SubcurveTraits_2::X_monotone_curve_2</computeroutput> are identical types representing line segments.</para><para>A polyline can be constructed given one of the following inputs:</para><para><itemizedlist>
<listitem><para><bold>A range of <emphasis>points</bold></emphasis>, where two succeeding points in the range represent the endpoints of a segment of the polyline.</para></listitem><listitem><para><bold>A range of <emphasis>segments</bold></emphasis>. Note that , if the types <computeroutput>SubcurveTraits_2::Curve_2</computeroutput> and <computeroutput>SubcurveTraits_2::X_monotone_curve_2</computeroutput> are not the same, then when <computeroutput>Make_x_monotone_2</computeroutput> is invoked the segments that compose the polyline will be broken into <formula id="138">$x$</formula>-monotone parts.</para></listitem><listitem><para><bold>A pair of points <emphasis>or</emphasis> a single segment</bold>. In this case a polyline that consists of a single segment is constructed.</para></listitem></itemizedlist>
</para><para>Note that degenerate polylines are not supported. That is, it is impossible to construct a polyline that contains a segment of length zero, or an isolated point. Finally, a polyline is <bold><emphasis>continuous</emphasis></bold> and <bold><emphasis>well-oriented</emphasis></bold>; that is, the target of the <formula id="139">$i$</formula>th segment is the source of the <formula id="140">$i+1$</formula>st segment. For example, the general polyline</para><para><image type="html" name="generic-polyline.png"></image>
 <image type="latex" name="generic-polyline.pdf"></image>
</para><para>can be represented by one of the following two</para><para><image type="html" name="well-oriented-polyline.png"></image>
 <image type="latex" name="well-oriented-polyline.pdf"></image>
</para><para>Also, note, that a single polyline can be split into several <formula id="2">$ x$</formula>-monotone polylines, and that the number of intersection points (or overlapping sections) between two polylines can also be large.</para><para></para><para>Technically speaking, it is possible to construct a general polyline that is neither well-oriented nor continuous. However, it is impossible to use such polylines for the purpose of computing an arrangement.</para><para></para><para>You can traverse over the range of defining segments of a given polyline. The <emphasis>first</emphasis> and <emphasis>past-the-end</emphasis> iterators can be obtained through the access functions of the polyline <computeroutput>begin_segments()</computeroutput> and <computeroutput>end_segments()</computeroutput>, respectively. The vertices of an <formula id="2">$ x$</formula>-monotone curve are always stored in a strongly monotonic lexicographical order. In other words, <formula id="138">$x$</formula>-monotone polylines can be directed <emphasis>either</emphasis> left-to-right <emphasis>or</emphasis> right-to-left. If the macro <ref refid="group__PkgArrangement2Macros_1gafe0299480c1e86ecbb89465252046f70" kindref="member">CGAL_ALWAYS_LEFT_TO_RIGHT</ref> is set to 1, then the <formula id="138">$x$</formula>-monotone polylines are always directed from left-to-right (only proposed for backward compatibility).</para><para>The polyline-traits class does not perform any geometric operations directly. Instead, it solely relies on the functionality of the segment traits. For example, when we need to determine the position of a point with respect to an <formula id="138">$x$</formula>-monotone polyline, we use binary search to locate the relevant segment that contains the point in its <formula id="138">$x$</formula>-range. Then, we compute the position of the point with respect to this segment. Thus, operations on <formula id="138">$x$</formula>-monotone polylines of size <formula id="141">$m$</formula> typically take <formula id="142">$O(\log m)$</formula> time.</para><para>You are free to choose the underlying segment traits class. Your decision could be based, for example, on the number of expected intersection points; see Section <ref refid="index_1arr_ssectr_segs" kindref="member">Traits Classes for Line Segments and Linear Objects</ref>. Moreover, it is possible to substitute the <computeroutput>SubcurveTraits_2</computeroutput> template parameter with a traits class that handles segments with some additional data attached to each individual segment; see Section <ref refid="index_1arr_ssecmeta_tr" kindref="member">Traits-Class Decorators</ref>. This makes it possible to associate different data objects with the different segments that compose a polyline.</para><para><anchor id="index_1fig__arr_figex_12"/><image type="html" name="ex_12.png"></image>
 <image type="latex" name="ex_12.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_12" kindref="member">fig__arr_figex_12</ref> An arrangement of three polylines, as constructed in <computeroutput>polylines.cpp</computeroutput>. Disks mark vertices associated with polyline endpoints, while circles mark vertices that correspond to intersection points. Note that <formula id="143">$ \pi_2$</formula> is split into three <formula id="2">$ x$</formula>-monotone polylines, and that <formula id="144">$ \pi_1$</formula> and <formula id="145">$ \pi_3$</formula> have two overlapping sections. <linebreak/>
</para><para>The following example program constructs an arrangement of three polylines, as depicted in <ref refid="index_1fig__arr_figex_12" kindref="member">fig__arr_figex_12</ref>. Note that most points defining the polylines are not associated with arrangement vertices. The arrangement vertices are either the endpoints of each <formula id="2">$ x$</formula>-monotone polyline or the intersection points between two polylines:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2polylines_8cpp-example" kindref="compound">Arrangement_on_surface_2/polylines.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>polylines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_polyline_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>Define<sp/>the<sp/>Arrangement<sp/>traits<sp/>class<sp/>to<sp/>be<sp/>used.<sp/>You<sp/>can<sp/>either<sp/>use<sp/>some<sp/>user</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>defined<sp/>kernel<sp/>and<sp/>Segment_traits_2<sp/>or<sp/>the<sp/>defaults.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Instantiate<sp/>the<sp/>traits<sp/>class<sp/>using<sp/>a<sp/>user-defined<sp/>kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>and<sp/>Segment_traits_2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">CGAL::Arr_polyline_traits_2&lt;Segment_traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/>Geom_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Identical<sp/>instantiation<sp/>can<sp/>be<sp/>achieved<sp/>using<sp/>the<sp/>default<sp/>Kernel:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedef<sp/>CGAL::Arr_polyline_traits_2&lt;&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Geom_traits_2;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Geom_traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Geom_traits_2::Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Geom_traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyline_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Geom_traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Geom_traits_2<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Geom_traits_2::Construct_curve_2<sp/>polyline_construct<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>points1[5];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points1[0]<sp/>=<sp/>Point_2(0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points1[1]<sp/>=<sp/>Point_2(2,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points1[2]<sp/>=<sp/>Point_2(3,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points1[3]<sp/>=<sp/>Point_2(4,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points1[4]<sp/>=<sp/>Point_2(6,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyline_2<sp/>pi1<sp/>=<sp/>polyline_construct(&amp;points1[0],<sp/>&amp;points1[5]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point_2&gt;<sp/>points2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point_2(1,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point_2(0,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point_2(1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point_2(2,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point_2(3,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point_2(4,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point_2(5,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point_2(6,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point_2(5,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point_2(4,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyline_2<sp/>pi2<sp/>=<sp/>polyline_construct(points2.begin(),<sp/>points2.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Segment_2&gt;<sp/>segs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs.push_back(Segment_2(Point_2(0,<sp/>2),<sp/>Point_2(1,<sp/>2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs.push_back(Segment_2(Point_2(1,<sp/>2),<sp/>Point_2(3,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs.push_back(Segment_2(Point_2(3,<sp/>6),<sp/>Point_2(5,<sp/>2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyline_2<sp/>pi3<sp/>=<sp/>polyline_construct(segs.begin(),<sp/>segs.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>pi1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>pi2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>pi3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The traits class <computeroutput><ref refid="classCGAL_1_1Arr__polycurve__traits__2" kindref="compound">Arr_polycurve_traits_2</ref>&lt;GeometryTraits_2&gt;</computeroutput> handles piecewise curves that are not necessarily linear, such as conic arcs, circular arcs, Bezier curves, or line segments. We call such a compound curve a <emphasis>polycurve</emphasis>. Similar to a polyline, a polycurve is a chain of subcurves, where each two neighboring subcurves in the chain share a common endpoint; that is, the polycurve is continuous. As a matter of fact, most characteristics of the <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref>&lt;GeometryTraits_2&gt;</computeroutput> traits class apply also to the <computeroutput><ref refid="classCGAL_1_1Arr__polycurve__traits__2" kindref="compound">Arr_polycurve_traits_2</ref>&lt;GeometryTraits_2&gt;</computeroutput> traits class. The only difference between the two, is that the latter is not a model of the concept <computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput>, and as such, it is not able to construct a subcurve from two points. As a consequence, it does not support the operations that (i) construct a polycurve from a sequence of point, and (ii) push a point at the back or at the front of a non-empty polycurve.</para></sect2>
<sect2 id="index_1arr_ssectr_circ_seg">
<title>A Traits Class for Circular Arcs and Line Segments</title>
<para>Circles and circular arcs are the simplest form of non-linear curves. We handle circles whose centers have rational coordinates and whose squared radii is also rational. If we denote the circle center by <formula id="146">$ (x_0,y_0)$</formula> and its radius by <formula id="5">$ r$</formula>, then the equation of the circle - that is, <formula id="147">$ (x - x_0)^2 + (y - y_0)^2 = r^2$</formula> - has rational coefficients. The intersection points of two such circles are therefore solutions of a quadratic equation with rational coefficients, or algebraic numbers of degree <formula id="50">$ 2$</formula>. The same applies for intersection points between such a rational circle and a line, or a line segment, with rational coefficients (a line whose equation is <formula id="148">$ ax + by + c = 0$</formula>, where <formula id="149">$ a$</formula>, <formula id="150">$ b$</formula> and <formula id="44">$ c$</formula> are rational). Such numbers can be expressed as <formula id="151">$ \alpha + \beta\sqrt{\gamma}$</formula>, where <formula id="152">$ \alpha$</formula>, <formula id="153">$ \beta$</formula> and <formula id="154">$ \gamma$</formula> are all rational numbers.</para><para>Arrangement of circular arcs and of line segment are very useful, as they occur in many applications. For example, when dilating a polygon by some radius we obtain a shape whose boundary is comprised of line segments, which correspond to dilated polygon edges, and circular arcs, which result from dilated polygon vertices. Using the arrangement of the boundary curves it is possible, for example, to compute the union of a set of dilated polygons.</para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">Arr_circle_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class-template is designed for efficient handling of arrangements of circular arcs and line segments. It is a model of the concepts <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>; the later enables Boolean set operations. Note that it is not a model of <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept, so it is impossible to use the landmark point-location strategy. The traits class template is parameterized by a geometric kernel, and can handle arrangements of segments of <computeroutput><ref refid="classKernel_1_1Circle__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Circle_2</ref></computeroutput> objects (full circles are also supported) or of <computeroutput><ref refid="classKernel_1_1Line__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Line_2</ref></computeroutput> objects - namely circular arcs and line segments. It is important to observe that the nested <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> type defined by the traits class, whose coordinates are typically algebraic numbers of degree 2, is <emphasis>not</emphasis> the same as the <computeroutput><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref></computeroutput> type, which is capable of representing a point with rational coordinates. The coordinates of a point are represented using the nested <computeroutput>CoordNT</computeroutput> number-type.</para><para><anchor id="index_1fig__arr_figex_13"/><image type="html" name="ex_13.png"></image>
 <image type="latex" name="ex_13.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_13" kindref="member">fig__arr_figex_13</ref> An arrangement of three circles constructed in <computeroutput>circles.cpp</computeroutput>. Each circle is split into two <formula id="2">$ x$</formula>-monotone circular arcs, whose endpoints are drawn as disks. Circles mark vertices that correspond to intersection points. The vertex <formula id="155">$ v_{\rm max}$</formula> is a common intersection point of all three circles.  <linebreak/>
</para><para>In the following example an arrangement of three full circles is constructed, as shown in <ref refid="index_1fig__arr_figex_13" kindref="member">fig__arr_figex_13</ref>. Then, the vertex of maximal degree is searched for. The geometric mapping of this vertex is the point <formula id="156">$ (4,3)$</formula>, as all three circles intersect at this point and the associated vertex has six incident edges:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2circles_8cpp-example" kindref="compound">Arrangement_on_surface_2/circles.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>circles<sp/>using<sp/>the<sp/>conic-arc<sp/>traits.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_circle_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Circle__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Circle_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Circle_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">CGAL::Arr_circle_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::CoordNT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CoordNT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circle<sp/>centered<sp/>at<sp/>the<sp/>origin<sp/>with<sp/>radius<sp/>5.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>c1<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref><sp/>sqr_r1<sp/>=<sp/><ref refid="group__nt__cgal_1ga0849ff44771b19582218ebdfa5614f64" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Exact_rational</ref>(25);<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>5^2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Circle_2<sp/>circ1<sp/>=<sp/>Circle_2(c1,<sp/>sqr_r1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve_2<sp/>cv1<sp/>=<sp/>Curve_2(circ1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circle<sp/>centered<sp/>at<sp/>(7,7)<sp/>with<sp/>radius<sp/>5.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>c2<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(7,<sp/>7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref><sp/>sqr_r2<sp/>=<sp/><ref refid="group__nt__cgal_1ga0849ff44771b19582218ebdfa5614f64" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Exact_rational</ref>(25);<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>5^2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Circle_2<sp/>circ2<sp/>=<sp/>Circle_2(c2,<sp/>sqr_r2,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve_2<sp/>cv2<sp/>=<sp/>Curve_2(circ2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circle<sp/>centered<sp/>at<sp/>(4,-0.5)<sp/>with<sp/>radius<sp/>3.5<sp/>(=<sp/>7/2).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>c3<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(4,<sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(-1,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref><sp/>sqr_r3<sp/>=<sp/><ref refid="group__nt__cgal_1ga0849ff44771b19582218ebdfa5614f64" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Exact_rational</ref>(49,<sp/>4);<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>=<sp/>3.5^2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Circle_2<sp/>circ3<sp/>=<sp/>Circle_2(c3,<sp/>sqr_r3,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve_2<sp/>cv3<sp/>=<sp/>Curve_2(circ3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>of<sp/>the<sp/>three<sp/>circles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>cv1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>cv2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>cv3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Locate<sp/>the<sp/>vertex<sp/>with<sp/>maximal<sp/>degree.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Vertex_const_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Vertex_const_handle<sp/>v_max;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>max_degree<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vit-&gt;degree()<sp/>&gt;<sp/>max_degree)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>v_max<sp/>=<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>max_degree<sp/>=<sp/>vit-&gt;degree();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>vertex<sp/>with<sp/>maximal<sp/>degree<sp/>in<sp/>the<sp/>arrangement<sp/>is:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;v_max<sp/>=<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>v_max-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;with<sp/>degree<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>max_degree<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The <computeroutput>Curve_2</computeroutput> type nested in <computeroutput><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">Arr_circle_segment_traits_2</ref></computeroutput> can be used to represent circles, circular arcs, or line segments. Curve objects can therefore be constructed from a <computeroutput><ref refid="classKernel_1_1Circle__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Circle_2</ref></computeroutput> object or from a <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> object. A circular arc is typically defined by a supporting circle and two endpoints, where the endpoints are instances of the <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> type, with rational or irrational coordinates. The orientation of the arc is determined by the orientation of the supporting circle. Similarly, we also support the construction of lines segments given their supporting line (of type <computeroutput><ref refid="classKernel_1_1Line__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Line_2</ref></computeroutput>) and two endpoints, which may have irrational coordinates (unlike the <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> type).</para><para>Note that the <computeroutput><ref refid="classKernel_1_1Circle__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Circle_2</ref></computeroutput> type represents a circle whose <emphasis>squared radius</emphasis> is rational, where the radius itself may be irrational. However, if the radius is known to be rational, it is advisable to use it, for efficiency reasons. It is therefore also possible to construct a circle, or a circular arc specifying the circle center (a <computeroutput><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref></computeroutput>), its rational radius, and its orientation. Finally, we also support the construction of a circular arcs that is defined by two endpoints and an arbitrary midpoint that lies on the arc in between its endpoint. In this case, all three points are required to have rational coordinates (to be kernel points).</para><para>The following example demonstrates the usage of the various construction methods for circular arcs and line segments. Note the usage of the constructor of <computeroutput>CoordNT (alpha, beta, gamma)</computeroutput>, which creates a degree- <formula id="50">$ 2$</formula> algebraic number whose value is <formula id="151">$ \alpha + \beta\sqrt{\gamma}$</formula>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2circular_arcs_8cpp-example" kindref="compound">Arrangement_on_surface_2/circular_arcs.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>various<sp/>circular<sp/>arcs<sp/>and<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_circle_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Circle__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Circle_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Circle_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">CGAL::Arr_circle_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::CoordNT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CoordNT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Curve_2&gt;<sp/><sp/>curves;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circle<sp/>centered<sp/>at<sp/>the<sp/>origin<sp/>with<sp/>squared<sp/>radius<sp/>2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>c1<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Circle_2<sp/>circ1<sp/>=<sp/>Circle_2(c1,<sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve_2(circ1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circle<sp/>centered<sp/>at<sp/>(2,3)<sp/>with<sp/>radius<sp/>3/2<sp/>-<sp/>note<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>as<sp/>the<sp/>radius<sp/>is<sp/>rational<sp/>we<sp/>use<sp/>a<sp/>different<sp/>curve<sp/>constructor.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>c2<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(2,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve_2(c2,<sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(3,<sp/>2)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>segment<sp/>of<sp/>the<sp/>line<sp/>(y<sp/>=<sp/>x)<sp/>with<sp/>rational<sp/>endpoints.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>s3<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(-2,<sp/>-2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>t3<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(2,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/>seg3<sp/>=<sp/>Segment_2(s3,<sp/>t3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve_2(seg3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>line<sp/>segment<sp/>with<sp/>the<sp/>same<sp/>supporting<sp/>line<sp/>(y<sp/>=<sp/>x),<sp/>but</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>having<sp/>one<sp/>endpoint<sp/>with<sp/>irrational<sp/>coefficients.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CoordNT<sp/>sqrt_15<sp/>=<sp/>CoordNT(0,<sp/>1,<sp/>15);<sp/></highlight><highlight class="comment">//<sp/>=<sp/>sqrt(15)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>s4<sp/>=<sp/>Point_2(3,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>t4<sp/>=<sp/>Point_2(sqrt_15,<sp/>sqrt_15);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve_2(seg3.supporting_line(),<sp/>s4,<sp/>t4));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circular<sp/>arc<sp/>that<sp/>correspond<sp/>to<sp/>the<sp/>upper<sp/>half<sp/>of<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>circle<sp/>centered<sp/>at<sp/>(1,1)<sp/>with<sp/>squared<sp/>radius<sp/>3.<sp/>We<sp/>create<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>circle<sp/>with<sp/>clockwise<sp/>orientation,<sp/>so<sp/>the<sp/>arc<sp/>is<sp/>directed<sp/>from</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(1<sp/>-<sp/>sqrt(3),<sp/>1)<sp/>to<sp/>(1<sp/>+<sp/>sqrt(3),<sp/>1).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>c5<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Circle_2<sp/>circ5<sp/>=<sp/>Circle_2(c5,<sp/>3,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CoordNT<sp/>one_minus_sqrt_3<sp/>=<sp/>CoordNT(1,<sp/>-1,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CoordNT<sp/>one_plus_sqrt_3<sp/>=<sp/>CoordNT(1,<sp/>1,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>s5<sp/>=<sp/>Point_2(one_minus_sqrt_3,<sp/>CoordNT(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>t5<sp/>=<sp/>Point_2(one_plus_sqrt_3,<sp/>CoordNT(1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve_2(circ5,<sp/>s5,<sp/>t5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circular<sp/>arc<sp/>of<sp/>the<sp/>unit<sp/>circle,<sp/>directed<sp/>clockwise<sp/>from</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(-1/2,<sp/>sqrt(3)/2)<sp/>to<sp/>(1/2,<sp/>sqrt(3)/2).<sp/>Note<sp/>that<sp/>we<sp/>orient<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>supporting<sp/>circle<sp/>accordingly.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>c6<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CoordNT<sp/>sqrt_3_div_2<sp/>=<sp/>CoordNT(<ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(1,2),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>s6<sp/>=<sp/>Point_2(<ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(-1,<sp/>2),<sp/>sqrt_3_div_2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>t6<sp/>=<sp/>Point_2(<ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(1,<sp/>2),<sp/>sqrt_3_div_2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve_2(c6,<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>,<sp/>s6,<sp/>t6));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circular<sp/>arc<sp/>defined<sp/>by<sp/>two<sp/>endpoints<sp/>and<sp/>a<sp/>midpoint,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>all<sp/>having<sp/>rational<sp/>coordinates.<sp/>This<sp/>arc<sp/>is<sp/>the<sp/>upper-right</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>quarter<sp/>of<sp/>a<sp/>circle<sp/>centered<sp/>at<sp/>the<sp/>origin<sp/>with<sp/>radius<sp/>5.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>s7<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(0,<sp/>5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>mid7<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(3,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>t7<sp/>=<sp/><ref refid="classKernel_1ada7ccf9efead4df158c2317406e5fa6c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(5,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve_2(s7,<sp/>mid7,<sp/>t7));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>of<sp/>the<sp/>curves.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>curves.begin(),<sp/>curves.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>size<sp/>of<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>It is also possible to construct <formula id="2">$ x$</formula>-monotone curve objects, which represent <formula id="2">$ x$</formula>-monotone circular arcs or line segments, using similar constructors. Construction from a full circle is obviously not supported. See the Reference Manual for more details.</para><para>The traits class-template <computeroutput><ref refid="classCGAL_1_1Arr__circular__line__arc__traits__2" kindref="compound">Arr_circular_line_arc_traits_2</ref>&lt;<ref refid="classCircularKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circular_kernel_2.tag">CircularKernel</ref>&gt;</computeroutput> offered by the arrangement package also handles circular arcs and line segments. It is an alternative to the <computeroutput><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">Arr_circle_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class-template. These two class templates, while serve similar purposes, are based on different concepts, and posses different characteristics. You are encouraged to experiment with both, compare their performance, and use the most suitable for your case.</para></sect2>
<sect2 id="index_1arr_ssectr_conic">
<title>A Traits Class for Conic Arcs</title>
<para>A <emphasis>conic curve</emphasis> is an algebraic curve of degree 2. Namely, it is the locus of all points <formula id="157">$ (x,y)$</formula> satisfying the equation <formula id="158">$ C:\ r x^2 + s y^2 + t xy + u x + v y + w = 0$</formula>, where the six coefficients <formula id="159">$ \langle r, s, t, u, v, w \rangle$</formula> completely characterize the curve. The sign of the expression <formula id="160">$ \Delta_{C} = 4 r s - t^2$</formula> determines the type of curve: <itemizedlist>
<listitem>
<para>If <formula id="161">$ \Delta_{C} &gt; 0$</formula> the curve is an ellipse. A circle is a special case of an ellipse, where <formula id="162">$ r = s$</formula> and <formula id="163">$ t = 0$</formula>. </para></listitem>
<listitem>
<para>If <formula id="164">$ \Delta_{C} = 0$</formula> the curve is a parabola - an unbounded conic curve with a single connected branch. When <formula id="165">$ r = s = t = 0$</formula> we have a line, which can be considered as a degenerate parabola. </para></listitem>
<listitem>
<para>If <formula id="166">$ \Delta_{C} &lt; 0$</formula> the curve is a hyperbola. That is, it is comprised of two disconnected unbounded branches. </para></listitem>
</itemizedlist>
</para><para>As the arrangement package is suitable for bounded curves, we consider bounded segments of conic curves, referred to as <emphasis>conic arcs</emphasis>. A conic arc <formula id="149">$ a$</formula> may be either (i) a full ellipse, or (ii) defined by the tuple <formula id="167">$ \langle C, p_s, p_t, o \rangle$</formula>, where <formula id="3">$ C$</formula> is a conic curve and <formula id="168">$ p_s$</formula> and <formula id="169">$ p_t$</formula> are two points on <formula id="3">$ C$</formula> (namely <formula id="170">$ C(p_s) = C(p_t) = 0$</formula>) that define the <emphasis>source</emphasis> and <emphasis>target</emphasis> of the arc, respectively. The arc is formed by traversing <formula id="3">$ C$</formula> from the source to the target going in the orientation specified by <formula id="171">$ o$</formula>, which is typically clockwise or counterclockwise orientation (but may also be collinear in case of degenerate conic curves).</para><para>We always assume that the conic coefficients <formula id="159">$ \langle r, s, t, u, v, w \rangle$</formula> are rational. When dealing with linear curves (line segments and polylines), similar assumptions guarantee that all intersection points also have rational coordinates, such that the arrangement of such curves can be constructed and maintained using only rational arithmetic. Unfortunately, this does not hold for conic curves, as the coordinates of intersection points of two conic curves with rational coefficients are in general algebraic numbers of degree <formula id="96">$ 4$</formula>.Namely, they are roots of polynomials with integer coefficients of degree <formula id="96">$ 4$</formula>. However, in some special cases, for example when handling only circles and circular arcs, the coordinates of the intersection points are only of degree <formula id="50">$ 2$</formula>, namely they are solutions of quadratic equations. In addition, conic arcs may not necessarily be <formula id="2">$ x$</formula>-monotone, and must be split at points where the tangent to the arc is vertical. In the general case, such points typically have coordinates that are algebraic numbers of degree <formula id="50">$ 2$</formula>. It is therefore clear that we have to use different number types to represent the conic coefficients and the point coordinates. Note that as arrangement vertices induced by intersection points and points with vertical tangents are likely to have algebraic coordinates, we also allow the original endpoints of the input arcs <formula id="168">$ p_s$</formula> and <formula id="169">$ p_t$</formula> to have algebraic coordinates.</para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">Arr_conic_traits_2</ref>&lt;RatKernel, AlgKernel, NtTraits&gt;</computeroutput> class template is designed for efficient handling of arrangements of bounded conic arcs. The template has three parameters, defined as follows: <itemizedlist>
<listitem>
<para>The <computeroutput>RatKernel</computeroutput> class is a geometric kernel, whose field type is an exact rational type. It is used to define basic geometric entities (e.g., a line segment or a circle) with rational coefficients. Typically we use one of the standard CGAL kernels, instantiated with the number type <computeroutput>NtTraits::Rational</computeroutput> (see below). </para></listitem>
<listitem>
<para>The <computeroutput>AlgKernel</computeroutput> class is a geometric kernel whose field type is an exact algebraic type. It is used to define points with algebraic coordinates. Typically we use one of the standard CGAL kernels, instantiated with the number type <computeroutput>NtTraits::Algebraic</computeroutput> (see below). </para></listitem>
<listitem>
<para>The <computeroutput>NtTraits</computeroutput> class (the number-type traits class) encapsulates all the numeric operations needed for performing the geometric computation carried out by the geometric traits class. It defines the <computeroutput>Integer</computeroutput>, <computeroutput>Rational</computeroutput> and <computeroutput>Algebraic</computeroutput> number-types, and supports several operations on these types, such as conversion between number types, solving quadratic equations and extracting the real roots of a polynomial with integer coefficients. It is highly recommended to use the <computeroutput>CORE_algebraic_number_traits</computeroutput> class, which is included in the arrangement package. It relies on the exact number types implemented in the Core library and performs exact computations on the number types it defines. </para></listitem>
</itemizedlist>
</para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">Arr_conic_traits_2</ref></computeroutput> models the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concepts. (It supports the landmark point-location strategy). Its <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> type is derived from <computeroutput>AlgKernel::Point_2</computeroutput>, while the <computeroutput>Curve_2</computeroutput> type represents a bounded, not necessarily <formula id="2">$ x$</formula>-monotone, conic arc. The <computeroutput>X_monotone_curve_2</computeroutput> type is derived from <computeroutput>Curve_2</computeroutput>, but its constructors are to be used only by the traits class. You should therefore construct only <computeroutput>Curve_2</computeroutput> objects and insert them into the arrangement using the <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> or <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> functions.</para><para>Conic arcs can be constructed from full ellipses or by specifying a supporting curve, two endpoints and an orientation. However, several constructors of <computeroutput>Curve_2</computeroutput> are available to allow for some special cases, such as circular arcs or line segments. The <computeroutput>Curve_2</computeroutput> (and the derived <computeroutput>X_monotone_curve_2</computeroutput>) classes also support basic access functions such as <computeroutput>source()</computeroutput>, <computeroutput>target()</computeroutput> and <computeroutput><ref refid="group__orientation__grp_1ga91d9866cfde916ba70e5dbc596176d9e" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">orientation()</ref></computeroutput>.</para></sect2>
<sect2 id="index_1Arrangement_on_surface_2ExamplesforArrangements">
<title>Examples for Arrangements of Conics</title>
<para><anchor id="index_1fig__arr_figex_14"/><image type="html" name="ex_14.png"></image>
 <image type="latex" name="ex_14.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_14" kindref="member">fig__arr_figex_14</ref> An arrangement of mixed conic arcs, as constructed in conics.cpp  <linebreak/>
</para><para>The following example demonstrates the usage of the various constructors for conic arcs. The resulting arrangement is depicted in <ref refid="index_1fig__arr_figex_14" kindref="member">fig__arr_figex_14</ref>. Especially noteworthy are the constructor of a circular arc that accepts three points and the constructor that allows specifying approximate endpoints, where the exact endpoints are given explicitly as intersections of the supporting conic with two other conic curves. Also note that as the preconditions required by some of these constructors are rather complicated (see the Reference Manual for the details), a precondition violation does not cause the program to terminate - instead, an <emphasis>invalid</emphasis> arc is created. We can verify the validity of an arc by using the <computeroutput><ref refid="group__nt__util_1ga06ee6c8472c94e9f14d6fc94b6b7079b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">is_valid()</ref></computeroutput> method. Needless to say, inserting invalid arcs into an arrangement is not allowed.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2conics_8cpp-example" kindref="compound">Arrangement_on_surface_2/conics.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>various<sp/>conic<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/CORE_algebraic_number_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_conic_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::CORE_algebraic_number_traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nt_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rational;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Algebraic<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rat_kernel::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rat_kernel::Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rat_kernel::Circle_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_circle_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Algebraic&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alg_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">CGAL::Arr_conic_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Conic_arc_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>hyperbolic<sp/>arc,<sp/>supported<sp/>by<sp/>the<sp/>hyperbola<sp/>y<sp/>=<sp/>1/x</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(or:<sp/>xy<sp/>-<sp/>1<sp/>=<sp/>0)<sp/>with<sp/>the<sp/>endpoints<sp/>(1/5,<sp/>4)<sp/>and<sp/>(2,<sp/>1/2).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>the<sp/>arc<sp/>is<sp/>counterclockwise<sp/>oriented.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>ps1<sp/>(Rational(1,4),<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>pt1<sp/>(2,<sp/>Rational(1,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc_2<sp/><sp/><sp/>c1<sp/>(0,<sp/>0,<sp/>1,<sp/>0,<sp/>0,<sp/>-1,<sp/><ref refid="group__kernel__enums_1ga39fcfbab0b0f0ce9139ad1613e21d60d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::COUNTERCLOCKWISE</ref>,<sp/>ps1,<sp/>pt1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>c1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>full<sp/>ellipse,<sp/>which<sp/>is<sp/>(x/4)^2<sp/>+<sp/>(y/2)^2<sp/>=<sp/>0<sp/>rotated<sp/>by</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>phi=36.87<sp/>degree<sp/>(such<sp/>that<sp/>sin(phi)<sp/>=<sp/>0.6,<sp/>cos(phi)<sp/>=<sp/>0.8),</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>yielding:<sp/>58x^2<sp/>+<sp/>72y^2<sp/>-<sp/>48xy<sp/>-<sp/>360<sp/>=<sp/>0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc_2<sp/><sp/><sp/>c2<sp/>(58,<sp/>72,<sp/>-48,<sp/>0,<sp/>0,<sp/>-360);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>c2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>the<sp/>segment<sp/>(1,<sp/>1)<sp/>--<sp/>(0,<sp/>-3).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_point_2<sp/><sp/><sp/>ps3<sp/>(1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_point_2<sp/><sp/><sp/>pt3<sp/>(0,<sp/>-3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc_2<sp/><sp/><sp/>c3<sp/>(Rat_segment_2<sp/>(ps3,<sp/>pt3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>c3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>circular<sp/>arc<sp/>supported<sp/>by<sp/>the<sp/>circle<sp/>x^2<sp/>+<sp/>y^2<sp/>=<sp/>5^2,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>with<sp/>(-3,<sp/>4)<sp/>and<sp/>(4,<sp/>3)<sp/>as<sp/>its<sp/>endpoints.<sp/>We<sp/>want<sp/>the<sp/>arc<sp/>to<sp/>be</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>clockwise<sp/>oriented,<sp/>so<sp/>it<sp/>passes<sp/>through<sp/>(0,<sp/>5)<sp/>as<sp/>well.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_point_2<sp/><sp/><sp/>ps4<sp/>(-3,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_point_2<sp/><sp/><sp/>pm4<sp/>(0,<sp/>5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_point_2<sp/><sp/><sp/>pt4<sp/>(4,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc_2<sp/><sp/><sp/>c4<sp/>(ps4,<sp/>pm4,<sp/>pt4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(c4.is_valid());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>c4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>full<sp/>unit<sp/>circle<sp/>that<sp/>is<sp/>centered<sp/>at<sp/>(0,<sp/>4).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_circle_2<sp/><sp/>circ5<sp/>(Rat_point_2(0,4),<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc_2<sp/><sp/><sp/>c5<sp/>(circ5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>c5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>parabolic<sp/>arc<sp/>that<sp/>is<sp/>supported<sp/>by<sp/>a<sp/>parabola<sp/>y<sp/>=<sp/>-x^2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(or:<sp/>x^2<sp/>+<sp/>y<sp/>=<sp/>0)<sp/>and<sp/>whose<sp/>endpoints<sp/>are<sp/>(-sqrt(3),<sp/>-3)<sp/>~<sp/>(-1.73,<sp/>-3)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>(sqrt(2),<sp/>-2)<sp/>~<sp/>(1.41,<sp/>-2).<sp/>Notice<sp/>that<sp/>since<sp/>the<sp/>x-coordinates</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>of<sp/>the<sp/>endpoints<sp/>cannot<sp/>be<sp/>accurately<sp/>represented,<sp/>we<sp/>specify<sp/>them</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>as<sp/>the<sp/>intersections<sp/>of<sp/>the<sp/>parabola<sp/>with<sp/>the<sp/>lines<sp/>y<sp/>=<sp/>-3<sp/>and<sp/>y<sp/>=<sp/>-2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>the<sp/>arc<sp/>is<sp/>clockwise<sp/>oriented.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc_2<sp/><sp/><sp/>c6<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Conic_arc_2<sp/>(1,<sp/>0,<sp/>0,<sp/>0,<sp/>1,<sp/>0,<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>parabola.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(-1.73,<sp/>-3),<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Approximation<sp/>of<sp/>the<sp/>source.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>0,<sp/>0,<sp/>0,<sp/>1,<sp/>3,<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>line:<sp/>y<sp/>=<sp/>-3.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(1.41,<sp/>-2),<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Approximation<sp/>of<sp/>the<sp/>target.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>0,<sp/>0,<sp/>0,<sp/>1,<sp/>2);<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>line:<sp/>y<sp/>=<sp/>-2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(c6.is_valid());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>c6);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>the<sp/>right<sp/>half<sp/>of<sp/>the<sp/>circle<sp/>centered<sp/>at<sp/>(4,<sp/>2.5)<sp/>whose<sp/>radius</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>is<sp/>1/2<sp/>(therefore<sp/>its<sp/>squared<sp/>radius<sp/>is<sp/>1/4).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_circle_2<sp/><sp/>circ7<sp/>(Rat_point_2(4,<sp/>Rational(5,2)),<sp/>Rational(1,4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>ps7<sp/>(4,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>pt7<sp/>(4,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc_2<sp/><sp/><sp/>c7<sp/>(circ7,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>,<sp/>ps7,<sp/>pt7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>c7);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>out<sp/>the<sp/>size<sp/>of<sp/>the<sp/>resulting<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para><para>The last example in this section demonstrates how the conic-traits class can handle intersection points with multiplicity. The supporting curves of the two arcs, a circle centered at <formula id="172">$ (0,\frac{1}{2})$</formula> with radius <formula id="173">$ \frac{1}{2}$</formula>, and the hyperbola <formula id="174">$ y = \frac{x^2}{1-x}$</formula>,This curve can also be written as <formula id="175">$ C: x^2 + xy - y = 0$</formula>. It is a hyperbola since <formula id="176">$ \Delta_{C} = -1$</formula>. intersect at the origin such that the intersection point has multiplicity <formula id="177">$ 3$</formula> (note that they both have the same horizontal tangent at <formula id="89">$ (0,0)$</formula> and the same curvature <formula id="121">$ 1$</formula>). In addition, they have another intersection point at <formula id="178">$ (\frac{1}{2},\frac{1}{2})$</formula> of multiplicity <formula id="121">$ 1$</formula>:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2conic_multiplicities_8cpp-example" kindref="compound">Arrangement_on_surface_2/conic_multiplicities.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Handling<sp/>intersection<sp/>points<sp/>with<sp/>multiplicity<sp/>between<sp/>conic<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/CORE_algebraic_number_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_conic_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_naive_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::CORE_algebraic_number_traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nt_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rational;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Algebraic<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rat_kernel::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rat_kernel::Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rat_kernel::Circle_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_circle_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Algebraic&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alg_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">CGAL::Arr_conic_traits_2</ref>&lt;Rat_kernel,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alg_kernel,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nt_traits&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Conic_arc_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__naive__point__location" kindref="compound">CGAL::Arr_naive_point_location&lt;Arrangement_2&gt;</ref><sp/>Naive_pl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Naive_pl<sp/><sp/><sp/><sp/><sp/><sp/><sp/>pl<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>hyperbolic<sp/>arc,<sp/>supported<sp/>by<sp/>the<sp/>hyperbola<sp/>y<sp/>=<sp/>x^2/(1-x)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(or:<sp/>x^2<sp/>+<sp/>xy<sp/>-<sp/>y<sp/>=<sp/>0)<sp/>with<sp/>the<sp/>endpoints<sp/>(-1,<sp/>1/2)<sp/>and<sp/>(1/2,<sp/>1/2).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>the<sp/>arc<sp/>is<sp/>counterclockwise<sp/>oriented.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ps1<sp/>(-1,<sp/>Rational(1,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pt1<sp/>(Rational(1,2),<sp/>Rational(1,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc_2<sp/><sp/><sp/><sp/>cv1<sp/>(1,<sp/>0,<sp/>1,<sp/>0,<sp/>-1,<sp/>0,<sp/><ref refid="group__kernel__enums_1ga39fcfbab0b0f0ce9139ad1613e21d60d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::COUNTERCLOCKWISE</ref>,<sp/>ps1,<sp/>pt1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>cv1,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>the<sp/>bottom<sp/>half<sp/>of<sp/>the<sp/>circle<sp/>centered<sp/>at<sp/>(0,<sp/>1/2)<sp/>whose<sp/>radius</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>is<sp/>1/2<sp/>(therefore<sp/>its<sp/>squared<sp/>radius<sp/>is<sp/>1/4).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_circle_2<sp/><sp/><sp/>circ2<sp/>(Rat_point_2(0,<sp/>Rational(1,2)),<sp/>Rational(1,4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ps2<sp/>(-Rational(1,2),<sp/>Rational(1,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pt2<sp/>(Rational(1,2),<sp/>Rational(1,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc_2<sp/><sp/><sp/><sp/>cv2<sp/>(circ2,<sp/><ref refid="group__kernel__enums_1ga39fcfbab0b0f0ce9139ad1613e21d60d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::COUNTERCLOCKWISE</ref>,<sp/>ps2,<sp/>pt2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>cv2,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>resulting<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssectr_ratfunc">
<title>A Traits Class for Arcs of Rational Functions</title>
<para>The traits class <computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">Arr_rational_function_traits_2</ref>&lt;<ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref>&gt;</computeroutput> handles bounded and unbounded arcs of rational functions, referred to as <emphasis>rational arcs</emphasis> (in particular, such an arc may correspond to the entire graph of a rational function), and enables the construction and maintenance of arrangements of such arcs. Rational functions, and polynomial functions in particular, are not only interesting in their own right, they are also very useful for approximating or interpolating more complicated curves; see, e.g., [<ref refid="citelist_1CITEREF_cgal:ptvf-nrcpp-02" kindref="member">[10]</ref> Chapter 3.</para><para><computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">Arr_rational_function_traits_2</ref>&lt;<ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref>&gt;</computeroutput> is a model of the concepts <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput>, and <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>; the later enables Boolean set operations. Note that it is not a model of <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept, so it is impossible to use the landmark point-location strategy with this traits class.</para><para>A rational function <formula id="179">$ y = \frac{P(x)}{Q(x)}$</formula> is defined by two polynomials <formula id="180">$ P$</formula> and <formula id="181">$ Q$</formula> of arbitrary degrees. If <formula id="182">$ Q(x) = 1$</formula> then the function is a simple polynomial function. Usually the domain is <formula id="183">$ \mathbb{R}$</formula> but the function may also be restricted to a bounded interval <formula id="184">$ [x_{\rm min}, x_{\rm max}]$</formula> or defined over a ray <formula id="185">$ (-\infty, x_{\rm max}]$</formula> or <formula id="186">$ [x_{\rm min}, \infty)$</formula>. Rational functions are represented by the nested type <computeroutput>Curve_2</computeroutput>. A rational arc is always <formula id="2">$ x$</formula>-monotone in the mathematical sense. However, it is not necessarily continuous, as it may have singularities. An arc that has singularities must be split into continuous portions before being inserted into the arrangement. Arbitrary rational functions are represented by the nested type <computeroutput>Curve_2</computeroutput> and continuous portions of rational functions are represented by the nested type <computeroutput>X_monotone_curve_2</computeroutput>. Constructors for both types are provided by the traits. A <computeroutput>Curve_2</computeroutput> may be split up into several <computeroutput>X_monotone_curve_2</computeroutput> using <computeroutput>Make_x_monotone_2</computeroutput>.</para><para>Using the <computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">Arr_rational_function_traits_2</ref>&lt;<ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref>&gt;</computeroutput> class template it is possible to construct and maintain arrangement of rational arcs. The template parameter of the traits must be a model of the concept <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref></computeroutput>. A rational function is represented as the quotient of two polynomials <formula id="180">$ P$</formula> and <formula id="181">$ Q$</formula> of type <computeroutput><ref refid="classAlgebraicKernel__d__1_1ae49b9882d6f700d17476e00933ed20f3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1::Polynomial_1</ref></computeroutput> and an <formula id="2">$ x$</formula>-interval over which the polynomials are defined. The type of the polynomial coefficients, namely <computeroutput><ref refid="classAlgebraicKernel__d__1_1a800674c4325a4c7dbc57186603fc8e3c" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1::Coefficient</ref></computeroutput>, cannot be algebraic. Moreover, it is recommended that this type is not made rational either, since using rational, as opposed to integral, coefficients does not extend the range of the rational arcs and is typically less efficient. The type of the interval bounds, namely <computeroutput><ref refid="classAlgebraicKernel__d__1_1a00c2a481bddf8a8812f517b1b81867c0" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1::Bound</ref></computeroutput>, however, can be algebraic. A point is represented by a rational function and its <formula id="2">$ x$</formula>-coordinate, which is of type <computeroutput><ref refid="classAlgebraicKernel__d__1_1a6b463d94115038aefb4e0f2aafc06a6e" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1::Algebraic_real_1</ref></computeroutput>. Note that an explicit representation of the <formula id="104">$ y$</formula>-coordinate is only computed upon request, as it can be a rather costly operation.</para><para>The constructed rational functions are cached by the traits class. The cache is local to each traits class object. It is therefore necessary to construct curves using only the constructor objects provided by member functions of the traits class. Moreover, a curve must only be used by the traits class object that was used to construct it. The cache is automatically cleaned up from time to time. The amortized clean up costs are constant. In addition, there is also a separate member function that cleans up the cache on demand.</para><para>The curve constructors have an additional advantage. They conveniently enable the provision of two polynomials that define a rational arc using rational coefficients. For example, let <formula id="180">$ P$</formula> and <formula id="181">$ Q$</formula> denote two polynomials with integral coefficients that define a rational arc at interest, and let <formula id="187">$ P&apos;$</formula> and <formula id="188">$ Q&apos;$</formula> denote two polynomials with rational coefficients that define the same rational arc; that is, the quotients <formula id="189">$ P/Q$</formula> and <formula id="190">$ P&apos;/Q&apos;$</formula> are identical. You can construct the rational arc providing the coefficients of <formula id="187">$ P&apos;$</formula> and <formula id="188">$ Q&apos;$</formula> to the constructor. In this case the constructor normalizes the coefficients and stores the desired polynomials <formula id="180">$ P$</formula> and <formula id="181">$ Q$</formula>.</para><para><anchor id="index_1fig__arr_figex_16"/><image type="html" name="ex_16.png"></image>
 <image type="latex" name="ex_16.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_16" kindref="member">fig__arr_figex_16</ref> An arrangement of four arcs of rational functions, as constructed in rational_functions.cpp.  <linebreak/>
</para><para>The following example demonstrates the construction of an arrangement of rational arcs depicted in <ref refid="index_1fig__arr_figex_16" kindref="member">fig__arr_figex_16</ref>. Note the usage of the two constructors, for polynomial arcs and for rational arcs:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2rational_functions_8cpp-example" kindref="compound">Arrangement_on_surface_2/rational_functions.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>arcs<sp/>of<sp/>rational<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="CORE__BigInt_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/CORE_BigInt.h</ref>&gt;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>NT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Algebraic_kernel_d_1.h&gt;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Algebraic<sp/>Kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_rational_function_traits_2.h&gt;</highlight><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Traits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Arrangement</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCORE_1_1BigInt" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CORE::BigInt</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_kernel_d.tag">CGAL::Algebraic_kernel_d_1&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/>AK1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">CGAL::Arr_rational_function_traits_2&lt;AK1&gt;</ref><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Polynomial_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polynomial_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Algebraic_real_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alg_real_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(std::cout);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>nice<sp/>printouts.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>polynomial<sp/>representing<sp/>x<sp/>.-)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>x<sp/>=<sp/>CGAL::shift(Polynomial_1(1),1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Traits<sp/>class<sp/>object<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits_2<sp/>traits;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits_2::Construct_x_monotone_curve_2<sp/>construct_arc</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>=<sp/>traits.construct_x_monotone_curve_2_object();<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>container<sp/>storing<sp/>all<sp/>arcs<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Traits_2::X_monotone_curve_2&gt;<sp/><sp/>arcs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>arc<sp/>supported<sp/>by<sp/>the<sp/>polynomial<sp/>y<sp/>=<sp/>x^4<sp/>-<sp/>6x^2<sp/>+<sp/>8,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>defined<sp/>over<sp/>the<sp/>interval<sp/>[-2.1,<sp/>2.1]:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>P1<sp/>=<sp/>x*x*x*x<sp/>-<sp/>6*x*x<sp/>+<sp/>8;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alg_real_1<sp/>l(Traits_2::Algebraic_kernel_d_1::Bound(-2.1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alg_real_1<sp/>r(Traits_2::Algebraic_kernel_d_1::Bound(2.1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct_arc(P1,<sp/>l,<sp/>r));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>arc<sp/>supported<sp/>by<sp/>the<sp/>function<sp/>y<sp/>=<sp/>x<sp/>/<sp/>(1<sp/>+<sp/>x^2),</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>defined<sp/>over<sp/>the<sp/>interval<sp/>[-3,<sp/>3]:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>P2<sp/>=<sp/>x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>Q2<sp/>=<sp/>1+x*x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct_arc(P2,<sp/>Q2,<sp/>Alg_real_1(-3),<sp/>Alg_real_1(3)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>arc<sp/>supported<sp/>by<sp/>the<sp/>parabola<sp/>y<sp/>=<sp/>8<sp/>-<sp/>x^2,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>defined<sp/>over<sp/>the<sp/>interval<sp/>[-2,<sp/>3]:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>P3<sp/>=<sp/>8<sp/>-<sp/>x*x;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct_arc(P3,<sp/>Alg_real_1(-2),<sp/>Alg_real_1(3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>arc<sp/>supported<sp/>by<sp/>the<sp/>line<sp/>y<sp/>=<sp/>-2x,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>defined<sp/>over<sp/>the<sp/>interval<sp/>[-3,<sp/>0]:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>P4<sp/>=<sp/>-2*x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct_arc(P4,<sp/>Alg_real_1(-3),<sp/>Alg_real_1(0)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>of<sp/>the<sp/>four<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i(0);<sp/>i<sp/>&lt;<sp/>arcs.size();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>arcs[i]&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>arcs.begin(),<sp/>arcs.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__arr_figex_unb_rat"/><image type="html" name="ex_unb_rat.png"></image>
 <image type="latex" name="ex_unb_rat.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_unb_rat" kindref="member">fig__arr_figex_unb_rat</ref> An arrangement of six arcs of rational functions, as constructed in unbounded_rational_functions.cpp  <linebreak/>
</para><para>The following example demonstrates the construction of an arrangement of six rational arcs - four unbounded arcs and two bounded ones - as depicted in <ref refid="index_1fig__arr_figex_unb_rat" kindref="member">fig__arr_figex_unb_rat</ref>. Note the usage of the constructors of an entire rational function and of an infinite &quot;ray&quot; of such a function. Also observe that the hyperbolas <formula id="191">$ y = \pm\frac{1}{x}$</formula> and <formula id="192">$ y = \pm\frac{1}{2x}$</formula> never intersect, although they have common vertical and horizontal asymptotes, so very &quot;thin&quot; unbounded faces are created between them:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2unbounded_rational_functions_8cpp-example" kindref="compound">Arrangement_on_surface_2/unbounded_rational_functions.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>unbounded<sp/>portions<sp/>of<sp/>rational<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="CORE__BigInt_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/CORE_BigInt.h</ref>&gt;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>NT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Algebraic_kernel_d_1.h&gt;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Algebraic<sp/>Kernel</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_rational_function_traits_2.h&gt;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>Traits</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Arrangement</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCORE_1_1BigInt" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CORE::BigInt</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_kernel_d.tag">CGAL::Algebraic_kernel_d_1&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/>AK1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">CGAL::Arr_rational_function_traits_2&lt;AK1&gt;</ref><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Polynomial_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polynomial_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Algebraic_real_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alg_real_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(std::cout);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>nice<sp/>printouts.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Traits<sp/>class<sp/>object<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK1<sp/>ak1;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits_2<sp/>traits(&amp;ak1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>constructor<sp/>for<sp/>rational<sp/>functions<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits_2::Construct_curve_2<sp/>construct<sp/>=<sp/>traits.construct_curve_2_object();<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>a<sp/>polynomial<sp/>representing<sp/>x<sp/>.-)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>x<sp/>=<sp/>CGAL::shift(Polynomial_1(1),1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>container<sp/>storing<sp/>all<sp/>arcs<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Traits_2::Curve_2&gt;<sp/><sp/>arcs;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>the<sp/>rational<sp/>functions<sp/>(y<sp/>=<sp/>1<sp/>/<sp/>x),<sp/>and<sp/>(y<sp/>=<sp/>-1<sp/>/<sp/>x).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>P1(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>minusP1(-P1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>Q1<sp/>=<sp/>x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(P1,<sp/>Q1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(minusP1,<sp/>Q1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>bounded<sp/>segments<sp/>of<sp/>the<sp/>parabolas<sp/>(y<sp/>=<sp/>-4*x^2<sp/>+<sp/>3)<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(y<sp/>=<sp/>4*x^2<sp/>-<sp/>3),<sp/>defined<sp/>over<sp/>[-sqrt(3)/2,<sp/>sqrt(3)/2].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>P2<sp/>=<sp/>-4*x*x+3;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>minusP2<sp/>=<sp/>-P2;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::pair&lt;Alg_real_1,int&gt;<sp/>&gt;<sp/>roots;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>[-sqrt(3)/2,<sp/>sqrt(3)/2]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>traits.algebraic_kernel_d_1()-&gt;solve_1_object()(P2,<sp/>std::back_inserter(roots));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(P2,<sp/>roots[0].first,<sp/>roots[1].first));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(minusP2,<sp/>roots[0].first,<sp/>roots[1].first));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>the<sp/>rational<sp/>function<sp/>(y<sp/>=<sp/>1<sp/>/<sp/>2*x)<sp/>for<sp/>x<sp/>&gt;<sp/>0,<sp/>and<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>rational<sp/>function<sp/>(y<sp/>=<sp/>-1<sp/>/<sp/>2*x)<sp/>for<sp/>x<sp/>&lt;<sp/>0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>P3(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>minusP3(-P3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial_1<sp/>Q3<sp/>=<sp/>2*x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(P3,<sp/>Q3,<sp/>Alg_real_1(0),<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(minusP3,<sp/>Q3,<sp/>Alg_real_1(0),<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>of<sp/>the<sp/>six<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//Arrangement_2<sp/>arr(&amp;traits);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>arcs.begin(),<sp/>arcs.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(plus<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices_at_infinity()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>at<sp/>infinity)&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_unbounded_faces()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>unbounded)&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssectr_bez">
<title>A Traits Class for Planar Bézier Curves</title>
<para>A planar <emphasis>B<eacute/>zier curve</emphasis> <formula id="193">$ B$</formula> is a parametric curve defined by a sequence of <emphasis>control points</emphasis> <formula id="194">$ p_0, \ldots, p_n$</formula> as follows:</para><para><formula id="195">\begin{eqnarray*} B(t) = \left(X(t), Y(t)\right) = \ccSum{k=0}{n}{p_k \cdot \frac{n!}{k! (n-k)!} \cdot t^k (1-t)^{n-k}}\ . \end{eqnarray*}</formula></para><para>where <formula id="196">$ t \in [0, 1]$</formula>. The degree of the curve is therefore <formula id="197">$ n$</formula> - namely, <formula id="198">$ X(t)$</formula> and <formula id="199">$ Y(t)$</formula> are polynomials of degree <formula id="197">$ n$</formula>. B<eacute/>zier curves have numerous applications in computer graphics and solid modelling. They are used, for example, in free-form sketches and for defining the true-type fonts.</para><para>Using the <computeroutput><ref refid="classCGAL_1_1Arr__Bezier__curve__traits__2" kindref="compound">Arr_Bezier_curve_traits_2</ref>&lt;RatKernel, AlgKernel, NtTraits&gt;</computeroutput> class template it is possible to construct and maintain arrangements of B<eacute/>zier curves that are given by rational control points (a sequence of objects of the <computeroutput>RatKernel::Point_2</computeroutput> type). We can handle curves of arbitrary degree (in general, a sequence of <formula id="200">$ n+1$</formula> control points define a B<eacute/>zier curve of degree <formula id="197">$ n$</formula>). The template parameters are the same ones used by the <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">Arr_conic_traits_2</ref></computeroutput> class template, and here it is also recommended to use the <computeroutput>CORE_algebraic_number_traits</computeroutput> class, with <ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref> kernels instantiated with the <computeroutput>Rational</computeroutput> and <computeroutput>Algebraic</computeroutput> number-types defined by this class.</para><para>As mentioned above, we assume that the coordinates of all control points that define a B<eacute/>zier curve are rational numbers, so both <formula id="198">$ X(t)$</formula> and <formula id="199">$ Y(t)$</formula> are polynomials with rational coefficients. The intersection points between curves are however algebraic numbers, and their exact computation is time-consuming. The traits class therefore contains a layer of geometric filtering that performs all computation in an approximate manner whenever possible. Thus, it resorts to exact computations only when the approximate computation fails to produce an unambiguous result. Note that most arrangement vertices are therefore associated with approximated points. You cannot access the coordinates of such points and obtain them as algebraic numbers, and only access to the approximate coordinates in possible. See the Reference Manual for the exact interface of the <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput>, <computeroutput>Curve_2</computeroutput> and <computeroutput>X_monotone_curve_2</computeroutput> defined by the traits class.</para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__Bezier__curve__traits__2" kindref="compound">Arr_Bezier_curve_traits_2</ref></computeroutput> is a model of the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept (but not of the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept, so it is impossible to use the landmark point-location strategy for arrangements of rational arcs).</para><para><anchor id="index_1fig__arr_figex_bez"/><image type="html" name="Bezier_arr.png"></image>
 <image type="latex" name="Bezier_arr.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_bez" kindref="member">fig__arr_figex_bez</ref> An arrangement of ten B<eacute/>zier curves of degree <formula id="78">$ 5$</formula>, as constructed in <computeroutput>Bezier_curves.cpp</computeroutput>.  <linebreak/>
</para><para>The following example reads a set of B<eacute/>zier curves from an input file, where each file is specified by an integer stating its number of control points, followed by the sequence of control points, given in integer or rational coordinates. By default, the program uses the <computeroutput>Bezier.dat</computeroutput> file, which contains ten curves of degree <formula id="78">$ 5$</formula> each; their resulting arrangement is depicted in <ref refid="index_1fig__arr_figex_bez" kindref="member">fig__arr_figex_bez</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2Bezier_curves_8cpp-example" kindref="compound">Arrangement_on_surface_2/Bezier_curves.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>Bezier<sp/>curves.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/CORE_algebraic_number_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_Bezier_curve_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::CORE_algebraic_number_traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nt_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rational;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Algebraic<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Algebraic&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alg_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rat_kernel::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__Bezier__curve__traits__2" kindref="compound">CGAL::Arr_Bezier_curve_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bezier_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Bezier.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/><sp/><sp/>*filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;Bezier.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/><sp/><sp/>in_file<sp/>(filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>curves<sp/>from<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n_curves;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Bezier_curve_2&gt;<sp/><sp/>curves;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Bezier_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>n_curves;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>n_curves;<sp/>k++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>current<sp/>curve<sp/>(specified<sp/>by<sp/>its<sp/>control<sp/>points).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>B;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>curves.push_back<sp/>(B);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;B<sp/>=<sp/>{&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>B<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;}&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>curves.begin(),<sp/>curves.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssectr_alg">
<title>A Traits Class for Planar Algebraic Curves of Arbitrary Degree</title>
<para>An algebraic curve <formula id="3">$ C$</formula> in the plane is defined as the (real) zero locus of a polynomial <formula id="201">$ f(x,y)$</formula> in two variables. The curve is uniquely defined by <formula id="38">$ f$</formula> (although several polynomials might define the same curve). We call <formula id="38">$ f$</formula> a <emphasis>defining polynomial</emphasis> of <formula id="3">$ C$</formula>.</para><para>We consider arrangements induced by algebraic curves or by (weakly) <formula id="2">$ x$</formula>-monotone segments for algebraic curves (Such a segment is not necessarily the maximal possible (weakly) x-monotone segment; see below.) When talking about algebraic curves, we use the term &quot;segment&quot; for a continuous, possibly non-linear subset of an algebraic curve - see the definition below. There are no restrictions on the algebraic curve, that means, we support unbounded curves, vertical curves or segments, and isolated points.</para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2" kindref="compound">Arr_algebraic_segment_traits_2</ref>&lt;Coefficient&gt;</computeroutput> class template is a model of the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept (but not of the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept, so it is impossible to use the landmark point-location strategy for arrangements of algebraic curves). The template argument <computeroutput>Coefficient</computeroutput> determines the type of the scalar coefficients of the polynomial. Currently supported types are <computeroutput><ref refid="classleda__integer" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">leda_integer</ref></computeroutput>, <computeroutput><ref refid="classCORE_1_1BigInt" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CORE::BigInt</ref></computeroutput>, and any instance of <computeroutput><ref refid="classCGAL_1_1Sqrt__extension" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Sqrt_extension</ref>&lt;A,B&gt;</computeroutput> instantiated with one of the integral types above.</para><para>The traits class defines a type <computeroutput>Curve_2</computeroutput> for algebraic curves. Such a type can be constructed by the <computeroutput>Construct_curve_2</computeroutput> functor, which accepts an instance of <computeroutput>Polynomial_2</computeroutput> as an argument. This polynomial type is also available by the traits class and constitutes a valid model of the concept <computeroutput>Polynomial_d</computeroutput> with two variables (see ??).</para><para><anchor id="index_1fig__arr_figex_alg_curves"/><image type="html" name="algebraic_curves.png"></image>
 <image type="latex" name="algebraic_curves.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_alg_curves" kindref="member">fig__arr_figex_alg_curves</ref> An arrangement of algebraic curves of degrees <formula id="121">$ 1$</formula>, <formula id="50">$ 2$</formula>, <formula id="177">$ 3$</formula>, and <formula id="202">$ 6$</formula>, as constructed in <computeroutput>algebraic_curves.cpp</computeroutput>.  <linebreak/>
</para><para>The following examples computes the arrangement induced by the four curves in <ref refid="index_1fig__arr_figex_alg_curves" kindref="member">fig__arr_figex_alg_curves</ref></para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2algebraic_curves_8cpp-example" kindref="compound">Arrangement_on_surface_2/algebraic_curves.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>(!CGAL_USE_CORE)<sp/>&amp;&amp;<sp/>(!CGAL_USE_LEDA)<sp/>&amp;&amp;<sp/>(!(CGAL_USE_GMP<sp/>&amp;&amp;<sp/>CGAL_USE_MPFI))</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE,<sp/>LEDA,<sp/>or<sp/>GMP+MPFI<sp/>...&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_algebraic_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>CGAL_USE_GMP<sp/>&amp;&amp;<sp/>CGAL_USE_MPFI</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Gmpz_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Gmpz.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Gmpz</ref><sp/>Integer;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="CORE__BigInt_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/CORE_BigInt.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCORE_1_1BigInt" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CORE::BigInt</ref><sp/>Integer;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="leda__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/leda_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LEDA::integer<sp/>Integer;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2" kindref="compound">CGAL::Arr_algebraic_segment_traits_2&lt;Integer&gt;</ref><sp/>Arr_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Arr_traits_2&gt;</ref><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arr_traits_2::Curve_2<sp/>Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arr_traits_2::Polynomial_2<sp/>Polynomial_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>nice<sp/>printouts</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgIOstreams_1ga2f2176255429973ea7bf156804a53857" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">CGAL::set_pretty_mode</ref>(std::cout);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arr_traits_2<sp/>arr_traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Functor<sp/>to<sp/>create<sp/>a<sp/>curve<sp/>from<sp/>a<sp/>Polynomial_2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arr_traits_2::Construct_curve_2<sp/>construct_curve</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>arr_traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polynomial_2<sp/>x<sp/>=<sp/>CGAL::shift(Polynomial_2(1),1,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polynomial_2<sp/>y<sp/>=<sp/>CGAL::shift(Polynomial_2(1),1,1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arrangement_2<sp/>arr(&amp;arr_traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>(unbounded<sp/>line)<sp/>with<sp/>equation<sp/>3x-5y+2=0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polynomial_2<sp/>f1<sp/>=<sp/>3*x-5*y+2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Curve_2<sp/>cv1<sp/>=<sp/>construct_curve(f1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Adding<sp/>curve<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>f1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>to<sp/>the<sp/>arrangement&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,cv1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>ellipse<sp/>x^2+3*y^2-10=0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polynomial_2<sp/>f2<sp/>=<sp/>CGAL::ipower(x,2)+3*CGAL::ipower(y,2)-10;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Curve_2<sp/>cv2<sp/>=<sp/>construct_curve(f2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Adding<sp/>curve<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>f2<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>to<sp/>the<sp/>arrangement&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,cv2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>cubic<sp/>curve<sp/>with<sp/>isoated<sp/>point,<sp/>and<sp/>vertical<sp/>asymptote</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>x^2+y^2+xy^2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polynomial_2<sp/>f3<sp/>=<sp/>CGAL::ipower(x,2)+CGAL::ipower(y,2)+x*CGAL::ipower(y,2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Curve_2<sp/>cv3<sp/>=<sp/>construct_curve(f3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Adding<sp/>curve<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>f3<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>to<sp/>the<sp/>arrangement&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,cv3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>curve<sp/>of<sp/>degree<sp/>6<sp/>with<sp/>equation<sp/>x^6+y^6-x^3y^3-12</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polynomial_2<sp/>f4<sp/>=<sp/>CGAL::ipower(x,6)+CGAL::ipower(y,6)-</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::ipower(x,3)*CGAL::ipower(y,3)-12;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Curve_2<sp/>cv4<sp/>=<sp/>construct_curve(f4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Adding<sp/>curve<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>f4<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>to<sp/>the<sp/>arrangement&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,cv4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para><para>We first give a precise definition of segments of algebraic curves. A point <formula id="46">$ p$</formula> on a curve <formula id="203">$ C_f\subset\mathbb{R}^2$</formula> (with <formula id="38">$ f$</formula> its defining equation) is called <emphasis>semi-regular</emphasis>, if locally around <formula id="46">$ p$</formula>, <formula id="204">$ C_f$</formula> can be written as a function graph of some continuous function in <formula id="2">$ x$</formula> or in <formula id="104">$ y$</formula> (we also say that <formula id="46">$ p$</formula> is parameterizable in <formula id="2">$ x$</formula> or <formula id="104">$ y$</formula>, respectively). The only two cases of non-semi-regular points are isolated points, and self-intersections. A <emphasis>segment</emphasis> of a curve is a closed and continuous point set such that each interior point is semi-regular. It follows that a weakly <formula id="2">$ x$</formula>-monotone segment is either a completely vertical segment, or a segment whose interior points are all parameterizable in <formula id="2">$ x$</formula>.</para><para>The traits class allows to construct weakly <formula id="2">$ x$</formula>-monotone segments of a curve using the <computeroutput>Construct_x_monotone_segment_2</computeroutput> functor. The <computeroutput>X_monotone_curve_2</computeroutput> type of the traits class represents weakly <formula id="2">$ x$</formula>-monotone segments of a curve; however, segments may need to be further subdivided into several (sub-)segments, for technical reasons. Therefore, <computeroutput>Construct_x_monotone_segment_2</computeroutput> constructs a sequence of <computeroutput>X_monotone_curve_2</computeroutput> objects, whose union represents the weakly <formula id="2">$ x$</formula>-monotone segment that was queried. We call a segment <emphasis>terminal</emphasis> if it can be represented by the type <computeroutput>X_monotone_curve_2</computeroutput>.</para><para></para><para>The subdivision of segments is due to the internal representation of <formula id="2">$ x$</formula>-monotone segments, which is based on a vertical decomposition. We assume the defining polynomial <formula id="38">$ f$</formula> of the curve <formula id="3">$ C$</formula> to be <emphasis>square-free</emphasis>, that means, it contains no divisor <formula id="205">$ g^2$</formula> of total degree greater than zero. We define a <emphasis>(complex) critical point</emphasis> <formula id="206">$ p\in\mathbb{C}^2$</formula> by <formula id="207">\[ f(p)=0=\frac{\partial f}{\partial y}(p). \]</formula> An <formula id="2">$ x$</formula>-coordinate <formula id="208">$ \alpha\in\mathbb{R}$</formula> is <emphasis>critical</emphasis> if either some critical point has <formula id="2">$ x$</formula>-coordinate <formula id="152">$ \alpha$</formula>, or if the leading coefficient of <formula id="38">$ f$</formula>, considered as a polynomial in <formula id="104">$ y$</formula>, vanishes. In particular, vertical lines of and isolated point of <formula id="3">$ C$</formula> can only take place at critical <formula id="2">$ x$</formula>-coordinates. Between two consecutive critical <formula id="2">$ x$</formula>-coordinates, the curve decomposes into a finite number of <formula id="2">$ x$</formula>-monotone segments (the same is true on the left of the leftmost, and on the right of the rightmost critical <formula id="2">$ x$</formula>-coordinate). The type <computeroutput>X_monotone_curve_2</computeroutput> is only able to represent such segments (and sub-segments of them). See <ref refid="index_1fig__arr_figcylindrical_decomposition" kindref="member">fig__arr_figcylindrical_decomposition</ref> for an example of a decomposition into terminal segments. Formally, a terminal segment is a weakly <formula id="2">$ x$</formula>-monotone segment that is either vertical, or its <formula id="2">$ x$</formula>-range contains no critical point in its interior. </para><para><anchor id="index_1fig__arr_figcylindrical_decomposition"/><image type="html" name="cylindrical_decomposition.png"></image>
 <image type="latex" name="cylindrical_decomposition.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figcylindrical_decomposition" kindref="member">fig__arr_figcylindrical_decomposition</ref> The critical <formula id="2">$ x$</formula>-coordinates of an algebraic curve (dashed lines), and its decomposition into terminal segments (in different colors). The segment from <formula id="46">$ p$</formula> to <formula id="73">$ q$</formula> consists of the union of three terminal segments.  <linebreak/>
</para><para>Coordinates of points are represented by the type <computeroutput>Algebraic_real_1</computeroutput>, which is defined in the traits class. This type is taken from a model of the <computeroutput>AlgebraicKernel_1</computeroutput> concept, which is also available by the type <computeroutput>Algebraic_kernel_1</computeroutput>. One can use this model to create algebraic numbers as roots of univariate polynomials, and process them, for instance, compare them, or approximate them to any precision. See the documentation of <computeroutput>AlgebraicKernel_1</computeroutput> for more information. One can construct an object of type <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> by a triple ( <formula id="209">$ x_0$</formula>,cv,i), which means that the <formula id="128">$ i$</formula>-th point (counted from below) in the fiber of cv at the <formula id="2">$ x$</formula>-coordinate <formula id="209">$ x_0$</formula> is constructed. This is also how points are presented internally. In the example displayed in <ref refid="index_1fig__arr_figcylindrical_decomposition" kindref="member">fig__arr_figcylindrical_decomposition</ref>, if <formula id="210">$ x_1$</formula> denotes the <formula id="2">$ x$</formula>-coordinate of <formula id="46">$ p$</formula>, and <formula id="211">$ cv$</formula> represents the algebraic curve, then <formula id="46">$ p$</formula> could be represented by <formula id="212">$ (x_1,cv,3)$</formula>. If <formula id="213">$ x_2$</formula> is the <formula id="2">$ x$</formula>-coordinate of <formula id="73">$ q$</formula>, then <formula id="214">$ (x_2,cv,1)$</formula> is a valid representation of <formula id="73">$ q$</formula>. Although the <formula id="104">$ y$</formula>-coordinate of an object of type <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> can be queried, we recommend to be careful with that option, since computing an explicit representation of the <formula id="104">$ y$</formula>-coordinate as an <computeroutput>Algebraic_real_1</computeroutput> object can become rather expensive.</para><para><anchor id="index_1fig__arr_figex_alg_segments"/><image type="html" name="algebraic_segments.png"></image>
 <image type="latex" name="algebraic_segments.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_alg_segments" kindref="member">fig__arr_figex_alg_segments</ref> An arrangement of algebraic segments (solid lines), as constructed in <computeroutput>algebraic_segments.cpp</computeroutput>. The supporting curves are drawn in dashed lines.  <linebreak/>
</para><para>The following code exemplifies various methods to construct algebraic segments. The computed arrangement is displayed in <ref refid="index_1fig__arr_figex_alg_segments" kindref="member">fig__arr_figex_alg_segments</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2algebraic_segments_8cpp-example" kindref="compound">Arrangement_on_surface_2/algebraic_segments.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/config.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/use.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>(!CGAL_USE_CORE)<sp/>&amp;&amp;<sp/>(!CGAL_USE_LEDA)<sp/>&amp;&amp;<sp/>(!(CGAL_USE_GMP<sp/>&amp;&amp;<sp/>CGAL_USE_MPFI))</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE,<sp/>LEDA,<sp/>or<sp/>GMP+MPFI<sp/>...&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_algebraic_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>CGAL_USE_GMP<sp/>&amp;&amp;<sp/>CGAL_USE_MPFI</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Gmpz_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Gmpz.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Gmpz</ref><sp/>Integer;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="CORE__BigInt_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/CORE_BigInt.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCORE_1_1BigInt" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CORE::BigInt</ref><sp/>Integer;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="leda__integer_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/leda_integer.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>LEDA::integer<sp/>Integer;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2" kindref="compound">CGAL::Arr_algebraic_segment_traits_2&lt;Integer&gt;</ref><sp/>Arr_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Arr_traits_2&gt;</ref><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arr_traits_2::Curve_2<sp/>Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arr_traits_2::Polynomial_2<sp/>Polynomial_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arr_traits_2::Algebraic_real_1<sp/>Algebraic_real_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arr_traits_2::X_monotone_curve_2<sp/>X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arr_traits_2::Point_2<sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arr_traits_2<sp/>arr_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arr_traits_2::Construct_curve_2<sp/>construct_curve</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>arr_traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arr_traits_2::Construct_x_monotone_segment_2<sp/>construct_x_monotone_segment</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>arr_traits.construct_x_monotone_segment_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arr_traits_2::Construct_point_2<sp/>construct_point</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>arr_traits.construct_point_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arr_traits_2::Make_x_monotone_2<sp/>make_x_monotone</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>arr_traits.make_x_monotone_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arrangement_2<sp/>arr(&amp;arr_traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;X_monotone_curve_2&gt;<sp/>segs;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polynomial_2<sp/>x<sp/>=<sp/>CGAL::shift(Polynomial_2(1),1,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polynomial_2<sp/>y<sp/>=<sp/>CGAL::shift(Polynomial_2(1),1,1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>x^4+y^3-1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Curve_2<sp/>cv0<sp/>=<sp/>construct_curve(CGAL::ipower(x,4)+CGAL::ipower(y,3)-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>all<sp/>x-monotone<sp/>segments<sp/>using<sp/>the<sp/>Make_x_mononotone<sp/>functor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;CGAL::Object&gt;<sp/>pre_segs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgCircularKernel2GeometricFunctions_1ga20791b9a88e184491fe836fb3780f8dc" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Circular_kernel_2.tag">make_x_monotone</ref>(cv0,std::back_inserter(pre_segs));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Cast<sp/>all<sp/>CGAL::Objects<sp/>into<sp/>X_monotone_segment_2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(the<sp/>vector<sp/>might<sp/>also<sp/>contain<sp/>Point_2<sp/>objects<sp/>for<sp/>isolated<sp/>points,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>but<sp/>not<sp/>for<sp/>this<sp/>instance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>pre_segs.size();<sp/>i++<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X_monotone_curve_2<sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>check<sp/>=<sp/>CGAL::assign(curr,pre_segs[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert(check);<sp/>CGAL_USE(check);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segs.push_back(curr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>ellipse<sp/>with<sp/>equation<sp/>2*x^2+5*y^2-7=0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Curve_2<sp/>cv1<sp/>=<sp/>construct_curve(2*CGAL::ipower(x,2)+5*CGAL::ipower(y,2)-7);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>point<sp/>on<sp/>the<sp/>upper<sp/>arc<sp/>(counting<sp/>of<sp/>arc<sp/>numbers<sp/>starts<sp/>with<sp/>0!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>p11<sp/>=<sp/>construct_point(Algebraic_real_1(0),cv1,1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>construct_x_monotone_segment(cv1,p11,Arr_traits_2::POINT_IN_INTERIOR,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>vertical<sp/>cusp<sp/>x^2-y^3=0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Curve_2<sp/>cv2<sp/>=<sp/>construct_curve(CGAL::ipower(x,2)-CGAL::ipower(y,3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>segment<sp/>containing<sp/>the<sp/>cusp<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>adds<sp/>to<sp/>X_monotone_curve_2<sp/>objects<sp/>to<sp/>the<sp/>vector,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>because<sp/>the<sp/>cusp<sp/>is<sp/>a<sp/>critical<sp/>point</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>p21<sp/>=<sp/>construct_point(Algebraic_real_1(-2),cv2,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>p22<sp/>=<sp/>construct_point(Algebraic_real_1(2),cv2,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>construct_x_monotone_segment(cv2,p21,p22,std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>unbounded<sp/>curve,<sp/>starting<sp/>at<sp/>x=3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>p23<sp/>=<sp/>construct_point(Algebraic_real_1(3),cv2,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>construct_x_monotone_segment(cv2,p23,Arr_traits_2::MIN_ENDPOINT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>another<sp/>conic:<sp/>y^2-x^2+1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Curve_2<sp/>cv3<sp/>=<sp/>construct_curve(CGAL::ipower(y,2)-CGAL::ipower(x,2)+1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>p31<sp/>=<sp/>construct_point(Algebraic_real_1(2),cv3,1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>construct_x_monotone_segment(cv3,p31,Arr_traits_2::MAX_ENDPOINT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>vertical<sp/>segment</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>v1<sp/>=<sp/>construct_point(0,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>v2<sp/>=<sp/>construct_point(Algebraic_real_1(0),cv1,1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>construct_x_monotone_segment(v1,v2,std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,segs.begin(),segs.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>some<sp/>isolated<sp/>points<sp/>(must<sp/>be<sp/>wrapped<sp/>into<sp/>CGAL::Object)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;CGAL::Object&gt;<sp/>isolated_points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>isolated_points.push_back</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(CGAL::make_object(construct_point(Algebraic_real_1(2),cv3,0)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>isolated_points.push_back</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(CGAL::make_object(construct_point(Integer(1),Integer(5))));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>isolated_points.push_back</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(CGAL::make_object(construct_point(Algebraic_real_1(-1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic_real_1(5))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,isolated_points.begin(),<sp/>isolated_points.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssecmeta_tr">
<title>Traits-Class Decorators</title>
<para>Geometric traits-class decorators allow you to attach auxiliary data to curves and to points. The data is automatically manipulated by the decorators and distributed to the constructed geometric entities. Note that additional information can alternatively be maintained by extending the vertex, halfedge, or face types provided by the Dcel class used by the arrangement; see the details in Section <ref refid="index_1arr_secex_dcel" kindref="member">Extending the DCEL</ref>.</para><para>The arrangement package includes a generic traits-class decorator template named <computeroutput><ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound">Arr_curve_data_traits_2</ref>&lt;BaseTraits, XMonotoneCurveData, Merge, CurveData, Convert&gt;</computeroutput>. This decorator is used to attach a data field to curves and to <formula id="2">$ x$</formula>-monotone curves. It is parameterized by a base-traits class, which is one of the geometric traits classes described in the previous subsections, or a user-defined traits class. The curve-data decorator derives itself from the base-traits class, and in particular inherits its <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> type. In addition: <itemizedlist>
<listitem>
<para><computeroutput>Curve_2</computeroutput> is derived from the basic <computeroutput>BaseTraits::Curve_2</computeroutput> class, extending it by an extra field of type <computeroutput>CurveData</computeroutput>. </para></listitem>
<listitem>
<para><computeroutput>X_monotone_curve_2</computeroutput> is derived from the basic <computeroutput>BaseTraits::X_monotone_curve_2</computeroutput> class, extending it by an extra field of type <computeroutput>XMonotoneCurveData</computeroutput>. </para></listitem>
</itemizedlist>
Note that the <computeroutput>Curve_2</computeroutput> and <computeroutput>X_monotone_curve_2</computeroutput> are not the same, even if the <computeroutput>BaseTraits::Curve_2</computeroutput> and <computeroutput>BaseTraits::X_monotone_curve_2</computeroutput> are (as in the case of the segment-traits class for example). The extended curve types support the additional methods <computeroutput>data()</computeroutput> and <computeroutput>set_data()</computeroutput> for accessing and modifying the data field.</para><para>You can create an extended curve (or an extended <formula id="2">$ x$</formula>-monotone curve) from a basic curve and a curve-data object. When curves are inserted into an arrangement, they may be split, and the decorator handles their data fields automatically: <itemizedlist>
<listitem>
<para>When a curve is subdivided into <formula id="2">$ x$</formula>-monotone subcurves, its data field of type <computeroutput>CurveData</computeroutput> is converted to an <computeroutput>XMonotoneCurveData</computeroutput> object <formula id="63">$ d$</formula> using the <computeroutput>Convert</computeroutput> functor. The object <formula id="63">$ d$</formula> is automatically associated with each of the resulting <formula id="2">$ x$</formula>-monotone subcurves.</para><para>Note that by default, the <computeroutput>CurveData</computeroutput> type is identical to the <computeroutput>XMonotoneCurveData</computeroutput> type (and the conversion functor <computeroutput>Convert</computeroutput> is trivially defined). Thus, the data field associated with the original curve is just duplicated and stored with the <formula id="2">$ x$</formula>-monotone subcurves. </para></listitem>
<listitem>
<para>When an <formula id="2">$ x$</formula>-monotone curve is split into two, the decorator class automatically copies its data field to both resulting subcurves. </para></listitem>
<listitem>
<para>When intersecting two <formula id="2">$ x$</formula>-monotone curves <formula id="48">$ c_1$</formula> and <formula id="49">$ c_2$</formula>, the result may include overlapping sections, represented as <formula id="2">$ x$</formula>-monotone curves. In this case the data fields of <formula id="48">$ c_1$</formula> and <formula id="49">$ c_2$</formula> are merged into a single <computeroutput>XMonotoneCurveData</computeroutput> object, using the <computeroutput>Merge</computeroutput> functor, which is supplied as a parameter to the traits class-template. The resulting object is assigned to the data field of the overlapping subcurves. </para></listitem>
<listitem>
<para>Merging two <formula id="2">$ x$</formula>-monotone curves is allowed only when (i) the two curves are geometrically mergeable - that is, the base-traits class allows to merge them - and (ii) the two curves store the same data field. </para></listitem>
</itemizedlist>
</para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__consolidated__curve__data__traits__2" kindref="compound">Arr_consolidated_curve_data_traits_2</ref>&lt;BaseTraits, Data&gt;</computeroutput> decorator specializes the generic curve-data decorator. It extends the basic <computeroutput>BaseTraits::Curve_2</computeroutput> by a single <computeroutput>Data</computeroutput> field, and the basic <computeroutput>BaseTraits::X_monotone_curve_2</computeroutput> with a <emphasis>set</emphasis> of (distinct) data objects. The <computeroutput>Data</computeroutput> type is required to support the equality operator, used to ensure that each set contains only distinct data objects with no duplicates. When a curve with a data field <formula id="63">$ d$</formula> is subdivided into <formula id="2">$ x$</formula>-monotone subcurves, each subcurve is associated with a set <formula id="215">$ S = \{ d \}$</formula>. In case of an overlap between two <formula id="2">$ x$</formula>-monotone curves <formula id="48">$ c_1$</formula> and <formula id="49">$ c_2$</formula> with associated data sets <formula id="216">$ S_1$</formula> and <formula id="217">$ S_2$</formula>, respectively, the overlapping subcurve is associated with the consolidated set <formula id="218">$ S_1 \cup S_2$</formula>.</para></sect2>
<sect2 id="index_1Arrangement_on_surface_2Examples">
<title>Examples</title>
<para><anchor id="index_1fig__arr_figex_17"/><image type="html" name="ex_17.png"></image>
 <image type="latex" name="ex_17.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_17" kindref="member">fig__arr_figex_17</ref> An arrangement of six red and blue segments, as constructed in <computeroutput>consolidated_curve_data.cpp</computeroutput>. Disks correspond to red-blue intersection points, while circles mark the endpoints of red-blue overlaps.  <linebreak/>
</para><para>In the following example, we use <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> as our base-traits class, attaching an additional <emphasis>color</emphasis> field to the segments using the consolidated curve-data traits class. A color may be either <emphasis>blue</emphasis> or <emphasis>red</emphasis>. Having constructed the arrangement of colored segments, as depicted in <ref refid="index_1fig__arr_figex_17" kindref="member">fig__arr_figex_17</ref>, we detect the vertices that have incident edges mapped to both blue and red segments. Thus, they correspond to red-blue intersection points. We also locate the edge that corresponds to overlaps between red and blue line segments:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2consolidated_curve_data_8cpp-example" kindref="compound">Arrangement_on_surface_2/consolidated_curve_data.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Associating<sp/>a<sp/>color<sp/>attribute<sp/>with<sp/>segments<sp/>using<sp/>the<sp/>consolidated</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>curve-data<sp/>traits.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_consolidated_curve_data_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_landmarks_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>Segment_color<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>RED,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BLUE</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Segment_traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__consolidated__curve__data__traits__2" kindref="compound">CGAL::Arr_consolidated_curve_data_traits_2</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;Segment_traits_2,<sp/>Segment_color&gt;<sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Colored_segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__landmarks__point__location" kindref="compound">CGAL::Arr_landmarks_point_location&lt;Arrangement_2&gt;</ref><sp/>Landmarks_pl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>containing<sp/>three<sp/>RED<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Landmarks_pl<sp/><sp/><sp/><sp/><sp/><sp/>pl<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s1<sp/>(Point_2(-1,<sp/>-1),<sp/>Point_2(1,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s2<sp/>(Point_2(2,<sp/>0),<sp/>Point_2(3,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s3<sp/>(Point_2(0,<sp/>3),<sp/>Point_2(2,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Colored_segment_2<sp/>(s1,<sp/>RED),<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Colored_segment_2<sp/>(s2,<sp/>RED),<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Colored_segment_2<sp/>(s3,<sp/>RED),<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>three<sp/>BLUE<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s4<sp/>(Point_2(-1,<sp/>3),<sp/>Point_2(4,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s5<sp/>(Point_2(-1,<sp/>0),<sp/>Point_2(4,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s6<sp/>(Point_2(-2,<sp/>1),<sp/>Point_2(1,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Colored_segment_2<sp/>(s4,<sp/>BLUE),<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Colored_segment_2<sp/>(s5,<sp/>BLUE),<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Colored_segment_2<sp/>(s6,<sp/>BLUE),<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>vertices<sp/>and<sp/>print<sp/>just<sp/>the<sp/>ones<sp/>corresponding<sp/>to<sp/>intersection</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>points<sp/>between<sp/>RED<sp/>segments<sp/>and<sp/>BLUE<sp/>segments.<sp/>Note<sp/>that<sp/>we<sp/>skip<sp/>endpoints</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>of<sp/>overlapping<sp/>sections.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Vertex_const_iterator<sp/><sp/><sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_color<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>the<sp/>incident<sp/>halfedges<sp/>of<sp/>the<sp/>current<sp/>vertex<sp/>and<sp/>examine<sp/>their</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>colors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>has_red<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>has_blue<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arrangement_2::Halfedge_around_vertex_const_circulator<sp/><sp/>eit,<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>eit<sp/>=<sp/>first<sp/>=<sp/>vit-&gt;incident_halfedges();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>color<sp/>of<sp/>the<sp/>current<sp/>half-edge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(eit-&gt;curve().data().size()<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color<sp/>=<sp/>eit-&gt;curve().data().front();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(color<sp/>==<sp/>RED)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>has_red<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(color<sp/>==<sp/>BLUE)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>has_blue<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++eit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(eit<sp/>!=<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>vertex<sp/>only<sp/>if<sp/>incident<sp/>RED<sp/>and<sp/>BLUE<sp/>edges<sp/>were<sp/>found.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(has_red<sp/>&amp;&amp;<sp/>has_blue)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Red-blue<sp/>intersection<sp/>at<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Locate<sp/>the<sp/>edges<sp/>that<sp/>correspond<sp/>to<sp/>a<sp/>red-blue<sp/>overlap.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1a9b3a4b116e66f66bcd69215fa3f513f9" kindref="member">Arrangement_2::Edge_iterator</ref><sp/><sp/><sp/>eit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>the<sp/>incident<sp/>edges<sp/>of<sp/>the<sp/>current<sp/>vertex<sp/>and<sp/>examine<sp/>their</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>colors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>has_red<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>has_blue<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Traits_2::Data_container::const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/>dit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(dit<sp/>=<sp/>eit-&gt;curve().data().begin();<sp/>dit<sp/>!=<sp/>eit-&gt;curve().data().end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++dit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(*dit<sp/>==<sp/>RED)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>has_red<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(*dit<sp/>==<sp/>BLUE)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>has_blue<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>edge<sp/>only<sp/>if<sp/>it<sp/>corresponds<sp/>to<sp/>a<sp/>red-blue<sp/>overlap.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(has_red<sp/>&amp;&amp;<sp/>has_blue)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Red-blue<sp/>overlap<sp/>at<sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]&quot;</highlight><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__arr_figex_18"/><image type="html" name="ex_18.png"></image>
 <image type="latex" name="ex_18.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_18" kindref="member">fig__arr_figex_18</ref> An arrangement of four polylines, named A-D, as constructed in <computeroutput>generic_curve_data.cpp</computeroutput>.  <linebreak/>
</para><para>In the following example, we use <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref></computeroutput> as our base-traits class, attaching an additional <emphasis>name</emphasis> field to each polyline using the generic curve-data traits class. In case of overlaps, we simply concatenate the names of the overlapping polylines. Also notice how we replace the curve associated with the edges that correspond to overlapping polylines with geometrically equivalent curves, but with a different data fields:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2generic_curve_data_8cpp-example" kindref="compound">Arrangement_on_surface_2/generic_curve_data.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Associating<sp/>a<sp/>name<sp/>attribute<sp/>with<sp/>segments<sp/>using<sp/>the<sp/>generic<sp/>curve-data</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>traits.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_polyline_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_curve_data_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>functor<sp/>for<sp/>concatenating<sp/>name<sp/>fields.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::string<sp/><sp/><sp/>Name;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Merge_names</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Name<sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Name&amp;<sp/>s1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Name&amp;<sp/>s2)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(s1<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>+<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">CGAL::Arr_polyline_traits_2&lt;Segment_traits_2&gt;</ref><sp/><sp/><sp/>Polyline_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyline_traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyline_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound">CGAL::Arr_curve_data_traits_2&lt;Polyline_traits_2, Name, Merge_names&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyline_traits_2<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyline_traits_2::Construct_curve_2<sp/>poly_const<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>of<sp/>four<sp/>polylines<sp/>named<sp/>A--D.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points1[5]<sp/>=<sp/>{Point_2(0,0),<sp/>Point_2(2,4),<sp/>Point_2(3,3),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2(4,4),<sp/>Point_2(6,0)};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Curve_2<sp/>(poly_const<sp/>(points1,<sp/>points1<sp/>+<sp/>5),<sp/></highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points2[3]<sp/>=<sp/>{Point_2(1,5),<sp/>Point_2(3,3),<sp/>Point_2(5,5)};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Curve_2<sp/>(poly_const<sp/>(points2,<sp/>points2<sp/>+<sp/>3),<sp/></highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points3[4]<sp/>=<sp/>{Point_2(1,0),<sp/>Point_2(2,2),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2(4,2),<sp/>Point_2(5,0)};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Curve_2<sp/>(poly_const<sp/>(points3,<sp/>points3<sp/>+<sp/>4),<sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points4[2]<sp/>=<sp/>{Point_2(0,2),<sp/>Point_2(6,2)};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Curve_2<sp/>(poly_const<sp/>(points4,<sp/>points4<sp/>+<sp/>2),<sp/></highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>all<sp/>edges<sp/>that<sp/>correspond<sp/>to<sp/>an<sp/>overlapping<sp/>polyline.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1a9b3a4b116e66f66bcd69215fa3f513f9" kindref="member">Arrangement_2::Edge_iterator</ref><sp/><sp/><sp/><sp/>eit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(eit-&gt;curve().data().length()<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/><sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;named:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;curve().data()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Rename<sp/>the<sp/>curve<sp/>associated<sp/>with<sp/>the<sp/>edge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>arr.modify_edge<sp/>(eit,<sp/>X_monotone_curve_2<sp/>(eit-&gt;curve(),<sp/></highlight><highlight class="stringliteral">&quot;overlap&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The third example we give in this section is based on <computeroutput>dual_lines.cpp</computeroutput> given in Section <ref refid="index_1arr_ssecunb_global" kindref="member">Free Functions</ref>. It constructs the arrangement of the dual lines for a set of point given in an input file (by default we use <computeroutput>coll_points.dat</computeroutput>, which contains <formula id="219">$ 50$</formula> points randomly selected on the grid <formula id="220">$ [-100,100]\times[-100,100]$</formula>; the file contains two distinct triplets of collinear points). Here we use the generic curve-data decorator to attach the index of the primal point to each of the lines. Doing so, we can go over the incident edges of each vertex whose degree is greater than <formula id="96">$ 4$</formula> and report the subsets collinear points (if we have a vertex of degree <formula id="63">$ d$</formula>, we actually need to go over <formula id="221">$ \frac{d}{2}$</formula> edges, as each incident line contributes exactly <formula id="50">$ 2$</formula> edges). Note that in this case the dual line cannot overlap, so we use a dummy merge functor to instantiate the curve-data traits:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2dual_with_data_8cpp-example" kindref="compound">Arrangement_on_surface_2/dual_with_data.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Checking<sp/>whether<sp/>there<sp/>are<sp/>three<sp/>collinear<sp/>points<sp/>in<sp/>a<sp/>given<sp/>input<sp/>set</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>using<sp/>the<sp/>arrangement<sp/>of<sp/>the<sp/>dual<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_linear_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_curve_data_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Linear_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Linear_traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Linear_traits_2::Line_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Line_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound">CGAL::Arr_curve_data_traits_2</ref>&lt;Linear_traits_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;<sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>points.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;coll_points.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/><sp/><sp/><sp/><sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>points<sp/>from<sp/>the<sp/>file,<sp/>and<sp/>construct<sp/>their<sp/>dual<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;X_monotone_curve_2&gt;<sp/><sp/>dual_lines;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.resize(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>n;<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>px,<sp/>py;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>px<sp/>&gt;&gt;<sp/>py;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points[k]<sp/>=<sp/>Point_2(px,<sp/>py);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>line<sp/>dual<sp/>to<sp/>the<sp/>point<sp/>(p_x,<sp/>p_y)<sp/>is<sp/>y<sp/>=<sp/>p_x*x<sp/>-<sp/>p_y,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>or:<sp/>p_x*x<sp/>-<sp/>y<sp/>-<sp/>p_y<sp/>=<sp/>0:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Line_2<sp/>dual_line<sp/>=<sp/>Line_2(<ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(px),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(-1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref>(-py));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Generate<sp/>the<sp/>x-monotone<sp/>curve<sp/>based<sp/>on<sp/>the<sp/>line<sp/>and<sp/>the<sp/>point<sp/>index.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dual_lines.push_back(X_monotone_curve_2(dual_line,<sp/>k));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>dual<sp/>arrangement<sp/>by<sp/>aggregately<sp/>inserting<sp/>the<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>dual_lines.begin(),<sp/>dual_lines.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Look<sp/>for<sp/>vertices<sp/>whose<sp/>degree<sp/>is<sp/>greater<sp/>than<sp/>4.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Vertex_const_iterator<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Halfedge_around_vertex_const_circulator<sp/>circ;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>d;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vit-&gt;degree()<sp/>&gt;<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>should<sp/>be<sp/>vit-&gt;degree()/2<sp/>lines<sp/>intersecting<sp/>at<sp/>the<sp/>current</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>vertex.<sp/>We<sp/>print<sp/>their<sp/>primal<sp/>points<sp/>and<sp/>their<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>circ<sp/>=<sp/>vit-&gt;incident_halfedges();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(d<sp/>=<sp/>0;<sp/>d<sp/>&lt;<sp/>vit-&gt;degree()<sp/>/<sp/>2;<sp/>d++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>k<sp/>=<sp/>circ-&gt;curve().data();<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>index<sp/>of<sp/>the<sp/>primal<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Point<sp/>no.<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k+1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points[k]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;),<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++circ;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;are<sp/>collinear.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1arr_secnotif">
<title>The Notification Mechanism</title>
<para>For some applications it is essential to know exactly what happens inside a specific arrangement-instance. For example, when a new curve is inserted into an arrangement, it might be desired to keep track of the faces that are split due to this insertion operation. Other important examples are the point-location strategies that require auxiliary data-structures (see Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>), which must be notified on various local changes in the arrangement, in order to keep their data structures up-to-date. The arrangement package offers a mechanism that uses <emphasis>observers</emphasis> (see <ref refid="citelist_1CITEREF_cgal:ghjv-dpero-95" kindref="member">[4]</ref>) that can be attached to an arrangement instance and receive notifications about the changes this arrangement goes through.</para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__observer" kindref="compound">Arr_observer</ref>&lt;Arrangement&gt;</computeroutput> class-template is parameterized with an arrangement class. It stores a pointer to an arrangement object, and is capable of receiving notifications <emphasis>just before</emphasis> a structural change occurs in the arrangement and <emphasis>immediately after</emphasis> such a change takes place. <computeroutput><ref refid="classCGAL_1_1Arr__observer" kindref="compound">Arr_observer</ref></computeroutput> serves as a base class for other observer classes and defines a set of virtual notification functions, with default empty implementations.</para><para>The set of functions can be divided into three categories, as follows: <orderedlist>
<listitem>
<para>Notifiers of changes that affect the entire topological structure of the arrangement. This category consists of two pairs that notify the observer of the following changes: <itemizedlist>
<listitem>
<para>The arrangement is cleared. </para></listitem>
<listitem>
<para>The arrangement is assigned with the contents of another arrangement. </para></listitem>
</itemizedlist>
</para></listitem>
<listitem>
<para>Pairs of notifiers of a local change that occurs in the topological structure. Most notifier functions belong to this category. The relevant local changes include: <itemizedlist>
<listitem>
<para>A new vertex is constructed and associated with a point. </para></listitem>
<listitem>
<para>An edgeThe term &quot;edge&quot; refers here to a pair of twin half-edges. is constructed and associated with an <formula id="2">$ x$</formula>-monotone curve. </para></listitem>
<listitem>
<para>An edge is split into two edges. </para></listitem>
<listitem>
<para>An existing face is split into two faces, as a consequence of the insertion of a new edge. </para></listitem>
<listitem>
<para>A hole is created in the interior of a face. </para></listitem>
<listitem>
<para>Two holes are merged to form a single hole, as a consequence of the insertion of a new edge. </para></listitem>
<listitem>
<para>A hole is moved from one face to another, as a consequence of a face split. </para></listitem>
<listitem>
<para>Two edges are merged into one edge. </para></listitem>
<listitem>
<para>Two faces are merged into one face, as a consequence of the removal of an edge that used to separate them. </para></listitem>
<listitem>
<para>One hole is split into two, as a consequence of the deletion of an edge that used to connect the two components. </para></listitem>
<listitem>
<para>A vertex is removed. </para></listitem>
<listitem>
<para>An edge is removed. </para></listitem>
<listitem>
<para>A hole is deleted from the interior of a face. </para></listitem>
</itemizedlist>
</para></listitem>
<listitem>
<para>Notifiers about a change applied by a free (global) function. This category consists of a single pair of notifiers, namely <computeroutput>before_global_change()</computeroutput> and <computeroutput>after_global_change()</computeroutput>. Neither of these functions is invoked by methods of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class. Instead, they are called by the free functions themselves. It is implied that no point-location queries (or any other queries for that matter) are issued between the calls to the notification functions above. </para></listitem>
</orderedlist>
See the Reference Manual for a detailed specification of the <computeroutput><ref refid="classCGAL_1_1Arr__observer" kindref="compound">Arr_observer</ref></computeroutput> class along with the exact prototypes of all notification functions.</para><para>Each arrangement object stores a (possibly empty) list of pointers to <computeroutput><ref refid="classCGAL_1_1Arr__observer" kindref="compound">Arr_observer</ref></computeroutput> objects, and whenever one of the structural changes listed in the first two categories above is about to take place, the arrangement object performs a <emphasis>forward</emphasis> traversal on this list and invokes the appropriate function of each observer. After the change takes place the observer list is traversed in a <emphasis>backward</emphasis> manner (from tail to head), and the appropriate notification function is invoked for each observer. This allows the nesting of observer objects.</para><para>Concrete arrangement-observer classes should inherit from <computeroutput><ref refid="classCGAL_1_1Arr__observer" kindref="compound">Arr_observer</ref></computeroutput>. When an observer is constructed, it is attached to a valid arrangement supplied to the observed constructor, or alternatively the observer can be attached to the arrangement at a later time. When this happens, the observer instance inserts itself into the observer list of the associated arrangement and starts receiving notifications whenever this arrangement changes thereafter. Naturally, the observer object unregisters itself by removing itself from this list just before it is destroyed.</para><para>The trapezoidal RIC and the landmark point-location strategies both use observers to keep their auxiliary data structures up-to-date. Besides them, users can define their own observer classes, by inheriting from the base observer class and overriding the relevant notification functions, as required by their applications.</para><para><anchor id="index_1fig__arr_figex_19"/><image type="html" name="ex_19.png"></image>
 <image type="latex" name="ex_19.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_19" kindref="member">fig__arr_figex_19</ref> An arrangement of five line segments, as constructed in <computeroutput>observer.cpp</computeroutput>. The halfedge <formula id="222">$ e_v$</formula> (dashed) is eventually removed, so that the final arrangement consists of four faces (one unbounded and three bounded ones).  <linebreak/>
</para><para>The following example shows how to define and use an observer class. The observer in the example keeps track of the arrangement faces, and prints a message whenever a face is split into two due to the insertion of an edge, and whenever two faces merge into one due to the removal of an edge. The layout of the arrangement is depicted in <ref refid="index_1fig__arr_figex_19" kindref="member">fig__arr_figex_19</ref> :</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2observer_8cpp-example" kindref="compound">Arrangement_on_surface_2/observer.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Using<sp/>a<sp/>simple<sp/>arrangement<sp/>observer.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Quotient_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Quotient.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="MP__Float_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/MP_Float.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_observer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Quotient&lt;CGAL::MP_Float&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>An<sp/>arrangement<sp/>observer,<sp/>used<sp/>to<sp/>receive<sp/>notifications<sp/>of<sp/>face<sp/>splits<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>face<sp/>mergers.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_observer<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__observer" kindref="compound">CGAL::Arr_observer</ref>&lt;Arrangement_2&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_observer<sp/>(Arrangement_2&amp;<sp/>arr)<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL" kindref="compound">CGAL</ref>::Arr_observer&lt;Arrangement_2&gt;<sp/>(arr)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>before_split_face<sp/>(Face_handle,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;-&gt;<sp/>The<sp/>insertion<sp/>of<sp/>:<sp/><sp/>[<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>e-&gt;curve()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>]<sp/><sp/>causes<sp/>a<sp/>face<sp/>to<sp/>split.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>before_merge_face<sp/>(Face_handle,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_handle,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;-&gt;<sp/>The<sp/>removal<sp/>of<sp/>:<sp/><sp/>[<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>e-&gt;curve()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>]<sp/><sp/>causes<sp/>two<sp/>faces<sp/>to<sp/>merge.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>containing<sp/>one<sp/>diamond-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_observer<sp/><sp/><sp/><sp/>obs<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s1<sp/>(Point_2(-1,<sp/>0),<sp/>Point_2(0,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s2<sp/>(Point_2(0,<sp/>1),<sp/>Point_2(1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s3<sp/>(Point_2(1,<sp/>0),<sp/>Point_2(0,<sp/>-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s4<sp/>(Point_2(0,<sp/>-1),<sp/>Point_2(-1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>vertical<sp/>segment<sp/>dividing<sp/>the<sp/>diamond<sp/>into<sp/>two,<sp/>and<sp/>a</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>a<sp/>horizontal<sp/>segment<sp/>further<sp/>dividing<sp/>the<sp/>diamond<sp/>into<sp/>four:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s_vert<sp/>(Point_2(0,<sp/>-1),<sp/>Point_2(0,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member">Arrangement_2::Halfedge_handle</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>e_vert<sp/>=<sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s_vert);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s_horiz<sp/>(Point_2(-1,<sp/>0),<sp/>Point_2(1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>s_horiz);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>initial<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Now<sp/>remove<sp/>a<sp/>portion<sp/>of<sp/>the<sp/>vertical<sp/>segment.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1ga324fdf8354e7812fe0e1c0e5ac14196c" kindref="member">remove_edge</ref><sp/>(arr,<sp/>e_vert);</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>final<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Observers are especially useful when the Dcel records are extended and store additional data, as they help updating this data on-line. See Section <ref refid="index_1arr_secex_dcel" kindref="member">Extending the DCEL</ref> for more details and examples.</para></sect1>
<sect1 id="index_1arr_secex_dcel">
<title>Extending the DCEL</title>
<para>For many applications of the arrangement package it is necessary to store additional information (perhaps of non-geometric nature) with the arrangement cells. As vertices are associated with <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> objects and edges (halfedge pairs) are associated with <computeroutput>X_monotone_curve_2</computeroutput> objects, both defined by the traits class, it is possible to extend the traits-class type by using a traits-class decorator, as explained in Section <ref refid="index_1arr_ssecmeta_tr" kindref="member">Traits-Class Decorators</ref>, which may be a sufficient solution for some applications. However, the Dcel faces are not associated with any geometric object, so it is impossible to extend them using a traits-class decorator. Extending the Dcel face records comes handy is such cases. As a matter of fact, it is possible to conveniently extend all Dcel records (namely vertices, halfedges and faces), which can also be advantageous for some applications.</para><para>All examples presented so far use the default <computeroutput><ref refid="classCGAL_1_1Arr__default__dcel" kindref="compound">Arr_default_dcel</ref>&lt;Traits&gt;</computeroutput>. This is done implicitly, as this class serves as a default parameter for the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> template. The default Dcel class just associates points with vertices and <formula id="2">$ x$</formula>-monotone curves with halfedge, but nothing more. In this section we show how to use alternative Dcel types to extend the desired Dcel records.</para><sect2 id="index_1arr_ssecex_dcel_face">
<title>Extending the DCEL Faces</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">Arr_face_extended_dcel</ref>&lt;Traits, FaceData&gt;</computeroutput> class-template is used to associate auxiliary data field of type <computeroutput>FaceData</computeroutput> to each face record in the Dcel.</para><para>When an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> object is parameterized by this Dcel class, its nested <computeroutput>Face</computeroutput> type is extended with the access function <computeroutput>data()</computeroutput> and with the modifier <computeroutput>set_data()</computeroutput>. Using these extra functions it is straightforward to access and maintain the auxiliary face-data field.</para><para>Note that the extra data fields must be maintained by the application programmers. They may choose to construct their arrangement, and only then go over the faces and attach the appropriate data fields to the arrangement faces. However, in some cases the face data can only be computed when the face is created (split from another face, or merged with another face). In such cases one can use an arrangement observer tailored for this task, which receives updates whenever a face is modified and sets its data field accordingly.</para><para><anchor id="index_1fig__arr_figex_20"/><image type="html" name="ex_20.png"></image>
 <image type="latex" name="ex_20.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_20" kindref="member">fig__arr_figex_20</ref> An arrangement of six line segments, as constructed in <computeroutput>face_extension.cpp</computeroutput> and <computeroutput>dcel_extension.cpp</computeroutput> (in <computeroutput>dcel_extension.cpp</computeroutput> we treat the segments as directed, so they are drawn as arrows directed from the source to the target). The indices associated with the halfedges in <computeroutput>face_extension.cpp</computeroutput> are shown in brackets.  <linebreak/>
</para><para>The next example constructs an arrangement that contains seven bounded faces induced by six line segments (see <ref refid="index_1fig__arr_figex_20" kindref="member">fig__arr_figex_20</ref>). An observer gets notified each time a new face <formula id="38">$ f$</formula> is created and it associates <formula id="38">$ f$</formula> with a running index, (where the index of the unbounded face is 0). As a result, the faces are numbered according to their creation order, as one can easily verify by examining the insertion order of the segments:For simplicity, the particular observer used must be attached to an empty arrangement. It is not difficult however to modify the program to handle the general case of attaching a similar observer to a non-empty arrangement.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2face_extension_8cpp-example" kindref="compound">Arrangement_on_surface_2/face_extension.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Extending<sp/>the<sp/>arrangement-face<sp/>records.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_observer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits_2, int&gt;</ref><sp/><sp/><sp/><sp/>Dcel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>An<sp/>arrangement<sp/>observer,<sp/>used<sp/>to<sp/>receive<sp/>notifications<sp/>of<sp/>face<sp/>splits<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>to<sp/>update<sp/>the<sp/>indices<sp/>of<sp/>the<sp/>newly<sp/>created<sp/>faces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Face_index_observer<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__observer" kindref="compound">CGAL::Arr_observer</ref>&lt;Arrangement_2&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>n_faces;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>current<sp/>number<sp/>of<sp/>faces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_index_observer<sp/>(Arrangement_2&amp;<sp/>arr)<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL" kindref="compound">CGAL</ref>::Arr_observer&lt;Arrangement_2&gt;<sp/>(arr),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n_faces<sp/>(0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_precondition<sp/>(arr.is_empty());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>arr.unbounded_face()-&gt;set_data<sp/>(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n_faces++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>after_split_face<sp/>(Face_handle<sp/></highlight><highlight class="comment">/*<sp/>old_face<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_handle<sp/>new_face,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Assign<sp/>index<sp/>to<sp/>the<sp/>new<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>new_face-&gt;set_data<sp/>(n_faces);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n_faces++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>containing<sp/>two<sp/>intersecting<sp/>triangles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_index_observer<sp/><sp/><sp/><sp/>obs<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s1<sp/>(Point_2(4,<sp/>1),<sp/>Point_2(7,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s2<sp/>(Point_2(1,<sp/>6),<sp/>Point_2(7,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s3<sp/>(Point_2(4,<sp/>1),<sp/>Point_2(1,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s4<sp/>(Point_2(1,<sp/>3),<sp/>Point_2(7,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s5<sp/>(Point_2(1,<sp/>3),<sp/>Point_2(4,<sp/>8));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s6<sp/>(Point_2(4,<sp/>8),<sp/>Point_2(7,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>s4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>s5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>s6);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>faces<sp/>and<sp/>print<sp/>the<sp/>index<sp/>of<sp/>each<sp/>face<sp/>and<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>outer<sp/>boundary.<sp/>The<sp/>face<sp/>index<sp/>is<sp/>stored<sp/>in<sp/>its<sp/>data<sp/>field<sp/>in<sp/>our<sp/>case.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Face_const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2::Ccb_halfedge_const_circulator<sp/><sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>faces:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Face<sp/>no.<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fit-&gt;data()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fit-&gt;is_unbounded())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Unbounded.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>curr<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>curr-&gt;source()-&gt;point();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>--&gt;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>curr-&gt;target()-&gt;point();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(curr<sp/>!=<sp/>fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssecex_dcel_all">
<title>Extending All DCEL Records</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">Arr_extended_dcel</ref>&lt;Traits, VertexData, HalfedgeData, FaceData&gt;</computeroutput> class-template is used to associate auxiliary data fields of types <computeroutput>VertexData</computeroutput> <computeroutput>HalfedgeData</computeroutput>, and <computeroutput>FaceData</computeroutput> to each Dcel vertex, halfedge, and face record types, respectively.</para><para>When an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> object is injected with this Dcel class, each one of its nested <computeroutput>Vertex</computeroutput>, <computeroutput>Halfedge</computeroutput> and <computeroutput>Face</computeroutput> classes is extended by the access function <computeroutput>data()</computeroutput> and by the modifier <computeroutput>set_data()</computeroutput>.</para><para>The next example shows how to use a Dcel with extended vertex, halfedge, and face records. In this example each vertex is associated with a color, which may be blue, red, or white, depending on whether the vertex is isolated, represents a segment endpoint, or whether it represents an intersection point. Each halfedge is associated with Boolean flag indicating whether its direction is the same as the direction of its associated segment (in this example segments are treated as directed objects). Each face is also extended to store the size of its outer boundary.</para><para>The constructed arrangement, depicted in <ref refid="index_1fig__arr_figex_20" kindref="member">fig__arr_figex_20</ref>, is similar to the arrangement constructed in the previous example. Note that all auxiliary data fields are set during the construction phase. Also note that the data fields are properly maintained when the arrangement is copied to another arrangement instance:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2dcel_extension_8cpp-example" kindref="compound">Arrangement_on_surface_2/dcel_extension.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Extending<sp/>all<sp/>DCEL<sp/>records<sp/>(vertices,<sp/>edges<sp/>and<sp/>faces).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>Color<sp/>{BLUE,<sp/>RED,<sp/>WHITE};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">CGAL::Arr_extended_dcel&lt;Traits_2,Color, bool, int&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Dcel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>containing<sp/>two<sp/>intersecting<sp/>triangles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s1<sp/>(Point_2(4,<sp/>1),<sp/>Point_2(7,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s2<sp/>(Point_2(1,<sp/>6),<sp/>Point_2(7,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s3<sp/>(Point_2(4,<sp/>1),<sp/>Point_2(1,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s4<sp/>(Point_2(1,<sp/>3),<sp/>Point_2(7,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s5<sp/>(Point_2(1,<sp/>3),<sp/>Point_2(4,<sp/>8));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s6<sp/>(Point_2(4,<sp/>8),<sp/>Point_2(7,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>s4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>s5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>s6);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>vertices<sp/>and<sp/>set<sp/>their<sp/>colors<sp/>according<sp/>to<sp/>our</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>coloring<sp/>convention.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1ac4a88fd2ca22b490454e4f425005e5c4" kindref="member">Arrangement_2::Vertex_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>degree;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>degree<sp/>=<sp/>vit-&gt;degree();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(degree<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>vit-&gt;set_data<sp/>(BLUE);<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Isolated<sp/>vertex.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(degree<sp/>&lt;=<sp/>2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>vit-&gt;set_data<sp/>(RED);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vertex<sp/>represents<sp/>an<sp/>endpoint.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>vit-&gt;set_data<sp/>(WHITE);<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vertex<sp/>represents<sp/>an<sp/>intersection<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>edges<sp/>and<sp/>set<sp/>their<sp/>flags.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1a9b3a4b116e66f66bcd69215fa3f513f9" kindref="member">Arrangement_2::Edge_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>eit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>flag;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>the<sp/>halfedge<sp/>has<sp/>the<sp/>same<sp/>direction<sp/>as<sp/>its<sp/>associated</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>segment.<sp/>Note<sp/>that<sp/>its<sp/>twin<sp/>always<sp/>has<sp/>an<sp/>opposite<sp/>direction.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>flag<sp/>=<sp/>(eit-&gt;source()-&gt;point()<sp/>==<sp/>eit-&gt;curve().source());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>eit-&gt;set_data<sp/>(flag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>eit-&gt;twin()-&gt;set_data<sp/>(!flag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>each<sp/>arrangement<sp/>face,<sp/>print<sp/>the<sp/>outer<sp/>boundary<sp/>and<sp/>its<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1aa91e8147cf0a7cc30366af5b6f9a058e" kindref="member">Arrangement_2::Face_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1ab4a594c193ca09a672dbe2fcafa090e9" kindref="member">Arrangement_2::Ccb_halfedge_circulator</ref><sp/><sp/><sp/><sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boundary_size;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boundary_size<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>fit-&gt;is_unbounded())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>curr<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++boundary_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(curr<sp/>!=<sp/>fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data<sp/>(boundary_size);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Copy<sp/>the<sp/>arrangement<sp/>and<sp/>print<sp/>the<sp/>vertices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/>arr2<sp/>=<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>vertices:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>arr2.vertices_begin();<sp/>vit<sp/>!=<sp/>arr2.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;(&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>-<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(vit-&gt;data())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>BLUE<sp/><sp/>:<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;BLUE.&quot;</highlight><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>RED<sp/><sp/><sp/>:<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;RED.&quot;</highlight><highlight class="normal"><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>WHITE<sp/>:<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;WHITE.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para></para><para>The various Dcel classes presented in this section are perfectly sufficient for most applications based on the arrangement package. However, users may also use their own implementation of a Dcel class to instantiate the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class-template, in case they need special functionality from their Dcel. Such a class must be a model of the concept <computeroutput><ref refid="classArrangementDcel" kindref="compound">ArrangementDcel</ref></computeroutput>, whose exact specification is listed in the Reference Manual. </para></sect2>
</sect1>
<sect1 id="index_1arr_secoverlay">
<title>Overlaying Arrangements</title>
<para>Assume that we are given two geographic maps represented as arrangements with some data objects attached to their faces, representing some geographic information - for example, a map of the annual precipitation in some country and a map of the vegetation in the same country. It is interesting to overlay the two maps to locate, for example, the regions where there is a pine forest and the annual precipitation is between 1000mm and 1500mm.</para><para>Computing the overlay of two planar arrangement is also useful for supporting Boolean set operations on polygons (or generalized polygons, see, e.g., <ref refid="citelist_1CITEREF_cgal:behhms-cbcab-02" kindref="member">[2]</ref>).</para><para>The function <computeroutput>overlay (arr_a, arr_b, ovl_arr, ovl_traits)</computeroutput> accepts two input arrangement instances <computeroutput>arr_a</computeroutput> and <computeroutput>arr_b</computeroutput>, and constructs their overlay instance <computeroutput>ovl_arr</computeroutput>. All three arrangements must use the same geometric primitives. More precisely, let <computeroutput>arr_a</computeroutput> be of type <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits_A,Dcel_A&gt;</computeroutput>, <computeroutput>arr_b</computeroutput> be of type <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits_B,Dcel_B&gt;</computeroutput> and the resulting <computeroutput>ovl_arr</computeroutput> be of type <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits_R,Dcel_R&gt;</computeroutput>. All types nested in geometry traits <computeroutput>Traits_A</computeroutput>, e.g., <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> and <computeroutput>X_monotone_curve_2</computeroutput>, must be convertible to the corresponding types nested in geometry traits <computeroutput>Traits_R</computeroutput>. The same holds for all types nested in geometry traits <computeroutput>Traits_B</computeroutput>. The <computeroutput>ovl_traits</computeroutput> parameter is an instance of an <emphasis>overlay traits-class</emphasis>, which enables the creation of <computeroutput>Dcel_R</computeroutput> records in the overlaid arrangement from the Dcel features of <computeroutput>arr_a</computeroutput> and <computeroutput>arr_b</computeroutput> that they correspond to.</para><para>In principle, we distinguish between three levels of overlay: <variablelist>
<varlistentry><term><bold>Simple overlay:</bold></term></varlistentry>
<listitem><para>An overlay of two arrangements that store no additional data with their Dcel records. That is, they are defined using the default Dcel class <computeroutput><ref refid="classCGAL_1_1Arr__default__dcel" kindref="compound">Arr_default_dcel</ref></computeroutput>. Typically, the overlaid arrangement in this case stores no extra data with its Dcel records as well (or if it does, the additional data fields cannot be computed by the overlay operation), so by overlaying the two arrangement we just compute the arrangement of all curves that induce <computeroutput>arr_a</computeroutput> and <computeroutput>arr_b</computeroutput>. Note that the same result can be obtained using the standard insertion operations, but users may choose to use overlay computation in order to achieve better running times.</para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__default__overlay__traits" kindref="compound">Arr_default_overlay_traits</ref></computeroutput> class should be used as an overlay traits-class for such simple overlay operations. </para></listitem>
<varlistentry><term><bold>Face overlay:</bold></term></varlistentry>
<listitem><para>An overlay of two arrangements that store additional data fields with their faces (e.g., the geographic-map example given in the beginning of this section). The resulting overlaid arrangement typically also stores extraneous data fields with its faces, where the data field that is attached to an overlaid face can be computed from the data fields of the two faces (in <computeroutput>arr_a</computeroutput> and <computeroutput>arr_b</computeroutput>) that induce the overlaid face.</para><para>The <computeroutput><ref refid="classCGAL_1_1Arr__face__overlay__traits" kindref="compound">Arr_face_overlay_traits</ref></computeroutput> class should be used as an overlay traits-class for face-overlay operations. It operates on arrangement, whose Dcel representation is based on the <computeroutput><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">Arr_face_extended_dcel</ref></computeroutput> class-template (see Section <ref refid="index_1arr_ssecex_dcel_face" kindref="member">Extending the DCEL Faces</ref>). The face-overlay traits-class is parameterized by a functor that is capable of combining two face-data fields of types <computeroutput>Dcel_A::Face_data</computeroutput> and <computeroutput>Dcel_B::Face_data</computeroutput>, and computing the output <computeroutput>Dcel_R::Face_data</computeroutput> object. The overlay traits-class uses this functor to properly construct the overlaid faces. </para></listitem>
<varlistentry><term><bold>Full overlay:</bold></term></varlistentry>
<listitem><para>An overlay of two arrangements that store additional data fields with all their Dcel records. That is, their Dcel classes are instantiations of the <computeroutput><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">Arr_extended_dcel</ref></computeroutput> class-template (see Section <ref refid="index_1arr_ssecex_dcel_all" kindref="member">Extending All DCEL Records</ref>), where the resulting arrangement also extends it Dcel records with data fields computed on the basis of the overlapping Dcel features of the two input arrangements. </para></listitem>
</variablelist>
</para><para>In the following subsections we give some examples for the simple and the face-overlay operations and demonstrate how to use the auxiliary overlay traits-classes. For the full overlay operations users need to implement their specialized overlay traits-class, which models the <computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> concept. The details of this concept are given in the Reference Manual.</para><sect2 id="index_1arr_ssecsimp_ovl">
<title>Example for a Simple Overlay</title>
<para><anchor id="index_1fig__arr_figex_22"/><image type="html" name="ex_22.png"></image>
 <image type="latex" name="ex_22.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_22" kindref="member">fig__arr_figex_22</ref> Overlaying two simple arrangements of line segments, as done in <computeroutput>overlay.cpp</computeroutput> and <computeroutput>ex_face_extension_overlay.cpp</computeroutput>. In <computeroutput>face_extension_overlay.cpp</computeroutput> the two bounded faces are considered as <emphasis>marked</emphasis>, and the octagonal face which is the intersection of the two marked faces is denoted by <formula id="16">$ f_0$</formula>.  <linebreak/>
</para><para>The next program constructs two simple arrangements, as depicted in <ref refid="index_1fig__arr_figex_22" kindref="member">fig__arr_figex_22</ref> and computes their overlay:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2overlay_8cpp-example" kindref="compound">Arrangement_on_surface_2/overlay.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>A<sp/>simple<sp/>overlay<sp/>of<sp/>two<sp/>arrangements.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_overlay_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_default_overlay_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__default__overlay__traits" kindref="compound">CGAL::Arr_default_overlay_traits&lt;Arrangement_2&gt;</ref><sp/><sp/>Overlay_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>first<sp/>arrangement,<sp/>containing<sp/>a<sp/>square-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s1<sp/>(Point_2(2,<sp/>2),<sp/>Point_2(6,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s2<sp/>(Point_2(6,<sp/>2),<sp/>Point_2(6,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s3<sp/>(Point_2(6,<sp/>6),<sp/>Point_2(2,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s4<sp/>(Point_2(2,<sp/>6),<sp/>Point_2(2,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr1,<sp/>s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr1,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr1,<sp/>s4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>second<sp/>arrangement,<sp/>containing<sp/>a<sp/>rhombus-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>t1<sp/>(Point_2(4,<sp/>1),<sp/>Point_2(7,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>t2<sp/>(Point_2(7,<sp/>4),<sp/>Point_2(4,<sp/>7));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>t3<sp/>(Point_2(4,<sp/>7),<sp/>Point_2(1,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>t4<sp/>(Point_2(1,<sp/>4),<sp/>Point_2(4,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr2,<sp/>t1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr2,<sp/>t2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr2,<sp/>t3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr2,<sp/>t4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>overlay<sp/>of<sp/>the<sp/>two<sp/>arrangements.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>overlay_arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Overlay_traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>overlay_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">overlay</ref><sp/>(arr1,<sp/>arr2,<sp/>overlay_arr,<sp/>overlay_traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>size<sp/>of<sp/>the<sp/>overlaid<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>overlaid<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>overlay_arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>overlay_arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>overlay_arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssecface_ovl">
<title>Examples for a Face Overlay</title>
<para>The following example shows how to compute the intersection of two polygons using the <computeroutput><ref refid="group__PkgArrangement2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">overlay()</ref></computeroutput> function. It uses a face-extended Dcel class to define our arrangement class. The Dcel extends each face with a Boolean flag. A polygon is represented as a <emphasis>marked</emphasis> arrangement face, (whose flag is set). The example uses a face-overlay traits class, instantiated with a functor that simply performs a logical <emphasis>and</emphasis> operations on Boolean flags. As a result, a face in the overlaid arrangement is marked only when it corresponds to an overlapping region of two marked cells in the input arrangements. Namely, it is part of the intersection of the two polygons.</para><para>The example computes the intersection between a square and a rhombus, (which is actually also a square). The resulting polygon is an octagon, denoted by <formula id="16">$ f_0$</formula> in <ref refid="index_1fig__arr_figex_22" kindref="member">fig__arr_figex_22</ref> :</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2face_extension_overlay_8cpp-example" kindref="compound">Arrangement_on_surface_2/face_extension_overlay.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>A<sp/>face<sp/>overlay<sp/>of<sp/>two<sp/>arrangements<sp/>with<sp/>extended<sp/>face<sp/>records.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_overlay_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_default_overlay_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits_2, bool&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dcel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__face__overlay__traits" kindref="compound">CGAL::Arr_face_overlay_traits</ref>&lt;Arrangement_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::logical_and&lt;bool&gt;<sp/>&gt;<sp/><sp/>Overlay_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>first<sp/>arrangement,<sp/>containing<sp/>a<sp/>square-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s1<sp/>(Point_2(2,<sp/>2),<sp/>Point_2(6,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s2<sp/>(Point_2(6,<sp/>2),<sp/>Point_2(6,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s3<sp/>(Point_2(6,<sp/>6),<sp/>Point_2(2,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s4<sp/>(Point_2(2,<sp/>6),<sp/>Point_2(2,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr1,<sp/>s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr1,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr1,<sp/>s4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Mark<sp/>just<sp/>the<sp/>bounded<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1aa91e8147cf0a7cc30366af5b6f9a058e" kindref="member">Arrangement_2::Face_iterator</ref><sp/><sp/><sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(arr1.number_of_faces()<sp/>==<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>arr1.faces_begin();<sp/>fit<sp/>!=<sp/>arr1.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data<sp/>(fit<sp/>!=<sp/>arr1.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>second<sp/>arrangement,<sp/>containing<sp/>a<sp/>rhombus-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>t1<sp/>(Point_2(4,<sp/>1),<sp/>Point_2(7,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>t2<sp/>(Point_2(7,<sp/>4),<sp/>Point_2(4,<sp/>7));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>t3<sp/>(Point_2(4,<sp/>7),<sp/>Point_2(1,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>t4<sp/>(Point_2(1,<sp/>4),<sp/>Point_2(4,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr2,<sp/>t1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr2,<sp/>t2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr2,<sp/>t3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr2,<sp/>t4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Mark<sp/>just<sp/>the<sp/>bounded<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(arr2.number_of_faces()<sp/>==<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>arr2.faces_begin();<sp/>fit<sp/>!=<sp/>arr2.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data<sp/>(fit<sp/>!=<sp/>arr2.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>overlay<sp/>of<sp/>the<sp/>two<sp/>arrangements,<sp/>marking<sp/>only<sp/>the<sp/>faces<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>are<sp/>intersections<sp/>of<sp/>two<sp/>marked<sp/>faces<sp/>in<sp/>arr1<sp/>and<sp/>arr2,<sp/>respectively.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>overlay_arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Overlay_traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>overlay_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">overlay</ref><sp/>(arr1,<sp/>arr2,<sp/>overlay_arr,<sp/>overlay_traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>the<sp/>faces<sp/>of<sp/>the<sp/>overlaid<sp/>arrangement<sp/>and<sp/>print<sp/>just<sp/>the<sp/>marked</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>ones.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1ab4a594c193ca09a672dbe2fcafa090e9" kindref="member">Arrangement_2::Ccb_halfedge_circulator</ref><sp/><sp/><sp/><sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>union<sp/>is:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>overlay_arr.faces_begin();<sp/>fit<sp/>!=<sp/>overlay_arr.faces_end();<sp/>++fit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>fit-&gt;data())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>curr<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>curr-&gt;source()-&gt;point();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>--&gt;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>curr-&gt;target()-&gt;point();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(curr<sp/>!=<sp/>fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The next example demonstrates the face overlay of two arrangements that have unbounded faces as well. The first arrangement is formed by the two lines <formula id="86">$ y = x$</formula> and <formula id="87">$ y = -x$</formula>, that subdivide the plane into four unbounded faces, denoted <formula id="223">$ A$</formula>, <formula id="193">$ B$</formula>, <formula id="3">$ C$</formula> and <formula id="224">$ D$</formula>. The second arrangement comprises four line segments that form a square-shaped face. When we overlay the two arrangements, each of the four faces <formula id="223">$ A$</formula>, <formula id="193">$ B$</formula>, <formula id="3">$ C$</formula> and <formula id="224">$ D$</formula> is split into an unbounded face (indexed 1) and a bounded face (indexed 2):</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2overlay_unbounded_8cpp-example" kindref="compound">Arrangement_on_surface_2/overlay_unbounded.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>A<sp/>face<sp/>overlay<sp/>of<sp/>two<sp/>arrangements<sp/>with<sp/>unbounded<sp/>faces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/lexical_cast.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_linear_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_overlay_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_default_overlay_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>functor<sp/>for<sp/>creating<sp/>a<sp/>label<sp/>from<sp/>a<sp/>character<sp/>and<sp/>an<sp/>integer.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Overlay_label</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>operator()<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>boost::lexical_cast&lt;std::string&gt;(c)<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>boost::lexical_cast&lt;std::string&gt;(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Ray_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ray_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Line_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Line_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X_monotone_curves_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits_2, char&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DcelA;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2, DcelA&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ArrangementA_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits_2, int&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DcelB;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2, DcelB&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ArrangementB_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits_2, std::string&gt;</ref><sp/>DcelRes;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2, DcelRes&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ArrangementRes_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__face__overlay__traits" kindref="compound">CGAL::Arr_face_overlay_traits</ref>&lt;ArrangementA_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ArrangementB_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ArrangementRes_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Overlay_label&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Overlay_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>first<sp/>arrangement,<sp/>induced<sp/>by<sp/>two<sp/>line<sp/>y<sp/>=<sp/>x<sp/>and<sp/>y<sp/>=<sp/>-x.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ArrangementA_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr1,<sp/>Line_2<sp/>(Point_2(0,<sp/>0),<sp/>Point_2(1,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr1,<sp/>Line_2<sp/>(Point_2(0,<sp/>0),<sp/>Point_2(1,<sp/>-1)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Label<sp/>the<sp/>four<sp/>(unbounded)<sp/>face<sp/>of<sp/>the<sp/>arrangement<sp/>as<sp/>&apos;A&apos;<sp/>to<sp/>&apos;D&apos;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>do<sp/>so<sp/>by<sp/>traversing<sp/>the<sp/>incident<sp/>faces<sp/>to<sp/>the<sp/>halfedges<sp/>around<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>single<sp/>arrangement<sp/>vertex<sp/>(0,<sp/>0).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(arr1.number_of_vertices()<sp/>==<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ArrangementA_2::Halfedge_around_vertex_circulator<sp/><sp/>first,<sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clabel<sp/>=<sp/></highlight><highlight class="charliteral">&apos;A&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curr<sp/>=<sp/>first<sp/>=<sp/>arr1.vertices_begin()-&gt;incident_halfedges();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>curr-&gt;face()-&gt;set_data<sp/>(clabel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++clabel;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(curr<sp/>!=<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>with<sp/>arr1.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>second<sp/>arrangement,<sp/>containing<sp/>a<sp/>single<sp/>square-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ArrangementB_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr2,<sp/>Segment_2<sp/>(Point_2(-4,<sp/>-4),<sp/>Point_2(4,<sp/>-4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr2,<sp/>Segment_2<sp/>(Point_2(4,<sp/>-4),<sp/>Point_2(4,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr2,<sp/>Segment_2<sp/>(Point_2(4,<sp/>4),<sp/>Point_2(-4,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr2,<sp/>Segment_2<sp/>(Point_2(-4,<sp/>4),<sp/>Point_2(-4,<sp/>-4)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Give<sp/>the<sp/>unbounded<sp/>face<sp/>the<sp/>index<sp/>1,<sp/>and<sp/>the<sp/>bounded<sp/>face<sp/>the<sp/>index<sp/>2.<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(arr2.number_of_faces()<sp/>==<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ArrangementB_2::Face_iterator<sp/><sp/><sp/><sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>arr2.faces_begin();<sp/>fit<sp/>!=<sp/>arr2.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data<sp/>((fit<sp/>==<sp/>arr2.unbounded_face())<sp/>?<sp/>1<sp/>:<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>with<sp/>arr2.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>overlay<sp/>of<sp/>the<sp/>two<sp/>arrangements.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ArrangementRes_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>overlay_arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Overlay_traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>overlay_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">overlay</ref><sp/>(arr1,<sp/>arr2,<sp/>overlay_arr,<sp/>overlay_traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>the<sp/>faces<sp/>of<sp/>the<sp/>overlaid<sp/>arrangement<sp/>and<sp/>their<sp/>labels.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ArrangementRes_2::Face_iterator<sp/><sp/>res_fit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>overlay<sp/>faces<sp/>are:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(res_fit<sp/>=<sp/>overlay_arr.faces_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_fit<sp/>!=<sp/>overlay_arr.faces_end();<sp/>++res_fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>res_fit-&gt;data()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>(res_fit-&gt;is_unbounded()<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;unbounded&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;bounded&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;).&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1arr_secarr_with_hist">
<title>Storing the Curve History</title>
<para>As stated at the beginning of this chapter (Section <ref refid="index_1arr_secintro" kindref="member">Introduction</ref>), when one constructs an arrangement induced by a set <formula id="0">$ \cal C$</formula> of arbitrary planar curves, she or he constructs a collection <formula id="10">$ \cal C&apos;&apos;$</formula> of <formula id="2">$ x$</formula>-monotone subcurves of <formula id="0">$ \cal C$</formula> that are pairwise disjoint in their interior, and these subcurves are associated with the arrangement edges (more precisely, with the Dcel halfedges). Doing so, the connection between the originating input curves and the arrangement edges is lost. This loss might be acceptable for some applications. However, in many practical cases it is important to determine the input curves that give rise to the final subcurves.</para><para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class-template extends the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class by keeping an additional container of input curves representing <formula id="0">$ \cal C$</formula>, and by maintaining a cross-mapping between these curves and the arrangement edges they induce. The traits class that is used for instantiating the template should be a model of the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept (see Section <ref refid="index_1arr_sssecinsert_gen" kindref="member">Inserting General Curves</ref>). That is, it should define the <computeroutput>Curve_2</computeroutput> type (and not just the <computeroutput>X_monotone_curve_2</computeroutput> type). The <computeroutput>Dcel</computeroutput> parameter should model the <computeroutput><ref refid="classArrangementDcel" kindref="compound">ArrangementDcel</ref></computeroutput> concept. Users can use the default Dcel class or an extended Dcel class according to their needs.</para><sect2 id="index_1arr_ssecarrwh_traverse">
<title>Traversing an Arrangement with History</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> class extends the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class, thus all the iterator and circulator types that are defined by the arrangement class are also available in <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput>. The reader is referred to Section <ref refid="index_1arr_ssectraverse" kindref="member">Traversing the Arrangement</ref> for a comprehensive review of these functions.</para><para>As mentioned above, the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> class maintains a container of input curves, which can be accessed using curve handles. The member function <computeroutput>number_of_curves()</computeroutput> returns the number of input curves stored in the container, while <computeroutput>curves_begin()</computeroutput> and <computeroutput>curves_end()</computeroutput> return <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2_1a1107ce3eaa58fe48844af22d430f70fd" kindref="member">Arrangement_with_history_2::Curve_iterator</ref></computeroutput> objects that define the valid range of curves that induce the arrangement. The value type of this iterator is <computeroutput>Curve_2</computeroutput>. Moreover, the curve-iterator type is equivalent to <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2_1a0f91465846104329a0a99090b0d7f3f6" kindref="member">Arrangement_with_history_2::Curve_handle</ref></computeroutput>, which is used for accessing the stored curves. Conveniently, the corresponding constant-iterator and constant-handle types are also defined.</para><para>As mentioned in the previous paragraph, a <computeroutput>Curve_handle</computeroutput> object <computeroutput>ch</computeroutput> serves as a pointer to a curve stored in an arrangement-with-history instance <computeroutput>arr</computeroutput>. Using this handle, it is possible to obtain the number of arrangement edges this curve induces by calling <computeroutput>arr.number_of_induced_edges(ch)</computeroutput>. The functions <computeroutput>arr.induced_edges_begin(ch)</computeroutput> and <computeroutput>arr.induced_edges_end(ch)</computeroutput> return iterators of type <computeroutput>Arrangement_with_history_2::Induced_edges_iterator</computeroutput> that define the valid range of edges induced by <computeroutput>ch</computeroutput>. The value type of these iterators is <computeroutput>Halfedge_handle</computeroutput>. It is thus possible to traverse all arrangement edges induced by an input curve.</para><para>It is also important to be able to perform the inverse mapping. Given an arrangement edge, we would like to be able to determine which input curve induces it. In case the edge represents an overlap of several curves, we should be able to trace all input curves that overlap over this edge. The <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> class is extended by several member functions that enable such an inverse mapping. Given a halfedge handle <computeroutput>e</computeroutput> in an arrangement with history <computeroutput>arr</computeroutput>, then <computeroutput>arr.number_of_originating_curves(e)</computeroutput> returns the number of curves that induce the edge (which should be 1 in non-degenerate cases, and 2 or more in case of overlaps), while <computeroutput>arr.originating_curves_begin(e)</computeroutput> and <computeroutput>arr.originating_curves_end(e)</computeroutput> return <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2_1aed5c031ddfa2bbd690ff0d08c8835131" kindref="member">Arrangement_with_history_2::Originating_curve_iterator</ref></computeroutput> objects that define the range of curves that induce <computeroutput>e</computeroutput>. The value type of these iterator is <computeroutput>Curve_2</computeroutput>.</para><para>It is possible to overlay two <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> instances instantiated by the same traits class. In this case, the resulting arrangement will store a consolidated container of input curves, and automatically preserve the cross-mapping between the arrangement edges and the consolidated curve set. Users can employ an overlay-traits class to maintain any type of auxiliary data stored with the Dcel features (see Section <ref refid="index_1arr_secoverlay" kindref="member">Overlaying Arrangements</ref>).</para></sect2>
<sect2 id="index_1arr_ssecmodif_traverse">
<title>Modifying an Arrangement with History</title>
<para>As the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> class extends the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class, it inherits the fundamental modification operations, such as <computeroutput>assign()</computeroutput> and <computeroutput><ref refid="group__PkgBGLHelperFct_1ga4d3b9bb446f55fd37206eeba9d582296" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">clear()</ref></computeroutput>, from it. The vertex-manipulation functions are also inherited and supported (see Sections <ref refid="index_1arr_sssecmf_iso_verts" kindref="member">Manipulating Isolated Vertices</ref> and <ref refid="index_1arr_sssecinsert_point" kindref="member">Inserting Points</ref> for the details). However, there are some fundamental differences between the interfaces of the two classes, which we highlight in this subsection.</para><para>The most significant difference between the arrangement-with-history class and the basic arrangement class is the way they handle their input curves. <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> always stores the <computeroutput>Curve_2</computeroutput> objects that induce it, thus it is impossible to insert <formula id="2">$ x$</formula>-monotone curves into an arrangement with history. The free <computeroutput><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve()</ref></computeroutput> and <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> that receives <formula id="2">$ x$</formula>-monotone curve (as well as their aggregated versions) are therefore not available for arrangement-with-history instances and only the free <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> and <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> functions that receive <computeroutput>Curve_2</computeroutput> (the incremental insertion function and the aggregated insertion function) are supported - see also Section <ref refid="index_1arr_sssecinsert_gen" kindref="member">Inserting General Curves</ref>. Notice however that while the incremental insertion function <computeroutput>insert(arr,c)</computeroutput> for an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> object <computeroutput>arr</computeroutput> does not have a return value, the corresponding arrangement-with-history function returns a <computeroutput>Curve_handle</computeroutput> to the inserted curve.</para><para>As we are able to keep track of all edges induced by an input curve, we also provide a free function that removes a curve from an arrangement. By calling <computeroutput>remove(arr,ch)</computeroutput>, where <computeroutput>ch</computeroutput> is a valid curve handle, the given curve is deleted from the curve container, and all edges induced solely by this curve (i.e., excluding overlapping edges) are removed from the arrangement. The function returns the number of edges that have been removed.</para><para>In some cases, users may need to operate directly on the arrangement edges. We first mention that the specialized insertion functions (see Section <ref refid="index_1arr_sssecmf_insert_cv" kindref="member">Inserting Non-Intersecting x-Monotone Curves</ref>) are not supported, as they accept <formula id="2">$ x$</formula>-monotone curves. Insertion can only be performed via the free insertion-functions. The other edge-manipulation functions (see Section <ref refid="index_1arr_sssecmf_halfedges" kindref="member">Manipulating Halfedges</ref>) are however available, but have a different interface that does not use <formula id="2">$ x$</formula>-monotone curves: <itemizedlist>
<listitem>
<para>Invoking <computeroutput>split_edge(e,p)</computeroutput> splits the edge <computeroutput>e</computeroutput> at a given point <computeroutput>p</computeroutput> that lies in its interior. </para></listitem>
<listitem>
<para>Invoking <computeroutput>merge_edge(e1,e2)</computeroutput> merges the two given edges. There is a precondition that <computeroutput>e1</computeroutput> and <computeroutput>e2</computeroutput> shared a common end-vertex of degree 2, and that the <formula id="2">$ x$</formula>-monotone subcurves associated with these edges are mergeable. </para></listitem>
<listitem>
<para>It is possible to remove an edge by simply invoking <computeroutput>remove_edge(e)</computeroutput>. </para></listitem>
</itemizedlist>
In all cases, the maintenance of cross-pointers for the appropriate input curves will be done automatically.</para><para>It should be noted that it is possible to attach observers to an arrangement-with-history instance in order to get detailed notifications of the changes the arrangements undergoes (see Section <ref refid="index_1arr_secnotif" kindref="member">The Notification Mechanism</ref> for the details).</para></sect2>
<sect2 id="index_1arr_ssecarr_hist_ex">
<title>Examples</title>
<para><anchor id="index_1fig__arr_figex_24"/><image type="html" name="ex_24.png"></image>
 <image type="latex" name="ex_24.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_24" kindref="member">fig__arr_figex_24</ref> An arrangement with history as constructed in <computeroutput>curve_history.cpp</computeroutput>. Note that <formula id="74">$ s_1$</formula> and <formula id="225">$ s_3$</formula> overlap over two edges. The point-location query points are drawn as lightly shaded dots.  <linebreak/>
</para><para>In the following example we construct a simple arrangement of six line segments, as depicted in <ref refid="index_1fig__arr_figex_24" kindref="member">fig__arr_figex_24</ref>, while maintaining the curve history. The example demonstrates the usage of the special traversal functions. It also shows how to issue point-location queries on the resulting arrangement, using the auxiliary function <computeroutput>locate_point()</computeroutput> defined in the header file <computeroutput>point_location_utils.h</computeroutput>; see also Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2curve_history_8cpp-example" kindref="compound">Arrangement_on_surface_2/curve_history.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>with<sp/>curve<sp/>history.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_on_surface_with_history_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_with_history_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_simple_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;point_location_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">CGAL::Arrangement_with_history_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arr_with_hist_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arr_with_hist_2::Curve_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Curve_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Arr_simple_point_location&lt;Arr_with_hist_2&gt;<sp/><sp/>Point_location;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist_2<sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>s1,<sp/>s2<sp/>and<sp/>s3<sp/>incrementally:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/>s1(Point_2(0,<sp/>3),<sp/>Point_2(4,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/>s2(Point_2(3,<sp/>2),<sp/>Point_2(3,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/>s3(Point_2(2,<sp/>3),<sp/>Point_2(5,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>three<sp/>additional<sp/>segments<sp/>aggregately:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/>segs[3];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[0]<sp/>=<sp/>Segment_2(Point_2(2,<sp/>6),<sp/>Point_2(7,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[1]<sp/>=<sp/>Segment_2(Point_2(0,<sp/>0),<sp/>Point_2(2,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[2]<sp/>=<sp/>Segment_2(Point_2(3,<sp/>4),<sp/>Point_2(6,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>segs,<sp/>segs<sp/>+<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>out<sp/>the<sp/>curves<sp/>and<sp/>the<sp/>number<sp/>of<sp/>edges<sp/>each<sp/>one<sp/>induces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist_2::Curve_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>contains<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr.number_of_curves()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>curves:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(cit<sp/>=<sp/>arr.curves_begin();<sp/>cit<sp/>!=<sp/>arr.curves_end();<sp/>++cit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Curve<sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*cit<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/>induces<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr.number_of_induced_edges(cit)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>edges.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>edges,<sp/>along<sp/>with<sp/>the<sp/>list<sp/>of<sp/>curves<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>induce<sp/>each<sp/>edge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist_2::Edge_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>eit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist_2::Originating_curve_iterator<sp/><sp/><sp/><sp/><sp/>ocit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>is<sp/>comprised<sp/>of<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>edges:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;].<sp/>Originating<sp/>curves:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(ocit<sp/>=<sp/>arr.originating_curves_begin(eit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ocit<sp/>!=<sp/>arr.originating_curves_end(eit);<sp/>++ocit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*ocit<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::flush;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>some<sp/>point-location<sp/>queries:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_location<sp/><sp/><sp/>pl(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p1(4,<sp/>6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>point_location_query(pl,<sp/>p1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p2(6,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>point_location_query(pl,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p3(2,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>point_location_query(pl,<sp/>p3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__arr_figex_25"/><image type="html" name="ex_25.png"></image>
 <image type="latex" name="ex_25.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_25" kindref="member">fig__arr_figex_25</ref> An arrangement with history of nine circle as constructed in <computeroutput>edge_manipulation_curve_history.cpp</computeroutput>. Note the vertical tangency points of <formula id="226">$ C_0$</formula>, marked as dark dots, which subdivide this circle into an upper half and a lower half, each consists of 9 edges. The large circle <formula id="226">$ C_0$</formula> is eventually removed from the arrangement, with all 18 edges it induces.  <linebreak/>
</para><para>The following example demonstrates the usage of the free <computeroutput>remove()</computeroutput> function. We construct an arrangement of nine circles, while keeping a handle to each inserted circle. We then remove the large circle <formula id="226">$ C_0$</formula>, which induces <formula id="227">$ 18$</formula> edges, as depicted in <ref refid="index_1fig__arr_figex_25" kindref="member">fig__arr_figex_25</ref>. The example also shows how to use the <computeroutput><ref refid="group__PkgBGLEulerOperations_1ga8a7629a2a0659ca059081eae8cedca3d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">split_edge()</ref></computeroutput> and <computeroutput>merge_edge()</computeroutput> functions when operating on an arrangement-with-history instance:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2edge_manipulation_curve_history_8cpp-example" kindref="compound">Arrangement_on_surface_2/edge_manipulation_curve_history.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Removing<sp/>curves<sp/>and<sp/>manipulating<sp/>edges<sp/>in<sp/>an<sp/>arrangement<sp/>with<sp/>history.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_circle_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_with_history_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Circle__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Circle_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Circle_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">CGAL::Arr_circle_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">CGAL::Arrangement_with_history_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/>Arr_with_hist_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arr_with_hist_2::Curve_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Curve_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">CGAL::Arr_walk_along_line_point_location&lt;Arr_with_hist_2&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_location;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>containing<sp/>nine<sp/>circles:<sp/>C[0]<sp/>of<sp/>radius<sp/>2<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>C[1],<sp/>...,<sp/>C[8]<sp/>of<sp/>radius<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Exact_rational</ref><sp/>_7_halves<sp/>=<sp/><ref refid="group__nt__cgal_1ga0849ff44771b19582218ebdfa5614f64" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Exact_rational</ref>(7,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist_2<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve_2<sp/>C[9];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve_handle<sp/>handles[9];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[0]<sp/>=<sp/>Circle_2(Rat_point_2(_7_halves,<sp/>_7_halves),<sp/>4,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[1]<sp/>=<sp/>Circle_2(Rat_point_2(_7_halves,<sp/>6),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[2]<sp/>=<sp/>Circle_2(Rat_point_2(5,<sp/>6),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[3]<sp/>=<sp/>Circle_2(Rat_point_2(6,<sp/>_7_halves),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[4]<sp/>=<sp/>Circle_2(Rat_point_2(5,<sp/>2),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[5]<sp/>=<sp/>Circle_2(Rat_point_2(_7_halves,<sp/>1),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[6]<sp/>=<sp/>Circle_2(Rat_point_2(2,<sp/>2),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[7]<sp/>=<sp/>Circle_2(Rat_point_2(1,<sp/>_7_halves),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[8]<sp/>=<sp/>Circle_2(Rat_point_2(2,<sp/>5),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>9;<sp/>k++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>handles[k]<sp/>=<sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>C[k]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>initial<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>the<sp/>large<sp/>circle<sp/>C[0].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Removing<sp/>C[0]<sp/>:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/><ref refid="group__PkgArrangement2Funcs_1ga9a27533ff4ade0c60978812e517b89d9" kindref="member">remove_curve</ref>(arr,<sp/>handles[0])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>edges<sp/>have<sp/>been<sp/>removed.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Locate<sp/>the<sp/>point<sp/>q,<sp/>which<sp/>should<sp/>be<sp/>on<sp/>an<sp/>edge<sp/>e.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_location<sp/>pl(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_2<sp/>q<sp/>=<sp/>Point_2(_7_halves,<sp/>7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_location::result_type<sp/>obj<sp/>=<sp/>pl.locate(q);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist_2::Halfedge_const_handle<sp/><sp/>e;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion_code(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>success<sp/>=<sp/>)<sp/><ref refid="namespaceCGAL" kindref="compound">CGAL</ref>::assign(e,<sp/>obj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(success);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Split<sp/>the<sp/>edge<sp/>e<sp/>to<sp/>two<sp/>edges<sp/>e1<sp/>and<sp/>e2;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist_2::Halfedge_handle<sp/>e1,<sp/>e2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>e1<sp/>=<sp/>arr.<ref refid="group__PkgBGLEulerOperations_1ga8a7629a2a0659ca059081eae8cedca3d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">split_edge</ref>(arr.non_const_handle(e),<sp/>q);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>e2<sp/>=<sp/>e1-&gt;next();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacestd" kindref="compound">std</ref>::cout<sp/>&lt;&lt;<sp/>&quot;After<sp/>edge<sp/>split:<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;V<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/><ref refid="namespacestd" kindref="compound">std</ref>::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Merge<sp/>back<sp/>the<sp/>two<sp/>split<sp/>edges.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.merge_edge(e1,<sp/>e2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacestd" kindref="compound">std</ref>::cout<sp/>&lt;&lt;<sp/>&quot;After<sp/>edge<sp/>merge:<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;V<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/><ref refid="namespacestd" kindref="compound">std</ref>::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1arr_secio">
<title>Input/Output Streams</title>
<para>In some cases, one would like to save an arrangement object constructed by some application, so that later on it can be restored. In other cases one would like to create nice drawings that represent arrangements constructed by some application. These drawings can be hard printed or displayed on a computer screen.</para><sect2 id="index_1arr_ssecio_stream">
<title>Input/Output Stream</title>
<para>Consider an arrangement that represents a very complicated geographical map, and assume that there are various applications that need to answer point-location queries on this map. Naturally, you can store the set of curves that induces the arrangement, but this implies that you would need to construct the arrangement from scratch each time you need to reuse it. A more efficient solution is to write the arrangement to a file in a format that other applications can read.</para><para>This package provides an <emphasis>inserter</emphasis> (the <computeroutput>&lt;&lt;</computeroutput> operator) and an <emphasis>extractor</emphasis> (the <computeroutput>&gt;&gt;</computeroutput> operator) for the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class that inserts and an arrangement object into an output stream and extracts an arrangement object from an input stream respectively. The arrangement is written using a simple predefined ASCII format that encodes the arrangement topology, as well as all geometric entities associated with vertices and edges.</para><para>The ability to use the input/output operators, requires that the <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> type and the <computeroutput>X_monotone_curve_2</computeroutput> type defined by the traits class both support the <computeroutput>&lt;&lt;</computeroutput> and <computeroutput>&gt;&gt;</computeroutput> operators. The <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">Arr_conic_traits_2</ref></computeroutput> class (see Section <ref refid="index_1arr_ssectr_conic" kindref="member">A Traits Class for Conic Arcs</ref>), the <computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">Arr_rational_function_traits_2</ref></computeroutput> class (see Section <ref refid="index_1arr_ssectr_ratfunc" kindref="member">A Traits Class for Arcs of Rational Functions</ref>), and the <computeroutput><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">Arr_linear_traits_2</ref></computeroutput> class (see Section <ref refid="index_1arr_ssectr_segs" kindref="member">Traits Classes for Line Segments and Linear Objects</ref>) currently do not provide these operators for the geometric types they define. Thus, only arrangements of line segments or of polylines can be written or read.</para><para>The following example constructs the arrangement depicted in <ref refid="index_1fig__arr_figex_5" kindref="member">fig__arr_figex_5</ref> and writes it to an output file. It also demonstrates how to re-read the arrangement from a file:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2io_8cpp-example" kindref="compound">Arrangement_on_surface_2/io.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Using<sp/>the<sp/>arrangement<sp/>I/O<sp/>operators.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Arr_iostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;point_location_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_segments_arr<sp/>(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Writing<sp/>an<sp/>arrangement<sp/>of<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>the<sp/>arrangement<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/><sp/><sp/><sp/>out_file<sp/>(</highlight><highlight class="stringliteral">&quot;arr_ex_io.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out_file<sp/>&lt;&lt;<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>arrangement<sp/>from<sp/>the<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/><sp/><sp/><sp/>in_file<sp/>(</highlight><highlight class="stringliteral">&quot;arr_ex_io.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Read<sp/>an<sp/>arrangement<sp/>of<sp/>size:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr2.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr2.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr2.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssecarr_io_aux_data">
<title>Arrangements with Auxiliary Data</title>
<para></para><para>The inserter and extractor both ignore any auxiliary data stored with the arrangement features. Thus, they are ideal for arrangements instantiated using the <computeroutput><ref refid="classCGAL_1_1Arr__default__dcel" kindref="compound">Arr_default_dcel</ref></computeroutput> class. However, as explained in Section <ref refid="index_1arr_secex_dcel" kindref="member">Extending the DCEL</ref>, one can easily extend the arrangement faces by using the <computeroutput><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">Arr_face_extended_dcel</ref></computeroutput> template, or extend all Dcel records by using the <computeroutput><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">Arr_extended_dcel</ref></computeroutput> template. In such cases, it might be crucial that the auxiliary data fields are written to the file and read from there.</para><para>The arrangement package includes the free functions <computeroutput>write(arr, os, formatter)</computeroutput>, which writes the arrangement <computeroutput>arr</computeroutput> to an output stream <computeroutput>os</computeroutput>, and <computeroutput>read(arr, os, formatter)</computeroutput>, which reads the arrangement <computeroutput>arr</computeroutput> from an input stream <computeroutput>is</computeroutput>. Both operations are performed using a <computeroutput>formatter</computeroutput> object, which defines the I/O format. The package contains three formatter classes: <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__text__formatter" kindref="compound">Arr_text_formatter</ref>&lt;Arrangement&gt;</computeroutput> defines a simple textual I/O format for the arrangement topology and geometry, disregarding any auxiliary data that may be associated with the arrangement features. This is the default formatter used by the arrangement inserter and the arrangement extractor, as defined above. </para></listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__face__extended__text__formatter" kindref="compound">Arr_face_extended_text_formatter</ref>&lt;Arrangement&gt;</computeroutput> operates on arrangements whose Dcel representation is based on the <computeroutput><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">Arr_face_extended_dcel</ref>&lt;Traits,FaceData&gt;</computeroutput> class (see Section <ref refid="index_1arr_ssecex_dcel_face" kindref="member">Extending the DCEL Faces</ref>). It supports reading and writing the auxiliary data objects stored with the arrangement faces provided that the <computeroutput>FaceData</computeroutput> class supports an inserter and an extractor. </para></listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__extended__dcel__text__formatter" kindref="compound">Arr_extended_dcel_text_formatter</ref>&lt;Arrangement&gt;</computeroutput> operates on arrangements whose Dcel representation is based on the <computeroutput><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">Arr_extended_dcel</ref>&lt;Traits,VertexData,HalfedgeData,FaceData&gt;</computeroutput> class (see Section <ref refid="index_1arr_ssecex_dcel_all" kindref="member">Extending All DCEL Records</ref>). It supports reading and writing the auxiliary data objects stored with the arrangement vertices, edges and faces, provided that the <computeroutput>VertexData</computeroutput>, <computeroutput>HalfedgeData</computeroutput> and <computeroutput>FaceData</computeroutput> classed all have inserters and extractors. </para></listitem>
</itemizedlist>
</para><para>The following example constructs the same arrangement as the example <computeroutput>dcel_extension</computeroutput> does (see Section <ref refid="index_1arr_ssecex_dcel_all" kindref="member">Extending All DCEL Records</ref>), depicted in <ref refid="index_1fig__arr_figex_20" kindref="member">fig__arr_figex_20</ref>, and writes it to an output file. It also demonstrates how to re-read the arrangement from a file:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2dcel_extension_io_8cpp-example" kindref="compound">Arrangement_on_surface_2/dcel_extension_io.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Using<sp/>the<sp/>I/O<sp/>operators<sp/>for<sp/>arrangements<sp/>with<sp/>extended<sp/>DCEL<sp/>records.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Arr_text_formatter.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Arr_iostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>Color<sp/>{BLUE,<sp/>RED,<sp/>WHITE};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::ostream&amp;<sp/><ref refid="group__IOstreamOperators_1ga525f8afc1fb75eb966517c447f1968ea" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">operator&lt;&lt; </ref>(std::ostream&amp;<sp/>os,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Color&amp;<sp/>color)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(color)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>BLUE:<sp/><sp/>os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;BLUE&quot;</highlight><highlight class="normal">;<sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>RED:<sp/><sp/><sp/>os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;RED&quot;</highlight><highlight class="normal">;<sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>WHITE:<sp/>os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;WHITE&quot;</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:<sp/>os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ERROR!&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(os);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::istream&amp;<sp/><ref refid="group__IOstreamOperators_1gae89c813a0404eae7e0901ed8f3c92915" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Stream_support.tag">operator&gt;&gt; </ref>(std::istream&amp;<sp/>is,<sp/>Color&amp;<sp/>color)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/><sp/><sp/>str;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>is<sp/>&gt;&gt;<sp/>str;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(str<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;BLUE&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>color<sp/>=<sp/>BLUE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(str<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;RED&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>color<sp/>=<sp/>RED;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(str<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;WHITE&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>color<sp/>=<sp/>WHITE;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(is);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">CGAL::Arr_extended_dcel</ref>&lt;Traits_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Color,<sp/>bool,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dcel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__extended__dcel__text__formatter" kindref="compound">CGAL::Arr_extended_dcel_text_formatter&lt;Arrangement_2&gt;</ref><sp/><sp/>Formatter;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>containing<sp/>two<sp/>intersecting<sp/>triangles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s1<sp/>(Point_2(4,<sp/>1),<sp/>Point_2(7,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s2<sp/>(Point_2(1,<sp/>6),<sp/>Point_2(7,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s3<sp/>(Point_2(4,<sp/>1),<sp/>Point_2(1,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s4<sp/>(Point_2(1,<sp/>3),<sp/>Point_2(7,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s5<sp/>(Point_2(1,<sp/>3),<sp/>Point_2(4,<sp/>8));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/>s6<sp/>(Point_2(4,<sp/>8),<sp/>Point_2(7,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>s4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>s5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>s6);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>vertices<sp/>and<sp/>set<sp/>their<sp/>colors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1ac4a88fd2ca22b490454e4f425005e5c4" kindref="member">Arrangement_2::Vertex_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>degree;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>degree<sp/>=<sp/>vit-&gt;degree();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(degree<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>vit-&gt;set_data<sp/>(BLUE);<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Isolated<sp/>vertex.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(degree<sp/>&lt;=<sp/>2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>vit-&gt;set_data<sp/>(RED);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vertex<sp/>represents<sp/>an<sp/>endpoint.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>vit-&gt;set_data<sp/>(WHITE);<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vertex<sp/>represents<sp/>an<sp/>intersection<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>edges<sp/>and<sp/>set<sp/>their<sp/>flags.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1a9b3a4b116e66f66bcd69215fa3f513f9" kindref="member">Arrangement_2::Edge_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>eit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>flag;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>the<sp/>halfedge<sp/>has<sp/>the<sp/>same<sp/>direction<sp/>as<sp/>its<sp/>associated</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>segment.<sp/>Note<sp/>that<sp/>its<sp/>twin<sp/>always<sp/>has<sp/>an<sp/>opposite<sp/>direction.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>flag<sp/>=<sp/>(eit-&gt;source()-&gt;point()<sp/>==<sp/>eit-&gt;curve().source());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>eit-&gt;set_data<sp/>(flag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>eit-&gt;twin()-&gt;set_data<sp/>(!flag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>faces<sp/>and<sp/>print<sp/>their<sp/>outer<sp/>boundary<sp/>and<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1aa91e8147cf0a7cc30366af5b6f9a058e" kindref="member">Arrangement_2::Face_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1ab4a594c193ca09a672dbe2fcafa090e9" kindref="member">Arrangement_2::Ccb_halfedge_circulator</ref><sp/><sp/><sp/><sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boundary_size;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boundary_size<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>fit-&gt;is_unbounded())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>curr<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++boundary_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(curr<sp/>!=<sp/>fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data<sp/>(boundary_size);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>the<sp/>arrangement<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/><sp/><sp/><sp/>out_file<sp/>(</highlight><highlight class="stringliteral">&quot;arr_ex_dcel_io.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Formatter<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>formatter;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Write_1ga382f8dae407f5ddd50f33521781d84b9" kindref="member">write</ref><sp/>(arr,<sp/>out_file,<sp/>formatter);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>arrangement<sp/>from<sp/>the<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/><sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/><sp/><sp/><sp/>in_file<sp/>(</highlight><highlight class="stringliteral">&quot;arr_ex_dcel_io.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Read_1ga22c750c70c5384ef1561fbd6cd3bfaa8" kindref="member">read</ref><sp/>(arr2,<sp/>in_file,<sp/>formatter);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>vertices:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>arr2.vertices_begin();<sp/>vit<sp/>!=<sp/>arr2.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;(&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>-<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;data()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>You may develop your own own formatter classes - models of the <computeroutput><ref refid="classArrangementInputFormatter" kindref="compound">ArrangementInputFormatter</ref></computeroutput> and <computeroutput><ref refid="classArrangementOutputFormatter" kindref="compound">ArrangementOutputFormatter</ref></computeroutput> concepts, as defined in the Reference Manual. Doing so, you can define other I/O formats, such as an XML-based format or a binary format. </para></sect2>
<sect2 id="index_1arr_ssecarr_io_hist">
<title>Arrangements with Curve History</title>
<para>Section <ref refid="index_1arr_secarr_with_hist" kindref="member">Storing the Curve History</ref> introduces the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class, which saves the set of curves inducing an arrangement and maintains the relations between these curves and the edges they induce. Naturally, when reading or writing an arrangement-with-history instance we would like this information to be saved to the output stream or restored from the input stream alongside with the basic arrangement structure.</para><para>The arrangement package supplies an inserter and an extractor for the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class. The arrangement is represented using a simple predefined ASCII format. An object of the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt;Traits,Dcel&gt;</computeroutput> type can be saved and restored, as long as the <computeroutput>Curve_2</computeroutput> type defined by the traits class - as well as the <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput> type and the <computeroutput>X_monotone_curve_2</computeroutput> types - support the <computeroutput>&lt;&lt;</computeroutput> and<computeroutput>&gt;&gt;</computeroutput> operators.</para><para>The following example constructs the same arrangement as example <computeroutput>curve_history</computeroutput> does (see Section <ref refid="index_1arr_ssecarr_hist_ex" kindref="member">Examples</ref>), depicted in <ref refid="index_1fig__arr_figex_24" kindref="member">fig__arr_figex_24</ref>, and writes it to an output file. It also demonstrates how to re-read the arrangement-with-history from a file:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2io_curve_history_8cpp-example" kindref="compound">Arrangement_on_surface_2/io_curve_history.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Using<sp/>the<sp/>arrangement-with-history<sp/>I/O<sp/>operators.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_with_history_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Arr_with_history_iostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">CGAL::Arrangement_with_history_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/>Arr_with_hist_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist_2<sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>six<sp/>additional<sp/>segments<sp/>aggregately:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segs[6];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[0]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(2,<sp/>6),<sp/>Point_2<sp/>(7,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[1]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(3,<sp/>2),<sp/>Point_2<sp/>(3,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[2]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(2,<sp/>3),<sp/>Point_2<sp/>(5,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[3]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(2,<sp/>6),<sp/>Point_2<sp/>(7,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[4]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(0,<sp/>0),<sp/>Point_2<sp/>(2,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[5]<sp/>=<sp/>Segment_2<sp/>(Point_2<sp/>(3,<sp/>4),<sp/>Point_2<sp/>(6,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>segs,<sp/>segs<sp/>+<sp/>6);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Writing<sp/>an<sp/>arrangement<sp/>of<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr.number_of_curves()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>input<sp/>segments:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>the<sp/>arrangement<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/><sp/><sp/><sp/><sp/>out_file<sp/>(</highlight><highlight class="stringliteral">&quot;arr_ex_io_hist.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out_file<sp/>&lt;&lt;<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>arrangement<sp/>from<sp/>the<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist_2<sp/><sp/><sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/><sp/><sp/><sp/><sp/>in_file<sp/>(</highlight><highlight class="stringliteral">&quot;arr_ex_io_hist.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Read<sp/>an<sp/>arrangement<sp/>of<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr2.number_of_curves()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>input<sp/>segments:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr2.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr2.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr2.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para></para><para>The arrangement package also includes the free functions <computeroutput>write(arr, os, formatter)</computeroutput> and <computeroutput>read(arr, os, formatter)</computeroutput> that operate on a given arrangement-with-history instance <computeroutput>arr</computeroutput>. Both functions are parameterized by a <computeroutput>formatter</computeroutput> object, which define the I/O format. The package contains a template called, <computeroutput>Arr_with_hist_text_formatter&lt;ArranagmentFormatter&gt;</computeroutput>, which extends an arrangement formatter class (see Section <ref refid="index_1arr_ssecarr_io_aux_data" kindref="member">Arrangements with Auxiliary Data</ref>) and defines a simple textual input/output format. </para></sect2>
</sect1>
<sect1 id="index_1arr_secbgl">
<title>Adapting to Boost Graphs</title>
<para>BoostSee also Boost&apos;s homepage at: <computeroutput>www.boost.org</computeroutput>. is a collection of portable C++ libraries that extend the Standard Template Library (Stl). The Boost Graph Library (bgl), which one of the libraries in the collection, offers an extensive set of generic graph algorithms parameterized through templates. As our arrangements are embedded as planar graphs, it is only natural to extend the underlying data structure with the interface that the bgl expects, and gain the ability to perform the operations that the bgl supports, such as shortest-path computation. This section describes how apply the graph algorithms implemented in the bgl to <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> instances.</para><para>An instance of <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> is adapted to a Boost graph through the provision of a set of free functions that operate on the arrangement features and conform with the relevant BGL concepts. Besides the straightforward adaptation, which associates a vertex with each Dcel vertex and an edge with each Dcel halfedge, the package also offer a <emphasis>dual</emphasis> adaptor, which associates a graph vertex with each Dcel face, such that two vertices are connected, iff there is a Dcel halfedge that connects the two corresponding faces.</para><sect2 id="index_1arr_ssecbgl_primal">
<title>The Primal Arrangement Representation</title>
<para>Arrangement instances are adapted to Boost graphs by specializing the <ref refid="group__PkgBGLTraits_1BGLArgtGT" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag"><computeroutput>boost:graph_traits</computeroutput> </ref> template for <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> instances. The graph-traits states the graph concepts that the arrangement class models (see below) and defines the types required by these concepts.</para><para>In this specialization the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> vertices correspond to the graph vertices, where two vertices are adjacent if there is at least one halfedge connecting them. More precisely, <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a7dac3eed2224beadf3658495bc671c49" kindref="member">Arrangement_2::Vertex_handle</ref></computeroutput> is the graph-vertex type, while <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member">Arrangement_2::Halfedge_handle</ref></computeroutput> is the graph-edge type. As halfedges are directed, we consider the graph to be directed as well. Moreover, as several interior-disjoint <formula id="2">$ x$</formula>-monotone curves (say circular arcs) may share two common endpoints, inducing an arrangement with two vertices that are connected with several edges, we allow parallel edges in our Boost graph.</para><para>Given an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> instance, we can efficiently traverse its vertices and halfedges. Thus, the arrangement graph is a model of the concepts <computeroutput><ref refid="classVertexListGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">VertexListGraph</ref></computeroutput> and <computeroutput><ref refid="classEdgeListGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">EdgeListGraph</ref></computeroutput> introduced by the bgl. At the same time, we use an iterator adapter of the circulator over the halfedges incident to a vertex (<computeroutput>Halfedge_around_vertex_circulator</computeroutput> - see Section <ref refid="index_1arr_sssectr_vertex" kindref="member">Traversal Methods for an Arrangement Vertex</ref>), so it is possible to go over the ingoing and outgoing edges of a vertex in linear time. Thus, our arrangement graph is a model of the concept <computeroutput><ref refid="classBidirectionalGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">BidirectionalGraph</ref></computeroutput> (this concept refines <computeroutput><ref refid="classIncidenceGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">IncidenceGraph</ref></computeroutput>, which requires only the traversal of outgoing edges).</para><para>It is important to notice that the vertex descriptors we use are <computeroutput>Vertex_handle</computeroutput> objects and <emphasis>not</emphasis> vertex indices. However, in order to gain more efficiency in most bgl algorithm, it is better to have them indexed <formula id="228">$ 0, 1, \ldots, (n-1)$</formula>, where <formula id="197">$ n$</formula> is the number of vertices. We therefore introduce the <computeroutput><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound">Arr_vertex_index_map</ref>&lt;Arrangement&gt;</computeroutput> class-template, which maintains a mapping of vertex handles to indices, as required by the bgl. An instance of this class must be attached to a valid arrangement vertex when it is created. It uses the notification mechanism (see Section <ref refid="index_1arr_secnotif" kindref="member">The Notification Mechanism</ref>) to automatically maintain the mapping of vertices to indices, even when new vertices are inserted into the arrangement or existing vertices are removed.</para><para>In most algorithm provided by the bgl, the output is given by <emphasis>property maps</emphasis>, such that each map entry corresponds to a vertex. For example, when we compute the shortest paths from a given source vertex <formula id="85">$ s$</formula> to all other vertices we can obtain a map of distances and a map of predecessors - namely for each <formula id="14">$ v$</formula> vertex we have its distance from <formula id="85">$ s$</formula> and a descriptor of the vertex that precedes <formula id="14">$ v$</formula> in the shortest path from <formula id="85">$ s$</formula>.</para><para>If the vertex descriptors are simply indices, boost supplies tools to easily represent property maps using vectors. <computeroutput><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound">Arr_vertex_index_map</ref>&lt;Arrangement&gt;</computeroutput> class allows create such indices, and together with <computeroutput>boost::vector_property_map&lt;Type, IndexMap&gt;</computeroutput> allows for an efficient mapping of <computeroutput>Vertex_handle</computeroutput> objects to properties of type <computeroutput>Type</computeroutput>. Note however that unlike the <computeroutput><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound">Arr_vertex_index_map</ref></computeroutput> class, the vertex property-map class is not kept synchronized with the number of vertices in the arrangement, so it should not be reused in calls to bgl functions in case the arrangement is modified in between these calls.</para><para><anchor id="index_1fig__arr_figex_bgl"/><image type="html" name="ex_bgl.png"></image>
 <image type="latex" name="ex_bgl.png" width="15cm"></image>
  <ref refid="index_1fig__arr_figex_bgl" kindref="member">fig__arr_figex_bgl</ref> An arrangement of 7 line segments, as constructed by <computeroutput>bgl_primal_adapter.cpp</computeroutput> and <computeroutput>bgl_dual_adapter.cpp</computeroutput>. The breadth-first visit times for the arrangement faces, starting from the unbounded face <formula id="16">$ f_0$</formula>, are shown is brackets.  <linebreak/>
</para><para>In the following example we construct an arrangement of 7 line segments, as shown in <ref refid="index_1fig__arr_figex_bgl" kindref="member">fig__arr_figex_bgl</ref>, then use Dijkstra&apos;s shortest-paths algorithm from the bgl to compute the graph distance of all vertices from the leftmost vertex in the arrangement <formula id="229">$ v_0$</formula>. Note the usage of the <computeroutput>boost::vector_property_map&lt;Type, IndexMap&gt;</computeroutput> and the <computeroutput>Arr_vertex_property_map</computeroutput> classes. The latter one, instantiated by the type <computeroutput>double</computeroutput> is used to map vertices to their distances from <formula id="229">$ v_0$</formula>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2bgl_primal_adapter_8cpp-example" kindref="compound">Arrangement_on_surface_2/bgl_primal_adapter.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Adapting<sp/>an<sp/>arrangement<sp/>to<sp/>a<sp/>BGL<sp/>graph.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/graph_traits_Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_vertex_index_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound">CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arr_vertex_index_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>functor<sp/>used<sp/>to<sp/>compute<sp/>the<sp/>length<sp/>of<sp/>an<sp/>edge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Edge_length_func</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Boost<sp/>property<sp/>type<sp/>definitions:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::readable_property_map_tag<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>category;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>value_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member">Arrangement_2::Halfedge_handle</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>operator()(<ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member">Arrangement_2::Halfedge_handle</ref><sp/>e)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>x1<sp/>=<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref><sp/>(e-&gt;source()-&gt;point().x());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>y1<sp/>=<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref><sp/>(e-&gt;source()-&gt;point().y());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>x2<sp/>=<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref><sp/>(e-&gt;target()-&gt;point().x());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>y2<sp/>=<sp/><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref><sp/>(e-&gt;target()-&gt;point().y());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>diff_x<sp/>=<sp/>x2<sp/>-<sp/>x1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>diff_y<sp/>=<sp/>y2<sp/>-<sp/>y1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">std::sqrt</ref>(diff_x*diff_x<sp/>+<sp/>diff_y*diff_y);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(Edge_length_func<sp/>edge_length,<sp/><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member">Arrangement_2::Halfedge_handle</ref><sp/>e)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>edge_length(e);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/><sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>of<sp/>seven<sp/>intersecting<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>keep<sp/>a<sp/>handle<sp/>for<sp/>the<sp/>vertex<sp/>v_0<sp/>that<sp/>corresponds<sp/>to<sp/>the<sp/>point<sp/>(1,1).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member">Arrangement_2::Halfedge_handle</ref><sp/><sp/>e<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgArrangement2Funcs_1gad453feb3ff2f60a9741bf9d2917bf225" kindref="member">insert_non_intersecting_curve</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(1,<sp/>1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2<sp/>(7,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1a7dac3eed2224beadf3658495bc671c49" kindref="member">Arrangement_2::Vertex_handle</ref><sp/><sp/><sp/><sp/>v0<sp/>=<sp/>e-&gt;source();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(1,<sp/>1),<sp/>Point_2<sp/>(3,<sp/>7)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(1,<sp/>4),<sp/>Point_2<sp/>(7,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(2,<sp/>2),<sp/>Point_2<sp/>(9,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(2,<sp/>2),<sp/>Point_2<sp/>(4,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(7,<sp/>1),<sp/>Point_2<sp/>(9,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref><sp/>(arr,<sp/>Segment_2<sp/>(Point_2<sp/>(3,<sp/>7),<sp/>Point_2<sp/>(9,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>mapping<sp/>of<sp/>the<sp/>arrangement<sp/>vertices<sp/>to<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_vertex_index_map<sp/>index_map(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>Dijkstra&apos;s<sp/>algorithm<sp/>from<sp/>the<sp/>vertex<sp/>v0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Edge_length_func<sp/>edge_length;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::vector_property_map&lt;double,<sp/>Arr_vertex_index_map&gt;<sp/>dist_map(static_cast&lt;unsigned<sp/>int&gt;(arr.number_of_vertices()),<sp/>index_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::dijkstra_shortest_paths(arr,<sp/>v0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::vertex_index_map(index_map).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>weight_map(edge_length).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>distance_map(dist_map));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>results:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2_1ac4a88fd2ca22b490454e4f425005e5c4" kindref="member">Arrangement_2::Vertex_iterator</ref><sp/><sp/><sp/><sp/><sp/><sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>distances<sp/>of<sp/>the<sp/>arrangement<sp/>vertices<sp/>from<sp/>(&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>v0-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>at<sp/>distance<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>dist_map[vit]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1arr_ssecbgl_dual">
<title>The Dual Arrangement Representation</title>
<para>It is possible to give a dual graph representation for an arrangement instance, such that each arrangement face corresponds to a graph vertex and two vertices are adjacent iff the corresponding faces share a common edge on their boundaries. This is done by specializing the <computeroutput>boost:graph_traits</computeroutput> template for <computeroutput><ref refid="classCGAL_1_1Dual" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">Dual</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;</computeroutput> instances, where <computeroutput><ref refid="classCGAL_1_1Dual" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">Dual</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;</computeroutput> is a template specialization that gives a dual interpretation to an arrangement instance.</para><para>In dual representation, <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1ad64170c3b8b8c4af16a4fb742bf56d48" kindref="member">Arrangement_2::Face_handle</ref></computeroutput> is the graph-vertex type, while <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1acdb9c49c90f9354f20c56efac599a7fe" kindref="member">Arrangement_2::Halfedge_handle</ref></computeroutput> is the graph-edge type. We treat the graph edges as directed, such that a halfedge <computeroutput>e</computeroutput> is directed from <formula id="20">$ f_1$</formula>, which is its incident face, to <formula id="21">$ f_2$</formula>, which is the incident face of its twin halfedge. As two arrangement faces may share more than a single edge on their boundary, we allow parallel edges in our Boost graph. As is the case in the primal graph, the dual arrangement graph is also a model of the concepts <computeroutput><ref refid="classVertexListGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">VertexListGraph</ref></computeroutput>, <computeroutput><ref refid="classEdgeListGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">EdgeListGraph</ref></computeroutput> and <computeroutput><ref refid="classBidirectionalGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">BidirectionalGraph</ref></computeroutput> (thus also of <computeroutput><ref refid="classIncidenceGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">IncidenceGraph</ref></computeroutput>).</para><para>Since we use <computeroutput>Face_handle</computeroutput> objects as the vertex descriptors, we define the <computeroutput><ref refid="classCGAL_1_1Arr__face__index__map" kindref="compound">Arr_face_index_map</ref>&lt;Arrangement&gt;</computeroutput> class-template, which maintains an efficient mapping of face handles to indices. Like vertices, <computeroutput>boost::vector_property_map&lt;Type, IndexMap&gt;</computeroutput> can be used for associating arbitrary data with the arrangement faces.</para><para>In the following example we construct the same arrangement as in example <computeroutput>bgl_primal_adapter.cpp</computeroutput> (see <ref refid="index_1fig__arr_figex_bgl" kindref="member">fig__arr_figex_bgl</ref>), and perform breadth-first search on the graph faces, starting from the unbounded face. We extend the Dcel faces with an unsigned integer, marking the discover time of the face using <computeroutput>boost</computeroutput> visitors and a property-map class that directly accesses the extended data of the faces:</para><para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2bgl_dual_adapter_8cpp-example" kindref="compound">Arrangement_on_surface_2/bgl_dual_adapter.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Adapting<sp/>the<sp/>dual<sp/>of<sp/>an<sp/>arrangement<sp/>to<sp/>a<sp/>BGL<sp/>graph.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Exact__rational_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Exact_rational.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/graph_traits_dual_arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_face_index_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;climits&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/breadth_first_search.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/visitors.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>property<sp/>map<sp/>that<sp/>reads/writes<sp/>the<sp/>information<sp/>to/from<sp/>the<sp/>extended</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Type&gt;<sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Extended_face_property_map<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Face_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Boost<sp/>property<sp/>type<sp/>definitions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::read_write_property_map_tag<sp/><sp/><sp/><sp/><sp/><sp/>category;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>value_type&amp;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Face_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>get<sp/>function<sp/>is<sp/>required<sp/>by<sp/>the<sp/>property<sp/>map<sp/>concept.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/>reference<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Extended_face_property_map&amp;<sp/></highlight><highlight class="comment">/*<sp/>map<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_type<sp/>key)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>key-&gt;data();<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>put<sp/>function<sp/>is<sp/>required<sp/>by<sp/>the<sp/>property<sp/>map<sp/>concept.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>put(Extended_face_property_map<sp/></highlight><highlight class="comment">/*<sp/>map<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_type<sp/>key,<sp/>value_type<sp/>val)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>key-&gt;set_data(val);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits_2, unsigned int&gt;</ref><sp/>Dcel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ex_arrangement;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Dual" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">CGAL::Dual&lt;Ex_arrangement&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dual_arrangement;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__face__index__map" kindref="compound">CGAL::Arr_face_index_map&lt;Ex_arrangement&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_index_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Extended_face_property_map&lt;Ex_arrangement,unsigned<sp/>int&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_property_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>of<sp/>seven<sp/>intersecting<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>p1(1,<sp/>1),<sp/>p2(1,<sp/>4),<sp/>p3(2,<sp/>2),<sp/>p4(3,<sp/>7),<sp/>p5(4,<sp/>4),<sp/>p6(7,<sp/>1),<sp/>p7(9,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment_2(p1,<sp/>p6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment_2(p1,<sp/>p4));<sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment_2(p2,<sp/>p6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment_2(p3,<sp/>p7));<sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment_2(p3,<sp/>p5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment_2(p6,<sp/>p7));<sp/><sp/><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment_2(p4,<sp/>p7));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>mapping<sp/>of<sp/>the<sp/>arrangement<sp/>faces<sp/>to<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_index_map<sp/><sp/>index_map(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>breadth-first<sp/>search<sp/>from<sp/>the<sp/>unbounded<sp/>face,<sp/>using<sp/>the<sp/>event</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>visitor<sp/>to<sp/>associate<sp/>each<sp/>arrangement<sp/>face<sp/>with<sp/>its<sp/>discover<sp/>time.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/>time<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::breadth_first_search(Dual_arrangement(arr),<sp/>arr.unbounded_face(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::vertex_index_map(index_map).visitor</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(boost::make_bfs_visitor</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(stamp_times(Face_property_map(),<sp/>time,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::on_discover_vertex()))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>discover<sp/>time<sp/>of<sp/>each<sp/>arrangement<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement::Face_iterator<sp/><sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Discover<sp/>time<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fit-&gt;data()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>for<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fit<sp/>!=<sp/>arr.unbounded_face())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;face<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>print_ccb&lt;Ex_arrangement&gt;(fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;the<sp/>unbounded<sp/>face.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1arr_sectips">
<title>How To Speed Up Your Computation</title>
<para>Before the specific tips, we remind you that compiling programs with debug flags disabled and with optimization flags enabled significantly reduces the running time.</para><para><orderedlist>
<listitem>
<para>When the curves to be inserted into an arrangement are <formula id="2">$ x$</formula>-monotone and pairwise disjoint in their interior to start with, then it is more efficient (in running time) and less demanding (in traits-class functionality) to use the non-intersection insertion-functions instead of the general ones; e.g., <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput>.</para><para></para></listitem>
<listitem>
<para>When the curves to be inserted into an arrangement are segments that are pairwise disjoint in their interior, it is more efficient to use the traits class <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">Arr_non_caching_segment_traits_2</ref></computeroutput> rather then the default one (<computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput>).</para><para>If the segments may intersect each other, the default traits class <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> can be safely used with the somehow limited number type <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;MP_float&gt;</computeroutput>.</para><para>On rare occasions the traits class <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">Arr_non_caching_segment_traits_2</ref></computeroutput> exhibits slightly better performance than the default one (<computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> even when the segments intersect each other, due to the small overhead of the latter (optimized) traits class. (For example, when the so called Leda rational kernel is used).</para><para></para></listitem>
<listitem>
<para>Prior knowledge of the combinatorial structure of the arrangement can be used to accelerate operations that insert <formula id="2">$ x$</formula>-monotone curves, whose interior is disjoint from existing edges and vertices of the arrangement. The specialized insertion functions, i.e., <computeroutput>insert_in_face_interior()</computeroutput>, <computeroutput>insert_from_left_vertex()</computeroutput>, <computeroutput>insert_from_right_vertex()</computeroutput>, and <computeroutput>insert_at_vertices()</computeroutput> can be used according to the available information. These functions hardly involve any geometric operations, if at all. They accept topologically related parameters, and use them to operate directly on the Dcel records, thus saving algebraic operations, which are especially expensive when high-degree curves are involved.</para><para>A polygon, represented by a list of segments along its boundary, can be inserted into an empty arrangement as follows. First, one segment is inserted using <computeroutput>insert_in_face_interior()</computeroutput> into the unbounded face. Then, a segment with a common end point is inserted using either <computeroutput>insert_from_left_vertex()</computeroutput> or <computeroutput>insert_from_right_vertex()</computeroutput>, and so on with the rest of the segments except for the last, which is inserted using <computeroutput>insert_at_vertices()</computeroutput>, as both endpoints of which are the mapping of known vertices.</para><para></para></listitem>
<listitem>
<para>The main trade-off among point-location strategies, is between time and storage. Using the naive or walk strategies, for example, takes more query time but does not require preprocessing or maintenance of auxiliary structures and saves storage space.</para><para></para></listitem>
<listitem>
<para>If point-location queries are not performed frequently, but other modifying functions, such as removing, splitting, or merging edges are, then using a point-location strategy that does not require the maintenance of auxiliary structures, such as the naive or walk strategies, is preferable.</para><para></para></listitem>
<listitem>
<para>There is a trade-off between two modes of the trapezoidal RIC strategy that enables the user to choose whether preprocessing should be performed or not. If preprocessing is not used, the creation of the structure is faster. However, for some input sequences the structure might be unbalanced and therefore queries and updates might take longer, especially, if many removal and split operations are performed.</para><para></para></listitem>
<listitem>
<para>When the curves to be inserted into an arrangement are available in advance (as opposed to supplied on-line), it is advised to use the more efficient aggregate (sweep-based) insertion over the incremental insertion; e.g., <computeroutput><ref refid="group__PkgArrangement2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput>.</para><para></para></listitem>
<listitem>
<para>The various traits classes should be instantiated with an exact number type to ensure robustness, when the input of the operations to be carried out might be degenerate, although inexact number types could be used at the user&apos;s own risk.</para><para></para></listitem>
<listitem>
<para>Maintaining short bit-lengths of coordinate representations may drastically decrease the time consumption of arithmetic operations on the coordinates. This can be achieved by caching certain information or normalization (of rational numbers). However, both solutions should be used cautiously, as the former may lead to an undue space consumption, and indiscriminate normalization may considerably slow down the overall process.</para><para></para></listitem>
<listitem>
<para>Geometric functions (e.g., traits methods) dominate the time consumption of most operations. Thus, calls to such function should be avoided or at least their number should be decreased, perhaps at the expense of increased combinatorial-function calls or increased space consumption. For example, repetition of geometric-function calls could be avoided by storing the results obtained by the first call, and reusing them when needed. </para></listitem>
</orderedlist>
</para></sect1>
<sect1 id="index_1Arrangement_on_surface_2Design">
<title>Design and Implementation History</title>
<para>The code of this package is the result of a long development process. Initially (and until version 3.1), the code was spread among several components, namely, <computeroutput>Topological_map</computeroutput>, <computeroutput>Planar_map_2</computeroutput>, <computeroutput>Planar_map_with_intersections_2</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput>, that were developed by Ester Ezra, Eyal Flato, Efi Fogel, Dan Halperin, Iddo Hanniel, Idit Haran, Shai Hirsch, Eugene Lipovetsky, Oren Nechushtan, Sigal Raab, Ron Wein, Baruch Zukerman, and Tali Zvi.</para><para>In version 3.2, as part of the ACS project, the packages have gone through a major re-design, resulting in an improved and unified <emphasis>2D Arrangements</emphasis> package. The code of the new package was restructured and developed by Efi Fogel, Idit Haran, Ron Wein, and Baruch Zukerman. This version included for the first time a new geometry-traits class that handles circular and linear curves, and is based on the circular kernel. The circular kernel was developed by Monique Teillaud, Sylvain Pion, and Julien Hazebrouck.</para><para>Version 3.3 features arrangements of unbounded curves for the first time. The design and development of this feature required yet another restructuring of the entire package. All this was done by Eric Berberich, Efi Fogel, Dan Halperin, Ophir Setter, and Ron Wein. Michael Hemmer helped tuning up parts of the geometry-traits concept related to unbounded curves.</para><para>Version 3.7 introduced a geometry-traits class that handles planar algebraic curves of arbitrary degree. It was developed by Eric Berberich and Michael Kerber.</para><para>Version 3.9 introduced a new geometry-traits class that handles rational arcs. It was developed by Oren Salzman and Michael Hemmer. It replaced an old traits, which handled the same family of curves, developed by Ron Wein.</para><para>Version 4.1 introduces a revised implementation of the point location class via a randomized incremental construction of the trapezoidal map. The old class was implemented by Oren Nechushtan, while the revamp was done by Michal Kleinbort and Michael Hemmer. The new class adds support for unbounded curves and can now guarantee logarithmic query time in all cases. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
