<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Arrangement_on_surface_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Arrangements: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Arrangements
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Arrangements"></a><a class="anchor" id="chapterArrangement_on_surface_2"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Ron Wein, Eric Berberich, Efi Fogel, Dan Halperin, Michael Hemmer, Oren Salzman, and Baruch Zukerman</dd></dl>
<h1><a class="anchor" id="arr_secintro"></a>
Introduction</h1>
<p>Given a set \( \cal C\) of planar curves, the <em>arrangement</em> \( \cal A(\cal C)\) is the subdivision of the plane into zero-dimensional, one-dimensional and two-dimensional cells, called <em>vertices</em>, <em>edges</em> and <em>faces</em>, respectively induced by the curves in \( \cal C\). Arrangements are ubiquitous in the computational-geometry literature and have many applications; see, e.g., <a class="el" href="citelist.html#CITEREF_as-aa-00">[1]</a>, <a class="el" href="citelist.html#CITEREF_cgal:h-a-04">[5]</a>.</p>
<p>The curves in \( \cal C\) can intersect each other (a single curve may also be self-intersecting or may be comprised of several disconnected branches) and are not necessarily \( x\)-monotone.<span class="footnote">A continuous planar curve \( C\) is <em> \( x\)-monotone</em> if every vertical line intersects it at most once. For example, a non-vertical line segment is always \( x\)-monotone and so is the graph of any continuous function \( y = f(x)\). For convenience, we treat vertical line segments as <em>weakly \( x\)-monotone</em>, as there exists a single vertical line that overlaps them. A circle of radius \( r\) centered at \( (x_0, y_0)\) is not \( x\)-monotone, as the vertical line \( x = x_0\) intersects it at \( (x_0, y_0 - r)\) and at \( (x_0, y_0 + r)\).</span> We construct a collection \( \cal C''\) of \( x\)-monotone subcurves that are pairwise disjoint in their interiors in two steps as follows. First, we decompose each curve in \( \cal C\) into maximal \( x\)-monotone subcurves (and possibly isolated points), obtaining the collection \( \cal C'\). Note that an \( x\)-monotone curve cannot be self-intersecting. Then, we decompose each curve in \( \cal C'\) into maximal connected subcurves not intersecting any other curve (or point) in \( \cal C'\). The collection \( \cal C''\) may also contain isolated points, if the curves of \( \cal C\) contain such points. The arrangement induced by the collection \( \cal C''\) can be conveniently embedded as a planar graph, whose vertices are associated with curve endpoints or with isolated points, and whose edges are associated with subcurves. It is easy to see that \( \cal A(\cal C) = \cal A(\cal C'')\). This graph can be represented using a <em>doubly-connected edge list</em> data-structure (<span style="font-variant: small-caps;">Dcel</span> for short), which consists of containers of vertices, edges and faces and maintains the incidence relations among these objects.</p>
<p>The main idea behind the <span style="font-variant: small-caps;">Dcel</span> data-structure is to represent each edge using a pair of directed <em>halfedges</em>, one going from the \( xy\)-lexicographically smaller (left) endpoint of the curve toward its the \( xy\)-lexicographically larger (right) endpoint, and the other, known as its <em>twin</em> halfedge, going in the opposite direction. As each halfedge is directed, we say it has a <em>source</em> vertex and a <em>target</em> vertex. Halfedges are used to separate faces, and to connect vertices (with the exception of <em>isolated vertices</em>, which are unconnected).</p>
<p>If a vertex \( v\) is the target of a halfedge \( e\), we say that \( v\) and \( e\) are <em>incident</em> to each other. The halfedges incident to a vertex \( v\) form a circular list oriented in a clockwise order around this vertex. (An isolated vertex has no incident halfedges.)</p>
<p>Each halfedge \( e\) stores a pointer to its <em>incident face</em>, which is the face lying to its left. Moreover, every halfedge is followed by another halfedge sharing the same incident face, such that the target vertex of the halfedge is the same as the source vertex of the next halfedge. The halfedges are therefore connected in circular lists, and form chains, such that all edges of a chain are incident to the same face and wind along its boundary. We call such a chain a <em>connected component of the boundary</em> (or <em>CCB</em> for short).</p>
<p>The unique CCB of halfedges winding in a counterclockwise orientation along a face boundary is referred to as the <em>outer CCB</em> of the face. For the time being let us consider only arrangements of bounded curves, such that exactly one unbounded face exists in every arrangement. The unbounded face does not have an outer boundary. Any other connected component of the boundary of the face is called a <em>hole</em> (or <em>inner CCB</em>), and can be represented as a circular chain of halfedges winding in a clockwise orientation around it. Note that a hole does not necessarily correspond to a single face, as it may have no area, or alternatively it may consist of several connected faces. Every face can have several holes contained in its interior (or no holes at all). In addition, every face may contain isolated vertices in its interior. See <a class="el" href="index.html#fig__arr_figseg_dcel">Figure 34.1</a> for an illustration of the various <span style="font-variant: small-caps;">Dcel</span> features. For more details on the <span style="font-variant: small-caps;">Dcel</span> data structure see <a class="el" href="citelist.html#CITEREF_bkos-cgaa-00">[3]</a> Chapter 2.</p>
<p><a class="anchor" id="fig__arr_figseg_dcel"></a></p><div class="image">
<img src="arr_segs.png" alt="arr_segs.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figseg_dcel">Figure 34.1</a> An arrangement of interior-disjoint line segments with some of the <span style="font-variant: small-caps;">Dcel</span> records that represent it. The unbounded face \( f_0\) has a single connected component that forms a hole inside it, and this hole is comprised if several faces. The half-edge \( e\) is directed from its source vertex \( v_1\) to its target vertex \( v_2\). This edge, together with its twin \( e'\), correspond to a line segment that connects the points associated with \( v_1\) and \( v_2\) and separates the face \( f_1\) from \( f_2\). The predecessor \( e_{\rm prev}\) and successor \( e_{\rm next}\) of \( e\) are part of the chain that form the outer boundary of the face \( f_2\). The face \( f_1\) has a more complicated structure as it contains two holes in its interior: One hole consists of two adjacent faces \( f_3\) and \( f_4\), while the other hole is comprised of two edges. \( f_1\) also contains two isolated vertices \( u_1\) and \( u_2\) in its interior.  </div>  <br />

<p>The \( x\)-monotone curves of an arrangement are embedded in an rectangular two-dimensional area called the parameter space.<span class="footnote">The term parameter space stems from a major extension the arrangement package is going through to support arrangements embedded on certain two-dimensional parametric surfaces in three-dimensions (or higher).</span> The parameter space is defined as \( X \times Y\), where \( X\) and \( Y\) are open, half-open, or closed intervals with endpoints in the compactified real line \( \mathbb{R} \cup \{-\infty,+\infty\}\). Let \( b_l\), \( b_r\), \( b_b\), and \( b_t\) denote the endpoints of \( X\) and \( Y\), respectively. We typically refer to these values as the left, right, bottom, and top sides of the boundary of the parameter space. If the parameter space is, for example, the entire compactified plane, which is currently the only option supported by the package, \( b_l = b_b = -\infty\) and \( b_r = b_t = +\infty\).</p>
<p>The rest of this chapter is organized as follows: In Section <a class="el" href="index.html#arr_secarr_class">The Main Arrangement Class</a> we review in detail the interface of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class-template, which is the central component in the arrangement package. In Section <a class="el" href="index.html#arr_secqueries">Issuing Queries on an Arrangement</a> we show how queries on an arrangement can be issued. In Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions in the Arrangement Package</a> we review some important free (global) functions that operate on arrangements, the most important ones being the free insertion-functions. Section <a class="el" href="index.html#arr_sectraits">Traits Classes</a> contains detailed descriptions of the various geometric traits classes included in the arrangement package. Using these traits classes it is possible to construct arrangements of different families of curves. In Section <a class="el" href="index.html#arr_secnotif">The Notification Mechanism</a> we review the notification mechanism that allows external classes to keep track of the changes that an arrangement instance goes through. Section <a class="el" href="index.html#arr_secex_dcel">Extending the DCEL</a> explains how to extend the <span style="font-variant: small-caps;">Dcel</span> records, to store extra data with them, and to efficiently update this data. In Section <a class="el" href="index.html#arr_secoverlay">Overlaying Arrangements</a> we introduce the fundamental operation of overlaying two arrangements. Section <a class="el" href="index.html#arr_secarr_with_hist">Storing the Curve History</a> describes the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> class-template that extends the arrangement by storing additional history records with its curves. Finally, in Section <a class="el" href="index.html#arr_secio">Input/Output Streams</a> we review the arrangement input/output functions.</p>
<h1><a class="anchor" id="arr_secarr_class"></a>
The Main Arrangement Class</h1>
<p>The class <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> is the main class in the arrangement package. It is used to represent planar arrangements and it provides the interface needed to construct them, traverse them, and maintain them. An arrangement is defined by a geometric <em>traits</em> class that determines the family of planar curves that form the arrangement, and a <span style="font-variant: small-caps;">Dcel</span> class, which represents the <em>topological structure</em> of the planar subdivision. It supplies a minimal set of geometric operations (predicates and constructions) required to construct and maintain the arrangement and to operate on it.</p>
<p>The design of the arrangement package is guided by the need to separate between the representation of the arrangements and the various geometric algorithms that operate on them, and by the need to separate between the topological and geometric aspects of the planar subdivision. The separation is exhibited by the two template parameters of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> template: </p><ul>
<li>
<p class="startli">The <code>Traits</code> template-parameter should be instantiated with a model of the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept and optionally additional geometry traits concepts. A model of the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept defines the types of \( x\)-monotone curves and two-dimensional points, namely <code>X_monotone_curve_2</code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code>, respectively, and supports basic geometric predicates on them.</p>
<p class="endli">In the first sections of this chapter we always use <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> as our traits class, to construct arrangements of line segments. However, the arrangement package contains several other traits classes that can handle other types of curves, such as polylines (continuous piecewise-linear curves), conic arcs, and arcs of rational functions. We exemplify the usage of these traits classes in Section <a class="el" href="index.html#arr_sectraits">Traits Classes</a>. </p>
</li>
<li>
The <code>Dcel</code> template-parameter should be instantiated with a class that is a model of the <code><a class="el" href="classArrangementDcel.html" title="A doubly-connected edge-list (Dcel for short) data-structure. It consists of three containers of reco...">ArrangementDcel</a></code> concept. The value of this parameter is <code><a class="el" href="classCGAL_1_1Arr__default__dcel.html" title="The default Dcel class used by the Arrangement_2 class-template is parameterized by a traits class...">Arr_default_dcel</a>&lt;Traits&gt;</code> by default. However, in many applications it is necessary to extend the <span style="font-variant: small-caps;">Dcel</span> features; see Section <a class="el" href="index.html#arr_secex_dcel">Extending the DCEL</a> for further explanations and examples. </li>
</ul>
<h2><a class="anchor" id="Arrangement_on_surface_2ASimpleProgram"></a>
A Simple Program</h2>
<div class="image">
<img src="triangle.png" alt="triangle.png" />
</div>
 <p>The simple program listed below constructs a planar map of three line segments forming a triangle. The constructed arrangement is instantiated with the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> traits class to handle segments only. The resulting arrangement consists of two faces, a bounded triangular face and the unbounded face. The program is not very useful as it is, since it ends immediately after the arrangement is constructed. We give more enhanced examples in the rest of this chapter.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Quotient_8h.html">CGAL/Quotient.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">CGAL::Quotient&lt;CGAL::MP_Float&gt;</a> Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a> Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2 Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2 Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a> Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Arrangement_2 arr;</div><div class="line">  Segment_2 cv[3];</div><div class="line">  Point_2 p1 (0, 0), p2 (0, 4), p3 (4, 0);</div><div class="line"></div><div class="line">  cv[0] = Segment_2 (p1, p2);</div><div class="line">  cv[1] = Segment_2 (p2, p3);</div><div class="line">  cv[2] = Segment_2 (p3, p1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a> (arr, &amp;cv[0], &amp;cv[3]);</div><div class="line">  <span class="keywordflow">return</span> (0);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssectraverse"></a>
Traversing the Arrangement</h2>
<p>The simplest and most fundamental arrangement operations are the various traversal methods, which allow users to systematically go over the relevant features of the arrangement at hand.</p>
<p>As mentioned above, the arrangement is represented as a <span style="font-variant: small-caps;">Dcel</span>, which stores three containers of vertices, halfedges and faces. Thus, the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class supplies iterators for these containers. For example, the methods <code>vertices_begin()</code> and <code>vertices_end()</code> return <code><a class="el" href="classCGAL_1_1Arrangement__2.html#ac4a88fd2ca22b490454e4f425005e5c4" title="a bidirectional iterator over the vertices of the arrangement. ">Arrangement_2::Vertex_iterator</a></code> objects that define the valid range of arrangement vertices. The value type of this iterator is <code><a class="el" href="classCGAL_1_1Arrangement__2_1_1Vertex.html" title="An object  of the class Vertex represents an arrangement vertex, that is - a -dimensional cell...">Arrangement_2::Vertex</a></code>. Moreover, the vertex-iterator type is equivalent to <code><a class="el" href="classCGAL_1_1Arrangement__2.html#a7dac3eed2224beadf3658495bc671c49" title="a handle for an arrangement vertex. ">Arrangement_2::Vertex_handle</a></code>, which serves as a pointer to a vertex. As we show next, all functions related to arrangement features accept handle types as input parameters and return handle types as their output.</p>
<p>In addition to the iterators for arrangement vertices, halfedges and faces, the arrangement class also provides <code>edges_begin()</code> and <code>edges_end()</code> that return <code><a class="el" href="classCGAL_1_1Arrangement__2.html#a9b3a4b116e66f66bcd69215fa3f513f9" title="a bidirectional iterator over the edges of the arrangement. ">Arrangement_2::Edge_iterator</a></code> objects for traversing the arrangement edges. Note that the value type of this iterator is <code><a class="el" href="classCGAL_1_1Arrangement__2_1_1Halfedge.html" title="An object  of the class Halfedge represents a halfedge in the arrangement. ">Arrangement_2::Halfedge</a></code>, representing one of the twin halfedges that represent the edge.</p>
<p>All iterator, circulator<span class="footnote">A <em>circulator</em> is used to traverse a circular list, such as the list of halfedges incident to a vertex - see below.</span> and handle types also have non-mutable (<em>const</em>) counterparts. These non-mutable iterators are useful to traverse an arrangement without changing it. For example, the arrangement has a non-constant member function called <code>vertices_begin()</code> that returns a <code>Vertex_iterator</code> object and another const member function that returns a <code>Vertex_const_iterator</code> object. In fact, all methods listed in this section that return an iterator, a circulator or a handle have non-mutable counterparts. It should be noted that, for example, <code>Vertex_handle</code> can be readily converted into a <code>Vertex_const_handle</code>, but not vice-verse.</p>
<p>Conversion of a non-mutable handle to a corresponding mutable handle are nevertheless possible, and can be performed using the static function <code><a class="el" href="classCGAL_1_1Arrangement__2.html#a11be9c67d85886e197306dc47abab37a" title="casts the given constant vertex handle to an equivalent mutable handle. ">Arrangement_2::non_const_handle()</a></code> (see, e.g., Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>). There are three variant of this function, one for each type of handle.</p>
<h2><a class="anchor" id="arr_sssectr_vertex"></a>
Traversal Methods for an Arrangement Vertex</h2>
<p>A vertex is always associated with a geometric entity, namely with a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> object, which can be obtained by the <code>point()</code> method of the <code>Vertex</code> class nested within <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code>.</p>
<p>The <code>is_isolated()</code> method determines whether a vertex is isolated or not. Recall that the halfedges incident to a non-isolated vertex, namely the halfedges that share a common target vertex, form a circular list around this vertex. The <code>incident_halfedges()</code> method returns a circulator of type <code><a class="el" href="classCGAL_1_1Arrangement__2.html#a1490b8301d182e9d46e0c4e45cff6aa9" title="a bidirectional circulator over the halfedges that have a given vertex as their target. ">Arrangement_2::Halfedge_around_vertex_circulator</a></code> that enables the traversal of this circular list in a clockwise direction. The value type of this circulator is <code>Halfedge</code>.</p>
<p>The following function prints all the neighbors of a given arrangement vertex (assuming that the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> type can be inserted into the standard output using the <code>&lt;&lt;</code> operator). The arrangement type is the same as in the simple example above.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_neighboring_vertices (Arrangement_2::Vertex_const_handle v)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (v-&gt;is_isolated()) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The vertex ("</span> &lt;&lt; v-&gt;point() &lt;&lt; <span class="stringliteral">") is isolated"</span> &lt;&lt; std::endl;</div><div class="line">   <span class="keywordflow">return</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  Arrangement_2::Halfedge_around_vertex_const_circulator first, curr;</div><div class="line">  first = curr = v-&gt;incident_halfedges();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The neighbors of the vertex ("</span> &lt;&lt; v-&gt;point() &lt;&lt; <span class="stringliteral">") are:"</span>;</div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">    <span class="comment">// Note that the current halfedge is directed from u to v:</span></div><div class="line">    Arrangement_2::Vertex_const_handle u = curr-&gt;source();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; u-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line">  } <span class="keywordflow">while</span> (++curr != first);</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>In case of an isolated vertex, it is possible to obtain the face that contains this vertex using the <code>face()</code> method.</p>
<h2><a class="anchor" id="arr_sssectr_halfedge"></a>
Traversal Methods for an Arrangement Halfedge</h2>
<p>Each arrangement edge, realized as a pair of twin halfedges, is associated with an <code>X_monotone_curve_2</code> object, which can be obtained by the <code>curve()</code> method of the <code>Halfedge</code> class nested in the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class.</p>
<p>The <code>source()</code> and <code>target()</code> methods return handles to the halfedge source and target vertices respectively. We can obtain a handle to the twin halfedge using the <code>twin()</code> method. From the definition of halfedges, it follows that if <code>he</code> is a halfedge handle, then: </p><ul>
<li>
<code>he-&gt;curve()</code> is equivalent to <code>he-&gt;twin()-&gt;curve()</code>, </li>
<li>
<code>he-&gt;source()</code> is equivalent to <code>he-&gt;twin()-&gt;target()</code>, and </li>
<li>
<code>he-&gt;target()</code> is equivalent to <code>he-&gt;twin()-&gt;source()</code>. </li>
</ul>
<p>Every halfedge has an incident face that lies to its left, which can be obtained by the <code>face()</code> method. Recall that a halfedge is always one link in a connected chain of halfedges that share the same incident face, known as a <em>CCB</em>. The <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#ga6c3790809028471b1eacccb0d714d040">prev()</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">next()</a></code> methods return handles to the previous and next halfedges in the CCB respectively.</p>
<p>As the CCB is a circular list of halfedges, it is only natural to traverse it using a circulator. The <code>ccb()</code> method returns a <code><a class="el" href="classCGAL_1_1Arrangement__2.html#ab4a594c193ca09a672dbe2fcafa090e9" title="a bidirectional circulator over the halfedges of a CCB (connected component of the boundary)...">Arrangement_2::Ccb_halfedge_circulator</a></code> object for the halfedges along the CCB.</p>
<p>The function <code>print_ccb()</code> listed below prints all \( x\)-monotone curves along a given CCB (assuming that the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> and the <code>X_monotone_curve_2</code> types can be inserted into the standard output using the <code>&lt;&lt;</code> operator).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_ccb (Arrangement_2::Ccb_halfedge_const_circulator circ)</div><div class="line">{</div><div class="line">  Ccb_halfedge_const_circulator curr = circ;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; curr-&gt;source()-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">    Arrangement_2::Halfedge_const_handle he = curr-&gt;handle();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; he-&gt;curve() &lt;&lt; <span class="stringliteral">"] "</span></div><div class="line">              &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; he-&gt;target()-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line">  } <span class="keywordflow">while</span> (++curr != circ);</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_sssectr_face"></a>
Traversal Methods for an Arrangement Face</h2>
<p>An arrangement of bounded curves always has a single unbounded face. The function <code>unbounded_face()</code> returns a handle to this face. (Note that an empty arrangement contains nothing <em>but</em> the unbounded face.)</p>
<p>Given a <code>Face</code> object, we can use the <code>is_unbounded()</code> method to determine whether it is unbounded. Bounded faces have an outer CCB, and the <code>outer_ccb()</code> method returns a circulator for the halfedges along this CCB. Note that the halfedges along this CCB wind in a counterclockwise orientation around the outer boundary of the face.</p>
<p>A face can also contain disconnected components in its interior, namely holes and isolated vertices: </p><ul>
<li>
The <code>holes_begin()</code> and <code>holes_end()</code> methods return <code><a class="el" href="classCGAL_1_1Arrangement__2.html#a13420f4fd95338b0384ff309f3a15153" title="a bidirectional iterator over the holes (i.e., inner CCBs) contained inside a given face...">Arrangement_2::Hole_iterator</a></code> iterators that define the range of holes inside the face. The value type of this iterator is <code>Ccb_halfedge_circulator</code>, defining the CCB that winds in a clockwise orientation around a hole. </li>
<li>
The <code>isolated_vertices_begin()</code> and <code>isolated_vertices_end()</code> methods return <code><a class="el" href="classCGAL_1_1Arrangement__2.html#a1e0b89ad746d728e06ed8b62640d3d20" title="a bidirectional iterator over the isolated vertices contained inside a given face. ">Arrangement_2::Isolated_vertex_iterator</a></code> iterators that define the range of isolated vertices inside the face. The value type of this iterator is <code>Vertex</code>. </li>
</ul>
<p>The function <code>print_face()</code> listed below prints the outer and inner boundaries of a given face, using the function <code>print_ccb()</code>, which was introduced in the previous subsection.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_face (Arrangement_2::Face_const_handle f)</div><div class="line">{</div><div class="line">  <span class="comment">// Print the outer boundary.</span></div><div class="line">  <span class="keywordflow">if</span> (f-&gt;is_unbounded())</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Unbounded face. "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Outer boundary: "</span>;</div><div class="line">    print_ccb (f-&gt;outer_ccb());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Print the boundary of each of the holes.</span></div><div class="line">  Arrangement_2::Hole_const_iterator hi;</div><div class="line">  <span class="keywordtype">int</span> index = 1;</div><div class="line">  <span class="keywordflow">for</span> (hi = f-&gt;holes_begin(); hi != f-&gt;holes_end(); ++hi, ++index) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" Hole #"</span> &lt;&lt; index &lt;&lt; <span class="stringliteral">": "</span>;</div><div class="line">    print_ccb (*hi);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Print the isolated vertices.</span></div><div class="line">  Arrangement_2::Isolated_vertex_const_iterator iv;</div><div class="line">  <span class="keywordflow">for</span> (iv = f-&gt;isolated_vertices_begin(), index = 1;</div><div class="line">       iv != f-&gt;isolated_vertices_end(); ++iv, ++index){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" Isolated vertex #"</span> &lt;&lt; index &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; iv-&gt;point() &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_sssectr_ex"></a>
Additional Example</h2>
<p>The function listed below prints the current setting of a given arrangement. This concludes the preview of the various traversal methods.<span class="footnote">The file <code>arr_print.h</code>, which can be found under the examples folder, includes this function and the rest of the functions listed in this section. Over there they are written in a more generic fashion, where the arrangement type serves as a template parameter for these functions, so different instantiations of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> template can be provided to the same function templates.</span></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_arrangement (<span class="keyword">const</span> Arrangement_2&amp; arr)</div><div class="line">{</div><div class="line">  <span class="comment">// Print the arrangement vertices.</span></div><div class="line">  Vertex_const_iterator vit;</div><div class="line">  std::cout &lt;&lt; arr.number_of_vertices() &lt;&lt; <span class="stringliteral">" vertices:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line">    <span class="keywordflow">if</span> (vit-&gt;is_isolated())</div><div class="line">       std::cout &lt;&lt; <span class="stringliteral">" - Isolated."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">       std::cout &lt;&lt; <span class="stringliteral">" - degree "</span> &lt;&lt; vit-&gt;degree() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement edges.</span></div><div class="line">  Edge_const_iterator eit;</div><div class="line">  std::cout &lt;&lt; arr.number_of_edges() &lt;&lt; <span class="stringliteral">" edges:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (eit = arr.edges_begin(); eit != arr.edges_end(); ++eit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; eit-&gt;curve() &lt;&lt; <span class="stringliteral">"]"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement faces.</span></div><div class="line">  Face_const_iterator fit;</div><div class="line">  std::cout &lt;&lt; arr.number_of_faces() &lt;&lt; <span class="stringliteral">" faces:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit)</div><div class="line">    print_face (fit);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecmodify"></a>
Modifying the Arrangement</h2>
<p>In this section we review the various member functions of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class that allow users to modify the topological structure of the arrangement by introducing new edges or vertices, modifying them, or removing them.</p>
<p>The arrangement member-functions that insert new curves into the arrangement, thus enabling the construction of a planar subdivision, are rather specialized, as they require a-priori knowledge on the location of the inserted curve. Indeed, for most purposes it is more convenient to construct an arrangement using the free (global) insertion-functions.</p>
<h2><a class="anchor" id="arr_sssecmf_insert_cv"></a>
Inserting Non-Intersecting x-Monotone Curves</h2>
<p>The most important functions that allow users to modify the arrangement, and perhaps the most frequently used ones, are the specialized insertion functions of \( x\)-monotone curves whose interior is disjoint from any other curve in the existing arrangement and do not contain any vertex of the arrangement. In addition, these function require that the location of the curve in the arrangement is known.</p>
<p>The motivation behind these rather harsh restrictions on the nature of the inserted curves is the decoupling of the topological arrangement representation from the various algorithms that operate on it. While the insertion of an \( x\)-monotone curve whose interior is disjoint from all existing arrangement features is quite straightforward (as we show next), inserting curves that intersect with the curves already inserted into the arrangement is much more complicated and requires the application of non-trivial geometric algorithms. These insertion operations are therefore implemented as free functions that operate on the arrangement and the inserted curve(s); see Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions in the Arrangement Package</a> for more details and examples. <span class="footnote">You may skip to Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions in the Arrangement Package</a>, and return to this subsection at a later point in time.</span></p>
<p><a class="anchor" id="fig__arr_figex_1"></a></p><div class="image">
<img src="insert.png" alt="insert.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_1">Figure 34.2</a> The various specialized insertion procedures. The inserted \( x\)-monotone curve is drawn with a light dashed line, surrounded by two solid arrows that represent the pair of twin half-edges added to the <span style="font-variant: small-caps;">Dcel</span>. Existing vertices are shown as black dots while new vertices are shown as light dots. Existing half-edges that are affected by the insertion operations are drawn as dashed arrows. (a) Inserting a curve as a new hole inside the face \( f\). (b) Inserting a curve from an existing vertex \( u\) that corresponds to one of its endpoints. (c) Inserting an \( x\)-monotone curve whose endpoints are the already existing vertices \( u_1\) and \( u_2\). In our case, the new pair of half-edges close a new face \( f'\), where the hole \( h_1\), which used to belong to \( f\), now becomes an enclave in this new face.  </div>  <br />

<p>When an \( x\)-monotone curve is inserted into an existing arrangement, such that the interior of this curve is disjoint from any arrangement feature, only the following three scenarios are possible, depending on the status of the endpoints of the inserted subcurve:</p>
<ol>
<li>
In case both curve endpoints do not correspond to any existing arrangement vertex we have to create two new vertices corresponding to the curve endpoints and connect them using a pair of twin halfedges. This halfedge pair initiates a new hole inside the face that contains the curve in its interior. </li>
<li>
If exactly one endpoint corresponds to an existing arrangement vertex (we distinguish between a vertex that corresponds to the left endpoint of the inserted curve and a vertex corresponding to its right endpoint), we have to create a new vertex that corresponds to the other endpoint of the curve and to connect the two vertices by a pair of twin halfedges that form an "antenna" emanating from the boundary of an existing connected component (note that if the existing vertex used to be isolated, this operation is actually equivalent to forming a new hole inside the face that contains this vertex). </li>
<li>
If both endpoints correspond to existing arrangement vertices, we connect these vertices using a pair of twin halfedges. (If one or both vertices are isolated this case reduces to one of the two previous cases respectively.) The two following subcases may occur: <ul>
<li>
Two disconnected components are merged into a single connected component (as is the case with the segment \(s_1\) in the figure to the left). </li>
<li>
A new face is created, a face that splits from an existing arrangement face. In this case we also have to examine the holes and isolated vertices in the existing face and move the relevant ones inside the new face (as is the case with the segment \(s_2\) in the figure to the left). </li>
</ul>
</li>
</ol>
<div class="image">
<img src="connect_comp.png" alt="connect_comp.png" />
</div>
 <p>The <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class offers insertion functions named <code>insert_in_face_interior()</code>, <code>insert_from_left_vertex()</code>, <code>insert_from_right_vertex()</code> and <code>insert_at_vertices()</code> that perform the special insertion procedures listed above. The first function accepts an \( x\)-monotone curve \( c\) and an arrangement face \( f\) that contains this curve in its interior. The other functions accept an \( x\)-monotone curve \( c\) and handles to the existing vertices that correspond to the curve endpoint(s). Each of the four functions returns a handle to one of the twin halfedges that have been created, where: </p><ul>
<li>
<code>insert_in_face_interior(c, f)</code> returns a halfedge directed from the vertex corresponding to the left endpoint of <code>c</code> toward the vertex corresponding to its right endpoint. </li>
<li>
<code>insert_from_left_vertex(c, v)</code> and <code>insert_from_right_vertex(c, v)</code> returns a halfedge whose source is the vertex \( v\) that and whose target is the new vertex that has just been created. </li>
<li>
<code>insert_at_vertices(c, v1, v2)</code> returns a halfedge directed from \( v_1\) to \( v_2\). </li>
</ul>
<p><a class="anchor" id="fig__arr_figex_2"></a></p><div class="image">
<img src="ex_1.png" alt="ex_1.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_2">Figure 34.3</a> The arrangement of the line segments \( s_1, \ldots, s_5\) constructed in <code>edge_insertion.cpp</code>. The arrows mark the direction of the halfedges returned from the various insertion functions.  </div>  <br />

<p>The following program demonstrates the usage of the four insertion functions. It creates an arrangement of five line segments, as depicted in <a class="el" href="index.html#fig__arr_figex_1">Figure 34.2</a>.<span class="footnote">Notice that in all figures in the rest of this chapter the coordinate axes are drawn only for illustrative purposes and are <em>not</em> part of the arrangement.</span> As the arrangement is very simple, we use the simple <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a> kernel of <span style="font-variant: small-caps;">CGAL</span> with integer coordinates for the segment endpoints. We also use the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> class that enables the efficient maintenance of arrangements of line segments; see more details on this traits class in Section <a class="el" href="index.html#arr_sectraits">Traits Classes</a>. This example, as many others in this chapter, uses some print-utility functions from the file <code>print_arr.h</code>; these functions are also listed in Section <a class="el" href="index.html#arr_ssectraverse">Traversing the Arrangement</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2edge_insertion_8cpp-example.html">Arrangement_on_surface_2/edge_insertion.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement using the simple edge-insertion functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span>                                           Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;Number_type&gt;</a>           <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>            Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                  Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                 Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#a7dac3eed2224beadf3658495bc671c49">Arrangement_2::Vertex_handle</a>                  Vertex_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#acdb9c49c90f9354f20c56efac599a7fe">Arrangement_2::Halfedge_handle</a>                Halfedge_handle;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Arrangement_2   arr;</div><div class="line"></div><div class="line">  Segment_2       s1(Point_2(1, 3), Point_2(3, 5));</div><div class="line">  Segment_2       s2(Point_2(3, 5), Point_2(5, 3));</div><div class="line">  Segment_2       s3(Point_2(5, 3), Point_2(3, 1));</div><div class="line">  Segment_2       s4(Point_2(3, 1), Point_2(1, 3));</div><div class="line">  Segment_2       s5(Point_2(1, 3), Point_2(5, 3));</div><div class="line"></div><div class="line">  Halfedge_handle e1 = arr.insert_in_face_interior(s1, arr.unbounded_face());</div><div class="line">  Vertex_handle   v1 = e1-&gt;source();</div><div class="line">  Vertex_handle   v2 = e1-&gt;target();</div><div class="line">  Halfedge_handle e2 = arr.insert_from_left_vertex(s2, v2);</div><div class="line">  Vertex_handle   v3 = e2-&gt;target();</div><div class="line">  Halfedge_handle e3 = arr.insert_from_right_vertex(s3, v3);</div><div class="line">  Vertex_handle   v4 = e3-&gt;target();</div><div class="line">  arr.insert_at_vertices(s4, v4, v1);</div><div class="line">  arr.insert_at_vertices(s5, v1, v3);</div><div class="line"></div><div class="line">  print_arrangement(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Observe that the first line segment is inserted in the interior of the unbounded face. The other line segments are inserted using the vertices created by the insertion of previous segments. The resulting arrangement consists of three faces, where the two bounded faces form together a hole in the unbounded face.</p>
<h2><a class="anchor" id="arr_sssecmf_iso_verts"></a>
Manipulating Isolated Vertices</h2>
<p>Isolated points are in general simpler geometric entities than curves and indeed the member functions that manipulate them are easier to understand.</p>
<p>The function <code>insert_in_face_interior(p, f)</code> inserts an isolated point \( p\), located in the interior of a given face \( f\), into the arrangement and returns a handle to the arrangement vertex it has created and associated with \( p\). Naturally, this function has a precondition that \( p\) is really an isolated point, namely it does not coincide with any existing arrangement vertex and does not lie on any edge. As mentioned in Section <a class="el" href="index.html#arr_ssectraverse">Traversing the Arrangement</a>, it is possible to obtain the face containing an isolated vertex handle \( v\) by calling <code>v-&gt;face()</code>.</p>
<p>The function <code>remove_isolated_vertex(v)</code> receives a handle to an isolated vertex and removes it from the arrangement.</p>
<p><a class="anchor" id="fig__arr_figex_3"></a></p><div class="image">
<img src="ex_2.png" alt="ex_2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_3">Figure 34.4</a> An arrangement of line segments containing three isolated vertices, as constructed in <code>isolated_vertices.cpp</code>. The vertices \( u_2\) and \( u_3\) are eventually removed from the arrangement.  </div>  <br />

<p>The following program demonstrates the usage of the arrangement member-functions for manipulating isolated vertices. It first inserts three isolated vertices located inside the unbounded face, then it inserts four line segments that form a rectangular hole inside the unbounded face (see <a class="el" href="index.html#fig__arr_figex_2">Figure 34.3</a> for an illustration). Finally, it traverses the vertices and removes those isolated vertices that are still contained in the unbounded face ( \( u_2\) and \( u_3\) in this case):</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2isolated_vertices_8cpp-example.html">Arrangement_on_surface_2/isolated_vertices.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement with isolated vertices.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_inexact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Insert isolated points.</span></div><div class="line">  Arrangement arr;</div><div class="line">  Face_handle uf = arr.unbounded_face();</div><div class="line">  arr.insert_in_face_interior(Point(3, 3), uf);</div><div class="line">  arr.insert_in_face_interior(Point(1, 5), uf);</div><div class="line">  arr.insert_in_face_interior(Point(5, 5), uf);</div><div class="line"></div><div class="line">  <span class="comment">// Insert four segments that form a square-shaped face.</span></div><div class="line">  Point p1(1, 3), p2(3, 5), p3(5, 3), p4(3, 1);</div><div class="line">  Segment s1(p1, p2), s2(p2, p3), s3(p3, p4), s4(p4, p1);</div><div class="line"></div><div class="line">  Halfedge_handle e1 = arr.insert_in_face_interior(s1, uf);</div><div class="line">  Vertex_handle   v1 = e1-&gt;source();</div><div class="line">  Vertex_handle   v2 = e1-&gt;target();</div><div class="line">  Halfedge_handle e2 = arr.insert_from_left_vertex(s2, v2);</div><div class="line">  Vertex_handle   v3 = e2-&gt;target();</div><div class="line">  Halfedge_handle e3 = arr.insert_from_right_vertex(s3, v3);</div><div class="line">  Vertex_handle   v4 = e3-&gt;target();</div><div class="line">  arr.insert_at_vertices(s4, v4, v1);</div><div class="line"></div><div class="line">  <span class="comment">// Remove the isolated vertices located in the unbounded face.</span></div><div class="line">  Arrangement::Vertex_iterator curr, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">next</a> = arr.vertices_begin();</div><div class="line">  <span class="keywordflow">for</span> (curr = next++; curr != arr.vertices_end(); curr = next++) {</div><div class="line">    <span class="comment">// Keep an iterator to the next vertex, as curr might be deleted.</span></div><div class="line">    <span class="keywordflow">if</span> (curr-&gt;is_isolated() &amp;&amp; curr-&gt;face() == uf)</div><div class="line">      arr.remove_isolated_vertex(curr);</div><div class="line">  }</div><div class="line"></div><div class="line">  print_arrangement(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_sssecmf_halfedges"></a>
Manipulating Halfedges</h2>
<p>In the previous subsection we showed how to introduce new isolated vertices in the arrangement. But how does one create a vertex that lies on an existing arrangement edge (more precisely, on an \( x\)-monotone curve that is associated with an arrangement edge)?</p>
<p>It should be noted that such an operation involves the splitting of a curve at a given point in its interior, while the traits class used by <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> does not necessarily have the ability to perform such a split operation. However, if users have the ability to split an \( x\)-monotone curve into two at a given point \( p\) (this is usually the case when employing a more sophisticated traits class; see Section <a class="el" href="index.html#arr_sectraits">Traits Classes</a> for more details) they can use the <code>split_edge(e, c1, c2)</code> function, were \( c_1\) and \( c_2\) are the two subcurves resulting from splitting the \( x\)-monotone curve associated with the halfedge \( e\) at some point (call it \( p\)) in its interior. The function splits the halfedge pair into two pairs, both incident to a new vertex \( v\) associated with \( p\), and returns a handle to a halfedge whose source equals \( e\)'s source vertex and whose target is the new vertex \( v\).</p>
<p>The reverse operation is also possible. Suppose that we have a vertex \( v\) of degree \( 2\), whose two incident halfedges, \( e_1\) and \( e_2\), are associated with the curves \( c_1\) and \( c_2\). Suppose further that it is possible to merge these two curves into a single continuous \( x\)-monotone curve \( c\). Calling <code>merge_edge(e1, e2, c)</code> will merge the two edges into a single edge associated with the curve \( c\), essentially removing the vertex \( v\) from the arrangement.</p>
<p>Finally, the function <code>remove_edge(e)</code> removes the edge \( e\) from the arrangement. Note that this operation is the reverse of an insertion operation, so it may cause a connected component to split into two, or two faces to merge into one, or a hole to disappear. By default, if the removal of <code>e</code> causes one of its end-vertices to become isolated, we remove this vertex as well. However, users can control this behavior and choose to keep the isolated vertices by supplying additional Boolean flags to <code><a class="el" href="group__PkgArrangement2Funcs.html#ga324fdf8354e7812fe0e1c0e5ac14196c" title="Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. ">remove_edge()</a></code> indicating whether the source and the target vertices are to be removed should they become isolated.</p>
<p><a class="anchor" id="fig__arr_figex_4"></a></p><div class="image">
<img src="ex_3.png" alt="ex_3.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_4">Figure 34.5</a> An arrangement of line segments as constructed in <code>edge_manipulation.cpp</code>. Note that the edges \( e_7\) and \( e_8\) and the vertices \( w_1\) and \( w_2\), introduced in step (b) are eventually removed in step (c).  </div>  <br />

<p>In the following example program we show how the edge-manipulation functions can be used. The program works in three steps, as demonstrated in <a class="el" href="index.html#fig__arr_figex_3">Figure 34.4</a>. Note that here we still stick to integer coordinates, but as we work on a larger scale we use an unbounded integer number-type (in this case, the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">Gmpz</a></code> type taken from the <span class="textsc">Gmp</span> library) instead of the built-in <code>int</code> type.<span class="footnote">As a rule of thumb, one can use a bounded integer type for representing line segments whose coordinates are bounded by \( \lfloor\sqrt[3]{M}\rfloor\), where \( M\) is the maximal representable integer value. This guarantees that no overflows occur in the computations carried out by the traits class, hence all traits-class predicates always return correct results.</span> In case the <span class="textsc">Gmp</span> library is not installed (as indicated by the <code>CGAL_USE_GMP</code> flag defined in <code>CGAL/basic.h</code>), we use <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">MP_Float</a></code>, a number-type included in <span style="font-variant: small-caps;">CGAL</span>'s support library that is capable of storing floating-point numbers with unbounded mantissa. We also use the standard <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a> kernel of <span style="font-variant: small-caps;">CGAL</span> as our kernel. This is recommended when the kernel is instantiated with a more complex number type, as we demonstrate in other examples in this chapter.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2edge_manipulation_8cpp-example.html">Arrangement_on_surface_2/edge_manipulation.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the edge-manipulation functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>   Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                  Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                   Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                        Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                       Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#a7dac3eed2224beadf3658495bc671c49">Arrangement_2::Vertex_handle</a>                        Vertex_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#acdb9c49c90f9354f20c56efac599a7fe">Arrangement_2::Halfedge_handle</a>                      Halfedge_handle;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Step(a) - construct a triangular face.</span></div><div class="line">  Arrangement_2   arr;</div><div class="line"></div><div class="line">  Segment_2       s1(Point_2(667, 1000), Point_2(4000, 5000));</div><div class="line">  Segment_2       s2(Point_2(4000, 0), Point_2(4000, 5000));</div><div class="line">  Segment_2       s3(Point_2(667, 1000), Point_2(4000, 0));</div><div class="line"></div><div class="line">  Halfedge_handle e1 = arr.insert_in_face_interior(s1, arr.unbounded_face());</div><div class="line">  Vertex_handle   v1 = e1-&gt;source();</div><div class="line">  Vertex_handle   v2 = e1-&gt;target();</div><div class="line">  Halfedge_handle e2 = arr.insert_from_right_vertex(s2, v2);</div><div class="line">  Vertex_handle   v3 = e2-&gt;target();</div><div class="line">  arr.insert_at_vertices(s3, v3, v1);</div><div class="line"></div><div class="line">  <span class="comment">// Step (b) - create additional two faces inside the triangle.</span></div><div class="line">  Point_2         p1(4000, 3666), p2(4000, 1000);</div><div class="line">  Segment_2       s4(Point_2(4000, 5000), p1);</div><div class="line">  Segment_2       s5(p1, p2);</div><div class="line">  Segment_2       s6(Point_2(4000, 0), p2);</div><div class="line"></div><div class="line">  Halfedge_handle e4 = arr.split_edge(e2, s4, Segment_2(Point_2(4000, 0), p1));</div><div class="line">  Vertex_handle   w1 = e4-&gt;target();</div><div class="line">  Halfedge_handle e5 = arr.split_edge(e4-&gt;next(), s5, s6);</div><div class="line">  Vertex_handle   w2 = e5-&gt;target();</div><div class="line">  Halfedge_handle e6 = e5-&gt;next();</div><div class="line"></div><div class="line">  Segment_2       s7(p1, Point_2(3000, 2666));</div><div class="line">  Segment_2       s8(p2, Point_2(3000, 1333));</div><div class="line">  Segment_2       s9(Point_2(3000, 2666), Point_2(2000, 1666));</div><div class="line">  Segment_2       s10(Point_2(3000, 1333), Point_2(2000, 1666));</div><div class="line">  Segment_2       s11(Point_2(3000, 1333), Point_2(3000, 2666));</div><div class="line"></div><div class="line">  Halfedge_handle e7 = arr.insert_from_right_vertex(s7, w1);</div><div class="line">  Vertex_handle   v4 = e7-&gt;target();</div><div class="line">  Halfedge_handle e8 = arr.insert_from_right_vertex(s8, w2);</div><div class="line">  Vertex_handle   v5 = e8-&gt;target();</div><div class="line">  Vertex_handle   v6 =</div><div class="line">    arr.insert_in_face_interior(Point_2(2000, 1666), e8-&gt;face());</div><div class="line"></div><div class="line">  arr.insert_at_vertices(s9, v4, v6);</div><div class="line">  arr.insert_at_vertices(s10, v5, v6);</div><div class="line">  arr.insert_at_vertices(s11, v4, v5);</div><div class="line"></div><div class="line">  <span class="comment">// Step(c) - remove and merge faces to form a single hole in the traingle.</span></div><div class="line">  arr.remove_edge(e7);</div><div class="line">  arr.remove_edge(e8);</div><div class="line"></div><div class="line">  e5 = arr.merge_edge(e5, e6, Segment_2(e5-&gt;source()-&gt;point(),</div><div class="line">                                        e6-&gt;target()-&gt;point()));</div><div class="line">  e2 = arr.merge_edge(e4, e5, s2);</div><div class="line"></div><div class="line">  print_arrangement(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Note how we use the halfedge handles returned from <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga8a7629a2a0659ca059081eae8cedca3d">split_edge()</a></code> and <code>merge_edge()</code>. Also note the insertion of the isolated vertex \( v_6\) located inside the triangular face (the incident face of \( e_7\)). This vertex seizes from being isolated, as it is gets connected to other vertices.</p>
<p>In this context, we should mention the two member functions <code>modify_vertex(v, p)</code>, which sets \( p\) to be the point associated with the vertex \( v\), and <code>modify_edge(e, c)</code>, which sets \( c\) to be the \( x\)-monotone curve associated with the halfedge \( e\). These functions have preconditions that \( p\) is geometrically equivalent to <code>v-&gt;point()</code> and \( c\) is equivalent to <code>e-&gt;curve()</code> (i.e., the two curves have the same graph), respectively, to avoid the invalidation of the geometric structure of the arrangement. At a first glance it may seen as these two functions are of little use. However, we should keep in mind that there may be extraneous data (probably non-geometric) associated with the point objects or with the curve objects, as defined by the traits class. With these two functions we can modify this data; see more details in Section <a class="el" href="index.html#arr_sectraits">Traits Classes</a>.</p>
<p>In addition, we can use these functions to replace a geometric object (a point or a curve) with an equivalent object that has a more compact representation. For example, we can replace the point \( (\frac{20}{40}, \frac{99}{33})\) associated with some vertex \( v\), by \( (\frac{1}{2}, 3)\).</p>
<h2><a class="anchor" id="arr_sssecadv_insert"></a>
Advanced Insertion Functions</h2>
<div class="image">
<img src="pred_around_vertex.png" alt="pred_around_vertex.png" />
</div>
 <p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>Assume that the specialized insertion function <code>insert_from_left_vertex(c,v)</code> is invoked for a curve \( c\), whose left endpoint is already associated with a non-isolated vertex \( v\). Namely, \( v\) has already several incident halfedges. It is necessary in this case to locate the exact place for the new halfedge mapped to the inserted new curve \( c\) in the circular list of halfedges incident to \( v\). More precisely, it is sufficient to locate one of the halfedges <code>pred</code> directed toward \( v\) such that \( c\) is located between <code>pred</code> and <code>pred-&gt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gad4dbc8daf3c0e2201f4972eb9eea404d">next()</a></code> in clockwise order around \( v\), in order to complete the insertion (see <a class="el" href="index.html#fig__arr_figex_1">Figure 34.2</a> for an illustration). This may take \( O(d)\) time where \( d\) is the degree of the vertex. However, if the halfedge <code>pred</code> is known in advance, the insertion can be carried out in constant time.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class provides the advanced versions of the specialized insertion functions for a curve \( c\) - namely we have <code>insert_from_left_vertex(c,pred)</code> and <code>insert_from_right_vertex(c,pred)</code> that accept a halfedge <code>pred</code> as specified above, instead of a vertex \( v\). These functions are more efficient, as they take constant time and do not perform any geometric operations. Thus, they should be used when the halfedge <code>pred</code> is known. In case that the vertex \( v\) is isolated or that the predecessor halfedge for the new inserted curve is not known, the simpler versions of these insertion functions should be used.</p>
<p>Similarly, there exist two overrides of the <code>insert_at_vertices()</code> function: One that accept the two predecessor halfedges around the two vertices \( v_1\) and \( v_2\) that correspond to the curve endpoints, and one that accepts a handle for one vertex and a predecessor halfedge around the other vertex.</p>
<p><a class="anchor" id="fig__arr_figex_5"></a></p><div class="image">
<img src="ex_4.png" alt="ex_4.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_5">Figure 34.6</a> An arrangement of line segments, as constructed in <code>special_edge_insertion.cpp</code>. Note that \( p_0\) is initially inserted as an isolated point and later on connected to the other four vertices.  </div>  <br />

<p>The following program shows how to construct the arrangement depicted in <a class="el" href="index.html#fig__arr_figex_4">Figure 34.5</a> using the specialized insertion functions that accept predecessor halfedges:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2special_edge_insertion_8cpp-example.html">Arrangement_on_surface_2/special_edge_insertion.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement using the specialized edge-insertion functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_inexact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Point           p0(3, 3), p1(1, 3), p2(3, 5), p3(5, 3), p4(3, 1);</div><div class="line">  Segment         s1(p1, p2), s2(p2, p3), s3(p3, p4), s4(p4, p1);</div><div class="line">  Segment         s5(p1, p0), s6(p0, p3), s7(p4, p0), s8(p0, p2);</div><div class="line"></div><div class="line">  Arrangement     arr;</div><div class="line">  Vertex_handle   v0 = arr.insert_in_face_interior(p0, arr.unbounded_face());</div><div class="line">  Halfedge_handle e1 = arr.insert_in_face_interior(s1, arr.unbounded_face());</div><div class="line">  Halfedge_handle e2 = arr.insert_from_left_vertex(s2, e1);</div><div class="line">  Halfedge_handle e3 = arr.insert_from_right_vertex(s3, e2);</div><div class="line">  Halfedge_handle e4 = arr.insert_at_vertices(s4, e3, e1-&gt;twin());</div><div class="line">  Halfedge_handle e5 = arr.insert_at_vertices(s5, e1-&gt;twin(), v0);</div><div class="line">  Halfedge_handle e6 = arr.insert_at_vertices(s6, e5, e3-&gt;twin());</div><div class="line">  arr.insert_at_vertices(s7, e4-&gt;twin(), e6-&gt;twin());</div><div class="line">  arr.insert_at_vertices(s8, e5, e2-&gt;twin());</div><div class="line"></div><div class="line">  print_arrangement(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>It is possible to perform even more refined operations on an <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instance given specific topological information. As most of these operations are very fragile and perform no precondition testing on their input in order to gain efficiency, they are not included in the public interface of the arrangement class. Instead, the <code><a class="el" href="classCGAL_1_1Arr__accessor.html">Arr_accessor</a>&lt;Arrangement&gt;</code> class allows access to these internal arrangement operations - see more details in the Reference Manual.  </p></div> 
<h1><a class="anchor" id="arr_secqueries"></a>
Issuing Queries on an Arrangement</h1>
<p>One of the most important query types defined on arrangements is the <em>point-location</em> query: Given a point, find the arrangement cell that contains it. Typically, the result of a point-location query is one of the arrangement faces, but in degenerate situations the query point can be located on an edge or it may coincide with a vertex.</p>
<p>Point-location queries are common in many applications, and also play an important role in the incremental construction of arrangements (and more specifically in the free insertion-functions described in Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions in the Arrangement Package</a>). Therefore, it is crucial to have the ability to answer such queries effectively.</p>
<h2><a class="anchor" id="arr_ssecpl"></a>
Point-Location Queries</h2>
<p>The <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template does not support point-location queries directly, as the arrangement representation is decoupled from the geometric algorithms that operate on it. The <em>2D Arrangements</em> package includes a set of classe templates that are capable of answering such queries; all are models of the concept <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code>. Each model employs a different algorithm or <em>strategy</em> for answering queries. A model of this concept must define the <code><a class="el" href="group__PkgArrangement2PointLocation.html#ga81a8e48ebfc5a10a040f3b7d94a4c97d" title="Performs a batched point-location operation on a given arrangement. ">locate()</a></code> member function, which accepts an input query-point and returns an object that represents the arrangement cell that contains this point. This object is is type <code><a class="el" href="structCGAL_1_1Arr__point__location__result.html" title="A unary metafunction to determine the return type of a point-location or vertical ray-shoot query...">Arr_point_location_result</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;::Type</code>a discriminated union container of the bounded types <code>Vertex_const_handle</code>, <code>Halfedge_const_handle</code>, or <code>Face_const_handle</code>. Depending on whether the query point is located inside a face, on an edge, or on a vertex, the appropriate handle can be obtained with <em>value retrieval</em> by <code>boost::get</code> as demonstrated in the example below.</p>
<p>Note that the handles returned by the <code><a class="el" href="group__PkgArrangement2PointLocation.html#ga81a8e48ebfc5a10a040f3b7d94a4c97d" title="Performs a batched point-location operation on a given arrangement. ">locate()</a></code> functions are non-mutable (<code>const</code>). If necessary, such handles may be cast to mutable handles using the <code>non_const_handle()</code> methods <code><a class="el" href="classCGAL_1_1Arrangement__2.html#a11be9c67d85886e197306dc47abab37a" title="casts the given constant vertex handle to an equivalent mutable handle. ">Arrangement_2::non_const_handle()</a></code> provided by the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class.</p>
<p>An object <code>pl</code> of any point-location class must be attached to an <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> object <code>arr</code> before it is used to answer point-location queries on <code>arr</code>. This attachment can be performed when <code>pl</code> is constructed or at a later time using the <code>pl.init(arr)</code> call.</p>
<p>The function template listed below accepts a point-location object, the type of which is a model of the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept, and a query point. The function template issues a point-location query for the given point, and prints out the result. It is defined in the header file <code>point_location_utils.h</code>.</p>
<p><a class="anchor" id="lst_pl"></a></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>Location&gt;</div><div class="line"><span class="keywordtype">void</span> locate_point(<span class="keyword">const</span> PointLocation&amp; pl,</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">typename</span> PointLocation::Arrangement_2::Point_2&amp; q)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> PointLocation                                 Point_location;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Point_location::Arrangement_2        Arrangement_2;</div><div class="line">  <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Arr_point_location_result&lt;Arrangement_2&gt;::Type</a> obj =</div><div class="line">    pl.locate(q);</div><div class="line"></div><div class="line">  <span class="comment">// Print the result.</span></div><div class="line">  print_point_location&lt;Arrangement_2&gt;(q, obj);</div><div class="line">}</div></div><!-- fragment --><p>The function template <code>locate_point()</code> calls an instance of the function template <code>print_point_location()</code>, which inserts the result of the query into the standard output-stream. It is listed below, and defined in the header file <code>point_location_utils.h</code>. Observe how the function <code>boost::get()</code> is used to cast the resulting object into a handle to an arrangement feature. The point-location object <code>pl</code> is assumed to be already attached to an arrangement.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement_&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">print_point_location</div><div class="line">(<span class="keyword">const</span> <span class="keyword">typename</span> PointLocation::Arrangement_2::Point_2&amp; q</div><div class="line"> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Arr_point_location_result&lt;Arrangement_&gt;::Type</a> obj)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Arrangement_                                  Arrangement_2;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement_2::Vertex_const_handle   Vertex_const_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement_2::Halfedge_const_handle Halfedge_const_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement_2::Face_const_handle     Face_const_handle;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Vertex_const_handle*   v;</div><div class="line">  <span class="keyword">const</span> Halfedge_const_handle* e;</div><div class="line">  <span class="keyword">const</span> Face_const_handle*     f;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The point ("</span> &lt;&lt; q &lt;&lt; <span class="stringliteral">") is located "</span>;</div><div class="line">  <span class="keywordflow">if</span> (f = boost::get&lt;Face_const_handle&gt;(&amp;obj)) <span class="comment">// located inside a face</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"inside "</span></div><div class="line">              &lt;&lt; (((*f)-&gt;is_unbounded()) ? <span class="stringliteral">"the unbounded"</span> : <span class="stringliteral">"a bounded"</span>)</div><div class="line">              &lt;&lt; <span class="stringliteral">" face."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e = boost::get&lt;Halfedge_const_handle&gt;(&amp;obj)) <span class="comment">// located on an edge</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"on an edge: "</span> &lt;&lt; (*e)-&gt;curve() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (v = boost::get&lt;Vertex_const_handle&gt;(&amp;obj)) <span class="comment">// located on a vertex</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"on "</span> &lt;&lt; (((*v)-&gt;is_isolated()) ? <span class="stringliteral">"an isolated"</span> : <span class="stringliteral">"a"</span>)</div><div class="line">              &lt;&lt; <span class="stringliteral">" vertex: "</span> &lt;&lt; (*v)-&gt;point() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> CGAL_error_msg(<span class="stringliteral">"Invalid object."</span>);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_sssecpl_strat"></a>
Choosing a Point-Location Strategy</h2>
<p>Each of the various point-location class templates employs a different algorithm or <em>strategy</em><span class="footnote">The term <em>strategy</em> is borrowed from the design-pattern taxonomy <a class="el" href="citelist.html#CITEREF_cgal:ghjv-dpero-95">[4]</a>, Chapter 5. A <em>strategy</em> provides the means to define a family of algorithms, each implemented by a separate class. All classes that implement the various algorithms are made interchangeable, letting the algorithm in use vary according to the user choice.</span> for answering queries: </p><ul>
<li>
<p class="startli"><code><a class="el" href="classCGAL_1_1Arr__naive__point__location.html">Arr_naive_point_location</a>&lt;Arrangement&gt;</code> employs the <em>naive</em> strategy. It locates the query point naively, exhaustively scanning all arrangement cells.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;Arrangement&gt;</code> employs the <em>walk-along-a-line</em> (or <em>walk</em> for short) strategy. It simulates a traversal, in reverse order, along an imaginary vertical ray emanating from the query point. It starts from the unbounded face of the arrangement and moves downward toward the query point until it locates the arrangement cell containing it.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="classCGAL_1_1Arr__landmarks__point__location.html">Arr_landmarks_point_location</a>&lt;Arrangement,Generator&gt;</code> uses a set of <em>landmark</em> points, the location of which in the arrangement is known. It employs the <em>landmark</em> strategy. Given a query point, it uses a nearest-neighbor search-structure (a <span class="textsc">Kd</span>-tree is used by default) to find the nearest landmark, and then traverses the straight-line segment connecting this landmark to the query point.</p>
<p>There are various ways to select the landmark set in the arrangement. The selection is governed by the <code>Generator</code> template parameter. The default generator class, namely <code>Arr_landmarks_vertices_generator</code>, selects all the vertices of the attached arrangement as landmarks. Additional generators that select the set in other ways, such as by sampling random points or choosing points on a grid, are also available; see the Reference Manual for more details.</p>
<p>The landmark strategy requires that the type of the attached arrangement be an instance of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template, where the <code>Traits</code> parameter is substituted with a geometry-traits class that models the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept, which refines the basic <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept; see Section <a class="el" href="index.html#arr_sssectr_lanmarks_concept">The Landmarks Concept</a> for details. Most traits classes included in the <em>2D Arrangement</em> package are models of this refined concept.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="classCGAL_1_1Arr__trapezoid__ric__point__location.html">Arr_trapezoid_ric_point_location</a>&lt;Arrangement&gt;</code> implements an improved variant of Mulmuley's point-location algorithm <a class="el" href="citelist.html#CITEREF_m-fppa-90">[8]</a>; see also <a class="el" href="citelist.html#CITEREF_bkos-cgaa-00">[3]</a>, Chapter 6. The (expected) query-time is logarithmic. The arrangement faces are decomposed into simpler cells each of constant complexity, known as <em>pseudo-trapezoids</em>, and a search structure (a directed acyclic graph) is constructed on top of these cells, facilitating the search of the pseudo trapezoid (hence the arrangement cell) containing a query point in expected logarithmic time. The trapezoidal map and the search structure are built by a randomized incremental construction algorithm (RIC).</p>
<p class="endli"></p>
</li>
</ul>
<p>The first two strategies do not require any extra data. The class templates that implement them store a pointer to an arrangement object and operate directly on it. Attaching such point-location objects to an existing arrangement has virtually no running-time cost at all, but the query time is linear in the size of the arrangement (the performance of the walk strategy is much better in practice, but its worst-case performance is linear). Using these strategies is therefore recommended only when a relatively small number of point-location queries are issued by the application, or when the arrangement is constantly changing (That is, changes in the arrangement structure are more frequent than point-location queries).</p>
<p>On the other hand, the landmarks and the trapezoid RIC strategies require auxiliary data structures on top of the arrangement, which they need to construct once they are attached to an arrangement object and need to keep up-to-date as this arrangement changes. The data structure needed by the landmarks strategy can be constructed in \( O(N \log N) \) time, where \( N \) is the overall number of edges in the arrangement, but the constant hidden in the \( O() \) notation for the trapezoidal map RIC strategy is much larger. Thus, construction needed by the landmark algorithm is in practice significantly faster than the construction needed by the trapezoidal map RIC strategy. In addition, although both resulting data structures are asymptotically linear in size, using a <span class="textsc">Kd</span>-tree as the nearest-neighbor search-structure that the landmark algorithm stores significantly reduces memory consumption. The trapezoidal map RIC algorithm has expected logarithmic query time, while the query time for the landmark strategy may be as large as linear. In practice however, the query times of both strategies are competitive. For a detailed experimental comparison see <a class="el" href="citelist.html#CITEREF_cgal:hh-eplca-05">[6]</a>.</p>
<p>Updating the auxiliary data structures of the trapezoidal map RIC algorithm is done very efficiently. On the other hand, updating the nearest-neighbor search-structure of the landmark algorithm may consume more time when the arrangement changes frequently, especially when a <span class="textsc">Kd</span>-tree is used, as it must be rebuilt each time the arrangement changes. It is therefore recommended that the <code><a class="el" href="classCGAL_1_1Arr__landmarks__point__location.html">Arr_landmarks_point_location</a></code> class template be used when the application frequently issues point-location queries on an arrangement that only seldom changes. If the arrangement is more dynamic and is frequently going through changes, the <code><a class="el" href="classCGAL_1_1Arr__trapezoid__ric__point__location.html">Arr_trapezoid_ric_point_location</a></code> class template should be the selected point-location strategy.</p>
<h2><a class="anchor" id="arr_sssecpl_ex"></a>
An Example</h2>
<p><a class="anchor" id="fig__arr_figex_8"></a></p><div class="image">
<img src="ex_5.png" alt="ex_5.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_8">Figure 34.7</a> The arrangement of line segments, as constructed in <code>point_location_example.cpp</code>, <code>vertical_ray_shooting.cpp</code>, and <code>batched_point_location.cpp</code>. The arrangement vertices are drawn as small discs, while the query points \( q_1, \ldots, q_6\) are marked with crosses.  </div>  <br />

<p>The program listed below constructs a simple arrangement of five line segments that form a pentagonal face, with a single isolated vertex in its interior, as depicted in <a class="el" href="index.html#fig__arr_figex_5">Figure 34.6</a>. Notice that we use the same arrangement structure in the next three example programs. The arrangement construction is performed by the function <code>construct_segment_arr()</code> defined in the header file <code>point_location_utils.h</code>. (Its listing is omitted here.) The program employs the naive and the landmark strategies to issue several point-location queries on this arrangement.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2point_location_example_8cpp-example.html">Arrangement_on_surface_2/point_location_example.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Answering point-location queries.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_naive_point_location.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_landmarks_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "point_location_utils.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span>                                                     Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;Number_type&gt;</a>                     Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                      Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                       Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                           Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__naive__point__location.html">CGAL::Arr_naive_point_location&lt;Arrangement_2&gt;</a>           Naive_pl;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__landmarks__point__location.html">CGAL::Arr_landmarks_point_location&lt;Arrangement_2&gt;</a>       Landmarks_pl;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the arrangement.</span></div><div class="line">  Arrangement_2    arr;</div><div class="line">  Naive_pl         naive_pl(arr);</div><div class="line">  construct_segments_arr(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform some point-location queries using the naive strategy.</span></div><div class="line">  point_location_query (naive_pl, Point_2(1, 4));        <span class="comment">// q1</span></div><div class="line">  point_location_query (naive_pl, Point_2(4, 3));        <span class="comment">// q2</span></div><div class="line">  point_location_query (naive_pl, Point_2(6, 3));        <span class="comment">// q3</span></div><div class="line"></div><div class="line">  <span class="comment">// Attach the landmarks object to the arrangement and perform queries.</span></div><div class="line">  Landmarks_pl landmarks_pl;</div><div class="line">  landmarks_pl.attach(arr);</div><div class="line">  point_location_query (landmarks_pl, Point_2(3, 2));    <span class="comment">// q4</span></div><div class="line">  point_location_query (landmarks_pl, Point_2(5, 2));    <span class="comment">// q5</span></div><div class="line">  point_location_query (landmarks_pl, Point_2(1, 0));    <span class="comment">// q6</span></div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Note that the program uses the <code>locate_point()</code> function template to locate a point and nicely print the result of each query; see <a class="el" href="index.html#lst_pl">here</a>.</p>
<h2><a class="anchor" id="arr_ssecray_shoot"></a>
Vertical Ray Shooting</h2>
<p>Another important query issued on arrangements is the vertical ray-shooting query: Given a query point, which arrangement feature do we encounter by a vertical ray shot upward (or downward) from this point? In the general case the ray hits an edge, but it is possible that it hits a vertex, or that the arrangement does not have any vertex or edge lying directly above (or below) the query point.</p>
<p>All point-location classes listed in the previous section are also models of the <code><a class="el" href="classArrangementVerticalRayShoot__2.html" title="A model of the ArrangementVerticalRayShoot_2 concept can answer vertical ray-shooting queries on an a...">ArrangementVerticalRayShoot_2</a></code> concept. That is, they all have member functions called <code>ray_shoot_up(q)</code> and <code>ray_shoot_down(q)</code> that accept a query point <code>q</code>. These functions output an object of type type <code><a class="el" href="structCGAL_1_1Arr__point__location__result.html" title="A unary metafunction to determine the return type of a point-location or vertical ray-shoot query...">Arr_point_location_result</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;::Type</code>a discriminated union container of the bounded types <code>Vertex_const_handle</code>, <code>Halfedge_const_handle</code>, or <code>Face_const_handle</code>. The latter type is used for the unbounded face of the arrangement, in case there is no edge or vertex lying directly above (or below) <code>q</code>.</p>
<p>The function template <code>vertical_ray_shooting_query()</code> listed below accepts a vertical ray-shooting object, the type of which models the <code><a class="el" href="classArrangementVerticalRayShoot__2.html" title="A model of the ArrangementVerticalRayShoot_2 concept can answer vertical ray-shooting queries on an a...">ArrangementVerticalRayShoot_2</a></code> concept. It exports the result of the upward vertical ray-shooting operation from a given query point to the standard output-stream. The ray-shooting object <code>vrs</code> is assumed to be already attached to an arrangement. The function template is defined in the header file `point_location_utils.h.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RayShoot&gt;</div><div class="line"><span class="keywordtype">void</span> shoot_vertical_ray(<span class="keyword">const</span> RayShoot&amp; vrs,</div><div class="line">                       <span class="keyword">const</span> <span class="keyword">typename</span> RayShoot::Arrangement_2::Point_2&amp; q)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> RayShoot                                      Vertical_ray_shooting;</div><div class="line"></div><div class="line">  <span class="comment">// Perform the point-location query.</span></div><div class="line">  <span class="keyword">typename</span> Vertical_ray_shooting::result_type obj = vrs.ray_shoot_up(q);</div><div class="line"></div><div class="line">  <span class="comment">// Print the result.</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Vertical_ray_shooting::Arrangement_2 Arrangement_2;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement_2::Vertex_const_handle   Vertex_const_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement_2::Halfedge_const_handle Halfedge_const_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement_2::Face_const_handle     Face_const_handle;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Vertex_const_handle*   v;</div><div class="line">  <span class="keyword">const</span> Halfedge_const_handle* e;</div><div class="line">  <span class="keyword">const</span> Face_const_handle*     f;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Shooting up from ("</span> &lt;&lt; q &lt;&lt; <span class="stringliteral">") : "</span>;</div><div class="line">  <span class="keywordflow">if</span> (v = boost::get&lt;Vertex_const_handle&gt;(&amp;obj))         <span class="comment">// we hit a vertex</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"hit "</span> &lt;&lt; (((*v)-&gt;is_isolated()) ? <span class="stringliteral">"an isolated"</span> : <span class="stringliteral">"a"</span>)</div><div class="line">              &lt;&lt; <span class="stringliteral">" vertex: "</span> &lt;&lt; (*v)-&gt;point() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e = boost::get&lt;Halfedge_const_handle&gt;(&amp;obj))  <span class="comment">// we hit an edge</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"hit an edge: "</span> &lt;&lt; (*e)-&gt;curve() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f = boost::get&lt;Face_const_handle&gt;(&amp;obj)) \{    <span class="comment">// we hit nothing</span></div><div class="line">    CGAL_assertion((*f)-&gt;is_unbounded());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"hit nothing."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> CGAL_error();</div><div class="line">}</div></div><!-- fragment --><p>The program below uses the function template listed above to perform vertical ray-shooting queries on an arrangement. The arrangement and the query points are exactly the same as in <code>point_location.cpp</code>; see <a class="el" href="index.html#fig__arr_figex_5">Figure 34.6</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2vertical_ray_shooting_8cpp-example.html">Arrangement_on_surface_2/vertical_ray_shooting.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Answering vertical ray-shooting queries.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_walk_along_line_point_location.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_trapezoid_ric_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "point_location_utils.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">CGAL::MP_Float</a>                                          Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                            Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                      Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                       Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                           Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__walk__along__line__point__location.html">CGAL::Arr_walk_along_line_point_location&lt;Arrangement_2&gt;</a> Walk_pl;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__trapezoid__ric__point__location.html">CGAL::Arr_trapezoid_ric_point_location&lt;Arrangement_2&gt;</a>   Trap_pl;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the arrangement.</span></div><div class="line">  Arrangement_2    arr;</div><div class="line">  Walk_pl          walk_pl (arr);</div><div class="line">  Trap_pl          trap_pl;</div><div class="line"></div><div class="line">  construct_segments_arr (arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform some vertical ray-shooting queries using the walk strategy.</span></div><div class="line">  Point_2          q1 (1, 4);</div><div class="line">  Point_2          q2 (4, 3);</div><div class="line">  Point_2          q3 (6, 3);</div><div class="line"></div><div class="line">  vertical_ray_shooting_query (walk_pl, q1);</div><div class="line">  vertical_ray_shooting_query (walk_pl, q2);</div><div class="line">  vertical_ray_shooting_query (walk_pl, q3);</div><div class="line"></div><div class="line">  <span class="comment">// Attach the trapezoid-RIC object to the arrangement and perform queries.</span></div><div class="line">  Point_2          q4 (3, 2);</div><div class="line">  Point_2          q5 (5, 2);</div><div class="line">  Point_2          q6 (1, 0);</div><div class="line"></div><div class="line">  trap_pl.attach (arr);</div><div class="line">  vertical_ray_shooting_query (trap_pl, q4);</div><div class="line">  vertical_ray_shooting_query (trap_pl, q5);</div><div class="line">  vertical_ray_shooting_query (trap_pl, q6);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The number type we use in this example is <span style="font-variant: small-caps;">CGAL</span>'s built-in <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">MP_Float</a></code> type, which is a floating-point number with an unbounded mantissa and a 32-bit exponent. It supports construction from an integer or from a machine <code>float</code> or <code>double</code> and performs additions, subtractions and multiplications in an exact number.</p>
<h2><a class="anchor" id="arr_ssecbatched_pl"></a>
Batched Point-Location</h2>
<p>Suppose that at a given moment our application has to issue a relatively large number \( m\) of point-location queries on a specific arrangement object. Naturally, It is possible to define a point-location object and use it to issue separate queries on the arrangement. However, as explained in Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a> choosing a simple point-location strategy (either the naive or the walk strategy) means inefficient queries, while the more sophisticated strategies need to construct auxiliary structures that incur considerable overhead in running time.</p>
<p>Alternatively, the <em>2D Arrangement</em> package includes a free <code><a class="el" href="group__PkgArrangement2PointLocation.html#ga81a8e48ebfc5a10a040f3b7d94a4c97d" title="Performs a batched point-location operation on a given arrangement. ">locate()</a></code> function that accepts an arrangement and a range of query points as its input and sweeps through the arrangement to locate all query points in one pass. The function outputs the query results as pairs, where each pair consists of a query point and a discriminated union container, which represents the cell containing the point; see Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>. The output pairs are sorted in increasing $xy$-lexicographical order of the query point.</p>
<p>The batched point-location operation is carried out by sweeping the arrangement. Thus, it takes \( O((m+N)\log{(m+N)}) \) time, where \( N \) is the number of edges in the arrangement. Issuing separate queries exploiting a point-location strategy with logarithmic query time per query, such as the trapezoidal map RIC strategy (see Section <a class="el" href="index.html#arr_sssecpl_strat">Choosing a Point-Location Strategy</a>), is asymptotically more efficient. However, experiments show that when the number \( m \) of point-location queries is of the same order of magnitude as \( N\), the batched point-location operation is more efficient in practice. One of the reasons for the inferior performance of the alternative (asymptotically faster) procedures is the necessity to construct and maintain complex additional data structures.</p>
<p>The program below issues a batched point-location query, which is essentially equivalent to the six separate queries performed in <code>point_location_example.cpp</code>; see Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2batched_point_location_8cpp-example.html">Arrangement_on_surface_2/batched_point_location.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Answering a batched point-location query.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_batched_point_location.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "point_location_utils.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>              Traits;</div><div class="line"><span class="keyword">typedef</span> Traits::Point_2                                 Point;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits&gt;</a>                     Arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Arr__point__location__result.html">CGAL::Arr_point_location_result&lt;Arrangement&gt;</a>    Point_location_result;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Point_location_result::Type&gt;   Query_result;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Arrangement::Vertex_const_handle                Vertex_const_handle;</div><div class="line"><span class="keyword">typedef</span> Arrangement::Halfedge_const_handle              Halfedge_const_handle;</div><div class="line"><span class="keyword">typedef</span> Arrangement::Face_const_handle                  Face_const_handle;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the arrangement.</span></div><div class="line">  Arrangement arr;</div><div class="line">  construct_segments_arr(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform a batched point-location query.</span></div><div class="line">  std::list&lt;Point&gt; points;</div><div class="line">  points.push_back(Point(1, 4));</div><div class="line">  points.push_back(Point(4, 3));</div><div class="line">  points.push_back(Point(6, 3));</div><div class="line">  points.push_back(Point(3, 2));</div><div class="line">  points.push_back(Point(5, 2));</div><div class="line">  points.push_back(Point(1, 0));</div><div class="line">  std::list&lt;Query_result&gt; results;</div><div class="line">  <a class="code" href="group__PkgArrangement2PointLocation.html#ga81a8e48ebfc5a10a040f3b7d94a4c97d">locate</a>(arr, points.begin(), points.end(), std::back_inserter(results));</div><div class="line"></div><div class="line">  <span class="comment">// Print the results.</span></div><div class="line">  std::list&lt;Query_result&gt;::const_iterator it;</div><div class="line">  <span class="keywordflow">for</span> (it = results.begin(); it != results.end(); ++it) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The point ("</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">") is located "</span>;</div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">const</span> Face_const_handle* f =</div><div class="line">        boost::get&lt;Face_const_handle&gt;(&amp;(it-&gt;second)))       <span class="comment">// inside a face</span></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"inside "</span></div><div class="line">                &lt;&lt; (((*f)-&gt;is_unbounded()) ? <span class="stringliteral">"the unbounded"</span> : <span class="stringliteral">"a bounded"</span>)</div><div class="line">                &lt;&lt; <span class="stringliteral">" face."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> Halfedge_const_handle* e =</div><div class="line">             boost::get&lt;Halfedge_const_handle&gt;(&amp;(it-&gt;second))) <span class="comment">// on an edge</span></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"on an edge: "</span> &lt;&lt; (*e)-&gt;curve() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> Vertex_const_handle* v =</div><div class="line">             boost::get&lt;Vertex_const_handle&gt;(&amp;(it-&gt;second)))  <span class="comment">// on a vertex</span></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"on "</span></div><div class="line">                &lt;&lt; (((*v)-&gt;is_isolated()) ? <span class="stringliteral">"an isolated"</span> : <span class="stringliteral">"a"</span>)</div><div class="line">                &lt;&lt; <span class="stringliteral">" vertex: "</span> &lt;&lt; (*v)-&gt;point() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="arr_secgl_funcs"></a>
Free Functions in the Arrangement Package</h1>
<p>In Section <a class="el" href="index.html#arr_secarr_class">The Main Arrangement Class</a> we reviewed in details the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class, which represents two-dimensional subdivisions induced by planar curves, and mentioned that its interface is minimal in the sense that the member functions hardly perform any geometric algorithms and are mainly used for maintaining the topological structure of the subdivision. In this section we explain how to utilize the free (global) functions that operate on arrangements. The implementation of these operations typically require non-trivial geometric algorithms or load some extra requirements on the traits class.</p>
<h2><a class="anchor" id="arr_ssecinc_insert"></a>
Incremental Insertion Functions</h2>
<h2><a class="anchor" id="arr_sssecinsert_non_x"></a>
Inserting Non-Intersecting Curves</h2>
<p>In Section <a class="el" href="index.html#arr_secarr_class">The Main Arrangement Class</a> we explained how to construct arrangements of \( x\)-monotone curves that are pairwise disjoint in their interior, when the location of the segment endpoints in the arrangement is known. Here we relax this constraint, and allow the location of the inserted \( x\)-monotone curve endpoints to be arbitrary, as it may be unknown at the time of insertion. We retain, for the moment, the requirement that the interior of the inserted curve is disjoint from all existing arrangement edges and vertices.</p>
<p>The free function <code>insert_non_intersecting_curve(arr, c, pl)</code> inserts the \( x\)-monotone curve \( c\) into the arrangement <code>arr</code>, with the precondition that the interior of \( c\) is disjoint from all <code>arr</code>'s existing edges and vertices. The third argument <code>pl</code> is a point-location object attached to the arrangement, which is used for performing the insertion. It locates both curve endpoints in the arrangement, where each endpoint is expected to either coincide with an existing vertex or lie inside a face. It is possible to invoke one of the specialized insertion functions (see Section <a class="el" href="index.html#arr_secarr_class">The Main Arrangement Class</a>), based on the query results, and insert \( c\) at its proper position.<span class="footnote">The <code><a class="el" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225" title="Inserts a given -monotone curve into a given arrangement, where the interior of the given curve is di...">insert_non_intersecting_curve()</a></code> function, as all other functions reviewed in this section, is a function template, parameterized by an arrangement class and a point-location class (a model of the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept).</span> The insertion operation thus hardly requires any geometric operations on top on the ones needed to answer the point-location queries. Moreover, it is sufficient that the arrangement class is instantiated with a traits class that models the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept (or the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept, if the landmark point-location strategy is used), which does not have to support the computation of intersection points between curves.</p>
<p>The variant <code>insert_non_intersecting_curve(arr, c)</code> is also available. Instead of accepting a user-defined point-location object, it defines a local instance of the walk point-location class and uses it to insert the curve.</p>
<h2><a class="anchor" id="arr_sssecinsert_x_mon"></a>
Inserting x-Monotone Curves</h2>
<p>The <code><a class="el" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225" title="Inserts a given -monotone curve into a given arrangement, where the interior of the given curve is di...">insert_non_intersecting_curve()</a></code> function is very efficient, but its preconditions on the input curves are still rather restricting. Let us assume that the arrangement is instantiated with a traits class that models the refined <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept and supports intersection computations (see Section <a class="el" href="index.html#arr_sectraits">Traits Classes</a> for the exact details). Given an \( x\)-monotone curve, it is sufficient to locate its left endpoint in the arrangement and to trace its <em>zone</em>, namely the set of arrangement features crossing the curve, until the right endpoint is reached. Each time the new curve \( c\) crosses an existing vertex or an edge, the curve is split into subcurves (in the latter case, we have to split the curve associated with the existing halfedge as well) and associate new edges with the resulting subcurves. Recall that an edge is represented by a pair of twin halfedges, so we split it into two halfedge pairs.</p>
<p>The free function <code>insert(arr, c, pl)</code> performs this insertion operation. It accepts an \( x\)-monotone curve \( c\), which may intersect some of the curves already in the arrangement <code>arr</code>, and inserts it into the arrangement by computing its zone. Users may supply a point-location object <code>pl</code>, or use the default walk point-location strategy (namely, the variant <code>insert(arr, c)</code> is also available). The running-time of this insertion function is proportional to the complexity of the zone of the curve \( c\).</p>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>In some cases users may have a prior knowledge of the location of the left endpoint of the \( x\)-monotone curve <code>c</code> they wish to insert, so they can perform the insertion without issuing any point-location queries. This can be done by calling <code>insert(arr, c, obj)</code>, where <code>obj</code> is an object represents the location of <code>c</code>'s left endpoint in the arrangement - namely it wraps a <code>Vertex_const_handle</code>, a <code>Halfedge_const_handle</code> or a <code>Face_const_handle</code> (see also Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>).  </p></div> 
<h2><a class="anchor" id="arr_sssecinsert_gen"></a>
Inserting General Curves</h2>
<p>So far all our examples were of arrangements of line segments, where the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> template was instantiated with the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> class. In this case, the fact that <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code> accepts an \( x\)-monotone curve does not seem to be a restriction, as all line segments are \( x\)-monotone (note that we consider vertical line segments to be <em>weakly</em> \( x\)-monotone).</p>
<p>Suppose that we construct an arrangement of circles. A circle is obviously not \( x\)-monotone, so we cannot insert it in the same way we inserted \( x\)-monotone curves. <span class="footnote">Note that a key operation performed by <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code> is to locate the left endpoint of the curve in the arrangement. A circle, however, does not have any endpoints!</span> However, it is possible to subdivide each circle into two \( x\)-monotone circular arcs (its upper half and its lower half) and to insert each \( x\)-monotone arc separately.</p>
<p>The free function <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code> also supports general curve and not necessarily \( x\)-monotone curves. In this case it requires that the traits class used by the arrangement <code>arr</code> to be a model of the concept <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code>, which refines the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept. It has to define an additional <code>Curve_2</code> type (which may differ from the <code>X_monotone_curve_2</code> type), and support the subdivision of curves of this new type into \( x\)-monotone curves (see the exact details in Section <a class="el" href="index.html#arr_sectraits">Traits Classes</a>). The <code>insert(arr, c, pl)</code> function performs the insertion of the curve \( c\), which does not need to be \( x\)-monotone, into the arrangement by subdividing it (if needed) into \( x\)-monotone subcurves and inserting each one separately. Users may supply a point-location object <code>pl</code>, or use the default walk point-location strategy by calling <code>insert(arr, c)</code>.</p>
<h2><a class="anchor" id="arr_sssecinsert_point"></a>
Inserting Points</h2>
<p>The arrangement class enables us to insert a point as an isolated vertex in a given face. The free function <code>insert_point(arr, p, pl)</code> inserts a vertex into <code>arr</code> that corresponds to the point <code>p</code> at an arbitrary location. It uses the point-location object <code>pl</code> to locate the point in the arrangement (by default, the walk point-location strategy is used), and acts according to the result as follows: </p><ul>
<li>
If <code>p</code> is located inside a face, it is inserted as an isolated vertex inside this face. </li>
<li>
If <code>p</code> lies on an edge, the edge is split to create a vertex associated with <code>p</code>. </li>
<li>
Otherwise, <code>p</code> coincides with an existing vertex and we are done. </li>
</ul>
<p>In all cases, the function returns a handle to the vertex associated with <code>p</code>.</p>
<p>The arrangement <code>arr</code> should be instantiated with a traits class that models the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept, as the insertion operation may involve splitting curves.</p>
<h2><a class="anchor" id="arr_sssecinsert_ex"></a>
An Example</h2>
<p><a class="anchor" id="fig__arr_figex_10"></a></p><div class="image">
<img src="ex_8.png" alt="ex_8.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_10">Figure 34.8</a> An arrangement of five intersecting line segments, as constructed in <code>incremental_insertion.cpp</code> and <code>aggregated_insertion.cpp</code>. The segment endpoints are marked by black disks and the arrangement vertices that correspond to intersection points are marked by circles. The query point \( q\) is marked with a cross and the face that contains it is shaded.  </div>  <br />

<p>The program below constructs an arrangement of intersecting line-segments. We know that \( s_1\) and \( s_2\) do not intersect, so we use <code><a class="el" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225" title="Inserts a given -monotone curve into a given arrangement, where the interior of the given curve is di...">insert_non_intersecting_curve()</a></code> to insert them into the empty arrangement. The rest of the segments are inserted using <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code>. The resulting arrangement consists of \( 13\) vertices, \( 16\) edges, and \( 5\) faces, as can be seen in <a class="el" href="index.html#fig__arr_figex_8">Figure 34.7</a>.</p>
<p>In the earlier examples, all arrangement vertices corresponded to segment endpoints. In this example we have additional vertices that correspond to intersection points between two segments. The coordinates of these intersection points are rational numbers, if the input coordinates are rational (or integer). Therefore, the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a>&lt;int&gt;</code> number type is used to represent the coordinates:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2incremental_insertion_8cpp-example.html">Arrangement_on_surface_2/incremental_insertion.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the global incremental insertion functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Quotient_8h.html">CGAL/Quotient.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_walk_along_line_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">CGAL::Quotient&lt;int&gt;</a>                                     Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                            Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                      Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                       Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                            Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                           Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__walk__along__line__point__location.html">CGAL::Arr_walk_along_line_point_location&lt;Arrangement_2&gt;</a> Walk_pl;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the arrangement of five intersecting segments.</span></div><div class="line">  Arrangement_2  arr;</div><div class="line">  Walk_pl        pl(arr);</div><div class="line"></div><div class="line">  Segment_2      s1(Point_2(1, 0), Point_2(2, 4));</div><div class="line">  Segment_2      s2(Point_2(5, 0), Point_2(5, 5));</div><div class="line">  Segment_2      s3(Point_2(1, 0), Point_2(5, 3));  </div><div class="line">  Segment_2      s4(Point_2(0, 2), Point_2(6, 0));</div><div class="line">  Segment_2      s5(Point_2(3, 0), Point_2(5, 5));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, s1, pl);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, s2, pl);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s3, pl);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s4, pl);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s5, pl);</div><div class="line"></div><div class="line">  <span class="comment">// Print the size of the arrangement.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Perform a point-location query on the resulting arrangement and print</span></div><div class="line">  <span class="comment">// the boundary of the face that contains it.</span></div><div class="line">  Point_2 q(4, 1);</div><div class="line">  Walk_pl::result_type obj = pl.locate(q);</div><div class="line">  </div><div class="line">  Arrangement_2::Face_const_handle  f;</div><div class="line">  CGAL_assertion_code(<span class="keywordtype">bool</span> success =) <a class="code" href="namespaceCGAL.html">CGAL</a>::assign(f, obj);</div><div class="line"></div><div class="line">  CGAL_assertion(success);</div><div class="line">  <a class="code" href="namespacestd.html">std</a>::cout &lt;&lt; "The query point (" &lt;&lt; q &lt;&lt; ") is located in: ";</div><div class="line">  print_face&lt;Arrangement_2&gt;(f);</div><div class="line"></div><div class="line">  return 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssseczone"></a>
Other Zone Related Functions</h2>
<p>In this section we have described so far free functions that insert curves and points to a given arrangement. Now we will describe functions that don't insert curves or points to an arrangement nor do they change the arrangement, but they are closely related to the incremental insertion functions as they also use the zone algorithm.</p>
<p>The free function <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__do__intersect__linear__grp.html#ga9514a218a097ac392d21775368d3dd0d">do_intersect()</a></code> checks if a given curve or \( x\)-monotone curve intersects an existing arrangement's edges or vertices. If the give curve is not an \( x\)-monotone curve then the function subdivides the given curve into \( x\)-monotone subcurves and isolated vertices . Each subcurve is in turn checked for intersection. The function uses the zone algorithm to check if the curve intersects the arrangement. First, the curve's left endpoint is located. Then, its zone is computed starting from its left endpoint location. The zone computation terminates when an intersection with an arrangement's edge/vertex is found or when the right endpoint is reached. A given point-location object is used for locating the left endpoint of the given curve in the existing arrangement. By default, the function uses the "walk along line" point-location strategy - namely an instance of the class <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a></code>. If the given curve is \( x\)-monotone then the traits class must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept. If the curve is not \( x\)-monotone curve then the traits class must model the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> concept.</p>
<p>The <code><a class="el" href="group__PkgArrangement2Funcs.html#ga49aa156968945f5533a2b5d9897ca659" title="Compute the zone of the given -monotone curve in the existing arrangement. ">zone()</a></code> function computes the zone of a given \( x\)-monotone curve in a given arrangement. Meaning, it outputs all the arrangement's elements (vertices, edges and faces) that the \( x\)-monotone curve intersects in the order that they are discovered when traversing the \( x\)-monotone curve from left to right. The function uses a given point-location object to locate the left endpoint of the given \( x\)-monotone curve. By default, the function uses the "walk along line" point-location strategy. The function requires that the traits class will model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept.</p>
<h2><a class="anchor" id="arr_ssecagg_insert"></a>
Aggregated Insertion Functions</h2>
<p>Let us assume that we have to insert a set of \( m\) input curves into an arrangement. It is possible to do this incrementally, inserting the curves one by one, as shown in the previous section. However, the arrangement package provides three free functions that aggregately insert a range of curves into an arrangement: </p><ul>
<li>
<code>insert_non_intersecting_curves(arr, begin, end)</code> inserts a range of \( x\)-monotone curves given by the input iterators <code>[begin, end)</code> into an arrangement <code>arr</code>. The \( x\)-monotone curves should be pairwise disjoint in their interior and also interior-disjoint from all existing edges and vertices of <code>arr</code>. </li>
<li>
<code>insert(arr, begin, end)</code> inserts a range of general (not necessarily \( x\)-monotone) curves of type <code>Curve_2</code> or <code>X_monotone_curve_2</code> that may intersect one another, given by the input iterators <code>[begin, end)</code>, into the arrangement <code>arr</code>. </li>
</ul>
<p>We distinguish between two cases: (i) The given arrangement <code>arr</code> is empty (has only an unbounded face), so we have to construct it from scratch. (ii) We have to insert \( m\) input curves to a non-empty arrangement <code>arr</code>.</p>
<p>In the first case, we sweep over the input curves, compute their intersection points and construct the <span style="font-variant: small-caps;">Dcel</span> that represents their planar arrangement. This process is performed in \( O\left((m + k)\log m\right)\) time, where \( k\) is the total number of intersection points. The running time is asymptotically better than the time needed for incremental insertion, if the arrangement is relatively sparse (when \( k\) is bounded by \( \frac{m^2}{\log m}\)), but in practice it is recommended to use this aggregated construction process even for dense arrangements, since the sweep-line algorithm needs less geometric operations compared to the incremental insertion algorithms and hence typically runs much faster in practice.</p>
<p>Another important advantage the aggregated insertion functions have is that they do not issue point-location queries. Thus, no point-location object needs to be attached to the arrangement. As explained in Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>, there is a trade-off between construction time and query time in each of the point-location strategies, which affects the running times of the incremental insertion process. Naturally, this trade-off is irrelevant in case of aggregated insertion as above.</p>
<p>The example below shows how to construct the arrangement of line segments depicted in <a class="el" href="index.html#fig__arr_figex_8">Figure 34.7</a> and built incrementally in <code>incremental_insertion.cpp</code>, as shown in the previous section. We use the aggregated insertion function <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code> as we deal with line segments. Note that no point-location object needs to be defined and attached to the arrangement:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2aggregated_insertion_8cpp-example.html">Arrangement_on_surface_2/aggregated_insertion.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the global aggregated insertion functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Quotient_8h.html">CGAL/Quotient.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">CGAL::Quotient&lt;int&gt;</a>                           Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>            Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                  Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                 Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the arrangement of five intersecting segments.</span></div><div class="line">  Arrangement_2 arr;</div><div class="line">  std::list&lt;Segment_2&gt; segments;</div><div class="line"></div><div class="line">  segments.push_back(Segment_2(Point_2(1, 0), Point_2(2, 4)));</div><div class="line">  segments.push_back(Segment_2(Point_2(5, 0), Point_2(5, 5)));</div><div class="line">  segments.push_back(Segment_2(Point_2(1, 0), Point_2(5, 3)));</div><div class="line">  segments.push_back(Segment_2(Point_2(0, 2), Point_2(6, 0)));</div><div class="line">  segments.push_back(Segment_2(Point_2(3, 0), Point_2(5, 5)));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, segments.begin(), segments.end());</div><div class="line"></div><div class="line">  <span class="comment">// Print the size of the arrangement.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>In case we have to insert a set of \( m\) curves into an existing arrangement, where we denote the number of edges in the arrangement by \( N\). As a rule of thumb, if \( m = o(\sqrt{N})\), we insert the curves one by one. For larger input sets, we use the aggregated insertion procedures.</p>
<p><a class="anchor" id="fig__arr_figex_unb1"></a></p><div class="image">
<img src="ex_10.png" alt="ex_10.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_unb1">Figure 34.9</a> An arrangement of intersecting line segments, as constructed in <code>global_insertion.cpp</code>. The segments of \( {\mathcal S}_1\) are drawn in solid lines and the segments of \( {\mathcal S}_2\) are drawn in dark dashed lines. Note that the segment \( s\) (light dashed line) overlaps one of the segments in \( {\mathcal S}_1\).  </div>  <br />

<p>In the example below we aggregately construct an arrangement of a set \( {\mathcal S}_1\) containing five line segments. Then we insert a single segment using the incremental insertion function. Finally, we add a set \( {\mathcal S}_2\) with five more line segments in an aggregated fashion. Notice that the line segments of \( {\mathcal S}_1\) are pairwise interior-disjoint, so we use <code><a class="el" href="group__PkgArrangement2Funcs.html#gad4aa37a4e938747028690579fb703d67" title="Inserts a set of -monotone curves in a given range into a given arrangement. ">insert_non_intersecting_curves()</a></code>. \( {\mathcal S}_2\) also contain pairwise interior-disjoint segments, but as they intersect the existing arrangement, we have to use <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code> to insert them. Also note that the single segment \( s\) we insert incrementally overlaps an existing arrangement edge:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2global_insertion_8cpp-example.html">Arrangement_on_surface_2/global_insertion.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the global insertion functions (incremental and aggregated).</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Quotient_8h.html">CGAL/Quotient.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_naive_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">CGAL::Quotient&lt;CGAL::MP_Float&gt;</a>                Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>            Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                  Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                 Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__naive__point__location.html">CGAL::Arr_naive_point_location&lt;Arrangement_2&gt;</a> Naive_pl;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the arrangement of five intersecting segments.</span></div><div class="line">  Arrangement_2     arr;</div><div class="line">  Segment_2         S1 [5];</div><div class="line"></div><div class="line">  S1[0] = Segment_2 (Point_2 (1, 2.5), Point_2 (4, 5));</div><div class="line">  S1[1] = Segment_2 (Point_2 (1, 2.5), Point_2 (6, 2.5));</div><div class="line">  S1[2] = Segment_2 (Point_2 (1, 2.5), Point_2 (4, 0));  </div><div class="line">  S1[3] = Segment_2 (Point_2 (4, 5), Point_2 (6, 2.5));</div><div class="line">  S1[4] = Segment_2 (Point_2 (4, 0), Point_2 (6, 2.5));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad4aa37a4e938747028690579fb703d67">insert_non_intersecting_curves</a> (arr, S1, S1 + 5);</div><div class="line"></div><div class="line">  <span class="comment">// Perform an incremental insertion of a single overlapping segment.</span></div><div class="line">  Naive_pl          pl (arr);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Segment_2 (Point_2 (0, 2.5), Point_2 (4, 2.5)), pl);</div><div class="line"></div><div class="line">  <span class="comment">// Aggregately insert an additional set of five segments.</span></div><div class="line">  Segment_2         S2 [5];</div><div class="line"></div><div class="line">  S2[0] = Segment_2 (Point_2 (0, 4), Point_2 (6, 5));</div><div class="line">  S2[1] = Segment_2 (Point_2 (0, 3), Point_2 (6, 4));</div><div class="line">  S2[2] = Segment_2 (Point_2 (0, 2), Point_2 (6, 1));</div><div class="line">  S2[3] = Segment_2 (Point_2 (0, 1), Point_2 (6, 0));</div><div class="line">  S2[4] = Segment_2 (Point_2 (6, 1), Point_2 (6, 4));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, S2, S2 + 5);</div><div class="line"></div><div class="line">  <span class="comment">// Print the size of the arrangement.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges() </div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The number type used in the example above, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">MP_Float</a>&gt;</code>, is comprised of a numerator and a denominator of type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">MP_Float</a></code>, namely floating-point numbers with unbounded mantissa. This number type is therefore capable of exactly computing the intersection points as long as the segment endpoints are given as floating-point numbers.</p>
<h2><a class="anchor" id="arr_ssecgl_remove"></a>
Removing Vertices and Edges</h2>
<p>The free functions <code><a class="el" href="group__PkgArrangement2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778" title="Attempts to removed a given vertex from a given arrangement. ">remove_vertex()</a></code> and <code><a class="el" href="group__PkgArrangement2Funcs.html#ga324fdf8354e7812fe0e1c0e5ac14196c" title="Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. ">remove_edge()</a></code> handle the removal of vertices and edges from an arrangement. The difference between these functions and the member functions of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> template having the same name is that they allow the merger of two curves associated with adjacent edges to form a single edge. Thus, they require that the traits class that instantiates the arrangement instance is a model of the refined <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept (see Section <a class="el" href="index.html#arr_sectraits">Traits Classes</a>).</p>
<p>The function <code>remove_vertex(arr, v)</code> removes the vertex <code>v</code> from the given arrangement <code>arr</code>, where <code>v</code> is either an isolated vertex or is a <em>redundant</em> vertex - namely, it has exactly two incident edges that are associated with two curves that can be merged to form a single \( x\)-monotone curve. If neither of the two cases apply, the function returns an indication that it has failed to remove the vertex.</p>
<p>The function <code>remove_edge(arr, e)</code> removes the edge <code>e</code> from the arrangement by simply calling <code>arr.remove_edge(e)</code> (see Section <a class="el" href="index.html#arr_ssecmodify">Modifying the Arrangement</a>). In addition, if either of the end vertices of <code>e</code> becomes isolated or redundant after the removal of the edge, it is removed as well.</p>
<div class="image">
<img src="h_shape.png" alt="h_shape.png" />
</div>
 <p>The following example demonstrates the usage of the free removal functions. In creates an arrangement of four line segment forming an H-shape with a double horizontal line. Then it removes the two horizontal edges and clears all redundant vertices, such that the final arrangement consists of just two edges associated with the vertical line segments:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2global_removal_8cpp-example.html">Arrangement_on_surface_2/global_removal.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the global removal functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_linear_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_naive_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span>                                           Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__linear__traits__2.html">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</a>             Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                  Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                 Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#a7dac3eed2224beadf3658495bc671c49">Arrangement_2::Vertex_handle</a>                  Vertex_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#acdb9c49c90f9354f20c56efac599a7fe">Arrangement_2::Halfedge_handle</a>                Halfedge_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__naive__point__location.html">CGAL::Arr_naive_point_location&lt;Arrangement_2&gt;</a> Naive_pl;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Create an arrangement of four line segments forming an H-shape:</span></div><div class="line">  Arrangement_2   arr;</div><div class="line"></div><div class="line">  Segment_2       s1 (Point_2(1, 3), Point_2(4, 3));</div><div class="line">  Halfedge_handle e1 = arr.insert_in_face_interior (s1, arr.unbounded_face());</div><div class="line">  Segment_2       s2 (Point_2(1, 4), Point_2(4, 4));</div><div class="line">  Halfedge_handle e2 = arr.insert_in_face_interior (s2, arr.unbounded_face());</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment_2(Point_2(1, 1), Point_2(1, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment_2(Point_2(4, 1), Point_2(4, 6)));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The initial arrangement:"</span> &lt;&lt; std::endl;</div><div class="line">  print_arrangement (arr);</div><div class="line"></div><div class="line">  <span class="comment">// Remove e1 and its incident vertices using the function remove_edge().</span></div><div class="line">  Vertex_handle   v1 = e1-&gt;source(), v2 = e1-&gt;target();</div><div class="line">  arr.remove_edge(e1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778">remove_vertex</a>(arr, v1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778">remove_vertex</a>(arr, v2);</div><div class="line"></div><div class="line">  <span class="comment">// Remove e2 using the free remove_edge() function.</span></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#ga324fdf8354e7812fe0e1c0e5ac14196c">remove_edge</a> (arr, e2);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The final arrangement:"</span> &lt;&lt; std::endl;</div><div class="line">  print_arrangement (arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="arr_secunbounded"></a>
Arrangements of Unbounded Curves</h1>
<p>Previous sections dealt only with arrangements of line segments, namely of bounded curves. Such arrangements always have one unbounded face that contains all other arrangement features. This section explains how to construct arrangements of unbounded curves, such as lines and rays.</p>
<h2><a class="anchor" id="arr_ssecunb_basic"></a>
Basic Manipulation and Traversal Methods</h2>
<p>Consider the arrangement induced by the two lines \( y = x\) and \( y = -x\). These two lines intersect at the origin, such that the arrangement contains a single vertex \( v = (0,0)\), with four infinite rays emanating from it. Each ray corresponds to an arrangement edge, and these edges subdivide the plane into four unbounded faces. Consider a halfedge pair that represents one of the edges. The source vertex of one of these halfedges is \( v\) and its target is at infinity, while the other has its source at infinity and \( v\) is its target.</p>
<p>If <code>e</code> is an object of the nested type <code><a class="el" href="classCGAL_1_1Arrangement__2_1_1Halfedge.html" title="An object  of the class Halfedge represents a halfedge in the arrangement. ">Arrangement_2::Halfedge</a></code>, then the predicates <code>e.source_at_infinity()</code> and <code>e.target_at_infinity()</code> indicate whether the halfedge represents a curve with an infinite end. In general there is no need to access the source (or the target) of a halfedge if it lies at infinity, since this vertex is not associated with any valid point. Similarly, calling <code>arr.number_of_vertices()</code> for an arrangement object <code>arr</code> counts only the vertices associated with finite points, and ignores vertices at infinity (and the range <code>[vertices_begin(), vertices_end())</code> contains only finite vertices). The method <code>arr.number_of_vertices_at_infinity()</code> counts the number of vertices at infinity.</p>
<p>As mentioned above, arrangements of unbounded curves usually have more than one unbounded face. The function <code>arr.number_of_unbounded_faces()</code> returns the number of unbounded arrangement faces (Thus, <code>arr.number_of_faces() - arr.number_of_unbounded_faces()</code> is the number of bounded faces). The functions <code>arr.unbounded_faces_begin()</code> and <code>arr.unbounded_faces_end()</code> return iterators of type <code><a class="el" href="classCGAL_1_1Arrangement__2.html#ae2ea7ee0fc95f9b49fe2c090e43ed0bc" title="a bidirectional iterator over the unbounded faces of arrangement. ">Arrangement_2::Unbounded_face_iterator</a></code> that specify the range of unbounded faces. Naturally, the value-type of this iterator is <code><a class="el" href="classCGAL_1_1Arrangement__2_1_1Face.html" title="An object of the class Face represents an arrangement face, namely, a -dimensional arrangement cell...">Arrangement_2::Face</a></code>.</p>
<p>The specialized insertion functions listed in Section <a class="el" href="index.html#arr_sssecmf_insert_cv">Inserting Non-Intersecting x-Monotone Curves</a> can also be used for inserting \( x\)-monotone unbounded curves, provided that they are interior-disjoint from any subcurve that already exists in the arrangement. For example, if you wish to insert a ray \( r\) emanating from \( (0,0)\) in the direction of \( (1,0)\), to the arrangement of \( y = -x\) and \( y = x\), you can use the function <code>arr.insert_from_left_vertex()</code>, as the left endpoint of \( r\) is already associated with an arrangement vertex. Other edge-manipulation functions can also be applied on edges associated with unbounded curves.</p>
<p><a class="anchor" id="fig__arr_figunb_dcel"></a></p><div class="image">
<img src="ex_unb1.png" alt="ex_unb1.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figunb_dcel">Figure 34.10</a> An arrangement of unbounded linear objects, as constructed in unbounded_non_intersecting.cpp.  </div>  <br />

<p>The following example demonstrates the use of the insertion function for pairwise interior-disjoint unbounded curves. In this example we use the traits class <code><a class="el" href="classCGAL_1_1Arr__linear__traits__2.html" title="The traits class Arr_linear_traits_2 is a model of the ArrangementTraits_2 concept, which enables the construction and maintenance of arrangements of linear objects. ">Arr_linear_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> to instantiate the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> template. This traits class is capable of representing line segments as well as unbounded linear curves (namely lines and rays). Observe that objects of the type <code>X_monotone_curve_2</code> defined by this traits class are constructible from <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Line__2.html">Line_2</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Ray__2.html">Ray_2</a></code>, and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Segment__2.html">Segment_2</a></code> objects, as defined in the instantiated kernel.</p>
<p>The first three curves are inserted using the special insertion functions for \( x\)-monotone curves whose location in the arrangement is known. Notice that inserting an unbounded curve in the interior of an unbounded face, or from an existing vertex that represents the bounded end of the curve, may cause an unbounded face to split (this is never the case when inserting a bounded curve - compare with Section <a class="el" href="index.html#arr_sssecmf_insert_cv">Inserting Non-Intersecting x-Monotone Curves</a>). Then, three additional rays are inserted incrementally, using the insertion function for \( x\)-monotone curves whose interior is disjoint from all arrangement features. Finally, the program prints the size of the arrangement (compare to the illustration in <a class="el" href="index.html#fig__arr_figex_unb1">Figure 34.9</a>) and the outer boundaries of its six unbounded faces:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2unbounded_non_intersecting_8cpp-example.html">Arrangement_on_surface_2/unbounded_non_intersecting.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of unbounded linear objects using the insertion</span></div><div class="line"><span class="comment">// function for non-intersecting curves.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_linear_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span>                                           Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;Number_type&gt;</a>           Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__linear__traits__2.html">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</a>             Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Segment_2                           Segment_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Ray_2                               Ray_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Line_2                              Line_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                  X_monotone_curve_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                 Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#a7dac3eed2224beadf3658495bc671c49">Arrangement_2::Vertex_handle</a>                  Vertex_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#acdb9c49c90f9354f20c56efac599a7fe">Arrangement_2::Halfedge_handle</a>                Halfedge_handle;</div><div class="line"> </div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  Arrangement_2      arr;</div><div class="line"></div><div class="line">  <span class="comment">// Insert a line in the (currently single) unbounded face of the arrangement,</span></div><div class="line">  <span class="comment">// then split it into two at (0,0). Assign v to be the split point.</span></div><div class="line">  X_monotone_curve_2 c1 = Line_2 (Point_2 (-1, 0), Point_2 (1, 0));</div><div class="line">  Halfedge_handle    e1 = arr.insert_in_face_interior (c1,</div><div class="line">                                                       arr.unbounded_face());</div><div class="line"></div><div class="line">  X_monotone_curve_2 c1_left = Ray_2 (Point_2 (0, 0), Point_2 (-1, 0));</div><div class="line">  X_monotone_curve_2 c1_right = Ray_2 (Point_2 (0, 0), Point_2 (1, 0));</div><div class="line"> </div><div class="line">  e1 = arr.split_edge (e1, c1_left, c1_right);</div><div class="line">  Vertex_handle      v = e1-&gt;target();</div><div class="line"></div><div class="line">  CGAL_assertion (! v-&gt;is_at_open_boundary());</div><div class="line"></div><div class="line">  <span class="comment">// Add two more rays using the specialized insertion functions.</span></div><div class="line">  X_monotone_curve_2 c2 = Ray_2 (Point_2 (0, 0), Point_2 (-1, 1));</div><div class="line">  X_monotone_curve_2 c3 = Ray_2 (Point_2 (0, 0), Point_2 (1, 1));</div><div class="line"></div><div class="line">  arr.insert_from_right_vertex (c2, v);</div><div class="line">  arr.insert_from_left_vertex (c3, v);</div><div class="line"></div><div class="line">  <span class="comment">// Insert three more interior-disjoint rays.</span></div><div class="line">  X_monotone_curve_2 c4 = Ray_2 (Point_2 (0, -1), Point_2 (-2, -2));</div><div class="line">  X_monotone_curve_2 c5 = Ray_2 (Point_2 (0, -1), Point_2 (2, -2));</div><div class="line">  X_monotone_curve_2 c6 = Ray_2 (Point_2 (0, 0), Point_2 (0, 1));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, c4);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, c5);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, c6);</div><div class="line"></div><div class="line">  <span class="comment">// Print out the size of the resulting arrangement.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">" (plus "</span> &lt;&lt; arr.number_of_vertices_at_infinity()</div><div class="line">            &lt;&lt; <span class="stringliteral">" at infinity)"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges() </div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() </div><div class="line">            &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; arr.number_of_unbounded_faces() &lt;&lt; <span class="stringliteral">" unbounded)"</span></div><div class="line">            &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Print the outer CCBs of the unbounded faces.</span></div><div class="line">  Arrangement_2::Face_const_iterator            fit;</div><div class="line">  Arrangement_2::Ccb_halfedge_const_circulator  first, curr;</div><div class="line">  Arrangement_2::Halfedge_const_handle          he;</div><div class="line">  <span class="keywordtype">int</span>                                           k = 1;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit, k++) {</div><div class="line">    <span class="keywordflow">if</span> (! fit-&gt;is_unbounded())</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Face no. "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">": "</span>;</div><div class="line">    curr = first = fit-&gt;outer_ccb();</div><div class="line">    <span class="keywordflow">if</span> (! curr-&gt;source()-&gt;is_at_open_boundary())</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; curr-&gt;source()-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">      he = curr;</div><div class="line">      <span class="keywordflow">if</span> (! he-&gt;is_fictitious())</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"   ["</span> &lt;&lt; he-&gt;curve() &lt;&lt; <span class="stringliteral">"]   "</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"   [ ... ]   "</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (! he-&gt;target()-&gt;is_at_open_boundary())</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; he-&gt;target()-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line"></div><div class="line">      ++curr;</div><div class="line">    } <span class="keywordflow">while</span> (curr != first);</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecunb_global"></a>
Free Functions</h2>
<p>In principle, all queries and operations that relate to arrangements of bounded curves can also be applied to arrangements of unbounded curves. For example, it is possible to issue point-location and vertical ray-shooting queries (see also Section <a class="el" href="index.html#arr_secqueries">Issuing Queries on an Arrangement</a>) on arrangements of lines, where the only restriction is that the query point has finite coordinates.<span class="footnote">Currently, all point-location strategies except the trapezoidal RIC point-location strategy are capable of handling arrangements of unbounded curves.</span></p>
<p>In the following example we show how an arrangement of unbounded lines is utilized to solve the following problem: Given a set of points, does the set contain at least three collinear points? In this example a set of input points is read from a file. The file <code>points.dat</code> is used by default. It contains definitions of \( 100\) points randomly selected on the grid \( [-10000,10000]\times[-10000,10000]\). We construct an arrangement of the dual lines, where the line \( p^{*}\) dual to the point \( p = (p_x, p_y)\) is given by the equation \( y = p_x*x - p_y\), and check whether three (or more) of the dual lines intersect at a common point, by searching for a (dual) vertex, whose degree is greater than \( 4\). If such a vertex exists, then there are at least three dual lines that intersect at a common point, which implies that there are at least three collinear points.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2dual_lines_8cpp-example.html">Arrangement_on_surface_2/dual_lines.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Checking whether there are three collinear points in a given input set</span></div><div class="line"><span class="comment">// using the arrangement of the dual lines.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_linear_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__linear__traits__2.html">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</a>             Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Line_2                              Line_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                  X_monotone_curve_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                 Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div><div class="line">  <span class="comment">// points.dat file if no command-line parameters are given.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"points.dat"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Open the input file.</span></div><div class="line">  std::ifstream in_file(filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">"!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Read the points from the file, and construct their dual lines.</span></div><div class="line">  <span class="comment">// The input file format should be (all coordinate values are integers):</span></div><div class="line">  <span class="comment">// &lt;n&gt;                                 // number of point.</span></div><div class="line">  <span class="comment">// &lt;x_1&gt; &lt;y_1&gt;                         // point #1.</span></div><div class="line">  <span class="comment">// &lt;x_2&gt; &lt;y_2&gt;                         // point #2.</span></div><div class="line">  <span class="comment">//   :      :       :      :</span></div><div class="line">  <span class="comment">// &lt;x_n&gt; &lt;y_n&gt;                         // point #n.</span></div><div class="line">  std::vector&lt;Point_2&gt; points;</div><div class="line">  std::list&lt;X_monotone_curve_2&gt; dual_lines;</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> n;</div><div class="line">  in_file &gt;&gt; n;</div><div class="line">  points.resize(n);</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;</div><div class="line">  <span class="keywordflow">for</span> (k = 0; k &lt; n; ++k) {</div><div class="line">    <span class="keywordtype">int</span> px, py;</div><div class="line">    in_file &gt;&gt; px &gt;&gt; py;</div><div class="line">    points[k] = Point_2(px, py);</div><div class="line"></div><div class="line">    <span class="comment">// The line dual to the point (p_x, p_y) is y = p_x*x - p_y,</span></div><div class="line">    <span class="comment">// or: p_x*x - y - p_y = 0:</span></div><div class="line">    dual_lines.push_back(Line_2(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(px),</div><div class="line">                                <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(-1),</div><div class="line">                                <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(-py)));</div><div class="line">  }</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Construct the dual arrangement by aggregately inserting the lines.</span></div><div class="line">  Arrangement_2 arr;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, dual_lines.begin(), dual_lines.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The dual arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">" (+ "</span> &lt;&lt; arr.number_of_vertices_at_infinity()</div><div class="line">            &lt;&lt; <span class="stringliteral">" at infinity)"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces()</div><div class="line">            &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; arr.number_of_unbounded_faces()</div><div class="line">            &lt;&lt; <span class="stringliteral">" unbounded)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Look for a vertex whose degree is greater than 4.</span></div><div class="line">  Arrangement_2::Vertex_const_iterator vit;</div><div class="line">  <span class="keywordtype">bool</span> found_collinear = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    <span class="keywordflow">if</span> (vit-&gt;degree() &gt; 4) {</div><div class="line">      found_collinear = <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (found_collinear)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Found at least three collinear points in the input set."</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"No three collinear points are found in the input set."</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Pick two points from the input set, compute their midpoint and insert</span></div><div class="line">  <span class="comment">// its dual line into the arrangement.</span></div><div class="line">  Kernel ker;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> k1 = std::rand() % n, k2 = (k1 + 1) % n;</div><div class="line">  Point_2 p_mid = ker.construct_midpoint_2_object()(points[k1], points[k2]);</div><div class="line">  X_monotone_curve_2 dual_p_mid = Line_2(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(p_mid.x()),</div><div class="line">                                         <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(-1),</div><div class="line">                                         <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__cgal.html#ga0849ff44771b19582218ebdfa5614f64">CGAL::Exact_rational</a>(-p_mid.y()));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, dual_p_mid);</div><div class="line"></div><div class="line">  <span class="comment">// Make sure that we now have three collinear points.</span></div><div class="line">  found_collinear = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    <span class="keywordflow">if</span> (vit-&gt;degree() &gt; 4) {</div><div class="line">      found_collinear = <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  CGAL_assertion(found_collinear);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (0);</div><div class="line">}</div></div><!-- fragment --><p>Note that there are no three collinear points among the points defined in the input file <code>points.dat</code>. In the second part of the example the existence of collinearity is forced and verified as follows. A line dual to the midpoint of two randomly selected points is introduced, and inserted into the arrangement. This operation is followed by a test that verifies that a vertex of degree greater than \( 4\) exists. This implied that collinearity indeed exists as explained above.</p>
<h2><a class="anchor" id="arr_ssecunb_rep"></a>
Representation of Unbounded Arrangements</h2>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p><a class="anchor" id="fig__typenormal"></a></p><div class="image">
<img src="unb_dcel.png" alt="unb_dcel.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__typenormal">Figure 34.11</a> A <span style="font-variant: small-caps;">Dcel</span> representing an arrangement of four lines. Halfedges are drawn as thin arrows. The vertices \( v_1, \ldots, v_8\) lie at infinity, and are not associated with valid points. The halfedges that connect them are fictitious, and are not associated with concrete curves. The face denoted \( f_0\) (lightly shaded) is the fictitious "unbounded face" which lies outside the bounding rectangle (dashed) that bounds the actual arrangement. The four fictitious vertices \( v_{\rm bl}, v_{\rm tl}, v_{\rm br}\) and \( v_{\rm tr}\) represent the four corners of the bounding rectangle.  </div>  <br />

<p>Given a set \( \cal C\) of unbounded curves, a simple approach for representing the arrangement induced by \( \cal C\) would be to clip the unbounded curves using an axis-parallel rectangle that contains all finite curve endpoints and intersection points between curves in \( \cal C\). This process would result in a set \( \cal C\) of bounded curves (line segments if \( \cal C\) contains lines and rays), and it would be straightforward to compute the arrangement induced by this set. However, we would like to operate directly on the unbounded curves without having to preprocess them. Therefore, we use an implicit bounding rectangle embedded in the <span style="font-variant: small-caps;">Dcel</span> structure. <a class="el" href="index.html#fig__arr_figunb_dcel">Figure 34.10</a> shows the arrangement of four lines that subdivide the plane into eight unbounded faces and two bounded ones. Notice that in this case the unbounded faces have outer boundaries, and the halfedges along these outer CCBs are drawn as arrows. The bounding rectangle is drawn with a dashed line. The vertices \( v_1,v_2,\ldots,v_8\), which represent the unbounded ends of the four lines, and lie on the bounding rectangle, actually exist at infinity, and the halfedges connecting them are <em>fictitious</em>, and represent portions of the bounding rectangle. Note that the outer CCBs of the unbounded faces contain fictitious halfedges. The twins of these halfedges form together one connected component that corresponds to the entire bounding rectangle, which forms a single hole in a face \( f_0\). We say that \( f_0\) is <em>fictitious</em>, as it does not correspond to a real two-dimensional cell of the arrangement.</p>
<p>Observe that there are four extra vertices at infinity that do not lie on any curve; they are denoted as \( v_{\rm bl}, v_{\rm tl}, v_{\rm br}\), and \( v_{\rm tr}\), and represent the bottom-left, top-left, bottom-right, and top-right corners of the bounding rectangle, respectively. Similarly, there are fictitious halfedges that lie on the top, the bottom, the left, or the right edge of the bounding rectangle. When the arrangement is empty, there are exactly four pairs of fictitious halfedges, that divide the plane into two faces, namely a fictitious face lying outside of the bounding rectangle and a single unbounded face bounded by the bounding rectangle.</p>
<p>Summarizing the above, there are four types of arrangement vertices, which differ from one another by their location with respect to the bounding bounding rectangle: </p><ol>
<li>
A vertex, associated with a point in \( \mathbb{R}^2\) whose coordinates are bounded. Such a vertex always lies inside the bounding rectangle. </li>
<li>
<a class="anchor" id="typeunbounded"></a>A vertex that represents an unbounded end of an \( x\)-monotone curve that is defined at \( x = -\infty\) or at \( x = \infty\). In case of a horizontal line or a curve with a horizontal asymptote, the \( y\)-coordinate of the curve end may be finite (see for example the vertices \( v_2\) and \( v_7\) in <a class="el" href="index.html#fig__arr_figunb_dcel">Figure 34.10</a>), but in general the curve end also goes to \( y = \pm\infty\) (see for instance the vertices \( v_1\), \( v_3\), \( v_6\) and \( v_8\) in <a class="el" href="index.html#fig__arr_figunb_dcel">Figure 34.10</a>). For our convenience, we will always take a "tall" enough bounding rectangle and treat such vertices as lying on either the left or right rectangle edges (that is, if a curve is defined at \( x = -\infty\), its left end will be represented by a vertex on the left edge of the bounding rectangle, and if it is defined at \( x = \infty\), its right end will be represented by a vertex of the right edge). </li>
<li>
A<a class="anchor" id="typeunboundedvertical"></a>vertex that represent the unbounded end of a vertical line or of a curve with a vertical asymptote (finite \( x\)-coordinate and an unbounded \( y\)-coordinate). Such a vertex always lies on one of the horizontal edges of the bounding rectangle (either the bottom one if \( y = -\infty\), or the top one if \( y = \infty\)). The vertices \( v_4\) and \( v_5\) in <a class="el" href="index.html#fig__arr_figunb_dcel">Figure 34.10</a> are of this type. </li>
<li>
The<a class="anchor" id="typefictitious"></a>fictitious vertices that represent the four corners of the bounding bounding rectangle. </li>
</ol>
<p>A vertex (at infinity) of Type <a class="el" href="index.html#typeunbounded">typeunbounded</a> or Type <a class="el" href="index.html#typeunboundedvertical">typeunboundedvertical</a> above always has three incident edges: one concrete edge that is associated with an unbounded portion of an \( x\)-monotone curve, and two fictitious edges connecting the vertex to its neighboring vertices at infinity. Fictitious vertices (of type 4 above) have exactly two incident edges. See Section <a class="el" href="index.html#arr_sectraits">Traits Classes</a> on how the traits-class interface helps imposing the fact that we never have more than one curve incident to any true vertex at infinity.</p>
<p>The nested types defined in the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class support the following methods, in addition to the ones listed in Section <a class="el" href="index.html#arr_ssectraverse">Traversing the Arrangement</a> : </p><ul>
<li>
The <code>Vertex</code> class provides three-valued predicates <code>parameter_space_in_x()</code> and <code>parameter_space_in_y()</code>, which return the location of the geometric embedding of the vertex in the parameter space. In particular, the former returns <code>ARR_LEFT_BOUNDARY</code>, <code>ARR_INTERIOR</code>, or <code>ARR_RIGHT_BOUNDARY</code>, and the latter returns <code>ARR_BOTTOM_BOUNDARY</code>, <code>ARR_INTERIOR</code>, or <code>ARR_TOP_BOUNDARY</code>. As the package currently supports only the case where the parameter space is the compactified plane, the former returns <code>ARR_INTERIOR</code> if the \( x\)-coordinate associated with the vertex is finite, <code>ARR_LEFT_BOUNDARY</code> if it is \( -\infty\), and <code>ARR_RIGHT_BOUNDARY</code> if it is \( \infty\). The latter returns <code>ARR_INTERIOR</code> if the \( y\)-coordinate associated with the vertex is finite, <code>ARR_BOTTOM_BOUNDARY</code> if it is \( -\infty\), and <code>ARR_TOP_BOUNDARY</code> if it is \( \infty\). The Boolean predicate <code>is_at_open_boundary()</code> is also provided. You can access the point associated with a vertex only if it is not a vertex at an open boundary (recall that a vertex at an open boundary is not associated with a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> object). </li>
<li>
The nested <code>Halfedge</code> class provides the Boolean predicate <code>is_fictitious()</code>. The \( x\)-monotone curve associated with a halfedge can be accessed by the <code>curve()</code> method only if the halfedge is not fictitious. </li>
<li>
The nested <code>Face</code> class provides the Boolean predicate <code>f.is_fictitious()</code>. The method <code>outer_ccb()</code> has the precondition that the face is not fictitious. Note that non-fictitious unbounded faces always have valid CCBs (although this CCB may comprise only fictitious halfedge in case the arrangement contains only bounded curves). </li>
</ul>
<p>The method <code>arr.number_of_edges()</code> does not count the number of fictitious edges, (which is always <code>arr.number_of_vertices_at_infinity() + 4</code>), and the iterators returned by <code>arr.edges_begin()</code> and <code>arr.edges_end()</code> specify a range of non-fictitious edges. Similarly, <code>arr.number_of_faces()</code> does not count the fictitious face. However, the <code>Ccb_halfedge_circulator</code> of the outer boundary of an unbounded face or the <code>Halfegde_around_vertex_circulator</code> of a vertex at infinity do traverse fictitious halfedges. For example, it is possible to traverse the outer boundaries of the unbounded arrangement edges using the following procedure:</p>
<div class="fragment"><div class="line">  Arrangement_2::Unbounded_face_const_iterator fit;</div><div class="line">  Arrangement_2::Ccb_halfedge_const_circulator first, curr;</div><div class="line">  Arrangement_2::Halfedge_const_handle he;</div><div class="line">  <span class="keywordtype">int</span> k = 1;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (fit = arr.unbounded_faces_begin();</div><div class="line">       fit != arr.unbounded_faces_end(); ++fit, k++) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Unbounded face no. "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">": "</span>;</div><div class="line">    curr = first = fit-&gt;outer_ccb();</div><div class="line">    <span class="keywordflow">if</span> (! curr-&gt;source()-&gt;is_at_infinity())</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; curr-&gt;source()-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">      he = curr;</div><div class="line">      <span class="keywordflow">if</span> (! he-&gt;is_fictitious())</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; he-&gt;curve() &lt;&lt; <span class="stringliteral">"] "</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">" [ ... ] "</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (! he-&gt;target()-&gt;is_at_infinity())</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; he-&gt;target()-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line"></div><div class="line">      ++curr;</div><div class="line">    } <span class="keywordflow">while</span> (curr != first);</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>  </p></div> 
<h1><a class="anchor" id="arr_sectraits"></a>
Traits Classes</h1>
<p>As mentioned in the introduction of this chapter, the traits class encapsulates the definitions of the geometric entities and implements the geometric predicates and constructions needed by the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class and by its peripheral algorithms. We also mention throughout the chapter that there are different levels of requirements from the traits class, namely the traits class can model different concept refinement-levels.</p>
<h2><a class="anchor" id="arr_sssectr_concepts"></a>
The Hierarchy of Traits-Class Concepts</h2>
<h2><a class="anchor" id="arr_sssectr_basic_concept"></a>
The Basic Concept</h2>
<p>A model of the basic concept, <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code>, needs to define the types <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> and <code>X_monotone_curve_2</code>, where objects of the first type are the geometric mapping of arrangement vertices, and objects of the latter type are the geometric mapping of edges. Such a model has to support in addition the following set of operations: </p><dl>
<dt><b><code>Compare_x_2</code>:</b></dt>
<dd>Compares the \( x\)-coordinates of two points. </dd>
<dt><b><code>Compare_xy_2</code>:</b></dt>
<dd>Compares two points lexicographically, by their \( x\)-coordinates and then (in case of equality) by their \( y\)-coordinates. </dd>
<dt><b><code>Construct_min_vertex_2</code>,<code>Construct_max_vertex_2</code>:</b></dt>
<dd>Returns the left endpoint (similarly, the right endpoint) of an \( x\)-monotone curve. </dd>
<dt><b><code>Compare_y_at_x_2</code>:</b></dt>
<dd>Given an \( x\)-monotone curve \( c\) and a point \( p\) that lies in its \( x\)-range, this predicate determines whether \( p\) lies below, above or on \( c\). </dd>
<dt><b><code>Compare_y_at_x_right_2</code>:</b></dt>
<dd>Given two \( x\)-monotone curves \( c_1\) and \( c_2\) that share a common left endpoint \( p\), this predicate determines whether \( c_1\) lies above or under \( c_2\) immediately to the right of \( p\), or whether the two curves coincide there. </dd>
<dt><b><code>Equal_2</code>:</b></dt>
<dd>Checks two points and two curves for equality (two curves are equal if their graph is the same). </dd>
<dt><b><code>Is_vertical_2</code>:</b></dt>
<dd>Determines whether an \( x\)-monotone curve is vertical. </dd>
</dl>
<p>Each model of the concept <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> needs to define a tag named <code>Has_left_category</code>. It determines whether the traits class supports the following predicate: </p><dl>
<dt><b><code>Compare_y_at_x_left_2</code>:</b></dt>
<dd>Given two \( x\)-monotone curves \( c_1\) and \( c_2\) that share a common right endpoint \( p\), this predicate determines whether \( c_1\) lies above or under \( c_2\) immediately to the left of \( p\), or whether the two curves coincide there. </dd>
</dl>
<p>This predicate is optional, as it can be answered using the other traits-class primitives, and we wish to alleviate the need to implement an extra method that is not absolutely necessary. However, as implementing the predicate directly may prove to be more efficient, the traits-class implementer may choose to provide it.</p>
<p>The basic set of predicates is sufficient for constructing arrangements of \( x\)-monotone curves that do not reach or approach the boundary of the parameter space. The nature of the input curves, i.e., whether some of them are expected to reach or approach the left, right, bottom, or top side of the boundary of the parameter space, must be conveyed by the traits class. This is done through the definition of four additional nested types, namely <code>Left_side_category</code>, <code>Right_side_category</code>, <code>Bottom_side_category</code>, and <code>Top_side_category</code>. Each of those types must be convertible to the type <code><a class="el" href="structCGAL_1_1Arr__oblivious__side__tag.html" title="The categories Left_side_category, Right_side_category, Bottom_side_category, and Top_side_category...">Arr_oblivious_side_tag</a></code> for the class to be a model of the concept <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code>.</p>
<h2><a class="anchor" id="arr_sssectr_lanmarks_concept"></a>
The Landmarks Concept</h2>
<p>The type of an arrangement associated with the landmark point-location strategy (see Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>) must be an instance of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template, where the <code>Traits</code> parameter is substituted with a model of the concept <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code>. (Naturally, it can also model either the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept or the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> concept.) The <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept refines the two concepts <code><a class="el" href="classArrangementApproximateTraits__2.html" title="The concept ArrangementApproximateTraits_2 refines the basic traits concept ArrangementBasicTraits_2...">ArrangementApproximateTraits_2</a></code> and <code><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html" title="The concept ArrangementConstructXMonotoneCurveTraits_2 refines the basic traits concept ArrangementBa...">ArrangementConstructXMonotoneCurveTraits_2</a></code>. Each of these two concepts, in turn, refines the concept <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code>.</p>
<p>A model of the <code><a class="el" href="classArrangementApproximateTraits__2.html" title="The concept ArrangementApproximateTraits_2 refines the basic traits concept ArrangementBasicTraits_2...">ArrangementApproximateTraits_2</a></code> concept must define a fixed precision number type (typically the double-precision floating-point <code>double</code>) and support the additional below (in addition to fulfilling the requirements listed by the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept). </p><dl>
<dt><b><code>Approximate_2</code>:</b> </dt>
<dd>Given a point <code>p</code>, approximate the \( x\) and \( y\)-coordinates of <code>p</code> using the fixed precision number type. We use this operation for approximate computationsthere are certain operations in the search for the location of the point that need not be exact and we can perform them faster than other operations. </dd>
</dl>
<p>A model of the <code><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html" title="The concept ArrangementConstructXMonotoneCurveTraits_2 refines the basic traits concept ArrangementBa...">ArrangementConstructXMonotoneCurveTraits_2</a></code> concept support the operation below (in addition to fulfilling the requirements listed by the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept). </p><dl>
<dt><b><code>Construct_x_monotone_curve_2</code>:</b> </dt>
<dd>Given two points \( p_1\) and \( p_2\), this predicate constructs an \( x\)-monotone curve connecting \( p_1\) and \( p_2\). </dd>
</dl>
<h2><a class="anchor" id="arr_sssectr_xmon_concept"></a>
Supporting Intersecting x-Monotone Curves</h2>
<p>A traits class that models the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept, which refines the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept, has to support the following functions: </p><dl>
<dt><b><code>Intersection_2</code>:</b></dt>
<dd>Computes all intersection points and overlapping sections of two given \( x\)-monotone curves. If possible, computes also the multiplicity of each intersection point.<span class="footnote">If the two curves intersect at a point \( p\) but have different tangents, \( p\) is of multiplicity 1. If the tangents are also equal but the their curvatures are not the same, \( p\) is of multiplicity 2, etc.</span> Knowing the multiplicity of an intersection point is not required, but it can speed up the arrangement construction. </dd>
<dt><b><code>Split_2</code>:</b></dt>
<dd>Splits an \( x\)-monotone curve \( c\) into two subcurves at a point \( p\) lying in the interior of \( c\). </dd>
<dt><b><code>Are_mergeable_2</code>:</b></dt>
<dd>Given two \( x\)-monotone curve \( c_1\) and \( c_2\) that share a common endpoint, this predicate determines whether \( c_1\) and \( c_2\) are <em>mergeable</em>, that is, whether they can be merged to form a single continuous \( x\)-monotone curve of the type supported by the traits class. </dd>
<dt><b><code>Merge_2</code>:</b></dt>
<dd>Merges two mergeable \( x\)-monotone curves. </dd>
</dl>
<p>Using a model of the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code>, it is possible to construct arrangements of sets of \( x\)-monotone curves (and points) that may intersect one another.</p>
<h2><a class="anchor" id="arr_sssectr_full_concept"></a>
Supporting Arbitrary Curves</h2>
<p>The concept <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> refines the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept by adding the notion of a general, not necessarily \( x\)-monotone (and not necessarily continuous) curve. A model of this concept must define the <code>Curve_2</code> type and support the subdivision of a curve into a set of continuous \( x\)-monotone curves and isolated points using the predicate <code>Make_x_monotone_2</code>. For example, the curve \( C:\ (x^2 + y^2)(x^2 + y^2 - 1) = 0\) is the unit circle (the loci of all points for which \( x^2 + y^2 = 1\)) with the origin \( (0,0)\) as a singular point in its interior. \( C\) should therefore be divided into two circular arcs (the upper part and the lower part of the unit circle) and a single isolated point.</p>
<p>Note that the refined model <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> is required only when using the free <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code> functions (see Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions in the Arrangement Package</a>), which accept a <code>Curve_2</code> object in the incremental version, or a range of <code>Curve_2</code> objects in the aggregated version. In all other cases it is sufficient to use a model of the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept.</p>
<h2><a class="anchor" id="Arrangement_on_surface_2SupportingUnbounded"></a>
Supporting Unbounded Curves</h2>
<p>An arrangement that supports unbounded \( x\)-monotone curves maintains an implicit bounding rectangle in the <span style="font-variant: small-caps;">Dcel</span> structure; see Section <a class="el" href="index.html#arr_ssecunb_rep">Representation of Unbounded Arrangements</a>. The unbounded ends of vertical rays, vertical lines, and curves with vertical asymptotes are represented by vertices that lie on the bottom or top sides of this bounding rectangle. These vertices are not associated with points, but are associated with (finite) \( x\)-coordinates. The unbounded ends of all other curves are represented by vertices that lie on the left or right sides of this bounding rectangle. These vertices are not associated with points either. Edges connect these vertices and the four vertices that represents the corners of this bounding rectangle to form the rectangle.</p>
<p>Several predicates are required to handle \( x\)-monotone curves that approach infinity and thus approach the boundary of the parameter space. These predicates are sufficient to handle not only curves embedded in an unbounded parameter space, but also curves embedded in a bounded parameter space with open boundaries. Let \( b_l\) and \( b_r\) denote the \( x\)-coordinates of the left and right boundaries of the parameter space, respectively. Let \( b_b\) and \( b_t\) denote the \( y\)-coordinates of the bottom and top boundaries of the parameter space, respectively. Recall that currently the general code of the arrangement only supports the case where the parameter space is the entire compactified plane, thus \( b_l = b_b = -\infty\) and \( b_r = b_t = +\infty\). Nonetheless, when the parameter space is bounded, it is the exact geometric embedding of the implicit bounding rectangle. In the following we assume that an \( x\) monotone curve \( C\) can be considered as a parametric curve \( C(t) = (X(t),Y(t))\) defined over a closed, open, or half open interval with endpoints \( 0\) and \( 1\).</p>
<p>Models of the concept <code><a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code> handle curves that approach the boundary of the parameter space. This concept refines the concept <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code>. The arrangement template instantiated with a traits class that models this concept can handle curves that are unbounded in any direction. If some curves inserted into an arrangement object are expected to be unbounded, namely, there exists \( d \in \{0,1\}\) such that \( \lim_{t \rightarrow d}X(t) = \pm\infty\) or \( \lim_{t \rightarrow d}y(t) = \pm\infty\) holds for at least one input curve \( C(t) = (X(t),Y(t))\), the arrangement template must be instantiated with a model of the <code>ArrangementOpenBoundaryTraits</code> concept.<span class="footnote">We intend to enhance the arrangement template to handle curves confined to a bounded yet open parameter space. A curve that reaches the boundary of the parameter space in this case is bounded and open.</span></p>
<p>All the four types <code>Left_side_category</code>, <code>Right_side_category</code>, <code>Bottom_side_category</code>, and <code>Top_side_category</code> nested in a model of the concept <code>ArrangementOpenBoundaryTraits</code> must be convertible to <code><a class="el" href="structCGAL_1_1Arr__open__side__tag.html" title="All the four types Left_side_category, Right_side_category, Bottom_side_category, and Top_side_catego...">Arr_open_side_tag</a></code>.<span class="footnote">The tags <code><a class="el" href="structCGAL_1_1Arr__oblivious__side__tag.html" title="The categories Left_side_category, Right_side_category, Bottom_side_category, and Top_side_category...">Arr_oblivious_side_tag</a></code> and <code><a class="el" href="structCGAL_1_1Arr__open__side__tag.html" title="All the four types Left_side_category, Right_side_category, Bottom_side_category, and Top_side_catego...">Arr_open_side_tag</a></code> are only two out of a larger number of options for the side categories included in major extension the code is going through.</span> For example, the <code><a class="el" href="classCGAL_1_1Arr__rational__function__traits__2.html" title="The traits class Arr_rational_function_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_rational_function_traits_2</a></code> traits-model supports unbounded curves; see Section <a class="el" href="index.html#arr_ssectr_ratfunc">A Traits Class for Arcs of Rational Functions</a>. Thus, all four nested types are defined as <code><a class="el" href="structCGAL_1_1Arr__open__side__tag.html" title="All the four types Left_side_category, Right_side_category, Bottom_side_category, and Top_side_catego...">Arr_open_side_tag</a></code>. Adversely, all four types nested in the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> traits-model (see Section <a class="el" href="index.html#arr_ssectr_segs">Traits Classes for Line Segments and Linear Objects</a>) are defined as <code><a class="el" href="structCGAL_1_1Arr__oblivious__side__tag.html" title="The categories Left_side_category, Right_side_category, Bottom_side_category, and Top_side_category...">Arr_oblivious_side_tag</a></code>, as segments are always bounded.<span class="footnote">We intend to introduce more concepts that require only a subset of the categories to be convertible to <code><a class="el" href="structCGAL_1_1Arr__open__side__tag.html" title="All the four types Left_side_category, Right_side_category, Bottom_side_category, and Top_side_catego...">Arr_open_side_tag</a></code>.</span></p>
<p>A model of the concept <code><a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code> must provide the additional predicates listed below. \( x\)-coordinates and \( y\)-coordinates are differently handled. This asymmetry is brought on by the various algorithms applied to arrangements, the input and output arguments of which are \( x\)-monotone curves. Indeed, all curves maintained by any arrangement are continuous weakly \( x\)-monotone curves. A non \( x\)-monotone curve is divided into \( x\)-monotone sub curves (and perhaps points) before it is inserted into an arrangement. This asymmetry is also reflected in the additional predicates listed below.</p>
<dl>
<dt><b><code>Parameter_space_in_x_2</code>:</b></dt>
<dd>Given a parametric \( x\)-monotone curve \( C(t) = (X(t),Y(t))\) and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value \( d \in \{0,1\}\), this predicate determines the location of the curve end along the \( x\)-dimension. Formally, the predicate determines whether \( \lim_{t \rightarrow d} X(t)\) evaluates to \( b_l\), \( b_r\), or a value in between. </dd>
<dt><b><code>Compare_y_near_boundary_2</code>:</b></dt>
<dd>Given two \( x\)-monotone curves \( C_1\) and \( C_2\) and an enumerator \( i\) that specifies either the minimum ends or the maximum ends of the two curves, this predicate compares the \( y\)-coordinates of the curves near their respective ends. That is, the predicate compares the \( y\)-coordinates of the vertical projection of a point \( p\) onto \( C_1\) and onto \( C_2\). If the enumerator \( i\) specifies the minimum ends, the curves must approach the left boundary-side. In this case \( p\) is located far to the left, such that the result is invariant under a translation of \( p\) farther to the left. If \( i\) specifies the maximum ends, the curves must approach the right boundary-side. In that case \( p\) is located far to the right in a similar manner. </dd>
<dt><b><code>Parameter_space_in_y_2</code>:</b></dt>
<dd>Given a parametric \( x\)-monotone curve \( C(t) = (X(t),Y(t))\) and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value \( d \in \{0,1\}\), this predicate determines the location of the curve end along the \( y\)-dimension. Formally, the predicate determines whether \( \lim_{t \rightarrow d} Y(t)\) evaluates to \( b_b\), \( b_t\), or a value in between. </dd>
<dt><b><code>Compare_x_at_limit_2</code>:</b></dt>
<dd>Two versions of this predicate are provided: (i) Given a point \( p\), a parametric \( x\)-monotone curve \( C(t) = (X(t),Y(t))\), and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value \( d \in \{0,1\}\), this predicate compares the \( x\)-coordinate of \( p\) and \( \lim_{t \rightarrow d} X(t)\). If the parameter space is unbounded, a precondition assures that \( C\) has a vertical asymptote at its \( d\)-end; that is \( \lim_{t \rightarrow d} X(t)\) is finite. (ii) Given two parametric \( x\)-monotone curves \( C_1(t) = (X_1(t),Y_1(t))\) and \( C_2(t) = (X_2(t),Y_2(t))\) and two enumerators that specify either the minimum end or the maximum end of each curve, and thus map to parameter values \( d_1\in \{0,1\}\) and \( d_2 \in \{0,1\}\) for \( C_1\) and for \( C_2\), respectively, this predicate compares \( \lim_{t \rightarrow d_1} X_1(t)\) and \( \lim_{t \rightarrow d_2} X_2(t)\). If the parameter space is unbounded, a precondition assures that \( C_1\) and \( C_2\) have vertical asymptote at their respective ends; that is \( \lim_{t \rightarrow d_1} X_1(t)\) and \( \lim_{t \rightarrow d_2} X_2(t)\) are finite. </dd>
<dt><b><code>Compare_x_near_limit_2</code>:</b></dt>
<dd>Given two \( x\)-monotone curves \( C_1\) and \( C_2\) and an enumerator \( i\) that specifies either the minimum ends or the maximum ends of the two curves, this predicate compares the \( x\)-coordinates of the curves near their respective ends. That is, the predicate compares the \( x\)-coordinates of the horizontal projection of a point \( p\) onto \( C_1\) and onto \( C_2\). If the parameter space is unbounded, a precondition assures that \( C_1\) and \( C_2\) have vertical asymptote at their respective ends. Furthermore, both curves approach the same boundary-side, either the bottom or the top, at their respective ends. If both curves approach the bottom boundary-side, \( p\) is located far to the bottom, such that the result is invariant under a translation of \( p\) farther to the bottom. If both curves approach the top boundary-side, \( p\) is located far to the top in a similar manner. Another precondition assures that the \( x\)-coordinates of the limits of the curves at their respective ends are equal. That is, the predicate <code>Compare_x_at_limit_2</code> applied to \( C_1\), \( C_2\), and \( i\) evaluates to <code>EQUAL</code>. </dd>
</dl>
<p>In the rest of this section we review the traits classes included in the public distribution of <span style="font-variant: small-caps;">CGAL</span>, that handle line segments, polylines, conic arcs, rational functions, and arcs of Bzier and algebraic curves. The last subsection overviews decorators for geometric traits classes distributed with <span style="font-variant: small-caps;">CGAL</span>, which extend other geometric traits-class by attaching auxiliary data with the geometric objects.</p>
<h2><a class="anchor" id="arr_ssectr_segs"></a>
Traits Classes for Line Segments and Linear Objects</h2>
<p>The <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class used so far in most example programs in this chapter is a model of the concepts <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code>, <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code>, and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classArrangementDirectionalXMonotoneTraits__2.html">ArrangementDirectionalXMonotoneTraits_2</a></code>; the later enables Boolean set operations. It is parameterized by a geometric kernel and uses the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></code> type as it point type. However, neither the <code>Curve_2</code> nor the <code>X_monotone_curve_2</code> types are identical to the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> type. A kernel segment is typically represented by its two endpoints, and these may have a large bit-size representation, if the segment is intersected and split several times (in comparison with the representation of its original endpoints). The large representation may significantly slow down the various traits-class operations involving such a segment. In contrast, the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> represents a segment using its supporting line and the two endpoints, such that most computations are performed on the supporting line, which never changes as the segment is split. It also caches some additional information with the segment to speed up various predicates. An <code>X_monotone_curve_2</code> object can still be constructed from two endpoints or from a kernel segment. Moreover, an <code>X_monotone_curve_2</code> instance can also be casted or assigned to a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> object. The two types are thus fully convertible to one another.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class is very efficient for maintaining arrangements of a large number of intersecting line segments, especially if it is instantiated with the appropriate geometric kernel. Using <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">Exact_predicates_exact_constructions_kernel</a></code> as the kernel type, which is the default, is generally a good choice; the coordinates of the segment endpoints are represented as exact rational numbers, and this ensures the robustness and correctness of any computation.<span class="footnote">Many of the example programs in the rest of the chapter include a header file named <code>arr_rational_nt.h</code>, which defines a type named <code>Number_type</code> as either <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">Gmpq</a></code> or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">MP_Float</a>&gt;</code>, depending on whether <span class="textsc">Gmp</span> is installed or not.</span></p>
<p>An instance of the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template can be very efficient for constructing arrangements induced by line segments with a large number of intersections. Efficiency is affected by the substituted geometric kernel. Using <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">Gmpq</a>&gt;</code> as the kernel type is in general not a bad choice; the coordinates of the segment endpoints are represented as multi-precision rational-numbers, and this ensures the correctness of all computations regardless of the input. Computations on multi-precision number types, such as <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">Gmpq</a></code>, typically take longer than computations on machine-precision floating-point. However, in almost all cases it is possible to expedite the computation using numerical filtering; see <code>Kernel_2</code> and <code>Kernel_3</code>. If the input set of line segments do not have degeneracies; namely, no two segments in the set share a common endpoint, and no three segments intersect at a common point, or at least, degeneracies exist but their number is relatively small, then filtered computation incurs only negligible overhead compared to floating-point arithmetic, which is error-prone. Indeed, in almost all examples and applications given in this manual, a predefined filtered kernel is used to instantiate the line-segment traits class, namely <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">Exact_predicates_exact_constructions_kernel</a></code>. Furthermore, this kernel is used as a default kernel in case the user did not provide one.</p>
<p><a class="anchor" id="fig__arr_figpredef_kernels"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="fan_grids.png" alt="fan_grids.png" />
</div>
   </td><td><div class="image">
<img src="Europe.png" alt="Europe.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__arr_figpredef_kernels">Figure 34.12</a> (a) An arrangement of \( 104\) line segments from the input file <code>fan_grids.dat</code>. (b) An arrangement of more than \( 3000\) interior disjoint line segments, defined in the input file <code>Europe.dat</code>.  </div>  <br />

<p>In the following example we use the predefined <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">Exact_predicates_exact_constructions_kernel</a></code> for instantiating our segment-traits class. This kernel use interval arithmetic to filter the exact computations. The program reads a set of line segments with integer coordinates from a file and computes their arrangement. By default it opens the <code>fan_grids.dat</code> input-file, located in the examples folder, which contains \( 104\) line segments that form four "fan-like" grids and induce a dense arrangement, as illustrated in <a class="el" href="index.html#fig__arr_figpredef_kernels">Figure 34.12</a> (a):</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2predefined_kernel_8cpp-example.html">Arrangement_on_surface_2/predefined_kernel.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangements of intersecting line segments using the</span></div><div class="line"><span class="comment">// predefined kernel with exact constructions and exact predicates.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                         Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                 Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                  Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                       Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                      Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div><div class="line">  <span class="comment">// fan_grids.dat file if no command-line parameters are given.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> * filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"fan_grids.dat"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Open the input file.</span></div><div class="line">  std::ifstream     in_file (filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">" ..."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> (1);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Read the segments from the file.</span></div><div class="line">  <span class="comment">// The input file format should be (all coordinate values are integers):</span></div><div class="line">  <span class="comment">// &lt;n&gt;                                 // number of segments.</span></div><div class="line">  <span class="comment">// &lt;sx_1&gt; &lt;sy_1&gt;  &lt;tx_1&gt; &lt;ty_1&gt;        // source and target of segment #1.</span></div><div class="line">  <span class="comment">// &lt;sx_2&gt; &lt;sy_2&gt;  &lt;tx_2&gt; &lt;ty_2&gt;        // source and target of segment #2.</span></div><div class="line">  <span class="comment">//   :      :       :      :</span></div><div class="line">  <span class="comment">// &lt;sx_n&gt; &lt;sy_n&gt;  &lt;tx_n&gt; &lt;ty_n&gt;        // source and target of segment #n.</span></div><div class="line">  </div><div class="line">  std::list&lt;Segment_2&gt;  segments;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n;</div><div class="line">  in_file &gt;&gt; n;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;</div><div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; n; ++i) {</div><div class="line">    <span class="keywordtype">int</span> sx, sy, tx, ty;</div><div class="line">    in_file &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty;</div><div class="line">    segments.push_back (Segment_2 (Point_2 (Number_type(sx), Number_type(sy)),</div><div class="line">                                   Point_2 (Number_type(tx), Number_type(ty))));</div><div class="line">  }</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement by aggregately inserting all segments.</span></div><div class="line">  Arrangement_2                  arr;</div><div class="line">  CGAL::Timer                    timer;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Performing aggregated insertion of "</span> </div><div class="line">            &lt;&lt; n &lt;&lt; <span class="stringliteral">" segments."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  timer.start();</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, segments.begin(), segments.end());</div><div class="line">  timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement dimensions.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">        &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges() </div><div class="line">        &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Construction took "</span> &lt;&lt; timer.time() </div><div class="line">        &lt;&lt; <span class="stringliteral">" seconds."</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The arrangement package also offers a simpler alternative segment-traits class. The traits class <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__basic__traits__2.html" title="The traits class Arr_non_caching_segment_basic_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_non_caching_segment_basic_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> models the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept. It uses <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></code> as its point type and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> as its \( x\)-monotone curve type. As this traits class does not support intersecting and splitting segments, the kernel representation is sufficient. It is still less efficient than <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> for constructing arrangements of pairwise disjoint line segments in many cases, as it performs no caching at all, but using this traits class may be preferable as it reduces the memory consumption a bit, since no extra data is stored with the line segments.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html" title="The traits class Arr_non_caching_segment_traits_2 is a model of the ArrangementTraits_2 concept that ...">Arr_non_caching_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> inherits from <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__basic__traits__2.html" title="The traits class Arr_non_caching_segment_basic_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_non_caching_segment_basic_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> and extends it to be a model of the concepts <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code>, <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code>,and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classArrangementDirectionalXMonotoneTraits__2.html">ArrangementDirectionalXMonotoneTraits_2</a></code>. It may thus be used to construct arrangement of intersecting line segments, but as explained above, for efficiency reasons it is recommended to use it only when the arrangement is very sparse and contains hardly any intersection points.</p>
<p>In the following example we read an input file containing a set of line segments that are pairwise disjoint in their interior. As the segments do not intersect, no new points are constructed and we can instantiate the <code>Arr_non_caching_segment_traits_basic_2&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class-template with the predefined <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">Exact_predicates_inexact_constructions_kernel</a></code>. Note that we use the <code><a class="el" href="group__PkgArrangement2Funcs.html#gad4aa37a4e938747028690579fb703d67" title="Inserts a set of -monotone curves in a given range into a given arrangement. ">insert_non_intersecting_curves()</a></code> function to construct the arrangement. By default, the example opens the <code>Europe.dat</code> input-file, located in the examples folder, which contains more than \( 3000\) line segments with floating-point coordinates that form the map of Europe, as depicted in <a class="el" href="index.html#fig__arr_figpredef_kernels">Figure 34.12</a> (b):</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2predefined_kernel_non_intersecting_8cpp-example.html">Arrangement_on_surface_2/predefined_kernel_non_intersecting.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of non-intersecting line segments using the</span></div><div class="line"><span class="comment">// predefined kernel with exact predicates.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_non_caching_segment_basic_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                            Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__non__caching__segment__basic__traits__2.html">CGAL::Arr_non_caching_segment_basic_traits_2&lt;Kernel&gt;</a>  Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                     Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                          Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                         Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div><div class="line">  <span class="comment">// Europe.dat file if no command-line parameters are given.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> * filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"Europe.dat"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Open the input file.</span></div><div class="line">  std::ifstream     in_file (filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">" ..."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> (1);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Read the segments from the file.</span></div><div class="line">  <span class="comment">// The input file format should be (all coordinate values are double</span></div><div class="line">  <span class="comment">// precision floating-point numbers):</span></div><div class="line">  <span class="comment">// &lt;n&gt;                                 // number of segments.</span></div><div class="line">  <span class="comment">// &lt;sx_1&gt; &lt;sy_1&gt;  &lt;tx_1&gt; &lt;ty_1&gt;        // source and target of segment #1.</span></div><div class="line">  <span class="comment">// &lt;sx_2&gt; &lt;sy_2&gt;  &lt;tx_2&gt; &lt;ty_2&gt;        // source and target of segment #2.</span></div><div class="line">  <span class="comment">//   :      :       :      :</span></div><div class="line">  <span class="comment">// &lt;sx_n&gt; &lt;sy_n&gt;  &lt;tx_n&gt; &lt;ty_n&gt;        // source and target of segment #n.</span></div><div class="line">  std::list&lt;Segment_2&gt;  segments;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n;</div><div class="line">  in_file &gt;&gt; n;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;</div><div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; n; ++i) {</div><div class="line">    <span class="keywordtype">double</span> sx, sy, tx, ty;</div><div class="line">    in_file &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty;</div><div class="line">    segments.push_back (Segment_2 (Point_2 (Number_type(sx), Number_type(sy)),</div><div class="line">                                   Point_2 (Number_type(tx), Number_type(ty))));</div><div class="line">  }</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement by aggregately inserting all segments.</span></div><div class="line">  Arrangement_2                  arr;</div><div class="line">  CGAL::Timer                    timer;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Performing aggregated insertion of "</span> </div><div class="line">            &lt;&lt; n &lt;&lt; <span class="stringliteral">" segments."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  timer.start();</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad4aa37a4e938747028690579fb703d67">insert_non_intersecting_curves</a> (arr, segments.begin(), segments.end());</div><div class="line">  timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement dimensions.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">        &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges() </div><div class="line">        &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Construction took "</span> &lt;&lt; timer.time() </div><div class="line">        &lt;&lt; <span class="stringliteral">" seconds."</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The <code><a class="el" href="classCGAL_1_1Arr__linear__traits__2.html" title="The traits class Arr_linear_traits_2 is a model of the ArrangementTraits_2 concept, which enables the construction and maintenance of arrangements of linear objects. ">Arr_linear_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class used for demonstrating the construction of arrangements of unbounded curves is capable of handling bounded and unbounded linear objects, namely lines, rays and line segments. It is parameterized by a geometric kernel and such that its nested <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> type is the same as the kernel point. The <code>Curve_2</code> (and <code>X_monotone_curve_2</code>) type it defines is constructible from a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Line__2.html">Kernel::Line_2</a></code>, a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Ray__2.html">Kernel::Ray_2</a></code> or from a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> object. Just like the default segment-traits class, the linear-traits class also use caching techniques to speed up its predicates and constructions.</p>
<h2><a class="anchor" id="arr_ssectr_polylines"></a>
The Polyline and Polycurve Traits Classes</h2>
<p>Polylines are continuous piecewise linear curves. Polylines are of particular interest, as they can be used to approximate more complex curves in the plane. At the same time they are easier to handle in comparison to higher-degree algebraic curves, as rational arithmetic is sufficient to carry out computations on polylines, and to construct arrangements of polylines in an exact and robust manner.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arr__polyline__traits__2.html" title="The traits class Arr_polyline_traits_2 handles piecewise linear curves, commonly referred to as polyl...">Arr_polyline_traits_2</a>&lt;SubcurveTraits_2&gt;</code> class template handles polylines. It models the concepts <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code>, and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classArrangementDirectionalXMonotoneTraits__2.html">ArrangementDirectionalXMonotoneTraits_2</a></code>. The type that substitutes the template parameter <code>SubcurveTraits_2</code> when <code><a class="el" href="classCGAL_1_1Arr__polyline__traits__2.html" title="The traits class Arr_polyline_traits_2 handles piecewise linear curves, commonly referred to as polyl...">Arr_polyline_traits_2</a>&lt;SubcurveTraits_2&gt;</code> is instantiated must be a geometry-traits class that models the following concepts:</p>
<ul>
<li><code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code>,</li>
<li><code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classArrangementDirectionalXMonotoneTraits__2.html">ArrangementDirectionalXMonotoneTraits_2</a></code>,</li>
<li><code><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html" title="The concept ArrangementConstructXMonotoneCurveTraits_2 refines the basic traits concept ArrangementBa...">ArrangementConstructXMonotoneCurveTraits_2</a></code>.</li>
</ul>
<p>We refer to the type that substitutes the template parameter <code>SubcurveTraits_2</code> as the <em>subcurve traits</em> hereafter. If, in addition, the subcurve traits also models the concept <code><a class="el" href="classArrangementApproximateTraits__2.html" title="The concept ArrangementApproximateTraits_2 refines the basic traits concept ArrangementBasicTraits_2...">ArrangementApproximateTraits_2</a></code> then the instantiated <code><a class="el" href="classCGAL_1_1Arr__polyline__traits__2.html" title="The traits class Arr_polyline_traits_2 handles piecewise linear curves, commonly referred to as polyl...">Arr_polyline_traits_2</a>&lt;SubcurveTraits&gt;</code> type models the concept <code><a class="el" href="classArrangementApproximateTraits__2.html" title="The concept ArrangementApproximateTraits_2 refines the basic traits concept ArrangementBasicTraits_2...">ArrangementApproximateTraits_2</a></code> as well. (By definition, modeling the concepts <code><a class="el" href="classArrangementApproximateTraits__2.html" title="The concept ArrangementApproximateTraits_2 refines the basic traits concept ArrangementBasicTraits_2...">ArrangementApproximateTraits_2</a></code> and <code><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html" title="The concept ArrangementConstructXMonotoneCurveTraits_2 refines the basic traits concept ArrangementBa...">ArrangementConstructXMonotoneCurveTraits_2</a></code> implies modeling the concept <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code>.) The same holds for the <code><a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code> concept as well. Modeling the <code><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html" title="The concept ArrangementConstructXMonotoneCurveTraits_2 refines the basic traits concept ArrangementBa...">ArrangementConstructXMonotoneCurveTraits_2</a></code> concept implies that the subcurve traits must support the construction of a unique ( \(x\)-monotone) segment given two input points. Roughly speaking, it means that each operation defined by the subcurve traits must handle linear curves.</p>
<p>An instance of the polyline traits class-template inherits its nested point type, i.e., <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code>, from the subcurve traits, and defines the nested types <code>Curve_2</code> and <code>X_monotone_curve_2</code>, which are used to represent polylines and \(x\)-monotone polylines, respectively. A polyline of the nested type <code>Curve_2</code> is stored as a vector of <code>SubcurveTraits_2::Curve_2</code> objects, and an \(x\)-monotone polyline of the nested type <code>X_monotone_curve_2</code> is stored as a vector of <code>SubcurveTraits_2::X_monotone_curve_2</code> objects. The nested <code>X_monotone_curve_2</code> type inherits from the nested type <code>Curve_2</code>. By default, <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> is used as the subcurve traits (in case where the <code>SubcurveTraits_2</code> parameter is omitted). In this case the nested types <code>SubcurveTraits_2::Curve_2</code> and <code>SubcurveTraits_2::X_monotone_curve_2</code> are identical types representing line segments.</p>
<p>A polyline can be constructed given one of the following inputs:</p>
<ul>
<li><b>A range of <em>points</em></b>, where two succeeding points in the range represent the endpoints of a segment of the polyline.</li>
<li><b>A range of <em>segments</em></b>. Note that , if the types <code>SubcurveTraits_2::Curve_2</code> and <code>SubcurveTraits_2::X_monotone_curve_2</code> are not the same, then when <code>Make_x_monotone_2</code> is invoked the segments that compose the polyline will be broken into \(x\)-monotone parts.</li>
<li><b>A pair of points <em>or</em> a single segment</b>. In this case a polyline that consists of a single segment is constructed.</li>
</ul>
<p>Note that degenerate polylines are not supported. That is, it is impossible to construct a polyline that contains a segment of length zero, or an isolated point. Finally, a polyline is <b><em>continuous</em></b> and <b><em>well-oriented</em></b>; that is, the target of the \(i\)th segment is the source of the \(i+1\)st segment. For example, the general polyline</p>
<div class="image">
<img src="generic-polyline.png" alt="generic-polyline.png" />
</div>
 <p>can be represented by one of the following two</p>
<div class="image">
<img src="well-oriented-polyline.png" alt="well-oriented-polyline.png" />
</div>
 <p>Also, note, that a single polyline can be split into several \( x\)-monotone polylines, and that the number of intersection points (or overlapping sections) between two polylines can also be large.</p>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>Technically speaking, it is possible to construct a general polyline that is neither well-oriented nor continuous. However, it is impossible to use such polylines for the purpose of computing an arrangement.</p>
<p> </p></div> 
<p>You can traverse over the range of defining segments of a given polyline. The <em>first</em> and <em>past-the-end</em> iterators can be obtained through the access functions of the polyline <code>begin_segments()</code> and <code>end_segments()</code>, respectively. The vertices of an \( x\)-monotone curve are always stored in a strongly monotonic lexicographical order. In other words, \(x\)-monotone polylines can be directed <em>either</em> left-to-right <em>or</em> right-to-left. If the macro <a class="el" href="group__PkgArrangement2Macros.html#gafe0299480c1e86ecbb89465252046f70" title="If the macro is set to one, then -monotone curves are always directed from left-to-right. ">CGAL_ALWAYS_LEFT_TO_RIGHT</a> is set to 1, then the \(x\)-monotone polylines are always directed from left-to-right (only proposed for backward compatibility).</p>
<p>The polyline-traits class does not perform any geometric operations directly. Instead, it solely relies on the functionality of the segment traits. For example, when we need to determine the position of a point with respect to an \(x\)-monotone polyline, we use binary search to locate the relevant segment that contains the point in its \(x\)-range. Then, we compute the position of the point with respect to this segment. Thus, operations on \(x\)-monotone polylines of size \(m\) typically take \(O(\log m)\) time.</p>
<p>You are free to choose the underlying segment traits class. Your decision could be based, for example, on the number of expected intersection points; see Section <a class="el" href="index.html#arr_ssectr_segs">Traits Classes for Line Segments and Linear Objects</a>. Moreover, it is possible to substitute the <code>SubcurveTraits_2</code> template parameter with a traits class that handles segments with some additional data attached to each individual segment; see Section <a class="el" href="index.html#arr_ssecmeta_tr">Traits-Class Decorators</a>. This makes it possible to associate different data objects with the different segments that compose a polyline.</p>
<p><a class="anchor" id="fig__arr_figex_12"></a></p><div class="image">
<img src="ex_12.png" alt="ex_12.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_12">Figure 34.13</a> An arrangement of three polylines, as constructed in <code>polylines.cpp</code>. Disks mark vertices associated with polyline endpoints, while circles mark vertices that correspond to intersection points. Note that \( \pi_2\) is split into three \( x\)-monotone polylines, and that \( \pi_1\) and \( \pi_3\) have two overlapping sections. </div>  <br />

<p>The following example program constructs an arrangement of three polylines, as depicted in <a class="el" href="index.html#fig__arr_figex_12">Figure 34.13</a>. Note that most points defining the polylines are not associated with arrangement vertices. The arrangement vertices are either the endpoints of each \( x\)-monotone polyline or the intersection points between two polylines:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2polylines_8cpp-example.html">Arrangement_on_surface_2/polylines.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of polylines.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_polyline_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  Define the Arrangement traits class to be used. You can either use some user</span></div><div class="line"><span class="comment">  defined kernel and Segment_traits_2 or the defaults.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="comment">// Instantiate the traits class using a user-defined kernel</span></div><div class="line"><span class="comment">// and Segment_traits_2.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                Segment_traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__polyline__traits__2.html">CGAL::Arr_polyline_traits_2&lt;Segment_traits_2&gt;</a>     Geom_traits_2;</div><div class="line"></div><div class="line"><span class="comment">// Identical instantiation can be achieved using the default Kernel:</span></div><div class="line"><span class="comment">// typedef CGAL::Arr_polyline_traits_2&lt;&gt;                    Geom_traits_2;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Geom_traits_2::Point_2                            Point_2;</div><div class="line"><span class="keyword">typedef</span> Geom_traits_2::Segment_2                          Segment_2;</div><div class="line"><span class="keyword">typedef</span> Geom_traits_2::Curve_2                            Polyline_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Geom_traits_2&gt;</a>                Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Geom_traits_2 traits;</div><div class="line">  Arrangement_2 arr(&amp;traits);</div><div class="line"></div><div class="line">  Geom_traits_2::Construct_curve_2 polyline_construct =</div><div class="line">    traits.construct_curve_2_object();</div><div class="line"></div><div class="line">  Point_2 points1[5];</div><div class="line">  points1[0] = Point_2(0, 0);</div><div class="line">  points1[1] = Point_2(2, 4);</div><div class="line">  points1[2] = Point_2(3, 0);</div><div class="line">  points1[3] = Point_2(4, 4);</div><div class="line">  points1[4] = Point_2(6, 0);</div><div class="line">  Polyline_2 pi1 = polyline_construct(&amp;points1[0], &amp;points1[5]);</div><div class="line"></div><div class="line">  std::list&lt;Point_2&gt; points2;</div><div class="line">  points2.push_back(Point_2(1, 3));</div><div class="line">  points2.push_back(Point_2(0, 2));</div><div class="line">  points2.push_back(Point_2(1, 0));</div><div class="line">  points2.push_back(Point_2(2, 1));</div><div class="line">  points2.push_back(Point_2(3, 0));</div><div class="line">  points2.push_back(Point_2(4, 1));</div><div class="line">  points2.push_back(Point_2(5, 0));</div><div class="line">  points2.push_back(Point_2(6, 2));</div><div class="line">  points2.push_back(Point_2(5, 3));</div><div class="line">  points2.push_back(Point_2(4, 2));</div><div class="line">  Polyline_2 pi2 = polyline_construct(points2.begin(), points2.end());</div><div class="line"></div><div class="line">  std::vector&lt;Segment_2&gt; segs;</div><div class="line">  segs.push_back(Segment_2(Point_2(0, 2), Point_2(1, 2)));</div><div class="line">  segs.push_back(Segment_2(Point_2(1, 2), Point_2(3, 6)));</div><div class="line">  segs.push_back(Segment_2(Point_2(3, 6), Point_2(5, 2)));</div><div class="line">  Polyline_2 pi3 = polyline_construct(segs.begin(), segs.end());</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, pi1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, pi2);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, pi3);</div><div class="line"></div><div class="line">  print_arrangement(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The traits class <code><a class="el" href="classCGAL_1_1Arr__polycurve__traits__2.html" title="Note: The SubcurveTraits_2 can comprise of Line_segments, Conic_arcs, Circular_arc, Bezier_curves, or Linear_curves. ">Arr_polycurve_traits_2</a>&lt;GeometryTraits_2&gt;</code> handles piecewise curves that are not necessarily linear, such as conic arcs, circular arcs, Bezier curves, or line segments. We call such a compound curve a <em>polycurve</em>. Similar to a polyline, a polycurve is a chain of subcurves, where each two neighboring subcurves in the chain share a common endpoint; that is, the polycurve is continuous. As a matter of fact, most characteristics of the <code><a class="el" href="classCGAL_1_1Arr__polyline__traits__2.html" title="The traits class Arr_polyline_traits_2 handles piecewise linear curves, commonly referred to as polyl...">Arr_polyline_traits_2</a>&lt;GeometryTraits_2&gt;</code> traits class apply also to the <code><a class="el" href="classCGAL_1_1Arr__polycurve__traits__2.html" title="Note: The SubcurveTraits_2 can comprise of Line_segments, Conic_arcs, Circular_arc, Bezier_curves, or Linear_curves. ">Arr_polycurve_traits_2</a>&lt;GeometryTraits_2&gt;</code> traits class. The only difference between the two, is that the latter is not a model of the concept <code><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html" title="The concept ArrangementConstructXMonotoneCurveTraits_2 refines the basic traits concept ArrangementBa...">ArrangementConstructXMonotoneCurveTraits_2</a></code>, and as such, it is not able to construct a subcurve from two points. As a consequence, it does not support the operations that (i) construct a polycurve from a sequence of point, and (ii) push a point at the back or at the front of a non-empty polycurve.</p>
<h2><a class="anchor" id="arr_ssectr_circ_seg"></a>
A Traits Class for Circular Arcs and Line Segments</h2>
<p>Circles and circular arcs are the simplest form of non-linear curves. We handle circles whose centers have rational coordinates and whose squared radii is also rational. If we denote the circle center by \( (x_0,y_0)\) and its radius by \( r\), then the equation of the circle - that is, \( (x - x_0)^2 + (y - y_0)^2 = r^2\) - has rational coefficients. The intersection points of two such circles are therefore solutions of a quadratic equation with rational coefficients, or algebraic numbers of degree \( 2\). The same applies for intersection points between such a rational circle and a line, or a line segment, with rational coefficients (a line whose equation is \( ax + by + c = 0\), where \( a\), \( b\) and \( c\) are rational). Such numbers can be expressed as \( \alpha + \beta\sqrt{\gamma}\), where \( \alpha\), \( \beta\) and \( \gamma\) are all rational numbers.</p>
<p>Arrangement of circular arcs and of line segment are very useful, as they occur in many applications. For example, when dilating a polygon by some radius we obtain a shape whose boundary is comprised of line segments, which correspond to dilated polygon edges, and circular arcs, which result from dilated polygon vertices. Using the arrangement of the boundary curves it is possible, for example, to compute the union of a set of dilated polygons.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arr__circle__segment__traits__2.html" title="The class Arr_circle_segment_traits_2 is a model of the ArrangementTraits_2 concept and can be used t...">Arr_circle_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class-template is designed for efficient handling of arrangements of circular arcs and line segments. It is a model of the concepts <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classArrangementDirectionalXMonotoneTraits__2.html">ArrangementDirectionalXMonotoneTraits_2</a></code>; the later enables Boolean set operations. Note that it is not a model of <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept, so it is impossible to use the landmark point-location strategy. The traits class template is parameterized by a geometric kernel, and can handle arrangements of segments of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Circle__2.html">Kernel::Circle_2</a></code> objects (full circles are also supported) or of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Line__2.html">Kernel::Line_2</a></code> objects - namely circular arcs and line segments. It is important to observe that the nested <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> type defined by the traits class, whose coordinates are typically algebraic numbers of degree 2, is <em>not</em> the same as the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></code> type, which is capable of representing a point with rational coordinates. The coordinates of a point are represented using the nested <code>CoordNT</code> number-type.</p>
<p><a class="anchor" id="fig__arr_figex_13"></a></p><div class="image">
<img src="ex_13.png" alt="ex_13.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_13">Figure 34.14</a> An arrangement of three circles constructed in <code>circles.cpp</code>. Each circle is split into two \( x\)-monotone circular arcs, whose endpoints are drawn as disks. Circles mark vertices that correspond to intersection points. The vertex \( v_{\rm max}\) is a common intersection point of all three circles.  </div>  <br />

<p>In the following example an arrangement of three full circles is constructed, as shown in <a class="el" href="index.html#fig__arr_figex_13">Figure 34.14</a>. Then, the vertex of maximal degree is searched for. The geometric mapping of this vertex is the point \( (4,3)\), as all three circles intersect at this point and the associated vertex has six incident edges:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2circles_8cpp-example.html">Arrangement_on_surface_2/circles.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of circles using the conic-arc traits.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_circle_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Circle__2.html">Kernel::Circle_2</a>                              Circle_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__circle__segment__traits__2.html">CGAL::Arr_circle_segment_traits_2&lt;Kernel&gt;</a>     Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::CoordNT                             CoordNT;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                             Curve_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                 Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Create a circle centered at the origin with radius 5.</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> c1 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(0, 0);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a> sqr_r1 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__cgal.html#ga0849ff44771b19582218ebdfa5614f64">CGAL::Exact_rational</a>(25);       <span class="comment">// = 5^2</span></div><div class="line">  Circle_2 circ1 = Circle_2(c1, sqr_r1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  Curve_2 cv1 = Curve_2(circ1);</div><div class="line"></div><div class="line">  <span class="comment">// Create a circle centered at (7,7) with radius 5.</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> c2 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(7, 7);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a> sqr_r2 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__cgal.html#ga0849ff44771b19582218ebdfa5614f64">CGAL::Exact_rational</a>(25);       <span class="comment">// = 5^2</span></div><div class="line">  Circle_2 circ2 = Circle_2(c2, sqr_r2, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  Curve_2 cv2 = Curve_2(circ2);</div><div class="line"></div><div class="line">  <span class="comment">// Create a circle centered at (4,-0.5) with radius 3.5 (= 7/2).</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> c3 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(4, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(-1,2));</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a> sqr_r3 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__cgal.html#ga0849ff44771b19582218ebdfa5614f64">CGAL::Exact_rational</a>(49, 4);    <span class="comment">// = 3.5^2</span></div><div class="line">  Circle_2 circ3 = Circle_2(c3, sqr_r3, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  Curve_2 cv3 = Curve_2(circ3);</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement of the three circles.</span></div><div class="line">  Arrangement_2 arr;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, cv1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, cv2);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, cv3);</div><div class="line"></div><div class="line">  <span class="comment">// Locate the vertex with maximal degree.</span></div><div class="line">  Arrangement_2::Vertex_const_iterator vit;</div><div class="line">  Arrangement_2::Vertex_const_handle v_max;</div><div class="line">  std::size_t max_degree = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    <span class="keywordflow">if</span> (vit-&gt;degree() &gt; max_degree) {</div><div class="line">      v_max = vit;</div><div class="line">      max_degree = vit-&gt;degree();</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The vertex with maximal degree in the arrangement is: "</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"v_max = ("</span> &lt;&lt; v_max-&gt;point() &lt;&lt; <span class="stringliteral">") "</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"with degree "</span> &lt;&lt; max_degree &lt;&lt; <span class="stringliteral">"."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The <code>Curve_2</code> type nested in <code><a class="el" href="classCGAL_1_1Arr__circle__segment__traits__2.html" title="The class Arr_circle_segment_traits_2 is a model of the ArrangementTraits_2 concept and can be used t...">Arr_circle_segment_traits_2</a></code> can be used to represent circles, circular arcs, or line segments. Curve objects can therefore be constructed from a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Circle__2.html">Kernel::Circle_2</a></code> object or from a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> object. A circular arc is typically defined by a supporting circle and two endpoints, where the endpoints are instances of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> type, with rational or irrational coordinates. The orientation of the arc is determined by the orientation of the supporting circle. Similarly, we also support the construction of lines segments given their supporting line (of type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Line__2.html">Kernel::Line_2</a></code>) and two endpoints, which may have irrational coordinates (unlike the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> type).</p>
<p>Note that the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Circle__2.html">Kernel::Circle_2</a></code> type represents a circle whose <em>squared radius</em> is rational, where the radius itself may be irrational. However, if the radius is known to be rational, it is advisable to use it, for efficiency reasons. It is therefore also possible to construct a circle, or a circular arc specifying the circle center (a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></code>), its rational radius, and its orientation. Finally, we also support the construction of a circular arcs that is defined by two endpoints and an arbitrary midpoint that lies on the arc in between its endpoint. In this case, all three points are required to have rational coordinates (to be kernel points).</p>
<p>The following example demonstrates the usage of the various construction methods for circular arcs and line segments. Note the usage of the constructor of <code>CoordNT (alpha, beta, gamma)</code>, which creates a degree- \( 2\) algebraic number whose value is \( \alpha + \beta\sqrt{\gamma}\).</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2circular_arcs_8cpp-example.html">Arrangement_on_surface_2/circular_arcs.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of various circular arcs and line segments.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_circle_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Circle__2.html">Kernel::Circle_2</a>                              Circle_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a>                             Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__circle__segment__traits__2.html">CGAL::Arr_circle_segment_traits_2&lt;Kernel&gt;</a>     Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::CoordNT                             CoordNT;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                             Curve_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                 Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::list&lt;Curve_2&gt;  curves;</div><div class="line"></div><div class="line">  <span class="comment">// Create a circle centered at the origin with squared radius 2.</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> c1 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(0, 0);</div><div class="line">  Circle_2 circ1 = Circle_2(c1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(2));</div><div class="line"></div><div class="line">  curves.push_back(Curve_2(circ1));</div><div class="line"></div><div class="line">  <span class="comment">// Create a circle centered at (2,3) with radius 3/2 - note that</span></div><div class="line">  <span class="comment">// as the radius is rational we use a different curve constructor.</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> c2 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(2, 3);</div><div class="line"></div><div class="line">  curves.push_back(Curve_2(c2, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(3, 2)));</div><div class="line"></div><div class="line">  <span class="comment">// Create a segment of the line (y = x) with rational endpoints.</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> s3 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(-2, -2);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> t3 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(2, 2);</div><div class="line">  Segment_2 seg3 = Segment_2(s3, t3);</div><div class="line"></div><div class="line">  curves.push_back(Curve_2(seg3));</div><div class="line"></div><div class="line">  <span class="comment">// Create a line segment with the same supporting line (y = x), but</span></div><div class="line">  <span class="comment">// having one endpoint with irrational coefficients.</span></div><div class="line">  CoordNT sqrt_15 = CoordNT(0, 1, 15); <span class="comment">// = sqrt(15)</span></div><div class="line">  Point_2 s4 = Point_2(3, 3);</div><div class="line">  Point_2 t4 = Point_2(sqrt_15, sqrt_15);</div><div class="line"></div><div class="line">  curves.push_back(Curve_2(seg3.supporting_line(), s4, t4));</div><div class="line"></div><div class="line">  <span class="comment">// Create a circular arc that correspond to the upper half of the</span></div><div class="line">  <span class="comment">// circle centered at (1,1) with squared radius 3. We create the</span></div><div class="line">  <span class="comment">// circle with clockwise orientation, so the arc is directed from</span></div><div class="line">  <span class="comment">// (1 - sqrt(3), 1) to (1 + sqrt(3), 1).</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> c5 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(1, 1);</div><div class="line">  Circle_2 circ5 = Circle_2(c5, 3, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  CoordNT one_minus_sqrt_3 = CoordNT(1, -1, 3);</div><div class="line">  CoordNT one_plus_sqrt_3 = CoordNT(1, 1, 3);</div><div class="line">  Point_2 s5 = Point_2(one_minus_sqrt_3, CoordNT(1));</div><div class="line">  Point_2 t5 = Point_2(one_plus_sqrt_3, CoordNT(1));</div><div class="line"></div><div class="line">  curves.push_back(Curve_2(circ5, s5, t5));</div><div class="line"></div><div class="line">  <span class="comment">// Create a circular arc of the unit circle, directed clockwise from</span></div><div class="line">  <span class="comment">// (-1/2, sqrt(3)/2) to (1/2, sqrt(3)/2). Note that we orient the</span></div><div class="line">  <span class="comment">// supporting circle accordingly.</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> c6 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(0, 0);</div><div class="line">  CoordNT sqrt_3_div_2 = CoordNT(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(0),</div><div class="line">                                 <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(1,2),</div><div class="line">                                 <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(3));</div><div class="line">  Point_2 s6 = Point_2(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(-1, 2), sqrt_3_div_2);</div><div class="line">  Point_2 t6 = Point_2(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(1, 2), sqrt_3_div_2);</div><div class="line"></div><div class="line">  curves.push_back(Curve_2(c6, 1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>, s6, t6));</div><div class="line"></div><div class="line">  <span class="comment">// Create a circular arc defined by two endpoints and a midpoint,</span></div><div class="line">  <span class="comment">// all having rational coordinates. This arc is the upper-right</span></div><div class="line">  <span class="comment">// quarter of a circle centered at the origin with radius 5.</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> s7 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(0, 5);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> mid7 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(3, 4);</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> t7 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>(5, 0);</div><div class="line"></div><div class="line">  curves.push_back(Curve_2(s7, mid7, t7));</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement of the curves.</span></div><div class="line">  Arrangement_2 arr;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, curves.begin(), curves.end());</div><div class="line"></div><div class="line">  <span class="comment">// Print the size of the arrangement.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>It is also possible to construct \( x\)-monotone curve objects, which represent \( x\)-monotone circular arcs or line segments, using similar constructors. Construction from a full circle is obviously not supported. See the Reference Manual for more details.</p>
<p>The traits class-template <code><a class="el" href="classCGAL_1_1Arr__circular__line__arc__traits__2.html" title="This class is a traits class for CGAL arrangements, built on top of a model of concept CircularKernel...">Arr_circular_line_arc_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circular_kernel_2.tag:../Circular_kernel_2/" href="../Circular_kernel_2/classCircularKernel.html">CircularKernel</a>&gt;</code> offered by the arrangement package also handles circular arcs and line segments. It is an alternative to the <code><a class="el" href="classCGAL_1_1Arr__circle__segment__traits__2.html" title="The class Arr_circle_segment_traits_2 is a model of the ArrangementTraits_2 concept and can be used t...">Arr_circle_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class-template. These two class templates, while serve similar purposes, are based on different concepts, and posses different characteristics. You are encouraged to experiment with both, compare their performance, and use the most suitable for your case.</p>
<h2><a class="anchor" id="arr_ssectr_conic"></a>
A Traits Class for Conic Arcs</h2>
<p>A <em>conic curve</em> is an algebraic curve of degree 2. Namely, it is the locus of all points \( (x,y)\) satisfying the equation \( C:\ r x^2 + s y^2 + t xy + u x + v y + w = 0\), where the six coefficients \( \langle r, s, t, u, v, w \rangle\) completely characterize the curve. The sign of the expression \( \Delta_{C} = 4 r s - t^2\) determines the type of curve: </p><ul>
<li>
If \( \Delta_{C} &gt; 0\) the curve is an ellipse. A circle is a special case of an ellipse, where \( r = s\) and \( t = 0\). </li>
<li>
If \( \Delta_{C} = 0\) the curve is a parabola - an unbounded conic curve with a single connected branch. When \( r = s = t = 0\) we have a line, which can be considered as a degenerate parabola. </li>
<li>
If \( \Delta_{C} &lt; 0\) the curve is a hyperbola. That is, it is comprised of two disconnected unbounded branches. </li>
</ul>
<p>As the arrangement package is suitable for bounded curves, we consider bounded segments of conic curves, referred to as <em>conic arcs</em>. A conic arc \( a\) may be either (i) a full ellipse, or (ii) defined by the tuple \( \langle C, p_s, p_t, o \rangle\), where \( C\) is a conic curve and \( p_s\) and \( p_t\) are two points on \( C\) (namely \( C(p_s) = C(p_t) = 0\)) that define the <em>source</em> and <em>target</em> of the arc, respectively. The arc is formed by traversing \( C\) from the source to the target going in the orientation specified by \( o\), which is typically clockwise or counterclockwise orientation (but may also be collinear in case of degenerate conic curves).</p>
<p>We always assume that the conic coefficients \( \langle r, s, t, u, v, w \rangle\) are rational. When dealing with linear curves (line segments and polylines), similar assumptions guarantee that all intersection points also have rational coordinates, such that the arrangement of such curves can be constructed and maintained using only rational arithmetic. Unfortunately, this does not hold for conic curves, as the coordinates of intersection points of two conic curves with rational coefficients are in general algebraic numbers of degree \( 4\).<span class="footnote">Namely, they are roots of polynomials with integer coefficients of degree \( 4\). However, in some special cases, for example when handling only circles and circular arcs, the coordinates of the intersection points are only of degree \( 2\), namely they are solutions of quadratic equations.</span> In addition, conic arcs may not necessarily be \( x\)-monotone, and must be split at points where the tangent to the arc is vertical. In the general case, such points typically have coordinates that are algebraic numbers of degree \( 2\). It is therefore clear that we have to use different number types to represent the conic coefficients and the point coordinates. Note that as arrangement vertices induced by intersection points and points with vertical tangents are likely to have algebraic coordinates, we also allow the original endpoints of the input arcs \( p_s\) and \( p_t\) to have algebraic coordinates.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arr__conic__traits__2.html" title="The class Arr_conic_traits_2 is a model of the ArrangementTraits_2 concept and can be used to constru...">Arr_conic_traits_2</a>&lt;RatKernel, AlgKernel, NtTraits&gt;</code> class template is designed for efficient handling of arrangements of bounded conic arcs. The template has three parameters, defined as follows: </p><ul>
<li>
The <code>RatKernel</code> class is a geometric kernel, whose field type is an exact rational type. It is used to define basic geometric entities (e.g., a line segment or a circle) with rational coefficients. Typically we use one of the standard <span style="font-variant: small-caps;">CGAL</span> kernels, instantiated with the number type <code>NtTraits::Rational</code> (see below). </li>
<li>
The <code>AlgKernel</code> class is a geometric kernel whose field type is an exact algebraic type. It is used to define points with algebraic coordinates. Typically we use one of the standard <span style="font-variant: small-caps;">CGAL</span> kernels, instantiated with the number type <code>NtTraits::Algebraic</code> (see below). </li>
<li>
The <code>NtTraits</code> class (the number-type traits class) encapsulates all the numeric operations needed for performing the geometric computation carried out by the geometric traits class. It defines the <code>Integer</code>, <code>Rational</code> and <code>Algebraic</code> number-types, and supports several operations on these types, such as conversion between number types, solving quadratic equations and extracting the real roots of a polynomial with integer coefficients. It is highly recommended to use the <code>CORE_algebraic_number_traits</code> class, which is included in the arrangement package. It relies on the exact number types implemented in the <span class="textsc">Core</span> library and performs exact computations on the number types it defines. </li>
</ul>
<p>The <code><a class="el" href="classCGAL_1_1Arr__conic__traits__2.html" title="The class Arr_conic_traits_2 is a model of the ArrangementTraits_2 concept and can be used to constru...">Arr_conic_traits_2</a></code> models the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> and <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concepts. (It supports the landmark point-location strategy). Its <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> type is derived from <code>AlgKernel::Point_2</code>, while the <code>Curve_2</code> type represents a bounded, not necessarily \( x\)-monotone, conic arc. The <code>X_monotone_curve_2</code> type is derived from <code>Curve_2</code>, but its constructors are to be used only by the traits class. You should therefore construct only <code>Curve_2</code> objects and insert them into the arrangement using the <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code> or <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code> functions.</p>
<p>Conic arcs can be constructed from full ellipses or by specifying a supporting curve, two endpoints and an orientation. However, several constructors of <code>Curve_2</code> are available to allow for some special cases, such as circular arcs or line segments. The <code>Curve_2</code> (and the derived <code>X_monotone_curve_2</code>) classes also support basic access functions such as <code>source()</code>, <code>target()</code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__orientation__grp.html#ga91d9866cfde916ba70e5dbc596176d9e">orientation()</a></code>.</p>
<h2><a class="anchor" id="Arrangement_on_surface_2ExamplesforArrangements"></a>
Examples for Arrangements of Conics</h2>
<p><a class="anchor" id="fig__arr_figex_14"></a></p><div class="image">
<img src="ex_14.png" alt="ex_14.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_14">Figure 34.15</a> An arrangement of mixed conic arcs, as constructed in conics.cpp  </div>  <br />

<p>The following example demonstrates the usage of the various constructors for conic arcs. The resulting arrangement is depicted in <a class="el" href="index.html#fig__arr_figex_14">Figure 34.15</a>. Especially noteworthy are the constructor of a circular arc that accepts three points and the constructor that allows specifying approximate endpoints, where the exact endpoints are given explicitly as intersections of the supporting conic with two other conic curves. Also note that as the preconditions required by some of these constructors are rather complicated (see the Reference Manual for the details), a precondition violation does not cause the program to terminate - instead, an <em>invalid</em> arc is created. We can verify the validity of an arc by using the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#ga06ee6c8472c94e9f14d6fc94b6b7079b">is_valid()</a></code> method. Needless to say, inserting invalid arcs into an arrangement is not allowed.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2conics_8cpp-example.html">Arrangement_on_surface_2/conics.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of various conic arcs.</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef CGAL_USE_CORE</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE ..."</span> &lt;&lt; std::endl; </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/CORE_algebraic_number_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_conic_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::CORE_algebraic_number_traits              Nt_traits;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Rational                             Rational;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Algebraic                            Algebraic;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Rational&gt;</a>                       Rat_kernel;</div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Point_2                             Rat_point_2;</div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Segment_2                           Rat_segment_2;</div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Circle_2                            Rat_circle_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Algebraic&gt;</a>                      Alg_kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__conic__traits__2.html">CGAL::Arr_conic_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</a></div><div class="line">                                                        Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                               Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                               Conic_arc_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                   Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  Arrangement_2    arr;</div><div class="line"></div><div class="line">  <span class="comment">// Insert a hyperbolic arc, supported by the hyperbola y = 1/x</span></div><div class="line">  <span class="comment">// (or: xy - 1 = 0) with the endpoints (1/5, 4) and (2, 1/2).</span></div><div class="line">  <span class="comment">// Note that the arc is counterclockwise oriented.</span></div><div class="line">  Point_2       ps1 (Rational(1,4), 4);</div><div class="line">  Point_2       pt1 (2, Rational(1,2));</div><div class="line">  Conic_arc_2   c1 (0, 0, 1, 0, 0, -1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga39fcfbab0b0f0ce9139ad1613e21d60d">CGAL::COUNTERCLOCKWISE</a>, ps1, pt1);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, c1);</div><div class="line"></div><div class="line">  <span class="comment">// Insert a full ellipse, which is (x/4)^2 + (y/2)^2 = 0 rotated by</span></div><div class="line">  <span class="comment">// phi=36.87 degree (such that sin(phi) = 0.6, cos(phi) = 0.8),</span></div><div class="line">  <span class="comment">// yielding: 58x^2 + 72y^2 - 48xy - 360 = 0.</span></div><div class="line">  Conic_arc_2   c2 (58, 72, -48, 0, 0, -360);</div><div class="line">  </div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, c2);</div><div class="line"></div><div class="line">  <span class="comment">// Insert the segment (1, 1) -- (0, -3).</span></div><div class="line">  Rat_point_2   ps3 (1, 1);</div><div class="line">  Rat_point_2   pt3 (0, -3);</div><div class="line">  Conic_arc_2   c3 (Rat_segment_2 (ps3, pt3));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, c3);</div><div class="line"></div><div class="line">  <span class="comment">// Insert a circular arc supported by the circle x^2 + y^2 = 5^2,</span></div><div class="line">  <span class="comment">// with (-3, 4) and (4, 3) as its endpoints. We want the arc to be</span></div><div class="line">  <span class="comment">// clockwise oriented, so it passes through (0, 5) as well.</span></div><div class="line">  Rat_point_2   ps4 (-3, 4);</div><div class="line">  Rat_point_2   pm4 (0, 5);</div><div class="line">  Rat_point_2   pt4 (4, 3);</div><div class="line">  Conic_arc_2   c4 (ps4, pm4, pt4);</div><div class="line"></div><div class="line">  CGAL_assertion (c4.is_valid());</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, c4);</div><div class="line"></div><div class="line">  <span class="comment">// Insert a full unit circle that is centered at (0, 4).</span></div><div class="line">  Rat_circle_2  circ5 (Rat_point_2(0,4), 1);</div><div class="line">  Conic_arc_2   c5 (circ5);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, c5);</div><div class="line"></div><div class="line">  <span class="comment">// Insert a parabolic arc that is supported by a parabola y = -x^2</span></div><div class="line">  <span class="comment">// (or: x^2 + y = 0) and whose endpoints are (-sqrt(3), -3) ~ (-1.73, -3)</span></div><div class="line">  <span class="comment">// and (sqrt(2), -2) ~ (1.41, -2). Notice that since the x-coordinates</span></div><div class="line">  <span class="comment">// of the endpoints cannot be accurately represented, we specify them</span></div><div class="line">  <span class="comment">// as the intersections of the parabola with the lines y = -3 and y = -2.</span></div><div class="line">  <span class="comment">// Note that the arc is clockwise oriented.</span></div><div class="line">  Conic_arc_2   c6 =</div><div class="line">    Conic_arc_2 (1, 0, 0, 0, 1, 0,       <span class="comment">// The parabola.</span></div><div class="line">                 <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>,</div><div class="line">                 Point_2 (-1.73, -3),    <span class="comment">// Approximation of the source.</span></div><div class="line">                 0, 0, 0, 0, 1, 3,       <span class="comment">// The line: y = -3.</span></div><div class="line">                 Point_2 (1.41, -2),     <span class="comment">// Approximation of the target.</span></div><div class="line">                 0, 0, 0, 0, 1, 2);      <span class="comment">// The line: y = -2.</span></div><div class="line"></div><div class="line">  CGAL_assertion (c6.is_valid());</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, c6);</div><div class="line"></div><div class="line">  <span class="comment">// Insert the right half of the circle centered at (4, 2.5) whose radius</span></div><div class="line">  <span class="comment">// is 1/2 (therefore its squared radius is 1/4).</span></div><div class="line">  Rat_circle_2  circ7 (Rat_point_2(4, Rational(5,2)), Rational(1,4));</div><div class="line">  Point_2       ps7 (4, 3);</div><div class="line">  Point_2       pt7 (4, 2);</div><div class="line">  Conic_arc_2   c7 (circ7, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>, ps7, pt7);</div><div class="line">  </div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, c7);</div><div class="line"></div><div class="line">  <span class="comment">// Print out the size of the resulting arrangement.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges() </div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>The last example in this section demonstrates how the conic-traits class can handle intersection points with multiplicity. The supporting curves of the two arcs, a circle centered at \( (0,\frac{1}{2})\) with radius \( \frac{1}{2}\), and the hyperbola \( y = \frac{x^2}{1-x}\),<span class="footnote">This curve can also be written as \( C: x^2 + xy - y = 0\). It is a hyperbola since \( \Delta_{C} = -1\).</span> intersect at the origin such that the intersection point has multiplicity \( 3\) (note that they both have the same horizontal tangent at \( (0,0)\) and the same curvature \( 1\)). In addition, they have another intersection point at \( (\frac{1}{2},\frac{1}{2})\) of multiplicity \( 1\):</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2conic_multiplicities_8cpp-example.html">Arrangement_on_surface_2/conic_multiplicities.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Handling intersection points with multiplicity between conic arcs.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef CGAL_USE_CORE</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE ..."</span> &lt;&lt; std::endl; </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/CORE_algebraic_number_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_conic_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_naive_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::CORE_algebraic_number_traits            Nt_traits;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Rational                           Rational;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Algebraic                          Algebraic;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Rational&gt;</a>                     Rat_kernel;</div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Point_2                           Rat_point_2;</div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Segment_2                         Rat_segment_2;</div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Circle_2                          Rat_circle_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Algebraic&gt;</a>                    Alg_kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__conic__traits__2.html">CGAL::Arr_conic_traits_2</a>&lt;Rat_kernel, </div><div class="line">                                 Alg_kernel,</div><div class="line">                                 Nt_traits&gt;           Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                             Conic_arc_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                 Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__naive__point__location.html">CGAL::Arr_naive_point_location&lt;Arrangement_2&gt;</a> Naive_pl;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  Arrangement_2  arr;</div><div class="line">  Naive_pl       pl (arr);</div><div class="line"></div><div class="line">  <span class="comment">// Insert a hyperbolic arc, supported by the hyperbola y = x^2/(1-x)</span></div><div class="line">  <span class="comment">// (or: x^2 + xy - y = 0) with the endpoints (-1, 1/2) and (1/2, 1/2).</span></div><div class="line">  <span class="comment">// Note that the arc is counterclockwise oriented.</span></div><div class="line">  Point_2        ps1 (-1, Rational(1,2));</div><div class="line">  Point_2        pt1 (Rational(1,2), Rational(1,2));</div><div class="line">  Conic_arc_2    cv1 (1, 0, 1, 0, -1, 0, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga39fcfbab0b0f0ce9139ad1613e21d60d">CGAL::COUNTERCLOCKWISE</a>, ps1, pt1);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, cv1, pl);</div><div class="line"></div><div class="line">  <span class="comment">// Insert the bottom half of the circle centered at (0, 1/2) whose radius</span></div><div class="line">  <span class="comment">// is 1/2 (therefore its squared radius is 1/4).</span></div><div class="line">  Rat_circle_2   circ2 (Rat_point_2(0, Rational(1,2)), Rational(1,4));</div><div class="line">  Point_2        ps2 (-Rational(1,2), Rational(1,2));</div><div class="line">  Point_2        pt2 (Rational(1,2), Rational(1,2));</div><div class="line">  Conic_arc_2    cv2 (circ2, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga39fcfbab0b0f0ce9139ad1613e21d60d">CGAL::COUNTERCLOCKWISE</a>, ps2, pt2);</div><div class="line">  </div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, cv2, pl);</div><div class="line"></div><div class="line">  <span class="comment">// Print the resulting arrangement.</span></div><div class="line">  print_arrangement (arr);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h2><a class="anchor" id="arr_ssectr_ratfunc"></a>
A Traits Class for Arcs of Rational Functions</h2>
<p>The traits class <code><a class="el" href="classCGAL_1_1Arr__rational__function__traits__2.html" title="The traits class Arr_rational_function_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_rational_function_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a>&gt;</code> handles bounded and unbounded arcs of rational functions, referred to as <em>rational arcs</em> (in particular, such an arc may correspond to the entire graph of a rational function), and enables the construction and maintenance of arrangements of such arcs. Rational functions, and polynomial functions in particular, are not only interesting in their own right, they are also very useful for approximating or interpolating more complicated curves; see, e.g., [<a class="el" href="citelist.html#CITEREF_cgal:ptvf-nrcpp-02">[10]</a> Chapter 3.</p>
<p><code><a class="el" href="classCGAL_1_1Arr__rational__function__traits__2.html" title="The traits class Arr_rational_function_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_rational_function_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a>&gt;</code> is a model of the concepts <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code>, <code><a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code>, and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classArrangementDirectionalXMonotoneTraits__2.html">ArrangementDirectionalXMonotoneTraits_2</a></code>; the later enables Boolean set operations. Note that it is not a model of <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept, so it is impossible to use the landmark point-location strategy with this traits class.</p>
<p>A rational function \( y = \frac{P(x)}{Q(x)}\) is defined by two polynomials \( P\) and \( Q\) of arbitrary degrees. If \( Q(x) = 1\) then the function is a simple polynomial function. Usually the domain is \( \mathbb{R}\) but the function may also be restricted to a bounded interval \( [x_{\rm min}, x_{\rm max}]\) or defined over a ray \( (-\infty, x_{\rm max}]\) or \( [x_{\rm min}, \infty)\). Rational functions are represented by the nested type <code>Curve_2</code>. A rational arc is always \( x\)-monotone in the mathematical sense. However, it is not necessarily continuous, as it may have singularities. An arc that has singularities must be split into continuous portions before being inserted into the arrangement. Arbitrary rational functions are represented by the nested type <code>Curve_2</code> and continuous portions of rational functions are represented by the nested type <code>X_monotone_curve_2</code>. Constructors for both types are provided by the traits. A <code>Curve_2</code> may be split up into several <code>X_monotone_curve_2</code> using <code>Make_x_monotone_2</code>.</p>
<p>Using the <code><a class="el" href="classCGAL_1_1Arr__rational__function__traits__2.html" title="The traits class Arr_rational_function_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_rational_function_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a>&gt;</code> class template it is possible to construct and maintain arrangement of rational arcs. The template parameter of the traits must be a model of the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a></code>. A rational function is represented as the quotient of two polynomials \( P\) and \( Q\) of type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html#ae49b9882d6f700d17476e00933ed20f3">AlgebraicKernel_d_1::Polynomial_1</a></code> and an \( x\)-interval over which the polynomials are defined. The type of the polynomial coefficients, namely <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html#a800674c4325a4c7dbc57186603fc8e3c">AlgebraicKernel_d_1::Coefficient</a></code>, cannot be algebraic. Moreover, it is recommended that this type is not made rational either, since using rational, as opposed to integral, coefficients does not extend the range of the rational arcs and is typically less efficient. The type of the interval bounds, namely <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html#a00c2a481bddf8a8812f517b1b81867c0">AlgebraicKernel_d_1::Bound</a></code>, however, can be algebraic. A point is represented by a rational function and its \( x\)-coordinate, which is of type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html#a6b463d94115038aefb4e0f2aafc06a6e">AlgebraicKernel_d_1::Algebraic_real_1</a></code>. Note that an explicit representation of the \( y\)-coordinate is only computed upon request, as it can be a rather costly operation.</p>
<p>The constructed rational functions are cached by the traits class. The cache is local to each traits class object. It is therefore necessary to construct curves using only the constructor objects provided by member functions of the traits class. Moreover, a curve must only be used by the traits class object that was used to construct it. The cache is automatically cleaned up from time to time. The amortized clean up costs are constant. In addition, there is also a separate member function that cleans up the cache on demand.</p>
<p>The curve constructors have an additional advantage. They conveniently enable the provision of two polynomials that define a rational arc using rational coefficients. For example, let \( P\) and \( Q\) denote two polynomials with integral coefficients that define a rational arc at interest, and let \( P'\) and \( Q'\) denote two polynomials with rational coefficients that define the same rational arc; that is, the quotients \( P/Q\) and \( P'/Q'\) are identical. You can construct the rational arc providing the coefficients of \( P'\) and \( Q'\) to the constructor. In this case the constructor normalizes the coefficients and stores the desired polynomials \( P\) and \( Q\).</p>
<p><a class="anchor" id="fig__arr_figex_16"></a></p><div class="image">
<img src="ex_16.png" alt="ex_16.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_16">Figure 34.16</a> An arrangement of four arcs of rational functions, as constructed in rational_functions.cpp.  </div>  <br />

<p>The following example demonstrates the construction of an arrangement of rational arcs depicted in <a class="el" href="index.html#fig__arr_figex_16">Figure 34.16</a>. Note the usage of the two constructors, for polynomial arcs and for rational arcs:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2rational_functions_8cpp-example.html">Arrangement_on_surface_2/rational_functions.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of arcs of rational functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef CGAL_USE_CORE</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE ..."</span> &lt;&lt; std::endl; </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/CORE__BigInt_8h.html">CGAL/CORE_BigInt.h</a>&gt;</span>                      <span class="comment">// NT</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Algebraic_kernel_d_1.h&gt;</span>             <span class="comment">// Algebraic Kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_rational_function_traits_2.h&gt;</span>   <span class="comment">// Traits</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span>                    <span class="comment">// Arrangement</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCORE_1_1BigInt.html">CORE::BigInt</a>                               Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classCGAL_1_1Algebraic__kernel__d__1.html">CGAL::Algebraic_kernel_d_1&lt;Number_type&gt;</a>    AK1;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__rational__function__traits__2.html">CGAL::Arr_rational_function_traits_2&lt;AK1&gt;</a>  Traits_2;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Traits_2::Polynomial_1                     Polynomial_1;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Algebraic_real_1                 Alg_real_1;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>              Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#ga2f2176255429973ea7bf156804a53857">CGAL::set_pretty_mode</a>(std::cout);             <span class="comment">// for nice printouts.</span></div><div class="line"></div><div class="line">  <span class="comment">// create a polynomial representing x .-)</span></div><div class="line">  Polynomial_1 x = CGAL::shift(Polynomial_1(1),1);</div><div class="line"></div><div class="line">  <span class="comment">// Traits class object </span></div><div class="line">  Traits_2 traits; </div><div class="line">  Traits_2::Construct_x_monotone_curve_2 construct_arc</div><div class="line">    = traits.construct_x_monotone_curve_2_object(); </div><div class="line"></div><div class="line">  <span class="comment">// container storing all arcs </span></div><div class="line">  std::vector&lt;Traits_2::X_monotone_curve_2&gt;  arcs;</div><div class="line">  </div><div class="line">  <span class="comment">// Create an arc supported by the polynomial y = x^4 - 6x^2 + 8,</span></div><div class="line">  <span class="comment">// defined over the interval [-2.1, 2.1]:</span></div><div class="line">  Polynomial_1 P1 = x*x*x*x - 6*x*x + 8;</div><div class="line">  Alg_real_1 l(Traits_2::Algebraic_kernel_d_1::Bound(-2.1));</div><div class="line">  Alg_real_1 r(Traits_2::Algebraic_kernel_d_1::Bound(2.1));</div><div class="line">  arcs.push_back(construct_arc(P1, l, r));</div><div class="line"></div><div class="line">  <span class="comment">// Create an arc supported by the function y = x / (1 + x^2),</span></div><div class="line">  <span class="comment">// defined over the interval [-3, 3]:</span></div><div class="line">  Polynomial_1 P2 = x;</div><div class="line">  Polynomial_1 Q2 = 1+x*x;</div><div class="line">  </div><div class="line">  arcs.push_back(construct_arc(P2, Q2, Alg_real_1(-3), Alg_real_1(3)));</div><div class="line"></div><div class="line">  <span class="comment">// Create an arc supported by the parabola y = 8 - x^2,</span></div><div class="line">  <span class="comment">// defined over the interval [-2, 3]:</span></div><div class="line">  Polynomial_1 P3 = 8 - x*x; </div><div class="line">  arcs.push_back(construct_arc(P3, Alg_real_1(-2), Alg_real_1(3)));</div><div class="line">  </div><div class="line">  <span class="comment">// Create an arc supported by the line y = -2x,</span></div><div class="line">  <span class="comment">// defined over the interval [-3, 0]:</span></div><div class="line">  Polynomial_1 P4 = -2*x;</div><div class="line">  arcs.push_back(construct_arc(P4, Alg_real_1(-3), Alg_real_1(0)));</div><div class="line">  </div><div class="line">  <span class="comment">// Construct the arrangement of the four arcs.</span></div><div class="line"></div><div class="line">  <span class="comment">// Print the arcs.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i(0); i &lt; arcs.size(); ++i)</div><div class="line">    std::cout &lt;&lt; arcs[i]&lt;&lt;std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  Arrangement_2 arr(&amp;traits);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, arcs.begin(), arcs.end());</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement size.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p><a class="anchor" id="fig__arr_figex_unb_rat"></a></p><div class="image">
<img src="ex_unb_rat.png" alt="ex_unb_rat.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_unb_rat">Figure 34.17</a> An arrangement of six arcs of rational functions, as constructed in unbounded_rational_functions.cpp  </div>  <br />

<p>The following example demonstrates the construction of an arrangement of six rational arcs - four unbounded arcs and two bounded ones - as depicted in <a class="el" href="index.html#fig__arr_figex_unb_rat">Figure 34.17</a>. Note the usage of the constructors of an entire rational function and of an infinite "ray" of such a function. Also observe that the hyperbolas \( y = \pm\frac{1}{x}\) and \( y = \pm\frac{1}{2x}\) never intersect, although they have common vertical and horizontal asymptotes, so very "thin" unbounded faces are created between them:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2unbounded_rational_functions_8cpp-example.html">Arrangement_on_surface_2/unbounded_rational_functions.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of unbounded portions of rational functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef CGAL_USE_CORE</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE ..."</span> &lt;&lt; std::endl; </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/CORE__BigInt_8h.html">CGAL/CORE_BigInt.h</a>&gt;</span>                    <span class="comment">// NT</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Algebraic_kernel_d_1.h&gt;</span>           <span class="comment">// Algebraic Kernel</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_rational_function_traits_2.h&gt;</span> <span class="comment">// Traits</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span>                  <span class="comment">// Arrangement</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCORE_1_1BigInt.html">CORE::BigInt</a>                               Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classCGAL_1_1Algebraic__kernel__d__1.html">CGAL::Algebraic_kernel_d_1&lt;Number_type&gt;</a>    AK1;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__rational__function__traits__2.html">CGAL::Arr_rational_function_traits_2&lt;AK1&gt;</a>  Traits_2;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Traits_2::Polynomial_1                     Polynomial_1;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Algebraic_real_1                 Alg_real_1;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>              Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#ga2f2176255429973ea7bf156804a53857">CGAL::set_pretty_mode</a>(std::cout);             <span class="comment">// for nice printouts.</span></div><div class="line">  </div><div class="line">  <span class="comment">// Traits class object </span></div><div class="line">  AK1 ak1; </div><div class="line">  Traits_2 traits(&amp;ak1);</div><div class="line">    </div><div class="line">  <span class="comment">// constructor for rational functions </span></div><div class="line">  Traits_2::Construct_curve_2 construct = traits.construct_curve_2_object(); </div><div class="line">  </div><div class="line">  <span class="comment">// a polynomial representing x .-)</span></div><div class="line">  Polynomial_1 x = CGAL::shift(Polynomial_1(1),1);</div><div class="line">  </div><div class="line">  <span class="comment">// container storing all arcs </span></div><div class="line">  std::vector&lt;Traits_2::Curve_2&gt;  arcs;</div><div class="line"></div><div class="line">  </div><div class="line">  <span class="comment">// Create the rational functions (y = 1 / x), and (y = -1 / x).</span></div><div class="line">  Polynomial_1 P1(1);</div><div class="line">  Polynomial_1 minusP1(-P1);</div><div class="line">  Polynomial_1 Q1 = x;</div><div class="line">  arcs.push_back(construct(P1, Q1));</div><div class="line">  arcs.push_back(construct(minusP1, Q1));</div><div class="line"></div><div class="line">  <span class="comment">// Create a bounded segments of the parabolas (y = -4*x^2 + 3) and</span></div><div class="line">  <span class="comment">// (y = 4*x^2 - 3), defined over [-sqrt(3)/2, sqrt(3)/2].</span></div><div class="line">  Polynomial_1 P2 = -4*x*x+3; </div><div class="line">  Polynomial_1 minusP2 = -P2; </div><div class="line">  std::vector&lt;std::pair&lt;Alg_real_1,int&gt; &gt; roots;</div><div class="line"></div><div class="line">  <span class="comment">// [-sqrt(3)/2, sqrt(3)/2]</span></div><div class="line">  traits.algebraic_kernel_d_1()-&gt;solve_1_object()(P2, std::back_inserter(roots));</div><div class="line">  arcs.push_back(construct(P2, roots[0].first, roots[1].first));</div><div class="line">  arcs.push_back(construct(minusP2, roots[0].first, roots[1].first));</div><div class="line"></div><div class="line">  <span class="comment">// Create the rational function (y = 1 / 2*x) for x &gt; 0, and the</span></div><div class="line">  <span class="comment">// rational function (y = -1 / 2*x) for x &lt; 0.</span></div><div class="line">  Polynomial_1 P3(1);</div><div class="line">  Polynomial_1 minusP3(-P3);</div><div class="line">  Polynomial_1 Q3 = 2*x;</div><div class="line">  arcs.push_back(construct(P3, Q3, Alg_real_1(0), <span class="keyword">true</span>));</div><div class="line">  arcs.push_back(construct(minusP3, Q3, Alg_real_1(0), <span class="keyword">false</span>));</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement of the six arcs.</span></div><div class="line">  <span class="comment">//Arrangement_2 arr(&amp;traits);</span></div><div class="line">  Arrangement_2 arr;</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, arcs.begin(), arcs.end());</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement size.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">    &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">    &lt;&lt; <span class="stringliteral">" (plus "</span> &lt;&lt; arr.number_of_vertices_at_infinity()</div><div class="line">    &lt;&lt; <span class="stringliteral">" at infinity)"</span></div><div class="line">    &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges() </div><div class="line">    &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() </div><div class="line">    &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; arr.number_of_unbounded_faces() &lt;&lt; <span class="stringliteral">" unbounded)"</span></div><div class="line">    &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h2><a class="anchor" id="arr_ssectr_bez"></a>
A Traits Class for Planar Bzier Curves</h2>
<p>A planar <em>Bzier curve</em> \( B\) is a parametric curve defined by a sequence of <em>control points</em> \( p_0, \ldots, p_n\) as follows:</p>
<p class="formulaDsp">
\begin{eqnarray*} B(t) = \left(X(t), Y(t)\right) = \ccSum{k=0}{n}{p_k \cdot \frac{n!}{k! (n-k)!} \cdot t^k (1-t)^{n-k}}\ . \end{eqnarray*}
</p>
<p>where \( t \in [0, 1]\). The degree of the curve is therefore \( n\) - namely, \( X(t)\) and \( Y(t)\) are polynomials of degree \( n\). Bzier curves have numerous applications in computer graphics and solid modelling. They are used, for example, in free-form sketches and for defining the true-type fonts.</p>
<p>Using the <code><a class="el" href="classCGAL_1_1Arr__Bezier__curve__traits__2.html" title="The traits class Arr_Bezier_curve_traits_2 is a model of the ArrangementTraits_2 concept that handles...">Arr_Bezier_curve_traits_2</a>&lt;RatKernel, AlgKernel, NtTraits&gt;</code> class template it is possible to construct and maintain arrangements of Bzier curves that are given by rational control points (a sequence of objects of the <code>RatKernel::Point_2</code> type). We can handle curves of arbitrary degree (in general, a sequence of \( n+1\) control points define a Bzier curve of degree \( n\)). The template parameters are the same ones used by the <code><a class="el" href="classCGAL_1_1Arr__conic__traits__2.html" title="The class Arr_conic_traits_2 is a model of the ArrangementTraits_2 concept and can be used to constru...">Arr_conic_traits_2</a></code> class template, and here it is also recommended to use the <code>CORE_algebraic_number_traits</code> class, with <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a> kernels instantiated with the <code>Rational</code> and <code>Algebraic</code> number-types defined by this class.</p>
<p>As mentioned above, we assume that the coordinates of all control points that define a Bzier curve are rational numbers, so both \( X(t)\) and \( Y(t)\) are polynomials with rational coefficients. The intersection points between curves are however algebraic numbers, and their exact computation is time-consuming. The traits class therefore contains a layer of geometric filtering that performs all computation in an approximate manner whenever possible. Thus, it resorts to exact computations only when the approximate computation fails to produce an unambiguous result. Note that most arrangement vertices are therefore associated with approximated points. You cannot access the coordinates of such points and obtain them as algebraic numbers, and only access to the approximate coordinates in possible. See the Reference Manual for the exact interface of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code>, <code>Curve_2</code> and <code>X_monotone_curve_2</code> defined by the traits class.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arr__Bezier__curve__traits__2.html" title="The traits class Arr_Bezier_curve_traits_2 is a model of the ArrangementTraits_2 concept that handles...">Arr_Bezier_curve_traits_2</a></code> is a model of the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> concept (but not of the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept, so it is impossible to use the landmark point-location strategy for arrangements of rational arcs).</p>
<p><a class="anchor" id="fig__arr_figex_bez"></a></p><div class="image">
<img src="Bezier_arr.png" alt="Bezier_arr.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_bez">Figure 34.18</a> An arrangement of ten Bzier curves of degree \( 5\), as constructed in <code>Bezier_curves.cpp</code>.  </div>  <br />

<p>The following example reads a set of Bzier curves from an input file, where each file is specified by an integer stating its number of control points, followed by the sequence of control points, given in integer or rational coordinates. By default, the program uses the <code>Bezier.dat</code> file, which contains ten curves of degree \( 5\) each; their resulting arrangement is depicted in <a class="el" href="index.html#fig__arr_figex_bez">Figure 34.18</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2Bezier_curves_8cpp-example.html">Arrangement_on_surface_2/Bezier_curves.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of Bezier curves.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef CGAL_USE_CORE</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE ..."</span> &lt;&lt; std::endl; </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/CORE_algebraic_number_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_Bezier_curve_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::CORE_algebraic_number_traits              Nt_traits;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Rational                             NT;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Rational                             Rational;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Algebraic                            Algebraic;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Rational&gt;</a>                       Rat_kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Algebraic&gt;</a>                      Alg_kernel;</div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Point_2                             Rat_point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__Bezier__curve__traits__2.html">CGAL::Arr_Bezier_curve_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</a></div><div class="line">                                                        Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                               Bezier_curve_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                   Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div><div class="line">  <span class="comment">// Bezier.dat file if no command-line parameters are given.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>   *filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"Bezier.dat"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Open the input file.</span></div><div class="line">  std::ifstream   in_file (filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Read the curves from the input file.</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               n_curves;</div><div class="line">  std::list&lt;Bezier_curve_2&gt;  curves;</div><div class="line">  Bezier_curve_2             B;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               k;</div><div class="line">  </div><div class="line">  in_file &gt;&gt; n_curves;</div><div class="line">  <span class="keywordflow">for</span> (k = 0; k &lt; n_curves; k++) {</div><div class="line">    <span class="comment">// Read the current curve (specified by its control points).</span></div><div class="line">    in_file &gt;&gt; B;</div><div class="line">    curves.push_back (B);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"B = {"</span> &lt;&lt; B &lt;&lt; <span class="stringliteral">"}"</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement.</span></div><div class="line">  Arrangement_2                     arr;</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, curves.begin(), curves.end());</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement size.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges() </div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h2><a class="anchor" id="arr_ssectr_alg"></a>
A Traits Class for Planar Algebraic Curves of Arbitrary Degree</h2>
<p>An algebraic curve \( C\) in the plane is defined as the (real) zero locus of a polynomial \( f(x,y)\) in two variables. The curve is uniquely defined by \( f\) (although several polynomials might define the same curve). We call \( f\) a <em>defining polynomial</em> of \( C\).</p>
<p>We consider arrangements induced by algebraic curves or by (weakly) \( x\)-monotone segments for algebraic curves (Such a segment is not necessarily the maximal possible (weakly) x-monotone segment; see below.) When talking about algebraic curves, we use the term "segment" for a continuous, possibly non-linear subset of an algebraic curve - see the definition below. There are no restrictions on the algebraic curve, that means, we support unbounded curves, vertical curves or segments, and isolated points.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html" title="The traits class Arr_algebraic_segment_traits_2 is a model of the ArrangementTraits_2 concept that ha...">Arr_algebraic_segment_traits_2</a>&lt;Coefficient&gt;</code> class template is a model of the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> concept (but not of the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept, so it is impossible to use the landmark point-location strategy for arrangements of algebraic curves). The template argument <code>Coefficient</code> determines the type of the scalar coefficients of the polynomial. Currently supported types are <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__integer.html">leda_integer</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCORE_1_1BigInt.html">CORE::BigInt</a></code>, and any instance of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Sqrt__extension.html">Sqrt_extension</a>&lt;A,B&gt;</code> instantiated with one of the integral types above.</p>
<p>The traits class defines a type <code>Curve_2</code> for algebraic curves. Such a type can be constructed by the <code>Construct_curve_2</code> functor, which accepts an instance of <code>Polynomial_2</code> as an argument. This polynomial type is also available by the traits class and constitutes a valid model of the concept <code>Polynomial_d</code> with two variables (see ??).</p>
<p><a class="anchor" id="fig__arr_figex_alg_curves"></a></p><div class="image">
<img src="algebraic_curves.png" alt="algebraic_curves.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_alg_curves">Figure 34.19</a> An arrangement of algebraic curves of degrees \( 1\), \( 2\), \( 3\), and \( 6\), as constructed in <code>algebraic_curves.cpp</code>.  </div>  <br />

<p>The following examples computes the arrangement induced by the four curves in <a class="el" href="index.html#fig__arr_figex_alg_curves">Figure 34.19</a></p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2algebraic_curves_8cpp-example.html">Arrangement_on_surface_2/algebraic_curves.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if (!CGAL_USE_CORE) &amp;&amp; (!CGAL_USE_LEDA) &amp;&amp; (!(CGAL_USE_GMP &amp;&amp; CGAL_USE_MPFI))</span></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE, LEDA, or GMP+MPFI ..."</span> </div><div class="line">        &lt;&lt; std::endl; </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_algebraic_segment_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if CGAL_USE_GMP &amp;&amp; CGAL_USE_MPFI</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpz_8h.html">CGAL/Gmpz.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">CGAL::Gmpz</a> Integer;</div><div class="line"><span class="preprocessor">#elif CGAL_USE_CORE</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/CORE__BigInt_8h.html">CGAL/CORE_BigInt.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCORE_1_1BigInt.html">CORE::BigInt</a> Integer;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/leda__integer_8h.html">CGAL/leda_integer.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> LEDA::integer Integer;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html">CGAL::Arr_algebraic_segment_traits_2&lt;Integer&gt;</a> Arr_traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Arr_traits_2&gt;</a> Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> Arr_traits_2::Curve_2 Curve_2;</div><div class="line"><span class="keyword">typedef</span> Arr_traits_2::Polynomial_2 Polynomial_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    <span class="comment">// For nice printouts</span></div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgIOstreams.html#ga2f2176255429973ea7bf156804a53857">CGAL::set_pretty_mode</a>(std::cout);</div><div class="line"></div><div class="line">    Arr_traits_2 arr_traits;</div><div class="line"> </div><div class="line">    <span class="comment">// Functor to create a curve from a Polynomial_2</span></div><div class="line">    Arr_traits_2::Construct_curve_2 construct_curve</div><div class="line">        = arr_traits.construct_curve_2_object();</div><div class="line"></div><div class="line">    Polynomial_2 x = CGAL::shift(Polynomial_2(1),1,0);</div><div class="line">    Polynomial_2 y = CGAL::shift(Polynomial_2(1),1,1);</div><div class="line">  </div><div class="line">    Arrangement_2 arr(&amp;arr_traits);</div><div class="line"></div><div class="line">    <span class="comment">// Construct an (unbounded line) with equation 3x-5y+2=0</span></div><div class="line">    Polynomial_2 f1 = 3*x-5*y+2;</div><div class="line">    Curve_2 cv1 = construct_curve(f1);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Adding curve "</span> &lt;&lt; f1 &lt;&lt; <span class="stringliteral">" to the arrangement"</span> &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr,cv1);</div><div class="line"></div><div class="line">    <span class="comment">// Construct the ellipse x^2+3*y^2-10=0</span></div><div class="line">    Polynomial_2 f2 = CGAL::ipower(x,2)+3*CGAL::ipower(y,2)-10;</div><div class="line">    Curve_2 cv2 = construct_curve(f2);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Adding curve "</span> &lt;&lt; f2 &lt;&lt; <span class="stringliteral">" to the arrangement"</span> &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr,cv2);</div><div class="line"></div><div class="line">    <span class="comment">// Construct a cubic curve with isoated point, and vertical asymptote</span></div><div class="line">    <span class="comment">// x^2+y^2+xy^2</span></div><div class="line">    Polynomial_2 f3 = CGAL::ipower(x,2)+CGAL::ipower(y,2)+x*CGAL::ipower(y,2);</div><div class="line">    Curve_2 cv3 = construct_curve(f3);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Adding curve "</span> &lt;&lt; f3 &lt;&lt; <span class="stringliteral">" to the arrangement"</span> &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr,cv3);</div><div class="line"></div><div class="line">    <span class="comment">// Construct a curve of degree 6 with equation x^6+y^6-x^3y^3-12</span></div><div class="line">    Polynomial_2 f4 = CGAL::ipower(x,6)+CGAL::ipower(y,6)-</div><div class="line">                      CGAL::ipower(x,3)*CGAL::ipower(y,3)-12;</div><div class="line">    Curve_2 cv4 = construct_curve(f4);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Adding curve "</span> &lt;&lt; f4 &lt;&lt; <span class="stringliteral">" to the arrangement"</span> &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr,cv4);</div><div class="line"></div><div class="line">    <span class="comment">// Print the arrangement size.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">              &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges() </div><div class="line">              &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>We first give a precise definition of segments of algebraic curves. A point \( p\) on a curve \( C_f\subset\mathbb{R}^2\) (with \( f\) its defining equation) is called <em>semi-regular</em>, if locally around \( p\), \( C_f\) can be written as a function graph of some continuous function in \( x\) or in \( y\) (we also say that \( p\) is parameterizable in \( x\) or \( y\), respectively). The only two cases of non-semi-regular points are isolated points, and self-intersections. A <em>segment</em> of a curve is a closed and continuous point set such that each interior point is semi-regular. It follows that a weakly \( x\)-monotone segment is either a completely vertical segment, or a segment whose interior points are all parameterizable in \( x\).</p>
<p>The traits class allows to construct weakly \( x\)-monotone segments of a curve using the <code>Construct_x_monotone_segment_2</code> functor. The <code>X_monotone_curve_2</code> type of the traits class represents weakly \( x\)-monotone segments of a curve; however, segments may need to be further subdivided into several (sub-)segments, for technical reasons. Therefore, <code>Construct_x_monotone_segment_2</code> constructs a sequence of <code>X_monotone_curve_2</code> objects, whose union represents the weakly \( x\)-monotone segment that was queried. We call a segment <em>terminal</em> if it can be represented by the type <code>X_monotone_curve_2</code>.</p>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>The subdivision of segments is due to the internal representation of \( x\)-monotone segments, which is based on a vertical decomposition. We assume the defining polynomial \( f\) of the curve \( C\) to be <em>square-free</em>, that means, it contains no divisor \( g^2\) of total degree greater than zero. We define a <em>(complex) critical point</em> \( p\in\mathbb{C}^2\) by </p><p class="formulaDsp">
\[ f(p)=0=\frac{\partial f}{\partial y}(p). \]
</p>
<p> An \( x\)-coordinate \( \alpha\in\mathbb{R}\) is <em>critical</em> if either some critical point has \( x\)-coordinate \( \alpha\), or if the leading coefficient of \( f\), considered as a polynomial in \( y\), vanishes. In particular, vertical lines of and isolated point of \( C\) can only take place at critical \( x\)-coordinates. Between two consecutive critical \( x\)-coordinates, the curve decomposes into a finite number of \( x\)-monotone segments (the same is true on the left of the leftmost, and on the right of the rightmost critical \( x\)-coordinate). The type <code>X_monotone_curve_2</code> is only able to represent such segments (and sub-segments of them). See <a class="el" href="index.html#fig__arr_figcylindrical_decomposition">Figure 34.20</a> for an example of a decomposition into terminal segments. Formally, a terminal segment is a weakly \( x\)-monotone segment that is either vertical, or its \( x\)-range contains no critical point in its interior.  </p></div> 
<p><a class="anchor" id="fig__arr_figcylindrical_decomposition"></a></p><div class="image">
<img src="cylindrical_decomposition.png" alt="cylindrical_decomposition.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figcylindrical_decomposition">Figure 34.20</a> The critical \( x\)-coordinates of an algebraic curve (dashed lines), and its decomposition into terminal segments (in different colors). The segment from \( p\) to \( q\) consists of the union of three terminal segments.  </div>  <br />

<p>Coordinates of points are represented by the type <code>Algebraic_real_1</code>, which is defined in the traits class. This type is taken from a model of the <code>AlgebraicKernel_1</code> concept, which is also available by the type <code>Algebraic_kernel_1</code>. One can use this model to create algebraic numbers as roots of univariate polynomials, and process them, for instance, compare them, or approximate them to any precision. See the documentation of <code>AlgebraicKernel_1</code> for more information. One can construct an object of type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> by a triple ( \( x_0\),cv,i), which means that the \( i\)-th point (counted from below) in the fiber of cv at the \( x\)-coordinate \( x_0\) is constructed. This is also how points are presented internally. In the example displayed in <a class="el" href="index.html#fig__arr_figcylindrical_decomposition">Figure 34.20</a>, if \( x_1\) denotes the \( x\)-coordinate of \( p\), and \( cv\) represents the algebraic curve, then \( p\) could be represented by \( (x_1,cv,3)\). If \( x_2\) is the \( x\)-coordinate of \( q\), then \( (x_2,cv,1)\) is a valid representation of \( q\). Although the \( y\)-coordinate of an object of type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> can be queried, we recommend to be careful with that option, since computing an explicit representation of the \( y\)-coordinate as an <code>Algebraic_real_1</code> object can become rather expensive.</p>
<p><a class="anchor" id="fig__arr_figex_alg_segments"></a></p><div class="image">
<img src="algebraic_segments.png" alt="algebraic_segments.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_alg_segments">Figure 34.21</a> An arrangement of algebraic segments (solid lines), as constructed in <code>algebraic_segments.cpp</code>. The supporting curves are drawn in dashed lines.  </div>  <br />

<p>The following code exemplifies various methods to construct algebraic segments. The computed arrangement is displayed in <a class="el" href="index.html#fig__arr_figex_alg_segments">Figure 34.21</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2algebraic_segments_8cpp-example.html">Arrangement_on_surface_2/algebraic_segments.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/config.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/use.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if (!CGAL_USE_CORE) &amp;&amp; (!CGAL_USE_LEDA) &amp;&amp; (!(CGAL_USE_GMP &amp;&amp; CGAL_USE_MPFI))</span></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE, LEDA, or GMP+MPFI ..."</span></div><div class="line">        &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_algebraic_segment_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if CGAL_USE_GMP &amp;&amp; CGAL_USE_MPFI</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpz_8h.html">CGAL/Gmpz.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">CGAL::Gmpz</a> Integer;</div><div class="line"><span class="preprocessor">#elif CGAL_USE_CORE</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/CORE__BigInt_8h.html">CGAL/CORE_BigInt.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCORE_1_1BigInt.html">CORE::BigInt</a> Integer;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/leda__integer_8h.html">CGAL/leda_integer.h</a>&gt;</span></div><div class="line"><span class="keyword">typedef</span> LEDA::integer Integer;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html">CGAL::Arr_algebraic_segment_traits_2&lt;Integer&gt;</a> Arr_traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Arr_traits_2&gt;</a> Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> Arr_traits_2::Curve_2 Curve_2;</div><div class="line"><span class="keyword">typedef</span> Arr_traits_2::Polynomial_2 Polynomial_2;</div><div class="line"><span class="keyword">typedef</span> Arr_traits_2::Algebraic_real_1 Algebraic_real_1;</div><div class="line"><span class="keyword">typedef</span> Arr_traits_2::X_monotone_curve_2 X_monotone_curve_2;</div><div class="line"><span class="keyword">typedef</span> Arr_traits_2::Point_2 Point_2;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    Arr_traits_2 arr_traits;</div><div class="line"></div><div class="line">    Arr_traits_2::Construct_curve_2 construct_curve</div><div class="line">        = arr_traits.construct_curve_2_object();</div><div class="line">    Arr_traits_2::Construct_x_monotone_segment_2 construct_x_monotone_segment</div><div class="line">        = arr_traits.construct_x_monotone_segment_2_object();</div><div class="line">    Arr_traits_2::Construct_point_2 construct_point</div><div class="line">        = arr_traits.construct_point_2_object();</div><div class="line">    Arr_traits_2::Make_x_monotone_2 <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circular_kernel_2.tag:../Circular_kernel_2/" href="../Circular_kernel_2/group__PkgCircularKernel2GeometricFunctions.html#ga20791b9a88e184491fe836fb3780f8dc">make_x_monotone</a></div><div class="line">        = arr_traits.make_x_monotone_2_object();</div><div class="line"></div><div class="line">    Arrangement_2 arr(&amp;arr_traits);</div><div class="line"></div><div class="line">    std::vector&lt;X_monotone_curve_2&gt; segs;</div><div class="line"></div><div class="line">    Polynomial_2 x = CGAL::shift(Polynomial_2(1),1,0);</div><div class="line">    Polynomial_2 y = CGAL::shift(Polynomial_2(1),1,1);</div><div class="line"></div><div class="line">    <span class="comment">// Construct x^4+y^3-1</span></div><div class="line">    Curve_2 cv0 = construct_curve(CGAL::ipower(x,4)+CGAL::ipower(y,3)-1);</div><div class="line">    <span class="comment">// Construct all x-monotone segments using the Make_x_mononotone functor</span></div><div class="line">    std::vector&lt;CGAL::Object&gt; pre_segs;</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circular_kernel_2.tag:../Circular_kernel_2/" href="../Circular_kernel_2/group__PkgCircularKernel2GeometricFunctions.html#ga20791b9a88e184491fe836fb3780f8dc">make_x_monotone</a>(cv0,std::back_inserter(pre_segs));</div><div class="line">    <span class="comment">// Cast all CGAL::Objects into X_monotone_segment_2</span></div><div class="line">    <span class="comment">// (the vector might also contain Point_2 objects for isolated points,</span></div><div class="line">    <span class="comment">// but not for this instance</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; pre_segs.size(); i++ ) {</div><div class="line">        X_monotone_curve_2 curr;</div><div class="line">        <span class="keywordtype">bool</span> check = CGAL::assign(curr,pre_segs[i]);</div><div class="line">        assert(check); CGAL_USE(check);</div><div class="line">        segs.push_back(curr);</div><div class="line">    }</div><div class="line">    <span class="comment">// Construct an ellipse with equation 2*x^2+5*y^2-7=0</span></div><div class="line">    Curve_2 cv1 = construct_curve(2*CGAL::ipower(x,2)+5*CGAL::ipower(y,2)-7);</div><div class="line"></div><div class="line">    <span class="comment">// Construct point on the upper arc (counting of arc numbers starts with 0!</span></div><div class="line">    Point_2 p11 = construct_point(Algebraic_real_1(0),cv1,1);</div><div class="line"></div><div class="line">    construct_x_monotone_segment(cv1,p11,Arr_traits_2::POINT_IN_INTERIOR,</div><div class="line">                                 std::back_inserter(segs));</div><div class="line"></div><div class="line">    <span class="comment">// Construct a vertical cusp x^2-y^3=0</span></div><div class="line">    Curve_2 cv2 = construct_curve(CGAL::ipower(x,2)-CGAL::ipower(y,3));</div><div class="line"></div><div class="line">    <span class="comment">// Construct a segment containing the cusp point.</span></div><div class="line">    <span class="comment">// This adds to X_monotone_curve_2 objects to the vector,</span></div><div class="line">    <span class="comment">// because the cusp is a critical point</span></div><div class="line">    Point_2 p21 = construct_point(Algebraic_real_1(-2),cv2,0);</div><div class="line">    Point_2 p22 = construct_point(Algebraic_real_1(2),cv2,0);</div><div class="line">    construct_x_monotone_segment(cv2,p21,p22,std::back_inserter(segs));</div><div class="line"></div><div class="line">    <span class="comment">// Construct an unbounded curve, starting at x=3</span></div><div class="line">    Point_2 p23 = construct_point(Algebraic_real_1(3),cv2,0);</div><div class="line">    construct_x_monotone_segment(cv2,p23,Arr_traits_2::MIN_ENDPOINT,</div><div class="line">                                 std::back_inserter(segs));</div><div class="line"></div><div class="line">    <span class="comment">// Construct another conic: y^2-x^2+1</span></div><div class="line">    Curve_2 cv3 = construct_curve(CGAL::ipower(y,2)-CGAL::ipower(x,2)+1);</div><div class="line"></div><div class="line">    Point_2 p31 = construct_point(Algebraic_real_1(2),cv3,1);</div><div class="line">    construct_x_monotone_segment(cv3,p31,Arr_traits_2::MAX_ENDPOINT,</div><div class="line">                                 std::back_inserter(segs));</div><div class="line"></div><div class="line">    <span class="comment">// Construct a vertical segment</span></div><div class="line">    Point_2 v1 = construct_point(0,0);</div><div class="line">    Point_2 v2 = construct_point(Algebraic_real_1(0),cv1,1);</div><div class="line">    construct_x_monotone_segment(v1,v2,std::back_inserter(segs));</div><div class="line"></div><div class="line">    <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr,segs.begin(),segs.end());</div><div class="line"></div><div class="line">    <span class="comment">// Add some isolated points (must be wrapped into CGAL::Object)</span></div><div class="line">    std::vector&lt;CGAL::Object&gt; isolated_points;</div><div class="line">    isolated_points.push_back</div><div class="line">        (CGAL::make_object(construct_point(Algebraic_real_1(2),cv3,0)));</div><div class="line">    isolated_points.push_back</div><div class="line">      (CGAL::make_object(construct_point(Integer(1),Integer(5))));</div><div class="line">    isolated_points.push_back</div><div class="line">      (CGAL::make_object(construct_point(Algebraic_real_1(-1),</div><div class="line">                     Algebraic_real_1(5))));</div><div class="line"></div><div class="line">    <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr,isolated_points.begin(), isolated_points.end());</div><div class="line"></div><div class="line">    <span class="comment">// Print the arrangement size.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">              &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">              &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecmeta_tr"></a>
Traits-Class Decorators</h2>
<p>Geometric traits-class decorators allow you to attach auxiliary data to curves and to points. The data is automatically manipulated by the decorators and distributed to the constructed geometric entities. Note that additional information can alternatively be maintained by extending the vertex, halfedge, or face types provided by the <span style="font-variant: small-caps;">Dcel</span> class used by the arrangement; see the details in Section <a class="el" href="index.html#arr_secex_dcel">Extending the DCEL</a>.</p>
<p>The arrangement package includes a generic traits-class decorator template named <code><a class="el" href="classCGAL_1_1Arr__curve__data__traits__2.html" title="The class Arr_curve_data_traits_2 is a model of the ArrangementTraits_2 concept and serves as a decor...">Arr_curve_data_traits_2</a>&lt;BaseTraits, XMonotoneCurveData, Merge, CurveData, Convert&gt;</code>. This decorator is used to attach a data field to curves and to \( x\)-monotone curves. It is parameterized by a base-traits class, which is one of the geometric traits classes described in the previous subsections, or a user-defined traits class. The curve-data decorator derives itself from the base-traits class, and in particular inherits its <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> type. In addition: </p><ul>
<li>
<code>Curve_2</code> is derived from the basic <code>BaseTraits::Curve_2</code> class, extending it by an extra field of type <code>CurveData</code>. </li>
<li>
<code>X_monotone_curve_2</code> is derived from the basic <code>BaseTraits::X_monotone_curve_2</code> class, extending it by an extra field of type <code>XMonotoneCurveData</code>. </li>
</ul>
<p>Note that the <code>Curve_2</code> and <code>X_monotone_curve_2</code> are not the same, even if the <code>BaseTraits::Curve_2</code> and <code>BaseTraits::X_monotone_curve_2</code> are (as in the case of the segment-traits class for example). The extended curve types support the additional methods <code>data()</code> and <code>set_data()</code> for accessing and modifying the data field.</p>
<p>You can create an extended curve (or an extended \( x\)-monotone curve) from a basic curve and a curve-data object. When curves are inserted into an arrangement, they may be split, and the decorator handles their data fields automatically: </p><ul>
<li>
<p class="startli">When a curve is subdivided into \( x\)-monotone subcurves, its data field of type <code>CurveData</code> is converted to an <code>XMonotoneCurveData</code> object \( d\) using the <code>Convert</code> functor. The object \( d\) is automatically associated with each of the resulting \( x\)-monotone subcurves.</p>
<p class="endli">Note that by default, the <code>CurveData</code> type is identical to the <code>XMonotoneCurveData</code> type (and the conversion functor <code>Convert</code> is trivially defined). Thus, the data field associated with the original curve is just duplicated and stored with the \( x\)-monotone subcurves. </p>
</li>
<li>
When an \( x\)-monotone curve is split into two, the decorator class automatically copies its data field to both resulting subcurves. </li>
<li>
When intersecting two \( x\)-monotone curves \( c_1\) and \( c_2\), the result may include overlapping sections, represented as \( x\)-monotone curves. In this case the data fields of \( c_1\) and \( c_2\) are merged into a single <code>XMonotoneCurveData</code> object, using the <code>Merge</code> functor, which is supplied as a parameter to the traits class-template. The resulting object is assigned to the data field of the overlapping subcurves. </li>
<li>
Merging two \( x\)-monotone curves is allowed only when (i) the two curves are geometrically mergeable - that is, the base-traits class allows to merge them - and (ii) the two curves store the same data field. </li>
</ul>
<p>The <code><a class="el" href="classCGAL_1_1Arr__consolidated__curve__data__traits__2.html" title="The class Arr_consolidated_curve_data_traits_2 is a model of the concept ArrangementTraits_2, and serves as a decorator class that enables the extension of the curve type defined by the Traits parameter. ">Arr_consolidated_curve_data_traits_2</a>&lt;BaseTraits, Data&gt;</code> decorator specializes the generic curve-data decorator. It extends the basic <code>BaseTraits::Curve_2</code> by a single <code>Data</code> field, and the basic <code>BaseTraits::X_monotone_curve_2</code> with a <em>set</em> of (distinct) data objects. The <code>Data</code> type is required to support the equality operator, used to ensure that each set contains only distinct data objects with no duplicates. When a curve with a data field \( d\) is subdivided into \( x\)-monotone subcurves, each subcurve is associated with a set \( S = \{ d \}\). In case of an overlap between two \( x\)-monotone curves \( c_1\) and \( c_2\) with associated data sets \( S_1\) and \( S_2\), respectively, the overlapping subcurve is associated with the consolidated set \( S_1 \cup S_2\).</p>
<h2><a class="anchor" id="Arrangement_on_surface_2Examples"></a>
Examples</h2>
<p><a class="anchor" id="fig__arr_figex_17"></a></p><div class="image">
<img src="ex_17.png" alt="ex_17.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_17">Figure 34.22</a> An arrangement of six red and blue segments, as constructed in <code>consolidated_curve_data.cpp</code>. Disks correspond to red-blue intersection points, while circles mark the endpoints of red-blue overlaps.  </div>  <br />

<p>In the following example, we use <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> as our base-traits class, attaching an additional <em>color</em> field to the segments using the consolidated curve-data traits class. A color may be either <em>blue</em> or <em>red</em>. Having constructed the arrangement of colored segments, as depicted in <a class="el" href="index.html#fig__arr_figex_17">Figure 34.22</a>, we detect the vertices that have incident edges mapped to both blue and red segments. Thus, they correspond to red-blue intersection points. We also locate the edge that corresponds to overlaps between red and blue line segments:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2consolidated_curve_data_8cpp-example.html">Arrangement_on_surface_2/consolidated_curve_data.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Associating a color attribute with segments using the consolidated</span></div><div class="line"><span class="comment">// curve-data traits.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_consolidated_curve_data_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_landmarks_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> Segment_color {</div><div class="line">  RED,</div><div class="line">  BLUE</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>             Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                Segment_traits_2;</div><div class="line"><span class="keyword">typedef</span> Segment_traits_2::Curve_2                         Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__consolidated__curve__data__traits__2.html">CGAL::Arr_consolidated_curve_data_traits_2</a></div><div class="line">                   &lt;Segment_traits_2, Segment_color&gt;      Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                 Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                                 Colored_segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                     Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__landmarks__point__location.html">CGAL::Arr_landmarks_point_location&lt;Arrangement_2&gt;</a> Landmarks_pl;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct an arrangement containing three RED line segments.</span></div><div class="line">  Arrangement_2     arr;</div><div class="line">  Landmarks_pl      pl (arr);</div><div class="line"></div><div class="line">  Segment_2         s1 (Point_2(-1, -1), Point_2(1, 3));</div><div class="line">  Segment_2         s2 (Point_2(2, 0), Point_2(3, 3));</div><div class="line">  Segment_2         s3 (Point_2(0, 3), Point_2(2, 5));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Colored_segment_2 (s1, RED), pl);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Colored_segment_2 (s2, RED), pl);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Colored_segment_2 (s3, RED), pl);</div><div class="line"></div><div class="line">  <span class="comment">// Insert three BLUE line segments.</span></div><div class="line">  Segment_2         s4 (Point_2(-1, 3), Point_2(4, 1));</div><div class="line">  Segment_2         s5 (Point_2(-1, 0), Point_2(4, 1));</div><div class="line">  Segment_2         s6 (Point_2(-2, 1), Point_2(1, 4));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Colored_segment_2 (s4, BLUE), pl);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Colored_segment_2 (s5, BLUE), pl);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Colored_segment_2 (s6, BLUE), pl);</div><div class="line"></div><div class="line">  <span class="comment">// Go over all vertices and print just the ones corresponding to intersection</span></div><div class="line">  <span class="comment">// points between RED segments and BLUE segments. Note that we skip endpoints</span></div><div class="line">  <span class="comment">// of overlapping sections.</span></div><div class="line">  Arrangement_2::Vertex_const_iterator   vit;</div><div class="line">  Segment_color                          color;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    <span class="comment">// Go over the incident halfedges of the current vertex and examine their</span></div><div class="line">    <span class="comment">// colors.</span></div><div class="line">    <span class="keywordtype">bool</span>       has_red = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordtype">bool</span>       has_blue = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    Arrangement_2::Halfedge_around_vertex_const_circulator  eit, first;</div><div class="line"></div><div class="line">    eit = first = vit-&gt;incident_halfedges();</div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">      <span class="comment">// Get the color of the current half-edge.</span></div><div class="line">      <span class="keywordflow">if</span> (eit-&gt;curve().data().size() == 1) {</div><div class="line">        color = eit-&gt;curve().data().front();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (color == RED)</div><div class="line">          has_red = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (color == BLUE)</div><div class="line">          has_blue = <span class="keyword">true</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">      ++eit;</div><div class="line">    } <span class="keywordflow">while</span> (eit != first);</div><div class="line"></div><div class="line">    <span class="comment">// Print the vertex only if incident RED and BLUE edges were found.</span></div><div class="line">    <span class="keywordflow">if</span> (has_red &amp;&amp; has_blue)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"Red-blue intersection at ("</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">")"</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Locate the edges that correspond to a red-blue overlap.</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#a9b3a4b116e66f66bcd69215fa3f513f9">Arrangement_2::Edge_iterator</a>   eit;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (eit = arr.edges_begin(); eit != arr.edges_end(); ++eit)</div><div class="line">  {</div><div class="line">    <span class="comment">// Go over the incident edges of the current vertex and examine their</span></div><div class="line">    <span class="comment">// colors.</span></div><div class="line">    <span class="keywordtype">bool</span>       has_red = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordtype">bool</span>       has_blue = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    Traits_2::Data_container::const_iterator       dit;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (dit = eit-&gt;curve().data().begin(); dit != eit-&gt;curve().data().end();</div><div class="line">         ++dit)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (*dit == RED)</div><div class="line">        has_red = <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*dit == BLUE)</div><div class="line">        has_blue = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Print the edge only if it corresponds to a red-blue overlap.</span></div><div class="line">    <span class="keywordflow">if</span> (has_red &amp;&amp; has_blue)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"Red-blue overlap at ["</span> &lt;&lt; eit-&gt;curve() &lt;&lt; <span class="stringliteral">"]"</span>  &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__arr_figex_18"></a></p><div class="image">
<img src="ex_18.png" alt="ex_18.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_18">Figure 34.23</a> An arrangement of four polylines, named A-D, as constructed in <code>generic_curve_data.cpp</code>.  </div>  <br />

<p>In the following example, we use <code><a class="el" href="classCGAL_1_1Arr__polyline__traits__2.html" title="The traits class Arr_polyline_traits_2 handles piecewise linear curves, commonly referred to as polyl...">Arr_polyline_traits_2</a></code> as our base-traits class, attaching an additional <em>name</em> field to each polyline using the generic curve-data traits class. In case of overlaps, we simply concatenate the names of the overlapping polylines. Also notice how we replace the curve associated with the edges that correspond to overlapping polylines with geometrically equivalent curves, but with a different data fields:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2generic_curve_data_8cpp-example.html">Arrangement_on_surface_2/generic_curve_data.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Associating a name attribute with segments using the generic curve-data</span></div><div class="line"><span class="comment">// traits.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_polyline_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_curve_data_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a functor for concatenating name fields.</span></div><div class="line"><span class="keyword">typedef</span> std::string   Name;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Merge_names</div><div class="line">{</div><div class="line">  Name operator() (<span class="keyword">const</span> Name&amp; s1, <span class="keyword">const</span> Name&amp; s2)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (s1 + <span class="stringliteral">" "</span> + s2);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>           Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>              Segment_traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__polyline__traits__2.html">CGAL::Arr_polyline_traits_2&lt;Segment_traits_2&gt;</a>   Polyline_traits_2;</div><div class="line"><span class="keyword">typedef</span> Polyline_traits_2::Curve_2                      Polyline_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__curve__data__traits__2.html">CGAL::Arr_curve_data_traits_2&lt;Polyline_traits_2, Name, Merge_names&gt;</a></div><div class="line">                                                        Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                               Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                               Curve_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                    X_monotone_curve_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                   Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  Polyline_traits_2 traits;</div><div class="line">  Polyline_traits_2::Construct_curve_2 poly_const =</div><div class="line">    traits.construct_curve_2_object();</div><div class="line"></div><div class="line">  <span class="comment">// Construct an arrangement of four polylines named A--D.</span></div><div class="line">  Arrangement_2    arr;</div><div class="line"></div><div class="line">  Point_2          points1[5] = {Point_2(0,0), Point_2(2,4), Point_2(3,3),</div><div class="line">                                 Point_2(4,4), Point_2(6,0)};</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Curve_2 (poly_const (points1, points1 + 5), <span class="stringliteral">"A"</span>));</div><div class="line"></div><div class="line">  Point_2          points2[3] = {Point_2(1,5), Point_2(3,3), Point_2(5,5)};</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Curve_2 (poly_const (points2, points2 + 3), <span class="stringliteral">"B"</span>));</div><div class="line"></div><div class="line">  Point_2          points3[4] = {Point_2(1,0), Point_2(2,2),</div><div class="line">                                 Point_2(4,2), Point_2(5,0)};</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Curve_2 (poly_const (points3, points3 + 4), <span class="stringliteral">"C"</span>));</div><div class="line"></div><div class="line">  Point_2          points4[2] = {Point_2(0,2), Point_2(6,2)};</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Curve_2 (poly_const (points4, points4 + 2), <span class="stringliteral">"D"</span>));</div><div class="line"></div><div class="line">  <span class="comment">// Print all edges that correspond to an overlapping polyline.</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#a9b3a4b116e66f66bcd69215fa3f513f9">Arrangement_2::Edge_iterator</a>    eit;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (eit = arr.edges_begin(); eit != arr.edges_end(); ++eit) {</div><div class="line">    <span class="keywordflow">if</span> (eit-&gt;curve().data().length() &gt; 1) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; eit-&gt;curve() &lt;&lt; <span class="stringliteral">"]  "</span></div><div class="line">                &lt;&lt; <span class="stringliteral">"named: "</span> &lt;&lt; eit-&gt;curve().data() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="comment">// Rename the curve associated with the edge.</span></div><div class="line">      arr.modify_edge (eit, X_monotone_curve_2 (eit-&gt;curve(), <span class="stringliteral">"overlap"</span>));</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The third example we give in this section is based on <code>dual_lines.cpp</code> given in Section <a class="el" href="index.html#arr_ssecunb_global">Free Functions</a>. It constructs the arrangement of the dual lines for a set of point given in an input file (by default we use <code>coll_points.dat</code>, which contains \( 50\) points randomly selected on the grid \( [-100,100]\times[-100,100]\); the file contains two distinct triplets of collinear points). Here we use the generic curve-data decorator to attach the index of the primal point to each of the lines. Doing so, we can go over the incident edges of each vertex whose degree is greater than \( 4\) and report the subsets collinear points (if we have a vertex of degree \( d\), we actually need to go over \( \frac{d}{2}\) edges, as each incident line contributes exactly \( 2\) edges). Note that in this case the dual line cannot overlap, so we use a dummy merge functor to instantiate the curve-data traits:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2dual_with_data_8cpp-example.html">Arrangement_on_surface_2/dual_with_data.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Checking whether there are three collinear points in a given input set</span></div><div class="line"><span class="comment">// using the arrangement of the dual lines.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_linear_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_curve_data_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>            Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__linear__traits__2.html">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</a>                Linear_traits_2;</div><div class="line"><span class="keyword">typedef</span> Linear_traits_2::Point_2                         Point_2;</div><div class="line"><span class="keyword">typedef</span> Linear_traits_2::Line_2                          Line_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__curve__data__traits__2.html">CGAL::Arr_curve_data_traits_2</a>&lt;Linear_traits_2,</div><div class="line">                                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;      Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                     X_monotone_curve_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                    Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div><div class="line">  <span class="comment">// points.dat file if no command-line parameters are given.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> * filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"coll_points.dat"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Open the input file.</span></div><div class="line">  std::ifstream     in_file(filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">" ..."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> (1);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Read the points from the file, and construct their dual lines.</span></div><div class="line">  std::vector&lt;Point_2&gt;           points;</div><div class="line">  std::list&lt;X_monotone_curve_2&gt;  dual_lines;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n;</div><div class="line">  in_file &gt;&gt; n;</div><div class="line">  points.resize(n);</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;</div><div class="line">  <span class="keywordflow">for</span> (k = 0; k &lt; n; ++k) {</div><div class="line">    <span class="keywordtype">int</span> px, py;</div><div class="line">    in_file &gt;&gt; px &gt;&gt; py;</div><div class="line">    points[k] = Point_2(px, py);</div><div class="line"></div><div class="line">    <span class="comment">// The line dual to the point (p_x, p_y) is y = p_x*x - p_y,</span></div><div class="line">    <span class="comment">// or: p_x*x - y - p_y = 0:</span></div><div class="line">    Line_2 dual_line = Line_2(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(px),</div><div class="line">                              <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(-1),</div><div class="line">                              <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>(-py));</div><div class="line"></div><div class="line">    <span class="comment">// Generate the x-monotone curve based on the line and the point index.</span></div><div class="line">    dual_lines.push_back(X_monotone_curve_2(dual_line, k));</div><div class="line">  }</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Construct the dual arrangement by aggregately inserting the lines.</span></div><div class="line">  Arrangement_2 arr;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, dual_lines.begin(), dual_lines.end());</div><div class="line"></div><div class="line">  <span class="comment">// Look for vertices whose degree is greater than 4.</span></div><div class="line">  Arrangement_2::Vertex_const_iterator vit;</div><div class="line">  Arrangement_2::Halfedge_around_vertex_const_circulator circ;</div><div class="line">  <span class="keywordtype">size_t</span> d;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    <span class="keywordflow">if</span> (vit-&gt;degree() &gt; 4) {</div><div class="line">      <span class="comment">// There should be vit-&gt;degree()/2 lines intersecting at the current</span></div><div class="line">      <span class="comment">// vertex. We print their primal points and their indices.</span></div><div class="line">      circ = vit-&gt;incident_halfedges();</div><div class="line">      <span class="keywordflow">for</span> (d = 0; d &lt; vit-&gt;degree() / 2; d++) {</div><div class="line">        k = circ-&gt;curve().data();     <span class="comment">// The index of the primal point.</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Point no. "</span> &lt;&lt; k+1 &lt;&lt; <span class="stringliteral">": ("</span> &lt;&lt; points[k] &lt;&lt; <span class="stringliteral">"), "</span>;</div><div class="line">        ++circ;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"are collinear."</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="arr_secnotif"></a>
The Notification Mechanism</h1>
<p>For some applications it is essential to know exactly what happens inside a specific arrangement-instance. For example, when a new curve is inserted into an arrangement, it might be desired to keep track of the faces that are split due to this insertion operation. Other important examples are the point-location strategies that require auxiliary data-structures (see Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>), which must be notified on various local changes in the arrangement, in order to keep their data structures up-to-date. The arrangement package offers a mechanism that uses <em>observers</em> (see <a class="el" href="citelist.html#CITEREF_cgal:ghjv-dpero-95">[4]</a>) that can be attached to an arrangement instance and receive notifications about the changes this arrangement goes through.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a>&lt;Arrangement&gt;</code> class-template is parameterized with an arrangement class. It stores a pointer to an arrangement object, and is capable of receiving notifications <em>just before</em> a structural change occurs in the arrangement and <em>immediately after</em> such a change takes place. <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a></code> serves as a base class for other observer classes and defines a set of virtual notification functions, with default empty implementations.</p>
<p>The set of functions can be divided into three categories, as follows: </p><ol>
<li>
Notifiers of changes that affect the entire topological structure of the arrangement. This category consists of two pairs that notify the observer of the following changes: <ul>
<li>
The arrangement is cleared. </li>
<li>
The arrangement is assigned with the contents of another arrangement. </li>
</ul>
</li>
<li>
Pairs of notifiers of a local change that occurs in the topological structure. Most notifier functions belong to this category. The relevant local changes include: <ul>
<li>
A new vertex is constructed and associated with a point. </li>
<li>
An edge<span class="footnote">The term "edge" refers here to a pair of twin half-edges.</span> is constructed and associated with an \( x\)-monotone curve. </li>
<li>
An edge is split into two edges. </li>
<li>
An existing face is split into two faces, as a consequence of the insertion of a new edge. </li>
<li>
A hole is created in the interior of a face. </li>
<li>
Two holes are merged to form a single hole, as a consequence of the insertion of a new edge. </li>
<li>
A hole is moved from one face to another, as a consequence of a face split. </li>
<li>
Two edges are merged into one edge. </li>
<li>
Two faces are merged into one face, as a consequence of the removal of an edge that used to separate them. </li>
<li>
One hole is split into two, as a consequence of the deletion of an edge that used to connect the two components. </li>
<li>
A vertex is removed. </li>
<li>
An edge is removed. </li>
<li>
A hole is deleted from the interior of a face. </li>
</ul>
</li>
<li>
Notifiers about a change applied by a free (global) function. This category consists of a single pair of notifiers, namely <code>before_global_change()</code> and <code>after_global_change()</code>. Neither of these functions is invoked by methods of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class. Instead, they are called by the free functions themselves. It is implied that no point-location queries (or any other queries for that matter) are issued between the calls to the notification functions above. </li>
</ol>
<p>See the Reference Manual for a detailed specification of the <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a></code> class along with the exact prototypes of all notification functions.</p>
<p>Each arrangement object stores a (possibly empty) list of pointers to <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a></code> objects, and whenever one of the structural changes listed in the first two categories above is about to take place, the arrangement object performs a <em>forward</em> traversal on this list and invokes the appropriate function of each observer. After the change takes place the observer list is traversed in a <em>backward</em> manner (from tail to head), and the appropriate notification function is invoked for each observer. This allows the nesting of observer objects.</p>
<p>Concrete arrangement-observer classes should inherit from <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a></code>. When an observer is constructed, it is attached to a valid arrangement supplied to the observed constructor, or alternatively the observer can be attached to the arrangement at a later time. When this happens, the observer instance inserts itself into the observer list of the associated arrangement and starts receiving notifications whenever this arrangement changes thereafter. Naturally, the observer object unregisters itself by removing itself from this list just before it is destroyed.</p>
<p>The trapezoidal RIC and the landmark point-location strategies both use observers to keep their auxiliary data structures up-to-date. Besides them, users can define their own observer classes, by inheriting from the base observer class and overriding the relevant notification functions, as required by their applications.</p>
<p><a class="anchor" id="fig__arr_figex_19"></a></p><div class="image">
<img src="ex_19.png" alt="ex_19.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_19">Figure 34.24</a> An arrangement of five line segments, as constructed in <code>observer.cpp</code>. The halfedge \( e_v\) (dashed) is eventually removed, so that the final arrangement consists of four faces (one unbounded and three bounded ones).  </div>  <br />

<p>The following example shows how to define and use an observer class. The observer in the example keeps track of the arrangement faces, and prints a message whenever a face is split into two due to the insertion of an edge, and whenever two faces merge into one due to the removal of an edge. The layout of the arrangement is depicted in <a class="el" href="index.html#fig__arr_figex_19">Figure 34.24</a> :</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2observer_8cpp-example.html">Arrangement_on_surface_2/observer.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using a simple arrangement observer.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Quotient_8h.html">CGAL/Quotient.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/MP__Float_8h.html">CGAL/MP_Float.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_observer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">CGAL::Quotient&lt;CGAL::MP_Float&gt;</a>                Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>            Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                  Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                 Arrangement_2;</div><div class="line"></div><div class="line"><span class="comment">// An arrangement observer, used to receive notifications of face splits and</span></div><div class="line"><span class="comment">// face mergers.</span></div><div class="line"><span class="keyword">class </span>My_observer : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Arr__observer.html">CGAL::Arr_observer</a>&lt;Arrangement_2&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  My_observer (Arrangement_2&amp; arr) :</div><div class="line">    <a class="code" href="namespaceCGAL.html">CGAL</a>::Arr_observer&lt;Arrangement_2&gt; (arr)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> before_split_face (Face_handle,</div><div class="line">                                  Halfedge_handle e)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"-&gt; The insertion of :  [ "</span> &lt;&lt; e-&gt;curve()</div><div class="line">              &lt;&lt; <span class="stringliteral">" ]  causes a face to split."</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> before_merge_face (Face_handle,</div><div class="line">                                  Face_handle,</div><div class="line">                                  Halfedge_handle e)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"-&gt; The removal of :  [ "</span> &lt;&lt; e-&gt;curve()</div><div class="line">              &lt;&lt; <span class="stringliteral">" ]  causes two faces to merge."</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the arrangement containing one diamond-shaped face.</span></div><div class="line">  Arrangement_2  arr;</div><div class="line">  My_observer    obs (arr);</div><div class="line"></div><div class="line">  Segment_2      s1 (Point_2(-1, 0), Point_2(0, 1));</div><div class="line">  Segment_2      s2 (Point_2(0, 1), Point_2(1, 0));</div><div class="line">  Segment_2      s3 (Point_2(1, 0), Point_2(0, -1));</div><div class="line">  Segment_2      s4 (Point_2(0, -1), Point_2(-1, 0));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s2);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s3);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s4);</div><div class="line"></div><div class="line">  <span class="comment">// Insert a vertical segment dividing the diamond into two, and a</span></div><div class="line">  <span class="comment">// a horizontal segment further dividing the diamond into four:</span></div><div class="line">  Segment_2      s_vert (Point_2(0, -1), Point_2(0, 1));</div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#acdb9c49c90f9354f20c56efac599a7fe">Arrangement_2::Halfedge_handle</a></div><div class="line">                 e_vert = <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s_vert);</div><div class="line"></div><div class="line">  Segment_2      s_horiz (Point_2(-1, 0), Point_2(1, 0));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, s_horiz);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The initial arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges() </div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Now remove a portion of the vertical segment.</span></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#ga324fdf8354e7812fe0e1c0e5ac14196c">remove_edge</a> (arr, e_vert);</div><div class="line"> </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The final arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges() </div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Observers are especially useful when the <span style="font-variant: small-caps;">Dcel</span> records are extended and store additional data, as they help updating this data on-line. See Section <a class="el" href="index.html#arr_secex_dcel">Extending the DCEL</a> for more details and examples.</p>
<h1><a class="anchor" id="arr_secex_dcel"></a>
Extending the DCEL</h1>
<p>For many applications of the arrangement package it is necessary to store additional information (perhaps of non-geometric nature) with the arrangement cells. As vertices are associated with <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> objects and edges (halfedge pairs) are associated with <code>X_monotone_curve_2</code> objects, both defined by the traits class, it is possible to extend the traits-class type by using a traits-class decorator, as explained in Section <a class="el" href="index.html#arr_ssecmeta_tr">Traits-Class Decorators</a>, which may be a sufficient solution for some applications. However, the <span style="font-variant: small-caps;">Dcel</span> faces are not associated with any geometric object, so it is impossible to extend them using a traits-class decorator. Extending the <span style="font-variant: small-caps;">Dcel</span> face records comes handy is such cases. As a matter of fact, it is possible to conveniently extend all <span style="font-variant: small-caps;">Dcel</span> records (namely vertices, halfedges and faces), which can also be advantageous for some applications.</p>
<p>All examples presented so far use the default <code><a class="el" href="classCGAL_1_1Arr__default__dcel.html" title="The default Dcel class used by the Arrangement_2 class-template is parameterized by a traits class...">Arr_default_dcel</a>&lt;Traits&gt;</code>. This is done implicitly, as this class serves as a default parameter for the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> template. The default <span style="font-variant: small-caps;">Dcel</span> class just associates points with vertices and \( x\)-monotone curves with halfedge, but nothing more. In this section we show how to use alternative <span style="font-variant: small-caps;">Dcel</span> types to extend the desired <span style="font-variant: small-caps;">Dcel</span> records.</p>
<h2><a class="anchor" id="arr_ssecex_dcel_face"></a>
Extending the DCEL Faces</h2>
<p>The <code><a class="el" href="classCGAL_1_1Arr__face__extended__dcel.html" title="The Arr_face_extended_dcel class-template extends the Dcel face-records, making it possible to store ...">Arr_face_extended_dcel</a>&lt;Traits, FaceData&gt;</code> class-template is used to associate auxiliary data field of type <code>FaceData</code> to each face record in the <span style="font-variant: small-caps;">Dcel</span>.</p>
<p>When an <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> object is parameterized by this <span style="font-variant: small-caps;">Dcel</span> class, its nested <code>Face</code> type is extended with the access function <code>data()</code> and with the modifier <code>set_data()</code>. Using these extra functions it is straightforward to access and maintain the auxiliary face-data field.</p>
<p>Note that the extra data fields must be maintained by the application programmers. They may choose to construct their arrangement, and only then go over the faces and attach the appropriate data fields to the arrangement faces. However, in some cases the face data can only be computed when the face is created (split from another face, or merged with another face). In such cases one can use an arrangement observer tailored for this task, which receives updates whenever a face is modified and sets its data field accordingly.</p>
<p><a class="anchor" id="fig__arr_figex_20"></a></p><div class="image">
<img src="ex_20.png" alt="ex_20.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_20">Figure 34.25</a> An arrangement of six line segments, as constructed in <code>face_extension.cpp</code> and <code>dcel_extension.cpp</code> (in <code>dcel_extension.cpp</code> we treat the segments as directed, so they are drawn as arrows directed from the source to the target). The indices associated with the halfedges in <code>face_extension.cpp</code> are shown in brackets.  </div>  <br />

<p>The next example constructs an arrangement that contains seven bounded faces induced by six line segments (see <a class="el" href="index.html#fig__arr_figex_20">Figure 34.25</a>). An observer gets notified each time a new face \( f\) is created and it associates \( f\) with a running index, (where the index of the unbounded face is 0). As a result, the faces are numbered according to their creation order, as one can easily verify by examining the insertion order of the segments:<span class="footnote">For simplicity, the particular observer used must be attached to an empty arrangement. It is not difficult however to modify the program to handle the general case of attaching a similar observer to a non-empty arrangement.</span></p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2face_extension_8cpp-example.html">Arrangement_on_surface_2/face_extension.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Extending the arrangement-face records.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_observer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>          Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>             Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                              Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                   Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits_2, int&gt;</a>    Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</a>            Arrangement_2;</div><div class="line"></div><div class="line"><span class="comment">// An arrangement observer, used to receive notifications of face splits and</span></div><div class="line"><span class="comment">// to update the indices of the newly created faces.</span></div><div class="line"><span class="keyword">class </span>Face_index_observer : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Arr__observer.html">CGAL::Arr_observer</a>&lt;Arrangement_2&gt;</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span>     n_faces;          <span class="comment">// The current number of faces.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  Face_index_observer (Arrangement_2&amp; arr) :</div><div class="line">    <a class="code" href="namespaceCGAL.html">CGAL</a>::Arr_observer&lt;Arrangement_2&gt; (arr),</div><div class="line">    n_faces (0)</div><div class="line">  {</div><div class="line">    CGAL_precondition (arr.is_empty());</div><div class="line"></div><div class="line">    arr.unbounded_face()-&gt;set_data (0);</div><div class="line">    n_faces++;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> after_split_face (Face_handle <span class="comment">/* old_face */</span>,</div><div class="line">                                 Face_handle new_face, <span class="keywordtype">bool</span> )</div><div class="line">  {</div><div class="line">    <span class="comment">// Assign index to the new face.</span></div><div class="line">    new_face-&gt;set_data (n_faces);</div><div class="line">    n_faces++;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the arrangement containing two intersecting triangles.</span></div><div class="line">  Arrangement_2          arr;</div><div class="line">  Face_index_observer    obs (arr);</div><div class="line"></div><div class="line">  Segment_2      s1 (Point_2(4, 1), Point_2(7, 6));</div><div class="line">  Segment_2      s2 (Point_2(1, 6), Point_2(7, 6));</div><div class="line">  Segment_2      s3 (Point_2(4, 1), Point_2(1, 6));</div><div class="line">  Segment_2      s4 (Point_2(1, 3), Point_2(7, 3));</div><div class="line">  Segment_2      s5 (Point_2(1, 3), Point_2(4, 8));</div><div class="line">  Segment_2      s6 (Point_2(4, 8), Point_2(7, 3));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s2);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s3);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, s4);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, s5);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, s6);</div><div class="line"></div><div class="line">  <span class="comment">// Go over all arrangement faces and print the index of each face and it</span></div><div class="line">  <span class="comment">// outer boundary. The face index is stored in its data field in our case.</span></div><div class="line">  Arrangement_2::Face_const_iterator            fit;</div><div class="line">  Arrangement_2::Ccb_halfedge_const_circulator  curr;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; arr.number_of_faces() &lt;&lt; <span class="stringliteral">" faces:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Face no. "</span> &lt;&lt; fit-&gt;data() &lt;&lt; <span class="stringliteral">": "</span>;</div><div class="line">    <span class="keywordflow">if</span> (fit-&gt;is_unbounded())</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"Unbounded."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">      curr = fit-&gt;outer_ccb();</div><div class="line">      std::cout &lt;&lt; curr-&gt;source()-&gt;point();</div><div class="line">      <span class="keywordflow">do</span> {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">" --&gt; "</span> &lt;&lt; curr-&gt;target()-&gt;point();</div><div class="line">        ++curr;</div><div class="line">      } <span class="keywordflow">while</span> (curr != fit-&gt;outer_ccb());</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecex_dcel_all"></a>
Extending All DCEL Records</h2>
<p>The <code><a class="el" href="classCGAL_1_1Arr__extended__dcel.html" title="The Arr_extended_dcel class-template extends the topological-features of the Dcel namely the vertex...">Arr_extended_dcel</a>&lt;Traits, VertexData, HalfedgeData, FaceData&gt;</code> class-template is used to associate auxiliary data fields of types <code>VertexData</code> <code>HalfedgeData</code>, and <code>FaceData</code> to each <span style="font-variant: small-caps;">Dcel</span> vertex, halfedge, and face record types, respectively.</p>
<p>When an <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> object is injected with this <span style="font-variant: small-caps;">Dcel</span> class, each one of its nested <code>Vertex</code>, <code>Halfedge</code> and <code>Face</code> classes is extended by the access function <code>data()</code> and by the modifier <code>set_data()</code>.</p>
<p>The next example shows how to use a <span style="font-variant: small-caps;">Dcel</span> with extended vertex, halfedge, and face records. In this example each vertex is associated with a color, which may be blue, red, or white, depending on whether the vertex is isolated, represents a segment endpoint, or whether it represents an intersection point. Each halfedge is associated with Boolean flag indicating whether its direction is the same as the direction of its associated segment (in this example segments are treated as directed objects). Each face is also extended to store the size of its outer boundary.</p>
<p>The constructed arrangement, depicted in <a class="el" href="index.html#fig__arr_figex_20">Figure 34.25</a>, is similar to the arrangement constructed in the previous example. Note that all auxiliary data fields are set during the construction phase. Also note that the data fields are properly maintained when the arrangement is copied to another arrangement instance:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2dcel_extension_8cpp-example.html">Arrangement_on_surface_2/dcel_extension.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Extending all DCEL records (vertices, edges and faces).</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> Color {BLUE, RED, WHITE};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>                   Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                      Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                       Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                            Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__extended__dcel.html">CGAL::Arr_extended_dcel&lt;Traits_2,Color, bool, int&gt;</a>      Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</a>                     Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the arrangement containing two intersecting triangles.</span></div><div class="line">  Arrangement_2          arr;</div><div class="line"></div><div class="line">  Segment_2      s1 (Point_2(4, 1), Point_2(7, 6));</div><div class="line">  Segment_2      s2 (Point_2(1, 6), Point_2(7, 6));</div><div class="line">  Segment_2      s3 (Point_2(4, 1), Point_2(1, 6));</div><div class="line">  Segment_2      s4 (Point_2(1, 3), Point_2(7, 3));</div><div class="line">  Segment_2      s5 (Point_2(1, 3), Point_2(4, 8));</div><div class="line">  Segment_2      s6 (Point_2(4, 8), Point_2(7, 3));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s2);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s3);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, s4);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, s5);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, s6);</div><div class="line"></div><div class="line">  <span class="comment">// Go over all arrangement vertices and set their colors according to our</span></div><div class="line">  <span class="comment">// coloring convention.</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#ac4a88fd2ca22b490454e4f425005e5c4">Arrangement_2::Vertex_iterator</a>            vit;</div><div class="line">  std::size_t                               degree;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit)</div><div class="line">  {</div><div class="line">    degree = vit-&gt;degree();</div><div class="line">    <span class="keywordflow">if</span> (degree == 0)</div><div class="line">      vit-&gt;set_data (BLUE);       <span class="comment">// Isolated vertex.</span></div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (degree &lt;= 2)</div><div class="line">      vit-&gt;set_data (RED);        <span class="comment">// Vertex represents an endpoint.</span></div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      vit-&gt;set_data (WHITE);      <span class="comment">// Vertex represents an intersection point.</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Go over all arrangement edges and set their flags.</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#a9b3a4b116e66f66bcd69215fa3f513f9">Arrangement_2::Edge_iterator</a>              eit;</div><div class="line">  <span class="keywordtype">bool</span>                                      flag;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (eit = arr.edges_begin(); eit != arr.edges_end(); ++eit) {</div><div class="line">    <span class="comment">// Check if the halfedge has the same direction as its associated</span></div><div class="line">    <span class="comment">// segment. Note that its twin always has an opposite direction.</span></div><div class="line">    flag = (eit-&gt;source()-&gt;point() == eit-&gt;curve().source());</div><div class="line">    eit-&gt;set_data (flag);</div><div class="line">    eit-&gt;twin()-&gt;set_data (!flag);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// For each arrangement face, print the outer boundary and its size.</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#aa91e8147cf0a7cc30366af5b6f9a058e">Arrangement_2::Face_iterator</a>              fit;</div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#ab4a594c193ca09a672dbe2fcafa090e9">Arrangement_2::Ccb_halfedge_circulator</a>    curr;</div><div class="line">  <span class="keywordtype">int</span>                                       boundary_size;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit) {</div><div class="line">    boundary_size = 0;</div><div class="line">    <span class="keywordflow">if</span> (! fit-&gt;is_unbounded()) {</div><div class="line">      curr = fit-&gt;outer_ccb();</div><div class="line">      <span class="keywordflow">do</span> {</div><div class="line">        ++boundary_size;</div><div class="line">        ++curr;</div><div class="line">      } <span class="keywordflow">while</span> (curr != fit-&gt;outer_ccb());</div><div class="line">    }</div><div class="line">    fit-&gt;set_data (boundary_size);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Copy the arrangement and print the vertices.</span></div><div class="line">  Arrangement_2    arr2 = arr;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement vertices:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (vit = arr2.vertices_begin(); vit != arr2.vertices_end(); ++vit) {</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">'('</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">") - "</span>;</div><div class="line">    <span class="keywordflow">switch</span> (vit-&gt;data()) {</div><div class="line">     <span class="keywordflow">case</span> BLUE  : std::cout &lt;&lt; <span class="stringliteral">"BLUE."</span>  &lt;&lt; std::endl; <span class="keywordflow">break</span>;</div><div class="line">     <span class="keywordflow">case</span> RED   : std::cout &lt;&lt; <span class="stringliteral">"RED."</span>   &lt;&lt; std::endl; <span class="keywordflow">break</span>;</div><div class="line">     <span class="keywordflow">case</span> WHITE : std::cout &lt;&lt; <span class="stringliteral">"WHITE."</span> &lt;&lt; std::endl; <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>The various <span style="font-variant: small-caps;">Dcel</span> classes presented in this section are perfectly sufficient for most applications based on the arrangement package. However, users may also use their own implementation of a <span style="font-variant: small-caps;">Dcel</span> class to instantiate the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class-template, in case they need special functionality from their <span style="font-variant: small-caps;">Dcel</span>. Such a class must be a model of the concept <code><a class="el" href="classArrangementDcel.html" title="A doubly-connected edge-list (Dcel for short) data-structure. It consists of three containers of reco...">ArrangementDcel</a></code>, whose exact specification is listed in the Reference Manual.  </p></div> 
<h1><a class="anchor" id="arr_secoverlay"></a>
Overlaying Arrangements</h1>
<p>Assume that we are given two geographic maps represented as arrangements with some data objects attached to their faces, representing some geographic information - for example, a map of the annual precipitation in some country and a map of the vegetation in the same country. It is interesting to overlay the two maps to locate, for example, the regions where there is a pine forest and the annual precipitation is between 1000mm and 1500mm.</p>
<p>Computing the overlay of two planar arrangement is also useful for supporting Boolean set operations on polygons (or generalized polygons, see, e.g., <a class="el" href="citelist.html#CITEREF_cgal:behhms-cbcab-02">[2]</a>).</p>
<p>The function <code>overlay (arr_a, arr_b, ovl_arr, ovl_traits)</code> accepts two input arrangement instances <code>arr_a</code> and <code>arr_b</code>, and constructs their overlay instance <code>ovl_arr</code>. All three arrangements must use the same geometric primitives. More precisely, let <code>arr_a</code> be of type <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits_A,Dcel_A&gt;</code>, <code>arr_b</code> be of type <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits_B,Dcel_B&gt;</code> and the resulting <code>ovl_arr</code> be of type <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits_R,Dcel_R&gt;</code>. All types nested in geometry traits <code>Traits_A</code>, e.g., <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> and <code>X_monotone_curve_2</code>, must be convertible to the corresponding types nested in geometry traits <code>Traits_R</code>. The same holds for all types nested in geometry traits <code>Traits_B</code>. The <code>ovl_traits</code> parameter is an instance of an <em>overlay traits-class</em>, which enables the creation of <code>Dcel_R</code> records in the overlaid arrangement from the <span style="font-variant: small-caps;">Dcel</span> features of <code>arr_a</code> and <code>arr_b</code> that they correspond to.</p>
<p>In principle, we distinguish between three levels of overlay: </p><dl>
<dt><b>Simple overlay:</b></dt>
<dd><p class="startdd">An overlay of two arrangements that store no additional data with their <span style="font-variant: small-caps;">Dcel</span> records. That is, they are defined using the default <span style="font-variant: small-caps;">Dcel</span> class <code><a class="el" href="classCGAL_1_1Arr__default__dcel.html" title="The default Dcel class used by the Arrangement_2 class-template is parameterized by a traits class...">Arr_default_dcel</a></code>. Typically, the overlaid arrangement in this case stores no extra data with its <span style="font-variant: small-caps;">Dcel</span> records as well (or if it does, the additional data fields cannot be computed by the overlay operation), so by overlaying the two arrangement we just compute the arrangement of all curves that induce <code>arr_a</code> and <code>arr_b</code>. Note that the same result can be obtained using the standard insertion operations, but users may choose to use overlay computation in order to achieve better running times.</p>
<p class="enddd">The <code><a class="el" href="classCGAL_1_1Arr__default__overlay__traits.html" title="An instance of Arr_default_overlay_traits should be used for overlaying two arrangements of type Arra...">Arr_default_overlay_traits</a></code> class should be used as an overlay traits-class for such simple overlay operations. </p>
</dd>
<dt><b>Face overlay:</b></dt>
<dd><p class="startdd">An overlay of two arrangements that store additional data fields with their faces (e.g., the geographic-map example given in the beginning of this section). The resulting overlaid arrangement typically also stores extraneous data fields with its faces, where the data field that is attached to an overlaid face can be computed from the data fields of the two faces (in <code>arr_a</code> and <code>arr_b</code>) that induce the overlaid face.</p>
<p class="enddd">The <code><a class="el" href="classCGAL_1_1Arr__face__overlay__traits.html" title="An instance of Arr_face_overlay_traits should be used for overlaying two arrangements of types Arr_A ...">Arr_face_overlay_traits</a></code> class should be used as an overlay traits-class for face-overlay operations. It operates on arrangement, whose <span style="font-variant: small-caps;">Dcel</span> representation is based on the <code><a class="el" href="classCGAL_1_1Arr__face__extended__dcel.html" title="The Arr_face_extended_dcel class-template extends the Dcel face-records, making it possible to store ...">Arr_face_extended_dcel</a></code> class-template (see Section <a class="el" href="index.html#arr_ssecex_dcel_face">Extending the DCEL Faces</a>). The face-overlay traits-class is parameterized by a functor that is capable of combining two face-data fields of types <code>Dcel_A::Face_data</code> and <code>Dcel_B::Face_data</code>, and computing the output <code>Dcel_R::Face_data</code> object. The overlay traits-class uses this functor to properly construct the overlaid faces. </p>
</dd>
<dt><b>Full overlay:</b></dt>
<dd>An overlay of two arrangements that store additional data fields with all their <span style="font-variant: small-caps;">Dcel</span> records. That is, their <span style="font-variant: small-caps;">Dcel</span> classes are instantiations of the <code><a class="el" href="classCGAL_1_1Arr__extended__dcel.html" title="The Arr_extended_dcel class-template extends the topological-features of the Dcel namely the vertex...">Arr_extended_dcel</a></code> class-template (see Section <a class="el" href="index.html#arr_ssecex_dcel_all">Extending All DCEL Records</a>), where the resulting arrangement also extends it <span style="font-variant: small-caps;">Dcel</span> records with data fields computed on the basis of the overlapping <span style="font-variant: small-caps;">Dcel</span> features of the two input arrangements. </dd>
</dl>
<p>In the following subsections we give some examples for the simple and the face-overlay operations and demonstrate how to use the auxiliary overlay traits-classes. For the full overlay operations users need to implement their specialized overlay traits-class, which models the <code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices, halfedges and faces) of two input Dcel classes, named Dcel_A and Dcel_B, and construct the records of an output Dcel class, referred to as Dcel_R. ">OverlayTraits</a></code> concept. The details of this concept are given in the Reference Manual.</p>
<h2><a class="anchor" id="arr_ssecsimp_ovl"></a>
Example for a Simple Overlay</h2>
<p><a class="anchor" id="fig__arr_figex_22"></a></p><div class="image">
<img src="ex_22.png" alt="ex_22.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_22">Figure 34.26</a> Overlaying two simple arrangements of line segments, as done in <code>overlay.cpp</code> and <code>ex_face_extension_overlay.cpp</code>. In <code>face_extension_overlay.cpp</code> the two bounded faces are considered as <em>marked</em>, and the octagonal face which is the intersection of the two marked faces is denoted by \( f_0\).  </div>  <br />

<p>The next program constructs two simple arrangements, as depicted in <a class="el" href="index.html#fig__arr_figex_22">Figure 34.26</a> and computes their overlay:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2overlay_8cpp-example.html">Arrangement_on_surface_2/overlay.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// A simple overlay of two arrangements.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_overlay_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_default_overlay_traits.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>            Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>               Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                     Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                    Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__default__overlay__traits.html">CGAL::Arr_default_overlay_traits&lt;Arrangement_2&gt;</a>  Overlay_traits;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the first arrangement, containing a square-shaped face.</span></div><div class="line">  Arrangement_2          arr1;</div><div class="line"></div><div class="line">  Segment_2      s1 (Point_2(2, 2), Point_2(6, 2));</div><div class="line">  Segment_2      s2 (Point_2(6, 2), Point_2(6, 6));</div><div class="line">  Segment_2      s3 (Point_2(6, 6), Point_2(2, 6));</div><div class="line">  Segment_2      s4 (Point_2(2, 6), Point_2(2, 2));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr1, s1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr1, s2);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr1, s3);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr1, s4);</div><div class="line"></div><div class="line">  <span class="comment">// Construct the second arrangement, containing a rhombus-shaped face.</span></div><div class="line">  Arrangement_2          arr2;</div><div class="line"></div><div class="line">  Segment_2      t1 (Point_2(4, 1), Point_2(7, 4));</div><div class="line">  Segment_2      t2 (Point_2(7, 4), Point_2(4, 7));</div><div class="line">  Segment_2      t3 (Point_2(4, 7), Point_2(1, 4));</div><div class="line">  Segment_2      t4 (Point_2(1, 4), Point_2(4, 1));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr2, t1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr2, t2);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr2, t3);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr2, t4);</div><div class="line"></div><div class="line">  <span class="comment">// Compute the overlay of the two arrangements.</span></div><div class="line">  Arrangement_2          overlay_arr;</div><div class="line">  Overlay_traits         overlay_traits;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#ga339cdba93f54001be303595689002396">overlay</a> (arr1, arr2, overlay_arr, overlay_traits);</div><div class="line"></div><div class="line">  <span class="comment">// Print the size of the overlaid arrangement.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The overlaid arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; overlay_arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; overlay_arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; overlay_arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecface_ovl"></a>
Examples for a Face Overlay</h2>
<p>The following example shows how to compute the intersection of two polygons using the <code><a class="el" href="group__PkgArrangement2Funcs.html#ga339cdba93f54001be303595689002396" title="Computes the overlay of two arrangements arr1 and arr2, and sets the output arrangement res to repres...">overlay()</a></code> function. It uses a face-extended <span style="font-variant: small-caps;">Dcel</span> class to define our arrangement class. The <span style="font-variant: small-caps;">Dcel</span> extends each face with a Boolean flag. A polygon is represented as a <em>marked</em> arrangement face, (whose flag is set). The example uses a face-overlay traits class, instantiated with a functor that simply performs a logical <em>and</em> operations on Boolean flags. As a result, a face in the overlaid arrangement is marked only when it corresponds to an overlapping region of two marked cells in the input arrangements. Namely, it is part of the intersection of the two polygons.</p>
<p>The example computes the intersection between a square and a rhombus, (which is actually also a square). The resulting polygon is an octagon, denoted by \( f_0\) in <a class="el" href="index.html#fig__arr_figex_22">Figure 34.26</a> :</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2face_extension_overlay_8cpp-example.html">Arrangement_on_surface_2/face_extension_overlay.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// A face overlay of two arrangements with extended face records.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_overlay_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_default_overlay_traits.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>                   Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                      Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                       Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                            Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits_2, bool&gt;</a>            Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</a>                     Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__overlay__traits.html">CGAL::Arr_face_overlay_traits</a>&lt;Arrangement_2,</div><div class="line">                                      Arrangement_2,</div><div class="line">                                      Arrangement_2,</div><div class="line">                                      std::logical_and&lt;bool&gt; &gt;  Overlay_traits;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the first arrangement, containing a square-shaped face.</span></div><div class="line">  Arrangement_2          arr1;</div><div class="line"></div><div class="line">  Segment_2      s1 (Point_2(2, 2), Point_2(6, 2));</div><div class="line">  Segment_2      s2 (Point_2(6, 2), Point_2(6, 6));</div><div class="line">  Segment_2      s3 (Point_2(6, 6), Point_2(2, 6));</div><div class="line">  Segment_2      s4 (Point_2(2, 6), Point_2(2, 2));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr1, s1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr1, s2);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr1, s3);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr1, s4);</div><div class="line"></div><div class="line">  <span class="comment">// Mark just the bounded face.</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#aa91e8147cf0a7cc30366af5b6f9a058e">Arrangement_2::Face_iterator</a>   fit;</div><div class="line"></div><div class="line">  CGAL_assertion (arr1.number_of_faces() == 2);</div><div class="line">  <span class="keywordflow">for</span> (fit = arr1.faces_begin(); fit != arr1.faces_end(); ++fit)</div><div class="line">    fit-&gt;set_data (fit != arr1.unbounded_face());</div><div class="line"></div><div class="line">  <span class="comment">// Construct the second arrangement, containing a rhombus-shaped face.</span></div><div class="line">  Arrangement_2          arr2;</div><div class="line"></div><div class="line">  Segment_2      t1 (Point_2(4, 1), Point_2(7, 4));</div><div class="line">  Segment_2      t2 (Point_2(7, 4), Point_2(4, 7));</div><div class="line">  Segment_2      t3 (Point_2(4, 7), Point_2(1, 4));</div><div class="line">  Segment_2      t4 (Point_2(1, 4), Point_2(4, 1));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr2, t1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr2, t2);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr2, t3);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr2, t4);</div><div class="line"></div><div class="line">  <span class="comment">// Mark just the bounded face.</span></div><div class="line">  CGAL_assertion (arr2.number_of_faces() == 2);</div><div class="line">  <span class="keywordflow">for</span> (fit = arr2.faces_begin(); fit != arr2.faces_end(); ++fit)</div><div class="line">    fit-&gt;set_data (fit != arr2.unbounded_face());</div><div class="line"></div><div class="line">  <span class="comment">// Compute the overlay of the two arrangements, marking only the faces that</span></div><div class="line">  <span class="comment">// are intersections of two marked faces in arr1 and arr2, respectively.</span></div><div class="line">  Arrangement_2          overlay_arr;</div><div class="line">  Overlay_traits         overlay_traits;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#ga339cdba93f54001be303595689002396">overlay</a> (arr1, arr2, overlay_arr, overlay_traits);</div><div class="line"></div><div class="line">  <span class="comment">// Go over the faces of the overlaid arrangement and print just the marked</span></div><div class="line">  <span class="comment">// ones.</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#ab4a594c193ca09a672dbe2fcafa090e9">Arrangement_2::Ccb_halfedge_circulator</a>    curr;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The union is: "</span>;</div><div class="line">  <span class="keywordflow">for</span> (fit = overlay_arr.faces_begin(); fit != overlay_arr.faces_end(); ++fit) {</div><div class="line">    <span class="keywordflow">if</span> (! fit-&gt;data())</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    curr = fit-&gt;outer_ccb();</div><div class="line">    std::cout &lt;&lt; curr-&gt;source()-&gt;point();</div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">" --&gt; "</span> &lt;&lt; curr-&gt;target()-&gt;point();</div><div class="line">      ++curr;</div><div class="line">    } <span class="keywordflow">while</span> (curr != fit-&gt;outer_ccb());</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The next example demonstrates the face overlay of two arrangements that have unbounded faces as well. The first arrangement is formed by the two lines \( y = x\) and \( y = -x\), that subdivide the plane into four unbounded faces, denoted \( A\), \( B\), \( C\) and \( D\). The second arrangement comprises four line segments that form a square-shaped face. When we overlay the two arrangements, each of the four faces \( A\), \( B\), \( C\) and \( D\) is split into an unbounded face (indexed 1) and a bounded face (indexed 2):</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2overlay_unbounded_8cpp-example.html">Arrangement_on_surface_2/overlay_unbounded.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// A face overlay of two arrangements with unbounded faces.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_linear_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_overlay_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_default_overlay_traits.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a functor for creating a label from a character and an integer.</span></div><div class="line"><span class="keyword">struct </span>Overlay_label</div><div class="line">{</div><div class="line">  std::string operator() (<span class="keywordtype">char</span> c, <span class="keywordtype">int</span> i)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> boost::lexical_cast&lt;std::string&gt;(c) +</div><div class="line">      boost::lexical_cast&lt;std::string&gt;(i);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>   Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__linear__traits__2.html">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</a>                   Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                   Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Segment_2                                 Segment_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Ray_2                                     Ray_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Line_2                                    Line_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                        X_monotone_curves_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits_2, char&gt;</a>        DcelA;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, DcelA&gt;</a>                ArrangementA_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits_2, int&gt;</a>         DcelB;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, DcelB&gt;</a>                ArrangementB_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits_2, std::string&gt;</a> DcelRes;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, DcelRes&gt;</a>              ArrangementRes_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__overlay__traits.html">CGAL::Arr_face_overlay_traits</a>&lt;ArrangementA_2,</div><div class="line">                                      ArrangementB_2,</div><div class="line">                                      ArrangementRes_2,</div><div class="line">                                      Overlay_label&gt;        Overlay_traits;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the first arrangement, induced by two line y = x and y = -x.</span></div><div class="line">  ArrangementA_2          arr1;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr1, Line_2 (Point_2(0, 0), Point_2(1, 1)));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr1, Line_2 (Point_2(0, 0), Point_2(1, -1)));</div><div class="line"></div><div class="line">  <span class="comment">// Label the four (unbounded) face of the arrangement as 'A' to 'D'.</span></div><div class="line">  <span class="comment">// We do so by traversing the incident faces to the halfedges around the</span></div><div class="line">  <span class="comment">// single arrangement vertex (0, 0).</span></div><div class="line">  CGAL_assertion (arr1.number_of_vertices() == 1);</div><div class="line"></div><div class="line">  ArrangementA_2::Halfedge_around_vertex_circulator  first, curr;</div><div class="line">  <span class="keywordtype">char</span>                                               clabel = <span class="charliteral">'A'</span>;</div><div class="line"></div><div class="line">  curr = first = arr1.vertices_begin()-&gt;incident_halfedges();</div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">    curr-&gt;face()-&gt;set_data (clabel);</div><div class="line">    ++clabel;</div><div class="line">    ++curr;</div><div class="line">  } <span class="keywordflow">while</span> (curr != first);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Done with arr1."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Construct the second arrangement, containing a single square-shaped face.</span></div><div class="line">  ArrangementB_2          arr2;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr2, Segment_2 (Point_2(-4, -4), Point_2(4, -4)));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr2, Segment_2 (Point_2(4, -4), Point_2(4, 4)));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr2, Segment_2 (Point_2(4, 4), Point_2(-4, 4)));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr2, Segment_2 (Point_2(-4, 4), Point_2(-4, -4)));</div><div class="line"></div><div class="line">  <span class="comment">// Give the unbounded face the index 1, and the bounded face the index 2. </span></div><div class="line">  CGAL_assertion (arr2.number_of_faces() == 2);</div><div class="line"></div><div class="line">  ArrangementB_2::Face_iterator    fit;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (fit = arr2.faces_begin(); fit != arr2.faces_end(); ++fit)</div><div class="line">    fit-&gt;set_data ((fit == arr2.unbounded_face()) ? 1 : 2);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Done with arr2."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Compute the overlay of the two arrangements.</span></div><div class="line">  ArrangementRes_2       overlay_arr;</div><div class="line">  Overlay_traits         overlay_traits;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#ga339cdba93f54001be303595689002396">overlay</a> (arr1, arr2, overlay_arr, overlay_traits);</div><div class="line"></div><div class="line">  <span class="comment">// Go over the faces of the overlaid arrangement and their labels.</span></div><div class="line">  ArrangementRes_2::Face_iterator  res_fit;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The overlay faces are: "</span>;</div><div class="line">  <span class="keywordflow">for</span> (res_fit = overlay_arr.faces_begin();</div><div class="line">       res_fit != overlay_arr.faces_end(); ++res_fit)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; res_fit-&gt;data() &lt;&lt; <span class="stringliteral">" ("</span></div><div class="line">              &lt;&lt; (res_fit-&gt;is_unbounded() ? <span class="stringliteral">"unbounded"</span> : <span class="stringliteral">"bounded"</span>)</div><div class="line">              &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="arr_secarr_with_hist"></a>
Storing the Curve History</h1>
<p>As stated at the beginning of this chapter (Section <a class="el" href="index.html#arr_secintro">Introduction</a>), when one constructs an arrangement induced by a set \( \cal C\) of arbitrary planar curves, she or he constructs a collection \( \cal C''\) of \( x\)-monotone subcurves of \( \cal C\) that are pairwise disjoint in their interior, and these subcurves are associated with the arrangement edges (more precisely, with the <span style="font-variant: small-caps;">Dcel</span> halfedges). Doing so, the connection between the originating input curves and the arrangement edges is lost. This loss might be acceptable for some applications. However, in many practical cases it is important to determine the input curves that give rise to the final subcurves.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt;Traits,Dcel&gt;</code> class-template extends the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class by keeping an additional container of input curves representing \( \cal C\), and by maintaining a cross-mapping between these curves and the arrangement edges they induce. The traits class that is used for instantiating the template should be a model of the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> concept (see Section <a class="el" href="index.html#arr_sssecinsert_gen">Inserting General Curves</a>). That is, it should define the <code>Curve_2</code> type (and not just the <code>X_monotone_curve_2</code> type). The <code>Dcel</code> parameter should model the <code><a class="el" href="classArrangementDcel.html" title="A doubly-connected edge-list (Dcel for short) data-structure. It consists of three containers of reco...">ArrangementDcel</a></code> concept. Users can use the default <span style="font-variant: small-caps;">Dcel</span> class or an extended <span style="font-variant: small-caps;">Dcel</span> class according to their needs.</p>
<h2><a class="anchor" id="arr_ssecarrwh_traverse"></a>
Traversing an Arrangement with History</h2>
<p>The <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> class extends the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class, thus all the iterator and circulator types that are defined by the arrangement class are also available in <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code>. The reader is referred to Section <a class="el" href="index.html#arr_ssectraverse">Traversing the Arrangement</a> for a comprehensive review of these functions.</p>
<p>As mentioned above, the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> class maintains a container of input curves, which can be accessed using curve handles. The member function <code>number_of_curves()</code> returns the number of input curves stored in the container, while <code>curves_begin()</code> and <code>curves_end()</code> return <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#a1107ce3eaa58fe48844af22d430f70fd" title="a bidirectional iterator over the curves that induce the arrangement. ">Arrangement_with_history_2::Curve_iterator</a></code> objects that define the valid range of curves that induce the arrangement. The value type of this iterator is <code>Curve_2</code>. Moreover, the curve-iterator type is equivalent to <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#a0f91465846104329a0a99090b0d7f3f6" title="a handle for an input curve. ">Arrangement_with_history_2::Curve_handle</a></code>, which is used for accessing the stored curves. Conveniently, the corresponding constant-iterator and constant-handle types are also defined.</p>
<p>As mentioned in the previous paragraph, a <code>Curve_handle</code> object <code>ch</code> serves as a pointer to a curve stored in an arrangement-with-history instance <code>arr</code>. Using this handle, it is possible to obtain the number of arrangement edges this curve induces by calling <code>arr.number_of_induced_edges(ch)</code>. The functions <code>arr.induced_edges_begin(ch)</code> and <code>arr.induced_edges_end(ch)</code> return iterators of type <code>Arrangement_with_history_2::Induced_edges_iterator</code> that define the valid range of edges induced by <code>ch</code>. The value type of these iterators is <code>Halfedge_handle</code>. It is thus possible to traverse all arrangement edges induced by an input curve.</p>
<p>It is also important to be able to perform the inverse mapping. Given an arrangement edge, we would like to be able to determine which input curve induces it. In case the edge represents an overlap of several curves, we should be able to trace all input curves that overlap over this edge. The <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> class is extended by several member functions that enable such an inverse mapping. Given a halfedge handle <code>e</code> in an arrangement with history <code>arr</code>, then <code>arr.number_of_originating_curves(e)</code> returns the number of curves that induce the edge (which should be 1 in non-degenerate cases, and 2 or more in case of overlaps), while <code>arr.originating_curves_begin(e)</code> and <code>arr.originating_curves_end(e)</code> return <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#aed5c031ddfa2bbd690ff0d08c8835131" title="an iterator for the curves that originate a given arrangement edge. ">Arrangement_with_history_2::Originating_curve_iterator</a></code> objects that define the range of curves that induce <code>e</code>. The value type of these iterator is <code>Curve_2</code>.</p>
<p>It is possible to overlay two <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> instances instantiated by the same traits class. In this case, the resulting arrangement will store a consolidated container of input curves, and automatically preserve the cross-mapping between the arrangement edges and the consolidated curve set. Users can employ an overlay-traits class to maintain any type of auxiliary data stored with the <span style="font-variant: small-caps;">Dcel</span> features (see Section <a class="el" href="index.html#arr_secoverlay">Overlaying Arrangements</a>).</p>
<h2><a class="anchor" id="arr_ssecmodif_traverse"></a>
Modifying an Arrangement with History</h2>
<p>As the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> class extends the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class, it inherits the fundamental modification operations, such as <code>assign()</code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga4d3b9bb446f55fd37206eeba9d582296">clear()</a></code>, from it. The vertex-manipulation functions are also inherited and supported (see Sections <a class="el" href="index.html#arr_sssecmf_iso_verts">Manipulating Isolated Vertices</a> and <a class="el" href="index.html#arr_sssecinsert_point">Inserting Points</a> for the details). However, there are some fundamental differences between the interfaces of the two classes, which we highlight in this subsection.</p>
<p>The most significant difference between the arrangement-with-history class and the basic arrangement class is the way they handle their input curves. <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> always stores the <code>Curve_2</code> objects that induce it, thus it is impossible to insert \( x\)-monotone curves into an arrangement with history. The free <code><a class="el" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225" title="Inserts a given -monotone curve into a given arrangement, where the interior of the given curve is di...">insert_non_intersecting_curve()</a></code> and <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code> that receives \( x\)-monotone curve (as well as their aggregated versions) are therefore not available for arrangement-with-history instances and only the free <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code> and <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code> functions that receive <code>Curve_2</code> (the incremental insertion function and the aggregated insertion function) are supported - see also Section <a class="el" href="index.html#arr_sssecinsert_gen">Inserting General Curves</a>. Notice however that while the incremental insertion function <code>insert(arr,c)</code> for an <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> object <code>arr</code> does not have a return value, the corresponding arrangement-with-history function returns a <code>Curve_handle</code> to the inserted curve.</p>
<p>As we are able to keep track of all edges induced by an input curve, we also provide a free function that removes a curve from an arrangement. By calling <code>remove(arr,ch)</code>, where <code>ch</code> is a valid curve handle, the given curve is deleted from the curve container, and all edges induced solely by this curve (i.e., excluding overlapping edges) are removed from the arrangement. The function returns the number of edges that have been removed.</p>
<p>In some cases, users may need to operate directly on the arrangement edges. We first mention that the specialized insertion functions (see Section <a class="el" href="index.html#arr_sssecmf_insert_cv">Inserting Non-Intersecting x-Monotone Curves</a>) are not supported, as they accept \( x\)-monotone curves. Insertion can only be performed via the free insertion-functions. The other edge-manipulation functions (see Section <a class="el" href="index.html#arr_sssecmf_halfedges">Manipulating Halfedges</a>) are however available, but have a different interface that does not use \( x\)-monotone curves: </p><ul>
<li>
Invoking <code>split_edge(e,p)</code> splits the edge <code>e</code> at a given point <code>p</code> that lies in its interior. </li>
<li>
Invoking <code>merge_edge(e1,e2)</code> merges the two given edges. There is a precondition that <code>e1</code> and <code>e2</code> shared a common end-vertex of degree 2, and that the \( x\)-monotone subcurves associated with these edges are mergeable. </li>
<li>
It is possible to remove an edge by simply invoking <code>remove_edge(e)</code>. </li>
</ul>
<p>In all cases, the maintenance of cross-pointers for the appropriate input curves will be done automatically.</p>
<p>It should be noted that it is possible to attach observers to an arrangement-with-history instance in order to get detailed notifications of the changes the arrangements undergoes (see Section <a class="el" href="index.html#arr_secnotif">The Notification Mechanism</a> for the details).</p>
<h2><a class="anchor" id="arr_ssecarr_hist_ex"></a>
Examples</h2>
<p><a class="anchor" id="fig__arr_figex_24"></a></p><div class="image">
<img src="ex_24.png" alt="ex_24.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_24">Figure 34.27</a> An arrangement with history as constructed in <code>curve_history.cpp</code>. Note that \( s_1\) and \( s_3\) overlap over two edges. The point-location query points are drawn as lightly shaded dots.  </div>  <br />

<p>In the following example we construct a simple arrangement of six line segments, as depicted in <a class="el" href="index.html#fig__arr_figex_24">Figure 34.27</a>, while maintaining the curve history. The example demonstrates the usage of the special traversal functions. It also shows how to issue point-location queries on the resulting arrangement, using the auxiliary function <code>locate_point()</code> defined in the header file <code>point_location_utils.h</code>; see also Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2curve_history_8cpp-example.html">Arrangement_on_surface_2/curve_history.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement with curve history.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_on_surface_with_history_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_with_history_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_simple_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "point_location_utils.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>             Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                 Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                                 Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__with__history__2.html">CGAL::Arrangement_with_history_2&lt;Traits_2&gt;</a>        Arr_with_hist_2;</div><div class="line"><span class="keyword">typedef</span> Arr_with_hist_2::Curve_handle                     Curve_handle;</div><div class="line"><span class="keyword">typedef</span> CGAL::Arr_simple_point_location&lt;Arr_with_hist_2&gt;  Point_location;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Arr_with_hist_2   arr;</div><div class="line"></div><div class="line">  <span class="comment">// Insert s1, s2 and s3 incrementally:</span></div><div class="line">  Segment_2 s1(Point_2(0, 3), Point_2(4, 3));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s1);</div><div class="line">  Segment_2 s2(Point_2(3, 2), Point_2(3, 5));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s2);</div><div class="line">  Segment_2 s3(Point_2(2, 3), Point_2(5, 3));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s3);</div><div class="line"></div><div class="line">  <span class="comment">// Insert three additional segments aggregately:</span></div><div class="line">  Segment_2 segs[3];</div><div class="line">  segs[0] = Segment_2(Point_2(2, 6), Point_2(7, 1));</div><div class="line">  segs[1] = Segment_2(Point_2(0, 0), Point_2(2, 6));</div><div class="line">  segs[2] = Segment_2(Point_2(3, 4), Point_2(6, 4));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, segs, segs + 3);</div><div class="line"></div><div class="line">  <span class="comment">// Print out the curves and the number of edges each one induces.</span></div><div class="line">  Arr_with_hist_2::Curve_iterator            cit;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement contains "</span></div><div class="line">            &lt;&lt; arr.number_of_curves() &lt;&lt; <span class="stringliteral">" curves:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (cit = arr.curves_begin(); cit != arr.curves_end(); ++cit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Curve ["</span> &lt;&lt; *cit &lt;&lt; <span class="stringliteral">"] induces "</span></div><div class="line">              &lt;&lt; arr.number_of_induced_edges(cit) &lt;&lt; <span class="stringliteral">" edges."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement edges, along with the list of curves that</span></div><div class="line">  <span class="comment">// induce each edge.</span></div><div class="line">  Arr_with_hist_2::Edge_iterator                  eit;</div><div class="line">  Arr_with_hist_2::Originating_curve_iterator     ocit;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement is comprised of "</span></div><div class="line">            &lt;&lt; arr.number_of_edges() &lt;&lt; <span class="stringliteral">" edges:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (eit = arr.edges_begin(); eit != arr.edges_end(); ++eit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; eit-&gt;curve() &lt;&lt; <span class="stringliteral">"]. Originating curves: "</span>;</div><div class="line">    <span class="keywordflow">for</span> (ocit = arr.originating_curves_begin(eit);</div><div class="line">         ocit != arr.originating_curves_end(eit); ++ocit)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; *ocit &lt;&lt; <span class="stringliteral">"]"</span> &lt;&lt; std::flush;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Perform some point-location queries:</span></div><div class="line">  Point_location   pl(arr);</div><div class="line"></div><div class="line">  Point_2          p1(4, 6);</div><div class="line">  point_location_query(pl, p1);</div><div class="line">  Point_2          p2(6, 2);</div><div class="line">  point_location_query(pl, p2);</div><div class="line">  Point_2          p3(2, 4);</div><div class="line">  point_location_query(pl, p3);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__arr_figex_25"></a></p><div class="image">
<img src="ex_25.png" alt="ex_25.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_25">Figure 34.28</a> An arrangement with history of nine circle as constructed in <code>edge_manipulation_curve_history.cpp</code>. Note the vertical tangency points of \( C_0\), marked as dark dots, which subdivide this circle into an upper half and a lower half, each consists of 9 edges. The large circle \( C_0\) is eventually removed from the arrangement, with all 18 edges it induces.  </div>  <br />

<p>The following example demonstrates the usage of the free <code>remove()</code> function. We construct an arrangement of nine circles, while keeping a handle to each inserted circle. We then remove the large circle \( C_0\), which induces \( 18\) edges, as depicted in <a class="el" href="index.html#fig__arr_figex_25">Figure 34.28</a>. The example also shows how to use the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga8a7629a2a0659ca059081eae8cedca3d">split_edge()</a></code> and <code>merge_edge()</code> functions when operating on an arrangement-with-history instance:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2edge_manipulation_curve_history_8cpp-example.html">Arrangement_on_surface_2/edge_manipulation_curve_history.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Removing curves and manipulating edges in an arrangement with history.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_circle_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_with_history_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                               Rat_point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Circle__2.html">Kernel::Circle_2</a>                              Circle_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__circle__segment__traits__2.html">CGAL::Arr_circle_segment_traits_2&lt;Kernel&gt;</a>     Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                             Curve_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__with__history__2.html">CGAL::Arrangement_with_history_2&lt;Traits_2&gt;</a>    Arr_with_hist_2;</div><div class="line"><span class="keyword">typedef</span> Arr_with_hist_2::Curve_handle                 Curve_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__walk__along__line__point__location.html">CGAL::Arr_walk_along_line_point_location&lt;Arr_with_hist_2&gt;</a></div><div class="line">                                                      Point_location;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct an arrangement containing nine circles: C[0] of radius 2 and</span></div><div class="line">  <span class="comment">// C[1], ..., C[8] of radius 1.</span></div><div class="line">  <span class="keyword">const</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a> _7_halves = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__cgal.html#ga0849ff44771b19582218ebdfa5614f64">CGAL::Exact_rational</a>(7, 2);</div><div class="line">  Arr_with_hist_2 arr;</div><div class="line">  Curve_2 C[9];</div><div class="line">  Curve_handle handles[9];</div><div class="line"></div><div class="line">  C[0] = Circle_2(Rat_point_2(_7_halves, _7_halves), 4, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[1] = Circle_2(Rat_point_2(_7_halves, 6), 1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[2] = Circle_2(Rat_point_2(5, 6), 1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[3] = Circle_2(Rat_point_2(6, _7_halves), 1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[4] = Circle_2(Rat_point_2(5, 2), 1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[5] = Circle_2(Rat_point_2(_7_halves, 1), 1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[6] = Circle_2(Rat_point_2(2, 2), 1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[7] = Circle_2(Rat_point_2(1, _7_halves), 1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[8] = Circle_2(Rat_point_2(2, 5), 1, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> k;</div><div class="line">  <span class="keywordflow">for</span> (k = 0; k &lt; 9; k++)</div><div class="line">    handles[k] = <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, C[k]);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The initial arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Remove the large circle C[0].</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Removing C[0] : "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgArrangement2Funcs.html#ga9a27533ff4ade0c60978812e517b89d9">remove_curve</a>(arr, handles[0])</div><div class="line">            &lt;&lt; <span class="stringliteral">" edges have been removed."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Locate the point q, which should be on an edge e.</span></div><div class="line">  Point_location pl(arr);</div><div class="line">  <span class="keyword">const</span> Point_2 q = Point_2(_7_halves, 7);</div><div class="line">  Point_location::result_type obj = pl.locate(q);</div><div class="line">  Arr_with_hist_2::Halfedge_const_handle  e;</div><div class="line"></div><div class="line">  CGAL_assertion_code(<span class="keywordtype">bool</span> success = ) <a class="code" href="namespaceCGAL.html">CGAL</a>::assign(e, obj);</div><div class="line">  CGAL_assertion(success);</div><div class="line"></div><div class="line">  <span class="comment">// Split the edge e to two edges e1 and e2;</span></div><div class="line">  Arr_with_hist_2::Halfedge_handle e1, e2;</div><div class="line"></div><div class="line">  e1 = arr.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga8a7629a2a0659ca059081eae8cedca3d">split_edge</a>(arr.non_const_handle(e), q);</div><div class="line">  e2 = e1-&gt;next();</div><div class="line"></div><div class="line">  <a class="code" href="namespacestd.html">std</a>::cout &lt;&lt; "After edge split: "</div><div class="line">            &lt;&lt; "V = " &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; ",  E = " &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; ",  F = " &lt;&lt; arr.number_of_faces() &lt;&lt; <a class="code" href="namespacestd.html">std</a>::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Merge back the two split edges.</span></div><div class="line">  arr.merge_edge(e1, e2);</div><div class="line"></div><div class="line">  <a class="code" href="namespacestd.html">std</a>::cout &lt;&lt; "After edge merge: "</div><div class="line">            &lt;&lt; "V = " &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; ",  E = " &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; ",  F = " &lt;&lt; arr.number_of_faces() &lt;&lt; <a class="code" href="namespacestd.html">std</a>::endl;</div><div class="line">  return 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="arr_secio"></a>
Input/Output Streams</h1>
<p>In some cases, one would like to save an arrangement object constructed by some application, so that later on it can be restored. In other cases one would like to create nice drawings that represent arrangements constructed by some application. These drawings can be hard printed or displayed on a computer screen.</p>
<h2><a class="anchor" id="arr_ssecio_stream"></a>
Input/Output Stream</h2>
<p>Consider an arrangement that represents a very complicated geographical map, and assume that there are various applications that need to answer point-location queries on this map. Naturally, you can store the set of curves that induces the arrangement, but this implies that you would need to construct the arrangement from scratch each time you need to reuse it. A more efficient solution is to write the arrangement to a file in a format that other applications can read.</p>
<p>This package provides an <em>inserter</em> (the <code>&lt;&lt;</code> operator) and an <em>extractor</em> (the <code>&gt;&gt;</code> operator) for the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class that inserts and an arrangement object into an output stream and extracts an arrangement object from an input stream respectively. The arrangement is written using a simple predefined ASCII format that encodes the arrangement topology, as well as all geometric entities associated with vertices and edges.</p>
<p>The ability to use the input/output operators, requires that the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> type and the <code>X_monotone_curve_2</code> type defined by the traits class both support the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators. The <code><a class="el" href="classCGAL_1_1Arr__conic__traits__2.html" title="The class Arr_conic_traits_2 is a model of the ArrangementTraits_2 concept and can be used to constru...">Arr_conic_traits_2</a></code> class (see Section <a class="el" href="index.html#arr_ssectr_conic">A Traits Class for Conic Arcs</a>), the <code><a class="el" href="classCGAL_1_1Arr__rational__function__traits__2.html" title="The traits class Arr_rational_function_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_rational_function_traits_2</a></code> class (see Section <a class="el" href="index.html#arr_ssectr_ratfunc">A Traits Class for Arcs of Rational Functions</a>), and the <code><a class="el" href="classCGAL_1_1Arr__linear__traits__2.html" title="The traits class Arr_linear_traits_2 is a model of the ArrangementTraits_2 concept, which enables the construction and maintenance of arrangements of linear objects. ">Arr_linear_traits_2</a></code> class (see Section <a class="el" href="index.html#arr_ssectr_segs">Traits Classes for Line Segments and Linear Objects</a>) currently do not provide these operators for the geometric types they define. Thus, only arrangements of line segments or of polylines can be written or read.</p>
<p>The following example constructs the arrangement depicted in <a class="el" href="index.html#fig__arr_figex_5">Figure 34.6</a> and writes it to an output file. It also demonstrates how to re-read the arrangement from a file:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2io_8cpp-example.html">Arrangement_on_surface_2/io.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the arrangement I/O operators.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Arr_iostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "point_location_utils.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>            Traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                 Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the arrangement.</span></div><div class="line">  Arrangement_2    arr;</div><div class="line"></div><div class="line">  construct_segments_arr (arr);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Writing an arrangement of size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Write the arrangement to a file.</span></div><div class="line">  std::ofstream    out_file (<span class="stringliteral">"arr_ex_io.dat"</span>);</div><div class="line"></div><div class="line">  out_file &lt;&lt; arr;</div><div class="line">  out_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Read the arrangement from the file.</span></div><div class="line">  Arrangement_2    arr2;</div><div class="line">  std::ifstream    in_file (<span class="stringliteral">"arr_ex_io.dat"</span>);</div><div class="line"></div><div class="line">  in_file &gt;&gt; arr2;</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read an arrangement of size:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr2.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr2.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr2.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (0);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecarr_io_aux_data"></a>
Arrangements with Auxiliary Data</h2>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>The inserter and extractor both ignore any auxiliary data stored with the arrangement features. Thus, they are ideal for arrangements instantiated using the <code><a class="el" href="classCGAL_1_1Arr__default__dcel.html" title="The default Dcel class used by the Arrangement_2 class-template is parameterized by a traits class...">Arr_default_dcel</a></code> class. However, as explained in Section <a class="el" href="index.html#arr_secex_dcel">Extending the DCEL</a>, one can easily extend the arrangement faces by using the <code><a class="el" href="classCGAL_1_1Arr__face__extended__dcel.html" title="The Arr_face_extended_dcel class-template extends the Dcel face-records, making it possible to store ...">Arr_face_extended_dcel</a></code> template, or extend all <span style="font-variant: small-caps;">Dcel</span> records by using the <code><a class="el" href="classCGAL_1_1Arr__extended__dcel.html" title="The Arr_extended_dcel class-template extends the topological-features of the Dcel namely the vertex...">Arr_extended_dcel</a></code> template. In such cases, it might be crucial that the auxiliary data fields are written to the file and read from there.</p>
<p>The arrangement package includes the free functions <code>write(arr, os, formatter)</code>, which writes the arrangement <code>arr</code> to an output stream <code>os</code>, and <code>read(arr, os, formatter)</code>, which reads the arrangement <code>arr</code> from an input stream <code>is</code>. Both operations are performed using a <code>formatter</code> object, which defines the I/O format. The package contains three formatter classes: </p><ul>
<li>
<code><a class="el" href="classCGAL_1_1Arr__text__formatter.html" title="Arr_text_formatter defines the format of an arrangement in an input or output stream (typically a fil...">Arr_text_formatter</a>&lt;Arrangement&gt;</code> defines a simple textual I/O format for the arrangement topology and geometry, disregarding any auxiliary data that may be associated with the arrangement features. This is the default formatter used by the arrangement inserter and the arrangement extractor, as defined above. </li>
<li>
<code><a class="el" href="classCGAL_1_1Arr__face__extended__text__formatter.html" title="Arr_face_extended_text_formatter defines the format of an arrangement in an input or output stream (t...">Arr_face_extended_text_formatter</a>&lt;Arrangement&gt;</code> operates on arrangements whose <span style="font-variant: small-caps;">Dcel</span> representation is based on the <code><a class="el" href="classCGAL_1_1Arr__face__extended__dcel.html" title="The Arr_face_extended_dcel class-template extends the Dcel face-records, making it possible to store ...">Arr_face_extended_dcel</a>&lt;Traits,FaceData&gt;</code> class (see Section <a class="el" href="index.html#arr_ssecex_dcel_face">Extending the DCEL Faces</a>). It supports reading and writing the auxiliary data objects stored with the arrangement faces provided that the <code>FaceData</code> class supports an inserter and an extractor. </li>
<li>
<code><a class="el" href="classCGAL_1_1Arr__extended__dcel__text__formatter.html" title="Arr_extended_dcel_text_formatter defines the format of an arrangement in an input or output stream (t...">Arr_extended_dcel_text_formatter</a>&lt;Arrangement&gt;</code> operates on arrangements whose <span style="font-variant: small-caps;">Dcel</span> representation is based on the <code><a class="el" href="classCGAL_1_1Arr__extended__dcel.html" title="The Arr_extended_dcel class-template extends the topological-features of the Dcel namely the vertex...">Arr_extended_dcel</a>&lt;Traits,VertexData,HalfedgeData,FaceData&gt;</code> class (see Section <a class="el" href="index.html#arr_ssecex_dcel_all">Extending All DCEL Records</a>). It supports reading and writing the auxiliary data objects stored with the arrangement vertices, edges and faces, provided that the <code>VertexData</code>, <code>HalfedgeData</code> and <code>FaceData</code> classed all have inserters and extractors. </li>
</ul>
<p>The following example constructs the same arrangement as the example <code>dcel_extension</code> does (see Section <a class="el" href="index.html#arr_ssecex_dcel_all">Extending All DCEL Records</a>), depicted in <a class="el" href="index.html#fig__arr_figex_20">Figure 34.25</a>, and writes it to an output file. It also demonstrates how to re-read the arrangement from a file:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2dcel_extension_io_8cpp-example.html">Arrangement_on_surface_2/dcel_extension_io.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the I/O operators for arrangements with extended DCEL records.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Arr_text_formatter.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Arr_iostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> Color {BLUE, RED, WHITE};</div><div class="line"></div><div class="line">std::ostream&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamOperators.html#ga525f8afc1fb75eb966517c447f1968ea">operator&lt;&lt; </a>(std::ostream&amp; os, <span class="keyword">const</span> Color&amp; color)</div><div class="line">{</div><div class="line">  <span class="keywordflow">switch</span> (color)</div><div class="line">  {</div><div class="line">  <span class="keywordflow">case</span> BLUE:  os &lt;&lt; <span class="stringliteral">"BLUE"</span>;  <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> RED:   os &lt;&lt; <span class="stringliteral">"RED"</span>;   <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> WHITE: os &lt;&lt; <span class="stringliteral">"WHITE"</span>; <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">default</span>: os &lt;&lt; <span class="stringliteral">"ERROR!"</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> (os);</div><div class="line">}</div><div class="line"></div><div class="line">std::istream&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamOperators.html#gae89c813a0404eae7e0901ed8f3c92915">operator&gt;&gt; </a>(std::istream&amp; is, Color&amp; color)</div><div class="line">{</div><div class="line">  std::string   str;</div><div class="line">  is &gt;&gt; str;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (str == <span class="stringliteral">"BLUE"</span>)</div><div class="line">    color = BLUE;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str == <span class="stringliteral">"RED"</span>)</div><div class="line">    color = RED;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str == <span class="stringliteral">"WHITE"</span>)</div><div class="line">    color = WHITE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (is);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>             Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                 Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                      Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__extended__dcel.html">CGAL::Arr_extended_dcel</a>&lt;Traits_2,</div><div class="line">                                Color, bool, <span class="keywordtype">int</span>&gt;         Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</a>               Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__extended__dcel__text__formatter.html">CGAL::Arr_extended_dcel_text_formatter&lt;Arrangement_2&gt;</a>  Formatter;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the arrangement containing two intersecting triangles.</span></div><div class="line">  Arrangement_2          arr;</div><div class="line"></div><div class="line">  Segment_2      s1 (Point_2(4, 1), Point_2(7, 6));</div><div class="line">  Segment_2      s2 (Point_2(1, 6), Point_2(7, 6));</div><div class="line">  Segment_2      s3 (Point_2(4, 1), Point_2(1, 6));</div><div class="line">  Segment_2      s4 (Point_2(1, 3), Point_2(7, 3));</div><div class="line">  Segment_2      s5 (Point_2(1, 3), Point_2(4, 8));</div><div class="line">  Segment_2      s6 (Point_2(4, 8), Point_2(7, 3));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s1);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s2);</div><div class="line">  <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, s3);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, s4);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, s5);</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, s6);</div><div class="line"></div><div class="line">  <span class="comment">// Go over all arrangement vertices and set their colors.</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#ac4a88fd2ca22b490454e4f425005e5c4">Arrangement_2::Vertex_iterator</a>            vit;</div><div class="line">  std::size_t                               degree;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit)</div><div class="line">  {</div><div class="line">    degree = vit-&gt;degree();</div><div class="line">    <span class="keywordflow">if</span> (degree == 0)</div><div class="line">      vit-&gt;set_data (BLUE);       <span class="comment">// Isolated vertex.</span></div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (degree &lt;= 2)</div><div class="line">      vit-&gt;set_data (RED);        <span class="comment">// Vertex represents an endpoint.</span></div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      vit-&gt;set_data (WHITE);      <span class="comment">// Vertex represents an intersection point.</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Go over all arrangement edges and set their flags.</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#a9b3a4b116e66f66bcd69215fa3f513f9">Arrangement_2::Edge_iterator</a>              eit;</div><div class="line">  <span class="keywordtype">bool</span>                                      flag;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (eit = arr.edges_begin(); eit != arr.edges_end(); ++eit)</div><div class="line">  {</div><div class="line">    <span class="comment">// Check if the halfedge has the same direction as its associated</span></div><div class="line">    <span class="comment">// segment. Note that its twin always has an opposite direction.</span></div><div class="line">    flag = (eit-&gt;source()-&gt;point() == eit-&gt;curve().source());</div><div class="line">    eit-&gt;set_data (flag);</div><div class="line">    eit-&gt;twin()-&gt;set_data (!flag);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Go over all arrangement faces and print their outer boundary and indices.</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#aa91e8147cf0a7cc30366af5b6f9a058e">Arrangement_2::Face_iterator</a>              fit;</div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#ab4a594c193ca09a672dbe2fcafa090e9">Arrangement_2::Ccb_halfedge_circulator</a>    curr;</div><div class="line">  <span class="keywordtype">int</span>                                       boundary_size;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit)</div><div class="line">  {</div><div class="line">    boundary_size = 0;</div><div class="line">    <span class="keywordflow">if</span> (! fit-&gt;is_unbounded())</div><div class="line">    {</div><div class="line">      curr = fit-&gt;outer_ccb();</div><div class="line">      <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        ++boundary_size;</div><div class="line">        ++curr;</div><div class="line">      } <span class="keywordflow">while</span> (curr != fit-&gt;outer_ccb());</div><div class="line">    }</div><div class="line">    fit-&gt;set_data (boundary_size);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Write the arrangement to a file.</span></div><div class="line">  std::ofstream    out_file (<span class="stringliteral">"arr_ex_dcel_io.dat"</span>);</div><div class="line">  Formatter        formatter;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Write.html#ga382f8dae407f5ddd50f33521781d84b9">write</a> (arr, out_file, formatter);</div><div class="line">  out_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Read the arrangement from the file.</span></div><div class="line">  Arrangement_2    arr2;</div><div class="line">  std::ifstream    in_file (<span class="stringliteral">"arr_ex_dcel_io.dat"</span>);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangement2Read.html#ga22c750c70c5384ef1561fbd6cd3bfaa8">read</a> (arr2, in_file, formatter);</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement vertices: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (vit = arr2.vertices_begin(); vit != arr2.vertices_end(); ++vit)</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">'('</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">") - "</span> &lt;&lt; vit-&gt;data() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (0);</div><div class="line">}</div></div><!-- fragment --><p>You may develop your own own formatter classes - models of the <code><a class="el" href="classArrangementInputFormatter.html" title="A model for the ArrangementInputFormatter concept supports a set of functions that enable reading an ...">ArrangementInputFormatter</a></code> and <code><a class="el" href="classArrangementOutputFormatter.html" title="A model for the ArrangementOutputFormatter concept supports a set of functions that enable writing an...">ArrangementOutputFormatter</a></code> concepts, as defined in the Reference Manual. Doing so, you can define other I/O formats, such as an XML-based format or a binary format.  </p></div> 
<h2><a class="anchor" id="arr_ssecarr_io_hist"></a>
Arrangements with Curve History</h2>
<p>Section <a class="el" href="index.html#arr_secarr_with_hist">Storing the Curve History</a> introduces the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt;Traits,Dcel&gt;</code> class, which saves the set of curves inducing an arrangement and maintains the relations between these curves and the edges they induce. Naturally, when reading or writing an arrangement-with-history instance we would like this information to be saved to the output stream or restored from the input stream alongside with the basic arrangement structure.</p>
<p>The arrangement package supplies an inserter and an extractor for the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt;Traits,Dcel&gt;</code> class. The arrangement is represented using a simple predefined ASCII format. An object of the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt;Traits,Dcel&gt;</code> type can be saved and restored, as long as the <code>Curve_2</code> type defined by the traits class - as well as the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> type and the <code>X_monotone_curve_2</code> types - support the <code>&lt;&lt;</code> and<code>&gt;&gt;</code> operators.</p>
<p>The following example constructs the same arrangement as example <code>curve_history</code> does (see Section <a class="el" href="index.html#arr_ssecarr_hist_ex">Examples</a>), depicted in <a class="el" href="index.html#fig__arr_figex_24">Figure 34.27</a>, and writes it to an output file. It also demonstrates how to re-read the arrangement-with-history from a file:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2io_curve_history_8cpp-example.html">Arrangement_on_surface_2/io_curve_history.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the arrangement-with-history I/O operators.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_with_history_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Arr_with_history_iostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>            Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                             Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                             Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__with__history__2.html">CGAL::Arrangement_with_history_2&lt;Traits_2&gt;</a>    Arr_with_hist_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  Arr_with_hist_2   arr;</div><div class="line"></div><div class="line">  <span class="comment">// Insert six additional segments aggregately:</span></div><div class="line">  Segment_2         segs[6];</div><div class="line">  segs[0] = Segment_2 (Point_2 (2, 6), Point_2 (7, 1));</div><div class="line">  segs[1] = Segment_2 (Point_2 (3, 2), Point_2 (3, 5));</div><div class="line">  segs[2] = Segment_2 (Point_2 (2, 3), Point_2 (5, 3));</div><div class="line">  segs[3] = Segment_2 (Point_2 (2, 6), Point_2 (7, 1));</div><div class="line">  segs[4] = Segment_2 (Point_2 (0, 0), Point_2 (2, 6));</div><div class="line">  segs[5] = Segment_2 (Point_2 (3, 4), Point_2 (6, 4));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, segs, segs + 6);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Writing an arrangement of "</span></div><div class="line">            &lt;&lt; arr.number_of_curves() &lt;&lt; <span class="stringliteral">" input segments:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Write the arrangement to a file.</span></div><div class="line">  std::ofstream     out_file (<span class="stringliteral">"arr_ex_io_hist.dat"</span>);</div><div class="line"></div><div class="line">  out_file &lt;&lt; arr;</div><div class="line">  out_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Read the arrangement from the file.</span></div><div class="line">  Arr_with_hist_2   arr2;</div><div class="line">  std::ifstream     in_file (<span class="stringliteral">"arr_ex_io_hist.dat"</span>);</div><div class="line"></div><div class="line">  in_file &gt;&gt; arr2;</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read an arrangement of "</span></div><div class="line">            &lt;&lt; arr2.number_of_curves() &lt;&lt; <span class="stringliteral">" input segments:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"   V = "</span> &lt;&lt; arr2.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr2.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr2.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (0);</div><div class="line">}</div></div><!-- fragment --><p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>The arrangement package also includes the free functions <code>write(arr, os, formatter)</code> and <code>read(arr, os, formatter)</code> that operate on a given arrangement-with-history instance <code>arr</code>. Both functions are parameterized by a <code>formatter</code> object, which define the I/O format. The package contains a template called, <code>Arr_with_hist_text_formatter&lt;ArranagmentFormatter&gt;</code>, which extends an arrangement formatter class (see Section <a class="el" href="index.html#arr_ssecarr_io_aux_data">Arrangements with Auxiliary Data</a>) and defines a simple textual input/output format.  </p></div> 
<h1><a class="anchor" id="arr_secbgl"></a>
Adapting to Boost Graphs</h1>
<p><span class="textsc">Boost</span><span class="footnote">See also <span class="textsc">Boost</span>'s homepage at: <code>www.boost.org</code>.</span> is a collection of portable <span style="font-variant: small-caps;">C++</span> libraries that extend the Standard Template Library (<span class="textsc">Stl</span>). The <span class="textsc">Boost</span> Graph Library (<span class="textsc">bgl</span>), which one of the libraries in the collection, offers an extensive set of generic graph algorithms parameterized through templates. As our arrangements are embedded as planar graphs, it is only natural to extend the underlying data structure with the interface that the <span class="textsc">bgl</span> expects, and gain the ability to perform the operations that the <span class="textsc">bgl</span> supports, such as shortest-path computation. This section describes how apply the graph algorithms implemented in the <span class="textsc">bgl</span> to <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instances.</p>
<p>An instance of <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> is adapted to a <span class="textsc">Boost</span> graph through the provision of a set of free functions that operate on the arrangement features and conform with the relevant BGL concepts. Besides the straightforward adaptation, which associates a vertex with each <span style="font-variant: small-caps;">Dcel</span> vertex and an edge with each <span style="font-variant: small-caps;">Dcel</span> halfedge, the package also offer a <em>dual</em> adaptor, which associates a graph vertex with each <span style="font-variant: small-caps;">Dcel</span> face, such that two vertices are connected, iff there is a <span style="font-variant: small-caps;">Dcel</span> halfedge that connects the two corresponding faces.</p>
<h2><a class="anchor" id="arr_ssecbgl_primal"></a>
The Primal Arrangement Representation</h2>
<p>Arrangement instances are adapted to <span class="textsc">Boost</span> graphs by specializing the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLTraits.html#BGLArgtGT"><code>boost:graph_traits</code> </a> template for <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instances. The graph-traits states the graph concepts that the arrangement class models (see below) and defines the types required by these concepts.</p>
<p>In this specialization the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> vertices correspond to the graph vertices, where two vertices are adjacent if there is at least one halfedge connecting them. More precisely, <code><a class="el" href="classCGAL_1_1Arrangement__2.html#a7dac3eed2224beadf3658495bc671c49" title="a handle for an arrangement vertex. ">Arrangement_2::Vertex_handle</a></code> is the graph-vertex type, while <code><a class="el" href="classCGAL_1_1Arrangement__2.html#acdb9c49c90f9354f20c56efac599a7fe" title="a handle for a halfedge. ">Arrangement_2::Halfedge_handle</a></code> is the graph-edge type. As halfedges are directed, we consider the graph to be directed as well. Moreover, as several interior-disjoint \( x\)-monotone curves (say circular arcs) may share two common endpoints, inducing an arrangement with two vertices that are connected with several edges, we allow parallel edges in our <span class="textsc">Boost</span> graph.</p>
<p>Given an <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instance, we can efficiently traverse its vertices and halfedges. Thus, the arrangement graph is a model of the concepts <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classVertexListGraph.html">VertexListGraph</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> introduced by the <span class="textsc">bgl</span>. At the same time, we use an iterator adapter of the circulator over the halfedges incident to a vertex (<code>Halfedge_around_vertex_circulator</code> - see Section <a class="el" href="index.html#arr_sssectr_vertex">Traversal Methods for an Arrangement Vertex</a>), so it is possible to go over the ingoing and outgoing edges of a vertex in linear time. Thus, our arrangement graph is a model of the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (this concept refines <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>, which requires only the traversal of outgoing edges).</p>
<p>It is important to notice that the vertex descriptors we use are <code>Vertex_handle</code> objects and <em>not</em> vertex indices. However, in order to gain more efficiency in most <span class="textsc">bgl</span> algorithm, it is better to have them indexed \( 0, 1, \ldots, (n-1)\), where \( n\) is the number of vertices. We therefore introduce the <code><a class="el" href="classCGAL_1_1Arr__vertex__index__map.html" title="Arr_vertex_index_map maintains a mapping of vertex handles of an attached arrangement object to indic...">Arr_vertex_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains a mapping of vertex handles to indices, as required by the <span class="textsc">bgl</span>. An instance of this class must be attached to a valid arrangement vertex when it is created. It uses the notification mechanism (see Section <a class="el" href="index.html#arr_secnotif">The Notification Mechanism</a>) to automatically maintain the mapping of vertices to indices, even when new vertices are inserted into the arrangement or existing vertices are removed.</p>
<p>In most algorithm provided by the <span class="textsc">bgl</span>, the output is given by <em>property maps</em>, such that each map entry corresponds to a vertex. For example, when we compute the shortest paths from a given source vertex \( s\) to all other vertices we can obtain a map of distances and a map of predecessors - namely for each \( v\) vertex we have its distance from \( s\) and a descriptor of the vertex that precedes \( v\) in the shortest path from \( s\).</p>
<p>If the vertex descriptors are simply indices, boost supplies tools to easily represent property maps using vectors. <code><a class="el" href="classCGAL_1_1Arr__vertex__index__map.html" title="Arr_vertex_index_map maintains a mapping of vertex handles of an attached arrangement object to indic...">Arr_vertex_index_map</a>&lt;Arrangement&gt;</code> class allows create such indices, and together with <code>boost::vector_property_map&lt;Type, IndexMap&gt;</code> allows for an efficient mapping of <code>Vertex_handle</code> objects to properties of type <code>Type</code>. Note however that unlike the <code><a class="el" href="classCGAL_1_1Arr__vertex__index__map.html" title="Arr_vertex_index_map maintains a mapping of vertex handles of an attached arrangement object to indic...">Arr_vertex_index_map</a></code> class, the vertex property-map class is not kept synchronized with the number of vertices in the arrangement, so it should not be reused in calls to <span class="textsc">bgl</span> functions in case the arrangement is modified in between these calls.</p>
<p><a class="anchor" id="fig__arr_figex_bgl"></a></p><div class="image">
<img src="ex_bgl.png" alt="ex_bgl.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__arr_figex_bgl">Figure 34.29</a> An arrangement of 7 line segments, as constructed by <code>bgl_primal_adapter.cpp</code> and <code>bgl_dual_adapter.cpp</code>. The breadth-first visit times for the arrangement faces, starting from the unbounded face \( f_0\), are shown is brackets.  </div>  <br />

<p>In the following example we construct an arrangement of 7 line segments, as shown in <a class="el" href="index.html#fig__arr_figex_bgl">Figure 34.29</a>, then use Dijkstra's shortest-paths algorithm from the <span class="textsc">bgl</span> to compute the graph distance of all vertices from the leftmost vertex in the arrangement \( v_0\). Note the usage of the <code>boost::vector_property_map&lt;Type, IndexMap&gt;</code> and the <code>Arr_vertex_property_map</code> classes. The latter one, instantiated by the type <code>double</code> is used to map vertices to their distances from \( v_0\).</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2bgl_primal_adapter_8cpp-example.html">Arrangement_on_surface_2/bgl_primal_adapter.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_vertex_index_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>           Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>              Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                               Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                    Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                   Arrangement_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__vertex__index__map.html">CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt;</a>       Arr_vertex_index_map;</div><div class="line"></div><div class="line"><span class="comment">// A functor used to compute the length of an edge.</span></div><div class="line"><span class="keyword">class </span>Edge_length_func</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <span class="comment">// Boost property type definitions:</span></div><div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag        category;</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span>                                  value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type                              reference;</div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#acdb9c49c90f9354f20c56efac599a7fe">Arrangement_2::Halfedge_handle</a>          key_type;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> operator()(<a class="code" href="classCGAL_1_1Arrangement__2.html#acdb9c49c90f9354f20c56efac599a7fe">Arrangement_2::Halfedge_handle</a> e)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     x1 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;source()-&gt;point().x());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     y1 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;source()-&gt;point().y());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     x2 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;target()-&gt;point().x());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     y2 = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;target()-&gt;point().y());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     diff_x = x2 - x1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     diff_y = y2 - y1;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(diff_x*diff_x + diff_y*diff_y);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> <span class="keyword">get</span>(Edge_length_func edge_length, <a class="code" href="classCGAL_1_1Arrangement__2.html#acdb9c49c90f9354f20c56efac599a7fe">Arrangement_2::Halfedge_handle</a> e)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> edge_length(e);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Arrangement_2   arr;</div><div class="line"></div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  <span class="comment">// We keep a handle for the vertex v_0 that corresponds to the point (1,1).</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#acdb9c49c90f9354f20c56efac599a7fe">Arrangement_2::Halfedge_handle</a>  e =</div><div class="line">    <a class="code" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, Segment_2 (Point_2 (1, 1),</div><div class="line">                                                   Point_2 (7, 1)));</div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#a7dac3eed2224beadf3658495bc671c49">Arrangement_2::Vertex_handle</a>    v0 = e-&gt;source();</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Segment_2 (Point_2 (1, 1), Point_2 (3, 7)));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Segment_2 (Point_2 (1, 4), Point_2 (7, 1)));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Segment_2 (Point_2 (2, 2), Point_2 (9, 3)));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Segment_2 (Point_2 (2, 2), Point_2 (4, 4)));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Segment_2 (Point_2 (7, 1), Point_2 (9, 3)));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a> (arr, Segment_2 (Point_2 (3, 7), Point_2 (9, 3)));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement vertices to indices.</span></div><div class="line">  Arr_vertex_index_map index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform Dijkstra's algorithm from the vertex v0.</span></div><div class="line">  Edge_length_func edge_length;</div><div class="line"></div><div class="line">  boost::vector_property_map&lt;double, Arr_vertex_index_map&gt; dist_map(static_cast&lt;unsigned int&gt;(arr.number_of_vertices()), index_map);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  boost::dijkstra_shortest_paths(arr, v0,</div><div class="line">                                 boost::vertex_index_map(index_map).</div><div class="line">                                 weight_map(edge_length).</div><div class="line">                                 distance_map(dist_map));</div><div class="line"></div><div class="line">  <span class="comment">// Print the results:</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arrangement__2.html#ac4a88fd2ca22b490454e4f425005e5c4">Arrangement_2::Vertex_iterator</a>      vit;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The distances of the arrangement vertices from ("</span></div><div class="line">            &lt;&lt; v0-&gt;point() &lt;&lt; <span class="stringliteral">") :"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">") at distance "</span></div><div class="line">              &lt;&lt; dist_map[vit] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecbgl_dual"></a>
The Dual Arrangement Representation</h2>
<p>It is possible to give a dual graph representation for an arrangement instance, such that each arrangement face corresponds to a graph vertex and two vertices are adjacent iff the corresponding faces share a common edge on their boundaries. This is done by specializing the <code>boost:graph_traits</code> template for <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Dual.html">Dual</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> instances, where <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Dual.html">Dual</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> is a template specialization that gives a dual interpretation to an arrangement instance.</p>
<p>In dual representation, <code><a class="el" href="classCGAL_1_1Arrangement__2.html#ad64170c3b8b8c4af16a4fb742bf56d48" title="a handle for an arrangement face. ">Arrangement_2::Face_handle</a></code> is the graph-vertex type, while <code><a class="el" href="classCGAL_1_1Arrangement__2.html#acdb9c49c90f9354f20c56efac599a7fe" title="a handle for a halfedge. ">Arrangement_2::Halfedge_handle</a></code> is the graph-edge type. We treat the graph edges as directed, such that a halfedge <code>e</code> is directed from \( f_1\), which is its incident face, to \( f_2\), which is the incident face of its twin halfedge. As two arrangement faces may share more than a single edge on their boundary, we allow parallel edges in our <span class="textsc">Boost</span> graph. As is the case in the primal graph, the dual arrangement graph is also a model of the concepts <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classVertexListGraph.html">VertexListGraph</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (thus also of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>).</p>
<p>Since we use <code>Face_handle</code> objects as the vertex descriptors, we define the <code><a class="el" href="classCGAL_1_1Arr__face__index__map.html" title="Arr_face_index_map maintains a mapping of face handles of an attached arrangement object to indices (...">Arr_face_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains an efficient mapping of face handles to indices. Like vertices, <code>boost::vector_property_map&lt;Type, IndexMap&gt;</code> can be used for associating arbitrary data with the arrangement faces.</p>
<p>In the following example we construct the same arrangement as in example <code>bgl_primal_adapter.cpp</code> (see <a class="el" href="index.html#fig__arr_figex_bgl">Figure 34.29</a>), and perform breadth-first search on the graph faces, starting from the unbounded face. We extend the <span style="font-variant: small-caps;">Dcel</span> faces with an unsigned integer, marking the discover time of the face using <code>boost</code> visitors and a property-map class that directly accesses the extended data of the faces:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2bgl_dual_adapter_8cpp-example.html">Arrangement_on_surface_2/bgl_dual_adapter.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting the dual of an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_dual_arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_face_index_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;climits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/breadth_first_search.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/visitors.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="comment">// A property map that reads/writes the information to/from the extended</span></div><div class="line"><span class="comment">// face.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement, <span class="keyword">class</span> Type&gt; <span class="keyword">class </span>Extended_face_property_map {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Face_handle       Face_handle;</div><div class="line"></div><div class="line">  <span class="comment">// Boost property type definitions.</span></div><div class="line">  <span class="keyword">typedef</span> boost::read_write_property_map_tag      category;</div><div class="line">  <span class="keyword">typedef</span> Type                                    value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type&amp;                             reference;</div><div class="line">  <span class="keyword">typedef</span> Face_handle                             key_type;</div><div class="line"></div><div class="line">  <span class="comment">// The get function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> Extended_face_property_map&amp; <span class="comment">/* map */</span>,</div><div class="line">                       key_type key)</div><div class="line">  { <span class="keywordflow">return</span> key-&gt;data(); }</div><div class="line"></div><div class="line">  <span class="comment">// The put function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> <span class="keywordtype">void</span> put(Extended_face_property_map <span class="comment">/* map */</span>,</div><div class="line">                  key_type key, value_type val)</div><div class="line">  { key-&gt;set_data(val); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;CGAL::Exact_rational&gt;</a>                Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                   Traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits_2, unsigned int&gt;</a> Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</a>                  Ex_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Dual.html">CGAL::Dual&lt;Ex_arrangement&gt;</a>                           Dual_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__index__map.html">CGAL::Arr_face_index_map&lt;Ex_arrangement&gt;</a>             Face_index_map;</div><div class="line"><span class="keyword">typedef</span> Extended_face_property_map&lt;Ex_arrangement,unsigned int&gt;</div><div class="line">                                                             Face_property_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                      Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a>                                    Segment_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  Point_2 p1(1, 1), p2(1, 4), p3(2, 2), p4(3, 7), p5(4, 4), p6(7, 1), p7(9, 3);</div><div class="line">  Ex_arrangement  arr;</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment_2(p1, p6));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment_2(p1, p4));  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment_2(p2, p6));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment_2(p3, p7));  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment_2(p3, p5));</div><div class="line">  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment_2(p6, p7));  <a class="code" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment_2(p4, p7));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement faces to indices.</span></div><div class="line">  Face_index_map  index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform breadth-first search from the unbounded face, using the event</span></div><div class="line">  <span class="comment">// visitor to associate each arrangement face with its discover time.</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    time = 0;</div><div class="line">  boost::breadth_first_search(Dual_arrangement(arr), arr.unbounded_face(),</div><div class="line">                              boost::vertex_index_map(index_map).visitor</div><div class="line">                              (boost::make_bfs_visitor</div><div class="line">                               (stamp_times(Face_property_map(), time,</div><div class="line">                                            boost::on_discover_vertex()))));</div><div class="line"></div><div class="line">  <span class="comment">// Print the discover time of each arrangement face.</span></div><div class="line">  Ex_arrangement::Face_iterator  fit;</div><div class="line">  <span class="keywordflow">for</span> (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Discover time "</span> &lt;&lt; fit-&gt;data() &lt;&lt; <span class="stringliteral">" for "</span>;</div><div class="line">    <span class="keywordflow">if</span> (fit != arr.unbounded_face()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"face "</span>;</div><div class="line">      print_ccb&lt;Ex_arrangement&gt;(fit-&gt;outer_ccb());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">"the unbounded face."</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="arr_sectips"></a>
How To Speed Up Your Computation</h1>
<p>Before the specific tips, we remind you that compiling programs with debug flags disabled and with optimization flags enabled significantly reduces the running time.</p>
<ol>
<li>
<p class="startli">When the curves to be inserted into an arrangement are \( x\)-monotone and pairwise disjoint in their interior to start with, then it is more efficient (in running time) and less demanding (in traits-class functionality) to use the non-intersection insertion-functions instead of the general ones; e.g., <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When the curves to be inserted into an arrangement are segments that are pairwise disjoint in their interior, it is more efficient to use the traits class <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html" title="The traits class Arr_non_caching_segment_traits_2 is a model of the ArrangementTraits_2 concept that ...">Arr_non_caching_segment_traits_2</a></code> rather then the default one (<code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code>).</p>
<p>If the segments may intersect each other, the default traits class <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> can be safely used with the somehow limited number type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a>&lt;MP_float&gt;</code>.</p>
<p>On rare occasions the traits class <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html" title="The traits class Arr_non_caching_segment_traits_2 is a model of the ArrangementTraits_2 concept that ...">Arr_non_caching_segment_traits_2</a></code> exhibits slightly better performance than the default one (<code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> even when the segments intersect each other, due to the small overhead of the latter (optimized) traits class. (For example, when the so called <span class="textsc">Leda</span> rational kernel is used).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Prior knowledge of the combinatorial structure of the arrangement can be used to accelerate operations that insert \( x\)-monotone curves, whose interior is disjoint from existing edges and vertices of the arrangement. The specialized insertion functions, i.e., <code>insert_in_face_interior()</code>, <code>insert_from_left_vertex()</code>, <code>insert_from_right_vertex()</code>, and <code>insert_at_vertices()</code> can be used according to the available information. These functions hardly involve any geometric operations, if at all. They accept topologically related parameters, and use them to operate directly on the <span style="font-variant: small-caps;">Dcel</span> records, thus saving algebraic operations, which are especially expensive when high-degree curves are involved.</p>
<p>A polygon, represented by a list of segments along its boundary, can be inserted into an empty arrangement as follows. First, one segment is inserted using <code>insert_in_face_interior()</code> into the unbounded face. Then, a segment with a common end point is inserted using either <code>insert_from_left_vertex()</code> or <code>insert_from_right_vertex()</code>, and so on with the rest of the segments except for the last, which is inserted using <code>insert_at_vertices()</code>, as both endpoints of which are the mapping of known vertices.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The main trade-off among point-location strategies, is between time and storage. Using the naive or walk strategies, for example, takes more query time but does not require preprocessing or maintenance of auxiliary structures and saves storage space.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If point-location queries are not performed frequently, but other modifying functions, such as removing, splitting, or merging edges are, then using a point-location strategy that does not require the maintenance of auxiliary structures, such as the naive or walk strategies, is preferable.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">There is a trade-off between two modes of the trapezoidal RIC strategy that enables the user to choose whether preprocessing should be performed or not. If preprocessing is not used, the creation of the structure is faster. However, for some input sequences the structure might be unbalanced and therefore queries and updates might take longer, especially, if many removal and split operations are performed.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When the curves to be inserted into an arrangement are available in advance (as opposed to supplied on-line), it is advised to use the more efficient aggregate (sweep-based) insertion over the incremental insertion; e.g., <code><a class="el" href="group__PkgArrangement2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="The function insert inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. ">insert()</a></code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The various traits classes should be instantiated with an exact number type to ensure robustness, when the input of the operations to be carried out might be degenerate, although inexact number types could be used at the user's own risk.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Maintaining short bit-lengths of coordinate representations may drastically decrease the time consumption of arithmetic operations on the coordinates. This can be achieved by caching certain information or normalization (of rational numbers). However, both solutions should be used cautiously, as the former may lead to an undue space consumption, and indiscriminate normalization may considerably slow down the overall process.</p>
<p class="endli"></p>
</li>
<li>
Geometric functions (e.g., traits methods) dominate the time consumption of most operations. Thus, calls to such function should be avoided or at least their number should be decreased, perhaps at the expense of increased combinatorial-function calls or increased space consumption. For example, repetition of geometric-function calls could be avoided by storing the results obtained by the first call, and reusing them when needed. </li>
</ol>
<h1><a class="anchor" id="Arrangement_on_surface_2Design"></a>
Design and Implementation History</h1>
<p>The code of this package is the result of a long development process. Initially (and until version 3.1), the code was spread among several components, namely, <code>Topological_map</code>, <code>Planar_map_2</code>, <code>Planar_map_with_intersections_2</code> and <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code>, that were developed by Ester Ezra, Eyal Flato, Efi Fogel, Dan Halperin, Iddo Hanniel, Idit Haran, Shai Hirsch, Eugene Lipovetsky, Oren Nechushtan, Sigal Raab, Ron Wein, Baruch Zukerman, and Tali Zvi.</p>
<p>In version 3.2, as part of the ACS project, the packages have gone through a major re-design, resulting in an improved and unified <em>2D Arrangements</em> package. The code of the new package was restructured and developed by Efi Fogel, Idit Haran, Ron Wein, and Baruch Zukerman. This version included for the first time a new geometry-traits class that handles circular and linear curves, and is based on the circular kernel. The circular kernel was developed by Monique Teillaud, Sylvain Pion, and Julien Hazebrouck.</p>
<p>Version 3.3 features arrangements of unbounded curves for the first time. The design and development of this feature required yet another restructuring of the entire package. All this was done by Eric Berberich, Efi Fogel, Dan Halperin, Ophir Setter, and Ron Wein. Michael Hemmer helped tuning up parts of the geometry-traits concept related to unbounded curves.</p>
<p>Version 3.7 introduced a geometry-traits class that handles planar algebraic curves of arbitrary degree. It was developed by Eric Berberich and Michael Kerber.</p>
<p>Version 3.9 introduced a new geometry-traits class that handles rational arcs. It was developed by Oren Salzman and Michael Hemmer. It replaced an old traits, which handled the same family of curves, developed by Ron Wein.</p>
<p>Version 4.1 introduces a revised implementation of the point location class via a randomized incremental construction of the trapezoidal map. The old class was implemented by Oren Nechushtan, while the revamp was done by Michal Kleinbort and Michael Hemmer. The new class adds support for unbounded curves and can now guarantee logarithmic query time in all cases. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:48 for CGAL 4.13 - 2D Arrangements by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
