<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Arrangement_on_surface_2/group__PkgArrangement2Funcs.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Arrangements: Free Functions</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Arrangements
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__PkgArrangement2Funcs.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Free Functions<div class="ingroups"><a class="el" href="group__PkgArrangement2.html">2D Arrangement Reference</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups" id="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__PkgArrangement2Insert"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Insert.html">CGAL::insert()</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members" id="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga339cdba93f54001be303595689002396"><td class="memTemplParams" colspan="2">template&lt;class GeomTraitsA , class GeomTraitsB , class GeomTraitsRes , class TopTraitsA , class TopTraitsB , class TopTraitsRes , class OverlayTraits &gt; </td></tr>
<tr class="memitem:ga339cdba93f54001be303595689002396"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#ga339cdba93f54001be303595689002396">CGAL::overlay</a> (const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsA, TopTraitsA &gt; &amp;arr1, const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsB, TopTraitsB &gt; &amp;arr2, <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsRes, TopTraitsRes &gt; &amp;arr_res, <a class="el" href="classOverlayTraits.html">OverlayTraits</a> &amp;ovl_tr)</td></tr>
<tr class="memdesc:ga339cdba93f54001be303595689002396"><td class="mdescLeft"> </td><td class="mdescRight">Computes the overlay of two arrangements <code>arr1</code> and <code>arr2</code>, and sets the output arrangement <code>res</code> to represent the overlaid arrangement.  <a href="group__PkgArrangement2Funcs.html#ga339cdba93f54001be303595689002396">More...</a><br /></td></tr>
<tr class="separator:ga339cdba93f54001be303595689002396"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaddb9e44b14b27e4cf0c7bb26b27d8518"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel1 , typename Dcel2 , typename ResDcel , typename OverlayTraits &gt; </td></tr>
<tr class="memitem:gaddb9e44b14b27e4cf0c7bb26b27d8518"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#gaddb9e44b14b27e4cf0c7bb26b27d8518">CGAL::overlay</a> (const <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel1 &gt; &amp;arr1, const <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel2 &gt; &amp;arr2, <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, ResDcel &gt; &amp;res, <a class="el" href="classOverlayTraits.html">OverlayTraits</a> &amp;ovl_tr)</td></tr>
<tr class="memdesc:gaddb9e44b14b27e4cf0c7bb26b27d8518"><td class="mdescLeft"> </td><td class="mdescRight">Computes the overlay of two arrangements with history <code>arr1</code> and <code>arr2</code>, and sets the output arrangement with history <code>res</code> to represent the overlaid arrangement.  <a href="group__PkgArrangement2Funcs.html#gaddb9e44b14b27e4cf0c7bb26b27d8518">More...</a><br /></td></tr>
<tr class="separator:gaddb9e44b14b27e4cf0c7bb26b27d8518"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae20b2917f6de15db9bf025f83abf8e89"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gae20b2917f6de15db9bf025f83abf8e89"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#gae20b2917f6de15db9bf025f83abf8e89">CGAL::decompose</a> (const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> oi)</td></tr>
<tr class="memdesc:gae20b2917f6de15db9bf025f83abf8e89"><td class="mdescLeft"> </td><td class="mdescRight">Produces the symbolic vertical decomposition of a given arrangement, performing a batched vertical ray-shooting query from all arrangement vertices, such that every vertex is associated with a pair of objects, one corresponds to the arrangement feature that lies below it, and the other corresponds to the feature that lies above it.  <a href="group__PkgArrangement2Funcs.html#gae20b2917f6de15db9bf025f83abf8e89">More...</a><br /></td></tr>
<tr class="separator:gae20b2917f6de15db9bf025f83abf8e89"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab3d781b13fdf51ca9579ad13c2a32620"><td class="memTemplParams" colspan="2">template&lt;class GeomTraits , class TopTraits , class Curve , class PointLocation &gt; </td></tr>
<tr class="memitem:gab3d781b13fdf51ca9579ad13c2a32620"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#gab3d781b13fdf51ca9579ad13c2a32620">CGAL::do_intersect</a> (Arrangement_on_surface_2&lt; GeomTraits, TopTraits &gt; &amp;arr, const Curve &amp;c, const PointLocation &amp;pl)</td></tr>
<tr class="memdesc:gab3d781b13fdf51ca9579ad13c2a32620"><td class="mdescLeft"> </td><td class="mdescRight">Checks if a given curve or \( x\)-monotone curve intersects an existing arrangement's edges or vertices.  <a href="group__PkgArrangement2Funcs.html#gab3d781b13fdf51ca9579ad13c2a32620">More...</a><br /></td></tr>
<tr class="separator:gab3d781b13fdf51ca9579ad13c2a32620"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad453feb3ff2f60a9741bf9d2917bf225"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel , typename PointLocation &gt; </td></tr>
<tr class="memitem:gad453feb3ff2f60a9741bf9d2917bf225"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Halfedge_handle </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">CGAL::insert_non_intersecting_curve</a> (<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::X_monotone_curve_2 &amp;xc, const PointLocation &amp;pl=walk_pl)</td></tr>
<tr class="memdesc:gad453feb3ff2f60a9741bf9d2917bf225"><td class="mdescLeft"> </td><td class="mdescRight">Inserts a given \( x\)-monotone curve into a given arrangement, where the interior of the given curve is disjoint from all existing arrangement vertices and edges.  <a href="group__PkgArrangement2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">More...</a><br /></td></tr>
<tr class="separator:gad453feb3ff2f60a9741bf9d2917bf225"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad4aa37a4e938747028690579fb703d67"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel , InputIterator &gt; </td></tr>
<tr class="memitem:gad4aa37a4e938747028690579fb703d67"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#gad4aa37a4e938747028690579fb703d67">CGAL::insert_non_intersecting_curves</a> (<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classInputIterator.html">InputIterator</a> last)</td></tr>
<tr class="memdesc:gad4aa37a4e938747028690579fb703d67"><td class="mdescLeft"> </td><td class="mdescRight">Inserts a set of \( x\)-monotone curves in a given range into a given arrangement.  <a href="group__PkgArrangement2Funcs.html#gad4aa37a4e938747028690579fb703d67">More...</a><br /></td></tr>
<tr class="separator:gad4aa37a4e938747028690579fb703d67"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga13c103c1cea5249ca37ce7e0be4d97e4"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel , typename PointLocation &gt; </td></tr>
<tr class="memitem:ga13c103c1cea5249ca37ce7e0be4d97e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Vertex_handle </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#ga13c103c1cea5249ca37ce7e0be4d97e4">CGAL::insert_point</a> (<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::Point_2 &amp;p, const PointLocation &amp;pl=walk_pl)</td></tr>
<tr class="memdesc:ga13c103c1cea5249ca37ce7e0be4d97e4"><td class="mdescLeft"> </td><td class="mdescRight">Inserts a given point into a given arrangement.  <a href="group__PkgArrangement2Funcs.html#ga13c103c1cea5249ca37ce7e0be4d97e4">More...</a><br /></td></tr>
<tr class="separator:ga13c103c1cea5249ca37ce7e0be4d97e4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabcb9bc6c5859edf3fbc1390e60e32a17"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel &gt; </td></tr>
<tr class="memitem:gabcb9bc6c5859edf3fbc1390e60e32a17"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#gabcb9bc6c5859edf3fbc1390e60e32a17">CGAL::is_valid</a> (const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr)</td></tr>
<tr class="memdesc:gabcb9bc6c5859edf3fbc1390e60e32a17"><td class="mdescLeft"> </td><td class="mdescRight">Checks the validity of a given arrangement.  <a href="group__PkgArrangement2Funcs.html#gabcb9bc6c5859edf3fbc1390e60e32a17">More...</a><br /></td></tr>
<tr class="separator:gabcb9bc6c5859edf3fbc1390e60e32a17"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga324fdf8354e7812fe0e1c0e5ac14196c"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel &gt; </td></tr>
<tr class="memitem:ga324fdf8354e7812fe0e1c0e5ac14196c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Face_handle </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#ga324fdf8354e7812fe0e1c0e5ac14196c">CGAL::remove_edge</a> (<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr, typename <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Halfedge_handle e)</td></tr>
<tr class="memdesc:ga324fdf8354e7812fe0e1c0e5ac14196c"><td class="mdescLeft"> </td><td class="mdescRight">Removes an edge given by one of the twin halfedges that forms it, from a given arrangement.  <a href="group__PkgArrangement2Funcs.html#ga324fdf8354e7812fe0e1c0e5ac14196c">More...</a><br /></td></tr>
<tr class="separator:ga324fdf8354e7812fe0e1c0e5ac14196c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacbb4f22a59c77fb06a9d544cbbb04778"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel &gt; </td></tr>
<tr class="memitem:gacbb4f22a59c77fb06a9d544cbbb04778"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778">CGAL::remove_vertex</a> (<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr, typename <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Vertex_handle v)</td></tr>
<tr class="memdesc:gacbb4f22a59c77fb06a9d544cbbb04778"><td class="mdescLeft"> </td><td class="mdescRight">Attempts to removed a given vertex from a given arrangement.  <a href="group__PkgArrangement2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778">More...</a><br /></td></tr>
<tr class="separator:gacbb4f22a59c77fb06a9d544cbbb04778"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga49aa156968945f5533a2b5d9897ca659"><td class="memTemplParams" colspan="2">template&lt;class GeomTraits , class TopTraits , class OutputIterator , class PointLocation &gt; </td></tr>
<tr class="memitem:ga49aa156968945f5533a2b5d9897ca659"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#ga49aa156968945f5533a2b5d9897ca659">CGAL::zone</a> (Arrangement_on_surface_2&lt; GeomTraits, TopTraits &gt; &amp;arr, const typename GeomTraits::X_monotone_curve_2 &amp;c, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> oi, const PointLocation &amp;pl)</td></tr>
<tr class="memdesc:ga49aa156968945f5533a2b5d9897ca659"><td class="mdescLeft"> </td><td class="mdescRight">Compute the zone of the given \( x\)-monotone curve in the existing arrangement.  <a href="group__PkgArrangement2Funcs.html#ga49aa156968945f5533a2b5d9897ca659">More...</a><br /></td></tr>
<tr class="separator:ga49aa156968945f5533a2b5d9897ca659"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9a27533ff4ade0c60978812e517b89d9"><td class="memTemplParams" colspan="2">template&lt;class Traits , class Dcel &gt; </td></tr>
<tr class="memitem:ga9a27533ff4ade0c60978812e517b89d9"><td class="memTemplItemLeft" align="right" valign="top">Size </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangement2Funcs.html#ga9a27533ff4ade0c60978812e517b89d9">CGAL::remove_curve</a> (<a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel &gt; &amp;arr, typename <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel &gt;::Curve_handle ch)</td></tr>
<tr class="memdesc:ga9a27533ff4ade0c60978812e517b89d9"><td class="mdescLeft"> </td><td class="mdescRight">Removes a given curve from a given arrangement.  <a href="group__PkgArrangement2Funcs.html#ga9a27533ff4ade0c60978812e517b89d9">More...</a><br /></td></tr>
<tr class="separator:ga9a27533ff4ade0c60978812e517b89d9"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae20b2917f6de15db9bf025f83abf8e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae20b2917f6de15db9bf025f83abf8e89">◆ </a></span>decompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> CGAL::decompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>oi</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arr_vertical_decomposition_2.h&gt;</code></p>

<p>Produces the symbolic vertical decomposition of a given arrangement, performing a batched vertical ray-shooting query from all arrangement vertices, such that every vertex is associated with a pair of objects, one corresponds to the arrangement feature that lies below it, and the other corresponds to the feature that lies above it. </p>
<p>The output of this function can be readily used for inserting vertical walls and physically decomposing the arrangement into pseudo-trapezoids. To do this, it is convenient to process the vertices in an ascending \( xy\)-lexicographic order. The visible objects are therefore returned through an output iterator, which pairs each finite arrangement vertex with the two features it "sees", such that the vertices are given in ascending \( xy\)-lexicographic order.</p>
<p>Produces the symbolic vertical decomposition of the <code>arr</code> arrangement. More precisely, it performs a batched vertical ray-shooting query from all arrangement vertices, such that every vertex is associated with a pair of objects, one corresponding to the arrangement feature that lies below it, while the other corresponds to the feature that lies above it. The query results are returned through the output iterator, which pairs each finite arrangement vertex with a pair of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Object.html">Object</a></code>s, the first represents the feature below the vertex, and the second represents the feature that lies above it. Each <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Object.html">Object</a></code> may be one of the following: </p><ul>
<li>
<code>Halfedge_const_handle</code>, if the vertex is located above (or below) an edge. The given halfedge is always directed from right to left. In case there is no concrete edge below (or above) the vertex, and the arrangement is unbounded, then the object returned is a <em>fictitious</em> halfedge. </li>
<li>
<code>Face_const_handle</code>, in case there is no edge below (or above) the vertex, and the arrangement is bounded. </li>
<li>
<code>Vertex_const_handle</code>, in case the vertex is located vertically above (or below) another arrangement vertex. </li>
<li>
An empty object, in case the vertex is the top end-vertex of a vertical edge, we define there is no feature below it. Similarly, if it is the bottom end-vertex of a vertical edge, we define that there is no feature above it. </li>
</ul>
<p>The function returns a past-the-end iterator for its output sequence.</p>
<p><b>Requirements</b><br />
</p>
<p><code>OutputIterator::value_type</code> must be <code>pair&lt;Arrangement_2::Vertex_const_handle, pair&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Object.html">Object</a>, <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Object.html">Object</a>&gt; &gt;</code>. </p>

</div>
</div>
<a id="gab3d781b13fdf51ca9579ad13c2a32620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3d781b13fdf51ca9579ad13c2a32620">◆ </a></span>do_intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GeomTraits , class TopTraits , class Curve , class PointLocation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::do_intersect </td>
          <td>(</td>
          <td class="paramtype">Arrangement_on_surface_2&lt; GeomTraits, TopTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Curve &amp; </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointLocation &amp; </td>
          <td class="paramname"><em>pl</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Checks if a given curve or \( x\)-monotone curve intersects an existing arrangement's edges or vertices. </p>
<p>If the give curve is not an \( x\)-monotone curve then the function subdivides the given curve into \( x\)-monotone subcurves and isolated vertices . Each subcurve is in turn checked for intersection. The function uses the zone algorithm to check if the curve intersects the arrangement. First, the curve's left endpoint is located. Then, its zone is computed starting from its left endpoint location. The zone computation terminates when an intersection with an arrangement's edge/vertex is found or when the right endpoint is reached.</p>
<p>A given point-location object is used for locating the left endpoint of the given curve in the existing arrangement. By default, the function uses the "walk along line" point-location strategy - namely an instance of the class <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt; &gt;</code>.</p>
<p>Checks if the given curve or \( x\)-monotone curve <code>c</code> intersects edges or vertices of the existing arrangement <code>arr</code>. </p><dl class="section pre"><dt>Precondition</dt><dd>If provided, <code>pl</code> must be attached to the given arrangement <code>arr</code>.</dd></dl>
<p><b>Requirements</b><br />
</p>
<ul>
<li>
If <code>c</code> is \( x\)-monotone then the instantiated <code>GeomTraits</code> class must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept. If <code>c</code> is a curve then the instantiated <code>GeomTraits</code> class must model the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> concept. That is, it should define the <code>Curve_2</code> type, and support its subdivision into \( x\)-monotone subcurves (and perhaps isolated points). </li>
<li>
The point-location object <code>pl</code>, must model the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept. </li>
</ul>

</div>
</div>
<a id="gad453feb3ff2f60a9741bf9d2917bf225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad453feb3ff2f60a9741bf9d2917bf225">◆ </a></span>insert_non_intersecting_curve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel , typename PointLocation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;::Halfedge_handle CGAL::insert_non_intersecting_curve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::X_monotone_curve_2 &amp; </td>
          <td class="paramname"><em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointLocation &amp; </td>
          <td class="paramname"><em>pl</em> = <code>walk_pl</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Inserts a given \( x\)-monotone curve into a given arrangement, where the interior of the given curve is disjoint from all existing arrangement vertices and edges. </p>
<p>Under this assumption, it is possible to locate the endpoints of the given curve in the arrangement, and use one of the specialized insertion member-functions of the arrangement according to the results. The insertion operations creates a single new edge, that is, two twin halfedges, and the function returns a handle for the one directed lexicographically in increasing order (from left to right).</p>
<p>A given point-location object is used for answering the two point-location queries on the given curve endpoints. By default, the function uses the "walk along line" point-location strategy - namely, an instance of the class <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt; &gt;</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If provided, <code>pl</code> must be attached to the given arrangement <code>arr</code>.</dd></dl>
<p><b>Requirements</b><br />
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the restricted <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept, as no intersections are computed. </li>
<li>
The point-location object <code>pl</code> must model the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept. </li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Arrangement_on_surface_2_2bgl_primal_adapter_8cpp-example.html#a6">Arrangement_on_surface_2/bgl_primal_adapter.cpp</a>, <a class="el" href="Arrangement_on_surface_2_2dcel_extension_8cpp-example.html#a4">Arrangement_on_surface_2/dcel_extension.cpp</a>, <a class="el" href="Arrangement_on_surface_2_2dcel_extension_io_8cpp-example.html#a7">Arrangement_on_surface_2/dcel_extension_io.cpp</a>, <a class="el" href="Arrangement_on_surface_2_2face_extension_8cpp-example.html#a7">Arrangement_on_surface_2/face_extension.cpp</a>, <a class="el" href="Arrangement_on_surface_2_2face_extension_overlay_8cpp-example.html#a5">Arrangement_on_surface_2/face_extension_overlay.cpp</a>, <a class="el" href="Arrangement_on_surface_2_2incremental_insertion_8cpp-example.html#a5">Arrangement_on_surface_2/incremental_insertion.cpp</a>, <a class="el" href="Arrangement_on_surface_2_2observer_8cpp-example.html#a8">Arrangement_on_surface_2/observer.cpp</a>, <a class="el" href="Arrangement_on_surface_2_2overlay_8cpp-example.html#a4">Arrangement_on_surface_2/overlay.cpp</a>, and <a class="el" href="Arrangement_on_surface_2_2unbounded_non_intersecting_8cpp-example.html#a3">Arrangement_on_surface_2/unbounded_non_intersecting.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="gad4aa37a4e938747028690579fb703d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4aa37a4e938747028690579fb703d67">◆ </a></span>insert_non_intersecting_curves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel , InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::insert_non_intersecting_curves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>last</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Inserts a set of \( x\)-monotone curves in a given range into a given arrangement. </p>
<p>The insertion is performed in an aggregated manner, using the sweep-line algorithm. The input curves should be pairwise disjoint in their interior and pairwise interior-disjoint from all existing arrangement vertices and edges.</p>
<p><b>Requirements</b><br />
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept, as no intersections are computed. </li>
<li>
<code>InputIterator::value_type</code> must be <code>Traits::X_monotone_curve_2</code> </li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Arrangement_on_surface_2_2global_insertion_8cpp-example.html#a5">Arrangement_on_surface_2/global_insertion.cpp</a>, and <a class="el" href="Arrangement_on_surface_2_2predefined_kernel_non_intersecting_8cpp-example.html#a4">Arrangement_on_surface_2/predefined_kernel_non_intersecting.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ga13c103c1cea5249ca37ce7e0be4d97e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13c103c1cea5249ca37ce7e0be4d97e4">◆ </a></span>insert_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel , typename PointLocation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;::Vertex_handle CGAL::insert_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Point_2 &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointLocation &amp; </td>
          <td class="paramname"><em>pl</em> = <code>walk_pl</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Inserts a given point into a given arrangement. </p>
<p>It uses a given point-location object to locate the given point in the given arrangement. If the point conincides with an existing vertex, there is nothing left to do; if it lies on an edge, the edge is split at the point. Otherwise, the point is contained inside a face, and is inserted as an isolated vertex inside this face. By default, the function uses the "walk along line" point-location strategy - namely, an instance of the class <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt; &gt;</code>. In either case, the function returns a handle for the vertex associated with the point.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If provided, <code>pl</code> must be attached to the given arrangement <code>arr</code>.</dd></dl>
<p><b>Requirements</b><br />
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept, and support the splitting functionality. </li>
<li>
The point-location object <code>pl</code>, must model the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept. </li>
</ul>

</div>
</div>
<a id="gabcb9bc6c5859edf3fbc1390e60e32a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcb9bc6c5859edf3fbc1390e60e32a17">◆ </a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Checks the validity of a given arrangement. </p>
<p>Invokes the member function <code><a class="el" href="group__PkgArrangement2Funcs.html#gabcb9bc6c5859edf3fbc1390e60e32a17" title="Checks the validity of a given arrangement. ">arr.is_valid()</a></code> to verify the topological correctness of the arrangement. Then it performs additional validity tests. It checks that all \( x\)-monotone curves associated with arrangement edges are pairwise disjoint in their interior. Then it makes sure that all holes and all isolated vertices are located within the proper arrangement faces. Note that the test carried out by this function may take a considerable amount of time; it is recommended to be used only for debugging purposes.</p>
<p><b>Requirements</b><br />
</p>
<p>The instantiated traits class must model the concept <code>ArranagmentXMonotoneTraits_2</code>. </p>

</div>
</div>
<a id="ga339cdba93f54001be303595689002396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga339cdba93f54001be303595689002396">◆ </a></span>overlay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GeomTraitsA , class GeomTraitsB , class GeomTraitsRes , class TopTraitsA , class TopTraitsB , class TopTraitsRes , class OverlayTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::overlay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsA, TopTraitsA &gt; &amp; </td>
          <td class="paramname"><em>arr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsB, TopTraitsB &gt; &amp; </td>
          <td class="paramname"><em>arr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsRes, TopTraitsRes &gt; &amp; </td>
          <td class="paramname"><em>arr_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOverlayTraits.html">OverlayTraits</a> &amp; </td>
          <td class="paramname"><em>ovl_tr</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arr_overlay_2.h&gt;</code></p>

<p>Computes the overlay of two arrangements <code>arr1</code> and <code>arr2</code>, and sets the output arrangement <code>res</code> to represent the overlaid arrangement. </p>
<p>Computes the overlay of two input arrangement objects, and returns the overlaid arrangement. All three arrangements can be instantiated with different geometric traits classes and different <span class="textsc">Dcel</span> classes (encapsulated in the various topology-traits classes). The geometry traits of the resulting arrangement is used to construct the resulting arrangement. This means that all the types (e.g., <code>Traits::Point_2</code>, <code>Traits::Curve_2</code>, and <code>Traits::Point_2</code>) of both input arrangements have to be convertible to the types in the resulting arrangement. A given overlay-traits object is used to properly construct the overlaid <span class="textsc">Dcel</span> that represents the resulting arrangement.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>res</code> does not refer to either <code>arr1</code> or <code>arr2</code> (that is, "self overlay" is not supported).</dd>
<dd>
The overlay-traits object <code>ovl_tr</code> must model the <code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices, halfedges and faces) of two input Dcel classes, named Dcel_A and Dcel_B, and construct the records of an output Dcel class, referred to as Dcel_R. ">OverlayTraits</a></code> concept, which is able to construct records of the <code>ResDcel</code> class on the basis of the <code>Dcel1</code> and <code>Dcel2</code> records that induce them.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices, halfedges and faces) of two input Dcel classes, named Dcel_A and Dcel_B, and construct the records of an output Dcel class, referred to as Dcel_R. ">OverlayTraits</a></code> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Arrangement_on_surface_2_2face_extension_overlay_8cpp-example.html#a6">Arrangement_on_surface_2/face_extension_overlay.cpp</a>, <a class="el" href="Arrangement_on_surface_2_2overlay_8cpp-example.html#a5">Arrangement_on_surface_2/overlay.cpp</a>, and <a class="el" href="Arrangement_on_surface_2_2overlay_unbounded_8cpp-example.html#a6">Arrangement_on_surface_2/overlay_unbounded.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="gaddb9e44b14b27e4cf0c7bb26b27d8518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddb9e44b14b27e4cf0c7bb26b27d8518">◆ </a></span>overlay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel1 , typename Dcel2 , typename ResDcel , typename OverlayTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::overlay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel1 &gt; &amp; </td>
          <td class="paramname"><em>arr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel2 &gt; &amp; </td>
          <td class="paramname"><em>arr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, ResDcel &gt; &amp; </td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOverlayTraits.html">OverlayTraits</a> &amp; </td>
          <td class="paramname"><em>ovl_tr</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arr_overlay_2.h&gt;</code></p>

<p>Computes the overlay of two arrangements with history <code>arr1</code> and <code>arr2</code>, and sets the output arrangement with history <code>res</code> to represent the overlaid arrangement. </p>
<p>The function also constructs a consolidated set of curves that induce <code>res</code>.</p>
<p>Computes the overlay of two input arrangement objects, and returns the overlaid arrangement. All three arrangements can be instantiated with different geometric traits classes and different <span class="textsc">Dcel</span> classes (encapsulated in the various topology-traits classes). The geometry traits of the resulting arrangement is used to construct the resulting arrangement. This means that all the types (e.g., <code>Traits::Point_2</code>, <code>Traits::Curve_2</code>, and <code>Traits::Point_2</code>) of both input arrangements have to be convertible to the types in the resulting arrangement. A given overlay-traits object is used to properly construct the overlaid <span class="textsc">Dcel</span> that represents the resulting arrangement.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>res</code> does not refer to either <code>arr1</code> or <code>arr2</code> (that is, "self overlay" is not supported).</dd>
<dd>
The overlay-traits object <code>ovl_tr</code> must model the <code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices, halfedges and faces) of two input Dcel classes, named Dcel_A and Dcel_B, and construct the records of an output Dcel class, referred to as Dcel_R. ">OverlayTraits</a></code> concept, which is able to construct records of the <code>ResDcel</code> class on the basis of the <code>Dcel1</code> and <code>Dcel2</code> records that induce them.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices, halfedges and faces) of two input Dcel classes, named Dcel_A and Dcel_B, and construct the records of an output Dcel class, referred to as Dcel_R. ">OverlayTraits</a></code> </dd></dl>

</div>
</div>
<a id="ga9a27533ff4ade0c60978812e517b89d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a27533ff4ade0c60978812e517b89d9">◆ </a></span>remove_curve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class Dcel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Size CGAL::remove_curve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel &gt;::Curve_handle </td>
          <td class="paramname"><em>ch</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_with_history_2.h&gt;</code></p>

<p>Removes a given curve from a given arrangement. </p>
<p>The curve is specified by its handle <code>ch</code>, from the arrangement <code>arr</code>, by deleting all the edges it induces. The function returns the number of deleted edges. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Arrangement_on_surface_2_2edge_manipulation_curve_history_8cpp-example.html#a10">Arrangement_on_surface_2/edge_manipulation_curve_history.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ga324fdf8354e7812fe0e1c0e5ac14196c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga324fdf8354e7812fe0e1c0e5ac14196c">◆ </a></span>remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;::Face_handle CGAL::remove_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Halfedge_handle </td>
          <td class="paramname"><em>e</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. </p>
<p>Once the edge is removed, if the vertices associated with its endpoints become isolated, they are removed as well. The call <code>remove_edge(arr, e)</code> is equivalent to the call <code>arr.remove_edge (e, true, true)</code>. However, this free function requires that <code>Traits</code> be a model of the refined concept <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code>, which requires merge operations on \( x\)-monotone curves. If one of the end-vertices of the given edge becomes redundant after the edge is removed (see <code><a class="el" href="group__PkgArrangement2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778" title="Attempts to removed a given vertex from a given arrangement. ">remove_vertex()</a></code> for the definition of a redundant vertex), it is removed, and its incident edges are merged. If the edge-removal operation causes two faces to merge, the merged face is returned. Otherwise, the face to which the edge was incident before the removal is returned.</p>
<p><b>Requirements</b><br />
</p>
<ul>
<li>
The instantiated traits class must model the concept <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code>. </li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Arrangement_on_surface_2_2global_removal_8cpp-example.html#a6">Arrangement_on_surface_2/global_removal.cpp</a>, and <a class="el" href="Arrangement_on_surface_2_2observer_8cpp-example.html#a10">Arrangement_on_surface_2/observer.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="gacbb4f22a59c77fb06a9d544cbbb04778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbb4f22a59c77fb06a9d544cbbb04778">◆ </a></span>remove_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::remove_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Vertex_handle </td>
          <td class="paramname"><em>v</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Attempts to removed a given vertex from a given arrangement. </p>
<p>The vertex can be removed if it is either an isolated vertex, (and has no incident edge,) or if it is a <em>redundant</em> vertex. That is, it has exactly two incident edges, whose associated curves can be merged to form a single \( x\)-monotone curve. The function returns a boolean value that indicates whether it succeeded removing the vertex from the arrangement.</p>
<p><b>Requirements</b><br />
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept and support the merging functionality. </li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Arrangement_on_surface_2_2global_removal_8cpp-example.html#a5">Arrangement_on_surface_2/global_removal.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ga49aa156968945f5533a2b5d9897ca659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49aa156968945f5533a2b5d9897ca659">◆ </a></span>zone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GeomTraits , class TopTraits , class OutputIterator , class PointLocation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> CGAL::zone </td>
          <td>(</td>
          <td class="paramtype">Arrangement_on_surface_2&lt; GeomTraits, TopTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GeomTraits::X_monotone_curve_2 &amp; </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>oi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointLocation &amp; </td>
          <td class="paramname"><em>pl</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Compute the zone of the given \( x\)-monotone curve in the existing arrangement. </p>
<p>Meaning, it output the arrangement's vertices, edges and faces that the \( x\)-monotone curve intersects. The order of the objects is the order that they are discovered when traversing the \( x\)-monotone curve from left to right.</p>
<p>A given point-location object is used for answering point-location queries during the insertion process. By default, the function uses the "walk along line" point-location strategy - namely an instance of the class <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt; &gt;</code>.</p>
<p>Compute the zone of the given \( x\)-monotone curve <code>c</code> in the arrangement <code>arr</code>. </p><dl class="section pre"><dt>Precondition</dt><dd>If provided, <code>pl</code> must be attached to the given arrangement <code>arr</code>.</dd></dl>
<p><b>Requirements</b><br />
</p>
<ul>
<li>
The instantiated <code>GeomTraits</code> class must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept. </li>
<li>
The point-location object <code>pl</code>, must model the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept. </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:46 for CGAL 4.13 - 2D Arrangements by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
