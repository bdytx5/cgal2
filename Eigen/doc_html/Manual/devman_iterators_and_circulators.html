<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Manual/devman_iterators_and_circulators.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Manual: Iterators, Circulators and Handles</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt="" /></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('devman_iterators_and_circulators.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Iterators, Circulators and Handles </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Mariette Yvinec (<code><a href="#" onclick="location.href='mai'+'lto:'+'yvi'+'ne'+'c@s'+'op'+'hia'+'.i'+'nri'+'a.'+'fr'; return false;">yvine<span style="display: none;">.nosp@m.</span>c@so<span style="display: none;">.nosp@m.</span>phia.<span style="display: none;">.nosp@m.</span>inri<span style="display: none;">.nosp@m.</span>a.fr</a></code>)</dd></dl>
<p>Iterators are a generalization of pointers that allow a programmer to work with different data structures (containers) in a uniform manner. An iterator is the glue that allows one to write a single implementation of an algorithm that will work for data contained in an array, a list or some other container - even a container that did not yet exist when the algorithm was implemented.</p>
<p>The concept of an iterator is one of the major tools of the genericity in <span style="font-variant: small-caps;">STL</span>. Iterators are used almost everywhere in the <span style="font-variant: small-caps;">STL</span> to achieve the communication between containers and algorithms. Iterators are widely used in <span style="font-variant: small-caps;">CGAL</span> too. <span style="font-variant: small-caps;">CGAL</span> extends the idea of the iterator, which works for linear data structures, to circular data structures by defining the concept of a circulator. <a class="el" href="packages.html#PkgHandlesAndCirculatorsSummary">Circulators</a> are quite similar to iterators, with the major difference being the absence of a past-the-end position in a sequence. Note that circulators are NOT part of the <span style="font-variant: small-caps;">STL</span>, but of <span style="font-variant: small-caps;">CGAL</span>.</p>
<p>In <span style="font-variant: small-caps;">CGAL</span>, we also define the concept of <a class="el" href="packages.html#PkgHandlesAndCirculatorsSummary">handle</a>, which behaves roughly like a pointer to an object without an increment or decrement operation. More details about handles and their requirements can be found in the <a class="el" href="packages.html#PkgHandlesAndCirculatorsSummary">chapter Circulators and Handles</a> of the Support Library part of <span style="font-variant: small-caps;">CGAL</span> manual. Section <a class="el" href="devman_iterators_and_circulators.html#sechandle_vs_it_vs_circ">Handle, iterator, or circulator?</a> below discusses when handles should be used in your code.</p>
<p>The concepts of iterators is relatively well described in textbooks such as Stroustrup's book (<em>The C++ Programming Language</em> <a class="el" href="citelist.html#CITEREF_cgal:s-cpl-97">[9]</a>) and Austern's book (<em>Generic Programming and the <span style="font-variant: small-caps;">STL</span></em> <a class="el" href="citelist.html#CITEREF_cgal:a-gps-98">[2]</a>) and in chapter <a class="el" href="packages.html#PkgHandlesAndCirculatorsSummary">Handles and Circulators</a> of the <em>Support Library</em> part of the <span style="font-variant: small-caps;">CGAL</span> manual. which also presents the concepts of handles and circulators. Thus we will not give a full description of these concept here but only a few hints about how to use and write handle, iterators and circulators in <span style="font-variant: small-caps;">CGAL</span>. Developers should consult the above-mentioned references to become familiar with the iterator, circulator and handle concepts. In particular, the notions of iterator and circulator ranges, dereferencable and past-the-end values, mutable and constant iterators and circulators, and the different categories (forward, bidirectional, random-access, etc.) of iterators and circulators, are fundamental.</p>
<h1><a class="anchor" id="seciterator_traits"></a>
Iterator and circulator traits</h1>
<p>Iterators and/or circulators are required to provide a set of types such as the <code>value_type</code> for the type of objects referred to by the iterator and circulator or the <code>difference_type</code> for the distance between two iterators or circulators. These types are usually declared in the iterator or circulator classes. The iterator traits have been introduced to attach such types to pointer classes, thus enabling the use of pointer classes as models of iterator and circulator concepts. Therefore, an algorithm using an iterator of the type <code>Iter</code> will find the relevant types in an instantiation of a small templated class <code>iterator_traits</code>.</p>
<p>There is a general templated version of <code>iterator_traits</code> that looks like: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iter&gt; </div><div class="line"><span class="keyword">struct </span>iterator_traits {</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iter::iterator_category  iterator_category ;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iter::value_type         value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iter::difference_type    difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iter::pointer            pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iter::reference          reference;</div><div class="line">};</div></div><!-- fragment --><p> and a partial specialization of <code>iterator_traits</code> classes for pointers:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; </div><div class="line"><span class="keyword">struct </span>iterator_traits&lt;T*&gt; {</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator            iterator_category ;</div><div class="line">  <span class="keyword">typedef</span> T                                 value_type;</div><div class="line">  <span class="keyword">typedef</span> ptrdiff_t                         difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                                pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                                reference;</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="secinput_and_output_iterators"></a>
Input and output iterators</h1>
<p><b>Operator * for input and output iterators</b></p>
<p>The operator * of input and output iterators has a restricted semantics. Input iterators are designed for input operations, and it is not required that the value type <code>T</code> of an input iterator <code>it</code> be assignable. Thus, while assignments of the type <code>t = *it</code> are the usual way to get values from the input iterators, statements like <code>*it = ...</code> are likely to be illegal. On the other hand, output iterators are designed for write operations, and the only legal use of the operator * of an output iterator <code>it</code> is in the assignment <code>*it = ....</code>. The code of a standard copy function of the <span style="font-variant: small-caps;">STL</span> provides an example of both of these operations:</p>
<p><a class="anchor" id="copy_function"></a> </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator&gt;</div><div class="line"><a class="code" href="classOutputIterator.html">OutputIterator</a> copy(<a class="code" href="classInputIterator.html">InputIterator</a> first, </div><div class="line">                    <a class="code" href="classInputIterator.html">InputIterator</a> last,</div><div class="line">                    <a class="code" href="classOutputIterator.html">OutputIterator</a> result) {</div><div class="line">    <span class="keywordflow">while</span> (first != last)</div><div class="line">    {</div><div class="line">       *result = *first;</div><div class="line">       ++first; </div><div class="line">       ++result;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --> <p>The first two arguments of <code>copy</code> are of type <code><a class="el" href="classInputIterator.html" title="Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/InputIterator. ">InputIterator</a></code> (meaning any type that fulfills the requirements for an input iterator) while the third one is of type <code><a class="el" href="classOutputIterator.html" title="Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/OutputIterator. ">OutputIterator</a></code>. If these types were exchanged, then the statement <code>*result = *first;</code> might not be valid.</p>
<p><b>Stream iterators</b></p>
<p><span style="font-variant: small-caps;">STL</span> provides a special type of input iterator called <code>istream_iterator</code>, which is designed to be bound to an object of the class <code>istream</code> and provides a way to read a sequence of values from the input stream to which it is bound. For example, the following code reads numbers of type <code>double</code> from the standard input stream <code>cin</code> and computes their sum. </p><div class="fragment"><div class="line">istream_iterator&lt;double&gt; it(cin);</div><div class="line">istream_iterator&lt;double&gt; end();</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> sum=0.0;</div><div class="line"><span class="keywordflow">while</span>(it != end) {</div><div class="line">   sum += *it;</div><div class="line">   ++it;</div><div class="line">}</div><div class="line">cout &lt;&lt; sum &lt;&lt; endl;</div></div><!-- fragment --><p>In a similar fashion, <span style="font-variant: small-caps;">STL</span> provides the type <code>ostream_iterator</code>, which is designed to be bound to an object of the class <code>ostream</code> and used to output values to the output stream to which it is bound.</p>
<p><span style="font-variant: small-caps;">CGAL</span> provides extensions of the classes <code>istream_iterator</code> and <code>ostream_iterator</code>. The class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Ostream__iterator.html">CGAL::Ostream_iterator</a>&lt;T,Stream&gt;</code> is an output iterator adaptor for the stream class <code>Stream</code> and value</p>
<p>type <code>T</code>. It provides output iterators that can be used to output values of type <code>T</code> to objects of the class <code>Stream</code>. For example, the following code fragment inserts a list of segments into a window stream (<em>i.e.</em>, it draws the segments in the window) using the standard copy function:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;double&gt;</a>   K;</div><div class="line"><span class="keyword">typedef</span> K::Segment_2              Segment;</div><div class="line"></div><div class="line">std::vector&lt;Segment&gt;       segments;</div><div class="line">Window_stream        W( 400, 400);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="comment">// initialize segments</span></div><div class="line">  std::copy( segments.begin(),</div><div class="line">             segments.end(),</div><div class="line">             <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Ostream__iterator.html">CGAL::Ostream_iterator&lt; Segment, Window_stream&gt;</a>( W));</div><div class="line">}</div></div><!-- fragment --><p>Likewise, the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Istream__iterator.html">CGAL::Istream_iterator</a>&lt;T,Stream&gt;</code> is an input iterator adaptor for the stream class <code>Stream</code> and value type <code>T</code>. These adaptors are particularly useful for stream classes that are similar to but not derived from <code>std::istream</code> and <code>std::ostream</code>. The only requirements of the stream classes are that they define <code>operator&gt;&gt;</code> (for <code>Istream_iterator::value_type</code>) and <code>operator&lt;&lt;</code> (for <code>Ostream_iterator::value_type</code>).</p>
<p><b>Insert iterators</b></p>
<p>Insert iterators are output iterators that can be used to insert items into containers. With regular iterator classes, the code given above for the <code>copy</code> function of <span style="font-variant: small-caps;">STL</span>, causes the range <code>[first,last)</code> to be copied into an existing range starting with <code>result</code>. No memory allocation is involved and the existing range is overwritten. With an insert iterator supplied as the third argument, the same code will cause elements to be inserted into the container with which the output iterator is associated. That is, new memory may be allocated for these inserted elements.</p>
<p>The <span style="font-variant: small-caps;">STL</span> provides three kinds of insert iterators: <code>insert_iterator</code>s, <code>back_insert_iterator</code>s and <code>front_insert_iterator</code>s. The <code>back_inserter_iterator</code>s are used to insert elements at the end of a container by using the <code>push_back</code> member function of the container. Similarly, <code>front_insert_iterator</code>s are used to insert elements at the beginning of a container by using the container's <code>push_front</code> function. The general <code>insert_iterator</code> is used to insert elements at any point in a container, by using the container's <code>insert</code> member function and a provided location of the insertion.</p>
<p>For convenience, <span style="font-variant: small-caps;">STL</span> provides the templated functions (or adaptors) <code>front_inserter</code>, <code>back_inserter</code> and <code>inserter</code> to get insert iterators, also called inserters, from containers.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Container, <span class="keyword">class</span> Iterator&gt; </div><div class="line">insert_iterators&lt;Container&gt; inserter(Container&amp; c, <a class="code" href="classIterator.html">Iterator</a> it); </div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Container&gt; </div><div class="line">back_insert_iterators&lt;Container&gt; back_inserter(Container&amp; c); </div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Container&gt; </div><div class="line">front_insert_iterators&lt;Container&gt; front_inserter(Container&amp; c); </div></div><!-- fragment --><p>Thus, the <code>inserter</code> adaptor can be called for any container that has an <code>insert</code> member function, and <code>back_inserter</code> (resp. <code>front_inserter</code>) can be called for any container that has a <code>push_back</code> (resp. <code>push_front</code>) member function.</p>
<p>The following code will insert 200 copies of the value 7 at the end of <code>vec</code>. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> g(vector&lt;int&gt;&amp; vec)</div><div class="line">{</div><div class="line">    fill_n(std::back_inserter(vec),200,7);</div><div class="line">}</div></div><!-- fragment --><p> and this code will insert the points contained in the vector <code>vertices</code> into a Delaunay triangulation data structure:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;double&gt;</a>                          K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__euclidean__traits__2.html">CGAL::Triangulation_euclidean_traits_2&lt;K&gt;</a>        Gt;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__2.html">CGAL::Triangulation_vertex_base_2&lt;Gt&gt;</a>            Vb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__2.html">CGAL::Triangulation_face_base_2&lt;Gt&gt;</a>              Fb;</div><div class="line"><span class="keyword">typedef</span> CGAL::Triangulation_default_data_structure_2&lt;Gt,Vb,Fb&gt;</div><div class="line">                                                         Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Gt,Tds&gt;</a>           DT;</div><div class="line"></div><div class="line">DT triangulation;</div><div class="line"></div><div class="line">std::copy( vertices.begin(),</div><div class="line">           vertices.end(),</div><div class="line">           std::back_inserter( triangulation ));</div></div><!-- fragment --><h1><a class="anchor" id="Developer_manualWritingcodewithandforiterators"></a>
Writing code with and for iterators, circulators, and handles</h1>
<p>Because you should write generic code for <span style="font-variant: small-caps;">CGAL</span>, algorithms that require a sequence of data for input should be written to take an iterator (or circulator) range as input instead of, say, a particular container. Similarly, algorithms that compute a sequence of data as output should place the output data into an output iterator range. Both of these points are illustrated by the prototype of the following function that computes the convex hull of a set of points in two dimensions:</p>
<div class="fragment"><div class="line"><span class="comment">// generates the counterclockwise sequence of extreme points</span></div><div class="line"><span class="comment">// of the points in the range [first,beyond).</span></div><div class="line"><span class="comment">// The resulting sequence is placed starting at position</span></div><div class="line"><span class="comment">// result, and the past-the-end iterator for the resulting</span></div><div class="line"><span class="comment">// sequence is returned. It is not specified at which point the</span></div><div class="line"><span class="comment">// cyclic sequence of extreme points is cut into a linear sequence.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator&gt;</div><div class="line"><a class="code" href="classOutputIterator.html">OutputIterator</a></div><div class="line">convex_hull_points_2(<a class="code" href="classInputIterator.html">InputIterator</a> first, <a class="code" href="classInputIterator.html">InputIterator</a> beyond,</div><div class="line">                     <a class="code" href="classOutputIterator.html">OutputIterator</a>  result, <span class="keyword">const</span> Traits &amp; ch_traits );</div></div><!-- fragment --><p>Also, when writing container classes, you should be sure to provide iterators and/or circulators for the containers and design the interfaces so they can be used with generic algorithms from the <span style="font-variant: small-caps;">STL</span> and other <span style="font-variant: small-caps;">CGAL</span> algorithm. Here we give a few more details about how to accomplish these goals.</p>
<h2><a class="anchor" id="sechandle_vs_it_vs_circ"></a>
Handle, iterator, or circulator?</h2>
<p>Handles are indirect references that do not move, so whenever you need a pointer-like reference to a single element of a data structure, and it is not necessary to iterate (or circulate), use a handle. In contrast, iterators should be used when you want to move (that is, iterate) over a linear sequences of elements. When the sequence is circular, prefer a circulator over an iterator.</p>
<h2><a class="anchor" id="secit_and_circ_code"></a>
Writing functions for iterators AND circulators</h2>
<p>To make your code as generic as possible, you should, where appropriate, write functions that can accept either a circulator range or an iterator range to delimit the input values. Since empty circulator ranges are represented differently than empty iterator ranges, the following function is defined in <code>&lt;CGAL/circulator.h&gt;</code> so the test for an empty range can be done generically:</p>
<p>One would use this function in conjunction with a <code>do-while</code> loop as follows:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ( ! <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/group__PkgHandlesAndCirculatorsFunctions.html#gaf4e8c8285d91a1d8acd582191da0f255">CGAL::is_empty_range</a>( i, j) )</div><div class="line">{</div><div class="line">  <span class="keywordflow">do</span></div><div class="line">  { </div><div class="line">    <span class="comment">// ...</span></div><div class="line">  } <span class="keywordflow">while</span> ( ++i != j )</div><div class="line">}</div></div><!-- fragment --><p>The following two macros are also defined as a generic means for iterating over either a linear or circular sequence:</p><ul>
<li><code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/group__PkgHandlesAndCirculatorsFunctions.html#gae4f6b9dc3b933f01f2d0275a7bf8b308">CGAL_For_all( ic1, ic2)</a></code></li>
<li><code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/group__PkgHandlesAndCirculatorsFunctions.html#gace997aff7a7768aa76d2b2e19a7ef558">CGAL_For_all_backwards( ic1, ic2)</a></code>.</li>
</ul>
<p>See the chapter <a class="el" href="packages.html#PkgHandlesAndCirculatorsSummary">Handles and Circulators</a> in the <em>Support Library</em> part of <span style="font-variant: small-caps;">CGAL</span> manual for more information and examples.</p>
<h2><a class="anchor" id="secclass_iterator"></a>
Writing an iterator for your container</h2>
<p>Every container class in <span style="font-variant: small-caps;">CGAL</span> should strive to be a model for the <span style="font-variant: small-caps;">STL</span> concept of a container. As for all concepts, this means that certain types and functions are provided, as detailed, for example in <a class="el" href="citelist.html#CITEREF_cgal:a-gps-98">[2]</a>. For the purposes of this discussion, the relevant types are:</p>
<table class="doxtable">
<tr>
<td align="LEFT" valign="TOP"><code>iterator</code> </td><td align="LEFT" valign="TOP">type of iterator </td></tr>
<tr>
<td align="LEFT" valign="TOP"><code>const_iterator</code> </td><td align="LEFT" valign="TOP">iterator type for container with constant elements </td></tr>
</table>
<p>and the relevant functions are:</p>
<div class="fragment"><div class="line">iterator begin(); <span class="comment">// beginning of container</span></div><div class="line">const_iterator begin(); <span class="comment">// beginning of container with constant elements</span></div><div class="line">iterator end(); <span class="comment">// past-the-end value for container</span></div><div class="line">const_iterator end(); <span class="comment">// past-the-end value for container with constant elements</span></div></div><!-- fragment --><p>Variations on the above names are possible when, for example, the container contains more than one thing that can be iterated over. See Section <a class="el" href="devman_code_format.html#secnaming_scheme">Naming scheme</a> for more details about the naming conventions for iterators and their access functions.</p>
<h2><a class="anchor" id="secclass_circulator"></a>
Writing a circulator for your container</h2>
<p>When a container represents a circular data structure (<em>i.e.</em>, one without a defined beginning or end), one should provide circulators for the data elements in addition to (or, where appropriate, instead of) the iterators. This means that the following types should be defined:</p>
<table class="doxtable">
<tr>
<td align="LEFT" valign="TOP"><code>circulator</code> </td><td align="LEFT" valign="TOP">type of circulator </td></tr>
<tr>
<td align="LEFT" valign="TOP"><code>const_circulator</code> </td><td align="LEFT" valign="TOP">circulator type for container with constant elements </td></tr>
</table>
<p>as well as two access functions, one for each of the two types, with names that end in the suffix <code>_circulator</code> (Section <a class="el" href="devman_code_format.html#secnaming_scheme">Naming scheme</a> ).</p>
<h1><a class="anchor" id="it_and_circit_and_circ_req_and_rec"></a>
Requirements and recommendations</h1>
<p>Requirements: </p><ul>
<li>
<p class="startli">All container classes should provide iterator types and access functions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">All container classes that represent circular data structures should provide circulator types and access functions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Take care that decrement of the past-the-end value is, in accordance with the standard, a legal operation for a bidirectional iterator.</p>
<p class="endli">This can, for example, be used to get the last element of a sequence. </p>
</li>
</ul>
<p>Recommendations: </p><ul>
<li>
<p class="startli">Be aware that postincrement (respectively, postdecrement) is more expensive than preincrement (predecrement) since the iterator or circulator value must be copied in the former case.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Remember that iterators and circulators are intended to be lightweight objects. That is, copying them should require only constant time.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When writing a container-like structure, provide <code>push_back</code>, <code>push_front</code>, and <code>insert</code> member functions so all insert iterators can be used with your container.</p>
<p class="endli"></p>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:49 for CGAL 4.13 - Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
