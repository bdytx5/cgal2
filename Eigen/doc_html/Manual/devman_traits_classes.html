<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Manual/devman_traits_classes.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Manual: Traits Classes</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt="" /></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('devman_traits_classes.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Traits Classes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Bernd GÃ¤rtner (<code><a href="#" onclick="location.href='mai'+'lto:'+'gae'+'rt'+'ner'+'@i'+'nf.'+'et'+'hz.'+'ch'; return false;">gaert<span style="display: none;">.nosp@m.</span>ner@<span style="display: none;">.nosp@m.</span>inf.e<span style="display: none;">.nosp@m.</span>thz.<span style="display: none;">.nosp@m.</span>ch</a></code>)</dd></dl>
<p>The concept of a traits class is central to <span style="font-variant: small-caps;">CGAL</span>. The name <em>traits class</em> comes from a standard <span style="font-variant: small-caps;">C++</span> design pattern <a class="el" href="citelist.html#CITEREF_cgal:m-tnutt-95">[8]</a>; you may have heard about iterator traits which follow this design pattern. The traits class is used in template code to reflect properties (traits) of the actual template argument. On the lower levels, such as the number types, the traits classes in <span style="font-variant: small-caps;">CGAL</span> indeed follow this pattern. However, in higher level packages the term traits class is used in a slightly different spirit. The most noticeable change is that the traits class becomes the template argument. This allows to bundle several template arguments and provides more flexibility as explained in the subsequent sections.</p>
<h1><a class="anchor" id="secwhat_is_a_traits_class"></a>
What are traits classes in CGAL?</h1>
<p>The algorithms in <a class="el" href="namespaceCGAL.html">CGAL</a>'s basic library are implemented as function templates or class templates, usually having a template parameter whose name contains the word <code>Traits</code>. This template parameter represents a concept and so has a corresponding set of requirements that define the interface between the algorithm and the geometric (or numeric) primitives it uses. Any concrete class that serves as a model for this concept is a traits class for the given algorithm or data structure.</p>
<h1><a class="anchor" id="secwhy_traits_classes"></a>
Why are traits classes in CGAL?</h1>
<p>Using traits concepts as template parameters allows for customization of the behavior of algorithms without changing implementations. At least one model for each traits concept should be provided in <span style="font-variant: small-caps;">CGAL</span> (in the simplest case, the kernel models fit; see Section <a class="el" href="devman_traits_classes.html#seckernel_traits">Kernel as traits</a> ), but often more than one are provided in order to supply certain customizations that users may want. The user is also free to supply his or her own class as a model of the traits concept when the desired tailoring is not present in the library.</p>
<p>Traits classes allow for tailoring of algorithms not only at compile time but also at run time. Some primitive operations that appear in the traits class (in the form of functor types) may need additional data that are not known at compile time. A standard example is the following: we have three-dimensional points, but we want the convex hull of the two-dimensional points that arise after projecting along some direction in space, which is computed as the program runs. How does the algorithm get to know about this direction? If there is a traits class object as a parameter, the information can be provided to the proper primitives through a proper initialization of the traits class object. For this reason, traits class objects are passed as parameters to functions.</p>
<h1><a class="anchor" id="sectraits_class_example"></a>
An example - planar convex hulls</h1>
<p>Consider convex hulls in the plane. What are the geometric primitives a typical convex hull algorithm uses? Of course, this depends on the algorithm, so let us consider what is probably the simplest efficient algorithm, the so-called Graham Scan. This algorithm first sorts the points from left to right, and then builds the convex hull incrementally by adding one point after another from the sorted list. To do this, it must at least know about some point type, it should have some idea how to sort those points, and it must be able to evaluate the orientation of a triple of points. The signature of the Graham Scan algorithm in <span style="font-variant: small-caps;">CGAL</span> (actually a variation due to Andrews) is as follows:</p>
<p><a class="anchor" id="ch_grham_andrew"></a> </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> Traits&gt;</div><div class="line">            <a class="code" href="classOutputIterator.html">OutputIterator</a></div><div class="line">            <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#gaeccc6dda2f9d3096c94a7ff84cc91a85">ch_graham_andrew</a>( <a class="code" href="classInputIterator.html">InputIterator</a>  first,</div><div class="line">                              <a class="code" href="classInputIterator.html">InputIterator</a>  beyond,</div><div class="line">                              <a class="code" href="classOutputIterator.html">OutputIterator</a> result,</div><div class="line">                              <span class="keyword">const</span> Traits &amp; ch_traits);</div></div><!-- fragment --><p>You notice that there is a template parameter named <code>Traits</code>, and you also see a comment that mentions three identifiers (<code>Point_2</code>, <code>Left_turn_2</code> and <code>Less_xy_2</code>) that have to be defined in the scope of the traits class in order for the algorithm to work. As you can guess, <code>Left_turn_2</code> is responsible for the orientation test, while <code>Less_xy_2</code> does the sorting. So, obviously, the traits class must provide these three identifiers. The requirements it has to satisfy beyond that are documented in full with the concept <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/classConvexHullTraits__2.html">ConvexHullTraits_2</a>.</p>
<h2><a class="anchor" id="subsectraits_class_requirements"></a>
Traits class requirements</h2>
<p>Whenever you write a function or class that is parameterized with a traits class, you must provide the requirements that class has to fulfill. These requirements should be documented as a concept. For the example above, if you look in the manual at the description of the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/classConvexHullTraits__2.html">ConvexHullTraits_2</a></code>, you will find that the traits class itself and the identifiers that are mentioned have to meet the following specifications:</p>
<div class="fragment"><div class="line">concept <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/classConvexHullTraits__2.html">ConvexHullTraits_2</a> {</div><div class="line">    <span class="keyword">typename</span> Point_2;</div><div class="line">    <span class="keyword">typename</span> Left_xy_2;</div><div class="line">    <span class="keyword">typename</span> Left_turn_2;</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/classConvexHullTraits__2.html">ConvexHullTraits_2</a>(<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/classConvexHullTraits__2.html">ConvexHullTraits_2</a>&amp; t);</div><div class="line"></div><div class="line">    Less_xy_2 less_xy_2_object();</div><div class="line">    </div><div class="line">    Left_turn_2 left_turn_2_object();</div><div class="line">};</div></div><!-- fragment --><p>This ends the copied manual text. Some comments are in order here. You might have expected <code>Less_xy_2</code> and <code>Left_turn_2</code> to be simply member functions of the traits class. Instead, they are functor types, and there are member functions generating instances of these types, <em>i.e.</em>, the actual functors. Reasons for this are the following. </p><ul>
<li>
<em></em> <span style="font-variant: small-caps;">CGAL</span> is designed to have an <span style="font-variant: small-caps;">STL</span>-like look-and-feel. All algorithms in the <span style="font-variant: small-caps;">STL</span> that depend on computational primitives (like a sorting algorithm depending on a comparison operator), receive those primitives via parameters which are functors. (The only way to pass an actual function as a parameter would be via function pointers.) </li>
<li>
More flexibility. In contrast to member functions, functors can carry data. For example, repeated calls to a function with only slightly different parameters might be handled efficiently by storing intermediate results. Functors are the natural framework here. See <a class="el" href="citelist.html#CITEREF_hhkps-aegk-01">[5]</a> for more exposition. </li>
</ul>
<p>If you really look up the documentation of the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/classConvexHullTraits__2.html">concept</a> in the manual, you will find a larger list of requirements. A traits class fulfilling this complete list of requirements can be used for all of the 2-dimensional convex hull algorithms provided in <span style="font-variant: small-caps;">CGAL</span>. For example, there are also algorithms that require a sorting of points by angle, and a traits class for that algorithm has to supply appropriate predicates for that. Still, to use the Graham Scan, a traits class meeting only the specifications listed above is sufficient.</p>
<h2><a class="anchor" id="subseccgal_traits_classes"></a>
CGAL-provided traits classes</h2>
<p>As mentioned in Section <a class="el" href="devman_traits_classes.html#secwhat_is_a_traits_class">What are traits classes in CGAL?</a> , the traits class requirements define a concept. An actual traits class that complies with these requirements is a model for that concept. At least one such model must be provided for all <span style="font-variant: small-caps;">CGAL</span> algorithms. Often this is called the default traits class. Default traits classes are very easy to use, especially when they are invoked via default arguments. Look at the function <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#gaeccc6dda2f9d3096c94a7ff84cc91a85"><code>CGAL::ch_graham_andrew()</code> </a> again. The signature does not tell the whole story. In reality, the third template parameter defaults to the default traits class, and the last function parameter defaults to a default instance of the default traits class. Of course, such behavior must be specified in the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#gaeccc6dda2f9d3096c94a7ff84cc91a85">description of the function</a>.</p>
<p>The implication is that a user can call <code>ch_graham_andrews</code> with just three parameters, which delimit the iterator range to be handled and supply the iterator for the result. The types and primitives used by the algorithm in this case are the ones from the <span style="font-variant: small-caps;">CGAL</span> 2D and 3D kernel.</p>
<p>In many cases, there are more than one traits classes provided by <span style="font-variant: small-caps;">CGAL</span>. In the case of convex hulls, for example, there are traits classes that interface the algorithms with the geometry kernel of <span style="font-variant: small-caps;">LEDA</span>. Though the user who has a third-party geometric kernel will not be able to profit from the <span style="font-variant: small-caps;">CGAL</span> or <span style="font-variant: small-caps;">LEDA</span> traits, he or she can still provide own traits classes, which meet the specified requirements.</p>
<h1><a class="anchor" id="seckernel_traits"></a>
Kernel as traits</h1>
<p>Most default traits classes in <span style="font-variant: small-caps;">CGAL</span> are written in terms of the types and classes provided in the <span style="font-variant: small-caps;">CGAL</span> kernel. So one may wonder why it is not possible to plug the kernel in as a traits class directly. Ideally, it provides all the primitives an algorithm needs. However, some algorithms and data structures require specialized predicates that would not be appropriate to add to a general-purpose kernel. The traits classes for these algorithms and data structures should use kernel primitives wherever possible, and for those primitives not provided by the kernel the fixed naming scheme for predicates and constructions (Section <a class="el" href="devman_code_format.html#secnaming_scheme">Naming scheme</a> ) should be used to make the library more consistent and thus easier to use.</p>
<h1><a class="anchor" id="sectraits_class_req_and_rec"></a>
Requirements and recommendations</h1>
<p>This section condenses the previous material into a few guidelines you have to observe when you design a traits class yourself. </p><ul>
<li>
<p class="startli">Keep it small and simple. In particular, avoid redundant functionality in the traits class requirements. For example, if you require <code>Less_xy_2</code>, there is no reason to require <code>Greater_xy_2</code>, because the latter can be constructed from the former. In general, designing a good traits class requires a deep understanding of the algorithm it is made for. Finding the "right" set of geometric primitives required by the algorithm can be a nontrivial task. However, spending effort on that task decreases the effort needed later to implement traits classes and increases the ease of use of the algorithm.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Obey the naming conventions (Section <a class="el" href="devman_code_format.html#secnaming_scheme">Naming scheme</a> ).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Use functors instead of member functions for the predicates required. This is not only necessary for the kernel traits, it also gives the benefit of more flexibility. For each type you must provide a member function to get the actual functor and thus this seems to increase the size of the traits class. However, if you follow the naming scheme, the signatures of these functions are obvious and obtainable mechanically.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Provide at least one model (which should normally be the kernel traits class) for every traits concept.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Define and document a default traits class so the user need not provide a traits class argument if customization of the algorithm is not needed.</p>
<p class="endli"></p>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:49 for CGAL 4.13 - Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
