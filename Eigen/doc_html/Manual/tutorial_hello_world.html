<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Manual/tutorial_hello_world.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Manual: Hello World</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt="" /></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_hello_world.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Hello World </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Author</dt><dd>CGAL Editorial Board</dd></dl>
<p>This tutorial is for the CGAL newbie, who knows C++ and has a basic knowledge of geometric algorithms. The first section shows how to define a point and segment class, and how to apply geometric predicates on them. The section further raises the awareness that that there are serious issues when using floating point numbers for coordinates. In the second section you see how the 2D convex hull function gets its input and where it puts the result. The third section shows what we mean with a <em>Traits</em> class, and the fourth section explains the notion of <em>concept</em> and <em>model</em>.</p>
<h1><a class="anchor" id="intro_Three"></a>
Three Points and One Segment</h1>
<p>In this first example we see how to construct some points and a segment, and we perform some basic operations on them.</p>
<p>All <span style="font-variant: small-caps;">CGAL</span> header files are in the subdirectory <code>include/CGAL</code>. All <span style="font-variant: small-caps;">CGAL</span> classes and functions are in the namespace <code><a class="el" href="namespaceCGAL.html">CGAL</a></code>. Classes start with a capital letter, global function with a lowercase letter, and constants are all uppercase. The dimension of an object is expressed with a suffix.</p>
<p>The geometric primitives, like the point type, are defined in a <em>kernel</em>. The kernel we have chosen for this first example uses <code>double</code> precision floating point numbers for the Cartesian coordinates of the point.</p>
<p>Besides the types we see <em>predicates</em> like the orientation test for three points, and <em>constructions</em> like the distance and midpoint computation. A predicate has a discrete set of possible results, whereas a construction produces either a number, or another geometric entity.</p>
<p><br />
<b>File</b> <a class="el" href="Kernel_23_2points_and_segment_8cpp-example.html">Kernel_23/points_and_segment.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a> Segment_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Point_2 p(1,1), q(10,10);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"p = "</span> &lt;&lt; p &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"q = "</span> &lt;&lt; q.x() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; q.y() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"sqdist(p,q) = "</span> </div><div class="line">            &lt;&lt; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a>(p,q) &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  Segment_2 s(p,q);</div><div class="line">  Point_2 m(5, 9);</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"m = "</span> &lt;&lt; m &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"sqdist(Segment_2(p,q), m) = "</span></div><div class="line">            &lt;&lt; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a>(s,m) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"p, q, and m "</span>;</div><div class="line">  <span class="keywordflow">switch</span> (<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__orientation__grp.html#ga91d9866cfde916ba70e5dbc596176d9e">CGAL::orientation</a>(p,q,m)){</div><div class="line">  <span class="keywordflow">case</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga84f760a315c4f27cb4059db8a3a1159e">CGAL::COLLINEAR</a>: </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"are collinear\n"</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga803e5969acd01d45aec5acaee6f82883">CGAL::LEFT_TURN</a>:</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"make a left turn\n"</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga1f9d8cac74201e22d484b10384fe3bf9">CGAL::RIGHT_TURN</a>: </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"make a right turn\n"</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" midpoint(p,q) = "</span> &lt;&lt; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__midpoint__grp.html#ga6b9f14a470dfaacbfa833177762e4460">CGAL::midpoint</a>(p,q) &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>To do geometry with floating point numbers can be surprising as the next example shows.</p>
<p><br />
<b>File</b> <a class="el" href="Kernel_23_2surprising_8cpp-example.html">Kernel_23/surprising.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  {</div><div class="line">    Point_2 p(0, 0.3), q(1, 0.6), r(2, 0.9);</div><div class="line">    std::cout &lt;&lt; (<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);   </div><div class="line">  }</div><div class="line">  {</div><div class="line">    Point_2 p(0, 1.0/3.0), q(1, 2.0/3.0), r(2, 1);</div><div class="line">    std::cout &lt;&lt; (<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);   </div><div class="line">  }  </div><div class="line">  {</div><div class="line">    Point_2 p(0,0), q(1, 1), r(2, 2);</div><div class="line">    std::cout &lt;&lt; (<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);   </div><div class="line">  }  </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>When reading the code, we would assume that it prints three times "collinear". However we obtain:</p>
<pre class="fragment">not collinear
not collinear
collinear
</pre><p>As the fractions are not representable as double precision number the collinearity test will internally compute a determinant of a 3x3 matrix which is close but not equal to zero, and hence the non collinearity for the first two tests.</p>
<p>Something similar can happen with points that perform a left turn, but due to rounding errors during the determinant computation, it seems that the points are collinear, or perform a right turn.</p>
<p>If you need that the numbers get interpreted at their full precision you can use a <span style="font-variant: small-caps;">CGAL</span> kernel that performs exact predicates and extract constructions.</p>
<p><br />
<b>File</b> <a class="el" href="Kernel_23_2exact_8cpp-example.html">Kernel_23/exact.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Point_2 p(0, 0.3), q, r(2, 0.9);</div><div class="line">  {</div><div class="line">    q  = Point_2(1, 0.6);</div><div class="line">    std::cout &lt;&lt; (<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);</div><div class="line">  }</div><div class="line">  </div><div class="line">  {</div><div class="line">    std::istringstream input(<span class="stringliteral">"0 0.3   1 0.6   2 0.9"</span>);</div><div class="line">    input &gt;&gt; p &gt;&gt; q &gt;&gt; r;</div><div class="line">    std::cout &lt;&lt; (<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);</div><div class="line">  }</div><div class="line">  </div><div class="line">  {</div><div class="line">    q = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__midpoint__grp.html#ga6b9f14a470dfaacbfa833177762e4460">CGAL::midpoint</a>(p,r);</div><div class="line">    std::cout &lt;&lt; (<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);   </div><div class="line">  }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Here comes the output and you may still be surprised.</p>
<pre class="fragment">not collinear
collinear
collinear
</pre><p>In the first block the points are still not collinear, for the simple reason that the coordinates you see as text get turned into floating point numbers. When they are then turned into arbitrary precision rationals, they exactly represent the floating point number, but not the text.</p>
<p>This is different in the second block, which corresponds to reading numbers from a file. The arbitrary precision rationals are then directly constructed from a string so that they represent exactly the text.</p>
<p>In the third block you see that constructions as midpoint constructions are exact, just as the name of the kernel type suggests.</p>
<p>In many cases you will have floating point numbers that are "exact", in the sense that they were computed by some application or obtained from a sensor. They are not the string "0.1" or computed on the fly as "1.0/10.0", but a full precision floating point number. If they are input to an algorithm that makes no constructions you can use a kernel that provides exact predicates, but inexact constructions. An example for that is the convex hull algorithm which we will see in the next section. The output is a subset of the input, and the algorithm only compares coordinates and performs orientation tests.</p>
<p>At a first glance the kernel doing exact predicates and constructions seems to be the perfect choice, but performance requirements or limited memory resources make that it is not. Also for many algorithms it is irrelevant to do exact constructions. For example a surface mesh simplification algorithm that iteratively contracts an edge, by collapsing it to the midpoint of the edge.</p>
<p>Most <span style="font-variant: small-caps;">CGAL</span> packages explain what kind of kernel they need or support.</p>
<h1><a class="anchor" id="intro_convex_hull"></a>
The Convex Hull of a Sequence of Points</h1>
<p>All examples in this section compute the 2D convex hull of a set of points. We show that algorithms get their input as a begin/end iterator pair denoting a range of points, and that they write the result, in the example the points on the convex hull, into an output iterator.</p>
<h2><a class="anchor" id="intro_array"></a>
The Convex Hull of Points in a Built-in Array</h2>
<p>In the first example we have as input an array of five points. As the convex hull of these points is a subset of the input it is safe to provide an array for storing the result which has the same size.</p>
<p><br />
<b>File</b> <a class="el" href="Convex_hull_2_2array_convex_hull_2_8cpp-example.html">Convex_hull_2/array_convex_hull_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/convex_hull_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2 Point_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Point_2 points[5] = { Point_2(0,0), Point_2(10,0), Point_2(10,10), Point_2(6,5), Point_2(4,1) };</div><div class="line">  Point_2 result[5];</div><div class="line"></div><div class="line">  Point_2 *ptr = <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">CGAL::convex_hull_2</a>( points, points+5, result );</div><div class="line">  std::cout &lt;&lt;  ptr - result &lt;&lt; <span class="stringliteral">" points on the convex hull:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; ptr - result; i++){</div><div class="line">    std::cout &lt;&lt; result[i] &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>We saw in the previous section that <span style="font-variant: small-caps;">CGAL</span> comes with several kernels. As the convex hull algorithm only makes comparisons of coordinates and orientation tests of input points, we can choose a kernel that provides exact predicates, but no exact geometric constructions.</p>
<p>The convex hull function takes three arguments, the start and past-the-end pointer for the input, and the start pointer of the array for the result. The function returns the pointer into the result array just behind the last convex hull point written, so the pointer difference tells us how many points are on the convex hull.</p>
<h2><a class="anchor" id="intro_vector"></a>
The Convex Hull of Points in a Vector</h2>
<p>In the second example we replace the built-in array by a <code>std::vector</code> of the Standard Template Library.</p>
<p><br />
<b>File</b> <a class="el" href="Convex_hull_2_2vector_convex_hull_2_8cpp-example.html">Convex_hull_2/vector_convex_hull_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/convex_hull_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2 Point_2;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_2&gt; Points;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Points points, result;</div><div class="line">  points.push_back(Point_2(0,0));</div><div class="line">  points.push_back(Point_2(10,0));</div><div class="line">  points.push_back(Point_2(10,10));</div><div class="line">  points.push_back(Point_2(6,5));</div><div class="line">  points.push_back(Point_2(4,1));</div><div class="line"></div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">CGAL::convex_hull_2</a>( points.begin(), points.end(), std::back_inserter(result) );</div><div class="line">  std::cout &lt;&lt; result.size() &lt;&lt; <span class="stringliteral">" points on the convex hull"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>We put some points in the vector calling the <code>push_back()</code> method of the <code>std::vector</code> class.</p>
<p>We then call the convex hull function. The first two arguments, <code>points.begin()</code> and <code>points.end()</code> are <em>iterators</em>, which are a generalization of pointers: they can be dereferenced and incremented. The convex hull function is <em>generic</em> in the sense that it takes as input whatever can be dereferenced and incremented.</p>
<p>The third argument is where the result gets written to. In the previous example we provided a pointer to allocated memory. The generalization of such a pointer is the <em>output iterator</em>, which allows to increment and assign a value to the dereferenced iterator. In this example we start with an empty vector which grows as needed. Therefore, we cannot simply pass it <code>result.begin()</code>, but an output iterator generated by the helper function <code>std::back_inserter(result)</code>. This output iterator does nothing when incremented, and calls <code>result.push_back(..)</code> on the assignment.</p>
<p>If you know the <span style="font-variant: small-caps;">STL</span>, the Standard Template Library, the above makes perfect sense, as this is the way the <span style="font-variant: small-caps;">STL</span> decouples algorithms from containers. If you don't know the <span style="font-variant: small-caps;">STL</span>, you maybe better first familiarize yourself with its basic ideas.</p>
<h1><a class="anchor" id="intro_traits"></a>
About Kernels and Traits Classes</h1>
<p>In this section we show how we express the requirements that must be fulfilled in order that a function like <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">convex_hull_2()</a></code> can be used with an arbitrary point type.</p>
<p>If you look at the manual page of the function <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">convex_hull_2()</a></code> and the other 2D convex hull algorithms, you see that they come in two versions. In the examples we have seen so far the function that takes two iterators for the range of input points and an output iterator for writing the result to. The second version has an additional template parameter <code>Traits</code>, and an additional parameter of this type.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator , <span class="keyword">class</span> OutputIterator , <span class="keyword">class</span> Traits &gt;</div><div class="line"><a class="code" href="classOutputIterator.html">OutputIterator</a> </div><div class="line"><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">convex_hull_2</a>(<a class="code" href="classInputIterator.html">InputIterator</a> first,</div><div class="line">              <a class="code" href="classInputIterator.html">InputIterator</a> beyond,</div><div class="line">              <a class="code" href="classOutputIterator.html">OutputIterator</a> result,</div><div class="line">              <span class="keyword">const</span> Traits &amp; ch_traits)</div></div><!-- fragment --><p>What are the geometric primitives a typical convex hull algorithm uses? Of course, this depends on the algorithm, so let us consider what is probably the simplest efficient algorithm, the so-called "Graham/Andrew Scan". This algorithm first sorts the points from left to right, and then builds the convex hull incrementally by adding one point after another from the sorted list. To do this, it must at least know about some point type, it should have some idea how to sort those points, and it must be able to evaluate the orientation of a triple of points.</p>
<p>And that is where the template parameter <code>Traits</code> comes in. For <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#gaeccc6dda2f9d3096c94a7ff84cc91a85">ch_graham_andrew()</a></code> it must provide the following nested types:</p>
<ul>
<li><code>Traits::Point_2</code></li>
<li><code>Traits::Less_xy_2</code></li>
<li><code>Traits::Left_turn_2</code></li>
<li><code>Traits::Equal_2</code></li>
</ul>
<p>As you can guess, <code>Left_turn_2</code> is responsible for the orientation test, while <code>Less_xy_2</code> is used for sorting the points. The requirements these types have to satisfy are documented in full with the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/classConvexHullTraits__2.html">ConvexHullTraits_2</a></code>.</p>
<p>The types are regrouped for a simple reason. The alternative would have been a rather lengthy function template, and an even longer function call.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> Po<span class="keywordtype">int</span>_2, <span class="keyword">class</span> Less_xy_2, <span class="keyword">class</span> Left_turn_2, <span class="keyword">class</span> Equal_2&gt;</div><div class="line"><a class="code" href="classOutputIterator.html">OutputIterator</a></div><div class="line"><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#gaeccc6dda2f9d3096c94a7ff84cc91a85">ch_graham_andrew</a>( <a class="code" href="classInputIterator.html">InputIterator</a>  first,</div><div class="line">                  <a class="code" href="classInputIterator.html">InputIterator</a>  beyond,</div><div class="line">                  <a class="code" href="classOutputIterator.html">OutputIterator</a> result);</div></div><!-- fragment --><p>There are two obvious questions: What can be used as argument for this template parameter? And why do we have template parameters at all?</p>
<p>To answer the first question, any model of the CGAL concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> provides what is required by the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/classConvexHullTraits__2.html">ConvexHullTraits_2</a></code>.</p>
<p>As for the second question, think about an application where we want to compute the convex hull of 3D points projected into the <code>yz</code> plane. Using the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__yz__3.html">Projection_traits_yz_3</a></code> this is a small modification of the previous example.</p>
<p><br />
<b>File</b> <a class="el" href="Convex_hull_2_2convex_hull_yz_8cpp-example.html">Convex_hull_2/convex_hull_yz.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_traits_yz_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/convex_hull_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__yz__3.html">CGAL::Projection_traits_yz_3&lt;K3&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2 Point_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::istream_iterator&lt; Point_2 &gt;  input_begin( std::cin );</div><div class="line">  std::istream_iterator&lt; Point_2 &gt;  input_end;</div><div class="line">  std::ostream_iterator&lt; Point_2 &gt;  output( std::cout, <span class="stringliteral">"\n"</span> );</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">CGAL::convex_hull_2</a>( input_begin, input_end, output, K() );</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Another example would be about a user defined point type, or a point type coming from a third party library other than CGAL. Put the point type together with the required predicates for this point type in the scope of a class, and you can run <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Convex_hull_2.tag:../Convex_hull_2/" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">convex_hull_2()</a></code> with these points.</p>
<p>Finally, let us explain why a traits object that is passed to the convex hull function? It would allow to use a more general projection traits object to store state, for example if the projection plane was given by a direction, which is hardwired in the class <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__yz__3.html">Projection_traits_yz_3</a></code>.</p>
<h1><a class="anchor" id="intro_concept"></a>
Concepts and Models</h1>
<p>In the previous section we wrote that "Any model of the CGAL concept
Kernel provides what is required by the concept ConvexHullTraits_2".</p>
<p>A <em>concept</em> is a set of requirements on a type, namely that it has certain nested types, certain member functions, or comes with certain free functions that take the type as it. A <em>model</em> of a concept is a class that fulfills the requirements of the concept.</p>
<p>Let's have a look at the following function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T</div><div class="line">duplicate(T t)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> t;</div><div class="line">}</div></div><!-- fragment --><p>If you want to instantiate this function with a class <code>C</code> this class must at least provide a copy constructor, and we say that class <code>C</code> must be a model of <code><a class="el" href="classCopyConstructible.html" title="Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/CopyConstructible. ">CopyConstructible</a></code>. A singleton class does not fulfill this requirment.</p>
<p>Another example is the function</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </div><div class="line">T&amp; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gab0ad1dbf97e8a81da183514138f583e6">std::min</a>(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (a&lt;b)?a:b;</div><div class="line">} </div></div><!-- fragment --><p>This function only compiles if the <code>operator&lt;(..)</code> is defined for the type used as <code>T</code>, and we say that the type must be a model of <code><a class="el" href="classLessThanComparable.html" title="Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/LessThanComparable. ">LessThanComparable</a></code>.</p>
<p>An example for a concept with required free functions is the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classHalfedgeListGraph.html">HalfedgeListGraph</a></code> in the <span style="font-variant: small-caps;">CGAL</span> package <a class="el" href="packages.html#PkgBGLSummary">CGAL and the Boost Graph Library</a>. In order to be a model of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classHalfedgeListGraph.html">HalfedgeListGraph</a></code> a class <code>G</code> there must be a global function <code>halfedges(const G&amp;)</code>, etc.</p>
<p>An example for a concept with a required traits class is <code><a class="el" href="classInputIterator.html" title="Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/InputIterator. ">InputIterator</a></code>. For a model of an <code><a class="el" href="classInputIterator.html" title="Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/InputIterator. ">InputIterator</a></code> a specialization of the class <a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><code>std::iterator_traits</code></a> must exist (or the generic template must be applicable).</p>
<h1><a class="anchor" id="intro_further"></a>
Further Reading</h1>
<p>We also recommend the standard text books "The C++ Standard Library, A
Tutorial and Reference" by Nicolai M. Josuttis from Addison-Wesley, or "Generic Programming and the STL" by Matthew H. Austern for the <span style="font-variant: small-caps;">STL</span> and its notion of <em>concepts</em> and <em>models</em>.</p>
<p>Other resources for <span style="font-variant: small-caps;">CGAL</span> are the rest of the <a class="el" href="tutorials.html">tutorials</a> and the user support page at <a href="https://www.cgal.org/">https://www.cgal.org/</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:49 for CGAL 4.13 - Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
