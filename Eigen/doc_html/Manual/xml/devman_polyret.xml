<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="devman_polyret" kind="page">
    <compoundname>devman_polyret</compoundname>
    <title>Polymorphic Return Types</title>
    <detaileddescription>
<para><simplesect kind="author"><para>Stefan Schirra (<computeroutput><ulink url="mailto:stschirr@mpi-sb.mpg.de">stschirr@mpi-sb.mpg.de</ulink></computeroutput>)</para></simplesect>
For some geometric operations, the type of the result of the operation is not fixed a priori, but depends on the input. Intersection computation is a prime example. The standard object-oriented approach to this is defining a common base class for all possible result types and returning a reference or a pointer to an object of the result type by a reference or pointer to the base class. Then all the virtual member functions in the interface of the base class can be applied to the result object and the implementation corresponding to the actual result type is called. It is hard to define appropriate base class interface functions (besides <computeroutput><ref refid="group__PkgDrawPolyhedron_1ga3ca458ed11c9fb052476b00227d93584" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">draw()</ref></computeroutput>).</para><para>CGAL has chosen a different approach, since CGAL wants to avoid large class hierarchies. With the CGAL class <computeroutput>Object</computeroutput>, you can fake a common base class, see <ref refid="devman_polyret_1fig__FigObject" kindref="member">fig__FigObject</ref>.</para><para><anchor id="devman_polyret_1fig__FigObject"/><image type="html" name="Object.png"></image>
 <image type="latex" name="Object.png" width="15cm"></image>
  <ref refid="devman_polyret_1fig__FigObject" kindref="member">fig__FigObject</ref> UML class diagram for faked object hierarchies (since 2.2-I-4).  <linebreak/>
</para><para>Functions having a polymorphic return type create an object of the actual result type and wrap it into an object of type <computeroutput>Object</computeroutput>. Refer to the documentation of <computeroutput><ref refid="classCGAL_1_1Object" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Object</ref></computeroutput> class for more details.</para><para>An alternative is to use a class handling several output iterators at the same time such as the classes <computeroutput><ref refid="classCGAL_1_1Dispatch__output__iterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Dispatch_output_iterator</ref></computeroutput>. and <computeroutput><ref refid="classCGAL_1_1Dispatch__or__drop__output__iterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Dispatch_or_drop_output_iterator</ref></computeroutput>. </para>    </detaileddescription>
  </compounddef>
</doxygen>
