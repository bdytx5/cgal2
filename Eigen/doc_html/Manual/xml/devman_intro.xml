<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="devman_intro" kind="page">
    <compoundname>devman_intro</compoundname>
    <title>Introduction</title>
    <detaileddescription>
<para><simplesect kind="author"><para>Susan Hert </para></simplesect>
<simplesect kind="author"><para>Menelaos Karavelas (<computeroutput><ulink url="mailto:mkaravel@tem.uoc.gr">mkaravel@tem.uoc.gr</ulink></computeroutput>) </para></simplesect>
<simplesect kind="author"><para>Stefan Schirra</para></simplesect>
<center> <image type="html" name="cgal_small.png"></image>
 <image type="latex" name="cgal_small.png"></image>
 </center> <center>Computational Geometry Algorithms Library</center></para><para><blockquote><para><emphasis>The goal of the CGAL Open Source Project is to provide easy access to efficient and reliable geometric algorithms in the form of a C++ library. CGAL is used in various areas needing geometric computation, such as: computer graphics, scientific visualization, computer aided design and modeling, geographic information systems, molecular biology, medical imaging, robotics and motion planning, mesh generation, numerical methods... </emphasis> </para></blockquote></para><para>Work on CGAL has been supported in the past by esprit iv projects 21957 (<ref refid="namespaceCGAL" kindref="compound">CGAL</ref>) and 28155 (GALIA).</para><sect1 id="devman_intro_1secdesign_goals">
<title>Primary design goals</title>
<para>The primary design goals of CGAL are described in <ref refid="citelist_1CITEREF_fgkss-dccga-00" kindref="member">[4]</ref></para><sect2 id="devman_intro_1Developer_manualCorrectness">
<title>Correctness</title>
<para>A library component is correct if it behaves according to its specification. Basically, correctness is therefore a matter of verification that documentation and implementation coincide. In a modularized program the correctness of a module is determined by its own correctness and the correctness of all the modules it depends on. Clearly, in order to get correct results, correct algorithms and data structures must be used.</para><para>Exactness should not be confused with correctness in the sense of reliability. There is nothing wrong with algorithms computing approximate solutions instead of exact solutions, as long as their behavior is clearly documented and they do behave as specified. Also, an algorithm handling only non-degenerate cases can be correct with respect to its specification, although in CGAL we would like to provide algorithms handling degeneracies.</para></sect2>
<sect2 id="devman_intro_1Developer_manualRobustness">
<title>Robustness</title>
<para>A design goal particularly relevant for the implementation of geometric algorithms is robustness. Many implementations of geometric algorithms lack robustness because of precision problems; see Chapter <ref refid="devman_robustness" kindref="compound">Robustness Issues</ref> for a discussion of robustness issues within CGAL.</para></sect2>
<sect2 id="devman_intro_1Developer_manualFlexibility">
<title>Flexibility</title>
<para>The different needs of the potential application areas demand flexibility in the library. Four sub-issues of flexibility can be identified.</para><para><bold>Modularity.</bold></para><para>A clear structuring of CGAL into modules with as few dependencies as possible helps a user in learning and using CGAL, since the overall structure can be grasped more easily and the focus can be narrowed to those modules that are actually of interest.</para><para><bold>Adaptability.</bold></para><para>CGAL might be used in an already established environment with geometric classes and algorithms in which case the modules will most probably need adaptation before they can be used.</para><para><bold>Extensibility.</bold></para><para>Not all wishes can be fulfilled with CGAL. Users may want to extend the library. It should be possible, and in fact desirable, to integrate new classes and algorithms into CGAL.</para><para><bold>Openness.</bold></para><para>CGAL should be open to coexist with other libraries, or better, to work together with other libraries and programs. The C++ Standard <ref refid="citelist_1CITEREF_cgal:ansi-is14882-98" kindref="member">[3]</ref></para><para>defines with the C++ Standard Library a common foundation for all C++ platforms. So it is easy and natural to gain openness by following this standard. There are important libraries outside the standard, and CGAL should be easily adaptable to them as well.</para></sect2>
<sect2 id="devman_intro_1Developer_manualEaseofUse">
<title>Ease of Use</title>
<para>Many different qualities can contribute to the ease of use of a library. Which qualities are most important differs according to the experience of the user. The above-mentioned correctness and robustness issues are among these qualities. Of general importance is the length of time required before the library becomes useful. Another issue is the number of new concepts and exceptions to general rules that must be learned and remembered.</para><para>Ease of use tends to conflict with flexibility, but in many situations a solution can be found. The flexibility of CGAL should not distract a novice who takes the first steps with CGAL.</para><para><bold>Uniformity.</bold></para><para>A uniform look and feel of the design in CGAL will help in learning and memorizing. A concept once learned should be applicable in all places where one would wish to apply it. A function name once learned for a specific class should not be named differently for another class.</para><para>CGAL is based in many places on concepts borrowed from STL (Standard Template Library) or the other parts of the C++ Standard Library. An example is the use of streams and stream operators in CGAL. Another example is the use of container classes and algorithms from the STL. So these concepts should be used uniformly.</para><para>During the past few years, CGAL has moved towards using on concepts and ideas from the boost libraries, as well as providing interfaces towards boost libraries. These include the boost graph library and the boost property maps library.</para><para><bold>Complete and Minimal Interfaces.</bold></para><para>A goal with similar implications as uniformity is a design with complete and minimal interfaces, see for example Item 18 in Ref. <ref refid="citelist_1CITEREF_cgal:m-ec-97" kindref="member">[7]</ref>. An object or module should be complete in its functionality, but should not provide additional decorating functionality. Even if a certain function might look like it contributes to the ease of use for a certain class, in a more global picture it might hinder the understanding of similarities and differences among classes, and make it harder to learn and memorize.</para><para><bold>Rich and Complete Functionality.</bold></para><para>We aim for a useful and rich collection of geometric classes, data structures and algorithms. CGAL is supposed to be a foundation for algorithmic research in computational geometry and therefore needs a certain breadth and depth. The standard techniques in the field are supposed to appear in CGAL.</para><para>Completeness is also related to robustness.</para><para>We aim for general-purpose solutions that are, for example, not restricted by assumptions on general positions. Algorithms in CGAL should be able to handle special cases and degeneracies.</para><para>In those cases where handling of degeneracies turns out to be inefficient, special variants that are more efficient but less general should be provided in the library in addition to the general algorithms handling all degeneracies. Of course, it needs to be clearly documented which degeneracies are handled and which are not.</para></sect2>
<sect2 id="devman_intro_1Developer_manualEfficiency">
<title>Efficiency</title>
<para>For most geometric algorithms theoretical results for the time and space complexity are known. Also, the theoretic interest in efficiency for realistic inputs, as opposed to worst-case situations, is growing <ref refid="citelist_1CITEREF_v-ffrim-97" kindref="member">[11]</ref>. For practical purposes, insight into the constant factors hidden in the <formula id="4">$ O$</formula>-notation is necessary, especially if there are several competing algorithms.</para><para>Therefore, different implementations should be supplied if there is not one best solution, as, for example, when there is a tradeoff between time and space or a more efficient implementation when there are no or few degeneracies.</para></sect2>
</sect1>
<sect1 id="devman_intro_1secoverall_design">
<title>The overall design</title>
<para>The design goals, especially flexibility and efficient robust computation, have led us to opt for the generic programming paradigm using templates in C++.In appropriate places, however, CGAL does and should make use of object-oriented solutions and design patterns, as well. In the overall design of CGAL three major layers can be identified, the layer of algorithms and data structures, the kernel layer and the arithmetic and algebra layer. (<ref refid="devman_intro_1fig__figgenericCGAL" kindref="member">fig__figgenericCGAL</ref> ).</para><para><anchor id="devman_intro_1fig__figgenericCGAL"/><image type="html" name="generic_cgal.png"></image>
 <image type="latex" name="generic_cgal.png" width="15cm"></image>
  <ref refid="devman_intro_1fig__figgenericCGAL" kindref="member">fig__figgenericCGAL</ref> The generic design of CGAL.  <linebreak/>
</para><para>Algorithms and data structures in CGAL are parameterized by the types of objects and operations they use. They work with any concrete template arguments that fulfill certain syntactical as well as semantic requirements. In order to avoid long parameter lists, the parameter types are collected into a single class, called the traits class in CGAL (Chapter <ref refid="devman_traits_classes" kindref="compound">Traits Classes</ref> ). A <emphasis>concept</emphasis> is an abstraction of a type defined by a set of requirements. Any concrete type is called a <emphasis>model</emphasis> for a concept if it fulfills the set of requirements corresponding to the concept. Using this terminology, we can say a CGAL algorithm or data structure comes with a traits concept and can be used with any concrete traits model for this concept. Further contributions to CGAL should continue the current high level of genericity.</para><para>CGAL defines the concept of a geometry kernel. Ideally, any model for this concept can be used with any CGAL algorithm. This holds, of course, only if the requirements of an algorithm or data structure on its traits class are subsumed by the kernel concepts, <emphasis>i.e.</emphasis>, if an algorithm or data structure has no special requirements not covered in the definition of the kernel concept. Currently, CGAL offers a concept for a fundamental geometry kernel, that defines various geometric objects such as points, line segments, lines, circles, and operations on them, as well as two additional concepts, the circular and the spherical kernel. The goal of the last two kernels is to specify a large set of functionalities on circles and circular arcs on the plane (circular kernel), and analogous functionalities for circles, circular arcs living on a 3D sphere (spherical kernel).</para><para>CGAL currently provides several models for the CGAL 2D and 3D kernel concept, and one model for the 2D circular and the 3D spherical kernel concepts.. Those are again parameterized and differ in their representation of the geometric objects and the exchangeability of the types involved. In the first four cases the kernels are parameterized by a number type, which is used to store coordinates and which determines the basic arithmetic of the kernel primitives.</para><para>In the last two cases, the circular and spherical kernel are also parametrized by Algebraic Kernels, which, along with Algebraic Foundations, is the third distinct high level of genericity in CGAL. The algebraic foundations in CGAL is a collection of concepts representing algebraic structures, and are motivated by well-known counterparts in traditional algebra. The algebraic foundations determine the operations per algebraic structure, their properties (e.g., whether they are supposed to be exact or approximate), as well as interoperability between them. An algebraic kernel is responsible for providing an abstraction for the algebraic operations required by either geometry kernels or traits classes used in CGAL algorithms. The goal is to be able to construct, compare and perform operations on real roots of polynomial equations. There are different concepts depending on the number of variables of the polynomials used to determine the roots (currently there are concepts for univariate and bivariate algebraic kernel), as well as specialized concepts targeted towards specific geometric higher level layers of the library (such as the circular and spherical kernels). These concepts are accompanied by at least one model per concept.</para><para>There are further complementary layers in CGAL. The most basic layer is the configuration layer. This layer takes care of setting configuration flags according to the outcome of tests run during installation. The <emphasis>support library</emphasis> layer is documented in the <ref refid="packages_1PartSupportLibrary" kindref="member">Support Library Manual </ref> and contains packages that deal with things such as visualization, number types, streams, and STL extensions in CGAL. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
