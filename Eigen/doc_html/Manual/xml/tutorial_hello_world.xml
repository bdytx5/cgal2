<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="tutorial_hello_world" kind="page">
    <compoundname>tutorial_hello_world</compoundname>
    <title>Hello World</title>
    <detaileddescription>
<para></para><para><simplesect kind="author"><para>CGAL Editorial Board</para></simplesect>
This tutorial is for the CGAL newbie, who knows C++ and has a basic knowledge of geometric algorithms. The first section shows how to define a point and segment class, and how to apply geometric predicates on them. The section further raises the awareness that that there are serious issues when using floating point numbers for coordinates. In the second section you see how the 2D convex hull function gets its input and where it puts the result. The third section shows what we mean with a <emphasis>Traits</emphasis> class, and the fourth section explains the notion of <emphasis>concept</emphasis> and <emphasis>model</emphasis>.</para><sect1 id="tutorial_hello_world_1intro_Three">
<title>Three Points and One Segment</title>
<para>In this first example we see how to construct some points and a segment, and we perform some basic operations on them.</para><para>All CGAL header files are in the subdirectory <computeroutput>include/CGAL</computeroutput>. All CGAL classes and functions are in the namespace <computeroutput><ref refid="namespaceCGAL" kindref="compound">CGAL</ref></computeroutput>. Classes start with a capital letter, global function with a lowercase letter, and constants are all uppercase. The dimension of an object is expressed with a suffix.</para><para>The geometric primitives, like the point type, are defined in a <emphasis>kernel</emphasis>. The kernel we have chosen for this first example uses <computeroutput>double</computeroutput> precision floating point numbers for the Cartesian coordinates of the point.</para><para>Besides the types we see <emphasis>predicates</emphasis> like the orientation test for three points, and <emphasis>constructions</emphasis> like the distance and midpoint computation. A predicate has a discrete set of possible results, whereas a construction produces either a number, or another geometric entity.</para><para><linebreak/>
<bold>File</bold> <ref refid="Kernel_23_2points_and_segment_8cpp-example" kindref="compound">Kernel_23/points_and_segment.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref><sp/>Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>p(1,1),<sp/>q(10,10);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;p<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;q<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>q.x()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>q.y()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;sqdist(p,q)<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__squared__distance__grp_1ga1ff73525660a052564d33fbdd61a4f71" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::squared_distance</ref>(p,q)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment_2<sp/>s(p,q);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>m(5,<sp/>9);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;m<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>m<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;sqdist(Segment_2(p,q),<sp/>m)<sp/>=<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__squared__distance__grp_1ga1ff73525660a052564d33fbdd61a4f71" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::squared_distance</ref>(s,m)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;p,<sp/>q,<sp/>and<sp/>m<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(<ref refid="group__orientation__grp_1ga91d9866cfde916ba70e5dbc596176d9e" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::orientation</ref>(p,q,m)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__kernel__enums_1ga84f760a315c4f27cb4059db8a3a1159e" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::COLLINEAR</ref>:<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;are<sp/>collinear\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__kernel__enums_1ga803e5969acd01d45aec5acaee6f82883" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::LEFT_TURN</ref>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;make<sp/>a<sp/>left<sp/>turn\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__kernel__enums_1ga1f9d8cac74201e22d484b10384fe3bf9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::RIGHT_TURN</ref>:<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;make<sp/>a<sp/>right<sp/>turn\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>midpoint(p,q)<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__midpoint__grp_1ga6b9f14a470dfaacbfa833177762e4460" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::midpoint</ref>(p,q)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>To do geometry with floating point numbers can be surprising as the next example shows.</para><para><linebreak/>
<bold>File</bold> <ref refid="Kernel_23_2surprising_8cpp-example" kindref="compound">Kernel_23/surprising.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>p(0,<sp/>0.3),<sp/>q(1,<sp/>0.6),<sp/>r(2,<sp/>0.9);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>(<ref refid="group__collinear__grp_1gadaa777c7b2f72b4321fe1ac3893efc3b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::collinear</ref>(p,q,r)<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;collinear\n&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;not<sp/>collinear\n&quot;</highlight><highlight class="normal">);<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>p(0,<sp/>1.0/3.0),<sp/>q(1,<sp/>2.0/3.0),<sp/>r(2,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>(<ref refid="group__collinear__grp_1gadaa777c7b2f72b4321fe1ac3893efc3b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::collinear</ref>(p,q,r)<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;collinear\n&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;not<sp/>collinear\n&quot;</highlight><highlight class="normal">);<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>p(0,0),<sp/>q(1,<sp/>1),<sp/>r(2,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>(<ref refid="group__collinear__grp_1gadaa777c7b2f72b4321fe1ac3893efc3b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::collinear</ref>(p,q,r)<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;collinear\n&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;not<sp/>collinear\n&quot;</highlight><highlight class="normal">);<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>When reading the code, we would assume that it prints three times &quot;collinear&quot;. However we obtain:</para><para><verbatim>not collinear
not collinear
collinear
</verbatim></para><para>As the fractions are not representable as double precision number the collinearity test will internally compute a determinant of a 3x3 matrix which is close but not equal to zero, and hence the non collinearity for the first two tests.</para><para>Something similar can happen with points that perform a left turn, but due to rounding errors during the determinant computation, it seems that the points are collinear, or perform a right turn.</para><para>If you need that the numbers get interpreted at their full precision you can use a CGAL kernel that performs exact predicates and extract constructions.</para><para><linebreak/>
<bold>File</bold> <ref refid="Kernel_23_2exact_8cpp-example" kindref="compound">Kernel_23/exact.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;sstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>p(0,<sp/>0.3),<sp/>q,<sp/>r(2,<sp/>0.9);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>q<sp/><sp/>=<sp/>Point_2(1,<sp/>0.6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>(<ref refid="group__collinear__grp_1gadaa777c7b2f72b4321fe1ac3893efc3b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::collinear</ref>(p,q,r)<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;collinear\n&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;not<sp/>collinear\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::istringstream<sp/>input(</highlight><highlight class="stringliteral">&quot;0<sp/>0.3<sp/><sp/><sp/>1<sp/>0.6<sp/><sp/><sp/>2<sp/>0.9&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>input<sp/>&gt;&gt;<sp/>p<sp/>&gt;&gt;<sp/>q<sp/>&gt;&gt;<sp/>r;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>(<ref refid="group__collinear__grp_1gadaa777c7b2f72b4321fe1ac3893efc3b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::collinear</ref>(p,q,r)<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;collinear\n&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;not<sp/>collinear\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>q<sp/>=<sp/><ref refid="group__midpoint__grp_1ga6b9f14a470dfaacbfa833177762e4460" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::midpoint</ref>(p,r);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>(<ref refid="group__collinear__grp_1gadaa777c7b2f72b4321fe1ac3893efc3b" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::collinear</ref>(p,q,r)<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;collinear\n&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;not<sp/>collinear\n&quot;</highlight><highlight class="normal">);<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Here comes the output and you may still be surprised.</para><para><verbatim>not collinear
collinear
collinear
</verbatim></para><para>In the first block the points are still not collinear, for the simple reason that the coordinates you see as text get turned into floating point numbers. When they are then turned into arbitrary precision rationals, they exactly represent the floating point number, but not the text.</para><para>This is different in the second block, which corresponds to reading numbers from a file. The arbitrary precision rationals are then directly constructed from a string so that they represent exactly the text.</para><para>In the third block you see that constructions as midpoint constructions are exact, just as the name of the kernel type suggests.</para><para>In many cases you will have floating point numbers that are &quot;exact&quot;, in the sense that they were computed by some application or obtained from a sensor. They are not the string &quot;0.1&quot; or computed on the fly as &quot;1.0/10.0&quot;, but a full precision floating point number. If they are input to an algorithm that makes no constructions you can use a kernel that provides exact predicates, but inexact constructions. An example for that is the convex hull algorithm which we will see in the next section. The output is a subset of the input, and the algorithm only compares coordinates and performs orientation tests.</para><para>At a first glance the kernel doing exact predicates and constructions seems to be the perfect choice, but performance requirements or limited memory resources make that it is not. Also for many algorithms it is irrelevant to do exact constructions. For example a surface mesh simplification algorithm that iteratively contracts an edge, by collapsing it to the midpoint of the edge.</para><para>Most CGAL packages explain what kind of kernel they need or support.</para></sect1>
<sect1 id="tutorial_hello_world_1intro_convex_hull">
<title>The Convex Hull of a Sequence of Points</title>
<para>All examples in this section compute the 2D convex hull of a set of points. We show that algorithms get their input as a begin/end iterator pair denoting a range of points, and that they write the result, in the example the points on the convex hull, into an output iterator.</para><sect2 id="tutorial_hello_world_1intro_array">
<title>The Convex Hull of Points in a Built-in Array</title>
<para>In the first example we have as input an array of five points. As the convex hull of these points is a subset of the input it is safe to provide an array for storing the result which has the same size.</para><para><linebreak/>
<bold>File</bold> <ref refid="Convex_hull_2_2array_convex_hull_2_8cpp-example" kindref="compound">Convex_hull_2/array_convex_hull_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/convex_hull_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>points[5]<sp/>=<sp/>{<sp/>Point_2(0,0),<sp/>Point_2(10,0),<sp/>Point_2(10,10),<sp/>Point_2(6,5),<sp/>Point_2(4,1)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>result[5];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_2<sp/>*ptr<sp/>=<sp/><ref refid="group__PkgConvexHull2Functions_1ga8241d43969ff61cb9be46811c2e9e176" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">CGAL::convex_hull_2</ref>(<sp/>points,<sp/>points+5,<sp/>result<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/><sp/>ptr<sp/>-<sp/>result<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points<sp/>on<sp/>the<sp/>convex<sp/>hull:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ptr<sp/>-<sp/>result;<sp/>i++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>result[i]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>We saw in the previous section that CGAL comes with several kernels. As the convex hull algorithm only makes comparisons of coordinates and orientation tests of input points, we can choose a kernel that provides exact predicates, but no exact geometric constructions.</para><para>The convex hull function takes three arguments, the start and past-the-end pointer for the input, and the start pointer of the array for the result. The function returns the pointer into the result array just behind the last convex hull point written, so the pointer difference tells us how many points are on the convex hull.</para></sect2>
<sect2 id="tutorial_hello_world_1intro_vector">
<title>The Convex Hull of Points in a Vector</title>
<para>In the second example we replace the built-in array by a <computeroutput>std::vector</computeroutput> of the Standard Template Library.</para><para><linebreak/>
<bold>File</bold> <ref refid="Convex_hull_2_2vector_convex_hull_2_8cpp-example" kindref="compound">Convex_hull_2/vector_convex_hull_2.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/convex_hull_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>Points;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Points<sp/>points,<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_2(0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_2(10,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_2(10,10));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_2(6,5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_2(4,1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgConvexHull2Functions_1ga8241d43969ff61cb9be46811c2e9e176" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">CGAL::convex_hull_2</ref>(<sp/>points.begin(),<sp/>points.end(),<sp/>std::back_inserter(result)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>result.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points<sp/>on<sp/>the<sp/>convex<sp/>hull&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>We put some points in the vector calling the <computeroutput>push_back()</computeroutput> method of the <computeroutput>std::vector</computeroutput> class.</para><para>We then call the convex hull function. The first two arguments, <computeroutput>points.begin()</computeroutput> and <computeroutput>points.end()</computeroutput> are <emphasis>iterators</emphasis>, which are a generalization of pointers: they can be dereferenced and incremented. The convex hull function is <emphasis>generic</emphasis> in the sense that it takes as input whatever can be dereferenced and incremented.</para><para>The third argument is where the result gets written to. In the previous example we provided a pointer to allocated memory. The generalization of such a pointer is the <emphasis>output iterator</emphasis>, which allows to increment and assign a value to the dereferenced iterator. In this example we start with an empty vector which grows as needed. Therefore, we cannot simply pass it <computeroutput>result.begin()</computeroutput>, but an output iterator generated by the helper function <computeroutput>std::back_inserter(result)</computeroutput>. This output iterator does nothing when incremented, and calls <computeroutput>result.push_back(..)</computeroutput> on the assignment.</para><para>If you know the STL, the Standard Template Library, the above makes perfect sense, as this is the way the STL decouples algorithms from containers. If you don&apos;t know the STL, you maybe better first familiarize yourself with its basic ideas.</para></sect2>
</sect1>
<sect1 id="tutorial_hello_world_1intro_traits">
<title>About Kernels and Traits Classes</title>
<para>In this section we show how we express the requirements that must be fulfilled in order that a function like <computeroutput><ref refid="group__PkgConvexHull2Functions_1ga8241d43969ff61cb9be46811c2e9e176" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">convex_hull_2()</ref></computeroutput> can be used with an arbitrary point type.</para><para>If you look at the manual page of the function <computeroutput><ref refid="group__PkgConvexHull2Functions_1ga8241d43969ff61cb9be46811c2e9e176" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">convex_hull_2()</ref></computeroutput> and the other 2D convex hull algorithms, you see that they come in two versions. In the examples we have seen so far the function that takes two iterators for the range of input points and an output iterator for writing the result to. The second version has an additional template parameter <computeroutput>Traits</computeroutput>, and an additional parameter of this type.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>InputIterator<sp/>,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>OutputIterator<sp/>,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Traits<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classOutputIterator" kindref="compound">OutputIterator</ref><sp/></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__PkgConvexHull2Functions_1ga8241d43969ff61cb9be46811c2e9e176" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">convex_hull_2</ref>(<ref refid="classInputIterator" kindref="compound">InputIterator</ref><sp/>first,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classInputIterator" kindref="compound">InputIterator</ref><sp/>beyond,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classOutputIterator" kindref="compound">OutputIterator</ref><sp/>result,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Traits<sp/>&amp;<sp/>ch_traits)</highlight></codeline>
</programlisting></para><para>What are the geometric primitives a typical convex hull algorithm uses? Of course, this depends on the algorithm, so let us consider what is probably the simplest efficient algorithm, the so-called &quot;Graham/Andrew Scan&quot;. This algorithm first sorts the points from left to right, and then builds the convex hull incrementally by adding one point after another from the sorted list. To do this, it must at least know about some point type, it should have some idea how to sort those points, and it must be able to evaluate the orientation of a triple of points.</para><para>And that is where the template parameter <computeroutput>Traits</computeroutput> comes in. For <computeroutput><ref refid="group__PkgConvexHull2Functions_1gaeccc6dda2f9d3096c94a7ff84cc91a85" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">ch_graham_andrew()</ref></computeroutput> it must provide the following nested types:</para><para><itemizedlist>
<listitem><para><computeroutput>Traits::Point_2</computeroutput></para></listitem><listitem><para><computeroutput>Traits::Less_xy_2</computeroutput></para></listitem><listitem><para><computeroutput>Traits::Left_turn_2</computeroutput></para></listitem><listitem><para><computeroutput>Traits::Equal_2</computeroutput></para></listitem></itemizedlist>
</para><para>As you can guess, <computeroutput>Left_turn_2</computeroutput> is responsible for the orientation test, while <computeroutput>Less_xy_2</computeroutput> is used for sorting the points. The requirements these types have to satisfy are documented in full with the concept <computeroutput><ref refid="classConvexHullTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">ConvexHullTraits_2</ref></computeroutput>.</para><para>The types are regrouped for a simple reason. The alternative would have been a rather lengthy function template, and an even longer function call.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>InputIterator,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>OutputIterator,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Po</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">_2,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Less_xy_2,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Left_turn_2,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Equal_2&gt;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classOutputIterator" kindref="compound">OutputIterator</ref></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__PkgConvexHull2Functions_1gaeccc6dda2f9d3096c94a7ff84cc91a85" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">ch_graham_andrew</ref>(<sp/><ref refid="classInputIterator" kindref="compound">InputIterator</ref><sp/><sp/>first,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classInputIterator" kindref="compound">InputIterator</ref><sp/><sp/>beyond,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classOutputIterator" kindref="compound">OutputIterator</ref><sp/>result);</highlight></codeline>
</programlisting></para><para>There are two obvious questions: What can be used as argument for this template parameter? And why do we have template parameters at all?</para><para>To answer the first question, any model of the CGAL concept <computeroutput><ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> provides what is required by the concept <computeroutput><ref refid="classConvexHullTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">ConvexHullTraits_2</ref></computeroutput>.</para><para>As for the second question, think about an application where we want to compute the convex hull of 3D points projected into the <computeroutput>yz</computeroutput> plane. Using the class <computeroutput><ref refid="classCGAL_1_1Projection__traits__yz__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_yz_3</ref></computeroutput> this is a small modification of the previous example.</para><para><linebreak/>
<bold>File</bold> <ref refid="Convex_hull_2_2convex_hull_yz_8cpp-example" kindref="compound">Convex_hull_2/convex_hull_yz.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iterator&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Projection_traits_yz_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/convex_hull_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Projection__traits__yz__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Projection_traits_yz_3&lt;K3&gt;</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;<sp/>Point_2<sp/>&gt;<sp/><sp/>input_begin(<sp/>std::cin<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::istream_iterator&lt;<sp/>Point_2<sp/>&gt;<sp/><sp/>input_end;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ostream_iterator&lt;<sp/>Point_2<sp/>&gt;<sp/><sp/>output(<sp/>std::cout,<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal"><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgConvexHull2Functions_1ga8241d43969ff61cb9be46811c2e9e176" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">CGAL::convex_hull_2</ref>(<sp/>input_begin,<sp/>input_end,<sp/>output,<sp/>K()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Another example would be about a user defined point type, or a point type coming from a third party library other than CGAL. Put the point type together with the required predicates for this point type in the scope of a class, and you can run <computeroutput><ref refid="group__PkgConvexHull2Functions_1ga8241d43969ff61cb9be46811c2e9e176" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Convex_hull_2.tag">convex_hull_2()</ref></computeroutput> with these points.</para><para>Finally, let us explain why a traits object that is passed to the convex hull function? It would allow to use a more general projection traits object to store state, for example if the projection plane was given by a direction, which is hardwired in the class <computeroutput><ref refid="classCGAL_1_1Projection__traits__yz__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Projection_traits_yz_3</ref></computeroutput>.</para></sect1>
<sect1 id="tutorial_hello_world_1intro_concept">
<title>Concepts and Models</title>
<para>In the previous section we wrote that &quot;Any model of the CGAL concept
Kernel provides what is required by the concept ConvexHullTraits_2&quot;.</para><para>A <emphasis>concept</emphasis> is a set of requirements on a type, namely that it has certain nested types, certain member functions, or comes with certain free functions that take the type as it. A <emphasis>model</emphasis> of a concept is a class that fulfills the requirements of the concept.</para><para>Let&apos;s have a look at the following function.</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">T</highlight></codeline>
<codeline><highlight class="normal">duplicate(T<sp/>t)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>t;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>If you want to instantiate this function with a class <computeroutput>C</computeroutput> this class must at least provide a copy constructor, and we say that class <computeroutput>C</computeroutput> must be a model of <computeroutput><ref refid="classCopyConstructible" kindref="compound">CopyConstructible</ref></computeroutput>. A singleton class does not fulfill this requirment.</para><para>Another example is the function</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight></codeline>
<codeline><highlight class="normal">T&amp;<sp/><ref refid="group__nt__util_1gab0ad1dbf97e8a81da183514138f583e6" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">std::min</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>a,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>b)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(a&lt;b)?a:b;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight></codeline>
</programlisting></para><para>This function only compiles if the <computeroutput>operator&lt;(..)</computeroutput> is defined for the type used as <computeroutput>T</computeroutput>, and we say that the type must be a model of <computeroutput><ref refid="classLessThanComparable" kindref="compound">LessThanComparable</ref></computeroutput>.</para><para>An example for a concept with required free functions is the <computeroutput><ref refid="classHalfedgeListGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">HalfedgeListGraph</ref></computeroutput> in the CGAL package <ref refid="packages_1PkgBGLSummary" kindref="member">CGAL and the Boost Graph Library</ref>. In order to be a model of <computeroutput><ref refid="classHalfedgeListGraph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">HalfedgeListGraph</ref></computeroutput> a class <computeroutput>G</computeroutput> there must be a global function <computeroutput>halfedges(const G&amp;)</computeroutput>, etc.</para><para>An example for a concept with a required traits class is <computeroutput><ref refid="classInputIterator" kindref="compound">InputIterator</ref></computeroutput>. For a model of an <computeroutput><ref refid="classInputIterator" kindref="compound">InputIterator</ref></computeroutput> a specialization of the class <ulink url="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><computeroutput>std::iterator_traits</computeroutput></ulink> must exist (or the generic template must be applicable).</para></sect1>
<sect1 id="tutorial_hello_world_1intro_further">
<title>Further Reading</title>
<para>We also recommend the standard text books &quot;The C++ Standard Library, A
Tutorial and Reference&quot; by Nicolai M. Josuttis from Addison-Wesley, or &quot;Generic Programming and the STL&quot; by Matthew H. Austern for the STL and its notion of <emphasis>concepts</emphasis> and <emphasis>models</emphasis>.</para><para>Other resources for CGAL are the rest of the <ref refid="tutorials" kindref="compound">tutorials</ref> and the user support page at <ulink url="https://www.cgal.org/">https://www.cgal.org/</ulink>. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
