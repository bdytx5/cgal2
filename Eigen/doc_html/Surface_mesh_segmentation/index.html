<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Surface_mesh_segmentation/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Triangulated Surface Mesh Segmentation: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Triangulated Surface Mesh Segmentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_3D_SurfaceSegmentation"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Ilker O. Yaz and SÃ©bastien Loriot</dd></dl>
<p><a class="anchor" id="fig__Segmentation_Elephant_main"></a></p><div class="image">
<img src="elephant_sdf_partition.png" alt="elephant_sdf_partition.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Segmentation_Elephant_main">Figure 63.1</a> The shape diameter function applied to the elephant and the corresponding segmentation (using 6 clusters).  </div>  <br />

<h1><a class="anchor" id="Surface_mesh_segmentationIntroduction"></a>
Introduction</h1>
<p>Mesh segmentation is the process of decomposing a mesh into smaller and meaningful sub-meshes. This process is used in applications such as modeling, rigging, texturing, shape-retrieval, deformation ... We refer to a comprehensive survey on mesh segmentation <a class="el" href="citelist.html#CITEREF_Shamir2008SegmentationSurvey">[3]</a> for different segmentation techniques.</p>
<p>This package provides an implementation of the algorithm relying on the <em>Shape Diameter Function</em> <a class="el" href="citelist.html#CITEREF_shapira2008consistent">[4]</a> (SDF). Given a triangulated surface mesh (simply <em>mesh</em> in the following) bounding a 3D solid object, the SDF provides an estimate of the local object diameter for each facet of the mesh (the SDF values). The segmentation algorithm first applies a soft clustering on the facets using the associated SDF values. The final segmentation is then obtained via a graph-cut algorithm that considers surface-based features (dihedral-angle and concavity) together with the result of the soft clustering.</p>
<p>This package offers the computation of the SDF values and the mesh segmentation result as independent functions. This allows an alternative implementation of the SDF to be directly plugged into the segmentation algorithm, and also to reuse the SDF values several times with different parameters for the segmentation algorithm.</p>
<h1><a class="anchor" id="Surface_mesh_segmentationOverviewoftheSegmentation"></a>
Overview of the Segmentation Process</h1>
<h2><a class="anchor" id="Surface_mesh_segmentationShapeDiameterFunction"></a>
Shape Diameter Function</h2>
<p>The Shape Diameter Function provides a connection between the surface mesh and the volume of the subtended 3D bounded object. More specifically, the SDF is a scalar-valued function defined on facets of the mesh that measures the corresponding local object diameter. The SDF is used to distinguish between thin and thick parts by adding a local notion of thickness to the facets. In addition, the SDF is pose-invariant: SDF values remain largely unaffected after changes of pose (see <a class="el" href="index.html#fig__Segmentation_pose_changes">Figure 63.2</a>).</p>
<p><a class="anchor" id="fig__Segmentation_pose_changes"></a></p><div class="image">
<img src="pose_changes_sdf_low_3.png" alt="pose_changes_sdf_low_3.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Segmentation_pose_changes">Figure 63.2</a> Influence of pose changes over SDF values and the segmentation.  </div>  <br />

<h3><a class="anchor" id="Surface_mesh_segmentationRawSDF"></a>
Computing Raw SDF Values</h3>
<p>For a given input mesh, the raw SDF values are computed by processing each facet one by one. For each facet, several rays are sampled in a cone constructed using the centroid of the facet as apex and inward-normal of the facet as axis. Each ray is truncated into a segment, its endpoints being the apex of the cone and the first mesh facet intersection point. Using the lengths of these truncated rays, which intuitively correspond to a local volume sampling, the raw SDF value is computed by first applying an outlier removal procedure and then taking the average of the lengths.</p>
<p>The raw SDF values are computed through function <code><a class="el" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925" title="Function computing the Shape Diameter Function over a surface mesh. ">sdf_values()</a></code>, setting <code>postprocess</code> to <code>false</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This package also accepts input meshes with holes. In such a case, rays that can not be truncated to segments, or rays that form an obtuse angle with the inward-normal of the first intersected facet are ignored. Only facets having no ray get no raw SDF values</dd></dl>
<h3><a class="anchor" id="Surface_mesh_segmentationPostprocessing"></a>
Post-processing of Raw SDF Values</h3>
<p>After having calculated the raw SDF value for each facet, the SDF values used in the segmentation algorithm are the result of several post-processing steps:</p>
<ul>
<li>Facets with no raw SDF values are assigned the average raw SDF value of their edge-adjacent neighbors. If there is still a facet having no SDF value, the minimum amongst all the SDF values is assigned to it (this is a deviation from the description of the algorithm in <a class="el" href="citelist.html#CITEREF_shapira2008consistent">[4]</a>). The main reason for not assigning 0 to facets with no SDF values is that it can obstruct log-normalization process done at the beginning of <code><a class="el" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764" title="Function computing the segmentation of a surface mesh given an SDF value per facet. ">segmentation_from_sdf_values()</a></code>.</li>
<li><p class="startli">A bilateral smoothing <a class="el" href="citelist.html#CITEREF_Tomasi1998Bilateral">[5]</a> is applied. This smoothing technique removes the noise while trying to keep fast changes on SDF values unchanged since they are natural candidates for segment boundaries. The bilateral smoothing <a class="el" href="citelist.html#CITEREF_Tomasi1998Bilateral">[5]</a> has three parameters that are set as follows:</p><ul>
<li>\( w = \lfloor\sqrt{ |F| / 2000}\rfloor + 1 \), the window size (i.e. maximum level for breadth-first neighbor selection), where \( F \) denotes the set of facets</li>
<li>\( \sigma_s = w / 2 \), the spatial parameter</li>
<li>\( \sigma_{r_i} = \sqrt{1/|w_i| \sum_{f_j \in w_i}(SDF(f_j) - SDF(f_i))^2} \), the range parameter set for each facet \( f_i \); \( w_i \) denotes the set of neighboring facets of \( f_i \) collected using \( w \) in the facet neighbor breadth-first search</li>
</ul>
<p class="startli">Large window sizes are more effective at eliminating noise but may over-smooth SDF values along segment boundaries. Large range parameters make smoothing closer to Gaussian smoothing and may also lead to over-smoothed SDF values.</p>
</li>
<li>SDF values are linearly normalized between [0,1].</li>
</ul>
<p>These post-processing steps can be applied to raw SDF values (or an alternative set of similar scalar values associated with facets) using the function <code><a class="el" href="group__PkgSurfaceSegmentation.html#ga392cbdd609e2ba8cacf7f2af8e86c631" title="Function post-processing raw SDF values computed per facet. ">sdf_values_postprocessing()</a></code>.</p>
<h2><a class="anchor" id="Surface_mesh_segmentationSoftClustering"></a>
Soft Clustering</h2>
<p>Given a number \( k \) of clusters, the soft clustering is a Gaussian mixture model that consists in fitting \( k \) Gaussian distributions to the distribution of the SDF values of the facets. It is initialized with k-means++ <a class="el" href="citelist.html#CITEREF_Arthur2007Kmeans">[1]</a>, and run multiple times with random seeds. Among these runs, the best result is used for initializing the expectation-maximization algorithm for fitting the Gaussian distributions.</p>
<dl class="section note"><dt>Note</dt><dd>There is no direct relationship between the number of clusters (parameter for soft clustering) and the final number of segments. Intuitively, the number of clusters represents the number of levels of a segmentation by clustering facets that have close SDF values without considering their connectivity. However, a large number of clusters is likely to result in detailed segmentation of the mesh with a large number of segments, see <a class="el" href="index.html#fig__Segmentation_levels">Figure 63.3</a>.</dd></dl>
<p><a class="anchor" id="fig__Segmentation_levels"></a></p><div class="image">
<img src="effect_of_levels.png" alt="effect_of_levels.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Segmentation_levels">Figure 63.3</a> Influence of the number of clusters over the segmentation. The number of clusters are set to 4, 3, and 2 respectively.  </div>  <br />

<p>The output of this procedure is a matrix that contains probability values for each facet to belong to each cluster. These probability values are used as input to the hard clustering.</p>
<h2><a class="anchor" id="Surface_mesh_segmentationGraphCut"></a>
Hard clustering</h2>
<p>The hard clustering yields the final segmentation of the input mesh and results from minimizing an energy function combining the aforementioned probability matrix and geometric surface features.</p>
<p>The energy function minimized using alpha-expansion graph cut algorithm <a class="el" href="citelist.html#CITEREF_Boykov2001FastApproximate">[2]</a> is defined as follows:</p>
<table border="0">
<tr>
<td><p class="starttd">\( E(\bar{x}) = \sum\limits_{f \in F} e_1(f, x_f) + \lambda \sum\limits_{ \{f,g\} \in N} e_2(x_f, x_g) \)</p>
<p>\( e_1(f, x_f) = -log(max(P(f|x_f), \epsilon)) \)</p>
<p class="endtd">\( e_2(x_f, x_g) = \left \{ \begin{array}{rl} -log(\theta(f,g)/\pi) &amp;\mbox{ $x_f \ne x_g$} \\ 0 &amp;\mbox{ $x_f = x_g$} \end{array} \right \} \)  </p>
</td><td>where:<ul>
<li>\(F\) denotes the set of facets,</li>
<li>\(N\) denotes the set of pairs of neighboring facets,</li>
<li>\(x_f\) denotes the cluster assigned to facet \(f\),</li>
<li>\(P(f|x_p)\) denotes the probability of assigning facet \(f\) to cluster \(x_p\),</li>
<li>\(\theta(f,g)\) denotes the dihedral angle between neighboring facets \(f\) and \(g\): concave angles and convex angles are weighted by 1 and 0.1 respectively,</li>
<li>\(\epsilon\) denotes the minimal probability threshold,</li>
<li>\(\lambda \in [0,1]\) denotes a smoothness parameter.   </li>
</ul>
</td></tr>
</table>
<p>The first term of the energy function provides the contribution of the soft clustering probabilities. The second term of the energy function is a geometric criterion that is larger when two adjacent facets sharing a sharp and concave edge are in the same cluster. The smoothness parameter makes this geometric criteria more or less prevalent.</p>
<p>Assigning a high value to the smoothness parameter results in a small number of segments (since constructing a segment boundary would be expensive). In other words, merging facets that are placed under different clusters is less expensive than separating them and creating boundaries. On the contrary, assigning smaller values to smoothness parameter results in a high number of segments, by getting closer to the result of the soft clustering (notice that setting \( \lambda=0 \) provides the result of the soft clustering). <a class="el" href="index.html#fig__Segmentation_lambdas">Figure 63.4</a> depicts the influence of the smoothness parameter.</p>
<p><a class="anchor" id="fig__Segmentation_lambdas"></a></p><div class="image">
<img src="dino_different_lambda_small.png" alt="dino_different_lambda_small.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Segmentation_lambdas">Figure 63.4</a> Influence of the smoothness parameter lambda over the segmentation (using 10 clusters). Smoothness parameters are set to 0.0, 0.1, 0.25, 0.5 and 1.0 respectively. The coloring reflects the segmentation result before assigning each connected component to its own segment.  </div>  <br />

<p>The hard clustering assigns a cluster id to each facet (see <a class="el" href="index.html#fig__Cluster_vs_segment">Figure 63.5</a> (a)). A segment consists in a set of connected facets in the same cluster (see <a class="el" href="index.html#fig__Cluster_vs_segment">Figure 63.5</a> (b)). By default the function <code><a class="el" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764" title="Function computing the segmentation of a surface mesh given an SDF value per facet. ">segmentation_from_sdf_values()</a></code> assigns to each facet the id of its segment. It assigns to each facet the id of its cluster when <code>output_cluster_ids</code> is set to <code>true</code>.</p>
<p><a class="anchor" id="fig__Cluster_vs_segment"></a></p><div class="image">
<img src="cluster_vs_segment.png" alt="cluster_vs_segment.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Cluster_vs_segment">Figure 63.5</a> Clusters and segments. The input number of clusters is set to 5. <b>(a)</b> Result of the hard-clustering. <b>(b)</b> Segments are extracted from the computed clusters.  </div>  <br />

<h2><a class="anchor" id="Surface_mesh_segmentationAPI"></a>
Summary</h2>
<p>Four functions are provided:</p><ul>
<li><code><a class="el" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925" title="Function computing the Shape Diameter Function over a surface mesh. ">sdf_values()</a></code> : computes the SDF value of each facet of an input mesh in either raw or post-processed form. SDF values are associated to facets using a property map (see <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/index.html#Chapter_CGAL_and_Boost_Property_Maps">CGAL and Boost Property Maps</a>).</li>
<li><code><a class="el" href="group__PkgSurfaceSegmentation.html#ga392cbdd609e2ba8cacf7f2af8e86c631" title="Function post-processing raw SDF values computed per facet. ">sdf_values_postprocessing()</a></code> : post-processes raw SDF values. The post-processing is decoupled from the function <code><a class="el" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925" title="Function computing the Shape Diameter Function over a surface mesh. ">sdf_values()</a></code> to allow the use of alternative methods to compute SDF values or additional post-processing step.</li>
<li><code><a class="el" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764" title="Function computing the segmentation of a surface mesh given an SDF value per facet. ">segmentation_from_sdf_values()</a></code> : computes the mesh segmentation from the SDF values of the facets of an input mesh. The input SDF values can be any set of scalar values associated to each facet as long as they have been normalized between 0 and 1. This function allows using the same SDF values with different parameters for the segmentation stage. The segment or cluster ids are associated to the facets using a property map.</li>
<li><code><a class="el" href="group__PkgSurfaceSegmentation.html#gabc864f396347009726b858434c6d8659" title="Function computing the segmentation of a surface mesh. ">segmentation_via_sdf_values()</a></code> : combines the three functions above.</li>
</ul>
<p>These functions expect as input a triangulated surface mesh bounding a 3D solid object, with the following properties:</p><ul>
<li>Combinatorially 2-manifold;</li>
<li>The vertices of the facets are oriented counterclockwise when seen from outside of the object;</li>
<li>Intersection-free;</li>
<li>Boundary free.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The current implementation executes fine on meshes that do not match some of these properties but may produce unreliable or meaningless segmentations.</dd></dl>
<p>The current implementation of the computation of the SDF values relies on the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgAABB_treeSummary">3D Fast Intersection and Distance Computation</a> package. This operation is reliable when the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classAABBTraits.html">AABBTraits</a></code> model provided has exact predicates. <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></code> is recommended as geometric traits for this algorithm.</p>
<h1><a class="anchor" id="SDFExamples"></a>
Examples</h1>
<h2><a class="anchor" id="Example_1"></a>
Example: Computation of SDF Values</h2>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_segmentation_2sdf_values_example_8cpp-example.html">Surface_mesh_segmentation/sdf_values_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mesh_segmentation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> CGAL::Polyhedron_3&lt;Kernel&gt; Polyhedron;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// create and read Polyhedron</span></div><div class="line">  Polyhedron mesh;</div><div class="line">  std::ifstream input(<span class="stringliteral">"data/cactus.off"</span>);</div><div class="line">  <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; mesh) || mesh.empty() || ( !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh)) ) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Input is not a triangle mesh"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// create a property-map</span></div><div class="line">  <span class="keyword">typedef</span> std::map&lt;Polyhedron::Facet_const_handle, double&gt; Facet_double_map;</div><div class="line">  Facet_double_map internal_map;</div><div class="line">  boost::associative_property_map&lt;Facet_double_map&gt; sdf_property_map(internal_map);</div><div class="line"></div><div class="line">  <span class="comment">// compute SDF values</span></div><div class="line">  std::pair&lt;double, double&gt; min_max_sdf = <a class="code" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925">CGAL::sdf_values</a>(mesh, sdf_property_map);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// It is possible to compute the raw SDF values and post-process them using</span></div><div class="line">  <span class="comment">// the following lines:</span></div><div class="line">  <span class="comment">// const std::size_t number_of_rays = 25;  // cast 25 rays per facet</span></div><div class="line">  <span class="comment">// const double cone_angle = 2.0 / 3.0 * CGAL_PI; // set cone opening-angle</span></div><div class="line">  <span class="comment">// CGAL::sdf_values(mesh, sdf_property_map, cone_angle, number_of_rays, false);</span></div><div class="line">  <span class="comment">// std::pair&lt;double, double&gt; min_max_sdf =</span></div><div class="line">  <span class="comment">//  CGAL::sdf_values_postprocessing(mesh, sdf_property_map);</span></div><div class="line"></div><div class="line">  <span class="comment">// print minimum &amp; maximum SDF values</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"minimum SDF: "</span> &lt;&lt; min_max_sdf.first</div><div class="line">            &lt;&lt; <span class="stringliteral">" maximum SDF: "</span> &lt;&lt; min_max_sdf.second &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// print SDF values</span></div><div class="line">  <span class="keywordflow">for</span>(Polyhedron::Facet_const_iterator facet_it = mesh.facets_begin();</div><div class="line">      facet_it != mesh.facets_end(); ++facet_it) {</div><div class="line">      std::cout &lt;&lt; sdf_property_map[facet_it] &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Example_2"></a>
Example: Segmentation from SDF Values</h2>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_segmentation_2segmentation_from_sdf_values_example_8cpp-example.html">Surface_mesh_segmentation/segmentation_from_sdf_values_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mesh_segmentation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> CGAL::Polyhedron_3&lt;Kernel&gt; Polyhedron;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// create and read Polyhedron</span></div><div class="line">    Polyhedron mesh;</div><div class="line">    std::ifstream input(<span class="stringliteral">"data/cactus.off"</span>);</div><div class="line">    <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; mesh) || mesh.empty()  || ( !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))) {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Input is not a triangle mesh."</span> &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create a property-map for SDF values</span></div><div class="line">    <span class="keyword">typedef</span> std::map&lt;Polyhedron::Facet_const_handle, double&gt; Facet_double_map;</div><div class="line">    Facet_double_map internal_sdf_map;</div><div class="line">    boost::associative_property_map&lt;Facet_double_map&gt; sdf_property_map(internal_sdf_map);</div><div class="line"></div><div class="line">    <span class="comment">// compute SDF values using default parameters for number of rays, and cone angle</span></div><div class="line">    <a class="code" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925">CGAL::sdf_values</a>(mesh, sdf_property_map);</div><div class="line"></div><div class="line">    <span class="comment">// create a property-map for segment-ids</span></div><div class="line">    <span class="keyword">typedef</span> std::map&lt;Polyhedron::Facet_const_handle, std::size_t&gt; Facet_int_map;</div><div class="line">    Facet_int_map internal_segment_map;</div><div class="line">    boost::associative_property_map&lt;Facet_int_map&gt; segment_property_map(internal_segment_map);</div><div class="line"></div><div class="line">    <span class="comment">// segment the mesh using default parameters for number of levels, and smoothing lambda</span></div><div class="line">    <span class="comment">// Any other scalar values can be used instead of using SDF values computed using the CGAL function</span></div><div class="line">    std::size_t number_of_segments = <a class="code" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764">CGAL::segmentation_from_sdf_values</a>(mesh, sdf_property_map, segment_property_map);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Number of segments: "</span> &lt;&lt; number_of_segments &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// print segment-ids</span></div><div class="line">    <span class="keywordflow">for</span>(Polyhedron::Facet_const_iterator facet_it = mesh.facets_begin();</div><div class="line">        facet_it != mesh.facets_end(); ++facet_it) {</div><div class="line">        <span class="comment">// ids are between [0, number_of_segments -1]</span></div><div class="line">        std::cout &lt;&lt; segment_property_map[facet_it] &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::size_t number_of_clusters = 4;       <span class="comment">// use 4 clusters in soft clustering</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> smoothing_lambda = 0.3;  <span class="comment">// importance of surface features, suggested to be in-between [0,1]</span></div><div class="line"></div><div class="line">    <span class="comment">// Note that we can use the same SDF values (sdf_property_map) over and over again for segmentation.</span></div><div class="line">    <span class="comment">// This feature is relevant for segmenting the mesh several times with different parameters.</span></div><div class="line">    <a class="code" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764">CGAL::segmentation_from_sdf_values</a>(</div><div class="line">      mesh, sdf_property_map, segment_property_map, number_of_clusters, smoothing_lambda);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Example_3"></a>
Computation of SDF Values and Segmentation</h3>
<p>The function <code><a class="el" href="group__PkgSurfaceSegmentation.html#gabc864f396347009726b858434c6d8659" title="Function computing the segmentation of a surface mesh. ">segmentation_via_sdf_values()</a></code> combines the computation of sdf values, the post-processing and the segmentation. Note that when computing several segmentations of a mesh with different parameters (i.e. number of levels, and smoothing lambda), it is advised to first compute the SDF values using <code><a class="el" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925" title="Function computing the Shape Diameter Function over a surface mesh. ">sdf_values()</a></code> and use them in calls of the function <code><a class="el" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764" title="Function computing the segmentation of a surface mesh given an SDF value per facet. ">segmentation_from_sdf_values()</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_segmentation_2segmentation_via_sdf_values_example_8cpp-example.html">Surface_mesh_segmentation/segmentation_via_sdf_values_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mesh_segmentation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> CGAL::Polyhedron_3&lt;Kernel&gt; Polyhedron;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// create and read Polyhedron</span></div><div class="line">    Polyhedron mesh;</div><div class="line">    std::ifstream input(<span class="stringliteral">"data/cactus.off"</span>);</div><div class="line">    <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; mesh) || mesh.empty() || ( !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh)) ) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Input is not a triangle mesh"</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create a property-map for segment-ids</span></div><div class="line">    <span class="keyword">typedef</span> std::map&lt;Polyhedron::Facet_const_handle, std::size_t&gt; Facet_int_map;</div><div class="line">    Facet_int_map internal_segment_map;</div><div class="line">    boost::associative_property_map&lt;Facet_int_map&gt; segment_property_map(internal_segment_map);</div><div class="line"></div><div class="line">    <span class="comment">// calculate SDF values and segment the mesh using default parameters.</span></div><div class="line">    std::size_t number_of_segments = <a class="code" href="group__PkgSurfaceSegmentation.html#gabc864f396347009726b858434c6d8659">CGAL::segmentation_via_sdf_values</a>(mesh, segment_property_map);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Number of segments: "</span> &lt;&lt; number_of_segments &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// print segment-ids</span></div><div class="line">    <span class="keywordflow">for</span>(Polyhedron::Facet_const_iterator facet_it = mesh.facets_begin();</div><div class="line">        facet_it != mesh.facets_end(); ++facet_it) {</div><div class="line">        std::cout &lt;&lt; segment_property_map[facet_it] &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_segmentationUsingapolyhedron"></a>
Using a Polyhedron with an ID per Facet</h2>
<p>The previous examples use a <code>std::map</code> as property maps for storing the SDF values and the segmentation results. This example uses a polyhedron type with a facet type storing an extra ID field, together with a vector, as underlying data structure in the property maps. The main advantage is to decrease from log to constant the complexity for accessing the data associated to facets.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_segmentation_2segmentation_with_facet_ids_example_8cpp-example.html">Surface_mesh_segmentation/segmentation_with_facet_ids_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mesh_segmentation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> CGAL::Polyhedron_3&lt;K, CGAL::Polyhedron_items_with_id_3&gt;  Polyhedron;</div><div class="line"></div><div class="line"><span class="comment">// Property map associating a facet with an integer as id to an</span></div><div class="line"><span class="comment">// element in a vector stored internally</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ValueType&gt;</div><div class="line"><span class="keyword">struct </span>Facet_with_id_pmap</div><div class="line">    : <span class="keyword">public</span> boost::put_get_helper&lt;ValueType&amp;,</div><div class="line">             Facet_with_id_pmap&lt;ValueType&gt; &gt;</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> Polyhedron::Facet_const_handle key_type;</div><div class="line">    <span class="keyword">typedef</span> ValueType value_type;</div><div class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</div><div class="line">    <span class="keyword">typedef</span> boost::lvalue_property_map_tag category;</div><div class="line"></div><div class="line">    Facet_with_id_pmap(</div><div class="line">      std::vector&lt;ValueType&gt;&amp; internal_vector</div><div class="line">    ) : internal_vector(internal_vector) { }</div><div class="line"></div><div class="line">    reference operator[](key_type key)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> internal_vector[key-&gt;id()]; }</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::vector&lt;ValueType&gt;&amp; internal_vector;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// create and read Polyhedron</span></div><div class="line">    Polyhedron mesh;</div><div class="line">    std::ifstream input(<span class="stringliteral">"data/cactus.off"</span>);</div><div class="line">    <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; mesh) || mesh.empty() || ( !<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh)) ) {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Input is not a triangle mesh"</span> &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// assign id field for each facet</span></div><div class="line">    std::size_t facet_id = 0;</div><div class="line">    <span class="keywordflow">for</span>(Polyhedron::Facet_iterator facet_it = mesh.facets_begin();</div><div class="line">      facet_it != mesh.facets_end(); ++facet_it, ++facet_id) {</div><div class="line">        facet_it-&gt;id() = facet_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create a property-map for SDF values</span></div><div class="line">    std::vector&lt;double&gt; <a class="code" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925">sdf_values</a>(mesh.size_of_facets());</div><div class="line">    Facet_with_id_pmap&lt;double&gt; sdf_property_map(<a class="code" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925">sdf_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925">CGAL::sdf_values</a>(mesh, sdf_property_map);</div><div class="line"></div><div class="line">    <span class="comment">// access SDF values (with constant-complexity)</span></div><div class="line">    <span class="keywordflow">for</span>(Polyhedron::Facet_const_iterator facet_it = mesh.facets_begin();</div><div class="line">      facet_it != mesh.facets_end(); ++facet_it) {</div><div class="line">        std::cout &lt;&lt; sdf_property_map[facet_it] &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// create a property-map for segment-ids</span></div><div class="line">    std::vector&lt;std::size_t&gt; segment_ids(mesh.size_of_facets());</div><div class="line">    Facet_with_id_pmap&lt;std::size_t&gt; segment_property_map(segment_ids);</div><div class="line"></div><div class="line">    <a class="code" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764">CGAL::segmentation_from_sdf_values</a>(mesh, sdf_property_map, segment_property_map);</div><div class="line"></div><div class="line">    <span class="comment">// access segment-ids (with constant-complexity)</span></div><div class="line">    <span class="keywordflow">for</span>(Polyhedron::Facet_const_iterator facet_it = mesh.facets_begin();</div><div class="line">      facet_it != mesh.facets_end(); ++facet_it) {</div><div class="line">        std::cout &lt;&lt; segment_property_map[facet_it] &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_segmentationUsingSM"></a>
Using a Surface_mesh</h2>
<p>When using a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code>, you can use the built-in property mechanism.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_segmentation_2segmentation_from_sdf_values_SM_example_8cpp-example.html">Surface_mesh_segmentation/segmentation_from_sdf_values_SM_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mesh_segmentation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> Mesh; </div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor face_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_iterator face_iterator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div><div class="line">{</div><div class="line">  Mesh mesh;</div><div class="line">  <span class="keywordflow">if</span> (argc==2){</div><div class="line">    std::ifstream input(argv[1]); </div><div class="line">    input &gt;&gt; mesh;</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    std::ifstream cactus(<span class="stringliteral">"data/cactus.off"</span>);</div><div class="line">    cactus &gt;&gt; mesh;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh)){</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Input is not a triangle mesh"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  <span class="keyword">typedef</span> Mesh::Property_map&lt;face_descriptor,double&gt; Facet_double_map;</div><div class="line">  Facet_double_map sdf_property_map;</div><div class="line"></div><div class="line">  sdf_property_map = mesh.add_property_map&lt;face_descriptor,<span class="keywordtype">double</span>&gt;(<span class="stringliteral">"f:sdf"</span>).first;</div><div class="line"></div><div class="line">  <span class="comment">// compute SDF values</span></div><div class="line">  <span class="comment">// We can't use default parameters for number of rays, and cone angle</span></div><div class="line">  <span class="comment">// and the postprocessing</span></div><div class="line">  <a class="code" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925">CGAL::sdf_values</a>(mesh, sdf_property_map, 2.0 / 3.0 * CGAL_PI, 25, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  <span class="comment">// create a property-map for segment-ids</span></div><div class="line">  <span class="keyword">typedef</span> Mesh::Property_map&lt;face_descriptor, std::size_t&gt; Facet_int_map;</div><div class="line">  Facet_int_map segment_property_map = mesh.add_property_map&lt;face_descriptor,std::size_t&gt;(<span class="stringliteral">"f:sid"</span>).first;;</div><div class="line"></div><div class="line">  <span class="comment">// segment the mesh using default parameters for number of levels, and smoothing lambda</span></div><div class="line">  <span class="comment">// Any other scalar values can be used instead of using SDF values computed using the CGAL function</span></div><div class="line">  std::size_t number_of_segments = <a class="code" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764">CGAL::segmentation_from_sdf_values</a>(mesh, sdf_property_map, segment_property_map);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Number of segments: "</span> &lt;&lt; number_of_segments &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// print segment-ids</span></div><div class="line">  face_iterator facet_it, fend;</div><div class="line">  BOOST_FOREACH(face_descriptor fd, faces(mesh)){</div><div class="line">      <span class="comment">// ids are between [0, number_of_segments -1]</span></div><div class="line">      std::cout &lt;&lt; segment_property_map[fd] &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::size_t number_of_clusters = 4;       <span class="comment">// use 4 clusters in soft clustering</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> smoothing_lambda = 0.3;  <span class="comment">// importance of surface features, suggested to be in-between [0,1]</span></div><div class="line"></div><div class="line">  <span class="comment">// Note that we can use the same SDF values (sdf_property_map) over and over again for segmentation.</span></div><div class="line">  <span class="comment">// This feature is relevant for segmenting the mesh several times with different parameters.</span></div><div class="line">  <a class="code" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764">CGAL::segmentation_from_sdf_values</a>(mesh, sdf_property_map, segment_property_map, number_of_clusters, smoothing_lambda);</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_segmentationIndependantmeshpersegment"></a>
Independant TriangleMesh per Segment</h2>
<p>It is possible to consider each segment as an independant triangle mesh, like in the following example, where the area of each segment is computed.</p>
<p><br />
<b>File</b> <a class="el" href="Surface_mesh_segmentation_2extract_segmentation_into_mesh_example_8cpp-example.html">Surface_mesh_segmentation/extract_segmentation_into_mesh_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/Face_filtered_graph.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/measure.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/copy_face_graph.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mesh_segmentation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a> SM;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;SM&gt;::face_descriptor face_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div><div class="line">{</div><div class="line">  SM mesh;</div><div class="line">  <span class="keywordflow">if</span> (argc==2){</div><div class="line">    std::ifstream input(argv[1]);</div><div class="line">    input &gt;&gt; mesh;</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    std::ifstream cactus(<span class="stringliteral">"data/cactus.off"</span>);</div><div class="line">    cactus &gt;&gt; mesh;</div><div class="line">  }</div><div class="line">  <span class="keyword">typedef</span> SM::Property_map&lt;face_descriptor,double&gt; Facet_double_map;</div><div class="line">  Facet_double_map sdf_property_map;</div><div class="line"></div><div class="line">  sdf_property_map = mesh.add_property_map&lt;face_descriptor,<span class="keywordtype">double</span>&gt;(<span class="stringliteral">"f:sdf"</span>).first;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925">CGAL::sdf_values</a>(mesh, sdf_property_map);</div><div class="line"></div><div class="line">  <span class="comment">// create a property-map for segment-ids</span></div><div class="line">  <span class="keyword">typedef</span> SM::Property_map&lt;face_descriptor, std::size_t&gt; Facet_int_map;</div><div class="line">  Facet_int_map segment_property_map = mesh.add_property_map&lt;face_descriptor,std::size_t&gt;(<span class="stringliteral">"f:sid"</span>).first;;</div><div class="line"></div><div class="line">  <span class="comment">// segment the mesh using default parameters for number of levels, and smoothing lambda</span></div><div class="line">  <span class="comment">// Any other scalar values can be used instead of using SDF values computed using the CGAL function</span></div><div class="line">  std::size_t number_of_segments = <a class="code" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764">CGAL::segmentation_from_sdf_values</a>(mesh, sdf_property_map, segment_property_map);</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/structCGAL_1_1Face__filtered__graph.html">CGAL::Face_filtered_graph&lt;SM&gt;</a> Filtered_graph;</div><div class="line">  <span class="comment">//print area of each segment and then put it in a Mesh and print it in an OFF file</span></div><div class="line">  Filtered_graph segment_mesh(mesh, 0, segment_property_map);</div><div class="line">  <span class="keywordflow">for</span>(std::size_t <span class="keywordtype">id</span> = 0; <span class="keywordtype">id</span> &lt; number_of_segments; ++id)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span>(<span class="keywordtype">id</span> &gt; 0)</div><div class="line">      segment_mesh.set_selected_faces(<span class="keywordtype">id</span>, segment_property_map);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Segment "</span>&lt;&lt;<span class="keywordtype">id</span>&lt;&lt;<span class="stringliteral">"'s area is : "</span>&lt;&lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__area__grp.html#gad5b975e731751609655f88d287f7385a">CGAL::Polygon_mesh_processing::area</a>(segment_mesh)&lt;&lt;std::endl;</div><div class="line">    SM out;</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2d3eb044bfe42eab566779ce32216c11">CGAL::copy_face_graph</a>(segment_mesh, out);</div><div class="line">    std::ostringstream oss;</div><div class="line">    oss &lt;&lt; <span class="stringliteral">"Segment_"</span> &lt;&lt; <span class="keywordtype">id</span>&lt;&lt;<span class="stringliteral">".off"</span>;</div><div class="line">    std::ofstream os(oss.str().data());</div><div class="line">    os&lt;&lt;out;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="Performances"></a>
Performances</h1>
<p>The following tables provide the runtime of the functions <code><a class="el" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925" title="Function computing the Shape Diameter Function over a surface mesh. ">sdf_values()</a></code> and <code><a class="el" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764" title="Function computing the segmentation of a surface mesh given an SDF value per facet. ">segmentation_from_sdf_values()</a></code>. The results were produced with the release 4.4 of <span style="font-variant: small-caps;">CGAL</span>, on an Intel i7 3.2 Ghz laptop with 8 GB RAM, compiled by Visual C++ 2010 with /O2 option. The polyhedron types are using <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Polyhedron__items__with__id__3.html">Polyhedron_items_with_id_3</a></code> as item class. The models used for the benchmarks are the <em>dinosaur</em> model with 7,828 facets, the <em>bear</em> model with 20,188 facets and the <em>elephant</em> model with 88,928 facets.</p>
<p>Runtime in seconds of <code><a class="el" href="group__PkgSurfaceSegmentation.html#ga42c20ac00cd54fb258c8d98fb5673925" title="Function computing the Shape Diameter Function over a surface mesh. ">sdf_values()</a></code> with 25 rays showing the cost of the robustness:</p>
<center> <table class="doxtable">
<tr>
<th>Number of triangles </th><th align="right"><code>Simple_cartesian&lt;double&gt;</code> </th><th align="right"><code>Exact_predicates_inexact_constructions_kernel</code> (<code>EPICK</code>)  </th></tr>
<tr>
<td>7,828 </td><td align="right">2.3 </td><td align="right">3.8 </td></tr>
<tr>
<td>20,188 </td><td align="right">6.1 </td><td align="right">9.5 </td></tr>
<tr>
<td>88,928 </td><td align="right">46.1 </td><td align="right">62.3 </td></tr>
</table>
</center><p>Runtime in milliseconds of <code><a class="el" href="group__PkgSurfaceSegmentation.html#ga8a429857a748922d0e8460619db69764" title="Function computing the segmentation of a surface mesh given an SDF value per facet. ">segmentation_from_sdf_values()</a></code> (using <code>Simple_cartesian&lt;double&gt;</code> or <code>EPICK</code> gives the same results), the graph-cut part is using the library <a href="http://pub.ist.ac.at/~vnk/software.html">MaxFlow</a> v2.21:</p>
<center> <table class="doxtable">
<tr>
<th>Number of triangles </th><th align="right">Number of cluster = 2 </th><th align="right">Number of cluster = 5 </th><th align="right">Number of cluster = 10 </th><th align="right">Number of cluster = 15  </th></tr>
<tr>
<td>7,828 </td><td align="right">38 </td><td align="right">61 </td><td align="right">141 </td><td align="right">204 </td></tr>
<tr>
<td>20,188 </td><td align="right">50 </td><td align="right">163 </td><td align="right">483 </td><td align="right">608 </td></tr>
<tr>
<td>88,928 </td><td align="right">314 </td><td align="right">1,260 </td><td align="right">2,736 </td><td align="right">4,239 </td></tr>
</table>
</center><h1><a class="anchor" id="Surface_mesh_segmentationImplementationhistory"></a>
Design and Implementation History</h1>
<p>The initial implementation of this package is the result of the work of Ilker O. Yaz during the 2012 season of the Google Summer of Code. He has been mentored by SÃ©bastien Loriot who also contributed to the documentation and the API definition. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:47 for CGAL 4.13 - Triangulated Surface Mesh Segmentation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
