<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_3D_SurfaceSegmentation"/>  <simplesect kind="author"><para>Ilker O. Yaz and SÃ©bastien Loriot</para></simplesect>
<anchor id="index_1fig__Segmentation_Elephant_main"/><image type="html" name="elephant_sdf_partition.png"></image>
 <image type="latex" name="elephant_sdf_partition.png" width="15cm"></image>
  <ref refid="index_1fig__Segmentation_Elephant_main" kindref="member">fig__Segmentation_Elephant_main</ref> The shape diameter function applied to the elephant and the corresponding segmentation (using 6 clusters).  <linebreak/>
</para><sect1 id="index_1Surface_mesh_segmentationIntroduction">
<title>Introduction</title>
<para>Mesh segmentation is the process of decomposing a mesh into smaller and meaningful sub-meshes. This process is used in applications such as modeling, rigging, texturing, shape-retrieval, deformation ... We refer to a comprehensive survey on mesh segmentation <ref refid="citelist_1CITEREF_Shamir2008SegmentationSurvey" kindref="member">[3]</ref> for different segmentation techniques.</para><para>This package provides an implementation of the algorithm relying on the <emphasis>Shape Diameter Function</emphasis> <ref refid="citelist_1CITEREF_shapira2008consistent" kindref="member">[4]</ref> (SDF). Given a triangulated surface mesh (simply <emphasis>mesh</emphasis> in the following) bounding a 3D solid object, the SDF provides an estimate of the local object diameter for each facet of the mesh (the SDF values). The segmentation algorithm first applies a soft clustering on the facets using the associated SDF values. The final segmentation is then obtained via a graph-cut algorithm that considers surface-based features (dihedral-angle and concavity) together with the result of the soft clustering.</para><para>This package offers the computation of the SDF values and the mesh segmentation result as independent functions. This allows an alternative implementation of the SDF to be directly plugged into the segmentation algorithm, and also to reuse the SDF values several times with different parameters for the segmentation algorithm.</para></sect1>
<sect1 id="index_1Surface_mesh_segmentationOverviewoftheSegmentation">
<title>Overview of the Segmentation Process</title>
<sect2 id="index_1Surface_mesh_segmentationShapeDiameterFunction">
<title>Shape Diameter Function</title>
<para>The Shape Diameter Function provides a connection between the surface mesh and the volume of the subtended 3D bounded object. More specifically, the SDF is a scalar-valued function defined on facets of the mesh that measures the corresponding local object diameter. The SDF is used to distinguish between thin and thick parts by adding a local notion of thickness to the facets. In addition, the SDF is pose-invariant: SDF values remain largely unaffected after changes of pose (see <ref refid="index_1fig__Segmentation_pose_changes" kindref="member">fig__Segmentation_pose_changes</ref>).</para><para><anchor id="index_1fig__Segmentation_pose_changes"/><image type="html" name="pose_changes_sdf_low_3.png"></image>
 <image type="latex" name="pose_changes_sdf_low_3.png" width="15cm"></image>
  <ref refid="index_1fig__Segmentation_pose_changes" kindref="member">fig__Segmentation_pose_changes</ref> Influence of pose changes over SDF values and the segmentation.  <linebreak/>
</para><sect3 id="index_1Surface_mesh_segmentationRawSDF">
<title>Computing Raw SDF Values</title>
<para>For a given input mesh, the raw SDF values are computed by processing each facet one by one. For each facet, several rays are sampled in a cone constructed using the centroid of the facet as apex and inward-normal of the facet as axis. Each ray is truncated into a segment, its endpoints being the apex of the cone and the first mesh facet intersection point. Using the lengths of these truncated rays, which intuitively correspond to a local volume sampling, the raw SDF value is computed by first applying an outlier removal procedure and then taking the average of the lengths.</para><para>The raw SDF values are computed through function <computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">sdf_values()</ref></computeroutput>, setting <computeroutput>postprocess</computeroutput> to <computeroutput>false</computeroutput>.</para><para><simplesect kind="note"><para>This package also accepts input meshes with holes. In such a case, rays that can not be truncated to segments, or rays that form an obtuse angle with the inward-normal of the first intersected facet are ignored. Only facets having no ray get no raw SDF values</para></simplesect>
</para></sect3>
<sect3 id="index_1Surface_mesh_segmentationPostprocessing">
<title>Post-processing of Raw SDF Values</title>
<para>After having calculated the raw SDF value for each facet, the SDF values used in the segmentation algorithm are the result of several post-processing steps:</para><para><itemizedlist>
<listitem><para>Facets with no raw SDF values are assigned the average raw SDF value of their edge-adjacent neighbors. If there is still a facet having no SDF value, the minimum amongst all the SDF values is assigned to it (this is a deviation from the description of the algorithm in <ref refid="citelist_1CITEREF_shapira2008consistent" kindref="member">[4]</ref>). The main reason for not assigning 0 to facets with no SDF values is that it can obstruct log-normalization process done at the beginning of <computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">segmentation_from_sdf_values()</ref></computeroutput>.</para></listitem><listitem><para>A bilateral smoothing <ref refid="citelist_1CITEREF_Tomasi1998Bilateral" kindref="member">[5]</ref> is applied. This smoothing technique removes the noise while trying to keep fast changes on SDF values unchanged since they are natural candidates for segment boundaries. The bilateral smoothing <ref refid="citelist_1CITEREF_Tomasi1998Bilateral" kindref="member">[5]</ref> has three parameters that are set as follows:<itemizedlist>
<listitem><para><formula id="0">$ w = \lfloor\sqrt{ |F| / 2000}\rfloor + 1 $</formula>, the window size (i.e. maximum level for breadth-first neighbor selection), where <formula id="1">$ F $</formula> denotes the set of facets</para></listitem><listitem><para><formula id="2">$ \sigma_s = w / 2 $</formula>, the spatial parameter</para></listitem><listitem><para><formula id="3">$ \sigma_{r_i} = \sqrt{1/|w_i| \sum_{f_j \in w_i}(SDF(f_j) - SDF(f_i))^2} $</formula>, the range parameter set for each facet <formula id="4">$ f_i $</formula>; <formula id="5">$ w_i $</formula> denotes the set of neighboring facets of <formula id="4">$ f_i $</formula> collected using <formula id="6">$ w $</formula> in the facet neighbor breadth-first search</para></listitem></itemizedlist>
</para><para>Large window sizes are more effective at eliminating noise but may over-smooth SDF values along segment boundaries. Large range parameters make smoothing closer to Gaussian smoothing and may also lead to over-smoothed SDF values.</para></listitem><listitem><para>SDF values are linearly normalized between [0,1].</para></listitem></itemizedlist>
</para><para>These post-processing steps can be applied to raw SDF values (or an alternative set of similar scalar values associated with facets) using the function <computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga392cbdd609e2ba8cacf7f2af8e86c631" kindref="member">sdf_values_postprocessing()</ref></computeroutput>.</para></sect3>
</sect2>
<sect2 id="index_1Surface_mesh_segmentationSoftClustering">
<title>Soft Clustering</title>
<para>Given a number <formula id="7">$ k $</formula> of clusters, the soft clustering is a Gaussian mixture model that consists in fitting <formula id="7">$ k $</formula> Gaussian distributions to the distribution of the SDF values of the facets. It is initialized with k-means++ <ref refid="citelist_1CITEREF_Arthur2007Kmeans" kindref="member">[1]</ref>, and run multiple times with random seeds. Among these runs, the best result is used for initializing the expectation-maximization algorithm for fitting the Gaussian distributions.</para><para><simplesect kind="note"><para>There is no direct relationship between the number of clusters (parameter for soft clustering) and the final number of segments. Intuitively, the number of clusters represents the number of levels of a segmentation by clustering facets that have close SDF values without considering their connectivity. However, a large number of clusters is likely to result in detailed segmentation of the mesh with a large number of segments, see <ref refid="index_1fig__Segmentation_levels" kindref="member">fig__Segmentation_levels</ref>.</para></simplesect>
<anchor id="index_1fig__Segmentation_levels"/><image type="html" name="effect_of_levels.png"></image>
 <image type="latex" name="effect_of_levels.png" width="15cm"></image>
  <ref refid="index_1fig__Segmentation_levels" kindref="member">fig__Segmentation_levels</ref> Influence of the number of clusters over the segmentation. The number of clusters are set to 4, 3, and 2 respectively.  <linebreak/>
</para><para>The output of this procedure is a matrix that contains probability values for each facet to belong to each cluster. These probability values are used as input to the hard clustering.</para></sect2>
<sect2 id="index_1Surface_mesh_segmentationGraphCut">
<title>Hard clustering</title>
<para>The hard clustering yields the final segmentation of the input mesh and results from minimizing an energy function combining the aforementioned probability matrix and geometric surface features.</para><para>The energy function minimized using alpha-expansion graph cut algorithm <ref refid="citelist_1CITEREF_Boykov2001FastApproximate" kindref="member">[2]</ref> is defined as follows:</para><para><table rows="1" cols="2"><row>
<entry thead="no"><para><formula id="8">$ E(\bar{x}) = \sum\limits_{f \in F} e_1(f, x_f) + \lambda \sum\limits_{ \{f,g\} \in N} e_2(x_f, x_g) $</formula></para><para><formula id="9">$ e_1(f, x_f) = -log(max(P(f|x_f), \epsilon)) $</formula></para><para><formula id="10">$ e_2(x_f, x_g) = \left \{ \begin{array}{rl} -log(\theta(f,g)/\pi) &amp;\mbox{ $x_f \ne x_g$} \\ 0 &amp;\mbox{ $x_f = x_g$} \end{array} \right \} $</formula>  </para></entry><entry thead="no"><para>where:<itemizedlist>
<listitem><para><formula id="11">$F$</formula> denotes the set of facets,</para></listitem><listitem><para><formula id="12">$N$</formula> denotes the set of pairs of neighboring facets,</para></listitem><listitem><para><formula id="13">$x_f$</formula> denotes the cluster assigned to facet <formula id="14">$f$</formula>,</para></listitem><listitem><para><formula id="15">$P(f|x_p)$</formula> denotes the probability of assigning facet <formula id="14">$f$</formula> to cluster <formula id="16">$x_p$</formula>,</para></listitem><listitem><para><formula id="17">$\theta(f,g)$</formula> denotes the dihedral angle between neighboring facets <formula id="14">$f$</formula> and <formula id="18">$g$</formula>: concave angles and convex angles are weighted by 1 and 0.1 respectively,</para></listitem><listitem><para><formula id="19">$\epsilon$</formula> denotes the minimal probability threshold,</para></listitem><listitem><para><formula id="20">$\lambda \in [0,1]$</formula> denotes a smoothness parameter.   </para></listitem></itemizedlist>
</para></entry></row>
</table>
</para><para>The first term of the energy function provides the contribution of the soft clustering probabilities. The second term of the energy function is a geometric criterion that is larger when two adjacent facets sharing a sharp and concave edge are in the same cluster. The smoothness parameter makes this geometric criteria more or less prevalent.</para><para>Assigning a high value to the smoothness parameter results in a small number of segments (since constructing a segment boundary would be expensive). In other words, merging facets that are placed under different clusters is less expensive than separating them and creating boundaries. On the contrary, assigning smaller values to smoothness parameter results in a high number of segments, by getting closer to the result of the soft clustering (notice that setting <formula id="21">$ \lambda=0 $</formula> provides the result of the soft clustering). <ref refid="index_1fig__Segmentation_lambdas" kindref="member">fig__Segmentation_lambdas</ref> depicts the influence of the smoothness parameter.</para><para><anchor id="index_1fig__Segmentation_lambdas"/><image type="html" name="dino_different_lambda_small.png"></image>
 <image type="latex" name="dino_different_lambda_small.png" width="15cm"></image>
  <ref refid="index_1fig__Segmentation_lambdas" kindref="member">fig__Segmentation_lambdas</ref> Influence of the smoothness parameter lambda over the segmentation (using 10 clusters). Smoothness parameters are set to 0.0, 0.1, 0.25, 0.5 and 1.0 respectively. The coloring reflects the segmentation result before assigning each connected component to its own segment.  <linebreak/>
</para><para>The hard clustering assigns a cluster id to each facet (see <ref refid="index_1fig__Cluster_vs_segment" kindref="member">fig__Cluster_vs_segment</ref> (a)). A segment consists in a set of connected facets in the same cluster (see <ref refid="index_1fig__Cluster_vs_segment" kindref="member">fig__Cluster_vs_segment</ref> (b)). By default the function <computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">segmentation_from_sdf_values()</ref></computeroutput> assigns to each facet the id of its segment. It assigns to each facet the id of its cluster when <computeroutput>output_cluster_ids</computeroutput> is set to <computeroutput>true</computeroutput>.</para><para><anchor id="index_1fig__Cluster_vs_segment"/><image type="html" name="cluster_vs_segment.png"></image>
 <image type="latex" name="cluster_vs_segment.png" width="15cm"></image>
  <ref refid="index_1fig__Cluster_vs_segment" kindref="member">fig__Cluster_vs_segment</ref> Clusters and segments. The input number of clusters is set to 5. <bold>(a)</bold> Result of the hard-clustering. <bold>(b)</bold> Segments are extracted from the computed clusters.  <linebreak/>
</para></sect2>
<sect2 id="index_1Surface_mesh_segmentationAPI">
<title>Summary</title>
<para>Four functions are provided:<itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">sdf_values()</ref></computeroutput> : computes the SDF value of each facet of an input mesh in either raw or post-processed form. SDF values are associated to facets using a property map (see <ref refid="index_1Chapter_CGAL_and_Boost_Property_Maps" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Property_map.tag">CGAL and Boost Property Maps</ref>).</para></listitem><listitem><para><computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga392cbdd609e2ba8cacf7f2af8e86c631" kindref="member">sdf_values_postprocessing()</ref></computeroutput> : post-processes raw SDF values. The post-processing is decoupled from the function <computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">sdf_values()</ref></computeroutput> to allow the use of alternative methods to compute SDF values or additional post-processing step.</para></listitem><listitem><para><computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">segmentation_from_sdf_values()</ref></computeroutput> : computes the mesh segmentation from the SDF values of the facets of an input mesh. The input SDF values can be any set of scalar values associated to each facet as long as they have been normalized between 0 and 1. This function allows using the same SDF values with different parameters for the segmentation stage. The segment or cluster ids are associated to the facets using a property map.</para></listitem><listitem><para><computeroutput><ref refid="group__PkgSurfaceSegmentation_1gabc864f396347009726b858434c6d8659" kindref="member">segmentation_via_sdf_values()</ref></computeroutput> : combines the three functions above.</para></listitem></itemizedlist>
</para><para>These functions expect as input a triangulated surface mesh bounding a 3D solid object, with the following properties:<itemizedlist>
<listitem><para>Combinatorially 2-manifold;</para></listitem><listitem><para>The vertices of the facets are oriented counterclockwise when seen from outside of the object;</para></listitem><listitem><para>Intersection-free;</para></listitem><listitem><para>Boundary free.</para></listitem></itemizedlist>
</para><para><simplesect kind="note"><para>The current implementation executes fine on meshes that do not match some of these properties but may produce unreliable or meaningless segmentations.</para></simplesect>
The current implementation of the computation of the SDF values relies on the <ref refid="packages_1PkgAABB_treeSummary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">3D Fast Intersection and Distance Computation</ref> package. This operation is reliable when the <computeroutput><ref refid="classAABBTraits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/AABB_tree.tag">AABBTraits</ref></computeroutput> model provided has exact predicates. <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref></computeroutput> is recommended as geometric traits for this algorithm.</para></sect2>
</sect1>
<sect1 id="index_1SDFExamples">
<title>Examples</title>
<sect2 id="index_1Example_1">
<title>Example: Computation of SDF Values</title>
<para><linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_segmentation_2sdf_values_example_8cpp-example" kindref="compound">Surface_mesh_segmentation/sdf_values_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/mesh_segmentation.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Polyhedron_3&lt;Kernel&gt;<sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>and<sp/>read<sp/>Polyhedron</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyhedron<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>input(</highlight><highlight class="stringliteral">&quot;data/cactus.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!input<sp/>||<sp/>!(input<sp/>&gt;&gt;<sp/>mesh)<sp/>||<sp/>mesh.empty()<sp/>||<sp/>(<sp/>!<ref refid="group__PkgBGLHelperFct_1ga11883d231eec1b58f37efe4acedd9588" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">CGAL::is_triangle_mesh</ref>(mesh))<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Input<sp/>is<sp/>not<sp/>a<sp/>triangle<sp/>mesh&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>property-map</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::map&lt;Polyhedron::Facet_const_handle,<sp/>double&gt;<sp/>Facet_double_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Facet_double_map<sp/>internal_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::associative_property_map&lt;Facet_double_map&gt;<sp/>sdf_property_map(internal_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>SDF<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::pair&lt;double,<sp/>double&gt;<sp/>min_max_sdf<sp/>=<sp/><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">CGAL::sdf_values</ref>(mesh,<sp/>sdf_property_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>It<sp/>is<sp/>possible<sp/>to<sp/>compute<sp/>the<sp/>raw<sp/>SDF<sp/>values<sp/>and<sp/>post-process<sp/>them<sp/>using</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>following<sp/>lines:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>std::size_t<sp/>number_of_rays<sp/>=<sp/>25;<sp/><sp/>//<sp/>cast<sp/>25<sp/>rays<sp/>per<sp/>facet</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>double<sp/>cone_angle<sp/>=<sp/>2.0<sp/>/<sp/>3.0<sp/>*<sp/>CGAL_PI;<sp/>//<sp/>set<sp/>cone<sp/>opening-angle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>CGAL::sdf_values(mesh,<sp/>sdf_property_map,<sp/>cone_angle,<sp/>number_of_rays,<sp/>false);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>std::pair&lt;double,<sp/>double&gt;<sp/>min_max_sdf<sp/>=</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>CGAL::sdf_values_postprocessing(mesh,<sp/>sdf_property_map);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>minimum<sp/>&amp;<sp/>maximum<sp/>SDF<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;minimum<sp/>SDF:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>min_max_sdf.first</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>maximum<sp/>SDF:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>min_max_sdf.second<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>SDF<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Polyhedron::Facet_const_iterator<sp/>facet_it<sp/>=<sp/>mesh.facets_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>facet_it<sp/>!=<sp/>mesh.facets_end();<sp/>++facet_it)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>sdf_property_map[facet_it]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Example_2">
<title>Example: Segmentation from SDF Values</title>
<para><linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_segmentation_2segmentation_from_sdf_values_example_8cpp-example" kindref="compound">Surface_mesh_segmentation/segmentation_from_sdf_values_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/mesh_segmentation.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Polyhedron_3&lt;Kernel&gt;<sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>and<sp/>read<sp/>Polyhedron</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>input(</highlight><highlight class="stringliteral">&quot;data/cactus.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!input<sp/>||<sp/>!(input<sp/>&gt;&gt;<sp/>mesh)<sp/>||<sp/>mesh.empty()<sp/><sp/>||<sp/>(<sp/>!<ref refid="group__PkgBGLHelperFct_1ga11883d231eec1b58f37efe4acedd9588" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">CGAL::is_triangle_mesh</ref>(mesh)))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Input<sp/>is<sp/>not<sp/>a<sp/>triangle<sp/>mesh.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>property-map<sp/>for<sp/>SDF<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::map&lt;Polyhedron::Facet_const_handle,<sp/>double&gt;<sp/>Facet_double_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Facet_double_map<sp/>internal_sdf_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::associative_property_map&lt;Facet_double_map&gt;<sp/>sdf_property_map(internal_sdf_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>SDF<sp/>values<sp/>using<sp/>default<sp/>parameters<sp/>for<sp/>number<sp/>of<sp/>rays,<sp/>and<sp/>cone<sp/>angle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">CGAL::sdf_values</ref>(mesh,<sp/>sdf_property_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>property-map<sp/>for<sp/>segment-ids</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::map&lt;Polyhedron::Facet_const_handle,<sp/>std::size_t&gt;<sp/>Facet_int_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Facet_int_map<sp/>internal_segment_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::associative_property_map&lt;Facet_int_map&gt;<sp/>segment_property_map(internal_segment_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>segment<sp/>the<sp/>mesh<sp/>using<sp/>default<sp/>parameters<sp/>for<sp/>number<sp/>of<sp/>levels,<sp/>and<sp/>smoothing<sp/>lambda</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Any<sp/>other<sp/>scalar<sp/>values<sp/>can<sp/>be<sp/>used<sp/>instead<sp/>of<sp/>using<sp/>SDF<sp/>values<sp/>computed<sp/>using<sp/>the<sp/>CGAL<sp/>function</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::size_t<sp/>number_of_segments<sp/>=<sp/><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">CGAL::segmentation_from_sdf_values</ref>(mesh,<sp/>sdf_property_map,<sp/>segment_property_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>segments:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>number_of_segments<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>segment-ids</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Polyhedron::Facet_const_iterator<sp/>facet_it<sp/>=<sp/>mesh.facets_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>facet_it<sp/>!=<sp/>mesh.facets_end();<sp/>++facet_it)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>ids<sp/>are<sp/>between<sp/>[0,<sp/>number_of_segments<sp/>-1]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>segment_property_map[facet_it]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>number_of_clusters<sp/>=<sp/>4;<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>use<sp/>4<sp/>clusters<sp/>in<sp/>soft<sp/>clustering</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>smoothing_lambda<sp/>=<sp/>0.3;<sp/><sp/></highlight><highlight class="comment">//<sp/>importance<sp/>of<sp/>surface<sp/>features,<sp/>suggested<sp/>to<sp/>be<sp/>in-between<sp/>[0,1]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>we<sp/>can<sp/>use<sp/>the<sp/>same<sp/>SDF<sp/>values<sp/>(sdf_property_map)<sp/>over<sp/>and<sp/>over<sp/>again<sp/>for<sp/>segmentation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>feature<sp/>is<sp/>relevant<sp/>for<sp/>segmenting<sp/>the<sp/>mesh<sp/>several<sp/>times<sp/>with<sp/>different<sp/>parameters.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">CGAL::segmentation_from_sdf_values</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mesh,<sp/>sdf_property_map,<sp/>segment_property_map,<sp/>number_of_clusters,<sp/>smoothing_lambda);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><sect3 id="index_1Example_3">
<title>Computation of SDF Values and Segmentation</title>
<para>The function <computeroutput><ref refid="group__PkgSurfaceSegmentation_1gabc864f396347009726b858434c6d8659" kindref="member">segmentation_via_sdf_values()</ref></computeroutput> combines the computation of sdf values, the post-processing and the segmentation. Note that when computing several segmentations of a mesh with different parameters (i.e. number of levels, and smoothing lambda), it is advised to first compute the SDF values using <computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">sdf_values()</ref></computeroutput> and use them in calls of the function <computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">segmentation_from_sdf_values()</ref></computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_segmentation_2segmentation_via_sdf_values_example_8cpp-example" kindref="compound">Surface_mesh_segmentation/segmentation_via_sdf_values_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/mesh_segmentation.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Polyhedron_3&lt;Kernel&gt;<sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>and<sp/>read<sp/>Polyhedron</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>input(</highlight><highlight class="stringliteral">&quot;data/cactus.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!input<sp/>||<sp/>!(input<sp/>&gt;&gt;<sp/>mesh)<sp/>||<sp/>mesh.empty()<sp/>||<sp/>(<sp/>!<ref refid="group__PkgBGLHelperFct_1ga11883d231eec1b58f37efe4acedd9588" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">CGAL::is_triangle_mesh</ref>(mesh))<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Input<sp/>is<sp/>not<sp/>a<sp/>triangle<sp/>mesh&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>property-map<sp/>for<sp/>segment-ids</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::map&lt;Polyhedron::Facet_const_handle,<sp/>std::size_t&gt;<sp/>Facet_int_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Facet_int_map<sp/>internal_segment_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::associative_property_map&lt;Facet_int_map&gt;<sp/>segment_property_map(internal_segment_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>calculate<sp/>SDF<sp/>values<sp/>and<sp/>segment<sp/>the<sp/>mesh<sp/>using<sp/>default<sp/>parameters.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::size_t<sp/>number_of_segments<sp/>=<sp/><ref refid="group__PkgSurfaceSegmentation_1gabc864f396347009726b858434c6d8659" kindref="member">CGAL::segmentation_via_sdf_values</ref>(mesh,<sp/>segment_property_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>segments:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>number_of_segments<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>segment-ids</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Polyhedron::Facet_const_iterator<sp/>facet_it<sp/>=<sp/>mesh.facets_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>facet_it<sp/>!=<sp/>mesh.facets_end();<sp/>++facet_it)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>segment_property_map[facet_it]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
</sect2>
<sect2 id="index_1Surface_mesh_segmentationUsingapolyhedron">
<title>Using a Polyhedron with an ID per Facet</title>
<para>The previous examples use a <computeroutput>std::map</computeroutput> as property maps for storing the SDF values and the segmentation results. This example uses a polyhedron type with a facet type storing an extra ID field, together with a vector, as underlying data structure in the property maps. The main advantage is to decrease from log to constant the complexity for accessing the data associated to facets.</para><para><linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_segmentation_2segmentation_with_facet_ids_example_8cpp-example" kindref="compound">Surface_mesh_segmentation/segmentation_with_facet_ids_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_items_with_id_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/mesh_segmentation.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Polyhedron_3&lt;K,<sp/>CGAL::Polyhedron_items_with_id_3&gt;<sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Property<sp/>map<sp/>associating<sp/>a<sp/>facet<sp/>with<sp/>an<sp/>integer<sp/>as<sp/>id<sp/>to<sp/>an</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>element<sp/>in<sp/>a<sp/>vector<sp/>stored<sp/>internally</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>ValueType&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Facet_with_id_pmap</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>boost::put_get_helper&lt;ValueType&amp;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Facet_with_id_pmap&lt;ValueType&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Polyhedron::Facet_const_handle<sp/>key_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>ValueType<sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>value_type&amp;<sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::lvalue_property_map_tag<sp/>category;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Facet_with_id_pmap(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;ValueType&gt;&amp;<sp/>internal_vector</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)<sp/>:<sp/>internal_vector(internal_vector)<sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reference<sp/>operator[](key_type<sp/>key)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>internal_vector[key-&gt;id()];<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;ValueType&gt;&amp;<sp/>internal_vector;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>and<sp/>read<sp/>Polyhedron</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>input(</highlight><highlight class="stringliteral">&quot;data/cactus.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!input<sp/>||<sp/>!(input<sp/>&gt;&gt;<sp/>mesh)<sp/>||<sp/>mesh.empty()<sp/>||<sp/>(<sp/>!<ref refid="group__PkgBGLHelperFct_1ga11883d231eec1b58f37efe4acedd9588" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">CGAL::is_triangle_mesh</ref>(mesh))<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Input<sp/>is<sp/>not<sp/>a<sp/>triangle<sp/>mesh&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>assign<sp/>id<sp/>field<sp/>for<sp/>each<sp/>facet</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::size_t<sp/>facet_id<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Polyhedron::Facet_iterator<sp/>facet_it<sp/>=<sp/>mesh.facets_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>facet_it<sp/>!=<sp/>mesh.facets_end();<sp/>++facet_it,<sp/>++facet_id)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>facet_it-&gt;id()<sp/>=<sp/>facet_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>property-map<sp/>for<sp/>SDF<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;double&gt;<sp/><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">sdf_values</ref>(mesh.size_of_facets());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Facet_with_id_pmap&lt;double&gt;<sp/>sdf_property_map(<ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">sdf_values</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">CGAL::sdf_values</ref>(mesh,<sp/>sdf_property_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>access<sp/>SDF<sp/>values<sp/>(with<sp/>constant-complexity)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Polyhedron::Facet_const_iterator<sp/>facet_it<sp/>=<sp/>mesh.facets_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>facet_it<sp/>!=<sp/>mesh.facets_end();<sp/>++facet_it)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>sdf_property_map[facet_it]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>property-map<sp/>for<sp/>segment-ids</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::size_t&gt;<sp/>segment_ids(mesh.size_of_facets());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Facet_with_id_pmap&lt;std::size_t&gt;<sp/>segment_property_map(segment_ids);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">CGAL::segmentation_from_sdf_values</ref>(mesh,<sp/>sdf_property_map,<sp/>segment_property_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>access<sp/>segment-ids<sp/>(with<sp/>constant-complexity)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Polyhedron::Facet_const_iterator<sp/>facet_it<sp/>=<sp/>mesh.facets_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>facet_it<sp/>!=<sp/>mesh.facets_end();<sp/>++facet_it)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>segment_property_map[facet_it]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Surface_mesh_segmentationUsingSM">
<title>Using a Surface_mesh</title>
<para>When using a <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput>, you can use the built-in property mechanism.</para><para><linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_segmentation_2segmentation_from_sdf_values_SM_example_8cpp-example" kindref="compound">Surface_mesh_segmentation/segmentation_from_sdf_values_SM_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/mesh_segmentation.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Point_3&gt;</ref><sp/>Mesh;<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Mesh&gt;::vertex_descriptor<sp/>vertex_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Mesh&gt;::face_descriptor<sp/>face_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Mesh&gt;::face_iterator<sp/>face_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mesh<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc==2){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>input(argv[1]);<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>input<sp/>&gt;&gt;<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>cactus(</highlight><highlight class="stringliteral">&quot;data/cactus.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cactus<sp/>&gt;&gt;<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="group__PkgBGLHelperFct_1ga11883d231eec1b58f37efe4acedd9588" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">CGAL::is_triangle_mesh</ref>(mesh)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Input<sp/>is<sp/>not<sp/>a<sp/>triangle<sp/>mesh&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Mesh::Property_map&lt;face_descriptor,double&gt;<sp/>Facet_double_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Facet_double_map<sp/>sdf_property_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sdf_property_map<sp/>=<sp/>mesh.add_property_map&lt;face_descriptor,</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;f:sdf&quot;</highlight><highlight class="normal">).first;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>SDF<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>can&apos;t<sp/>use<sp/>default<sp/>parameters<sp/>for<sp/>number<sp/>of<sp/>rays,<sp/>and<sp/>cone<sp/>angle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>the<sp/>postprocessing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">CGAL::sdf_values</ref>(mesh,<sp/>sdf_property_map,<sp/>2.0<sp/>/<sp/>3.0<sp/>*<sp/>CGAL_PI,<sp/>25,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>property-map<sp/>for<sp/>segment-ids</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Mesh::Property_map&lt;face_descriptor,<sp/>std::size_t&gt;<sp/>Facet_int_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Facet_int_map<sp/>segment_property_map<sp/>=<sp/>mesh.add_property_map&lt;face_descriptor,std::size_t&gt;(</highlight><highlight class="stringliteral">&quot;f:sid&quot;</highlight><highlight class="normal">).first;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>segment<sp/>the<sp/>mesh<sp/>using<sp/>default<sp/>parameters<sp/>for<sp/>number<sp/>of<sp/>levels,<sp/>and<sp/>smoothing<sp/>lambda</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Any<sp/>other<sp/>scalar<sp/>values<sp/>can<sp/>be<sp/>used<sp/>instead<sp/>of<sp/>using<sp/>SDF<sp/>values<sp/>computed<sp/>using<sp/>the<sp/>CGAL<sp/>function</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>number_of_segments<sp/>=<sp/><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">CGAL::segmentation_from_sdf_values</ref>(mesh,<sp/>sdf_property_map,<sp/>segment_property_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>segments:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>number_of_segments<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>segment-ids</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>face_iterator<sp/>facet_it,<sp/>fend;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BOOST_FOREACH(face_descriptor<sp/>fd,<sp/>faces(mesh)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>ids<sp/>are<sp/>between<sp/>[0,<sp/>number_of_segments<sp/>-1]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>segment_property_map[fd]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>number_of_clusters<sp/>=<sp/>4;<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>use<sp/>4<sp/>clusters<sp/>in<sp/>soft<sp/>clustering</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>smoothing_lambda<sp/>=<sp/>0.3;<sp/><sp/></highlight><highlight class="comment">//<sp/>importance<sp/>of<sp/>surface<sp/>features,<sp/>suggested<sp/>to<sp/>be<sp/>in-between<sp/>[0,1]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>we<sp/>can<sp/>use<sp/>the<sp/>same<sp/>SDF<sp/>values<sp/>(sdf_property_map)<sp/>over<sp/>and<sp/>over<sp/>again<sp/>for<sp/>segmentation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>feature<sp/>is<sp/>relevant<sp/>for<sp/>segmenting<sp/>the<sp/>mesh<sp/>several<sp/>times<sp/>with<sp/>different<sp/>parameters.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">CGAL::segmentation_from_sdf_values</ref>(mesh,<sp/>sdf_property_map,<sp/>segment_property_map,<sp/>number_of_clusters,<sp/>smoothing_lambda);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Surface_mesh_segmentationIndependantmeshpersegment">
<title>Independant TriangleMesh per Segment</title>
<para>It is possible to consider each segment as an independant triangle mesh, like in the following example, where the area of each segment is computed.</para><para><linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_segmentation_2extract_segmentation_into_mesh_example_8cpp-example" kindref="compound">Surface_mesh_segmentation/extract_segmentation_into_mesh_example.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/graph_traits_Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/Face_filtered_graph.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygon_mesh_processing/measure.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/copy_face_graph.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/mesh_segmentation.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;sstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</ref><sp/>SM;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;SM&gt;::face_descriptor<sp/>face_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SM<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc==2){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>input(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>input<sp/>&gt;&gt;<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>cactus(</highlight><highlight class="stringliteral">&quot;data/cactus.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cactus<sp/>&gt;&gt;<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>SM::Property_map&lt;face_descriptor,double&gt;<sp/>Facet_double_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Facet_double_map<sp/>sdf_property_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sdf_property_map<sp/>=<sp/>mesh.add_property_map&lt;face_descriptor,</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;f:sdf&quot;</highlight><highlight class="normal">).first;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">CGAL::sdf_values</ref>(mesh,<sp/>sdf_property_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>property-map<sp/>for<sp/>segment-ids</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>SM::Property_map&lt;face_descriptor,<sp/>std::size_t&gt;<sp/>Facet_int_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Facet_int_map<sp/>segment_property_map<sp/>=<sp/>mesh.add_property_map&lt;face_descriptor,std::size_t&gt;(</highlight><highlight class="stringliteral">&quot;f:sid&quot;</highlight><highlight class="normal">).first;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>segment<sp/>the<sp/>mesh<sp/>using<sp/>default<sp/>parameters<sp/>for<sp/>number<sp/>of<sp/>levels,<sp/>and<sp/>smoothing<sp/>lambda</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Any<sp/>other<sp/>scalar<sp/>values<sp/>can<sp/>be<sp/>used<sp/>instead<sp/>of<sp/>using<sp/>SDF<sp/>values<sp/>computed<sp/>using<sp/>the<sp/>CGAL<sp/>function</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>number_of_segments<sp/>=<sp/><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">CGAL::segmentation_from_sdf_values</ref>(mesh,<sp/>sdf_property_map,<sp/>segment_property_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Face__filtered__graph" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">CGAL::Face_filtered_graph&lt;SM&gt;</ref><sp/>Filtered_graph;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//print<sp/>area<sp/>of<sp/>each<sp/>segment<sp/>and<sp/>then<sp/>put<sp/>it<sp/>in<sp/>a<sp/>Mesh<sp/>and<sp/>print<sp/>it<sp/>in<sp/>an<sp/>OFF<sp/>file</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Filtered_graph<sp/>segment_mesh(mesh,<sp/>0,<sp/>segment_property_map);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::size_t<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>=<sp/>0;<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>&lt;<sp/>number_of_segments;<sp/>++id)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>segment_mesh.set_selected_faces(</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/>segment_property_map);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Segment<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">&lt;&lt;</highlight><highlight class="stringliteral">&quot;&apos;s<sp/>area<sp/>is<sp/>:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<ref refid="group__area__grp_1gad5b975e731751609655f88d287f7385a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Polygon_mesh_processing::area</ref>(segment_mesh)&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SM<sp/>out;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBGLHelperFct_1ga2d3eb044bfe42eab566779ce32216c11" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">CGAL::copy_face_graph</ref>(segment_mesh,<sp/>out);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ostringstream<sp/>oss;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>oss<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Segment_&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">&lt;&lt;</highlight><highlight class="stringliteral">&quot;.off&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ofstream<sp/>os(oss.str().data());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>os&lt;&lt;out;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><linebreak/>
 </para></sect2>
</sect1>
<sect1 id="index_1Performances">
<title>Performances</title>
<para>The following tables provide the runtime of the functions <computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">sdf_values()</ref></computeroutput> and <computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">segmentation_from_sdf_values()</ref></computeroutput>. The results were produced with the release 4.4 of CGAL, on an Intel i7 3.2 Ghz laptop with 8 GB RAM, compiled by Visual C++ 2010 with /O2 option. The polyhedron types are using <computeroutput><ref refid="classCGAL_1_1Polyhedron__items__with__id__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag">Polyhedron_items_with_id_3</ref></computeroutput> as item class. The models used for the benchmarks are the <emphasis>dinosaur</emphasis> model with 7,828 facets, the <emphasis>bear</emphasis> model with 20,188 facets and the <emphasis>elephant</emphasis> model with 88,928 facets.</para><para>Runtime in seconds of <computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga42c20ac00cd54fb258c8d98fb5673925" kindref="member">sdf_values()</ref></computeroutput> with 25 rays showing the cost of the robustness:</para><para><center> <table rows="4" cols="3"><row>
<entry thead="yes"><para>Number of triangles </para></entry><entry thead="yes"><para><computeroutput>Simple_cartesian&lt;double&gt;</computeroutput> </para></entry><entry thead="yes"><para><computeroutput>Exact_predicates_inexact_constructions_kernel</computeroutput> (<computeroutput>EPICK</computeroutput>)  </para></entry></row>
<row>
<entry thead="no"><para>7,828 </para></entry><entry thead="no"><para>2.3 </para></entry><entry thead="no"><para>3.8 </para></entry></row>
<row>
<entry thead="no"><para>20,188 </para></entry><entry thead="no"><para>6.1 </para></entry><entry thead="no"><para>9.5 </para></entry></row>
<row>
<entry thead="no"><para>88,928 </para></entry><entry thead="no"><para>46.1 </para></entry><entry thead="no"><para>62.3 </para></entry></row>
</table>
</center></para><para>Runtime in milliseconds of <computeroutput><ref refid="group__PkgSurfaceSegmentation_1ga8a429857a748922d0e8460619db69764" kindref="member">segmentation_from_sdf_values()</ref></computeroutput> (using <computeroutput>Simple_cartesian&lt;double&gt;</computeroutput> or <computeroutput>EPICK</computeroutput> gives the same results), the graph-cut part is using the library <ulink url="http://pub.ist.ac.at/~vnk/software.html">MaxFlow</ulink> v2.21:</para><para><center> <table rows="4" cols="5"><row>
<entry thead="yes"><para>Number of triangles </para></entry><entry thead="yes"><para>Number of cluster = 2 </para></entry><entry thead="yes"><para>Number of cluster = 5 </para></entry><entry thead="yes"><para>Number of cluster = 10 </para></entry><entry thead="yes"><para>Number of cluster = 15  </para></entry></row>
<row>
<entry thead="no"><para>7,828 </para></entry><entry thead="no"><para>38 </para></entry><entry thead="no"><para>61 </para></entry><entry thead="no"><para>141 </para></entry><entry thead="no"><para>204 </para></entry></row>
<row>
<entry thead="no"><para>20,188 </para></entry><entry thead="no"><para>50 </para></entry><entry thead="no"><para>163 </para></entry><entry thead="no"><para>483 </para></entry><entry thead="no"><para>608 </para></entry></row>
<row>
<entry thead="no"><para>88,928 </para></entry><entry thead="no"><para>314 </para></entry><entry thead="no"><para>1,260 </para></entry><entry thead="no"><para>2,736 </para></entry><entry thead="no"><para>4,239 </para></entry></row>
</table>
</center></para></sect1>
<sect1 id="index_1Surface_mesh_segmentationImplementationhistory">
<title>Design and Implementation History</title>
<para>The initial implementation of this package is the result of the work of Ilker O. Yaz during the 2012 season of the Google Summer of Code. He has been mentored by SÃ©bastien Loriot who also contributed to the documentation and the API definition. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
