<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Geometric_Object_Generators"/><anchor id="index_1chapterGenerators"/> <simplesect kind="authors"><para>Pedro M. M. de Castro, Olivier Devillers, Susan Hert, Michael Hoffmann, Lutz Kettner, Sven Sch<oumlaut/>nherr, Alexandru Tifrea, and Maxime Gimeno</para></simplesect>
</para><sect1 id="index_1GeneratorIntroduction">
<title>Introduction</title>
<para>A variety of generators for geometric objects are provided in CGAL. They are useful as synthetic test data sets, e.g. for testing algorithms on degenerate object sets and for performance analysis.</para><para>Two kinds of point generators are provided: first, random point generators and second deterministic point generators. Most random point generators and a few deterministic point generators are provided as input iterators. The input iterators model an infinite sequence of points. The function <computeroutput><ref refid="group__STLAlgos_1gacb8df77d1d07b9cfff3fdd2f5d9c4fda" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::copy_n()</ref></computeroutput> can be used to copy a finite sequence. The iterator adaptor <computeroutput><ref refid="classCGAL_1_1Counting__iterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Counting_iterator</ref></computeroutput> can be used to create finite iterator ranges. Other generators are provided as functions that write to output iterators. Further functions add degeneracies or random perturbations.</para><para>In 2D, we provide input iterators to generate random points in a disc (<computeroutput><ref refid="classCGAL_1_1Random__points__in__disc__2" kindref="compound">Random_points_in_disc_2</ref></computeroutput>), in a square (<computeroutput><ref refid="classCGAL_1_1Random__points__in__square__2" kindref="compound">Random_points_in_square_2</ref></computeroutput>), on a circle (<computeroutput><ref refid="classCGAL_1_1Random__points__on__circle__2" kindref="compound">Random_points_on_circle_2</ref></computeroutput>), on a segment (<computeroutput>Random_points_on_segment</computeroutput>), in a square (<computeroutput><ref refid="classCGAL_1_1Random__points__on__square__2" kindref="compound">Random_points_on_square_2</ref></computeroutput>), in a triangle (<computeroutput><ref refid="classCGAL_1_1Random__points__in__triangle__2" kindref="compound">Random_points_in_triangle_2</ref></computeroutput>), in a range of triangles (<computeroutput><ref refid="structCGAL_1_1Random__points__in__triangles__2" kindref="compound">Random_points_in_triangles_2</ref></computeroutput>), and in a triangle mesh (<computeroutput><ref refid="classCGAL_1_1Random__points__in__triangle__mesh__2" kindref="compound">Random_points_in_triangle_mesh_2</ref></computeroutput>). For generating grid points we provide three functions, <computeroutput><ref refid="group__PkgGenerators_1ga58b8faf4c090fc9b367f51d9004cde4c" kindref="member">points_on_segment_2()</ref></computeroutput>, <computeroutput><ref refid="group__PkgGenerators_1gad5aec033ff62776826bd5b01be41b792" kindref="member">points_on_square_grid_2()</ref></computeroutput> that write to output iterators and an input iterator <computeroutput><ref refid="classCGAL_1_1Points__on__segment__2" kindref="compound">Points_on_segment_2</ref></computeroutput>.</para><para>For 3D points, input iterators are provided for random points uniformly distributed in a sphere (<computeroutput><ref refid="classCGAL_1_1Random__points__in__sphere__3" kindref="compound">Random_points_in_sphere_3</ref></computeroutput>), in a triangle (<computeroutput><ref refid="classCGAL_1_1Random__points__in__triangle__3" kindref="compound">Random_points_in_triangle_3</ref></computeroutput>), in a range of triangles (<computeroutput><ref refid="structCGAL_1_1Random__points__in__triangles__3" kindref="compound">Random_points_in_triangles_3</ref></computeroutput>), in a tetrahedron (<computeroutput><ref refid="classCGAL_1_1Random__points__in__tetrahedron__3" kindref="compound">Random_points_in_tetrahedron_3</ref></computeroutput>), in a cube (<computeroutput><ref refid="classCGAL_1_1Random__points__in__cube__3" kindref="compound">Random_points_in_cube_3</ref></computeroutput>), on the boundary of a sphere (<computeroutput><ref refid="classCGAL_1_1Random__points__on__sphere__3" kindref="compound">Random_points_on_sphere_3</ref></computeroutput>), in a triangle mesh (<computeroutput><ref refid="structCGAL_1_1Random__points__in__triangle__mesh__3" kindref="compound">Random_points_in_triangle_mesh_3</ref></computeroutput>), in a tetrahedron mesh (<computeroutput><ref refid="classCGAL_1_1Random__points__in__tetrahedral__mesh__3" kindref="compound">Random_points_in_tetrahedral_mesh_3</ref></computeroutput>), and on the boundary of a tetrahedron mesh (<computeroutput><ref refid="classCGAL_1_1Random__points__in__tetrahedral__mesh__boundary__3" kindref="compound">Random_points_in_tetrahedral_mesh_boundary_3</ref></computeroutput>). For generating 3D grid points, we provide the function <computeroutput><ref refid="group__PkgGenerators_1ga03437b3f68ee130c2438a0ab29511695" kindref="member">points_on_cube_grid_3()</ref></computeroutput> that writes to an output iterator.</para><para>For higher dimensions, input iterators are provided for random points uniformly distributed in a <computeroutput>d</computeroutput>-dimensional cube (<computeroutput><ref refid="classCGAL_1_1Random__points__in__cube__d" kindref="compound">Random_points_in_cube_d</ref></computeroutput>) or <computeroutput>d</computeroutput>-dimensional ball (<computeroutput><ref refid="classCGAL_1_1Random__points__in__ball__d" kindref="compound">Random_points_in_ball_d</ref></computeroutput>) or on the boundary of a sphere (<computeroutput><ref refid="classCGAL_1_1Random__points__on__sphere__d" kindref="compound">Random_points_on_sphere_d</ref></computeroutput>). For generating grid points, we provide the function <computeroutput><ref refid="group__PkgGenerators_1ga3c1b105fd97be68c3331b397b6e6ebe9" kindref="member">points_on_cube_grid_d()</ref></computeroutput> that writes to an output iterator.</para><para>We also provide two functions for generating more complex geometric objects. The function <computeroutput><ref refid="group__PkgGenerators_1ga48fe050c898078e688376009dc60b232" kindref="member">random_convex_set_2()</ref></computeroutput> computes a random convex planar point set of a given size where the points are drawn from a specific domain and <computeroutput><ref refid="group__PkgGenerators_1gaa8cb58e4cc9ab9e225808799b1a61174" kindref="member">random_polygon_2()</ref></computeroutput> generates a random simple polygon from points drawn from a specific domain. The function <computeroutput><ref refid="group__PkgGenerators_1ga55d4f2043b91c2870b5d4a6071d921f6" kindref="member">random_convex_hull_in_disc_2()</ref></computeroutput> computes a random polygon as a convex hull from uniformly generated random points in a disc.</para><sect2 id="index_1GeneratorRandomPerturbations">
<title>Random Perturbations</title>
<para>Degenerate input sets like grid points can be randomly perturbed by a small amount to produce <emphasis>quasi</emphasis>-degenerate test sets. This challenges numerical stability of algorithms using inexact arithmetic and exact predicates to compute the sign of expressions slightly off from zero. For this the function <computeroutput><ref refid="group__PkgGenerators_1gafacf70e214daa1206eb1e20b35bb8b64" kindref="member">perturb_points_2()</ref></computeroutput> is provided.</para></sect2>
<sect2 id="index_1GeneratorAddingDegeneracies">
<title>Adding Degeneracies</title>
<para>For a given point set certain kinds of degeneracies can be produced by adding new points. The <computeroutput><ref refid="group__PkgGenerators_1ga5931f8c3d40445dd776437d07a5058a1" kindref="member">random_selection()</ref></computeroutput> function is useful for generating multiple copies of identical points. The function <computeroutput><ref refid="group__PkgGenerators_1gae02cceaf04ecd42a5996b6b1b88be798" kindref="member">random_collinear_points_2()</ref></computeroutput> adds collinearities to a point set.</para></sect2>
<sect2 id="index_1GeneratorSupportFunctionsandClassesforGenerators">
<title>Support Functions and Classes for Generators</title>
<para>The function <computeroutput><ref refid="group__PkgGenerators_1ga5931f8c3d40445dd776437d07a5058a1" kindref="member">random_selection()</ref></computeroutput> chooses <computeroutput>n</computeroutput> items at random from a random access iterator range which is useful to produce degenerate input data sets with multiple entries of identical items.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Combination__enumerator" kindref="compound">Combination_enumerator</ref>&lt;<ref refid="classCombinationElement" kindref="compound">CombinationElement</ref>&gt;</computeroutput> is used to enumerate all fixed-size combinations (subsets) of a range of elements. It is useful in the context of high-dimensional triangulations, e.g., for enumerating the faces of a simplex.</para></sect2>
</sect1>
<sect1 id="index_1GeneratorExample_1">
<title>Example Generating Degenerate Point Sets</title>
<para>We want to generate a test set of 1000 points, where 60% are chosen randomly in a small disc, 20% are from a larger grid, 10% are duplicates points, and 10% collinear points. A random shuffle removes the construction order from the test set. See <ref refid="index_1fig__figurePointGenerator" kindref="member">fig__figurePointGenerator</ref> for the example output.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generator_2random_degenerate_point_set_8cpp-example" kindref="compound">Generator/random_degenerate_point_set.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/algorithm.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/random_selection.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL" kindref="compound">CGAL</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>R::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Creator_uniform_2&lt;double,Point&gt;</ref><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>test<sp/>point<sp/>set.<sp/>Prepare<sp/>a<sp/>vector<sp/>for<sp/>1000<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vector<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points.reserve(1000);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>600<sp/>points<sp/>within<sp/>a<sp/>disc<sp/>of<sp/>radius<sp/>150.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Random__points__in__disc__2" kindref="compound">Random_points_in_disc_2&lt;Point,Creator&gt;</ref><sp/>g(<sp/>150.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__STLAlgos_1gadba21cc5c30a79519438dfe0f9264255" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::copy_n</ref>(<sp/>g,<sp/>600,<sp/>std::back_inserter(points));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>200<sp/>points<sp/>from<sp/>a<sp/>15<sp/>x<sp/>15<sp/>grid.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgGenerators_1gad5aec033ff62776826bd5b01be41b792" kindref="member">points_on_square_grid_2</ref>(<sp/>250.0,<sp/>200,<sp/>std::back_inserter(points),Creator());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Select<sp/>100<sp/>points<sp/>randomly<sp/>and<sp/>append<sp/>them<sp/>at<sp/>the<sp/>end<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>current<sp/>vector<sp/>of<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgGenerators_1ga5931f8c3d40445dd776437d07a5058a1" kindref="member">random_selection</ref>(<sp/>points.begin(),<sp/>points.end(),<sp/>100,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(points));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>100<sp/>points<sp/>that<sp/>are<sp/>collinear<sp/>to<sp/>two<sp/>randomly<sp/>chosen</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>points<sp/>and<sp/>append<sp/>them<sp/>to<sp/>the<sp/>current<sp/>vector<sp/>of<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgGenerators_1gae02cceaf04ecd42a5996b6b1b88be798" kindref="member">random_collinear_points_2</ref>(<sp/>points.begin(),<sp/>points.end(),<sp/>100,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(<sp/>points));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>that<sp/>we<sp/>have<sp/>really<sp/>created<sp/>1000<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>points.size()<sp/>==<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>a<sp/>random<sp/>permutation<sp/>to<sp/>hide<sp/>the<sp/>creation<sp/>history</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>of<sp/>the<sp/>point<sp/>set.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__STLAlgos_1ga03da480625f380d4d06ea64de211add4" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp98::random_shuffle</ref>(<sp/>points.begin(),<sp/>points.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>range<sp/>of<sp/>values.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/>Vector::iterator<sp/>i<sp/>=<sp/>points.begin();<sp/>i<sp/>!=<sp/>points.end();<sp/>i++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>i-&gt;x()<sp/>&lt;=<sp/><sp/>251);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>i-&gt;x()<sp/>&gt;=<sp/>-251);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>i-&gt;y()<sp/>&lt;=<sp/><sp/>251);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>i-&gt;y()<sp/>&gt;=<sp/>-251);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__figurePointGenerator"/><image type="html" name="generators_prog1.png"></image>
 <image type="latex" name="generators_prog1.png" width="15cm"></image>
  <ref refid="index_1fig__figurePointGenerator" kindref="member">fig__figurePointGenerator</ref> Output of example program for point generators.  <linebreak/>
</para></sect1>
<sect1 id="index_1GeneratorExampleGridPoints">
<title>Example Generating Grid Points</title>
<para>The second example demonstrates the point generators with integer points. Floating point arithmetic is sufficient to produce regular integer grids. See <ref refid="index_1fig__figureIntegerPointGenerator" kindref="member">fig__figureIntegerPointGenerator</ref> for the example output.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generator_2random_grid_8cpp-example" kindref="compound">Generator/random_grid.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/algorithm.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL" kindref="compound">CGAL</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Simple_cartesian&lt;int&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Creator_uniform_2&lt;int,Point&gt;</ref><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>test<sp/>point<sp/>set.<sp/>Prepare<sp/>a<sp/>vector<sp/>for<sp/>400<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points.reserve(400);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>250<sp/>points<sp/>from<sp/>a<sp/>16<sp/>x<sp/>16<sp/>grid.<sp/>Note<sp/>that<sp/>the<sp/>double</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>arithmetic<sp/>_is_<sp/>sufficient<sp/>to<sp/>produce<sp/>exact<sp/>integer<sp/>grid<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>distance<sp/>between<sp/>neighbors<sp/>is<sp/>34<sp/>pixel<sp/>=<sp/>510<sp/>/<sp/>15.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgGenerators_1gad5aec033ff62776826bd5b01be41b792" kindref="member">points_on_square_grid_2</ref>(<sp/>255.0,<sp/>250,<sp/>std::back_inserter(points),Creator());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Lower,<sp/>left<sp/>corner.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>points[0].x()<sp/>==<sp/>-255);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>points[0].y()<sp/>==<sp/>-255);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Upper,<sp/>right<sp/>corner.<sp/>Note<sp/>that<sp/>6<sp/>points<sp/>are<sp/>missing<sp/>to<sp/>fill<sp/>the<sp/>grid.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>points[249].x()<sp/>==<sp/>255<sp/>-<sp/>6<sp/>*<sp/>34);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>points[249].y()<sp/>==<sp/>255);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>250<sp/>points<sp/>within<sp/>a<sp/>disc<sp/>of<sp/>radius<sp/>150.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Random__points__in__disc__2" kindref="compound">Random_points_in_disc_2&lt;Point,Creator&gt;</ref><sp/>g(<sp/>150.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__STLAlgos_1gadba21cc5c30a79519438dfe0f9264255" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::copy_n</ref>(<sp/>g,<sp/>250,<sp/>std::back_inserter(points));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>that<sp/>we<sp/>have<sp/>really<sp/>created<sp/>500<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>points.size()<sp/>==<sp/>500);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__figureIntegerPointGenerator"/><image type="html" name="generators_prog2.png"></image>
 <image type="latex" name="generators_prog2.png" width="15cm"></image>
  <ref refid="index_1fig__figureIntegerPointGenerator" kindref="member">fig__figureIntegerPointGenerator</ref> Output of example program for point generators working  <linebreak/>
</para></sect1>
<sect1 id="index_1GeneratorExample_mesh">
<title>Example Generating Random Point Sets On a Triangle Mesh</title>
<para>The following example demonstrates the use of the random point generator on a triangle mesh. We want to generate 100 points uniformly chosen on a <computeroutput>Polyhedron_3</computeroutput>. See <ref refid="index_1fig__figureMeshPointGenerator" kindref="member">fig__figureMeshPointGenerator</ref> <linebreak/>
<bold>File</bold> <ref refid="Generator_2random_points_on_triangle_mesh_3_8cpp-example" kindref="compound">Generator/random_points_on_triangle_mesh_3.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL" kindref="compound">CGAL</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Polyhedron_3&lt;K&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>Generated<sp/>points<sp/>are<sp/>in<sp/>that<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>input<sp/>polyhedron</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyhedron<sp/>polyhedron;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polyhedron.make_tetrahedron(Point(-1,0,0),<sp/>Point(0,1,0),<sp/>Point(1,0,0),<sp/>Point(0,0,-1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>the<sp/>generator,<sp/>input<sp/>is<sp/>the<sp/>Polyhedron<sp/>polyhedron</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="structCGAL_1_1Random__points__in__triangle__mesh__3" kindref="compound">Random_points_in_triangle_mesh_3&lt;Polyhedron&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>g(polyhedron);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>100<sp/>random<sp/>points<sp/>in<sp/>cdt</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__STLAlgos_1gadba21cc5c30a79519438dfe0f9264255" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::copy_n</ref>(g,<sp/>100,<sp/>std::back_inserter(points));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>that<sp/>we<sp/>have<sp/>really<sp/>created<sp/>100<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>points.size()<sp/>==<sp/>100);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>the<sp/>first<sp/>point<sp/>that<sp/>was<sp/>generated</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>points[0]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__figureMeshPointGenerator"/><image type="html" name="generator_mesh_3.png"></image>
 <image type="latex" name="generator_mesh_3.png" width="15cm"></image>
  <ref refid="index_1fig__figureMeshPointGenerator" kindref="member">fig__figureMeshPointGenerator</ref> Output of example program for point generator on a triangle mesh  <linebreak/>
</para></sect1>
<sect1 id="index_1secsegment_example">
<title>Examples Generating Segments</title>
<para>The following two examples illustrate the use of the generic functions from Section <ref refid="group__STLAlgos" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Generic Algorithms</ref> like <computeroutput><ref refid="classCGAL_1_1Join__input__iterator__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Join_input_iterator_2</ref></computeroutput> to generate composed objects from other generators - here two-dimensional segments from two point generators.</para><para>We want to generate a test set of 200 segments, where one endpoint is chosen randomly from a horizontal segment of length 200, and the other endpoint is chosen randomly from a circle of radius 250. See <ref refid="index_1fig__figureSegmentGenerator" kindref="member">fig__figureSegmentGenerator</ref> for the example output.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generator_2random_segments1_8cpp-example" kindref="compound">Generator/random_segments1.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Segment_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/function_objects.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Join_input_iterator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/algorithm.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL" kindref="compound">CGAL</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Creator_uniform_2&lt;double,Point&gt;</ref><sp/><sp/>Pt_creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Segment&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>test<sp/>segment<sp/>set.<sp/>Prepare<sp/>a<sp/>vector<sp/>for<sp/>200<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vector<sp/>segs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>segs.reserve(200);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Prepare<sp/>point<sp/>generator<sp/>for<sp/>the<sp/>horizontal<sp/>segment,<sp/>length<sp/>200.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Random__points__on__segment__2" kindref="compound">Random_points_on_segment_2&lt;Point,Pt_creator&gt;</ref><sp/><sp/>P1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P1<sp/>p1(<sp/>Point(-100,0),<sp/>Point(100,0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Prepare<sp/>point<sp/>generator<sp/>for<sp/>random<sp/>points<sp/>on<sp/>circle,<sp/>radius<sp/>250.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Random__points__on__circle__2" kindref="compound">Random_points_on_circle_2&lt;Point,Pt_creator&gt;</ref><sp/><sp/>P2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P2<sp/>p2(<sp/>250);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>200<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Creator_uniform_2&lt; Point, Segment&gt;</ref><sp/>Seg_creator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Join__input__iterator__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Join_input_iterator_2&lt; P1, P2, Seg_creator&gt;</ref><sp/>Seg_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Seg_iterator<sp/>g(<sp/>p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__STLAlgos_1gadba21cc5c30a79519438dfe0f9264255" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::cpp11::copy_n</ref>(<sp/>g,<sp/>200,<sp/>std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>segs.size()<sp/>==<sp/>200);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/>Vector::iterator<sp/>i<sp/>=<sp/>segs.begin();<sp/>i<sp/>!=<sp/>segs.end();<sp/>i++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert(<sp/>i-&gt;source().x()<sp/>&lt;=<sp/><sp/>100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert(<sp/>i-&gt;source().x()<sp/>&gt;=<sp/>-100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert(<sp/>i-&gt;source().y()<sp/>==<sp/><sp/><sp/><sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert(<sp/>i-&gt;target().x()<sp/>*<sp/>i-&gt;target().x()<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i-&gt;target().y()<sp/>*<sp/>i-&gt;target().y()<sp/>&lt;=<sp/><sp/>251*251);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert(<sp/>i-&gt;target().x()<sp/>*<sp/>i-&gt;target().x()<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i-&gt;target().y()<sp/>*<sp/>i-&gt;target().y()<sp/>&gt;=<sp/><sp/>249*249);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__figureSegmentGenerator"/><image type="html" name="Segment_generator_prog1.png"></image>
 <image type="latex" name="Segment_generator_prog1.png" width="15cm"></image>
  <ref refid="index_1fig__figureSegmentGenerator" kindref="member">fig__figureSegmentGenerator</ref> Output of example program for the generic segment generator.  <linebreak/>
</para><para>The second example generates a regular structure of 100 segments; see <ref refid="index_1fig__figureSegmentGeneratorFan" kindref="member">fig__figureSegmentGeneratorFan</ref> for the example output. It uses the <computeroutput><ref refid="classCGAL_1_1Points__on__segment__2" kindref="compound">Points_on_segment_2</ref></computeroutput> iterator, <computeroutput><ref refid="classCGAL_1_1Join__input__iterator__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Join_input_iterator_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Counting__iterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Counting_iterator</ref></computeroutput> to avoid any intermediate storage of the generated objects until they are used.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generator_2random_segments2_8cpp-example" kindref="compound">Generator/random_segments2.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>CGAL<sp/>example<sp/>program<sp/>for<sp/>the<sp/>generic<sp/>segment<sp/>generator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>using<sp/>precomputed<sp/>point<sp/>locations.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/function_objects.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Join_input_iterator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Counting_iterator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL" kindref="compound">CGAL</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Points__on__segment__2" kindref="compound">Points_on_segment_2&lt;Point&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PG;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Creator_uniform_2&lt; Point, Segment&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Join__input__iterator__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Join_input_iterator_2&lt; PG, PG, Creator&gt;</ref><sp/><sp/><sp/>Segm_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Counting__iterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Counting_iterator&lt;Segm_iterator,Segment&gt;</ref><sp/><sp/>Count_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Segment&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>test<sp/>segment<sp/>set.<sp/>Prepare<sp/>a<sp/>vector<sp/>for<sp/>100<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vector<sp/>segs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>segs.reserve(100);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>A<sp/>horizontal<sp/>like<sp/>fan.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PG<sp/>p1(<sp/>Point(-250,<sp/>-50),<sp/>Point(-250,<sp/>50),50);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Point<sp/>generator.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PG<sp/>p2(<sp/>Point(<sp/>250,-250),<sp/>Point(<sp/>250,250),50);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Segm_iterator<sp/><sp/>t1(<sp/>p1,<sp/>p2);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Segment<sp/>generator.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Count_iterator<sp/>t1_begin(<sp/>t1);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Finite<sp/>range.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Count_iterator<sp/>t1_end(<sp/>t1,<sp/>50);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::copy(<sp/>t1_begin,<sp/>t1_end,<sp/>std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>A<sp/>vertical<sp/>like<sp/>fan.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PG<sp/>p3(<sp/>Point(<sp/>-50,-250),<sp/>Point(<sp/><sp/>50,-250),50);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PG<sp/>p4(<sp/>Point(-250,<sp/>250),<sp/>Point(<sp/>250,<sp/>250),50);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Segm_iterator<sp/><sp/>t2(<sp/>p3,<sp/>p4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Count_iterator<sp/>t2_begin(<sp/>t2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Count_iterator<sp/>t2_end(<sp/>t2,<sp/>50);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::copy(<sp/>t2_begin,<sp/>t2_end,<sp/>std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>segs.size()<sp/>==<sp/>100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/>Vector::iterator<sp/>i<sp/>=<sp/>segs.begin();<sp/>i<sp/>!=<sp/>segs.end();<sp/>i++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>i-&gt;source().x()<sp/>&lt;=<sp/><sp/>250);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>i-&gt;source().x()<sp/>&gt;=<sp/>-250);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>i-&gt;source().y()<sp/>&lt;=<sp/><sp/>250);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>i-&gt;source().y()<sp/>&gt;=<sp/>-250);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>i-&gt;target().x()<sp/>&lt;=<sp/><sp/>250);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>i-&gt;target().x()<sp/>&gt;=<sp/>-250);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>i-&gt;target().y()<sp/>&lt;=<sp/><sp/>250);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion(<sp/>i-&gt;target().y()<sp/>&gt;=<sp/>-250);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__figureSegmentGeneratorFan"/><image type="html" name="Segment_generator_prog2.png"></image>
 <image type="latex" name="Segment_generator_prog2.png" width="15cm"></image>
  <ref refid="index_1fig__figureSegmentGeneratorFan" kindref="member">fig__figureSegmentGeneratorFan</ref> Output of example program for the generic segment generator using pre-computed point locations.  <linebreak/>
</para></sect1>
<sect1 id="index_1GeneratorExample_2">
<title>Example Generating Point Sets in d Dimensions</title>
<para>The following example generates points inside a cube in dimension 5 (examples for ball and sphere are available in the example directory) :</para><para><linebreak/>
<bold>File</bold> <ref refid="Generator_2cube_d_8cpp-example" kindref="compound">Generator/cube_d.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Cartesian_d&lt;double&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kd;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kd::Point_d<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb_points<sp/>=<sp/>10;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>dim<sp/>=5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>size<sp/>=<sp/>100.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Generating<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;nb_points&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>random<sp/>points<sp/>in<sp/>a<sp/>cube<sp/>in<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;dim&lt;&lt;</highlight><highlight class="stringliteral">&quot;D,<sp/>coordinates<sp/>from<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;-size&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>to<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;size&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v.reserve<sp/>(nb_points);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Random__points__in__cube__d" kindref="compound">CGAL::Random_points_in_cube_d&lt;Point&gt;</ref><sp/>gen<sp/>(dim,<sp/>size);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>nb_points;<sp/>++i)<sp/>v.push_back<sp/>(*gen++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>nb_points;<sp/>++i)<sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;v[i]&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The output of this example looks like: <verbatim>Generating 10 random points in a cube in 5D, coordinates from -100 to 100
5 32.9521 26.0403 59.3979 -99.2553 15.5102 
5 80.3731 30.809 7.32491 -90.2544 94.5635 
5 -71.3412 -31.933 -98.0734 79.6493 66.6104 
5 -78.5065 -58.2397 -33.9096 81.2196 57.2512 
5 21.4093 26.7661 57.6083 23.4958 93.1047 
5 10.5895 -21.8914 70.9726 36.756 -42.2667 
5 23.9813 54.4519 -26.0894 -85.18 -21.0775 
5 -48.7499 59.9873 6.22335 -4.16011 81.0727 
5 -11.6615 5.53147 -32.6578 -79.9283 44.5679 
5 53.0183 78.3228 -28.5665 83.3503 68.0482 
</verbatim></para><para>Next example generates grid points in dimension <computeroutput>d=4</computeroutput>. Since the required number of points, 20 is between <formula id="75">$ 2^d$</formula> and <formula id="76">$ 3^d$</formula> the supporting grid has <formula id="77">$ 3\times 3\times 3\times 3$</formula> points. Since the size parameter is 5, the coordinates are in <formula id="78">$ \{-5, 0, 5\}$</formula>, but since the number of points verifies <formula id="79">$ 20\leq 3^{d-1}$</formula>, all generated points have the same last coordinate <formula id="80">$ -5$</formula>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generator_2grid_d_8cpp-example" kindref="compound">Generator/grid_d.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/constructions_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Cartesian_d&lt;double&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kd;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kd::Point_d<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__d" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_d</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;std::vector&lt;double&gt;::iterator,<sp/>Point&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator_d;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb_points<sp/>=<sp/>20;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>dim<sp/>=<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>size<sp/>=<sp/>5.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Generating<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;nb_points&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>grid<sp/>points<sp/>in<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;dim&lt;&lt;</highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>v;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v.reserve(nb_points);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgGenerators_1ga3c1b105fd97be68c3331b397b6e6ebe9" kindref="member">CGAL::points_on_cube_grid_d</ref><sp/>(dim,<sp/>size,<sp/>(std::size_t)<sp/>nb_points,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(v),<sp/>Creator_d(dim)<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>nb_points;<sp/>++i)<sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/><sp/>&quot;</highlight><highlight class="normal">&lt;&lt;v[i]&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The output of previous example corresponds to the points of this figure depicted in red or pink (pink points are &quot;inside&quot; the cube). The output is:</para><para><verbatim>Generating 20 grid points in 4D
4 -5 -5 -5 -5 
4 0 -5 -5 -5 
4 5 -5 -5 -5 
4 -5 0 -5 -5 
4 0 0 -5 -5 
4 5 0 -5 -5 
4 -5 5 -5 -5 
4 0 5 -5 -5 
4 5 5 -5 -5 
4 -5 -5 0 -5 
4 0 -5 0 -5 
4 5 -5 0 -5 
4 -5 0 0 -5 
4 0 0 0 -5 
4 5 0 0 -5 
4 -5 5 0 -5 
4 0 5 0 -5 
4 5 5 0 -5 
4 -5 -5 5 -5 
4 0 -5 5 -5 
</verbatim></para><para><image type="html" name="hypergrid.png"></image>
 <image type="latex" name="hypergrid.png"></image>
</para></sect1>
<sect1 id="index_1GeneratorExGenCombi">
<title>Example Generating Combinations</title>
<sect2 id="index_1GeneratorFromRangeInt">
<title>From a Range of Integers</title>
<para>The following example enumerates and outputs all subsets of 3 elements from the range <formula id="81">$ [10, 15]$</formula>. Accordingly, it outputs <formula id="82">$ \frac{6!}{3! 3!}=20$</formula> triples.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generator_2combination_enumerator_8cpp-example" kindref="compound">Generator/combination_enumerator.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&quot;CGAL/Combination_enumerator.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespacestd" kindref="compound">std</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k(3),<sp/>first(10),<sp/>last(15);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Taking<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>distinct<sp/>integers<sp/>in<sp/>the<sp/>range<sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>first<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>last<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]:&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Combination__enumerator" kindref="compound">CGAL::Combination_enumerator&lt;int&gt;</ref><sp/>combi(k,<sp/>first,<sp/>last<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(<sp/>!<sp/>combi.finished()<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>{&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>k;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>combi[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>i<sp/>&lt;<sp/>k<sp/>-<sp/>1<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;}&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++combi;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Enumerated<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>combinations.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The output of this example is: <verbatim>Taking 3 distinct integers in the range [10, 15]: {10 11 12} {10 11 13} {10 11 14}
{10 11 15} {10 12 13} {10 12 14} {10 12 15} {10 13 14} {10 13 15} {10 14 15}
{11 12 13} {11 12 14} {11 12 15} {11 13 14} {11 13 15} {11 14 15} {12 13 14}
{12 13 15} {12 14 15} {13 14 15}
Enumerated 20 combinations.
</verbatim></para></sect2>
<sect2 id="index_1GeneratorFromArrayStr">
<title>From an Array of Strings</title>
<para>The following example generates all pairs of names from a set of names stored in an array of strings.</para><para><linebreak/>
<bold>File</bold> <ref refid="Generator_2name_pairs_8cpp-example" kindref="compound">Generator/name_pairs.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&quot;CGAL/Combination_enumerator.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespacestd" kindref="compound">std</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vector&lt;string&gt;<sp/>names;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>names.push_back(</highlight><highlight class="stringliteral">&quot;Sun&quot;</highlight><highlight class="normal">);<sp/><sp/><sp/><sp/>names.push_back(</highlight><highlight class="stringliteral">&quot;Shannon&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>names.push_back(</highlight><highlight class="stringliteral">&quot;Hurley&quot;</highlight><highlight class="normal">);<sp/>names.push_back(</highlight><highlight class="stringliteral">&quot;Sawyer&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>names.push_back(</highlight><highlight class="stringliteral">&quot;Kate&quot;</highlight><highlight class="normal">);<sp/><sp/><sp/>names.push_back(</highlight><highlight class="stringliteral">&quot;Claire&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>names.push_back(</highlight><highlight class="stringliteral">&quot;John&quot;</highlight><highlight class="normal">);<sp/><sp/><sp/>names.push_back(</highlight><highlight class="stringliteral">&quot;Jack&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Combination__enumerator" kindref="compound">CGAL::Combination_enumerator&lt;vector&lt;string&gt;::iterator</ref>&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>combi(2,<sp/>names.begin(),<sp/>names.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(<sp/>!<sp/>combi.finished()<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>{&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*combi[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*combi[1]<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;}&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++combi;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1GeneratorDesign">
<title>Design and Implementation History</title>
<para>Lutz Kettner coded generators in 2D and 3D For points <emphasis>in</emphasis> and <emphasis>on</emphasis> sphere, points are generated in a cube up to the moment the point is inside the sphere, then it is normalized to go on the boundary if needed.</para><para>Sven Sch<oumlaut/>nherr implemented the <ref refid="classCGAL_1_1Random" kindref="compound">Random</ref> class.</para><para>Michael Hoffmann coded the random convex polygon,</para><para>Geert-Jan Giezeman and Susan Hert coded the random simple polygon.</para><para>Olivier Devillers coded generators in high dimensions. For points <emphasis>in ball</emphasis> and <emphasis>on sphere</emphasis>, points are generated on a sphere/ball boundary as a product of normal distributions, then it is normalized. If needed a random radius (with relevant distribution) is used to put the point inside the ball.</para><para>Remy Thomasse coded the random convex hull in a disc.</para><para>During Google Summer of Code 2013, Pedro M. M. de Castro and Alexandru Tifrea coded generators for points in triangle (2D and 3D) and in tetrahedra (3D). Basically, in order to generate a random point in a <formula id="83">$N$</formula>-simplex (a triangle for <formula id="84">$N = 2$</formula>, and tetrahedron for <formula id="85">$N = 3$</formula>), we generate numbers <formula id="86">$a_1,a_2,\ldots,a_N$</formula> identically and independently uniformly distributed in <formula id="87">$(0,1)$</formula>, we sort them, we let <formula id="88">$a_0 = 0$</formula> and <formula id="89">$a_{N+1} = 1$</formula>, and then <formula id="90">$a_{i+1}−a_i$</formula>, for <formula id="91">$i = 1,\ldots,N$</formula> becomes its barycentric coordinates with respect to the simplex.</para><para>Maxime Gimemo introduced the random generators on 2D and 3D triangle meshes. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
