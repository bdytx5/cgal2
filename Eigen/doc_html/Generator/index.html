<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Generator/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Geometric Object Generators: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Geometric Object Generators
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Geometric_Object_Generators"></a><a class="anchor" id="chapterGenerators"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Pedro M. M. de Castro, Olivier Devillers, Susan Hert, Michael Hoffmann, Lutz Kettner, Sven Sch√∂nherr, Alexandru Tifrea, and Maxime Gimeno</dd></dl>
<h1><a class="anchor" id="GeneratorIntroduction"></a>
Introduction</h1>
<p>A variety of generators for geometric objects are provided in <span style="font-variant: small-caps;">CGAL</span>. They are useful as synthetic test data sets, e.g. for testing algorithms on degenerate object sets and for performance analysis.</p>
<p>Two kinds of point generators are provided: first, random point generators and second deterministic point generators. Most random point generators and a few deterministic point generators are provided as input iterators. The input iterators model an infinite sequence of points. The function <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gacb8df77d1d07b9cfff3fdd2f5d9c4fda">CGAL::copy_n()</a></code> can be used to copy a finite sequence. The iterator adaptor <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Counting__iterator.html">Counting_iterator</a></code> can be used to create finite iterator ranges. Other generators are provided as functions that write to output iterators. Further functions add degeneracies or random perturbations.</p>
<p>In 2D, we provide input iterators to generate random points in a disc (<code><a class="el" href="classCGAL_1_1Random__points__in__disc__2.html" title="The class Random_points_in_disc_2 is an input iterator creating points uniformly distributed in an op...">Random_points_in_disc_2</a></code>), in a square (<code><a class="el" href="classCGAL_1_1Random__points__in__square__2.html" title="The class Random_points_in_square_2 is an input iterator creating points uniformly distributed in a h...">Random_points_in_square_2</a></code>), on a circle (<code><a class="el" href="classCGAL_1_1Random__points__on__circle__2.html" title="The class Random_points_on_circle_2 is an input iterator creating points uniformly distributed on a c...">Random_points_on_circle_2</a></code>), on a segment (<code>Random_points_on_segment</code>), in a square (<code><a class="el" href="classCGAL_1_1Random__points__on__square__2.html" title="The class Random_points_on_square_2 is an input iterator creating points uniformly distributed on the...">Random_points_on_square_2</a></code>), in a triangle (<code><a class="el" href="classCGAL_1_1Random__points__in__triangle__2.html" title="The class Random_points_in_triangle_2 is an input iterator creating points uniformly distributed insi...">Random_points_in_triangle_2</a></code>), in a range of triangles (<code><a class="el" href="structCGAL_1_1Random__points__in__triangles__2.html" title="The class Random_points_in_triangles_2 is an input iterator creating points uniformly distributed ins...">Random_points_in_triangles_2</a></code>), and in a triangle mesh (<code><a class="el" href="classCGAL_1_1Random__points__in__triangle__mesh__2.html" title="The class Random_points_in_triangle_mesh_2 is an input iterator creating points uniformly distributed...">Random_points_in_triangle_mesh_2</a></code>). For generating grid points we provide three functions, <code><a class="el" href="group__PkgGenerators.html#ga58b8faf4c090fc9b367f51d9004cde4c" title="generates a set of points equally spaced on a segment given the endpoints of the segment. ">points_on_segment_2()</a></code>, <code><a class="el" href="group__PkgGenerators.html#gad5aec033ff62776826bd5b01be41b792" title="generates a given number of points on a square grid whose size is determined by the number of points ...">points_on_square_grid_2()</a></code> that write to output iterators and an input iterator <code><a class="el" href="classCGAL_1_1Points__on__segment__2.html" title="The class Points_on_segment_2 is a generator for points on a segment whose endpoints are specified up...">Points_on_segment_2</a></code>.</p>
<p>For 3D points, input iterators are provided for random points uniformly distributed in a sphere (<code><a class="el" href="classCGAL_1_1Random__points__in__sphere__3.html" title="The class Random_points_in_sphere_3 is an input iterator creating points uniformly distributed strict...">Random_points_in_sphere_3</a></code>), in a triangle (<code><a class="el" href="classCGAL_1_1Random__points__in__triangle__3.html" title="The class Random_points_in_triangle_3 is an input iterator creating points uniformly distributed insi...">Random_points_in_triangle_3</a></code>), in a range of triangles (<code><a class="el" href="structCGAL_1_1Random__points__in__triangles__3.html" title="The class Random_points_in_triangles_3 is an input iterator creating points uniformly distributed ins...">Random_points_in_triangles_3</a></code>), in a tetrahedron (<code><a class="el" href="classCGAL_1_1Random__points__in__tetrahedron__3.html" title="The class Random_points_in_tetrahedron_3 is an input iterator creating points uniformly distributed i...">Random_points_in_tetrahedron_3</a></code>), in a cube (<code><a class="el" href="classCGAL_1_1Random__points__in__cube__3.html" title="The class Random_points_in_cube_3 is an input iterator creating points uniformly distributed in a hal...">Random_points_in_cube_3</a></code>), on the boundary of a sphere (<code><a class="el" href="classCGAL_1_1Random__points__on__sphere__3.html" title="The class Random_points_on_sphere_3 is an input iterator creating points uniformly distributed on a s...">Random_points_on_sphere_3</a></code>), in a triangle mesh (<code><a class="el" href="structCGAL_1_1Random__points__in__triangle__mesh__3.html" title="The class Random_points_in_triangle_mesh_3 is an input iterator creating points uniformly distributed...">Random_points_in_triangle_mesh_3</a></code>), in a tetrahedron mesh (<code><a class="el" href="classCGAL_1_1Random__points__in__tetrahedral__mesh__3.html" title="The class Random_points_in_tetrahedral_mesh_3 is an input iterator creating points uniformly distribu...">Random_points_in_tetrahedral_mesh_3</a></code>), and on the boundary of a tetrahedron mesh (<code><a class="el" href="classCGAL_1_1Random__points__in__tetrahedral__mesh__boundary__3.html" title="The class Random_points_in_tetrahedral_mesh_boundary_3 is an input iterator creating points uniformly...">Random_points_in_tetrahedral_mesh_boundary_3</a></code>). For generating 3D grid points, we provide the function <code><a class="el" href="group__PkgGenerators.html#ga03437b3f68ee130c2438a0ab29511695" title="generates a given number of points on a cubic grid whose size is determined by the number of points t...">points_on_cube_grid_3()</a></code> that writes to an output iterator.</p>
<p>For higher dimensions, input iterators are provided for random points uniformly distributed in a <code>d</code>-dimensional cube (<code><a class="el" href="classCGAL_1_1Random__points__in__cube__d.html" title="The class Random_points_in_cube_d is an input iterator creating points uniformly distributed in an ha...">Random_points_in_cube_d</a></code>) or <code>d</code>-dimensional ball (<code><a class="el" href="classCGAL_1_1Random__points__in__ball__d.html" title="The class Random_points_in_ball_d is an input iterator creating points uniformly distributed in an op...">Random_points_in_ball_d</a></code>) or on the boundary of a sphere (<code><a class="el" href="classCGAL_1_1Random__points__on__sphere__d.html" title="The class Random_points_on_sphere_d is an input iterator creating points uniformly distributed on a s...">Random_points_on_sphere_d</a></code>). For generating grid points, we provide the function <code><a class="el" href="group__PkgGenerators.html#ga3c1b105fd97be68c3331b397b6e6ebe9" title="generates a given number of points on a cubic grid in any dimension whose size is determined by the n...">points_on_cube_grid_d()</a></code> that writes to an output iterator.</p>
<p>We also provide two functions for generating more complex geometric objects. The function <code><a class="el" href="group__PkgGenerators.html#ga48fe050c898078e688376009dc60b232" title="computes a random convex planar point set of given size where the points are drawn from a specific do...">random_convex_set_2()</a></code> computes a random convex planar point set of a given size where the points are drawn from a specific domain and <code><a class="el" href="group__PkgGenerators.html#gaa8cb58e4cc9ab9e225808799b1a61174" title="computes a random simple polygon by writing its vertices (oriented counterclockwise) to result...">random_polygon_2()</a></code> generates a random simple polygon from points drawn from a specific domain. The function <code><a class="el" href="group__PkgGenerators.html#ga55d4f2043b91c2870b5d4a6071d921f6" title="Computes a random convex polygon as the convex hull of  random points in a disc centered at the origi...">random_convex_hull_in_disc_2()</a></code> computes a random polygon as a convex hull from uniformly generated random points in a disc.</p>
<h2><a class="anchor" id="GeneratorRandomPerturbations"></a>
Random Perturbations</h2>
<p>Degenerate input sets like grid points can be randomly perturbed by a small amount to produce <em>quasi</em>-degenerate test sets. This challenges numerical stability of algorithms using inexact arithmetic and exact predicates to compute the sign of expressions slightly off from zero. For this the function <code><a class="el" href="group__PkgGenerators.html#gafacf70e214daa1206eb1e20b35bb8b64" title="perturbs each point in a given range of points by a random amount. ">perturb_points_2()</a></code> is provided.</p>
<h2><a class="anchor" id="GeneratorAddingDegeneracies"></a>
Adding Degeneracies</h2>
<p>For a given point set certain kinds of degeneracies can be produced by adding new points. The <code><a class="el" href="group__PkgGenerators.html#ga5931f8c3d40445dd776437d07a5058a1" title="chooses n items at random from a random access iterator range which is useful to produce degenerate i...">random_selection()</a></code> function is useful for generating multiple copies of identical points. The function <code><a class="el" href="group__PkgGenerators.html#gae02cceaf04ecd42a5996b6b1b88be798" title="randomly chooses two points from the range [first,last), creates a random third point on the segment ...">random_collinear_points_2()</a></code> adds collinearities to a point set.</p>
<h2><a class="anchor" id="GeneratorSupportFunctionsandClassesforGenerators"></a>
Support Functions and Classes for Generators</h2>
<p>The function <code><a class="el" href="group__PkgGenerators.html#ga5931f8c3d40445dd776437d07a5058a1" title="chooses n items at random from a random access iterator range which is useful to produce degenerate i...">random_selection()</a></code> chooses <code>n</code> items at random from a random access iterator range which is useful to produce degenerate input data sets with multiple entries of identical items.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Combination__enumerator.html" title="The class Combination_enumerator is used to enumerate all fixed-size combinations (subsets) of a sour...">Combination_enumerator</a>&lt;<a class="el" href="classCombinationElement.html" title="A CombinationElement can be used as template parameter for the class Combination_enumerator&lt;Combinati...">CombinationElement</a>&gt;</code> is used to enumerate all fixed-size combinations (subsets) of a range of elements. It is useful in the context of high-dimensional triangulations, e.g., for enumerating the faces of a simplex.</p>
<h1><a class="anchor" id="GeneratorExample_1"></a>
Example Generating Degenerate Point Sets</h1>
<p>We want to generate a test set of 1000 points, where 60% are chosen randomly in a small disc, 20% are from a larger grid, 10% are duplicates points, and 10% collinear points. A random shuffle removes the construction order from the test set. See <a class="el" href="index.html#fig__figurePointGenerator">Figure 95.1</a> for the example output.</p>
<p><br />
<b>File</b> <a class="el" href="Generator_2random_degenerate_point_set_8cpp-example.html">Generator/random_degenerate_point_set.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/algorithm.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/random_selection.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">Simple_cartesian&lt;double&gt;</a>         R;</div><div class="line"><span class="keyword">typedef</span> R::Point_2                       Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">Creator_uniform_2&lt;double,Point&gt;</a>  Creator;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt;               Vector;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Create test point set. Prepare a vector for 1000 points.</span></div><div class="line">    Vector points;</div><div class="line">    points.reserve(1000);</div><div class="line"></div><div class="line">    <span class="comment">// Create 600 points within a disc of radius 150.</span></div><div class="line">    <a class="code" href="classCGAL_1_1Random__points__in__disc__2.html">Random_points_in_disc_2&lt;Point,Creator&gt;</a> g( 150.0);</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gadba21cc5c30a79519438dfe0f9264255">CGAL::cpp11::copy_n</a>( g, 600, std::back_inserter(points));</div><div class="line"></div><div class="line">    <span class="comment">// Create 200 points from a 15 x 15 grid.</span></div><div class="line">    <a class="code" href="group__PkgGenerators.html#gad5aec033ff62776826bd5b01be41b792">points_on_square_grid_2</a>( 250.0, 200, std::back_inserter(points),Creator());</div><div class="line"></div><div class="line">    <span class="comment">// Select 100 points randomly and append them at the end of</span></div><div class="line">    <span class="comment">// the current vector of points.</span></div><div class="line">    <a class="code" href="group__PkgGenerators.html#ga5931f8c3d40445dd776437d07a5058a1">random_selection</a>( points.begin(), points.end(), 100,</div><div class="line">              std::back_inserter(points));</div><div class="line"></div><div class="line">    <span class="comment">// Create 100 points that are collinear to two randomly chosen</span></div><div class="line">    <span class="comment">// points and append them to the current vector of points.</span></div><div class="line">    <a class="code" href="group__PkgGenerators.html#gae02cceaf04ecd42a5996b6b1b88be798">random_collinear_points_2</a>( points.begin(), points.end(), 100,</div><div class="line">                   std::back_inserter( points));</div><div class="line"></div><div class="line">    <span class="comment">// Check that we have really created 1000 points.</span></div><div class="line">    assert( points.size() == 1000);</div><div class="line"></div><div class="line">    <span class="comment">// Use a random permutation to hide the creation history</span></div><div class="line">    <span class="comment">// of the point set.</span></div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#ga03da480625f380d4d06ea64de211add4">CGAL::cpp98::random_shuffle</a>( points.begin(), points.end());</div><div class="line"></div><div class="line">    <span class="comment">// Check range of values.</span></div><div class="line">    <span class="keywordflow">for</span> ( Vector::iterator i = points.begin(); i != points.end(); i++){</div><div class="line">    assert( i-&gt;x() &lt;=  251);</div><div class="line">    assert( i-&gt;x() &gt;= -251);</div><div class="line">    assert( i-&gt;y() &lt;=  251);</div><div class="line">    assert( i-&gt;y() &gt;= -251);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__figurePointGenerator"></a></p><div class="image">
<img src="generators_prog1.png" alt="generators_prog1.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figurePointGenerator">Figure 95.1</a> Output of example program for point generators.  </div>  <br />

<h1><a class="anchor" id="GeneratorExampleGridPoints"></a>
Example Generating Grid Points</h1>
<p>The second example demonstrates the point generators with integer points. Floating point arithmetic is sufficient to produce regular integer grids. See <a class="el" href="index.html#fig__figureIntegerPointGenerator">Figure 95.2</a> for the example output.</p>
<p><br />
<b>File</b> <a class="el" href="Generator_2random_grid_8cpp-example.html">Generator/random_grid.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/algorithm.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">Simple_cartesian&lt;int&gt;</a>         K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                    Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">Creator_uniform_2&lt;int,Point&gt;</a>  Creator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Create test point set. Prepare a vector for 400 points.</span></div><div class="line">    std::vector&lt;Point&gt; points;</div><div class="line">    points.reserve(400);</div><div class="line"></div><div class="line">    <span class="comment">// Create 250 points from a 16 x 16 grid. Note that the double</span></div><div class="line">    <span class="comment">// arithmetic _is_ sufficient to produce exact integer grid points.</span></div><div class="line">    <span class="comment">// The distance between neighbors is 34 pixel = 510 / 15.</span></div><div class="line">    <a class="code" href="group__PkgGenerators.html#gad5aec033ff62776826bd5b01be41b792">points_on_square_grid_2</a>( 255.0, 250, std::back_inserter(points),Creator());</div><div class="line"></div><div class="line">    <span class="comment">// Lower, left corner.</span></div><div class="line">    assert( points[0].x() == -255);</div><div class="line">    assert( points[0].y() == -255);</div><div class="line"></div><div class="line">    <span class="comment">// Upper, right corner. Note that 6 points are missing to fill the grid.</span></div><div class="line">    assert( points[249].x() == 255 - 6 * 34);</div><div class="line">    assert( points[249].y() == 255);</div><div class="line"></div><div class="line">    <span class="comment">// Create 250 points within a disc of radius 150.</span></div><div class="line">    <a class="code" href="classCGAL_1_1Random__points__in__disc__2.html">Random_points_in_disc_2&lt;Point,Creator&gt;</a> g( 150.0);</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gadba21cc5c30a79519438dfe0f9264255">CGAL::cpp11::copy_n</a>( g, 250, std::back_inserter(points));</div><div class="line"></div><div class="line">    <span class="comment">// Check that we have really created 500 points.</span></div><div class="line">    assert( points.size() == 500);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__figureIntegerPointGenerator"></a></p><div class="image">
<img src="generators_prog2.png" alt="generators_prog2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figureIntegerPointGenerator">Figure 95.2</a> Output of example program for point generators working  </div>  <br />

<h1><a class="anchor" id="GeneratorExample_mesh"></a>
Example Generating Random Point Sets On a Triangle Mesh</h1>
<p>The following example demonstrates the use of the random point generator on a triangle mesh. We want to generate 100 points uniformly chosen on a <code>Polyhedron_3</code>. See <a class="el" href="index.html#fig__figureMeshPointGenerator">Figure 95.3</a> <br />
<b>File</b> <a class="el" href="Generator_2random_points_on_triangle_mesh_3_8cpp-example.html">Generator/random_points_on_triangle_mesh_3.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">Simple_cartesian&lt;double&gt;</a>                           K;</div><div class="line"><span class="keyword">typedef</span> CGAL::Polyhedron_3&lt;K&gt;                              Polyhedron;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                         Point;</div><div class="line"><span class="keyword">typedef</span> K::FT                                              FT;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"> <span class="comment">// Generated points are in that vector</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="comment">// Create input polyhedron</span></div><div class="line">  Polyhedron polyhedron;</div><div class="line">  polyhedron.make_tetrahedron(Point(-1,0,0), Point(0,1,0), Point(1,0,0), Point(0,0,-1));</div><div class="line"></div><div class="line">  <span class="comment">// Create the generator, input is the Polyhedron polyhedron</span></div><div class="line">  <a class="code" href="structCGAL_1_1Random__points__in__triangle__mesh__3.html">Random_points_in_triangle_mesh_3&lt;Polyhedron&gt;</a></div><div class="line">      g(polyhedron);</div><div class="line"></div><div class="line">  <span class="comment">// Get 100 random points in cdt</span></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gadba21cc5c30a79519438dfe0f9264255">CGAL::cpp11::copy_n</a>(g, 100, std::back_inserter(points));</div><div class="line"></div><div class="line">  <span class="comment">// Check that we have really created 100 points.</span></div><div class="line">  assert( points.size() == 100);</div><div class="line"></div><div class="line">  <span class="comment">// print the first point that was generated</span></div><div class="line">  std::cout &lt;&lt; points[0] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p><a class="anchor" id="fig__figureMeshPointGenerator"></a></p><div class="image">
<img src="generator_mesh_3.png" alt="generator_mesh_3.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figureMeshPointGenerator">Figure 95.3</a> Output of example program for point generator on a triangle mesh  </div>  <br />

<h1><a class="anchor" id="secsegment_example"></a>
Examples Generating Segments</h1>
<p>The following two examples illustrate the use of the generic functions from Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html">Generic Algorithms</a> like <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Join__input__iterator__2.html">Join_input_iterator_2</a></code> to generate composed objects from other generators - here two-dimensional segments from two point generators.</p>
<p>We want to generate a test set of 200 segments, where one endpoint is chosen randomly from a horizontal segment of length 200, and the other endpoint is chosen randomly from a circle of radius 250. See <a class="el" href="index.html#fig__figureSegmentGenerator">Figure 95.4</a> for the example output.</p>
<p><br />
<b>File</b> <a class="el" href="Generator_2random_segments1_8cpp-example.html">Generator/random_segments1.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/function_objects.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Join_input_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/algorithm.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                       Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">Creator_uniform_2&lt;double,Point&gt;</a>  Pt_creator;</div><div class="line"><span class="keyword">typedef</span> K::Segment_2                     Segment;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Segment&gt;             Vector;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Create test segment set. Prepare a vector for 200 segments.</span></div><div class="line">    Vector segs;</div><div class="line">    segs.reserve(200);</div><div class="line"></div><div class="line">    <span class="comment">// Prepare point generator for the horizontal segment, length 200.</span></div><div class="line">    <span class="keyword">typedef</span>  <a class="code" href="classCGAL_1_1Random__points__on__segment__2.html">Random_points_on_segment_2&lt;Point,Pt_creator&gt;</a>  P1;</div><div class="line">    P1 p1( Point(-100,0), Point(100,0));</div><div class="line"></div><div class="line">    <span class="comment">// Prepare point generator for random points on circle, radius 250.</span></div><div class="line">    <span class="keyword">typedef</span>  <a class="code" href="classCGAL_1_1Random__points__on__circle__2.html">Random_points_on_circle_2&lt;Point,Pt_creator&gt;</a>  P2;</div><div class="line">    P2 p2( 250);</div><div class="line"></div><div class="line">    <span class="comment">// Create 200 segments.</span></div><div class="line">    <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">Creator_uniform_2&lt; Point, Segment&gt;</a> Seg_creator;</div><div class="line">    <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Join__input__iterator__2.html">Join_input_iterator_2&lt; P1, P2, Seg_creator&gt;</a> Seg_iterator;</div><div class="line">    Seg_iterator g( p1, p2);</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gadba21cc5c30a79519438dfe0f9264255">CGAL::cpp11::copy_n</a>( g, 200, std::back_inserter(segs));</div><div class="line"></div><div class="line">    assert( segs.size() == 200);</div><div class="line">    <span class="keywordflow">for</span> ( Vector::iterator i = segs.begin(); i != segs.end(); i++){</div><div class="line">        assert( i-&gt;source().x() &lt;=  100);</div><div class="line">        assert( i-&gt;source().x() &gt;= -100);</div><div class="line">        assert( i-&gt;source().y() ==    0);</div><div class="line">        assert( i-&gt;target().x() * i-&gt;target().x() +</div><div class="line">                i-&gt;target().y() * i-&gt;target().y() &lt;=  251*251);</div><div class="line">        assert( i-&gt;target().x() * i-&gt;target().x() +</div><div class="line">                i-&gt;target().y() * i-&gt;target().y() &gt;=  249*249);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__figureSegmentGenerator"></a></p><div class="image">
<img src="Segment_generator_prog1.png" alt="Segment_generator_prog1.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figureSegmentGenerator">Figure 95.4</a> Output of example program for the generic segment generator.  </div>  <br />

<p>The second example generates a regular structure of 100 segments; see <a class="el" href="index.html#fig__figureSegmentGeneratorFan">Figure 95.5</a> for the example output. It uses the <code><a class="el" href="classCGAL_1_1Points__on__segment__2.html" title="The class Points_on_segment_2 is a generator for points on a segment whose endpoints are specified up...">Points_on_segment_2</a></code> iterator, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Join__input__iterator__2.html">Join_input_iterator_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Counting__iterator.html">Counting_iterator</a></code> to avoid any intermediate storage of the generated objects until they are used.</p>
<p><br />
<b>File</b> <a class="el" href="Generator_2random_segments2_8cpp-example.html">Generator/random_segments2.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// CGAL example program for the generic segment generator</span></div><div class="line"><span class="comment">// using precomputed point locations.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/function_objects.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Join_input_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Counting_iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">Exact_predicates_inexact_constructions_kernel</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                Point;</div><div class="line"><span class="keyword">typedef</span> K::Segment_2                              Segment;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Points__on__segment__2.html">Points_on_segment_2&lt;Point&gt;</a>                PG;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">Creator_uniform_2&lt; Point, Segment&gt;</a>        Creator;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Join__input__iterator__2.html">Join_input_iterator_2&lt; PG, PG, Creator&gt;</a>   Segm_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Counting__iterator.html">Counting_iterator&lt;Segm_iterator,Segment&gt;</a>  Count_iterator;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Segment&gt;                      Vector;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Create test segment set. Prepare a vector for 100 segments.</span></div><div class="line">    Vector segs;</div><div class="line">    segs.reserve(100);</div><div class="line"></div><div class="line">    <span class="comment">// A horizontal like fan.</span></div><div class="line">    PG p1( Point(-250, -50), Point(-250, 50),50);   <span class="comment">// Point generator.</span></div><div class="line">    PG p2( Point( 250,-250), Point( 250,250),50);</div><div class="line">    Segm_iterator  t1( p1, p2);                     <span class="comment">// Segment generator.</span></div><div class="line">    Count_iterator t1_begin( t1);                   <span class="comment">// Finite range.</span></div><div class="line">    Count_iterator t1_end( t1, 50);</div><div class="line">    std::copy( t1_begin, t1_end, std::back_inserter(segs));</div><div class="line"></div><div class="line">    <span class="comment">// A vertical like fan.</span></div><div class="line">    PG p3( Point( -50,-250), Point(  50,-250),50);</div><div class="line">    PG p4( Point(-250, 250), Point( 250, 250),50);</div><div class="line">    Segm_iterator  t2( p3, p4);</div><div class="line">    Count_iterator t2_begin( t2);</div><div class="line">    Count_iterator t2_end( t2, 50);</div><div class="line">    std::copy( t2_begin, t2_end, std::back_inserter(segs));</div><div class="line"></div><div class="line">    CGAL_assertion( segs.size() == 100);</div><div class="line">    <span class="keywordflow">for</span> ( Vector::iterator i = segs.begin(); i != segs.end(); i++){</div><div class="line">    CGAL_assertion( i-&gt;source().x() &lt;=  250);</div><div class="line">    CGAL_assertion( i-&gt;source().x() &gt;= -250);</div><div class="line">    CGAL_assertion( i-&gt;source().y() &lt;=  250);</div><div class="line">    CGAL_assertion( i-&gt;source().y() &gt;= -250);</div><div class="line">    CGAL_assertion( i-&gt;target().x() &lt;=  250);</div><div class="line">    CGAL_assertion( i-&gt;target().x() &gt;= -250);</div><div class="line">    CGAL_assertion( i-&gt;target().y() &lt;=  250);</div><div class="line">    CGAL_assertion( i-&gt;target().y() &gt;= -250);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__figureSegmentGeneratorFan"></a></p><div class="image">
<img src="Segment_generator_prog2.png" alt="Segment_generator_prog2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figureSegmentGeneratorFan">Figure 95.5</a> Output of example program for the generic segment generator using pre-computed point locations.  </div>  <br />

<h1><a class="anchor" id="GeneratorExample_2"></a>
Example Generating Point Sets in d Dimensions</h1>
<p>The following example generates points inside a cube in dimension 5 (examples for ball and sphere are available in the example directory) :</p>
<p><br />
<b>File</b> <a class="el" href="Generator_2cube_d_8cpp-example.html">Generator/cube_d.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_d.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Cartesian_d&lt;double&gt;                           Kd;</div><div class="line"><span class="keyword">typedef</span> Kd::Point_d                                         Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> nb_points = 10;</div><div class="line">  <span class="keywordtype">int</span> dim =5;</div><div class="line">  <span class="keywordtype">double</span> size = 100.0;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Generating "</span>&lt;&lt;nb_points&lt;&lt;<span class="stringliteral">" random points in a cube in "</span></div><div class="line">        &lt;&lt;dim&lt;&lt;<span class="stringliteral">"D, coordinates from "</span>&lt;&lt;-size&lt;&lt;<span class="stringliteral">" to "</span>&lt;&lt;size&lt;&lt;std::endl;</div><div class="line">  std::vector&lt;Point&gt; v;</div><div class="line">  v.reserve (nb_points);</div><div class="line">  <a class="code" href="classCGAL_1_1Random__points__in__cube__d.html">CGAL::Random_points_in_cube_d&lt;Point&gt;</a> gen (dim, size);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_points; ++i) v.push_back (*gen++);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_points; ++i) std::cout&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;v[i]&lt;&lt;std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The output of this example looks like: </p><pre class="fragment">Generating 10 random points in a cube in 5D, coordinates from -100 to 100
5 32.9521 26.0403 59.3979 -99.2553 15.5102 
5 80.3731 30.809 7.32491 -90.2544 94.5635 
5 -71.3412 -31.933 -98.0734 79.6493 66.6104 
5 -78.5065 -58.2397 -33.9096 81.2196 57.2512 
5 21.4093 26.7661 57.6083 23.4958 93.1047 
5 10.5895 -21.8914 70.9726 36.756 -42.2667 
5 23.9813 54.4519 -26.0894 -85.18 -21.0775 
5 -48.7499 59.9873 6.22335 -4.16011 81.0727 
5 -11.6615 5.53147 -32.6578 -79.9283 44.5679 
5 53.0183 78.3228 -28.5665 83.3503 68.0482 
</pre><p>Next example generates grid points in dimension <code>d=4</code>. Since the required number of points, 20 is between \( 2^d\) and \( 3^d\) the supporting grid has \( 3\times 3\times 3\times 3\) points. Since the size parameter is 5, the coordinates are in \( \{-5, 0, 5\}\), but since the number of points verifies \( 20\leq 3^{d-1}\), all generated points have the same last coordinate \( -5\).</p>
<p><br />
<b>File</b> <a class="el" href="Generator_2grid_d_8cpp-example.html">Generator/grid_d.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/constructions_d.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Cartesian_d&lt;double&gt;                        Kd;</div><div class="line"><span class="keyword">typedef</span> Kd::Point_d                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Creator__uniform__d.html">CGAL::Creator_uniform_d</a></div><div class="line">          &lt;std::vector&lt;double&gt;::iterator, Point&gt;         Creator_d;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> nb_points = 20;</div><div class="line">  <span class="keywordtype">int</span> dim = 4;</div><div class="line">  <span class="keywordtype">double</span> size = 5.0;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Generating "</span>&lt;&lt;nb_points&lt;&lt;<span class="stringliteral">" grid points in "</span></div><div class="line">          &lt;&lt;dim&lt;&lt;<span class="stringliteral">"D"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;Point&gt; v; </div><div class="line">  v.reserve(nb_points);</div><div class="line">  <a class="code" href="group__PkgGenerators.html#ga3c1b105fd97be68c3331b397b6e6ebe9">CGAL::points_on_cube_grid_d</a> (dim, size, (std::size_t) nb_points, </div><div class="line">                   std::back_inserter(v), Creator_d(dim) );</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nb_points; ++i) std::cout&lt;&lt;<span class="stringliteral">"  "</span>&lt;&lt;v[i]&lt;&lt;std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The output of previous example corresponds to the points of this figure depicted in red or pink (pink points are "inside" the cube). The output is:</p>
<pre class="fragment">Generating 20 grid points in 4D
4 -5 -5 -5 -5 
4 0 -5 -5 -5 
4 5 -5 -5 -5 
4 -5 0 -5 -5 
4 0 0 -5 -5 
4 5 0 -5 -5 
4 -5 5 -5 -5 
4 0 5 -5 -5 
4 5 5 -5 -5 
4 -5 -5 0 -5 
4 0 -5 0 -5 
4 5 -5 0 -5 
4 -5 0 0 -5 
4 0 0 0 -5 
4 5 0 0 -5 
4 -5 5 0 -5 
4 0 5 0 -5 
4 5 5 0 -5 
4 -5 -5 5 -5 
4 0 -5 5 -5 
</pre><div class="image">
<img src="hypergrid.png" alt="hypergrid.png" />
</div>
 <h1><a class="anchor" id="GeneratorExGenCombi"></a>
Example Generating Combinations</h1>
<h2><a class="anchor" id="GeneratorFromRangeInt"></a>
From a Range of Integers</h2>
<p>The following example enumerates and outputs all subsets of 3 elements from the range \( [10, 15]\). Accordingly, it outputs \( \frac{6!}{3! 3!}=20\) triples.</p>
<p><br />
<b>File</b> <a class="el" href="Generator_2combination_enumerator_8cpp-example.html">Generator/combination_enumerator.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "CGAL/Combination_enumerator.h"</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n(0);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> k(3), first(10), last(15);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">"Taking "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" distinct integers in the range ["</span> &lt;&lt;</div><div class="line">            first &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; last &lt;&lt; <span class="stringliteral">"]:"</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classCGAL_1_1Combination__enumerator.html">CGAL::Combination_enumerator&lt;int&gt;</a> combi(k, first, last + 1);</div><div class="line">    <span class="keywordflow">while</span>( ! combi.finished() ) {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">" {"</span>;</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; k; ++i) {</div><div class="line">            cout &lt;&lt; combi[i];</div><div class="line">            <span class="keywordflow">if</span>( i &lt; k - 1 )</div><div class="line">                cout &lt;&lt; <span class="charliteral">' '</span>;</div><div class="line">        }</div><div class="line">        cout &lt;&lt; <span class="charliteral">'}'</span>;</div><div class="line">        ++n;</div><div class="line">        ++combi;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Enumerated "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" combinations."</span> &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>The output of this example is: </p><pre class="fragment">Taking 3 distinct integers in the range [10, 15]: {10 11 12} {10 11 13} {10 11 14}
{10 11 15} {10 12 13} {10 12 14} {10 12 15} {10 13 14} {10 13 15} {10 14 15}
{11 12 13} {11 12 14} {11 12 15} {11 13 14} {11 13 15} {11 14 15} {12 13 14}
{12 13 15} {12 14 15} {13 14 15}
Enumerated 20 combinations.
</pre><h2><a class="anchor" id="GeneratorFromArrayStr"></a>
From an Array of Strings</h2>
<p>The following example generates all pairs of names from a set of names stored in an array of strings.</p>
<p><br />
<b>File</b> <a class="el" href="Generator_2name_pairs_8cpp-example.html">Generator/name_pairs.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "CGAL/Combination_enumerator.h"</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    vector&lt;string&gt; names;</div><div class="line">    names.push_back(<span class="stringliteral">"Sun"</span>);    names.push_back(<span class="stringliteral">"Shannon"</span>);</div><div class="line">    names.push_back(<span class="stringliteral">"Hurley"</span>); names.push_back(<span class="stringliteral">"Sawyer"</span>);</div><div class="line">    names.push_back(<span class="stringliteral">"Kate"</span>);   names.push_back(<span class="stringliteral">"Claire"</span>);</div><div class="line">    names.push_back(<span class="stringliteral">"John"</span>);   names.push_back(<span class="stringliteral">"Jack"</span>);</div><div class="line">    <a class="code" href="classCGAL_1_1Combination__enumerator.html">CGAL::Combination_enumerator&lt;vector&lt;string&gt;::iterator</a>&gt;</div><div class="line">        combi(2, names.begin(), names.end());</div><div class="line">    <span class="keywordflow">while</span>( ! combi.finished() ) {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">" {"</span> &lt;&lt; *combi[0] &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; *combi[1] &lt;&lt; <span class="charliteral">'}'</span>;</div><div class="line">        ++combi;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="GeneratorDesign"></a>
Design and Implementation History</h1>
<p>Lutz Kettner coded generators in 2D and 3D For points <em>in</em> and <em>on</em> sphere, points are generated in a cube up to the moment the point is inside the sphere, then it is normalized to go on the boundary if needed.</p>
<p>Sven Sch√∂nherr implemented the <a class="el" href="classCGAL_1_1Random.html" title="The class Random is a random numbers generator. ">Random</a> class.</p>
<p>Michael Hoffmann coded the random convex polygon,</p>
<p>Geert-Jan Giezeman and Susan Hert coded the random simple polygon.</p>
<p>Olivier Devillers coded generators in high dimensions. For points <em>in ball</em> and <em>on sphere</em>, points are generated on a sphere/ball boundary as a product of normal distributions, then it is normalized. If needed a random radius (with relevant distribution) is used to put the point inside the ball.</p>
<p>Remy Thomasse coded the random convex hull in a disc.</p>
<p>During Google Summer of Code 2013, Pedro M. M. de Castro and Alexandru Tifrea coded generators for points in triangle (2D and 3D) and in tetrahedra (3D). Basically, in order to generate a random point in a \(N\)-simplex (a triangle for \(N = 2\), and tetrahedron for \(N = 3\)), we generate numbers \(a_1,a_2,\ldots,a_N\) identically and independently uniformly distributed in \((0,1)\), we sort them, we let \(a_0 = 0\) and \(a_{N+1} = 1\), and then \(a_{i+1}‚àía_i\), for \(i = 1,\ldots,N\) becomes its barycentric coordinates with respect to the simplex.</p>
<p>Maxime Gimemo introduced the random generators on 2D and 3D triangle meshes. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:02 for CGAL 4.13 - Geometric Object Generators by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
