<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespaceCGAL" kind="namespace" language="C++">
    <compoundname>CGAL</compoundname>
    <innerclass refid="classCGAL_1_1Algebraic__structure__traits" prot="public">CGAL::Algebraic_structure_traits</innerclass>
    <innerclass refid="structCGAL_1_1Boolean__tag" prot="public">CGAL::Boolean_tag</innerclass>
    <innerclass refid="structCGAL_1_1Cast__function__object" prot="public">CGAL::Cast_function_object</innerclass>
    <innerclass refid="classCGAL_1_1CC__safe__handle" prot="public">CGAL::CC_safe_handle</innerclass>
    <innerclass refid="structCGAL_1_1Coercion__traits" prot="public">CGAL::Coercion_traits</innerclass>
    <innerclass refid="structCGAL_1_1Compact" prot="public">CGAL::Compact</innerclass>
    <innerclass refid="classCGAL_1_1Compact__container" prot="public">CGAL::Compact_container</innerclass>
    <innerclass refid="classCGAL_1_1Compact__container__base" prot="public">CGAL::Compact_container_base</innerclass>
    <innerclass refid="structCGAL_1_1Compact__container__traits" prot="public">CGAL::Compact_container_traits</innerclass>
    <innerclass refid="classCGAL_1_1Compare__to__less" prot="public">CGAL::Compare_to_less</innerclass>
    <innerclass refid="classCGAL_1_1Concurrent__compact__container" prot="public">CGAL::Concurrent_compact_container</innerclass>
    <innerclass refid="structCGAL_1_1Concurrent__compact__container__traits" prot="public">CGAL::Concurrent_compact_container_traits</innerclass>
    <innerclass refid="classCGAL_1_1Const__oneset__iterator" prot="public">CGAL::Const_oneset_iterator</innerclass>
    <innerclass refid="structCGAL_1_1Construct__array" prot="public">CGAL::Construct_array</innerclass>
    <innerclass refid="classCGAL_1_1Counting__iterator" prot="public">CGAL::Counting_iterator</innerclass>
    <innerclass refid="classCGAL_1_1Creator__1" prot="public">CGAL::Creator_1</innerclass>
    <innerclass refid="classCGAL_1_1Creator__2" prot="public">CGAL::Creator_2</innerclass>
    <innerclass refid="classCGAL_1_1Creator__3" prot="public">CGAL::Creator_3</innerclass>
    <innerclass refid="classCGAL_1_1Creator__4" prot="public">CGAL::Creator_4</innerclass>
    <innerclass refid="classCGAL_1_1Creator__5" prot="public">CGAL::Creator_5</innerclass>
    <innerclass refid="classCGAL_1_1Creator__uniform__2" prot="public">CGAL::Creator_uniform_2</innerclass>
    <innerclass refid="classCGAL_1_1Creator__uniform__3" prot="public">CGAL::Creator_uniform_3</innerclass>
    <innerclass refid="classCGAL_1_1Creator__uniform__4" prot="public">CGAL::Creator_uniform_4</innerclass>
    <innerclass refid="classCGAL_1_1Creator__uniform__5" prot="public">CGAL::Creator_uniform_5</innerclass>
    <innerclass refid="classCGAL_1_1Creator__uniform__6" prot="public">CGAL::Creator_uniform_6</innerclass>
    <innerclass refid="classCGAL_1_1Creator__uniform__7" prot="public">CGAL::Creator_uniform_7</innerclass>
    <innerclass refid="classCGAL_1_1Creator__uniform__8" prot="public">CGAL::Creator_uniform_8</innerclass>
    <innerclass refid="classCGAL_1_1Creator__uniform__9" prot="public">CGAL::Creator_uniform_9</innerclass>
    <innerclass refid="classCGAL_1_1Creator__uniform__d" prot="public">CGAL::Creator_uniform_d</innerclass>
    <innerclass refid="structCGAL_1_1Default" prot="public">CGAL::Default</innerclass>
    <innerclass refid="structCGAL_1_1Dereference" prot="public">CGAL::Dereference</innerclass>
    <innerclass refid="classCGAL_1_1Dispatch__or__drop__output__iterator" prot="public">CGAL::Dispatch_or_drop_output_iterator</innerclass>
    <innerclass refid="classCGAL_1_1Dispatch__output__iterator" prot="public">CGAL::Dispatch_output_iterator</innerclass>
    <innerclass refid="structCGAL_1_1Emptyset__iterator" prot="public">CGAL::Emptyset_iterator</innerclass>
    <innerclass refid="structCGAL_1_1Euclidean__ring__tag" prot="public">CGAL::Euclidean_ring_tag</innerclass>
    <innerclass refid="structCGAL_1_1Fast" prot="public">CGAL::Fast</innerclass>
    <innerclass refid="structCGAL_1_1Field__tag" prot="public">CGAL::Field_tag</innerclass>
    <innerclass refid="structCGAL_1_1Field__with__kth__root__tag" prot="public">CGAL::Field_with_kth_root_tag</innerclass>
    <innerclass refid="structCGAL_1_1Field__with__root__of__tag" prot="public">CGAL::Field_with_root_of_tag</innerclass>
    <innerclass refid="structCGAL_1_1Field__with__sqrt__tag" prot="public">CGAL::Field_with_sqrt_tag</innerclass>
    <innerclass refid="structCGAL_1_1Filter__iterator" prot="public">CGAL::Filter_iterator</innerclass>
    <innerclass refid="classCGAL_1_1Fourtuple" prot="public">CGAL::Fourtuple</innerclass>
    <innerclass refid="classCGAL_1_1Fraction__traits" prot="public">CGAL::Fraction_traits</innerclass>
    <innerclass refid="structCGAL_1_1Get__address" prot="public">CGAL::Get_address</innerclass>
    <innerclass refid="classCGAL_1_1Gmpfi" prot="public">CGAL::Gmpfi</innerclass>
    <innerclass refid="classCGAL_1_1Gmpfr" prot="public">CGAL::Gmpfr</innerclass>
    <innerclass refid="classCGAL_1_1Gmpq" prot="public">CGAL::Gmpq</innerclass>
    <innerclass refid="classCGAL_1_1Gmpz" prot="public">CGAL::Gmpz</innerclass>
    <innerclass refid="classCGAL_1_1Gmpzf" prot="public">CGAL::Gmpzf</innerclass>
    <innerclass refid="structCGAL_1_1Identity" prot="public">CGAL::Identity</innerclass>
    <innerclass refid="classCGAL_1_1In__place__list" prot="public">CGAL::In_place_list</innerclass>
    <innerclass refid="classCGAL_1_1In__place__list__base" prot="public">CGAL::In_place_list_base</innerclass>
    <innerclass refid="classCGAL_1_1Insert__iterator" prot="public">CGAL::Insert_iterator</innerclass>
    <innerclass refid="structCGAL_1_1Integral__domain__tag" prot="public">CGAL::Integral_domain_tag</innerclass>
    <innerclass refid="structCGAL_1_1Integral__domain__without__division__tag" prot="public">CGAL::Integral_domain_without_division_tag</innerclass>
    <innerclass refid="classCGAL_1_1Interval__nt" prot="public">CGAL::Interval_nt</innerclass>
    <innerclass refid="classCGAL_1_1Inverse__index" prot="public">CGAL::Inverse_index</innerclass>
    <innerclass refid="classCGAL_1_1Is__valid" prot="public">CGAL::Is_valid</innerclass>
    <innerclass refid="classCGAL_1_1Iterator__range" prot="public">CGAL::Iterator_range</innerclass>
    <innerclass refid="classCGAL_1_1Join__input__iterator__1" prot="public">CGAL::Join_input_iterator_1</innerclass>
    <innerclass refid="classCGAL_1_1Join__input__iterator__2" prot="public">CGAL::Join_input_iterator_2</innerclass>
    <innerclass refid="classCGAL_1_1Join__input__iterator__3" prot="public">CGAL::Join_input_iterator_3</innerclass>
    <innerclass refid="classCGAL_1_1Lazy__exact__nt" prot="public">CGAL::Lazy_exact_nt</innerclass>
    <innerclass refid="structCGAL_1_1Location__policy" prot="public">CGAL::Location_policy</innerclass>
    <innerclass refid="structCGAL_1_1Max" prot="public">CGAL::Max</innerclass>
    <innerclass refid="structCGAL_1_1Min" prot="public">CGAL::Min</innerclass>
    <innerclass refid="classCGAL_1_1MP__Float" prot="public">CGAL::MP_Float</innerclass>
    <innerclass refid="structCGAL_1_1Mpzf" prot="public">CGAL::Mpzf</innerclass>
    <innerclass refid="classCGAL_1_1Multiset" prot="public">CGAL::Multiset</innerclass>
    <innerclass refid="classCGAL_1_1N__step__adaptor" prot="public">CGAL::N_step_adaptor</innerclass>
    <innerclass refid="structCGAL_1_1NT__converter" prot="public">CGAL::NT_converter</innerclass>
    <innerclass refid="structCGAL_1_1Null__functor" prot="public">CGAL::Null_functor</innerclass>
    <innerclass refid="structCGAL_1_1Null__tag" prot="public">CGAL::Null_tag</innerclass>
    <innerclass refid="classCGAL_1_1Number__type__checker" prot="public">CGAL::Number_type_checker</innerclass>
    <innerclass refid="classCGAL_1_1Object" prot="public">CGAL::Object</innerclass>
    <innerclass refid="classCGAL_1_1Oneset__iterator" prot="public">CGAL::Oneset_iterator</innerclass>
    <innerclass refid="structCGAL_1_1Parallel__tag" prot="public">CGAL::Parallel_tag</innerclass>
    <innerclass refid="structCGAL_1_1Project__facet" prot="public">CGAL::Project_facet</innerclass>
    <innerclass refid="structCGAL_1_1Project__next" prot="public">CGAL::Project_next</innerclass>
    <innerclass refid="structCGAL_1_1Project__next__opposite" prot="public">CGAL::Project_next_opposite</innerclass>
    <innerclass refid="structCGAL_1_1Project__normal" prot="public">CGAL::Project_normal</innerclass>
    <innerclass refid="structCGAL_1_1Project__opposite__prev" prot="public">CGAL::Project_opposite_prev</innerclass>
    <innerclass refid="structCGAL_1_1Project__plane" prot="public">CGAL::Project_plane</innerclass>
    <innerclass refid="structCGAL_1_1Project__point" prot="public">CGAL::Project_point</innerclass>
    <innerclass refid="structCGAL_1_1Project__prev" prot="public">CGAL::Project_prev</innerclass>
    <innerclass refid="structCGAL_1_1Project__vertex" prot="public">CGAL::Project_vertex</innerclass>
    <innerclass refid="structCGAL_1_1Protect__FPU__rounding" prot="public">CGAL::Protect_FPU_rounding</innerclass>
    <innerclass refid="classCGAL_1_1Quadruple" prot="public">CGAL::Quadruple</innerclass>
    <innerclass refid="classCGAL_1_1Quotient" prot="public">CGAL::Quotient</innerclass>
    <innerclass refid="classCGAL_1_1Random__access__adaptor" prot="public">CGAL::Random_access_adaptor</innerclass>
    <innerclass refid="classCGAL_1_1Random__access__value__adaptor" prot="public">CGAL::Random_access_value_adaptor</innerclass>
    <innerclass refid="classCGAL_1_1Rational__traits" prot="public">CGAL::Rational_traits</innerclass>
    <innerclass refid="classCGAL_1_1Real__embeddable__traits" prot="public">CGAL::Real_embeddable_traits</innerclass>
    <innerclass refid="structCGAL_1_1Root__of__traits" prot="public">CGAL::Root_of_traits</innerclass>
    <innerclass refid="structCGAL_1_1Sequential__tag" prot="public">CGAL::Sequential_tag</innerclass>
    <innerclass refid="classCGAL_1_1Set__ieee__double__precision" prot="public">CGAL::Set_ieee_double_precision</innerclass>
    <innerclass refid="classCGAL_1_1Sixtuple" prot="public">CGAL::Sixtuple</innerclass>
    <innerclass refid="classCGAL_1_1Spatial__lock__grid__3" prot="public">CGAL::Spatial_lock_grid_3</innerclass>
    <innerclass refid="classCGAL_1_1Sqrt__extension" prot="public">CGAL::Sqrt_extension</innerclass>
    <innerclass refid="classCGAL_1_1Threetuple" prot="public">CGAL::Threetuple</innerclass>
    <innerclass refid="classCGAL_1_1Triple" prot="public">CGAL::Triple</innerclass>
    <innerclass refid="classCGAL_1_1Twotuple" prot="public">CGAL::Twotuple</innerclass>
    <innerclass refid="classCGAL_1_1Uncertain" prot="public">CGAL::Uncertain</innerclass>
    <innerclass refid="structCGAL_1_1Unique__factorization__domain__tag" prot="public">CGAL::Unique_factorization_domain_tag</innerclass>
    <innerclass refid="structCGAL_1_1value__type__traits" prot="public">CGAL::value_type_traits</innerclass>
    <innerclass refid="structCGAL_1_1value__type__traits_3_01std_1_1back__insert__iterator_3_01Container_01_4_01_4" prot="public">CGAL::value_type_traits&lt; std::back_insert_iterator&lt; Container &gt; &gt;</innerclass>
    <innerclass refid="structCGAL_1_1value__type__traits_3_01std_1_1front__insert__iterator_3_01Container_01_4_01_4" prot="public">CGAL::value_type_traits&lt; std::front_insert_iterator&lt; Container &gt; &gt;</innerclass>
    <innerclass refid="structCGAL_1_1value__type__traits_3_01std_1_1insert__iterator_3_01Container_01_4_01_4" prot="public">CGAL::value_type_traits&lt; std::insert_iterator&lt; Container &gt; &gt;</innerclass>
    <innernamespace refid="namespaceCGAL_1_1cpp11">CGAL::cpp11</innernamespace>
    <innernamespace refid="namespaceCGAL_1_1cpp98">CGAL::cpp98</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__PkgStlExtensionAssertions_1gac5eee7bb7edcc41dd3251042c5934dee" prot="public" static="no">
        <name>Failure_behaviour</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__PkgStlExtensionUtilities_1ga96bf435aef680d59e1bcb722239222dd" prot="public" static="no">
        <type><ref refid="structCGAL_1_1Location__policy" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Location_policy</ref>&lt; <ref refid="structCGAL_1_1Compact" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Compact</ref> &gt;</type>
        <definition>typedef Location_policy&lt; Compact &gt; CGAL::Compact_location</definition>
        <argsstring></argsstring>
        <name>Compact_location</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag" line="1" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PkgStlExtensionUtilities_1ga8f61a2b71f265bad92d78ae606afc830" prot="public" static="no">
        <type><ref refid="structCGAL_1_1Location__policy" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Location_policy</ref>&lt; <ref refid="structCGAL_1_1Fast" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Fast</ref> &gt;</type>
        <definition>typedef Location_policy&lt; Fast &gt; CGAL::Fast_location</definition>
        <argsstring></argsstring>
        <name>Fast_location</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag" line="1" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PkgStlExtensionUtilities_1ga89d5ecf1540b2ec0a2bf5dd003e186d0" prot="public" static="no">
        <type><ref refid="structCGAL_1_1Boolean__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Boolean_tag</ref>&lt; false &gt;</type>
        <definition>typedef CGAL::Boolean_tag&lt; false &gt; CGAL::Tag_false</definition>
        <argsstring></argsstring>
        <name>Tag_false</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag" line="1" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PkgStlExtensionUtilities_1gab3e2296107b5d26c32c8183028a217f1" prot="public" static="no">
        <type><ref refid="structCGAL_1_1Boolean__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Boolean_tag</ref>&lt; true &gt;</type>
        <definition>typedef CGAL::Boolean_tag&lt; true &gt; CGAL::Tag_true</definition>
        <argsstring></argsstring>
        <name>Tag_true</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag" line="1" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PkgStlExtensionAssertions_1ga22c85e11e31ba1f9954022947822983d" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* CGAL::Failure_function)(const char *type, const char *expression, const char *file, int line, const char *explanation)</definition>
        <argsstring>)(const char *type, const char *expression, const char *file, int line, const char *explanation)</argsstring>
        <name>Failure_function</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag" line="1" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__nt__cgal_1ga2e3fce8233225177f57d66e7ed00880f" prot="public" static="no">
        <type><ref refid="classCGAL_1_1Interval__nt" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Interval_nt</ref>&lt; false &gt;</type>
        <definition>typedef Interval_nt&lt; false &gt; CGAL::Interval_nt_advanced</definition>
        <argsstring></argsstring>
        <name>Interval_nt_advanced</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag" line="1" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__nt__cgal_1gae96d924c796bfc4e781d28f81df43c52" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Exact_integer</definition>
        <argsstring></argsstring>
        <name>Exact_integer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag" line="1" column="1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__nt__cgal_1ga0849ff44771b19582218ebdfa5614f64" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Exact_rational</definition>
        <argsstring></argsstring>
        <name>Exact_rational</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag" line="1" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="group__PkgStlExtensionAssertions_1ggac5eee7bb7edcc41dd3251042c5934deeafd47edae67791f804b5f1b616f2782ff" prot="public" static="no" mutable="no">
        <type></type>
        <definition>CGAL::ABORT</definition>
        <argsstring></argsstring>
        <name>ABORT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag" line="1" column="1"/>
      </memberdef>
      <memberdef kind="variable" id="group__PkgStlExtensionAssertions_1ggac5eee7bb7edcc41dd3251042c5934deea03e7a9436476c257881f8ce46db26f7d" prot="public" static="no" mutable="no">
        <type></type>
        <definition>CGAL::EXIT</definition>
        <argsstring></argsstring>
        <name>EXIT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag" line="1" column="1"/>
      </memberdef>
      <memberdef kind="variable" id="group__PkgStlExtensionAssertions_1ggac5eee7bb7edcc41dd3251042c5934deeaf7034bd0320b9bca60e23c0be889d728" prot="public" static="no" mutable="no">
        <type></type>
        <definition>CGAL::EXIT_WITH_SUCCESS</definition>
        <argsstring></argsstring>
        <name>EXIT_WITH_SUCCESS</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag" line="1" column="1"/>
      </memberdef>
      <memberdef kind="variable" id="group__PkgStlExtensionAssertions_1ggac5eee7bb7edcc41dd3251042c5934deea697442e04c769afa5f8506d7dd378ed4" prot="public" static="no" mutable="no">
        <type></type>
        <definition>CGAL::CONTINUE</definition>
        <argsstring></argsstring>
        <name>CONTINUE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag" line="1" column="1"/>
      </memberdef>
      <memberdef kind="variable" id="group__PkgStlExtensionAssertions_1ggac5eee7bb7edcc41dd3251042c5934deea47ef91f2d5d0efcdc748c65519d3532d" prot="public" static="no" mutable="no">
        <type></type>
        <definition>CGAL::THROW_EXCEPTION</definition>
        <argsstring></argsstring>
        <name>THROW_EXCEPTION</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag" line="1" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__STLAlgos_1gacb8df77d1d07b9cfff3fdd2f5d9c4fda" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::copy_n</definition>
        <argsstring>(InputIterator first, Size n, OutputIterator result)</argsstring>
        <name>copy_n</name>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>n</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__STLAlgos_1gab7b9c20885fa91f21f014d849a07e9c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::pair&lt; <ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref>, <ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref> &gt;</type>
        <definition>std::pair&lt; ForwardIterator, ForwardIterator &gt; CGAL::min_max_element</definition>
        <argsstring>(ForwardIterator first, ForwardIterator last)</argsstring>
        <name>min_max_element</name>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__STLAlgos_1gaf404b198e27ef4018bc5185c9e7da751" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::pair&lt; <ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref>, <ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref> &gt;</type>
        <definition>std::pair&lt; ForwardIterator, ForwardIterator &gt; CGAL::min_max_element</definition>
        <argsstring>(ForwardIterator first, ForwardIterator last, CompareMin comp_min, CompareMax comp_max)</argsstring>
        <name>min_max_element</name>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>last</declname>
        </param>
        <param>
          <type>CompareMin</type>
          <declname>comp_min</declname>
        </param>
        <param>
          <type>CompareMax</type>
          <declname>comp_max</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__STLAlgos_1ga6c5d40930db429775066babac7c35d7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classBidirectionalIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">BidirectionalIterator</ref></type>
        <definition>BidirectionalIterator CGAL::predecessor</definition>
        <argsstring>(BidirectionalIterator it)</argsstring>
        <name>predecessor</name>
        <param>
          <type><ref refid="classBidirectionalIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">BidirectionalIterator</ref></type>
          <declname>it</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__STLAlgos_1gaeda33e3a2c07e29ca0f6d209182ced7c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
        <definition>ForwardIterator CGAL::successor</definition>
        <argsstring>(ForwardIterator it)</argsstring>
        <name>successor</name>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>it</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__CompactContainer_1ga041244256532c067edf94bd31141558d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1CC__safe__handle" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CC_safe_handle</ref>&lt; CC_iterator &gt;</type>
        <definition>CC_safe_handle&lt; CC_iterator &gt; CGAL::make_cc_safe_handle</definition>
        <argsstring>(CC_iterator iterator)</argsstring>
        <name>make_cc_safe_handle</name>
        <param>
          <type>CC_iterator</type>
          <declname>iterator</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__projectionobjects_1gaa343b4e41668290985efff5def93ca7c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Compare__to__less" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Compare_to_less</ref>&lt; F &gt;</type>
        <definition>Compare_to_less&lt; F &gt; CGAL::compare_to_less</definition>
        <argsstring>(const F &amp;f)</argsstring>
        <name>compare_to_less</name>
        <param>
          <type>const F &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceCGAL_1a266177f3e138c748f9906f7abb76320b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Iterator__range" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Iterator_range</ref>&lt; T &gt;</type>
        <definition>Iterator_range&lt; T &gt; CGAL::make_range</definition>
        <argsstring>(const T &amp;b, const T &amp;e)</argsstring>
        <name>make_range</name>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceCGAL_1a20aeec74989e860c5f20c11a844aad53" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>T</type>
        <definition>T CGAL::range_begin</definition>
        <argsstring>(Iterator_range&lt; T &gt; &amp;x)</argsstring>
        <name>range_begin</name>
        <param>
          <type><ref refid="classCGAL_1_1Iterator__range" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Iterator_range</ref>&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceCGAL_1acd0d74e5e80884f3c33b663e1e576435" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>T</type>
        <definition>T CGAL::range_end</definition>
        <argsstring>(Iterator_range&lt; T &gt; &amp;x)</argsstring>
        <name>range_end</name>
        <param>
          <type><ref refid="classCGAL_1_1Iterator__range" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Iterator_range</ref>&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceCGAL_1af0be841eaa3070123a308353961d2695" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>T</type>
        <definition>T CGAL::range_begin</definition>
        <argsstring>(const Iterator_range&lt; T &gt; &amp;x)</argsstring>
        <name>range_begin</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Iterator__range" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Iterator_range</ref>&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceCGAL_1a97c1af46c1e40a2f68495e0947e681b2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>T</type>
        <definition>T CGAL::range_end</definition>
        <argsstring>(const Iterator_range&lt; T &gt; &amp;x)</argsstring>
        <name>range_end</name>
        <param>
          <type>const <ref refid="classCGAL_1_1Iterator__range" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Iterator_range</ref>&lt; T &gt; &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgStlExtensionAssertions_1gaf17f67aed4fb6c658ec7cb3f96f9d838" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PkgStlExtensionAssertions_1ga22c85e11e31ba1f9954022947822983d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Failure_function</ref></type>
        <definition>Failure_function CGAL::set_error_handler</definition>
        <argsstring>(Failure_function handler)</argsstring>
        <name>set_error_handler</name>
        <param>
          <type><ref refid="group__PkgStlExtensionAssertions_1ga22c85e11e31ba1f9954022947822983d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Failure_function</ref></type>
          <declname>handler</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgStlExtensionAssertions_1ga7bf05b83505d915fb23cb23337b34c3e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PkgStlExtensionAssertions_1ga22c85e11e31ba1f9954022947822983d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Failure_function</ref></type>
        <definition>Failure_function CGAL::set_warning_handler</definition>
        <argsstring>(Failure_function handler)</argsstring>
        <name>set_warning_handler</name>
        <param>
          <type><ref refid="group__PkgStlExtensionAssertions_1ga22c85e11e31ba1f9954022947822983d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Failure_function</ref></type>
          <declname>handler</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgStlExtensionAssertions_1ga57511207f5935f17b3264e2d03124027" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PkgStlExtensionAssertions_1gac5eee7bb7edcc41dd3251042c5934dee" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Failure_behaviour</ref></type>
        <definition>Failure_behaviour CGAL::set_error_behaviour</definition>
        <argsstring>(Failure_behaviour eb)</argsstring>
        <name>set_error_behaviour</name>
        <param>
          <type><ref refid="group__PkgStlExtensionAssertions_1gac5eee7bb7edcc41dd3251042c5934dee" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Failure_behaviour</ref></type>
          <declname>eb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgStlExtensionAssertions_1gaeb4e85bca7bfc12e7fd086bf36a39a77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PkgStlExtensionAssertions_1gac5eee7bb7edcc41dd3251042c5934dee" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Failure_behaviour</ref></type>
        <definition>Failure_behaviour CGAL::set_warning_behaviour</definition>
        <argsstring>(Failure_behaviour eb)</argsstring>
        <name>set_warning_behaviour</name>
        <param>
          <type><ref refid="group__PkgStlExtensionAssertions_1gac5eee7bb7edcc41dd3251042c5934dee" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Failure_behaviour</ref></type>
          <declname>eb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceCGAL_1a47f0ae53dc4a6e546cf85257048a5512" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::is_finite</definition>
        <argsstring>(double x)</argsstring>
        <name>is_finite</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceCGAL_1a565f1b98f0d166db4a117ebf3bec0ea6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::is_finite</definition>
        <argsstring>(float x)</argsstring>
        <name>is_finite</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceCGAL_1a4b32f8f9b95fc15d00f5bee8f5c83e25" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::is_finite</definition>
        <argsstring>(long double x)</argsstring>
        <name>is_finite</name>
        <param>
          <type>long double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__nt__ralgebraic_1ga7b3b3eb35124b0c46373c88e324a7a95" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::compute_roots_of_2</definition>
        <argsstring>(const RT &amp;a, const RT &amp;b, const RT &amp;c, OutputIterator oit)</argsstring>
        <name>compute_roots_of_2</name>
        <param>
          <type>const RT &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const RT &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const RT &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>oit</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__nt__ralgebraic_1ga4cb90aeebfe5ff7cf7eef83ae2f09918" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structCGAL_1_1Root__of__traits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Root_of_traits</ref>&lt; RT &gt;::Root_of_2</type>
        <definition>Root_of_traits&lt; RT &gt;::Root_of_2 CGAL::make_root_of_2</definition>
        <argsstring>(const RT &amp;a, const RT &amp;b, const RT &amp;c, bool s)</argsstring>
        <name>make_root_of_2</name>
        <param>
          <type>const RT &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const RT &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const RT &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__nt__ralgebraic_1ga9f5fc25b40d694cc581931db4a1f8245" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structCGAL_1_1Root__of__traits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Root_of_traits</ref>&lt; RT &gt;::Root_of_2</type>
        <definition>Root_of_traits&lt; RT &gt;::Root_of_2 CGAL::make_root_of_2</definition>
        <argsstring>(RT alpha, RT beta, RT gamma)</argsstring>
        <name>make_root_of_2</name>
        <param>
          <type>RT</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>RT</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>RT</type>
          <declname>gamma</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__nt__ralgebraic_1ga65dbf48e30821c7445bc50480e3c5242" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structCGAL_1_1Root__of__traits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Root_of_traits</ref>&lt; RT &gt;::Root_of_2</type>
        <definition>Root_of_traits&lt; RT &gt;::Root_of_2 CGAL::make_sqrt</definition>
        <argsstring>(const RT &amp;x)</argsstring>
        <name>make_sqrt</name>
        <param>
          <type>const RT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__nt__rrational_1ga17858fbeefd20878349736beb169df97" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Rational</type>
        <definition>Rational CGAL::simplest_rational_in_interval</definition>
        <argsstring>(double d1, double d2)</argsstring>
        <name>simplest_rational_in_interval</name>
        <param>
          <type>double</type>
          <declname>d1</declname>
        </param>
        <param>
          <type>double</type>
          <declname>d2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__nt__rrational_1gaac65e38f22218d07ff294d8bf72790a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Rational</type>
        <definition>Rational CGAL::to_rational</definition>
        <argsstring>(double d)</argsstring>
        <name>to_rational</name>
        <param>
          <type>double</type>
          <declname>d</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__nt__util_1ga06ee6c8472c94e9f14d6fc94b6b7079b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::is_valid</definition>
        <argsstring>(const T &amp;x)</argsstring>
        <name>is_valid</name>
        <param>
          <type>const T &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__nt__util_1gad7dbfa919e255b52f36ea1512a92cb78" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>T</type>
        <definition>T CGAL::max</definition>
        <argsstring>(const T &amp;x, const T &amp;y)</argsstring>
        <name>max</name>
        <param>
          <type>const T &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__nt__util_1gab0ad1dbf97e8a81da183514138f583e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>T</type>
        <definition>T CGAL::min</definition>
        <argsstring>(const T &amp;x, const T &amp;y)</argsstring>
        <name>min</name>
        <param>
          <type>const T &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="" line="1" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga1d5106cf8be16adb4c4dc8b1ec3a5a92" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::abs</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>abs</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga1d5106cf8be16adb4c4dc8b1ec3a5a92" kindref="member">abs()</ref></computeroutput> returns the absolute value of a number. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1Abs" kindref="compound">RealEmbeddableTraits_::Abs</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="15" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga0397c01d0ea2364b92e98141e221e9bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::compare</definition>
        <argsstring>(const NT &amp;x, const NT &amp;y)</argsstring>
        <name>compare</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga0397c01d0ea2364b92e98141e221e9bb" kindref="member">compare()</ref></computeroutput> compares the first argument with respect to the second, i.e. it returns <computeroutput>CGAL::LARGER</computeroutput> if <formula id="0">$ x$</formula> is larger then <formula id="1">$ y$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, <computeroutput>compare</computeroutput> is performed with the semantic of the type determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>. The function is defined if this type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>CGAL::Comparison_result</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1Compare" kindref="compound">RealEmbeddableTraits_::Compare</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="39" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gae246e686f794e878361621e6d4898b5a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::div</definition>
        <argsstring>(const NT1 &amp;x, const NT2 &amp;y)</argsstring>
        <name>div</name>
        <param>
          <type>const NT1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT2 &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gae246e686f794e878361621e6d4898b5a" kindref="member">div()</ref></computeroutput> computes the integral quotient of division with remainder. </para>        </briefdescription>
        <detaileddescription>
<para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, the <computeroutput>result_type</computeroutput> is determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>.</para><para>Thus, the <computeroutput>result_type</computeroutput> is well defined if <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> are a model of <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>.</para><para>The actual <computeroutput>div</computeroutput> is performed with the semantic of that type.</para><para>The function is defined if <computeroutput>result_type</computeroutput> is a model of the <computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Div" kindref="compound">AlgebraicStructureTraits_::Div</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gac6bc445c0fc83ed997549ce869b7bae7" kindref="member">CGAL::mod()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga3445213fb9bc055253f5c346ce1693f6" kindref="member">CGAL::div_mod()</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="70" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga3445213fb9bc055253f5c346ce1693f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::div_mod</definition>
        <argsstring>(const NT1 &amp;x, const NT2 &amp;y, result_type &amp;q, result_type &amp;r)</argsstring>
        <name>div_mod</name>
        <param>
          <type>const NT1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT2 &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>result_type &amp;</type>
          <declname>q</declname>
        </param>
        <param>
          <type>result_type &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>computes the quotient <formula id="2">$ q$</formula> and remainder <formula id="3">$ r$</formula>, such that <formula id="4">$ x = q*y + r$</formula> and <formula id="3">$ r$</formula> minimal with respect to the Euclidean Norm of the <computeroutput>result_type</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga3445213fb9bc055253f5c346ce1693f6" kindref="member">div_mod()</ref></computeroutput> computes the integral quotient and remainder of division with remainder.</para><para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, the <computeroutput>result_type</computeroutput> is determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>.</para><para>Thus, the <computeroutput>result_type</computeroutput> is well defined if <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> are a model of <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>.</para><para>The actual <computeroutput>div_mod</computeroutput> is performed with the semantic of that type.</para><para>The function is defined if <computeroutput>result_type</computeroutput> is a model of the <computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1DivMod" kindref="compound">AlgebraicStructureTraits_::DivMod</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gac6bc445c0fc83ed997549ce869b7bae7" kindref="member">CGAL::mod()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gae246e686f794e878361621e6d4898b5a" kindref="member">CGAL::div()</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="105" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gade2b63594fb6827c33c0dcd73b4c7cfe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::gcd</definition>
        <argsstring>(const NT1 &amp;x, const NT2 &amp;y)</argsstring>
        <name>gcd</name>
        <param>
          <type>const NT1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT2 &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gade2b63594fb6827c33c0dcd73b4c7cfe" kindref="member">gcd()</ref></computeroutput> computes the greatest common divisor of two values. </para>        </briefdescription>
        <detaileddescription>
<para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, the <computeroutput>result_type</computeroutput> is determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>.</para><para>Thus, the <computeroutput>result_type</computeroutput> is well defined if <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> are a model of <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>.</para><para>The actual <computeroutput>gcd</computeroutput> is performed with the semantic of that type.</para><para>The function is defined if <computeroutput>result_type</computeroutput> is a model of the <computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Gcd" kindref="compound">AlgebraicStructureTraits_::Gcd</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="132" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga59e55b9e023c50ddb15c89fae4b68387" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::integral_division</definition>
        <argsstring>(const NT1 &amp;x, const NT2 &amp;y)</argsstring>
        <name>integral_division</name>
        <param>
          <type>const NT1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT2 &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga59e55b9e023c50ddb15c89fae4b68387" kindref="member">integral_division()</ref></computeroutput> (a.k.a. exact division or division without remainder) maps ring elements <formula id="5">$ (x,y)$</formula> to ring element <formula id="6">$ z$</formula> such that <formula id="7">$ x = yz$</formula> if such a <formula id="6">$ z$</formula> exists (i.e. if <formula id="0">$ x$</formula> is divisible by <formula id="1">$ y$</formula>). </para>        </briefdescription>
        <detaileddescription>
<para>Otherwise the effect of invoking this operation is undefined. Since the ring represented is an integral domain, <formula id="6">$ z$</formula> is uniquely defined if it exists.</para><para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, the <computeroutput>result_type</computeroutput> is determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>.</para><para>Thus, the <computeroutput>result_type</computeroutput> is well defined if <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> are a model of <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>.</para><para>The actual <computeroutput>integral_division</computeroutput> is performed with the semantic of that type.</para><para>The function is defined if <computeroutput>result_type</computeroutput> is a model of the <computeroutput><ref refid="classIntegralDomain" kindref="compound">IntegralDomain</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomain" kindref="compound">IntegralDomain</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IntegralDivision" kindref="compound">AlgebraicStructureTraits_::IntegralDivision</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="163" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga3152b245b3c1c2fccd78e1dc27942598" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::inverse</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>inverse</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga3152b245b3c1c2fccd78e1dc27942598" kindref="member">inverse()</ref></computeroutput> returns the inverse element with respect to multiplication. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput> concept.</para><para><simplesect kind="pre"><para><formula id="8">$ x \neq0$</formula>.</para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Inverse" kindref="compound">AlgebraicStructureTraits_::Inverse</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="183" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gab752a78af2e16a42c5bd8c09fafeb585" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>result_type</type>
        <definition>result_type CGAL::is_negative</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>is_negative</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gab752a78af2e16a42c5bd8c09fafeb585" kindref="member">is_negative()</ref></computeroutput> determines if a value is negative or not. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1IsNegative" kindref="compound">RealEmbeddableTraits_::IsNegative</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="202" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gab57640546cf6cf7e56d37a652927a6f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::is_one</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>is_one</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gab57640546cf6cf7e56d37a652927a6f7" kindref="member">is_one()</ref></computeroutput> determines if a value is equal to 1 or not. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IsOne" kindref="compound">AlgebraicStructureTraits_::IsOne</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="222" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gabbfc28149479e41f56111ffe692c07d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>result_type</type>
        <definition>result_type CGAL::is_positive</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>is_positive</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gabbfc28149479e41f56111ffe692c07d5" kindref="member">is_positive()</ref></computeroutput> determines if a value is positive or not. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1IsPositive" kindref="compound">RealEmbeddableTraits_::IsPositive</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="241" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga9e2d81a5ae3384b07b0f5848e8ae7bfa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::is_square</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>is_square</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>An ring element <formula id="0">$ x$</formula> is said to be a square iff there exists a ring element <formula id="1">$ y$</formula> such that <formula id="9">$ x= y*y$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>In case the ring is a <computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput>, <formula id="1">$ y$</formula> is uniquely defined up to multiplication by units.</para><para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga9e2d81a5ae3384b07b0f5848e8ae7bfa" kindref="member">is_square()</ref></computeroutput> is available if <computeroutput>Algebraic_structure_traits::Is_square</computeroutput> is not the <computeroutput><ref refid="structCGAL_1_1Null__functor" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Null_functor</ref></computeroutput>.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IsSquare" kindref="compound">AlgebraicStructureTraits_::IsSquare</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="264" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga890f40c3e1aa8708d1e1fb72fdfd7834" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::is_square</definition>
        <argsstring>(const NT &amp;x, NT &amp;y)</argsstring>
        <name>is_square</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>NT &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>An ring element <formula id="0">$ x$</formula> is said to be a square iff there exists a ring element <formula id="1">$ y$</formula> such that <formula id="9">$ x= y*y$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>In case the ring is a <computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput>, <formula id="1">$ y$</formula> is uniquely defined up to multiplication by units.</para><para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga9e2d81a5ae3384b07b0f5848e8ae7bfa" kindref="member">is_square()</ref></computeroutput> is available if <computeroutput>Algebraic_structure_traits::Is_square</computeroutput> is not the <computeroutput><ref refid="structCGAL_1_1Null__functor" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Null_functor</ref></computeroutput>.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IsSquare" kindref="compound">AlgebraicStructureTraits_::IsSquare</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="283" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga997aad1528e7e744e54a807caa2be56e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::is_zero</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>is_zero</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga997aad1528e7e744e54a807caa2be56e" kindref="member">is_zero()</ref></computeroutput> determines if a value is equal to 0 or not. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> or of the <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1IsZero" kindref="compound">RealEmbeddableTraits_::IsZero</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IsZero" kindref="compound">AlgebraicStructureTraits_::IsZero</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="305" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gabac14fc6cb4f556c19958b60f3305b9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::kth_root</definition>
        <argsstring>(int k, const NT &amp;x)</argsstring>
        <name>kth_root</name>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gabac14fc6cb4f556c19958b60f3305b9d" kindref="member">kth_root()</ref></computeroutput> returns the k-th root of a value. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the second argument type is a model of the <computeroutput><ref refid="classFieldWithKthRoot" kindref="compound">FieldWithKthRoot</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classFieldWithKthRoot" kindref="compound">FieldWithKthRoot</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1KthRoot" kindref="compound">AlgebraicStructureTraits_::KthRoot</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="323" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gac6bc445c0fc83ed997549ce869b7bae7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::mod</definition>
        <argsstring>(const NT1 &amp;x, const NT2 &amp;y)</argsstring>
        <name>mod</name>
        <param>
          <type>const NT1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT2 &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gac6bc445c0fc83ed997549ce869b7bae7" kindref="member">mod()</ref></computeroutput> computes the remainder of division with remainder. </para>        </briefdescription>
        <detaileddescription>
<para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, the <computeroutput>result_type</computeroutput> is determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>.</para><para>Thus, the <computeroutput>result_type</computeroutput> is well defined if <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> are a model of <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>.</para><para>The actual <computeroutput>mod</computeroutput> is performed with the semantic of that type.</para><para>The function is defined if <computeroutput>result_type</computeroutput> is a model of the <computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1DivMod" kindref="compound">AlgebraicStructureTraits_::DivMod</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga3445213fb9bc055253f5c346ce1693f6" kindref="member">CGAL::div_mod()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gae246e686f794e878361621e6d4898b5a" kindref="member">CGAL::div()</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="353" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga975ad8b8b91cd67463c6c2be863d16a2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::root_of</definition>
        <argsstring>(int k, InputIterator begin, InputIterator end)</argsstring>
        <name>root_of</name>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>begin</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>returns the k-th real root of the univariate polynomial, which is defined by the iterator range, where begin refers to the constant term. </para>        </briefdescription>
        <detaileddescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga975ad8b8b91cd67463c6c2be863d16a2" kindref="member">root_of()</ref></computeroutput> computes a real root of a square-free univariate polynomial.</para><para>The function is defined if the value type, <computeroutput>NT</computeroutput>, of the iterator range is a model of the <computeroutput><ref refid="classFieldWithRootOf" kindref="compound">FieldWithRootOf</ref></computeroutput> concept.</para><para><simplesect kind="pre"><para>The polynomial is square-free.</para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classFieldWithRootOf" kindref="compound">FieldWithRootOf</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1RootOf" kindref="compound">AlgebraicStructureTraits_::RootOf</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="379" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gaf3d75d272a29458960987a8f248ec636" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::sign</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>sign</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gaf3d75d272a29458960987a8f248ec636" kindref="member">sign()</ref></computeroutput> returns the sign of its argument. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>CGAL::Sign</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1Sgn" kindref="compound">RealEmbeddableTraits_::Sgn</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="399" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga5339b0f11fdc9babbc5ca0b33f4a982c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::simplify</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>simplify</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga5339b0f11fdc9babbc5ca0b33f4a982c" kindref="member">simplify()</ref></computeroutput> may simplify a given object. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Simplify" kindref="compound">AlgebraicStructureTraits_::Simplify</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="417" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::sqrt</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member">sqrt()</ref></computeroutput> returns the square root of a value. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classFieldWithSqrt" kindref="compound">FieldWithSqrt</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classFieldWithSqrt" kindref="compound">FieldWithSqrt</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Sqrt" kindref="compound">AlgebraicStructureTraits_::Sqrt</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="435" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga07001b5ddc5c43096c811c91a306be9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::square</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>square</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member">square()</ref></computeroutput> returns the square of a number. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Square" kindref="compound">AlgebraicStructureTraits_::Square</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="453" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double CGAL::to_double</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>to_double</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member">to_double()</ref></computeroutput> returns a double approximation of a number. </para>        </briefdescription>
        <detaileddescription>
<para>Note that in general, the value returned is not guaranteed to be the same when called several times on the same number. For example, if <computeroutput>NT</computeroutput> is a lazy number type (such as an instance of <computeroutput><ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Lazy_exact_nt</ref></computeroutput>), the double approximation returned might be affected by an exact computation internally triggered (that might have improved the double approximation).</para><para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para>Remark: In order to control the quality of approximation one has to resort to methods that are specific to NT. There are no general guarantees whatsoever.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1ToDouble" kindref="compound">RealEmbeddableTraits_::ToDouble</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="478" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gac30124cb713e69f02816e2b91c655fa6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; double, double &gt;</type>
        <definition>std::pair&lt;double,double&gt; CGAL::to_interval</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>to_interval</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gac30124cb713e69f02816e2b91c655fa6" kindref="member">to_interval()</ref></computeroutput> computes for a given real embeddable number <formula id="0">$ x$</formula> a double interval containing <formula id="0">$ x$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>This interval is represented by a <computeroutput>std::pair&lt;double,double&gt;</computeroutput>. The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1ToInterval" kindref="compound">RealEmbeddableTraits_::ToInterval</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="498" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga46969193a368780228dd0855cdc424b2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::unit_part</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>unit_part</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga46969193a368780228dd0855cdc424b2" kindref="member">unit_part()</ref></computeroutput> computes the unit part of a given ring element. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1UnitPart" kindref="compound">AlgebraicStructureTraits_::UnitPart</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="517" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag" line="1" column="1"/>
  </compounddef>
</doxygen>
