<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Algebraic_Foundations"/>  <simplesect kind="author"><para>Michael Hemmer</para></simplesect>
</para><sect1 id="index_1Algebraic_foundationsIntroduction">
<title>Introduction</title>
<para>CGAL is targeting towards exact computation with non-linear objects, in particular objects defined on algebraic curves and surfaces. As a consequence types representing polynomials, algebraic extensions and finite fields play a more important role in related implementations. This package has been introduced to stay abreast of these changes. Since in particular polynomials must be supported by the introduced framework the package avoids the term <emphasis>number type</emphasis>. Instead the package distinguishes between the <emphasis>algebraic structure</emphasis> of a type and whether a type is embeddable on the real axis, or <emphasis>real embeddable</emphasis> for short. Moreover, the package introduces the notion of <emphasis>interoperable</emphasis> types which allows an explicit handling of mixed operations.</para></sect1>
<sect1 id="index_1Algebraic_foundationsAlgebraic">
<title>Algebraic Structures</title>
<para>The algebraic structure concepts introduced within this section are motivated by their well known counterparts in traditional algebra, but we also had to pay tribute to existing types and their restrictions. To keep the interface minimal, it was not desirable to cover all known algebraic structures, e.g., we did not introduce concepts for such basic structures as <emphasis>groups</emphasis> or exceptional structures as <emphasis>skew fields</emphasis>.</para><para><anchor id="index_1fig__figConceptHierarchyOfAlgebraicStructures"/><image type="html" name="AlgebraicConceptHierarchy.png"></image>
 <image type="latex" name="AlgebraicConceptHierarchy.png" width="15cm"></image>
  <ref refid="index_1fig__figConceptHierarchyOfAlgebraicStructures" kindref="member">fig__figConceptHierarchyOfAlgebraicStructures</ref> Concept Hierarchy of Algebraic Structures  <linebreak/>
</para><para><ref refid="index_1fig__figConceptHierarchyOfAlgebraicStructures" kindref="member">fig__figConceptHierarchyOfAlgebraicStructures</ref> shows the refinement relationship of the algebraic structure concepts. <computeroutput><ref refid="classIntegralDomain" kindref="compound">IntegralDomain</ref></computeroutput>, <computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput>, <computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> and <computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput> correspond to the algebraic structures with the same name. <computeroutput><ref refid="classFieldWithSqrt" kindref="compound">FieldWithSqrt</ref></computeroutput>, <computeroutput><ref refid="classFieldWithKthRoot" kindref="compound">FieldWithKthRoot</ref></computeroutput> and <computeroutput><ref refid="classFieldWithRootOf" kindref="compound">FieldWithRootOf</ref></computeroutput> are fields that in addition are closed under the operations &apos;sqrt&apos;, &apos;k-th root&apos; and &apos;real root of a polynomial&apos;, respectively. The concept <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> also corresponds to integral domains in the algebraic sense, the distinction results from the fact that some implementations of integral domains lack the (algebraically always well defined) integral division. Note that <computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput> refines <computeroutput><ref refid="classIntegralDomain" kindref="compound">IntegralDomain</ref></computeroutput>. This is because most ring-theoretic notions like greatest common divisors become trivial for <computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput>s. Hence we see <computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput> as a refinement of <computeroutput><ref refid="classIntegralDomain" kindref="compound">IntegralDomain</ref></computeroutput> and not as a refinement of one of the more advanced ring concepts. If an algorithm wants to rely on gcd or remainder computation, it is trying to do things it should not do with a <computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput> in the first place.</para><para>The main properties of an algebraic structure are collected in the class <computeroutput><ref refid="classCGAL_1_1Algebraic__structure__traits" kindref="compound">Algebraic_structure_traits</ref></computeroutput>. In particular the (most refined) concept each concrete model <computeroutput>AS</computeroutput> fulfills is encoded in the tag <ref refid="classAlgebraicStructureTraits_1aa5ceaea55d77df93eb00cb537af0e5f3" kindref="member"><computeroutput>Algebraic_structure_traits&lt;AS&gt;::Algebraic_category</computeroutput> </ref> . An algebraic structure is at least <computeroutput><ref refid="classAssignable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">Assignable</ref></computeroutput>, <computeroutput><ref refid="classCopyConstructible" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CopyConstructible</ref></computeroutput>, <computeroutput><ref refid="classDefaultConstructible" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">DefaultConstructible</ref></computeroutput> and <computeroutput><ref refid="classEqualityComparable" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">EqualityComparable</ref></computeroutput>. Moreover, we require that it is constructible from <computeroutput>int</computeroutput>. For ease of use and since their semantic is sufficiently standard to presume their existence, the usual arithmetic and comparison operators are required to be realized via C++ operator overloading. The division operator is reserved for division in fields. All other unary (e.g., sqrt) and binary functions (e.g., gcd, div) must be models of the well known STL-concepts <computeroutput><ref refid="classAdaptableUnaryFunction" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">AdaptableUnaryFunction</ref></computeroutput> or <computeroutput><ref refid="classAdaptableBinaryFunction" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">AdaptableBinaryFunction</ref></computeroutput> concept and local to the traits class (e.g., <ref refid="classAlgebraicStructureTraits_1a5fcefa3646991324dbf00f7905116c41" kindref="member"><computeroutput>Algebraic_structure_traits&lt;AS&gt;::Sqrt()(x)</computeroutput> </ref>). This design allows us to profit from all parts in the STL and its programming style and avoids the name-lookup and two-pass template compilation problems experienced with the old design using overloaded functions. However, for ease of use and backward compatibility all functionality is also accessible through global functions defined within namespace <computeroutput><ref refid="namespaceCGAL" kindref="compound">CGAL</ref></computeroutput>, e.g., <ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member"><computeroutput>CGAL::sqrt(x)</computeroutput> </ref>. This is realized via function templates using the according functor of the traits class. For an overview see Section <ref refid="group__PkgAlgebraicFoundations" kindref="compound">Algebraic Foundations Reference</ref> in the reference manual.</para><sect2 id="index_1Algebraic_foundationsTagsinAlgebraicStructure">
<title>Tags in Algebraic Structure Traits</title>
</sect2>
<sect2 id="index_1Algebraic_foundationsAlgebraicCategory">
<title>Algebraic Category</title>
<para>For a type <computeroutput>AS</computeroutput>, <computeroutput><ref refid="classCGAL_1_1Algebraic__structure__traits" kindref="compound">Algebraic_structure_traits</ref>&lt;AS&gt;</computeroutput> provides several tags. The most important tag is the <computeroutput>Algebraic_category</computeroutput> tag, which indicates the most refined algebraic concept the type <computeroutput>AS</computeroutput> fulfills. The tag is one of; <computeroutput><ref refid="structCGAL_1_1Integral__domain__without__division__tag" kindref="compound">Integral_domain_without_division_tag</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Integral__domain__tag" kindref="compound">Integral_domain_tag</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Field__tag" kindref="compound">Field_tag</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Field__with__sqrt__tag" kindref="compound">Field_with_sqrt_tag</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Field__with__kth__root__tag" kindref="compound">Field_with_kth_root_tag</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Field__with__root__of__tag" kindref="compound">Field_with_root_of_tag</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Unique__factorization__domain__tag" kindref="compound">Unique_factorization_domain_tag</ref></computeroutput>, <computeroutput><ref refid="structCGAL_1_1Euclidean__ring__tag" kindref="compound">Euclidean_ring_tag</ref></computeroutput>, or even <computeroutput><ref refid="structCGAL_1_1Null__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Null_tag</ref></computeroutput> in case the type is not a model of an algebraic structure concept. The tags are derived from each other such that they reflect the hierarchy of the algebraic structure concept, e.g., <computeroutput><ref refid="structCGAL_1_1Field__with__sqrt__tag" kindref="compound">Field_with_sqrt_tag</ref></computeroutput> is derived from <computeroutput><ref refid="structCGAL_1_1Field__tag" kindref="compound">Field_tag</ref></computeroutput>.</para></sect2>
<sect2 id="index_1Algebraic_foundationsExactandNumericalSensitive">
<title>Exact and Numerical Sensitive</title>
<para>Moreover, <computeroutput><ref refid="classCGAL_1_1Algebraic__structure__traits" kindref="compound">Algebraic_structure_traits</ref>&lt;AS&gt;</computeroutput> provides the tags <computeroutput>Is_exact</computeroutput> and <computeroutput>Is_numerical_sensitive</computeroutput>, which are both <computeroutput><ref refid="structCGAL_1_1Boolean__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Boolean_tag</ref></computeroutput>s.</para><para>An algebraic structure is considered <emphasis>exact</emphasis>, if all operations required by its concept are computed such that a comparison of two algebraic expressions is always correct.</para><para>An algebraic structure is considered as <emphasis>numerically sensitive</emphasis>, if the performance of the type is sensitive to the condition number of an algorithm. Note that there is really a difference among these two notions, e.g., the fundamental type <computeroutput>int</computeroutput> is not numerical sensitive but considered inexact due to overflow. Conversely, types as <computeroutput><ref refid="classleda__real" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">leda_real</ref></computeroutput> or <computeroutput><ref refid="classCORE_1_1Expr" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CORE::Expr</ref></computeroutput> are exact but sensitive to numerical issues due to the internal use of multi precision floating point arithmetic. We expect that <computeroutput>Is_numerical_sensitive</computeroutput> is used for dispatching of algorithms, while <computeroutput>Is_exact</computeroutput> is useful to enable assertions that can be check for exact types only.</para><para>Tags are very useful to dispatch between alternative implementations. The following example illustrates a dispatch for <computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput>s using overloaded functions. The example only needs two overloads since the algebraic category tags reflect the algebraic structure hierarchy.</para><para><linebreak/>
<bold>File</bold> <ref refid="Algebraic_foundations_2algebraic_structure_dispatch_8cpp-example" kindref="compound">Algebraic_foundations/algebraic_structure_dispatch.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/io.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Algebraic_structure_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>NT<sp/>&gt;<sp/>NT<sp/><ref refid="group__PkgAlgebraicFoundations_1ga46969193a368780228dd0855cdc424b2" kindref="member">unit_part</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>NT&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>NT<sp/>&gt;<sp/></highlight></codeline>
<codeline><highlight class="normal">NT<sp/>unit_part_(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>NT&amp;<sp/>x,<sp/><ref refid="structCGAL_1_1Field__tag" kindref="compound">CGAL::Field_tag</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>NT<sp/>&gt;<sp/></highlight></codeline>
<codeline><highlight class="normal">NT<sp/>unit_part_(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>NT&amp;<sp/>x,<sp/><ref refid="structCGAL_1_1Integral__domain__without__division__tag" kindref="compound">CGAL::Integral_domain_without_division_tag</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>NT<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal">NT<sp/><ref refid="group__PkgAlgebraicFoundations_1ga46969193a368780228dd0855cdc424b2" kindref="member">unit_part</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>NT&amp;<sp/>x){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>unit<sp/>part<sp/>of<sp/>0<sp/>is<sp/>defined<sp/>as<sp/>1.<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(x<sp/>==<sp/>0<sp/>)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NT(1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Algebraic__structure__traits" kindref="compound">CGAL::Algebraic_structure_traits&lt;NT&gt;</ref><sp/>AST;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AST::Algebraic_category<sp/>Algebraic_category;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>unit_part_(x,Algebraic_category());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>NT<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal">NT<sp/>unit_part_(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>NT&amp;<sp/>x,<sp/><ref refid="structCGAL_1_1Integral__domain__without__division__tag" kindref="compound">CGAL::Integral_domain_without_division_tag</ref>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>many<sp/>other<sp/>types<sp/>the<sp/>only<sp/>units<sp/>are<sp/>just<sp/>-1<sp/>and<sp/>+1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NT(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">(<ref refid="group__PkgAlgebraicFoundations_1gaf3d75d272a29458960987a8f248ec636" kindref="member">CGAL::sign</ref>(x)));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>NT<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal">NT<sp/>unit_part_(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>NT&amp;<sp/>x,<sp/><ref refid="structCGAL_1_1Field__tag" kindref="compound">CGAL::Field_tag</ref>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>Fields<sp/>every<sp/>x<sp/>!=<sp/>0<sp/>is<sp/>a<sp/>unit.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Therefore,<sp/>every<sp/>x<sp/>!=<sp/>0<sp/>is<sp/>its<sp/>own<sp/>unit<sp/>part.<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>x;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Function<sp/>call<sp/>for<sp/>a<sp/>model<sp/>of<sp/>EuclideanRing,<sp/>i.e.<sp/>int.<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;int:<sp/><sp/><sp/><sp/>unit_part(-3<sp/><sp/>):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga46969193a368780228dd0855cdc424b2" kindref="member">unit_part</ref>(-3<sp/><sp/>)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Function<sp/>call<sp/>for<sp/>a<sp/>model<sp/>of<sp/>FieldWithSqrt,<sp/>i.e.<sp/>double<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;double:<sp/>unit_part(-3.0):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1ga46969193a368780228dd0855cdc424b2" kindref="member">unit_part</ref>(-3.0)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>this<sp/>is<sp/>just<sp/>an<sp/>example<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>implementation<sp/>for<sp/>unit<sp/>part<sp/>won&apos;t<sp/>work<sp/>for<sp/>some<sp/>types,<sp/>e.g.,<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>types<sp/>that<sp/>are<sp/>not<sp/>RealEmbeddable<sp/>or<sp/>types<sp/>representing<sp/>structures<sp/>that<sp/>have<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>more<sp/>units<sp/>than<sp/>just<sp/>-1<sp/>and<sp/>+1.<sp/>(e.g.<sp/>MP_Float<sp/>representing<sp/>Z[1/2])</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>From<sp/>there<sp/>Algebraic_structure_traits<sp/>provides<sp/>the<sp/>functor<sp/>Unit_part.<sp/><sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Algebraic_foundationsRealE">
<title>Real Embeddable</title>
<para><anchor id="index_1secRealEmbeddable"/> Most number types represent some subset of the real numbers. From those types we expect functionality to compute the sign, absolute value or double approximations. In particular we can expect an order on such a type that reflects the order along the real axis. All these properties are gathered in the concept <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput>. The concept is orthogonal to the algebraic structure concepts, i.e., it is possible that a type is a model of <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> only, since the type may just represent values on the real axis but does not provide any arithmetic operations.</para><para>As for algebraic structures this concept is also traits class oriented. The main functionality related to <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> is gathered in the class <computeroutput><ref refid="classCGAL_1_1Real__embeddable__traits" kindref="compound">Real_embeddable_traits</ref></computeroutput>. In particular, it porivdes the boolean tag <computeroutput>Is_real_embeddable</computeroutput> indicating whether a type is a model of <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput>. The comparison operators are required to be realized via C++ operator overloading. All unary functions (e.g. <emphasis>sign</emphasis>, <emphasis>to_double</emphasis>) and binary functions (e.g. <emphasis>compare</emphasis> ) are models of the STL-concepts <computeroutput><ref refid="classAdaptableUnaryFunction" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">AdaptableUnaryFunction</ref></computeroutput> and <computeroutput><ref refid="classAdaptableBinaryFunction" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">AdaptableBinaryFunction</ref></computeroutput> and are local to <computeroutput><ref refid="classCGAL_1_1Real__embeddable__traits" kindref="compound">Real_embeddable_traits</ref></computeroutput>.</para><para>In case a type is a model of <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> and <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> the number represented by an object of this type is the same for arithmetic and comparison. It follows that the ring represented by this type is a superset of the integers and a subset of the real numbers and hence has characteristic zero.</para><para>In case the type is a model of <computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput> and <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> it is a superset of the rational numbers.</para></sect1>
<sect1 id="index_1Algebraic_foundationsRealN">
<title>Real Number Types</title>
<para>Every CGAL <computeroutput>Kernel</computeroutput> comes with two <emphasis>real number types</emphasis> (number types embeddable into the real numbers). One of them is a <computeroutput><ref refid="classFieldNumberType" kindref="compound">FieldNumberType</ref></computeroutput>, and the other a <computeroutput><ref refid="classRingNumberType" kindref="compound">RingNumberType</ref></computeroutput>. The coordinates of the basic kernel objects (points, vectors, etc.) come from one of these types (the <computeroutput><ref refid="classFieldNumberType" kindref="compound">FieldNumberType</ref></computeroutput> in case of Cartesian kernels, and the <computeroutput><ref refid="classRingNumberType" kindref="compound">RingNumberType</ref></computeroutput> for Homogeneous kernels).</para><para>The concept <computeroutput><ref refid="classFieldNumberType" kindref="compound">FieldNumberType</ref></computeroutput> combines the requirements of the concepts <computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput> and <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput>, while <computeroutput><ref refid="classRingNumberType" kindref="compound">RingNumberType</ref></computeroutput> combines <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> and <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput>. Algebraically, the real number types do not form distinct structures and are therefore not listed in the concept hierarchy of <ref refid="index_1fig__figConceptHierarchyOfAlgebraicStructures" kindref="member">fig__figConceptHierarchyOfAlgebraicStructures</ref>.</para></sect1>
<sect1 id="index_1Algebraic_foundationsInteroperability">
<title>Interoperability</title>
<para>This section introduces two concepts for interoperability of types, namely <computeroutput><ref refid="classImplicitInteroperable" kindref="compound">ImplicitInteroperable</ref></computeroutput> and <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>. While <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput> is the base concept, we start with <computeroutput><ref refid="classImplicitInteroperable" kindref="compound">ImplicitInteroperable</ref></computeroutput> since it is the more intuitive one.</para><para>In general mixed operations are provided by overloaded operators and functions or just via implicit constructor calls. This level of interoperability is reflected by the concept <computeroutput><ref refid="classImplicitInteroperable" kindref="compound">ImplicitInteroperable</ref></computeroutput>. However, within template code the result type, or so called coercion type, of a mixed arithmetic operation may be unclear. Therefore, the package introduces <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput> giving access to the coercion type via <ref refid="structCGAL_1_1Coercion__traits_1adaa0ff8242fb38714a52ca411dcd5664" kindref="member"><computeroutput>Coercion_traits&lt;A,B&gt;::Type</computeroutput> </ref> for two interoperable types <computeroutput>A</computeroutput> and <computeroutput>B</computeroutput>.</para><para>Some trivial example are <computeroutput>int</computeroutput> and <computeroutput>double</computeroutput> with coercion type double or <computeroutput><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpz</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput> with coercion type <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput>. However, the coercion type is not necessarily one of the input types, e.g. the coercion type of a polynomial with integer coefficients that is multiplied by a rational type is supposed to be a polynomial with rational coefficients.</para><para><computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput> is also required to provide a functor <ref refid="structCGAL_1_1Coercion__traits_1a3241b3224d183bf3e0ce5d80b9100c4c" kindref="member"><computeroutput>Coercion_traits&lt;A,B&gt;::Cast()</computeroutput> </ref>, that converts from an input type into the coercion type. This is in fact the core of the more basic concept <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>. <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput> has been introduced to cover more complex cases for which it is hard or impossible to guarantee implicit interoperability. Note that this functor can be useful for <computeroutput><ref refid="classImplicitInteroperable" kindref="compound">ImplicitInteroperable</ref></computeroutput> types as well, since it can be used to void redundant type conversions.</para><para>In case two types <computeroutput>A</computeroutput> and <computeroutput>B</computeroutput> are <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput> with coercion type <computeroutput>C</computeroutput> they are valid argument types for all binary functors provided by <computeroutput><ref refid="classCGAL_1_1Algebraic__structure__traits" kindref="compound">Algebraic_structure_traits</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Real__embeddable__traits" kindref="compound">Real_embeddable_traits</ref></computeroutput> of <computeroutput>C</computeroutput>. This is also true for the according global functions.</para><sect2 id="index_1Algebraic_foundationsExamples">
<title>Examples</title>
<para>The following example illustrates how two write code for <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput> types.</para><para><linebreak/>
<bold>File</bold> <ref refid="Algebraic_foundations_2interoperable_8cpp-example" kindref="compound">Algebraic_foundations/interoperable.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Coercion_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/io.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>this<sp/>is<sp/>an<sp/>implementation<sp/>for<sp/>ExplicitInteroperable<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>result<sp/>type<sp/>is<sp/>determined<sp/>via<sp/>Coercion_traits&lt;A,B&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>A,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>B&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Coercion_traits&lt;A,B&gt;::Type</ref></highlight></codeline>
<codeline><highlight class="normal">binary_func(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>A&amp;<sp/>a<sp/>,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>B&amp;<sp/>b){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">CGAL::Coercion_traits&lt;A,B&gt;</ref><sp/>CT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>for<sp/>explicit<sp/>interoperability</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_static_assertion((CT::Are_explicit_interoperable::value));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>CT::Cast<sp/>is<sp/>used<sp/>to<sp/>to<sp/>convert<sp/>both<sp/>types<sp/>into<sp/>the<sp/>coercion<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>CT::Cast<sp/>cast;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>all<sp/>operations<sp/>are<sp/>performed<sp/>in<sp/>the<sp/>coercion<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cast(a)*cast(b);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Function<sp/>call<sp/>for<sp/>the<sp/>interoperable<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;<sp/>binary_func(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">(3),<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">(5))<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>Coercion_traits<sp/>is<sp/>symmetric</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;<sp/>binary_func(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">(3),<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">(5))<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The following example illustrates a dispatch for <computeroutput><ref refid="classImplicitInteroperable" kindref="compound">ImplicitInteroperable</ref></computeroutput> and <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput> types. The binary function (that just multiplies its two arguments) is supposed to take two <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput> arguments. For <computeroutput><ref refid="classImplicitInteroperable" kindref="compound">ImplicitInteroperable</ref></computeroutput> types a variant that avoids the explicit cast is selected.</para><para><linebreak/>
<bold>File</bold> <ref refid="Algebraic_foundations_2implicit_interoperable_dispatch_8cpp-example" kindref="compound">Algebraic_foundations/implicit_interoperable_dispatch.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Coercion_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Quotient_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Quotient.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Sqrt__extension_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Sqrt_extension.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/io.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>this<sp/>is<sp/>the<sp/>implementation<sp/>for<sp/>ExplicitInteroperable<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>A,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>B&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Coercion_traits&lt;A,B&gt;::Type</ref></highlight></codeline>
<codeline><highlight class="normal">binary_function_(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>A&amp;<sp/>a<sp/>,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>B&amp;<sp/>b,<sp/><ref refid="structCGAL_1_1Boolean__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Tag_false</ref>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Call<sp/>for<sp/>ExplicitInteroperable<sp/>types:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">CGAL::Coercion_traits&lt;A,B&gt;</ref><sp/>CT;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>CT::Cast<sp/>cast;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cast(a)*cast(b);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>this<sp/>is<sp/>the<sp/>implementation<sp/>for<sp/>ImplicitInteroperable<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>A,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>B&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Coercion_traits&lt;A,B&gt;::Type</ref></highlight></codeline>
<codeline><highlight class="normal">binary_function_(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>A&amp;<sp/>a<sp/>,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>B&amp;<sp/>b,<sp/><ref refid="structCGAL_1_1Boolean__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Tag_true</ref>){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Call<sp/>for<sp/>ImpicitInteroperable<sp/>types:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>a*b;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>this<sp/>function<sp/>selects<sp/>the<sp/>correct<sp/>implementation</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>A,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>B&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">CGAL::Coercion_traits&lt;A,B&gt;::Type</ref></highlight></codeline>
<codeline><highlight class="normal">binary_func(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>A&amp;<sp/>a<sp/>,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>B&amp;<sp/>b){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">CGAL::Coercion_traits&lt;A,B&gt;</ref><sp/>CT;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>CT::Are_implicit_interoperable<sp/>Are_implicit_interoperable;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>binary_function_(a,b,Are_implicit_interoperable());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::set_pretty_mode(std::cout);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Function<sp/>call<sp/>for<sp/>ImplicitInteroperable<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;<sp/>binary_func(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">(3),<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">(5))<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Function<sp/>call<sp/>for<sp/>ExplicitInteroperable<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Quotient&lt;int&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rational(1,3);<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>==<sp/>1/3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Sqrt__extension" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Sqrt_extension&lt;int,int&gt;</ref><sp/>extension(1,2,3);<sp/></highlight><highlight class="comment">//<sp/>==<sp/>1+2*sqrt(3)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Sqrt__extension" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Sqrt_extension&lt;CGAL::Quotient&lt;int&gt;</ref>,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;<sp/>result<sp/>=<sp/>binary_func(rational,<sp/>extension);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;<sp/>result<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Algebraic_foundationsFractions">
<title>Fractions</title>
<para>Beyond the need for performing algebraic operations on objects as a whole, there are also number types which one would like to decompose into numerator and denominator. This does not only hold for rational numbers as <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Quotient</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput>, <computeroutput><ref refid="classmpq__class" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">mpq_class</ref></computeroutput> or <computeroutput><ref refid="classleda__rational" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">leda_rational</ref></computeroutput>, but also for compound objects as <computeroutput><ref refid="classCGAL_1_1Sqrt__extension" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Sqrt_extension</ref></computeroutput> or <computeroutput>Polynomial</computeroutput> which may decompose into a (scalar) denominator and a compound numerator with a simpler coefficient type (e.g. integer instead of rational). Often operations can be performed faster on these denominator-free multiples. In case a type is a <computeroutput><ref refid="classFraction" kindref="compound">Fraction</ref></computeroutput> the relevant functionality as well as the numerator and denominator type are provided by <computeroutput><ref refid="classCGAL_1_1Fraction__traits" kindref="compound">Fraction_traits</ref></computeroutput>. In particular <computeroutput><ref refid="classCGAL_1_1Fraction__traits" kindref="compound">Fraction_traits</ref></computeroutput> provides a tag <ref refid="classFractionTraits_1adccf11bdb413fee30cb4f229c9450ee7" kindref="member"><computeroutput>Is_fraction</computeroutput> </ref> that can be used for dispatching.</para><para>A related class is <computeroutput><ref refid="classCGAL_1_1Rational__traits" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Rational_traits</ref></computeroutput> which has been kept for backward compatibility reasons. However, we recommend to use <computeroutput><ref refid="classCGAL_1_1Fraction__traits" kindref="compound">Fraction_traits</ref></computeroutput> since it is more general and offers dispatching functionality.</para><sect2 id="index_1Algebraic_foundationsExamples_1">
<title>Examples</title>
<para>The following example show a simple use of <computeroutput><ref refid="classCGAL_1_1Fraction__traits" kindref="compound">Fraction_traits</ref></computeroutput>: <linebreak/>
<bold>File</bold> <ref refid="Algebraic_foundations_2fraction_traits_8cpp-example" kindref="compound">Algebraic_foundations/fraction_traits.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Fraction_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/io.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_GMP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Gmpz_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Gmpz.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Gmpq_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Gmpq.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Fraction__traits" kindref="compound">CGAL::Fraction_traits&lt;CGAL::Gmpq&gt;</ref><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>FT::Numerator_type<sp/>Numerator_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>FT::Denominator_type<sp/>Denominator_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_static_assertion((boost::is_same&lt;Numerator_type,CGAL::Gmpz&gt;::value));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_static_assertion((boost::is_same&lt;Denominator_type,CGAL::Gmpz&gt;::value));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Numerator_type<sp/>numerator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Denominator_type<sp/>denominator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Gmpq</ref><sp/>fraction(4,5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT::Decompose()(fraction,numerator,denominator);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::set_pretty_mode(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;decompose<sp/>fraction:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;fraction<sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fraction<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;numerator<sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>numerator&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;denominator:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>denominator<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;re-compose<sp/>fraction:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fraction<sp/>=<sp/>FT::Compose()(numerator,denominator);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;fraction<sp/><sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fraction<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>examples<sp/>needs<sp/>GMP&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para><para>The following example illustrates the integralization of a vector, i.e., the coefficient vector of a polynomial. Note that for minimizing coefficient growth <ref refid="classFractionTraits_1abc51eea7ae3ec76c3e51c118a2fc32f9" kindref="member"><computeroutput>Fraction_traits&lt;Type&gt;::Common_factor</computeroutput> </ref> is used to compute the <emphasis>least</emphasis> common multiple of the denominators.</para><para><linebreak/>
<bold>File</bold> <ref refid="Algebraic_foundations_2integralize_8cpp-example" kindref="compound">Algebraic_foundations/integralize.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Fraction_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/io.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Fraction&gt;</highlight></codeline>
<codeline><highlight class="normal">std::vector&lt;typename<sp/>CGAL::Fraction_traits&lt;Fraction&gt;::Numerator_type<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal">integralize(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Fraction&gt;&amp;<sp/>vec,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Fraction__traits" kindref="compound">CGAL::Fraction_traits&lt;Fraction&gt;::Denominator_type</ref>&amp;<sp/>d</highlight></codeline>
<codeline><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Fraction__traits" kindref="compound">CGAL::Fraction_traits&lt;Fraction&gt;</ref><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>FT::Numerator_type<sp/>Numerator_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>FT::Denominator_type<sp/>Denominator_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>FT::Decompose<sp/>decompose;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Numerator_type&gt;<sp/><sp/><sp/>num(vec.size());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Denominator_type&gt;<sp/>den(vec.size());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>decompose<sp/>each<sp/>coefficient<sp/>into<sp/>integral<sp/>part<sp/>and<sp/>denominator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>vec.size();<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>decompose(vec[i],<sp/>num[i],<sp/>den[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>&apos;least&apos;<sp/>common<sp/>multiple<sp/>of<sp/>all<sp/>denominator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>would<sp/>like<sp/>to<sp/>use<sp/>gcd,<sp/>so<sp/>let&apos;s<sp/>think<sp/>of<sp/>Common_factor<sp/>as<sp/>gcd.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>FT::Common_factor<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PkgAlgebraicFoundations_1gade2b63594fb6827c33c0dcd73b4c7cfe" kindref="member">gcd</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>d<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>vec.size();<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>d<sp/>*=<sp/><ref refid="group__PkgAlgebraicFoundations_1ga59e55b9e023c50ddb15c89fae4b68387" kindref="member">CGAL::integral_division</ref>(den[i],<sp/><ref refid="group__PkgAlgebraicFoundations_1gade2b63594fb6827c33c0dcd73b4c7cfe" kindref="member">gcd</ref>(d,<sp/>den[i]));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>expand<sp/>each<sp/>(numerator,<sp/>denominator)<sp/>pair<sp/>to<sp/>common<sp/>denominator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>vec.size();<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>simplicity<sp/>ImplicitInteroperability<sp/>is<sp/>expected<sp/>in<sp/>this<sp/>example</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num[i]<sp/>*=<sp/><ref refid="group__PkgAlgebraicFoundations_1ga59e55b9e023c50ddb15c89fae4b68387" kindref="member">CGAL::integral_division</ref>(d,<sp/>den[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>num;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_GMP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Gmpz_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Gmpz.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Gmpq_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Gmpq.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;CGAL::Gmpq&gt;<sp/>vec(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vec[0]=<ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Gmpq</ref>(1,4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vec[1]=<ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Gmpq</ref>(1,6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vec[2]=<ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Gmpq</ref>(1,10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;compute<sp/>an<sp/>integralized<sp/>vector&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;input<sp/>vector:<sp/><sp/>[&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>vec[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vec[1]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vec[2]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Gmpz</ref><sp/>d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;CGAL::Gmpz&gt;<sp/>integral_vec<sp/>=<sp/>integralize(vec,d);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;output<sp/>vector:<sp/>[&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>integral_vec[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>integral_vec[1]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>integral_vec[2]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;denominator<sp/><sp/>:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>d<sp/>&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>examples<sp/>needs<sp/>GMP&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Algebraic_foundationsDesign">
<title>Design and Implementation History</title>
<para>The package is part of CGAL since release 3.3. Of course the package is based on the former Number type support of <ref refid="namespaceCGAL" kindref="compound">CGAL</ref>. This goes back to Stefan Schirra and Andreas Fabri. But on the other hand the package is to a large extend influenced by the experience with the number type support in Exacus <ref refid="citelist_1CITEREF_beh-eeeafcs-05" kindref="member">[1]</ref>, which in the main goes back to Lutz Kettner, Susan Hert, Arno Eigenwillig and Michael Hemmer. However, the package abstracts from the pure support for number types that are embedded on the real axis which allows the support of polynomials, finite fields, and algebraic extensions as well. See also related subsequent chapters. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
