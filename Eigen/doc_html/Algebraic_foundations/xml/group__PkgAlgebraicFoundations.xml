<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="group__PkgAlgebraicFoundations" kind="group">
    <compoundname>PkgAlgebraicFoundations</compoundname>
    <title>Algebraic Foundations Reference</title>
    <innerclass refid="classCGAL_1_1Algebraic__structure__traits" prot="public">CGAL::Algebraic_structure_traits</innerclass>
    <innerclass refid="structCGAL_1_1Euclidean__ring__tag" prot="public">CGAL::Euclidean_ring_tag</innerclass>
    <innerclass refid="structCGAL_1_1Field__tag" prot="public">CGAL::Field_tag</innerclass>
    <innerclass refid="structCGAL_1_1Field__with__kth__root__tag" prot="public">CGAL::Field_with_kth_root_tag</innerclass>
    <innerclass refid="structCGAL_1_1Field__with__root__of__tag" prot="public">CGAL::Field_with_root_of_tag</innerclass>
    <innerclass refid="structCGAL_1_1Field__with__sqrt__tag" prot="public">CGAL::Field_with_sqrt_tag</innerclass>
    <innerclass refid="structCGAL_1_1Integral__domain__tag" prot="public">CGAL::Integral_domain_tag</innerclass>
    <innerclass refid="structCGAL_1_1Integral__domain__without__division__tag" prot="public">CGAL::Integral_domain_without_division_tag</innerclass>
    <innerclass refid="structCGAL_1_1Unique__factorization__domain__tag" prot="public">CGAL::Unique_factorization_domain_tag</innerclass>
    <innerclass refid="structCGAL_1_1Coercion__traits" prot="public">CGAL::Coercion_traits</innerclass>
    <innerclass refid="classCGAL_1_1Fraction__traits" prot="public">CGAL::Fraction_traits</innerclass>
    <innerclass refid="classCGAL_1_1Real__embeddable__traits" prot="public">CGAL::Real_embeddable_traits</innerclass>
    <innergroup refid="group__PkgAlgebraicFoundationsAlgebraicStructuresConcepts">Concepts</innergroup>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga1d5106cf8be16adb4c4dc8b1ec3a5a92" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::abs</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>abs</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga1d5106cf8be16adb4c4dc8b1ec3a5a92" kindref="member">abs()</ref></computeroutput> returns the absolute value of a number. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1Abs" kindref="compound">RealEmbeddableTraits_::Abs</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="15" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga0397c01d0ea2364b92e98141e221e9bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::compare</definition>
        <argsstring>(const NT &amp;x, const NT &amp;y)</argsstring>
        <name>compare</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga0397c01d0ea2364b92e98141e221e9bb" kindref="member">compare()</ref></computeroutput> compares the first argument with respect to the second, i.e. it returns <computeroutput>CGAL::LARGER</computeroutput> if <formula id="0">$ x$</formula> is larger then <formula id="1">$ y$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, <computeroutput>compare</computeroutput> is performed with the semantic of the type determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>. The function is defined if this type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>CGAL::Comparison_result</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1Compare" kindref="compound">RealEmbeddableTraits_::Compare</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="39" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gae246e686f794e878361621e6d4898b5a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::div</definition>
        <argsstring>(const NT1 &amp;x, const NT2 &amp;y)</argsstring>
        <name>div</name>
        <param>
          <type>const NT1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT2 &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gae246e686f794e878361621e6d4898b5a" kindref="member">div()</ref></computeroutput> computes the integral quotient of division with remainder. </para>        </briefdescription>
        <detaileddescription>
<para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, the <computeroutput>result_type</computeroutput> is determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>.</para><para>Thus, the <computeroutput>result_type</computeroutput> is well defined if <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> are a model of <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>.</para><para>The actual <computeroutput>div</computeroutput> is performed with the semantic of that type.</para><para>The function is defined if <computeroutput>result_type</computeroutput> is a model of the <computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Div" kindref="compound">AlgebraicStructureTraits_::Div</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gac6bc445c0fc83ed997549ce869b7bae7" kindref="member">CGAL::mod()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga3445213fb9bc055253f5c346ce1693f6" kindref="member">CGAL::div_mod()</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="70" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga3445213fb9bc055253f5c346ce1693f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::div_mod</definition>
        <argsstring>(const NT1 &amp;x, const NT2 &amp;y, result_type &amp;q, result_type &amp;r)</argsstring>
        <name>div_mod</name>
        <param>
          <type>const NT1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT2 &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>result_type &amp;</type>
          <declname>q</declname>
        </param>
        <param>
          <type>result_type &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>computes the quotient <formula id="2">$ q$</formula> and remainder <formula id="3">$ r$</formula>, such that <formula id="4">$ x = q*y + r$</formula> and <formula id="3">$ r$</formula> minimal with respect to the Euclidean Norm of the <computeroutput>result_type</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga3445213fb9bc055253f5c346ce1693f6" kindref="member">div_mod()</ref></computeroutput> computes the integral quotient and remainder of division with remainder.</para><para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, the <computeroutput>result_type</computeroutput> is determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>.</para><para>Thus, the <computeroutput>result_type</computeroutput> is well defined if <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> are a model of <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>.</para><para>The actual <computeroutput>div_mod</computeroutput> is performed with the semantic of that type.</para><para>The function is defined if <computeroutput>result_type</computeroutput> is a model of the <computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1DivMod" kindref="compound">AlgebraicStructureTraits_::DivMod</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gac6bc445c0fc83ed997549ce869b7bae7" kindref="member">CGAL::mod()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gae246e686f794e878361621e6d4898b5a" kindref="member">CGAL::div()</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="105" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gade2b63594fb6827c33c0dcd73b4c7cfe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::gcd</definition>
        <argsstring>(const NT1 &amp;x, const NT2 &amp;y)</argsstring>
        <name>gcd</name>
        <param>
          <type>const NT1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT2 &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gade2b63594fb6827c33c0dcd73b4c7cfe" kindref="member">gcd()</ref></computeroutput> computes the greatest common divisor of two values. </para>        </briefdescription>
        <detaileddescription>
<para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, the <computeroutput>result_type</computeroutput> is determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>.</para><para>Thus, the <computeroutput>result_type</computeroutput> is well defined if <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> are a model of <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>.</para><para>The actual <computeroutput>gcd</computeroutput> is performed with the semantic of that type.</para><para>The function is defined if <computeroutput>result_type</computeroutput> is a model of the <computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Gcd" kindref="compound">AlgebraicStructureTraits_::Gcd</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="132" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga59e55b9e023c50ddb15c89fae4b68387" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::integral_division</definition>
        <argsstring>(const NT1 &amp;x, const NT2 &amp;y)</argsstring>
        <name>integral_division</name>
        <param>
          <type>const NT1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT2 &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga59e55b9e023c50ddb15c89fae4b68387" kindref="member">integral_division()</ref></computeroutput> (a.k.a. exact division or division without remainder) maps ring elements <formula id="5">$ (x,y)$</formula> to ring element <formula id="6">$ z$</formula> such that <formula id="7">$ x = yz$</formula> if such a <formula id="6">$ z$</formula> exists (i.e. if <formula id="0">$ x$</formula> is divisible by <formula id="1">$ y$</formula>). </para>        </briefdescription>
        <detaileddescription>
<para>Otherwise the effect of invoking this operation is undefined. Since the ring represented is an integral domain, <formula id="6">$ z$</formula> is uniquely defined if it exists.</para><para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, the <computeroutput>result_type</computeroutput> is determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>.</para><para>Thus, the <computeroutput>result_type</computeroutput> is well defined if <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> are a model of <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>.</para><para>The actual <computeroutput>integral_division</computeroutput> is performed with the semantic of that type.</para><para>The function is defined if <computeroutput>result_type</computeroutput> is a model of the <computeroutput><ref refid="classIntegralDomain" kindref="compound">IntegralDomain</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomain" kindref="compound">IntegralDomain</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IntegralDivision" kindref="compound">AlgebraicStructureTraits_::IntegralDivision</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="163" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga3152b245b3c1c2fccd78e1dc27942598" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::inverse</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>inverse</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga3152b245b3c1c2fccd78e1dc27942598" kindref="member">inverse()</ref></computeroutput> returns the inverse element with respect to multiplication. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput> concept.</para><para><simplesect kind="pre"><para><formula id="8">$ x \neq0$</formula>.</para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Inverse" kindref="compound">AlgebraicStructureTraits_::Inverse</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="183" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gab752a78af2e16a42c5bd8c09fafeb585" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>result_type</type>
        <definition>result_type CGAL::is_negative</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>is_negative</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gab752a78af2e16a42c5bd8c09fafeb585" kindref="member">is_negative()</ref></computeroutput> determines if a value is negative or not. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1IsNegative" kindref="compound">RealEmbeddableTraits_::IsNegative</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="202" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gab57640546cf6cf7e56d37a652927a6f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::is_one</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>is_one</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gab57640546cf6cf7e56d37a652927a6f7" kindref="member">is_one()</ref></computeroutput> determines if a value is equal to 1 or not. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IsOne" kindref="compound">AlgebraicStructureTraits_::IsOne</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="222" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gabbfc28149479e41f56111ffe692c07d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>result_type</type>
        <definition>result_type CGAL::is_positive</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>is_positive</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gabbfc28149479e41f56111ffe692c07d5" kindref="member">is_positive()</ref></computeroutput> determines if a value is positive or not. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1IsPositive" kindref="compound">RealEmbeddableTraits_::IsPositive</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="241" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga9e2d81a5ae3384b07b0f5848e8ae7bfa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::is_square</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>is_square</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>An ring element <formula id="0">$ x$</formula> is said to be a square iff there exists a ring element <formula id="1">$ y$</formula> such that <formula id="9">$ x= y*y$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>In case the ring is a <computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput>, <formula id="1">$ y$</formula> is uniquely defined up to multiplication by units.</para><para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga9e2d81a5ae3384b07b0f5848e8ae7bfa" kindref="member">is_square()</ref></computeroutput> is available if <computeroutput>Algebraic_structure_traits::Is_square</computeroutput> is not the <computeroutput><ref refid="structCGAL_1_1Null__functor" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Null_functor</ref></computeroutput>.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IsSquare" kindref="compound">AlgebraicStructureTraits_::IsSquare</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="264" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga890f40c3e1aa8708d1e1fb72fdfd7834" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::is_square</definition>
        <argsstring>(const NT &amp;x, NT &amp;y)</argsstring>
        <name>is_square</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>NT &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>An ring element <formula id="0">$ x$</formula> is said to be a square iff there exists a ring element <formula id="1">$ y$</formula> such that <formula id="9">$ x= y*y$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>In case the ring is a <computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput>, <formula id="1">$ y$</formula> is uniquely defined up to multiplication by units.</para><para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga9e2d81a5ae3384b07b0f5848e8ae7bfa" kindref="member">is_square()</ref></computeroutput> is available if <computeroutput>Algebraic_structure_traits::Is_square</computeroutput> is not the <computeroutput><ref refid="structCGAL_1_1Null__functor" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Null_functor</ref></computeroutput>.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IsSquare" kindref="compound">AlgebraicStructureTraits_::IsSquare</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="283" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga997aad1528e7e744e54a807caa2be56e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::is_zero</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>is_zero</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga997aad1528e7e744e54a807caa2be56e" kindref="member">is_zero()</ref></computeroutput> determines if a value is equal to 0 or not. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> or of the <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>bool</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1IsZero" kindref="compound">RealEmbeddableTraits_::IsZero</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IsZero" kindref="compound">AlgebraicStructureTraits_::IsZero</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="305" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gabac14fc6cb4f556c19958b60f3305b9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::kth_root</definition>
        <argsstring>(int k, const NT &amp;x)</argsstring>
        <name>kth_root</name>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gabac14fc6cb4f556c19958b60f3305b9d" kindref="member">kth_root()</ref></computeroutput> returns the k-th root of a value. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the second argument type is a model of the <computeroutput><ref refid="classFieldWithKthRoot" kindref="compound">FieldWithKthRoot</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classFieldWithKthRoot" kindref="compound">FieldWithKthRoot</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1KthRoot" kindref="compound">AlgebraicStructureTraits_::KthRoot</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="323" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gac6bc445c0fc83ed997549ce869b7bae7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
          <param>
            <type>class NT2</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::mod</definition>
        <argsstring>(const NT1 &amp;x, const NT2 &amp;y)</argsstring>
        <name>mod</name>
        <param>
          <type>const NT1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const NT2 &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gac6bc445c0fc83ed997549ce869b7bae7" kindref="member">mod()</ref></computeroutput> computes the remainder of division with remainder. </para>        </briefdescription>
        <detaileddescription>
<para>In case the argument types <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> differ, the <computeroutput>result_type</computeroutput> is determined via <computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">Coercion_traits</ref></computeroutput>.</para><para>Thus, the <computeroutput>result_type</computeroutput> is well defined if <computeroutput>NT1</computeroutput> and <computeroutput>NT2</computeroutput> are a model of <computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput>.</para><para>The actual <computeroutput>mod</computeroutput> is performed with the semantic of that type.</para><para>The function is defined if <computeroutput>result_type</computeroutput> is a model of the <computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1DivMod" kindref="compound">AlgebraicStructureTraits_::DivMod</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga3445213fb9bc055253f5c346ce1693f6" kindref="member">CGAL::div_mod()</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gae246e686f794e878361621e6d4898b5a" kindref="member">CGAL::div()</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="353" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga975ad8b8b91cd67463c6c2be863d16a2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::root_of</definition>
        <argsstring>(int k, InputIterator begin, InputIterator end)</argsstring>
        <name>root_of</name>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>begin</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>returns the k-th real root of the univariate polynomial, which is defined by the iterator range, where begin refers to the constant term. </para>        </briefdescription>
        <detaileddescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga975ad8b8b91cd67463c6c2be863d16a2" kindref="member">root_of()</ref></computeroutput> computes a real root of a square-free univariate polynomial.</para><para>The function is defined if the value type, <computeroutput>NT</computeroutput>, of the iterator range is a model of the <computeroutput><ref refid="classFieldWithRootOf" kindref="compound">FieldWithRootOf</ref></computeroutput> concept.</para><para><simplesect kind="pre"><para>The polynomial is square-free.</para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classFieldWithRootOf" kindref="compound">FieldWithRootOf</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1RootOf" kindref="compound">AlgebraicStructureTraits_::RootOf</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="379" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gaf3d75d272a29458960987a8f248ec636" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>result_type</type>
        <definition>result_type CGAL::sign</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>sign</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gaf3d75d272a29458960987a8f248ec636" kindref="member">sign()</ref></computeroutput> returns the sign of its argument. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para>The <computeroutput>result_type</computeroutput> is convertible to <computeroutput>CGAL::Sign</computeroutput>.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1Sgn" kindref="compound">RealEmbeddableTraits_::Sgn</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="399" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga5339b0f11fdc9babbc5ca0b33f4a982c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::simplify</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>simplify</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga5339b0f11fdc9babbc5ca0b33f4a982c" kindref="member">simplify()</ref></computeroutput> may simplify a given object. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Simplify" kindref="compound">AlgebraicStructureTraits_::Simplify</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="417" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::sqrt</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member">sqrt()</ref></computeroutput> returns the square root of a value. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classFieldWithSqrt" kindref="compound">FieldWithSqrt</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classFieldWithSqrt" kindref="compound">FieldWithSqrt</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Sqrt" kindref="compound">AlgebraicStructureTraits_::Sqrt</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="435" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga07001b5ddc5c43096c811c91a306be9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::square</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>square</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member">square()</ref></computeroutput> returns the square of a number. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Square" kindref="compound">AlgebraicStructureTraits_::Square</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="453" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double CGAL::to_double</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>to_double</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member">to_double()</ref></computeroutput> returns a double approximation of a number. </para>        </briefdescription>
        <detaileddescription>
<para>Note that in general, the value returned is not guaranteed to be the same when called several times on the same number. For example, if <computeroutput>NT</computeroutput> is a lazy number type (such as an instance of <computeroutput><ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL::Lazy_exact_nt</ref></computeroutput>), the double approximation returned might be affected by an exact computation internally triggered (that might have improved the double approximation).</para><para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para>Remark: In order to control the quality of approximation one has to resort to methods that are specific to NT. There are no general guarantees whatsoever.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1ToDouble" kindref="compound">RealEmbeddableTraits_::ToDouble</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="478" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1gac30124cb713e69f02816e2b91c655fa6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; double, double &gt;</type>
        <definition>std::pair&lt;double,double&gt; CGAL::to_interval</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>to_interval</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The template function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1gac30124cb713e69f02816e2b91c655fa6" kindref="member">to_interval()</ref></computeroutput> computes for a given real embeddable number <formula id="0">$ x$</formula> a double interval containing <formula id="0">$ x$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para>This interval is represented by a <computeroutput>std::pair&lt;double,double&gt;</computeroutput>. The function is defined if the argument type is a model of the <computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1ToInterval" kindref="compound">RealEmbeddableTraits_::ToInterval</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="498" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgAlgebraicFoundations_1ga46969193a368780228dd0855cdc424b2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT</type>
          </param>
        </templateparamlist>
        <type>NT</type>
        <definition>NT CGAL::unit_part</definition>
        <argsstring>(const NT &amp;x)</argsstring>
        <name>unit_part</name>
        <param>
          <type>const NT &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga46969193a368780228dd0855cdc424b2" kindref="member">unit_part()</ref></computeroutput> computes the unit part of a given ring element. </para>        </briefdescription>
        <detaileddescription>
<para>The function is defined if the argument type is a model of the <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> concept.</para><para><simplesect kind="see"><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput> </para></simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1UnitPart" kindref="compound">AlgebraicStructureTraits_::UnitPart</ref></computeroutput> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/number_utils.h" line="517" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para> <image type="html" name="Algebraic_foundations2.png"></image>
   Michael Hemmer This package defines what algebra means for CGAL, in terms of concepts, classes and functions. The main features are: (i) explicit concepts for interoperability of types (ii) separation between algebraic types (not necessarily embeddable into the reals), and number types (embeddable into the reals). <linebreak/>
   <bold>Introduced in:</bold> CGAL 3.3<linebreak/>
 <bold>BibTeX:</bold> <ulink url="../Manual/how_to_cite_cgal.html#cgal:h-af-18b">cgal:h-af-18b</ulink><linebreak/>
 <bold>License:</bold> <ref refid="preliminaries_1licensesLGPL" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">LGPL</ref> <linebreak/>
 </para><para></para><para><heading level="2">Algebraic Structures</heading>
</para><para><heading level="3">Concepts</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound">IntegralDomainWithoutDivision</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classIntegralDomain" kindref="compound">IntegralDomain</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classUniqueFactorizationDomain" kindref="compound">UniqueFactorizationDomain</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classEuclideanRing" kindref="compound">EuclideanRing</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classField" kindref="compound">Field</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classFieldWithSqrt" kindref="compound">FieldWithSqrt</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classFieldWithKthRoot" kindref="compound">FieldWithKthRoot</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classFieldWithRootOf" kindref="compound">FieldWithRootOf</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits" kindref="compound">AlgebraicStructureTraits</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IsZero" kindref="compound">AlgebraicStructureTraits_::IsZero</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IsOne" kindref="compound">AlgebraicStructureTraits_::IsOne</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Square" kindref="compound">AlgebraicStructureTraits_::Square</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Simplify" kindref="compound">AlgebraicStructureTraits_::Simplify</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1UnitPart" kindref="compound">AlgebraicStructureTraits_::UnitPart</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IntegralDivision" kindref="compound">AlgebraicStructureTraits_::IntegralDivision</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Divides" kindref="compound">AlgebraicStructureTraits_::Divides</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Gcd" kindref="compound">AlgebraicStructureTraits_::Gcd</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1DivMod" kindref="compound">AlgebraicStructureTraits_::DivMod</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Div" kindref="compound">AlgebraicStructureTraits_::Div</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Mod" kindref="compound">AlgebraicStructureTraits_::Mod</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Inverse" kindref="compound">AlgebraicStructureTraits_::Inverse</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1Sqrt" kindref="compound">AlgebraicStructureTraits_::Sqrt</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1IsSquare" kindref="compound">AlgebraicStructureTraits_::IsSquare</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1KthRoot" kindref="compound">AlgebraicStructureTraits_::KthRoot</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classAlgebraicStructureTraits___1_1RootOf" kindref="compound">AlgebraicStructureTraits_::RootOf</ref></computeroutput></para></listitem></itemizedlist>
</para><para><heading level="3">Classes</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Algebraic__structure__traits" kindref="compound">CGAL::Algebraic_structure_traits</ref>&lt;T&gt;</computeroutput></para></listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1Integral__domain__without__division__tag" kindref="compound">CGAL::Integral_domain_without_division_tag</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1Integral__domain__tag" kindref="compound">CGAL::Integral_domain_tag</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1Field__tag" kindref="compound">CGAL::Field_tag</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1Field__with__sqrt__tag" kindref="compound">CGAL::Field_with_sqrt_tag</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1Unique__factorization__domain__tag" kindref="compound">CGAL::Unique_factorization_domain_tag</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1Euclidean__ring__tag" kindref="compound">CGAL::Euclidean_ring_tag</ref></computeroutput></para></listitem></itemizedlist>
</para><para><heading level="3">Global Functions</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga997aad1528e7e744e54a807caa2be56e" kindref="member">CGAL::is_zero()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gab57640546cf6cf7e56d37a652927a6f7" kindref="member">CGAL::is_one()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member">CGAL::square()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga5339b0f11fdc9babbc5ca0b33f4a982c" kindref="member">CGAL::simplify()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga46969193a368780228dd0855cdc424b2" kindref="member">CGAL::unit_part()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga59e55b9e023c50ddb15c89fae4b68387" kindref="member">CGAL::integral_division()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga9e2d81a5ae3384b07b0f5848e8ae7bfa" kindref="member">CGAL::is_square()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gade2b63594fb6827c33c0dcd73b4c7cfe" kindref="member">CGAL::gcd()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga3445213fb9bc055253f5c346ce1693f6" kindref="member">CGAL::div_mod()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gae246e686f794e878361621e6d4898b5a" kindref="member">CGAL::div()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gac6bc445c0fc83ed997549ce869b7bae7" kindref="member">CGAL::mod()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga3152b245b3c1c2fccd78e1dc27942598" kindref="member">CGAL::inverse()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member">CGAL::sqrt()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gabac14fc6cb4f556c19958b60f3305b9d" kindref="member">CGAL::kth_root()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga975ad8b8b91cd67463c6c2be863d16a2" kindref="member">CGAL::root_of()</ref></computeroutput></para></listitem></itemizedlist>
</para><para><heading level="2">Real Embeddable</heading>
</para><para><heading level="3">Concepts</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound">RealEmbeddable</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classRealEmbeddableTraits" kindref="compound">RealEmbeddableTraits</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1IsZero" kindref="compound">RealEmbeddableTraits_::IsZero</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1Abs" kindref="compound">RealEmbeddableTraits_::Abs</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1Sgn" kindref="compound">RealEmbeddableTraits_::Sgn</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1IsPositive" kindref="compound">RealEmbeddableTraits_::IsPositive</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1IsNegative" kindref="compound">RealEmbeddableTraits_::IsNegative</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1Compare" kindref="compound">RealEmbeddableTraits_::Compare</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1ToDouble" kindref="compound">RealEmbeddableTraits_::ToDouble</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classRealEmbeddableTraits___1_1ToInterval" kindref="compound">RealEmbeddableTraits_::ToInterval</ref></computeroutput></para></listitem></itemizedlist>
</para><para><heading level="3">Classes</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Real__embeddable__traits" kindref="compound">CGAL::Real_embeddable_traits</ref>&lt;T&gt;</computeroutput></para></listitem></itemizedlist>
</para><para><heading level="3">Global Functions</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga997aad1528e7e744e54a807caa2be56e" kindref="member">CGAL::is_zero()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga1d5106cf8be16adb4c4dc8b1ec3a5a92" kindref="member">CGAL::abs()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gaf3d75d272a29458960987a8f248ec636" kindref="member">CGAL::sign()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gabbfc28149479e41f56111ffe692c07d5" kindref="member">CGAL::is_positive()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gab752a78af2e16a42c5bd8c09fafeb585" kindref="member">CGAL::is_negative()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga0397c01d0ea2364b92e98141e221e9bb" kindref="member">CGAL::compare()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member">CGAL::to_double()</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="group__PkgAlgebraicFoundations_1gac30124cb713e69f02816e2b91c655fa6" kindref="member">CGAL::to_interval()</ref></computeroutput></para></listitem></itemizedlist>
</para><para><heading level="2">Real Number Types</heading>
</para><para><heading level="3">Concepts</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classRingNumberType" kindref="compound">RingNumberType</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classFieldNumberType" kindref="compound">FieldNumberType</ref></computeroutput></para></listitem></itemizedlist>
</para><para><heading level="2">Interoperability</heading>
</para><para><heading level="3">Concepts</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classExplicitInteroperable" kindref="compound">ExplicitInteroperable</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classImplicitInteroperable" kindref="compound">ImplicitInteroperable</ref></computeroutput></para></listitem></itemizedlist>
</para><para><heading level="3">Classes</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="structCGAL_1_1Coercion__traits" kindref="compound">CGAL::Coercion_traits</ref>&lt;A,B&gt;</computeroutput></para></listitem></itemizedlist>
</para><para><heading level="2">Fractions</heading>
</para><para><heading level="3">Concepts</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classFraction" kindref="compound">Fraction</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classFractionTraits" kindref="compound">FractionTraits</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classFractionTraits___1_1Decompose" kindref="compound">FractionTraits_::Decompose</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classFractionTraits___1_1Compose" kindref="compound">FractionTraits_::Compose</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classFractionTraits___1_1CommonFactor" kindref="compound">FractionTraits_::CommonFactor</ref></computeroutput></para></listitem></itemizedlist>
</para><para><heading level="3">Classes</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Fraction__traits" kindref="compound">CGAL::Fraction_traits</ref>&lt;T&gt;</computeroutput></para></listitem></itemizedlist>
</para><para><heading level="2">Miscellaneous</heading>
</para><para><heading level="3">Concepts</heading>
</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classFromIntConstructible" kindref="compound">FromIntConstructible</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classFromDoubleConstructible" kindref="compound">FromDoubleConstructible</ref></computeroutput> </para></listitem></itemizedlist>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
