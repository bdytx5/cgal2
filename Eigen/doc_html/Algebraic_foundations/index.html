<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Algebraic_foundations/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - Algebraic Foundations: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - Algebraic Foundations
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Algebraic_Foundations"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Michael Hemmer</dd></dl>
<h1><a class="anchor" id="Algebraic_foundationsIntroduction"></a>
Introduction</h1>
<p><span style="font-variant: small-caps;">CGAL</span> is targeting towards exact computation with non-linear objects, in particular objects defined on algebraic curves and surfaces. As a consequence types representing polynomials, algebraic extensions and finite fields play a more important role in related implementations. This package has been introduced to stay abreast of these changes. Since in particular polynomials must be supported by the introduced framework the package avoids the term <em>number type</em>. Instead the package distinguishes between the <em>algebraic structure</em> of a type and whether a type is embeddable on the real axis, or <em>real embeddable</em> for short. Moreover, the package introduces the notion of <em>interoperable</em> types which allows an explicit handling of mixed operations.</p>
<h1><a class="anchor" id="Algebraic_foundationsAlgebraic"></a>
Algebraic Structures</h1>
<p>The algebraic structure concepts introduced within this section are motivated by their well known counterparts in traditional algebra, but we also had to pay tribute to existing types and their restrictions. To keep the interface minimal, it was not desirable to cover all known algebraic structures, e.g., we did not introduce concepts for such basic structures as <em>groups</em> or exceptional structures as <em>skew fields</em>.</p>
<p><a class="anchor" id="fig__figConceptHierarchyOfAlgebraicStructures"></a></p><div class="image">
<img src="AlgebraicConceptHierarchy.png" alt="AlgebraicConceptHierarchy.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figConceptHierarchyOfAlgebraicStructures">Figure 1.1</a> Concept Hierarchy of Algebraic Structures  </div>  <br />

<p><a class="el" href="index.html#fig__figConceptHierarchyOfAlgebraicStructures">Figure 1.1</a> shows the refinement relationship of the algebraic structure concepts. <code><a class="el" href="classIntegralDomain.html" title="IntegralDomain refines IntegralDomainWithoutDivision by providing an integral division. ">IntegralDomain</a></code>, <code><a class="el" href="classUniqueFactorizationDomain.html" title="A model of UniqueFactorizationDomain is an IntegralDomain with the additional property that the ring ...">UniqueFactorizationDomain</a></code>, <code><a class="el" href="classEuclideanRing.html" title="A model of EuclideanRing represents an euclidean ring (or Euclidean domain). It is an UniqueFactoriza...">EuclideanRing</a></code> and <code><a class="el" href="classField.html" title="A model of Field is an IntegralDomain in which every non-zero element has a multiplicative inverse...">Field</a></code> correspond to the algebraic structures with the same name. <code><a class="el" href="classFieldWithSqrt.html" title="A model of FieldWithSqrt is a Field that has operations to take square roots. ">FieldWithSqrt</a></code>, <code><a class="el" href="classFieldWithKthRoot.html" title="A model of FieldWithKthRoot is a FieldWithSqrt that has operations to take k-th roots. ">FieldWithKthRoot</a></code> and <code><a class="el" href="classFieldWithRootOf.html" title="A model of FieldWithRootOf is a FieldWithKthRoot with the possibility to construct it as the root of ...">FieldWithRootOf</a></code> are fields that in addition are closed under the operations 'sqrt', 'k-th root' and 'real root of a polynomial', respectively. The concept <code><a class="el" href="classIntegralDomainWithoutDivision.html" title="This is the most basic concept for algebraic structures considered within CGAL. ">IntegralDomainWithoutDivision</a></code> also corresponds to integral domains in the algebraic sense, the distinction results from the fact that some implementations of integral domains lack the (algebraically always well defined) integral division. Note that <code><a class="el" href="classField.html" title="A model of Field is an IntegralDomain in which every non-zero element has a multiplicative inverse...">Field</a></code> refines <code><a class="el" href="classIntegralDomain.html" title="IntegralDomain refines IntegralDomainWithoutDivision by providing an integral division. ">IntegralDomain</a></code>. This is because most ring-theoretic notions like greatest common divisors become trivial for <code><a class="el" href="classField.html" title="A model of Field is an IntegralDomain in which every non-zero element has a multiplicative inverse...">Field</a></code>s. Hence we see <code><a class="el" href="classField.html" title="A model of Field is an IntegralDomain in which every non-zero element has a multiplicative inverse...">Field</a></code> as a refinement of <code><a class="el" href="classIntegralDomain.html" title="IntegralDomain refines IntegralDomainWithoutDivision by providing an integral division. ">IntegralDomain</a></code> and not as a refinement of one of the more advanced ring concepts. If an algorithm wants to rely on gcd or remainder computation, it is trying to do things it should not do with a <code><a class="el" href="classField.html" title="A model of Field is an IntegralDomain in which every non-zero element has a multiplicative inverse...">Field</a></code> in the first place.</p>
<p>The main properties of an algebraic structure are collected in the class <code><a class="el" href="classCGAL_1_1Algebraic__structure__traits.html" title="An instance of Algebraic_structure_traits is a model of AlgebraicStructureTraits, where T is the asso...">Algebraic_structure_traits</a></code>. In particular the (most refined) concept each concrete model <code>AS</code> fulfills is encoded in the tag <a class="el" href="classAlgebraicStructureTraits.html#aa5ceaea55d77df93eb00cb537af0e5f3"><code>Algebraic_structure_traits&lt;AS&gt;::Algebraic_category</code> </a> . An algebraic structure is at least <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classAssignable.html">Assignable</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classCopyConstructible.html">CopyConstructible</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classDefaultConstructible.html">DefaultConstructible</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classEqualityComparable.html">EqualityComparable</a></code>. Moreover, we require that it is constructible from <code>int</code>. For ease of use and since their semantic is sufficiently standard to presume their existence, the usual arithmetic and comparison operators are required to be realized via <span style="font-variant: small-caps;">C++</span> operator overloading. The division operator is reserved for division in fields. All other unary (e.g., sqrt) and binary functions (e.g., gcd, div) must be models of the well known <span style="font-variant: small-caps;">STL</span>-concepts <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classAdaptableUnaryFunction.html">AdaptableUnaryFunction</a></code> or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classAdaptableBinaryFunction.html">AdaptableBinaryFunction</a></code> concept and local to the traits class (e.g., <a class="el" href="classAlgebraicStructureTraits.html#a5fcefa3646991324dbf00f7905116c41"><code>Algebraic_structure_traits&lt;AS&gt;::Sqrt()(x)</code> </a>). This design allows us to profit from all parts in the <span style="font-variant: small-caps;">STL</span> and its programming style and avoids the name-lookup and two-pass template compilation problems experienced with the old design using overloaded functions. However, for ease of use and backward compatibility all functionality is also accessible through global functions defined within namespace <code><a class="el" href="namespaceCGAL.html">CGAL</a></code>, e.g., <a class="el" href="group__PkgAlgebraicFoundations.html#gab922269072ee9ee99ba8c541418b2e11"><code>CGAL::sqrt(x)</code> </a>. This is realized via function templates using the according functor of the traits class. For an overview see Section <a class="el" href="group__PkgAlgebraicFoundations.html">Algebraic Foundations Reference</a> in the reference manual.</p>
<h2><a class="anchor" id="Algebraic_foundationsTagsinAlgebraicStructure"></a>
Tags in Algebraic Structure Traits</h2>
<h2><a class="anchor" id="Algebraic_foundationsAlgebraicCategory"></a>
Algebraic Category</h2>
<p>For a type <code>AS</code>, <code><a class="el" href="classCGAL_1_1Algebraic__structure__traits.html" title="An instance of Algebraic_structure_traits is a model of AlgebraicStructureTraits, where T is the asso...">Algebraic_structure_traits</a>&lt;AS&gt;</code> provides several tags. The most important tag is the <code>Algebraic_category</code> tag, which indicates the most refined algebraic concept the type <code>AS</code> fulfills. The tag is one of; <code><a class="el" href="structCGAL_1_1Integral__domain__without__division__tag.html" title="Tag indicating that a type is a model of the IntegralDomainWithoutDivision concept. ">Integral_domain_without_division_tag</a></code>, <code><a class="el" href="structCGAL_1_1Integral__domain__tag.html" title="Tag indicating that a type is a model of the IntegralDomain concept. ">Integral_domain_tag</a></code>, <code><a class="el" href="structCGAL_1_1Field__tag.html" title="Tag indicating that a type is a model of the Field concept. ">Field_tag</a></code>, <code><a class="el" href="structCGAL_1_1Field__with__sqrt__tag.html" title="Tag indicating that a type is a model of the FieldWithSqrt concept. ">Field_with_sqrt_tag</a></code>, <code><a class="el" href="structCGAL_1_1Field__with__kth__root__tag.html" title="Tag indicating that a type is a model of the FieldWithKthRoot concept. ">Field_with_kth_root_tag</a></code>, <code><a class="el" href="structCGAL_1_1Field__with__root__of__tag.html" title="Tag indicating that a type is a model of the FieldWithRootOf concept. ">Field_with_root_of_tag</a></code>, <code><a class="el" href="structCGAL_1_1Unique__factorization__domain__tag.html" title="Tag indicating that a type is a model of the UniqueFactorizationDomain concept. ">Unique_factorization_domain_tag</a></code>, <code><a class="el" href="structCGAL_1_1Euclidean__ring__tag.html" title="Tag indicating that a type is a model of the EuclideanRing concept. ">Euclidean_ring_tag</a></code>, or even <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Null__tag.html">Null_tag</a></code> in case the type is not a model of an algebraic structure concept. The tags are derived from each other such that they reflect the hierarchy of the algebraic structure concept, e.g., <code><a class="el" href="structCGAL_1_1Field__with__sqrt__tag.html" title="Tag indicating that a type is a model of the FieldWithSqrt concept. ">Field_with_sqrt_tag</a></code> is derived from <code><a class="el" href="structCGAL_1_1Field__tag.html" title="Tag indicating that a type is a model of the Field concept. ">Field_tag</a></code>.</p>
<h2><a class="anchor" id="Algebraic_foundationsExactandNumericalSensitive"></a>
Exact and Numerical Sensitive</h2>
<p>Moreover, <code><a class="el" href="classCGAL_1_1Algebraic__structure__traits.html" title="An instance of Algebraic_structure_traits is a model of AlgebraicStructureTraits, where T is the asso...">Algebraic_structure_traits</a>&lt;AS&gt;</code> provides the tags <code>Is_exact</code> and <code>Is_numerical_sensitive</code>, which are both <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Boolean__tag.html">Boolean_tag</a></code>s.</p>
<p>An algebraic structure is considered <em>exact</em>, if all operations required by its concept are computed such that a comparison of two algebraic expressions is always correct.</p>
<p>An algebraic structure is considered as <em>numerically sensitive</em>, if the performance of the type is sensitive to the condition number of an algorithm. Note that there is really a difference among these two notions, e.g., the fundamental type <code>int</code> is not numerical sensitive but considered inexact due to overflow. Conversely, types as <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__real.html">leda_real</a></code> or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCORE_1_1Expr.html">CORE::Expr</a></code> are exact but sensitive to numerical issues due to the internal use of multi precision floating point arithmetic. We expect that <code>Is_numerical_sensitive</code> is used for dispatching of algorithms, while <code>Is_exact</code> is useful to enable assertions that can be check for exact types only.</p>
<p>Tags are very useful to dispatch between alternative implementations. The following example illustrates a dispatch for <code><a class="el" href="classField.html" title="A model of Field is an IntegralDomain in which every non-zero element has a multiplicative inverse...">Field</a></code>s using overloaded functions. The example only needs two overloads since the algebraic category tags reflect the algebraic structure hierarchy.</p>
<p><br />
<b>File</b> <a class="el" href="Algebraic_foundations_2algebraic_structure_dispatch_8cpp-example.html">Algebraic_foundations/algebraic_structure_dispatch.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/io.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Algebraic_structure_traits.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> NT &gt; NT <a class="code" href="group__PkgAlgebraicFoundations.html#ga46969193a368780228dd0855cdc424b2">unit_part</a>(<span class="keyword">const</span> NT&amp; x);</div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> NT &gt; </div><div class="line">NT unit_part_(<span class="keyword">const</span> NT&amp; x, <a class="code" href="structCGAL_1_1Field__tag.html">CGAL::Field_tag</a>);</div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> NT &gt; </div><div class="line">NT unit_part_(<span class="keyword">const</span> NT&amp; x, <a class="code" href="structCGAL_1_1Integral__domain__without__division__tag.html">CGAL::Integral_domain_without_division_tag</a>);</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> NT &gt;</div><div class="line">NT <a class="code" href="group__PkgAlgebraicFoundations.html#ga46969193a368780228dd0855cdc424b2">unit_part</a>(<span class="keyword">const</span> NT&amp; x){</div><div class="line">    <span class="comment">// the unit part of 0 is defined as 1. </span></div><div class="line">    <span class="keywordflow">if</span> (x == 0 ) <span class="keywordflow">return</span> NT(1);</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Algebraic__structure__traits.html">CGAL::Algebraic_structure_traits&lt;NT&gt;</a> AST;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> AST::Algebraic_category Algebraic_category; </div><div class="line">    <span class="keywordflow">return</span> unit_part_(x,Algebraic_category());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> NT &gt;</div><div class="line">NT unit_part_(<span class="keyword">const</span> NT&amp; x, <a class="code" href="structCGAL_1_1Integral__domain__without__division__tag.html">CGAL::Integral_domain_without_division_tag</a>){</div><div class="line">    <span class="comment">// For many other types the only units are just -1 and +1.</span></div><div class="line">    <span class="keywordflow">return</span> NT(<span class="keywordtype">int</span>(<a class="code" href="group__PkgAlgebraicFoundations.html#gaf3d75d272a29458960987a8f248ec636">CGAL::sign</a>(x)));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> NT &gt;</div><div class="line">NT unit_part_(<span class="keyword">const</span> NT&amp; x, <a class="code" href="structCGAL_1_1Field__tag.html">CGAL::Field_tag</a>){</div><div class="line">    <span class="comment">// For Fields every x != 0 is a unit.</span></div><div class="line">    <span class="comment">// Therefore, every x != 0 is its own unit part. </span></div><div class="line">    <span class="keywordflow">return</span> x;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    <span class="comment">// Function call for a model of EuclideanRing, i.e. int. </span></div><div class="line">    std::cout&lt;&lt; <span class="stringliteral">"int:    unit_part(-3  ): "</span> &lt;&lt; <a class="code" href="group__PkgAlgebraicFoundations.html#ga46969193a368780228dd0855cdc424b2">unit_part</a>(-3  ) &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// Function call for a model of FieldWithSqrt, i.e. double </span></div><div class="line">    std::cout&lt;&lt; <span class="stringliteral">"double: unit_part(-3.0): "</span> &lt;&lt; <a class="code" href="group__PkgAlgebraicFoundations.html#ga46969193a368780228dd0855cdc424b2">unit_part</a>(-3.0) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Note that this is just an example </span></div><div class="line"><span class="comment">// This implementation for unit part won't work for some types, e.g., </span></div><div class="line"><span class="comment">// types that are not RealEmbeddable or types representing structures that have </span></div><div class="line"><span class="comment">// more units than just -1 and +1. (e.g. MP_Float representing Z[1/2])</span></div><div class="line"><span class="comment">// From there Algebraic_structure_traits provides the functor Unit_part.  </span></div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Algebraic_foundationsRealE"></a>
Real Embeddable</h1>
<p><a class="anchor" id="secRealEmbeddable"></a> Most number types represent some subset of the real numbers. From those types we expect functionality to compute the sign, absolute value or double approximations. In particular we can expect an order on such a type that reflects the order along the real axis. All these properties are gathered in the concept <code><a class="el" href="classRealEmbeddable.html" title="A model of this concepts represents numbers that are embeddable on the real axis. The type obeys the ...">RealEmbeddable</a></code>. The concept is orthogonal to the algebraic structure concepts, i.e., it is possible that a type is a model of <code><a class="el" href="classRealEmbeddable.html" title="A model of this concepts represents numbers that are embeddable on the real axis. The type obeys the ...">RealEmbeddable</a></code> only, since the type may just represent values on the real axis but does not provide any arithmetic operations.</p>
<p>As for algebraic structures this concept is also traits class oriented. The main functionality related to <code><a class="el" href="classRealEmbeddable.html" title="A model of this concepts represents numbers that are embeddable on the real axis. The type obeys the ...">RealEmbeddable</a></code> is gathered in the class <code><a class="el" href="classCGAL_1_1Real__embeddable__traits.html" title="An instance of Real_embeddable_traits is a model of RealEmbeddableTraits, where T is the associated t...">Real_embeddable_traits</a></code>. In particular, it porivdes the boolean tag <code>Is_real_embeddable</code> indicating whether a type is a model of <code><a class="el" href="classRealEmbeddable.html" title="A model of this concepts represents numbers that are embeddable on the real axis. The type obeys the ...">RealEmbeddable</a></code>. The comparison operators are required to be realized via <span style="font-variant: small-caps;">C++</span> operator overloading. All unary functions (e.g. <em>sign</em>, <em>to_double</em>) and binary functions (e.g. <em>compare</em> ) are models of the <span style="font-variant: small-caps;">STL</span>-concepts <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classAdaptableUnaryFunction.html">AdaptableUnaryFunction</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classAdaptableBinaryFunction.html">AdaptableBinaryFunction</a></code> and are local to <code><a class="el" href="classCGAL_1_1Real__embeddable__traits.html" title="An instance of Real_embeddable_traits is a model of RealEmbeddableTraits, where T is the associated t...">Real_embeddable_traits</a></code>.</p>
<p>In case a type is a model of <code><a class="el" href="classIntegralDomainWithoutDivision.html" title="This is the most basic concept for algebraic structures considered within CGAL. ">IntegralDomainWithoutDivision</a></code> and <code><a class="el" href="classRealEmbeddable.html" title="A model of this concepts represents numbers that are embeddable on the real axis. The type obeys the ...">RealEmbeddable</a></code> the number represented by an object of this type is the same for arithmetic and comparison. It follows that the ring represented by this type is a superset of the integers and a subset of the real numbers and hence has characteristic zero.</p>
<p>In case the type is a model of <code><a class="el" href="classField.html" title="A model of Field is an IntegralDomain in which every non-zero element has a multiplicative inverse...">Field</a></code> and <code><a class="el" href="classRealEmbeddable.html" title="A model of this concepts represents numbers that are embeddable on the real axis. The type obeys the ...">RealEmbeddable</a></code> it is a superset of the rational numbers.</p>
<h1><a class="anchor" id="Algebraic_foundationsRealN"></a>
Real Number Types</h1>
<p>Every <span style="font-variant: small-caps;">CGAL</span> <code>Kernel</code> comes with two <em>real number types</em> (number types embeddable into the real numbers). One of them is a <code><a class="el" href="classFieldNumberType.html" title="The concept FieldNumberType combines the requirements of the concepts Field and RealEmbeddable. A model of FieldNumberType can be used as a template parameter for Cartesian kernels. ">FieldNumberType</a></code>, and the other a <code><a class="el" href="classRingNumberType.html" title="The concept RingNumberType combines the requirements of the concepts IntegralDomainWithoutDivision an...">RingNumberType</a></code>. The coordinates of the basic kernel objects (points, vectors, etc.) come from one of these types (the <code><a class="el" href="classFieldNumberType.html" title="The concept FieldNumberType combines the requirements of the concepts Field and RealEmbeddable. A model of FieldNumberType can be used as a template parameter for Cartesian kernels. ">FieldNumberType</a></code> in case of Cartesian kernels, and the <code><a class="el" href="classRingNumberType.html" title="The concept RingNumberType combines the requirements of the concepts IntegralDomainWithoutDivision an...">RingNumberType</a></code> for Homogeneous kernels).</p>
<p>The concept <code><a class="el" href="classFieldNumberType.html" title="The concept FieldNumberType combines the requirements of the concepts Field and RealEmbeddable. A model of FieldNumberType can be used as a template parameter for Cartesian kernels. ">FieldNumberType</a></code> combines the requirements of the concepts <code><a class="el" href="classField.html" title="A model of Field is an IntegralDomain in which every non-zero element has a multiplicative inverse...">Field</a></code> and <code><a class="el" href="classRealEmbeddable.html" title="A model of this concepts represents numbers that are embeddable on the real axis. The type obeys the ...">RealEmbeddable</a></code>, while <code><a class="el" href="classRingNumberType.html" title="The concept RingNumberType combines the requirements of the concepts IntegralDomainWithoutDivision an...">RingNumberType</a></code> combines <code><a class="el" href="classIntegralDomainWithoutDivision.html" title="This is the most basic concept for algebraic structures considered within CGAL. ">IntegralDomainWithoutDivision</a></code> and <code><a class="el" href="classRealEmbeddable.html" title="A model of this concepts represents numbers that are embeddable on the real axis. The type obeys the ...">RealEmbeddable</a></code>. Algebraically, the real number types do not form distinct structures and are therefore not listed in the concept hierarchy of <a class="el" href="index.html#fig__figConceptHierarchyOfAlgebraicStructures">Figure 1.1</a>.</p>
<h1><a class="anchor" id="Algebraic_foundationsInteroperability"></a>
Interoperability</h1>
<p>This section introduces two concepts for interoperability of types, namely <code><a class="el" href="classImplicitInteroperable.html" title="Two types A and B are a model of the concept ImplicitInteroperable, if there is a superior type...">ImplicitInteroperable</a></code> and <code><a class="el" href="classExplicitInteroperable.html" title="Two types A and B are a model of the ExplicitInteroperable concept, if it is possible to derive a sup...">ExplicitInteroperable</a></code>. While <code><a class="el" href="classExplicitInteroperable.html" title="Two types A and B are a model of the ExplicitInteroperable concept, if it is possible to derive a sup...">ExplicitInteroperable</a></code> is the base concept, we start with <code><a class="el" href="classImplicitInteroperable.html" title="Two types A and B are a model of the concept ImplicitInteroperable, if there is a superior type...">ImplicitInteroperable</a></code> since it is the more intuitive one.</p>
<p>In general mixed operations are provided by overloaded operators and functions or just via implicit constructor calls. This level of interoperability is reflected by the concept <code><a class="el" href="classImplicitInteroperable.html" title="Two types A and B are a model of the concept ImplicitInteroperable, if there is a superior type...">ImplicitInteroperable</a></code>. However, within template code the result type, or so called coercion type, of a mixed arithmetic operation may be unclear. Therefore, the package introduces <code><a class="el" href="structCGAL_1_1Coercion__traits.html" title="An instance of Coercion_traits reflects the type coercion of the types A and B, it is symmetric in th...">Coercion_traits</a></code> giving access to the coercion type via <a class="el" href="structCGAL_1_1Coercion__traits.html#adaa0ff8242fb38714a52ca411dcd5664"><code>Coercion_traits&lt;A,B&gt;::Type</code> </a> for two interoperable types <code>A</code> and <code>B</code>.</p>
<p>Some trivial example are <code>int</code> and <code>double</code> with coercion type double or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">Gmpz</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">Gmpq</a></code> with coercion type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">Gmpq</a></code>. However, the coercion type is not necessarily one of the input types, e.g. the coercion type of a polynomial with integer coefficients that is multiplied by a rational type is supposed to be a polynomial with rational coefficients.</p>
<p><code><a class="el" href="structCGAL_1_1Coercion__traits.html" title="An instance of Coercion_traits reflects the type coercion of the types A and B, it is symmetric in th...">Coercion_traits</a></code> is also required to provide a functor <a class="el" href="structCGAL_1_1Coercion__traits.html#a3241b3224d183bf3e0ce5d80b9100c4c"><code>Coercion_traits&lt;A,B&gt;::Cast()</code> </a>, that converts from an input type into the coercion type. This is in fact the core of the more basic concept <code><a class="el" href="classExplicitInteroperable.html" title="Two types A and B are a model of the ExplicitInteroperable concept, if it is possible to derive a sup...">ExplicitInteroperable</a></code>. <code><a class="el" href="classExplicitInteroperable.html" title="Two types A and B are a model of the ExplicitInteroperable concept, if it is possible to derive a sup...">ExplicitInteroperable</a></code> has been introduced to cover more complex cases for which it is hard or impossible to guarantee implicit interoperability. Note that this functor can be useful for <code><a class="el" href="classImplicitInteroperable.html" title="Two types A and B are a model of the concept ImplicitInteroperable, if there is a superior type...">ImplicitInteroperable</a></code> types as well, since it can be used to void redundant type conversions.</p>
<p>In case two types <code>A</code> and <code>B</code> are <code><a class="el" href="classExplicitInteroperable.html" title="Two types A and B are a model of the ExplicitInteroperable concept, if it is possible to derive a sup...">ExplicitInteroperable</a></code> with coercion type <code>C</code> they are valid argument types for all binary functors provided by <code><a class="el" href="classCGAL_1_1Algebraic__structure__traits.html" title="An instance of Algebraic_structure_traits is a model of AlgebraicStructureTraits, where T is the asso...">Algebraic_structure_traits</a></code> and <code><a class="el" href="classCGAL_1_1Real__embeddable__traits.html" title="An instance of Real_embeddable_traits is a model of RealEmbeddableTraits, where T is the associated t...">Real_embeddable_traits</a></code> of <code>C</code>. This is also true for the according global functions.</p>
<h2><a class="anchor" id="Algebraic_foundationsExamples"></a>
Examples</h2>
<p>The following example illustrates how two write code for <code><a class="el" href="classExplicitInteroperable.html" title="Two types A and B are a model of the ExplicitInteroperable concept, if it is possible to derive a sup...">ExplicitInteroperable</a></code> types.</p>
<p><br />
<b>File</b> <a class="el" href="Algebraic_foundations_2interoperable_8cpp-example.html">Algebraic_foundations/interoperable.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Coercion_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/io.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// this is an implementation for ExplicitInteroperable types</span></div><div class="line"><span class="comment">// the result type is determined via Coercion_traits&lt;A,B&gt;</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</div><div class="line"><span class="keyword">typename</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Coercion_traits&lt;A,B&gt;::Type</a></div><div class="line">binary_func(<span class="keyword">const</span> A&amp; a , <span class="keyword">const</span> B&amp; b){</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Coercion__traits.html">CGAL::Coercion_traits&lt;A,B&gt;</a> CT;</div><div class="line"></div><div class="line">    <span class="comment">// check for explicit interoperability</span></div><div class="line">    CGAL_static_assertion((CT::Are_explicit_interoperable::value));</div><div class="line"></div><div class="line">    <span class="comment">// CT::Cast is used to to convert both types into the coercion type</span></div><div class="line">    <span class="keyword">typename</span> CT::Cast cast;</div><div class="line">    <span class="comment">// all operations are performed in the coercion type</span></div><div class="line">    <span class="keywordflow">return</span> cast(a)*cast(b);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    <span class="comment">// Function call for the interoperable types</span></div><div class="line">    std::cout&lt;&lt; binary_func(<span class="keywordtype">double</span>(3), <span class="keywordtype">int</span>(5)) &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// Note that Coercion_traits is symmetric</span></div><div class="line">    std::cout&lt;&lt; binary_func(<span class="keywordtype">int</span>(3), <span class="keywordtype">double</span>(5)) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The following example illustrates a dispatch for <code><a class="el" href="classImplicitInteroperable.html" title="Two types A and B are a model of the concept ImplicitInteroperable, if there is a superior type...">ImplicitInteroperable</a></code> and <code><a class="el" href="classExplicitInteroperable.html" title="Two types A and B are a model of the ExplicitInteroperable concept, if it is possible to derive a sup...">ExplicitInteroperable</a></code> types. The binary function (that just multiplies its two arguments) is supposed to take two <code><a class="el" href="classExplicitInteroperable.html" title="Two types A and B are a model of the ExplicitInteroperable concept, if it is possible to derive a sup...">ExplicitInteroperable</a></code> arguments. For <code><a class="el" href="classImplicitInteroperable.html" title="Two types A and B are a model of the concept ImplicitInteroperable, if there is a superior type...">ImplicitInteroperable</a></code> types a variant that avoids the explicit cast is selected.</p>
<p><br />
<b>File</b> <a class="el" href="Algebraic_foundations_2implicit_interoperable_dispatch_8cpp-example.html">Algebraic_foundations/implicit_interoperable_dispatch.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Coercion_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Quotient_8h.html">CGAL/Quotient.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Sqrt__extension_8h.html">CGAL/Sqrt_extension.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/io.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// this is the implementation for ExplicitInteroperable types</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</div><div class="line"><span class="keyword">typename</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Coercion_traits&lt;A,B&gt;::Type</a></div><div class="line">binary_function_(<span class="keyword">const</span> A&amp; a , <span class="keyword">const</span> B&amp; b, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Boolean__tag.html">CGAL::Tag_false</a>){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Call for ExplicitInteroperable types: "</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Coercion__traits.html">CGAL::Coercion_traits&lt;A,B&gt;</a> CT;</div><div class="line">    <span class="keyword">typename</span> CT::Cast cast;</div><div class="line">    <span class="keywordflow">return</span> cast(a)*cast(b);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// this is the implementation for ImplicitInteroperable types</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</div><div class="line"><span class="keyword">typename</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Coercion_traits&lt;A,B&gt;::Type</a></div><div class="line">binary_function_(<span class="keyword">const</span> A&amp; a , <span class="keyword">const</span> B&amp; b, <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Boolean__tag.html">CGAL::Tag_true</a>){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Call for ImpicitInteroperable types: "</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> a*b;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// this function selects the correct implementation</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</div><div class="line"><span class="keyword">typename</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Coercion_traits&lt;A,B&gt;::Type</a></div><div class="line">binary_func(<span class="keyword">const</span> A&amp; a , <span class="keyword">const</span> B&amp; b){</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Coercion__traits.html">CGAL::Coercion_traits&lt;A,B&gt;</a> CT;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> CT::Are_implicit_interoperable Are_implicit_interoperable;</div><div class="line">    <span class="keywordflow">return</span> binary_function_(a,b,Are_implicit_interoperable());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    CGAL::set_pretty_mode(std::cout);</div><div class="line"></div><div class="line">    <span class="comment">// Function call for ImplicitInteroperable types</span></div><div class="line">    std::cout&lt;&lt; binary_func(<span class="keywordtype">double</span>(3), <span class="keywordtype">int</span>(5)) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Function call for ExplicitInteroperable types</span></div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">CGAL::Quotient&lt;int&gt;</a>           rational(1,3);    <span class="comment">// == 1/3</span></div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Sqrt__extension.html">CGAL::Sqrt_extension&lt;int,int&gt;</a> extension(1,2,3); <span class="comment">// == 1+2*sqrt(3)</span></div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Sqrt__extension.html">CGAL::Sqrt_extension&lt;CGAL::Quotient&lt;int&gt;</a>,<span class="keywordtype">int</span>&gt; result = binary_func(rational, extension);</div><div class="line">    std::cout&lt;&lt; result &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Algebraic_foundationsFractions"></a>
Fractions</h1>
<p>Beyond the need for performing algebraic operations on objects as a whole, there are also number types which one would like to decompose into numerator and denominator. This does not only hold for rational numbers as <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">Gmpq</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classmpq__class.html">mpq_class</a></code> or <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__rational.html">leda_rational</a></code>, but also for compound objects as <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Sqrt__extension.html">Sqrt_extension</a></code> or <code>Polynomial</code> which may decompose into a (scalar) denominator and a compound numerator with a simpler coefficient type (e.g. integer instead of rational). Often operations can be performed faster on these denominator-free multiples. In case a type is a <code><a class="el" href="classFraction.html" title="A type is considered as a Fraction, if there is a reasonable way to decompose it into a numerator and...">Fraction</a></code> the relevant functionality as well as the numerator and denominator type are provided by <code><a class="el" href="classCGAL_1_1Fraction__traits.html" title="An instance of Fraction_traits is a model of FractionTraits, where T is the associated type...">Fraction_traits</a></code>. In particular <code><a class="el" href="classCGAL_1_1Fraction__traits.html" title="An instance of Fraction_traits is a model of FractionTraits, where T is the associated type...">Fraction_traits</a></code> provides a tag <a class="el" href="classFractionTraits.html#adccf11bdb413fee30cb4f229c9450ee7"><code>Is_fraction</code> </a> that can be used for dispatching.</p>
<p>A related class is <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Rational__traits.html">Rational_traits</a></code> which has been kept for backward compatibility reasons. However, we recommend to use <code><a class="el" href="classCGAL_1_1Fraction__traits.html" title="An instance of Fraction_traits is a model of FractionTraits, where T is the associated type...">Fraction_traits</a></code> since it is more general and offers dispatching functionality.</p>
<h2><a class="anchor" id="Algebraic_foundationsExamples_1"></a>
Examples</h2>
<p>The following example show a simple use of <code><a class="el" href="classCGAL_1_1Fraction__traits.html" title="An instance of Fraction_traits is a model of FractionTraits, where T is the associated type...">Fraction_traits</a></code>: <br />
<b>File</b> <a class="el" href="Algebraic_foundations_2fraction_traits_8cpp-example.html">Algebraic_foundations/fraction_traits.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Fraction_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_GMP</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpz_8h.html">CGAL/Gmpz.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpq_8h.html">CGAL/Gmpq.h</a>&gt;</span></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Fraction__traits.html">CGAL::Fraction_traits&lt;CGAL::Gmpq&gt;</a> FT;</div><div class="line">    <span class="keyword">typedef</span> FT::Numerator_type Numerator_type;</div><div class="line">    <span class="keyword">typedef</span> FT::Denominator_type Denominator_type;</div><div class="line"></div><div class="line">    CGAL_static_assertion((boost::is_same&lt;Numerator_type,CGAL::Gmpz&gt;::value));</div><div class="line">    CGAL_static_assertion((boost::is_same&lt;Denominator_type,CGAL::Gmpz&gt;::value));</div><div class="line"></div><div class="line">    Numerator_type numerator;</div><div class="line">    Denominator_type denominator;</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">CGAL::Gmpq</a> fraction(4,5);</div><div class="line">    FT::Decompose()(fraction,numerator,denominator);</div><div class="line"></div><div class="line">    CGAL::set_pretty_mode(std::cout);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"decompose fraction: "</span>&lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"fraction   : "</span> &lt;&lt; fraction &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"numerator  : "</span> &lt;&lt; numerator&lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"denominator: "</span> &lt;&lt; denominator &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"re-compose fraction: "</span>&lt;&lt; std::endl;</div><div class="line">    fraction = FT::Compose()(numerator,denominator);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"fraction   : "</span> &lt;&lt; fraction &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="keywordtype">int</span> main(){ std::cout &lt;&lt; <span class="stringliteral">"This examples needs GMP"</span> &lt;&lt; std::endl; }</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>The following example illustrates the integralization of a vector, i.e., the coefficient vector of a polynomial. Note that for minimizing coefficient growth <a class="el" href="classFractionTraits.html#abc51eea7ae3ec76c3e51c118a2fc32f9"><code>Fraction_traits&lt;Type&gt;::Common_factor</code> </a> is used to compute the <em>least</em> common multiple of the denominators.</p>
<p><br />
<b>File</b> <a class="el" href="Algebraic_foundations_2integralize_8cpp-example.html">Algebraic_foundations/integralize.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Fraction_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/io.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Fraction&gt;</div><div class="line">std::vector&lt;typename CGAL::Fraction_traits&lt;Fraction&gt;::Numerator_type &gt;</div><div class="line">integralize(</div><div class="line">        <span class="keyword">const</span> std::vector&lt;Fraction&gt;&amp; vec,</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="classCGAL_1_1Fraction__traits.html">CGAL::Fraction_traits&lt;Fraction&gt;::Denominator_type</a>&amp; d</div><div class="line">) {</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Fraction__traits.html">CGAL::Fraction_traits&lt;Fraction&gt;</a> FT;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> FT::Numerator_type Numerator_type;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> FT::Denominator_type Denominator_type;</div><div class="line">    <span class="keyword">typename</span> FT::Decompose decompose;</div><div class="line"></div><div class="line">    std::vector&lt;Numerator_type&gt;   num(vec.size());</div><div class="line">    std::vector&lt;Denominator_type&gt; den(vec.size());</div><div class="line"></div><div class="line">    <span class="comment">// decompose each coefficient into integral part and denominator</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; vec.size(); i++) {</div><div class="line">        decompose(vec[i], num[i], den[i]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// compute 'least' common multiple of all denominator</span></div><div class="line">    <span class="comment">// We would like to use gcd, so let's think of Common_factor as gcd.</span></div><div class="line">    <span class="keyword">typename</span> FT::Common_factor        <a class="code" href="group__PkgAlgebraicFoundations.html#gade2b63594fb6827c33c0dcd73b4c7cfe">gcd</a>;</div><div class="line">    d = 1;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; vec.size(); i++) {</div><div class="line">        d *= <a class="code" href="group__PkgAlgebraicFoundations.html#ga59e55b9e023c50ddb15c89fae4b68387">CGAL::integral_division</a>(den[i], <a class="code" href="group__PkgAlgebraicFoundations.html#gade2b63594fb6827c33c0dcd73b4c7cfe">gcd</a>(d, den[i]));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// expand each (numerator, denominator) pair to common denominator</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; vec.size(); i++) {</div><div class="line">        <span class="comment">// For simplicity ImplicitInteroperability is expected in this example</span></div><div class="line">        num[i] *= <a class="code" href="group__PkgAlgebraicFoundations.html#ga59e55b9e023c50ddb15c89fae4b68387">CGAL::integral_division</a>(d, den[i]);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> num;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_GMP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpz_8h.html">CGAL/Gmpz.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Gmpq_8h.html">CGAL/Gmpq.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    std::vector&lt;CGAL::Gmpq&gt; vec(3);</div><div class="line">    vec[0]=<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">CGAL::Gmpq</a>(1,4);</div><div class="line">    vec[1]=<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">CGAL::Gmpq</a>(1,6);</div><div class="line">    vec[2]=<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">CGAL::Gmpq</a>(1,10);</div><div class="line">    std::cout&lt;&lt; <span class="stringliteral">"compute an integralized vector"</span> &lt;&lt; std::endl;</div><div class="line">    std::cout&lt;&lt;<span class="stringliteral">"input vector:  ["</span></div><div class="line">             &lt;&lt; vec[0] &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; vec[1] &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; vec[2] &lt;&lt; <span class="stringliteral">"]"</span> &lt;&lt; std::endl;</div><div class="line">    <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">CGAL::Gmpz</a> d;</div><div class="line">    std::vector&lt;CGAL::Gmpz&gt; integral_vec = integralize(vec,d);</div><div class="line">    std::cout&lt;&lt;<span class="stringliteral">"output vector: ["</span></div><div class="line">             &lt;&lt; integral_vec[0] &lt;&lt; <span class="stringliteral">","</span></div><div class="line">             &lt;&lt; integral_vec[1] &lt;&lt; <span class="stringliteral">","</span></div><div class="line">             &lt;&lt; integral_vec[2] &lt;&lt; <span class="stringliteral">"]"</span> &lt;&lt; std::endl;</div><div class="line">    std::cout&lt;&lt;<span class="stringliteral">"denominator  : "</span>&lt;&lt; d &lt;&lt;std::endl;</div><div class="line">}</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="keywordtype">int</span> main(){ std::cout &lt;&lt; <span class="stringliteral">"This examples needs GMP"</span> &lt;&lt; std::endl; }</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h1><a class="anchor" id="Algebraic_foundationsDesign"></a>
Design and Implementation History</h1>
<p>The package is part of <span style="font-variant: small-caps;">CGAL</span> since release 3.3. Of course the package is based on the former Number type support of <a class="el" href="namespaceCGAL.html">CGAL</a>. This goes back to Stefan Schirra and Andreas Fabri. But on the other hand the package is to a large extend influenced by the experience with the number type support in <span class="textsc">Exacus</span> <a class="el" href="citelist.html#CITEREF_beh-eeeafcs-05">[1]</a>, which in the main goes back to Lutz Kettner, Susan Hert, Arno Eigenwillig and Michael Hemmer. However, the package abstracts from the pure support for number types that are embedded on the real axis which allows the support of polynomials, finite fields, and algebraic extensions as well. See also related subsequent chapters. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:58 for CGAL 4.13 - Algebraic Foundations by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
