<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Minkowski_Sums"/> <anchor id="index_1chapterMinkowskisum2"/>  <simplesect kind="authors"><para>Ron Wein, Alon Baram, Efi Fogel, Eyal Flato, Michael Hemmer, and Sebastian Morr</para></simplesect>
</para><sect1 id="index_1mink_secintro">
<title>Introduction</title>
<para>Given two sets <formula id="19">$ A,B \in \mathbb{R}^d$</formula>, their <emphasis>Minkowski sum</emphasis>, denoted by <formula id="20">$ A \oplus B$</formula>, is their point-wise sum, namely the set <formula id="21">$ \left\{ a + b ~|~ a \in A, b \in B \right\}$</formula>. Minkowski sums are used in many applications, such as motion planning and computer-aided design and manufacturing. This package contains functions that compute the planar Minkowski sums of two polygons. (Here, <formula id="22">$ A$</formula> and <formula id="23">$ B$</formula> are two closed polygons in <formula id="24">$ \mathbb{R}^2$</formula>, which may have holes; see Chapter <ref refid="index_1Chapter_2D_Regularized_Boolean_Set-Operations" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">2D Regularized Boolean Set-Operations</ref> for the precise definition of valid polygons), and the planar Minkowski sum of a simple polygon and a disc<mdash/>an operation also referred to as <emphasis>offsetting</emphasis> or <emphasis>dilating</emphasis> a polygon.The family of valid types of summands is slightly broader for certain operations, e.g., a degenerate polygon consisting of line segments is a valid operand for the approximate-offsetting operation. This package, like the <ref refid="index_1Chapter_2D_Regularized_Boolean_Set-Operations" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">2D Regularized Boolean Set-Operations</ref> package, is implemented on top of the arrangement infrastructure provided by the <ref refid="index_1chapterArrangement_on_surface_2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">2D Arrangements</ref> package. The two packages are integrated well to allow mixed operations. For example, it is possible to apply Boolean set operations on objects that are the result of Minkowski sum computations.The operands of the Minkowski sum operations supported by this package must be (linear) polygons, as opposed to the operands of the Boolean set operations supported by the <ref refid="index_1Chapter_2D_Regularized_Boolean_Set-Operations" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">2D Regularized Boolean Set-Operations</ref> package. The latter belong to the broader family of general polygons.</para></sect1>
<sect1 id="index_1mink_secsum_poly">
<title>Computing the Minkowski Sum of Two Polygons</title>
<para><anchor id="index_1fig__mink_figconvex"/><image type="html" name="ms_convex.png"></image>
 <image type="latex" name="ms_convex.png" width="15cm"></image>
  <ref refid="index_1fig__mink_figconvex" kindref="member">fig__mink_figconvex</ref>  <linebreak/>
</para><para>Computing the Minkowski sum of two convex polygons <formula id="0">$ P$</formula> and <formula id="25">$ Q$</formula> with <formula id="26">$ m$</formula> and <formula id="14">$ n$</formula> vertices, respectively, is rather easy. Observe that <formula id="8">$ P \oplus Q$</formula> is a convex polygon bounded by copies of the <formula id="27">$ m + n$</formula> edges ordered according to the angle they form with the <formula id="28">$ x$</formula>-axis. As the two input polygons are convex, their edges are already sorted by the angle they form with the <formula id="28">$ x$</formula>-axis; see the figure above. The Minkowski sum can therefore be computed using an operation similar to the merge step of the merge-sort algorithmSee, for example, <ulink url="http://en.wikipedia.org/wiki/Merge_sort">http://en.wikipedia.org/wiki/Merge_sort</ulink>. in <formula id="29">$ O(m + n)$</formula> time, starting from the two bottommost vertices in <formula id="0">$ P$</formula> and in <formula id="25">$ Q$</formula> and merging the ordered list of edges.</para><para><anchor id="index_1fig__mink_figonecyc"/><center> <table rows="1" cols="3"><row>
<entry thead="no"><para><image type="html" name="ms_convex_polygon.png"></image>
 <image type="latex" name="ms_convex_polygon.png" width="5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="ms_concave_polygon.png"></image>
 <image type="latex" name="ms_concave_polygon.png" width="5cm"></image>
  </para></entry><entry thead="no"><para><image type="html" name="ms_convolution.png"></image>
 <image type="latex" name="ms_convolution.png" width="5cm"></image>
   </para></entry></row>
</table>
</center>  <ref refid="index_1fig__mink_figonecyc" kindref="member">fig__mink_figonecyc</ref> The convolution of a convex polygon and a non-convex polygon. The convolution consists of a single self-intersecting cycle, drawn as a sequence of directed line segments. Each face of the arrangement induced by the segments forming the cycle contains its winding number. The Minkowski sum of the two polygons is shaded. Dotted edges are not part of the reduced convolution.  <linebreak/>
</para><para>If the polygons are not convex, you can utilize either the <emphasis>Decomposition</emphasis> or the <emphasis>Convolution</emphasis> approaches described below. Applications of some of the operations in this package are restricted to polygons that do not contain holes. (Resulting sums may contain holes though.)</para><para><variablelist>
<varlistentry><term><bold>Decomposition:</bold></term></varlistentry>
<listitem><para>We decompose <formula id="0">$ P$</formula> and <formula id="25">$ Q$</formula> into convex sub-polygons. Namely, we obtain two sets of convex polygons <formula id="6">$ P_1, \ldots, P_k$</formula> and <formula id="30">$ Q_1, \ldots, Q_\ell$</formula>, such that <formula id="31">$ \bigcup_{i = 1}^{k}{P_i} = P$</formula> and <formula id="32">$ \bigcup_{i = j}^{\ell}{Q_j} = Q$</formula>. We then calculate the pairwise sums <formula id="33">$ S_{ij} = P_i \oplus Q_j$</formula> using the simple procedure described above, and finally compute the union <formula id="34">$ P \oplus Q = \bigcup_{ij}{S_{ij}}$</formula>; see <ref refid="group__boolean__join_1ref_bso_union" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">Union Functions</ref>.</para><para>This approach relies on a successful decomposition of the input polygons into convex pieces, and its performance depends on the quality and performance of the decomposition. Some of the supplied decomposition methods do not handle polygons that contain holes.</para><para></para></listitem>
<varlistentry><term><bold>Convolution:</bold></term></varlistentry>
<listitem><para>Let <formula id="35">$ P = \left( p_0, \ldots, p_{m-1} \right)$</formula> and <formula id="36">$ Q = \left(q_0, \ldots, q_{n-1} \right)$</formula> denote the vertices of the input polygons. We assume that both <formula id="0">$ P$</formula> and <formula id="25">$ Q$</formula> have positive orientations (i.e., their boundaries wind in a counterclockwise order around their interiors). The <emphasis>convolution</emphasis> of these two polygons <ref refid="citelist_1CITEREF_grs-kfcg-83" kindref="member">[7]</ref>, denoted <formula id="37">$ P * Q$</formula>, is a collection of line segments of the form <formula id="38">$ [p_i + q_j, p_{i+1} + q_j]$</formula>,Throughout this chapter, we increment or decrement an index of a vertex modulo the size of the polygon. where the vector <formula id="39">$ {\mathbf{p_i p_{i+1}}}$</formula> lies between <formula id="40">$ {\mathbf{q_{j-1} q_j}}$</formula> and <formula id="41">$ {\mathbf{q_j q_{j+1}}}$</formula>,We say that a vector <formula id="42">$ {\mathbf v}$</formula> lies between two vectors <formula id="43">$ {\mathbf u}$</formula> and <formula id="44">$ {\mathbf w}$</formula> if we reach <formula id="42">$ {\mathbf v}$</formula> strictly before reaching <formula id="44">$ {\mathbf w}$</formula> if we move all three vectors to the origin and rotate <formula id="43">$ {\mathbf u}$</formula> counterclockwise. Note that this also covers the case where <formula id="43">$ {\mathbf u}$</formula> has the same direction as <formula id="42">$ {\mathbf v}$</formula>. and, symmetrically, of segments of the form <formula id="45">$ [p_i + q_j, p_i + q_{j+1}]$</formula>, where the vector <formula id="41">$ {\mathbf{q_j q_{j+1}}}$</formula> lies between <formula id="46">$ {\mathbf{p_{i-1} p_i}}$</formula> and <formula id="39">$ {\mathbf{p_i p_{i+1}}}$</formula>.</para><para>The segments of the convolution form a number of closed (not necessarily simple) polygonal curves called <emphasis>convolution cycles</emphasis>. The Minkowski sum <formula id="8">$ P \oplus Q$</formula> is the set of points having a non-zero winding number with respect to the cycles of <formula id="37">$ P * Q$</formula>.Informally speaking, the winding number of a point <formula id="47">$ p \in\mathbb{R}^2$</formula> with respect to some planar curve <formula id="48">$ \gamma$</formula> is an integer number counting how many times does <formula id="48">$ \gamma$</formula> wind in a counterclockwise direction around <formula id="49">$ p$</formula>. See <ref refid="index_1fig__mink_figonecyc" kindref="member">fig__mink_figonecyc</ref> for an illustration.</para><para>We construct the arrangement induced by the convolution cycles of <formula id="50">$P $</formula> and <formula id="51">$Q $</formula>, then compute the winding numbers of the cells of the arrangement. Finally, we extract the Minkowski sum from the arrangement. This variant is referred to as the full-convolution method.</para><para>A segment <formula id="52">$[p_i + q_j, p_{i+1} + q_j] $</formula> (resp. <formula id="53">$[p_i + q_j, p_i + q_{j+1}] $</formula>) cannot possibly contribute to the boundary of the Minkowski sum if <formula id="54">$q_j $</formula> (resp. <formula id="55">$p_i $</formula>) is a reflex vertex (see dotted edges in <ref refid="index_1fig__mink_figonecyc" kindref="member">fig__mink_figonecyc</ref>). The remaining subset of convolution segments is called the <emphasis>reduced convolution</emphasis> <ref refid="citelist_1CITEREF_cgal:bl-frmsurc-11" kindref="member">[3]</ref>. This subset is still a superset of the Minkowski sum boundary, but the winding number property does not apply any longer as there are no closed cycles anymore. We apply two different filters, which identify holes in the Minkowski sum: <orderedlist>
<listitem>
<para>A loop that is on the Minkowski sum boundary has to be orientable; that is, all normal directions of its edges have to point either inward or outward. </para></listitem>
<listitem>
<para>For any point <formula id="56">$x$</formula> inside of a hole of the Minkowski sum, the following condition holds: <formula id="57">$(-P + x) \cap Q = \emptyset$</formula>. If, on the other hand, the inversed version of <formula id="58">$P$</formula>, translated by <formula id="56">$x$</formula>, overlaps <formula id="59">$Q$</formula>, the loop is a <emphasis>false</emphasis> hole and is in the interior of the Minkowski sum. </para></listitem>
</orderedlist>
</para><para>After applying these two filters, only those segments which constitute the Minkowski sum boundary remain. This variant is referred to as the reduced-convolution method. </para></listitem>
</variablelist>
</para><para>The number of segments in the convolution of two polygons is usually smaller than the number of segments that constitute the boundaries of the sub-sums <formula id="60">$ S_{ij}$</formula> when using the decomposition approach. As both approaches construct the arrangement of these segments and extract the sum from this arrangement, computing Minkowski sum using the convolution approach usually generates a smaller intermediate arrangement; hence it is faster and consumes less space. In most cases, the reduced convolution method is faster than the full convolution method, as the respective induced arrangement is usually much smaller. However, in degenerate cases with many holes in the Minkowski sum, the full convolution method can be preferable, as it avoids costly intersection tests.</para><sect2 id="index_1mink_ssec_hole_filter">
<title>Filtering Out Holes</title>
<para>If a hole in one polygon is relatively small compared to the other polygon, the hole is irrelevant for the computation of <formula id="61">$P\oplus Q $</formula> <ref refid="citelist_1CITEREF_bfhhm-epsph-15" kindref="member">[2]</ref>; It implies that the hole can be removed (that is, filled up) before the main computation starts. Theoretically, we can always fill up all the holes of at least one polygon, transforming it into a simple polygon, and still obtain exactly the same Minkowski sum. Practically, we remove all holes in one polygon whose bounding boxes are, in <formula id="62">$x $</formula>- or <formula id="63">$y $</formula>-direction, smaller than, or as large as, the bounding box of the other polygon. Obliterating holes in the input summands speeds up the computation of Minkowski sums, regardless of the approach used to compute the Minkowski sum.</para></sect2>
<sect2 id="index_1mink_ssec_conv">
<title>Computing Minkowski Sum using Convolutions</title>
<para>The function template <ref refid="group__PkgMinkowskiSum2_1ga5ce6e837bdb4ea8973c8120c38301d7b" kindref="member"><computeroutput>minkowski_sum_2(P, Q)</computeroutput></ref> accepts two polygons <formula id="0">$ P$</formula> and <formula id="25">$ Q$</formula> and computes their Minkowski sum <formula id="64">$ S = P \oplus Q$</formula> using the convolution approach. The call <ref refid="group__PkgMinkowskiSum2_1ga5ce6e837bdb4ea8973c8120c38301d7b" kindref="member"><computeroutput>minkowski_sum_2(P, Q)</computeroutput></ref> defaults to the call <ref refid="group__PkgMinkowskiSum2_1gad3220ac962eacdaad0c3ad538e7d97af" kindref="member"><computeroutput>minkowski_sum_by_reduced_convolution_2(P, Q)</computeroutput></ref>, which applies the reduced convolution aforementioned method. Explicitly call <ref refid="group__PkgMinkowskiSum2_1ga09275e94b4a9016406f552b612c6335c" kindref="member"><computeroutput>minkowski_sum_by_full_convolution_2(P, Q)</computeroutput></ref> to apply the full convolution method. The types of the operands accepted by the function <ref refid="group__PkgMinkowskiSum2_1ga09275e94b4a9016406f552b612c6335c" kindref="member"><computeroutput>minkowski_sum_by_full_convolution_2(P, Q)</computeroutput></ref> are instances of the <ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag"><computeroutput>Polygon_2</computeroutput></ref> class template. The types of operands accepted by the function <ref refid="group__PkgMinkowskiSum2_1gad3220ac962eacdaad0c3ad538e7d97af" kindref="member"><computeroutput>minkowski_sum_by_reduced_convolution_2(P, Q)</computeroutput></ref> (and by the function <ref refid="group__PkgMinkowskiSum2_1ga5ce6e837bdb4ea8973c8120c38301d7b" kindref="member"><computeroutput>minkowski_sum_2(P, Q)</computeroutput></ref>) are instances of either the <ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag"><computeroutput>Polygon_2</computeroutput></ref> or <ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag"><computeroutput>Polygon_with_holes_2</computeroutput></ref> class templates. Even when the input polygons are restricted to be simple polygons, they still may not be convex; thus, their Minkowski sum may not be simply connected and may contain polygonal holes; see for example <ref refid="index_1fig__mink_figonecyc" kindref="member">fig__mink_figonecyc</ref>. The type of the returned object <formula id="65">$ S $</formula> is therefore an instance of the <ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag"><computeroutput>Polygon_with_holes_2</computeroutput></ref> class template in all cases. Recall that the outer boundary of <formula id="66">$S $</formula> is a polygon that can be accessed using <computeroutput>S.outer_boundary()</computeroutput>, and its polygonal holes are given by the range [<computeroutput>S.holes_begin()</computeroutput>, <computeroutput>S.holes_end()</computeroutput>) (where <formula id="65">$ S $</formula> contains <computeroutput>S.number_of_holes()</computeroutput> holes in its interior).</para><para><anchor id="index_1fig__mink_figsum_tri_sqr"/><image type="html" name="ms_sum_triangle_square.png"></image>
 <image type="latex" name="ms_sum_triangle_square.png" width="15cm"></image>
  <ref refid="index_1fig__mink_figsum_tri_sqr" kindref="member">fig__mink_figsum_tri_sqr</ref> The Minkowski sum of a triangle and a square, as computed by the example program <ref refid="Minkowski_sum_2_2sum_triangle_square_8cpp-example" kindref="compound">Minkowski_sum_2/sum_triangle_square.cpp</ref>.  <linebreak/>
</para><para>The example program below constructs the Minkowski sum of a triangle and a square, as depicted in <ref refid="index_1fig__mink_figsum_tri_sqr" kindref="member">fig__mink_figsum_tri_sqr</ref>. The result in this case is a convex hexagon. This program, like other example programs in this package, includes the header file <computeroutput>bops_linear.h</computeroutput>, which defines the polygon types.</para><para><linebreak/>
<bold>File</bold> <ref refid="Minkowski_sum_2_2sum_triangle_square_8cpp-example" kindref="compound">Minkowski_sum_2/sum_triangle_square.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Computing<sp/>the<sp/>Minkowski<sp/>sum<sp/>of<sp/>a<sp/>triangle<sp/>and<sp/>a<sp/>square.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/minkowski_sum_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;bops_linear.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>triangle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/><sp/><sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back(Point_2(-1,<sp/>-1));<sp/><sp/>P.push_back(Point_2(1,<sp/>-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back(Point_2(0,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;P<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>P<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>square.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/><sp/><sp/>Q;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back(Point_2(3,<sp/>-1));<sp/><sp/>Q.push_back(Point_2(5,<sp/>-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back(Point_2(5,<sp/>1));<sp/><sp/><sp/>Q.push_back(Point_2(3,<sp/><sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Q<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>Q<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>Minkowski<sp/>sum.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_with_holes_2<sp/><sp/>sum<sp/>=<sp/><ref refid="group__PkgMinkowskiSum2_1ga5ce6e837bdb4ea8973c8120c38301d7b" kindref="member">CGAL::minkowski_sum_2</ref>(P,<sp/>Q);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(sum.number_of_holes()<sp/>==<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;P<sp/>(+)<sp/>Q<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>sum.outer_boundary()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><anchor id="index_1fig__mink_figsum_holes"/><image type="html" name="ms_tight.png"></image>
 <image type="latex" name="ms_tight.png" width="15cm"></image>
  <ref refid="index_1fig__mink_figsum_holes" kindref="member">fig__mink_figsum_holes</ref> The Minkowski sum of two non-convex polygons <formula id="0">$ P$</formula> and <formula id="25">$ Q$</formula>, as computed by the example programs <ref refid="Minkowski_sum_2_2sum_with_holes_8cpp-example" kindref="compound">Minkowski_sum_2/sum_with_holes.cpp</ref> and <ref refid="Minkowski_sum_2_2sum_by_decomposition_8cpp-example" kindref="compound">Minkowski_sum_2/sum_by_decomposition.cpp</ref>.  <linebreak/>
</para><para>The program below computes the Minkowski sum of two polygons that are read from an input file. In this case the sum may contain holes. The Minkowski sum, for example, of the polygons described in the default input file <computeroutput>room_star.dat</computeroutput> is not simple and contains four holes, as illustrated in Figure <ref refid="index_1fig__mink_figsum_holes" kindref="member">fig__mink_figsum_holes</ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Minkowski_sum_2_2sum_with_holes_8cpp-example" kindref="compound">Minkowski_sum_2/sum_with_holes.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Computing<sp/>the<sp/>Minkowski<sp/>sum<sp/>of<sp/>two<sp/>non-convex<sp/>polygons<sp/>read<sp/>from<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/minkowski_sum_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;bops_linear.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pgn_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file<sp/>and<sp/>read<sp/>the<sp/>two<sp/>polygons<sp/>from<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;rooms_star.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/><sp/><sp/><sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>the<sp/>input<sp/>file.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/><sp/><sp/>P,<sp/>Q;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>P<sp/>&gt;&gt;<sp/>Q;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>and<sp/>print<sp/>the<sp/>Minkowski<sp/>sum.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_with_holes_2<sp/><sp/>sum<sp/>=<sp/><ref refid="group__PkgMinkowskiSum2_1ga5ce6e837bdb4ea8973c8120c38301d7b" kindref="member">CGAL::minkowski_sum_2</ref>(P,<sp/>Q);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;P<sp/>(+)<sp/>Q<sp/>=<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_polygon_with_holes(sum);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>While in general the convolution approach to computing Minkowski sums runs faster, we observed that when the proportion of reflex vertices in both summands is large, the decomposition approach runs faster. In the following we describe how to employ the decomposition-based Minkowski sum procedure.</para></sect2>
<sect2 id="index_1mink_ssec_decomp_strategies">
<title>Decomposition Strategies</title>
<para>In order to compute Minkowski sums of two polygon <formula id="67">$ P $</formula> and <formula id="68">$ Q $</formula> using the decomposition method, issue the call <ref refid="group__PkgMinkowskiSum2_1ga5ce6e837bdb4ea8973c8120c38301d7b" kindref="member"><computeroutput>minkowski_sum_2(P, Q, decompP, decompQ)</computeroutput></ref>, where each of <formula id="50">$P $</formula> and <formula id="51">$Q $</formula> is either a simple polygon or a polygon with holes. If <formula id="50">$P $</formula> is a simple polygon, <computeroutput>decompP</computeroutput> must be an object of a type that models the concept <computeroutput><ref refid="classPolygonConvexDecomposition__2" kindref="compound">PolygonConvexDecomposition_2</ref></computeroutput>. If <formula id="50">$P $</formula> is a polygon with holes, them <computeroutput>decompP</computeroutput> is an object of a type that models the concept <computeroutput><ref refid="classPolygonWithHolesConvexDecomposition__2" kindref="compound">PolygonWithHolesConvexDecomposition_2</ref></computeroutput>, which refines the concept <computeroutput><ref refid="classPolygonConvexDecomposition__2" kindref="compound">PolygonConvexDecomposition_2</ref></computeroutput>. The same holds for <formula id="51">$Q $</formula>. The two concepts <computeroutput><ref refid="classPolygonConvexDecomposition__2" kindref="compound">PolygonConvexDecomposition_2</ref></computeroutput> and <computeroutput><ref refid="classPolygonWithHolesConvexDecomposition__2" kindref="compound">PolygonWithHolesConvexDecomposition_2</ref></computeroutput> refine a <computeroutput>Functor</computeroutput> concept variant. Namely, they both require the provision of a function operator (<computeroutput>operator()</computeroutput>). The function operator of the model of the concept <computeroutput><ref refid="classPolygonConvexDecomposition__2" kindref="compound">PolygonConvexDecomposition_2</ref></computeroutput> accepts a planar simple polygon, while the function operator of the model of the concept <computeroutput><ref refid="classPolygonWithHolesConvexDecomposition__2" kindref="compound">PolygonWithHolesConvexDecomposition_2</ref></computeroutput> accepts a planar polygon with holes. Both return a range of convex polygons that represents the convex decomposition of the input polygon. If the decomposition strategy that decomposes <formula id="50">$P $</formula> is the same as the strategy that decomposes <formula id="51">$Q $</formula>, you can omit the forth argument, and issue the call <ref refid="group__PkgMinkowskiSum2_1ga5ce6e837bdb4ea8973c8120c38301d7b" kindref="member"><computeroutput>minkowski_sum_2(P, Q, decomp)</computeroutput></ref>, where <computeroutput>decomp</computeroutput> is an object that represents the common strategy. The class template <computeroutput><ref refid="classCGAL_1_1Polygon__nop__decomposition__2" kindref="compound">Polygon_nop_decomposition_2</ref></computeroutput>, which models the concept <computeroutput><ref refid="classPolygonConvexDecomposition__2" kindref="compound">PolygonConvexDecomposition_2</ref></computeroutput>, is a trivial convex decomposition strategy referred to as the <emphasis>nop</emphasis> strategy; it merely passes the input polygon to the next stage intact; use it in cases you know that the corresponding input polygon is convex to start with. If both <formula id="50">$P $</formula> and <formula id="51">$Q $</formula> are known to be convex, you can issue the call <ref refid="group__PkgMinkowskiSum2_1ga5ce6e837bdb4ea8973c8120c38301d7b" kindref="member"><computeroutput>minkowski_sum_2(P, Q, nop)</computeroutput></ref>, where <computeroutput>nop</computeroutput> is an object that represents the nop strategy.</para><para>The Minkowski-sum package includes four models of the concept <computeroutput><ref refid="classPolygonConvexDecomposition__2" kindref="compound">PolygonConvexDecomposition_2</ref></computeroutput> (besides the trivial model <computeroutput><ref refid="classCGAL_1_1Polygon__nop__decomposition__2" kindref="compound">Polygon_nop_decomposition_2</ref></computeroutput>) and two models of the refined concept <computeroutput><ref refid="classPolygonWithHolesConvexDecomposition__2" kindref="compound">PolygonWithHolesConvexDecomposition_2</ref></computeroutput> as described below. The first three are class templates that wrap the corresponding decomposition functions included in the <ref refid="index_1Chapter_2D_Polygon" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Planar Polygon Partitioning</ref> package.</para><para><itemizedlist>
<listitem>
<para>The <computeroutput><ref refid="classCGAL_1_1Optimal__convex__decomposition__2" kindref="compound">Optimal_convex_decomposition_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template uses the dynamic-programming algorithm of Greene <ref refid="citelist_1CITEREF_g-dpcp-83" kindref="member">[6]</ref> for computing an optimal decomposition of a polygon into a minimal number of convex sub-polygons. While this algorithm results in a small number of convex polygons, it consumes rather many resources, as it runs in <formula id="69">$ O(n^4) $</formula> time and <formula id="70">$ O(n^3) $</formula> space in the worst case, where <formula id="71">$ n $</formula> is the number of vertices in the input polygon.</para><para></para></listitem>
<listitem>
<para>The <computeroutput><ref refid="classCGAL_1_1Hertel__Mehlhorn__convex__decomposition__2" kindref="compound">Hertel_Mehlhorn_convex_decomposition_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template implements the approximation algorithm suggested by Hertel and Mehlhorn <ref refid="citelist_1CITEREF_hm-ftsp-83" kindref="member">[8]</ref>, which triangulates the input polygon and then discards unnecessary triangulation edges. After triangulation (carried out by the constrained-triangulation procedure of <ref refid="namespaceCGAL" kindref="compound">CGAL</ref>) the algorithm runs in <formula id="72">$ O(n) $</formula> time and space, and guarantees that the number of sub-polygons it generates is not more than four times the optimum.</para><para></para></listitem>
<listitem>
<para>The <computeroutput><ref refid="classCGAL_1_1Greene__convex__decomposition__2" kindref="compound">Greene_convex_decomposition_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template is an implementation of Greene&apos;s approximation algorithm <ref refid="citelist_1CITEREF_g-dpcp-83" kindref="member">[6]</ref>, which computes a convex decomposition of the polygon based on its partitioning into <formula id="73">$ y$</formula>-monotone polygons. This algorithm runs in <formula id="12">$ O(n \log n)$</formula> time and <formula id="13">$ O(n)$</formula> space, and has the same guarantee on the quality of approximation as Hertel and Mehlhorn&apos;s algorithm.</para><para></para></listitem>
<listitem>
<para>The <computeroutput><ref refid="classCGAL_1_1Small__side__angle__bisector__decomposition__2" kindref="compound">Small_side_angle_bisector_decomposition_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template is an implementation of a decomposition algorithm introduced in <ref refid="citelist_1CITEREF_cgal:afh-pdecm-02" kindref="member">[1]</ref>. It is based on the angle-bisector decomposition method suggested by Chazelle and Dobkin <ref refid="citelist_1CITEREF_cd-ocd-85" kindref="member">[4]</ref>, which runs in <formula id="17">$ O(n^2)$</formula> time. In addition, it applies a heuristic by Flato that reduces the number of output polygons in many common cases. The convex decompositions that it produces usually yield efficient running times for Minkowski sum computations. It starts by examining each pair of reflex vertices in the input polygon, such that the entire interior of the diagonal connecting these vertices is contained in the polygon. Out of all available pairs, the vertices <formula id="74">$ p_i$</formula> and <formula id="75">$ p_j$</formula> are selected, such that the number of reflex vertices encountered when traversing the boundary of the polygon from <formula id="74">$ p_i$</formula> to <formula id="75">$ p_j$</formula> in clockwise order is minimal. The polygon is split by the diagonal <formula id="76">$ p_i p_j$</formula>. This process is repeated recursively on both resulting sub-polygons. In case it is not possible to eliminate two reflex vertices at once any more, each reflex vertex is eliminated by a diagonal that is closest to the angle bisector emanating from this vertex and having rational-coordinate endpoints on both sides. </para></listitem>
</itemizedlist>
</para><para>The following are two models of the refined concept <computeroutput><ref refid="classPolygonWithHolesConvexDecomposition__2" kindref="compound">PolygonWithHolesConvexDecomposition_2</ref></computeroutput>. An instance of any one these two types can be used to decompose a polygon with holes. <itemizedlist>
<listitem>
<para>The <computeroutput><ref refid="classCGAL_1_1Polygon__vertical__decomposition__2" kindref="compound">Polygon_vertical_decomposition_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template uses vertical decomposition to decompose the underlying arrangement; see <ref refid="index_1chapterArrangement_on_surface_2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">2D Arrangements</ref> package.</para><para></para></listitem>
<listitem>
<para>The <computeroutput><ref refid="classCGAL_1_1Polygon__triangulation__decomposition__2" kindref="compound">Polygon_triangulation_decomposition_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template uses constrained triangulation to decompose the input polygons, which may have holes, into triangles. </para></listitem>
</itemizedlist>
</para><para>The example below demonstrates the computation of the Minkowski sum of the same input polygons used in <ref refid="Minkowski_sum_2_2sum_with_holes_8cpp-example" kindref="compound">Minkowski_sum_2/sum_with_holes.cpp</ref> (depicted in Figure <ref refid="index_1fig__mink_figsum_holes" kindref="member">fig__mink_figsum_holes</ref>), using the small-side angle-bisector decomposition strategy.</para><para><linebreak/>
<bold>File</bold> <ref refid="Minkowski_sum_2_2sum_by_decomposition_8cpp-example" kindref="compound">Minkowski_sum_2/sum_by_decomposition.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Computing<sp/>the<sp/>Minkowski<sp/>sum<sp/>of<sp/>two<sp/>non-convex<sp/>polygons<sp/>read<sp/>from<sp/>a<sp/>file</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>using<sp/>the<sp/>small-side<sp/>angle-bisector<sp/>decomposition<sp/>strategy.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/minkowski_sum_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Small_side_angle_bisector_decomposition_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pgn_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_with_holes_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_with_holes_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file<sp/>and<sp/>read<sp/>two<sp/>polygons<sp/>from<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;rooms_star.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/><sp/><sp/><sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>the<sp/>input<sp/>file.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/><sp/><sp/>P,<sp/>Q;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>P<sp/>&gt;&gt;<sp/>Q;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>Minkowski<sp/>sum<sp/>using<sp/>the<sp/>decomposition<sp/>approach.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Small__side__angle__bisector__decomposition__2" kindref="compound">CGAL::Small_side_angle_bisector_decomposition_2&lt;Kernel&gt;</ref><sp/><sp/>ssab_decomp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_with_holes_2<sp/><sp/>sum<sp/>=<sp/><ref refid="group__PkgMinkowskiSum2_1ga5ce6e837bdb4ea8973c8120c38301d7b" kindref="member">CGAL::minkowski_sum_2</ref>(P,<sp/>Q,<sp/>ssab_decomp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;P<sp/>(+)<sp/>Q<sp/>=<sp/>&quot;</highlight><highlight class="normal">;<sp/>print_polygon_with_holes(sum);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1mink_ssec_optimal_decomp">
<title>Optimal Decomposition</title>
<para>Decomposition methods that handle polygons with holes are typically more costly than decomposition methods that handle only simple polygons. The hole filtration (see <ref refid="index_1mink_ssec_hole_filter" kindref="member">Filtering Out Holes</ref>) is applied before the actual construction starts (be it convolution based or decomposition based). The filteration may result with a polygon that does not have holes, or even a convex polygon, but this is unkown at the time of the call. To this end, we introduce the overloaded function template <ref refid="group__PkgMinkowskiSum2_1ga06670e5f096d0fcbf4da539b6148c55f" kindref="member"><computeroutput>minkowski_sum_by_decomposition_2(P, Q, no_holes_decomp, with_holes_decomp)</computeroutput></ref>, where <computeroutput>no_holes_decomp</computeroutput> and <computeroutput>with_holes_decomp</computeroutput> are objects that model the concepts <computeroutput><ref refid="classPolygonConvexDecomposition__2" kindref="compound">PolygonConvexDecomposition_2</ref></computeroutput> and <computeroutput><ref refid="classPolygonWithHolesConvexDecomposition__2" kindref="compound">PolygonWithHolesConvexDecomposition_2</ref></computeroutput>, respectively. If after the application of the hole filtration <formula id="58">$P$</formula> remains a polygon with holes, then the strategy represented by the object <computeroutput>with_holes_decomp</computeroutput> is applied to it. If, however, <formula id="58">$P$</formula> turns into a polygon without holes, then the strategy represented by the object <computeroutput>no_holes_decomp</computeroutput> is applied to it, unless the result is a convex polygon, in which case the nop strategy is applied. If <formula id="58">$P$</formula> is a polygon without holes to start with, then only convexity is checked. (Checking whether the result is convex inccurs a small overhead though.) The same holds for <formula id="59">$Q$</formula>.</para></sect2>
</sect1>
<sect1 id="index_1mink_secoffset">
<title>Offsetting a Polygon</title>
<para>The operation of computing the Minkowski sum <formula id="3">$ P \oplus B_r$</formula> of a polygon <formula id="0">$ P$</formula> with a disc <formula id="77">$ b_r$</formula> of radius <formula id="1">$ r$</formula> centered at the origin is widely known as <emphasis>offsetting</emphasis> the polygon <formula id="0">$ P$</formula> by a radius <formula id="1">$ r$</formula>.</para><para><anchor id="index_1fig__mink_figpgn_offset"/><center> <table rows="2" cols="3"><row>
<entry thead="no"><para><image type="html" name="ms_offset_convex.png"></image>
 <image type="latex" name="ms_offset_convex.png"></image>
  </para></entry><entry thead="no"><para><image type="html" name="ms_offset_nonconvex.png"></image>
 <image type="latex" name="ms_offset_nonconvex.png"></image>
  </para></entry><entry thead="no"><para><image type="html" name="ms_offset_convolution.png"></image>
 <image type="latex" name="ms_offset_convolution.png"></image>
  </para></entry></row>
<row>
<entry thead="no"><para>(a)</para></entry><entry thead="no"><para>(b)</para></entry><entry thead="no"><para>(c) </para></entry></row>
</table>
</center>  <ref refid="index_1fig__mink_figpgn_offset" kindref="member">fig__mink_figpgn_offset</ref> (a) The offset of a convex polygon. (b) The offset of a non-convex polygon as computed by decomposing it into two convex sub-polygons. (c) The offset of a non-convex polygon as computed using the convolution approach. The convolution cycle induces an arrangement with three faces, whose winding numbers are indicated.  <linebreak/>
</para><para>Let <formula id="67">$ P $</formula> be a simple polygon, and let <formula id="78">$ p_0, \ldots, p_{n - 1} $</formula> be the vertices of <formula id="67">$ P $</formula> oriented counterclockwise around the interior of <formula id="67">$ P $</formula>. If <formula id="0">$ P$</formula> is a convex polygon the offset is easily computed by shifting each polygon edge by <formula id="1">$ r$</formula> away from the polygon, namely to the right side of the edge. As a result we obtain a collection of <formula id="14">$ n$</formula> disconnected <emphasis>offset edges</emphasis>. Each pair of adjacent offset edges, induced by <formula id="79">$ p_{i-1} p_i$</formula> and <formula id="80">$ p_i p_{i+1}$</formula>, are connected by a circular arc of radius <formula id="1">$ r$</formula>, whose supporting circle is centered at <formula id="74">$ p_i$</formula>. The angle that defines such a circular arc equals <formula id="81">$ 180^{\circ} - \angle (p_{i-1}, p_i, p_{i+1})$</formula>; see <ref refid="index_1fig__mink_figpgn_offset" kindref="member">fig__mink_figpgn_offset</ref> (a) for an illustration. The running time of this simple process is naturally linear with respect to the size of the polygon.</para><para>If <formula id="0">$ P$</formula> is not convex, its offset can be obtained by decomposing it into convex sub-polygons <formula id="82">$ P_1, \ldots P_m$</formula> such that <formula id="83">$ \bigcup_{i=1}^{m}{P_i} = P$</formula>, computing the offset of each sub-polygon, and finally calculating the union of these offsets sub-polygons; see <ref refid="index_1fig__mink_figpgn_offset" kindref="member">fig__mink_figpgn_offset</ref> (b). However, as with the case of the Minkowski sum of a pair of polygons, it is also more efficient to compute the <emphasis>convolution cycle</emphasis> of the polygon and the disc <formula id="4">$ B_r$</formula>,As the disc is convex, it is guaranteed that the convolution curve comprises a single cycle. which can be constructed by applying the process described in the previous paragraph for convex polygons: The only difference is that a circular arc induced by a reflex vertex <formula id="74">$ p_i$</formula> is defined by an angle <formula id="84">$ 180^{\circ} + \measuredangle p_{i-1} p_i p_{i+1}$</formula>; see <ref refid="index_1fig__mink_figpgn_offset" kindref="member">fig__mink_figpgn_offset</ref> (c) for an illustration. Recall that the last step consists of computing the winding numbers of the faces of the arrangement induced by the convolution cycle and discarding the faces with zero winding numbers.</para><sect2 id="index_1mink_ssec_approx_offset">
<title>Approximating the Offset with a Guaranteed Error Bound</title>
<para>Let <formula id="67">$ P $</formula> be a counterclockwise-oriented simple polygon all vertices of which <formula id="85">$ p_0, \ldots, p_{n-1} $</formula> have rational coordinates, i.e., for each vertex <formula id="86">$ p_i = (x_i, y_i)$</formula> we have <formula id="87">$ x_i, y_i \in {\mathbb Q}$</formula>. Consider the Minkowski sum of <formula id="67">$ P $</formula> with a disc of radius <formula id="1">$ r$</formula>, where <formula id="1">$ r$</formula> is also a rational number. The boundary of this sum is comprised line segments and circular arcs, where: <itemizedlist>
<listitem>
<para>Each circular arc is supported by a circle of radius <formula id="1">$ r$</formula> centered at a polygon vertex <formula id="88">$ p_i $</formula>. The equation of this circle, <formula id="89">$ (x - x_i)^2 + (y - y_i)^2 = r^2$</formula>, has only rational coefficients. </para></listitem>
<listitem>
<para>Each line segment is supported by a line parallel to a polygon edge <formula id="80">$ p_i p_{i+1}$</formula> at distance <formula id="1">$ r$</formula> from this edge. Let <formula id="90">$ A, B, C \in {\mathbb Q}$</formula> denote the coefficients of the equation <formula id="80">$ p_i p_{i+1}$</formula> by <formula id="91">$ Ax + By + C = 0 $</formula> of the supporting line of <formula id="92">$ p_i p_{i+1} $</formula>.</para><para>The locus of all points that lie at distance <formula id="93">$r $</formula> from the line <formula id="91">$ Ax + By + C = 0 $</formula> is given by: <formula id="94">\[ \frac{(Ax + By + C)^2}{A^2 + B^2} = r^2 \ .\]</formula> Thus, the linear offset edges are segments of an algebraic curve of degree <formula id="95">$ 2 $</formula> (a conic curve) with rational coefficients. This curve is actually a pair of the parallel lines <formula id="96">$ Ax + By + (C \pm r \cdot \sqrt{A/B+1}) = 0 $</formula>. The offset edge is supported by the line <formula id="97">$ Ax + By + C&apos; = 0 $</formula>, where <formula id="98">$ C&apos; = C + r \cdot \sqrt{A/B+1} $</formula> is in general <emphasis>not</emphasis> a rational number. Therefore, the line segments that compose the offset boundaries cannot be represented as segments of lines with rational coefficients. In Section <ref refid="index_1mink_ssec_exact_offset" kindref="member">Computing the Exact Offset</ref> we use the line-pair representation to construct the offset polygonin an exact manner using the traits class for conic arcs. </para></listitem>
</itemizedlist>
</para><para><anchor id="index_1fig__mink_figapprox_offset"/><image type="html" name="ms_approx_offset.png"></image>
 <image type="latex" name="ms_approx_offset.png" width="15cm"></image>
  <ref refid="index_1fig__mink_figapprox_offset" kindref="member">fig__mink_figapprox_offset</ref> Approximating the offset edge <formula id="99">$ o_1 o_2$</formula> induced by the polygon edge <formula id="100">$ p_1 p_2$</formula> by two line segments <formula id="101">$ o&apos;_1 q&apos;$</formula> and <formula id="102">$ q&apos; o&apos;_2$</formula>.  <linebreak/>
</para><para>The class-template <computeroutput><ref refid="classCGAL_1_1Gps__circle__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">Gps_circle_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput>, included in the Boolean Set-Operations package, is used for representing generalized polygons the edges of which are circular arcs or line segments, and for applying Boolean set operations (e.g., intersection and union) on such generalized polygons. When it is instantiated, the template parameter &apos;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&apos; must be substituted with a geometric kernel that employs exact rational arithmetic. The curves that compose the polygon edges should are then arcs of circles with rational coefficients or segments of lines with rational coefficients. However, the line segments that result from the (exact) offsetting operation may be irrational. As we still wish to use the polygons defined by the <computeroutput><ref refid="classCGAL_1_1Gps__circle__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">Gps_circle_segment_traits_2</ref></computeroutput> class template to compute Boolean set operations more efficiently, we apply a simple approximation scheme such that each irrational line segment is approximated by two rational segments.</para><para>Consider the example depicted in Figure <ref refid="index_1fig__mink_figapprox_offset" kindref="member">fig__mink_figapprox_offset</ref>, where the exact offset edge <formula id="99">$ o_1 o_2$</formula> is obtained by shifting the polygon edge <formula id="100">$ p_1 p_2$</formula> by a vector of length <formula id="1">$ r$</formula> that forms an angle <formula id="103">$ \phi$</formula> with the <formula id="28">$ x$</formula>-axis. We select two points <formula id="104">$ o&apos;_1$</formula> and <formula id="105">$ o&apos;_2$</formula> with rational coordinates that lie on the two circles of radius <formula id="106">$ r $</formula> centered at <formula id="107">$ p_1$</formula> and <formula id="108">$ p_2$</formula>, respectively. These points are selected such that <formula id="109">$ \phi&apos;_1 &lt; \phi &lt; \phi&apos;_2 $</formula>, where <formula id="110">$ \phi&apos;_j, j = 1,2 $</formula> is the angle that the vector <formula id="111">$ \overrightarrow{p_j o_j} $</formula> forms with the $x$-axis. Then, we construct two tangents to the two circles at <formula id="104">$ o&apos;_1$</formula> and <formula id="105">$ o&apos;_2$</formula>, respectively. The tangent lines have rational coefficients. Finally, we compute the intersection point of the two tangents, denoted by <formula id="112">$ q&apos;$</formula>. The two line segments <formula id="101">$ o&apos;_1 q&apos;$</formula> and <formula id="102">$ q&apos; o&apos;_2$</formula> approximate the original offset edge <formula id="99">$ o_1 o_2$</formula>.</para><para>The <ref refid="group__PkgMinkowskiSum2_1gaa5e4e711f2d098e97e6358a669e194aa" kindref="member"><computeroutput>approximated_offset_2(P, r, epsilon)</computeroutput></ref> function template accepts a polygon <formula id="0">$ P$</formula> that is either simple or degenerate (consisting of two points only), an offset radius <formula id="1">$ r$</formula>, and (a floating-point number) <formula id="113">$ \epsilon &gt; 0 $</formula>. It constructs an approximation of the offset of <formula id="0">$ P$</formula> by the radius <formula id="1">$ r$</formula> using the procedure described above. Furthermore, it is guaranteed that the approximation error, namely the distance of the point <formula id="112">$ q&apos;$</formula> from <formula id="99">$ o_1 o_2$</formula>, is bounded by <formula id="114">$ \epsilon $</formula>. Using this function, it is possible to use the <computeroutput><ref refid="classCGAL_1_1Gps__circle__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">Gps_circle_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template, which considerably speeds up the (approximate) construction of the offset polygon and the application of Boolean set operations on such polygons; see Section <ref refid="index_1arr_ssectr_circ_seg" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">A Traits Class for Circular Arcs and Line Segments</ref> for the exploitation of the efficient square root extension number type. The function returns an object of the nested type <computeroutput>Gps_circle_segment_traits_2::Polygon_with_holes_2</computeroutput> representing the approximated offset polygon. Recall that if <formula id="0">$ P$</formula> is not convex, its offset may not be simple and may contain holes, the boundaries of which are also formed by line segments and circular arcs.</para><para><anchor id="index_1fig__mink_figex_offset"/><image type="html" name="ms_exact_offset.png"></image>
 <image type="latex" name="ms_exact_offset.png" width="15cm"></image>
  <ref refid="index_1fig__mink_figex_offset" kindref="member">fig__mink_figex_offset</ref> The offset computation performed by the example programs <ref refid="Minkowski_sum_2_2approx_offset_8cpp-example" kindref="compound">Minkowski_sum_2/approx_offset.cpp</ref> and <ref refid="Minkowski_sum_2_2exact_offset_8cpp-example" kindref="compound">Minkowski_sum_2/exact_offset.cpp</ref>. The input polygon is shaded and the boundary of its offset is drawn in a thick black line.  <linebreak/>
</para><para>The example below demonstrates the construction of an approximated offset of a non-convex polygon, as depicted in Figure <ref refid="index_1fig__mink_figex_offset" kindref="member">fig__mink_figex_offset</ref>. The program uses types defined in the header file <computeroutput>bops_circular.h</computeroutput>, which defines the polygon types.</para><para><linebreak/>
<bold>File</bold> <ref refid="Minkowski_sum_2_2approx_offset_8cpp-example" kindref="compound">Minkowski_sum_2/approx_offset.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Computing<sp/>the<sp/>approximated<sp/>offset<sp/>of<sp/>a<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/timer.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/approximated_offset_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;bops_circular.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Linear_polygon;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file<sp/>and<sp/>read<sp/>a<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;spiked.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>the<sp/>input<sp/>file.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Linear_polygon<sp/><sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Read<sp/>an<sp/>input<sp/>polygon<sp/>with<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>P.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Approximate<sp/>the<sp/>offset<sp/>polygon<sp/>with<sp/>radius<sp/>5<sp/>and<sp/>error<sp/>bound<sp/>0.00001.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::timer<sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_with_holes_2<sp/>offset<sp/>=<sp/><ref refid="group__PkgMinkowskiSum2_1gaa5e4e711f2d098e97e6358a669e194aa" kindref="member">CGAL::approximated_offset_2</ref>(P,<sp/>5,<sp/>0.00001);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>secs<sp/>=<sp/>timer.elapsed();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>offset<sp/>polygon<sp/>has<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>offset.outer_boundary().size()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>offset.number_of_holes()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>holes.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Offset<sp/>computation<sp/>took<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>secs<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1mink_ssec_exact_offset">
<title>Computing the Exact Offset</title>
<para>As mentioned in the previous section, it is possible to represent offset polygons in an exact manner if the edges of the polygons are represented as arcs of conic curves with rational coefficients. The <ref refid="group__PkgMinkowskiSum2_1gabda2c65926cde6e2559c4203ae6b31c2" kindref="member"><computeroutput>offset_polygon_2(P, r, traits)</computeroutput></ref> function template computes the offset of a given polygon <formula id="0">$ P$</formula> by a rational radius <formula id="1">$ r$</formula> in an exact manner. The input polygon <formula id="0">$ P$</formula> must be either simple or degenerate consisting of two vertices (representing a line segment). The <computeroutput>traits</computeroutput> argument must model the concept <computeroutput><ref refid="classArrangementTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">ArrangementTraits_2</ref></computeroutput> and it should be capable of handling conic arcs in an exact manner<mdash/>using an instance of the <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_conic_traits_2</ref></computeroutput> class template with the number types provided by the Core library is the preferred option; see <ref refid="index_1arr_ssectr_conic" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">A Traits Class for Conic Arcs</ref> for more details. The function template returns an object of the nested type <computeroutput>Gps_traits_2::Polygons_with_holes_2</computeroutput> (see <ref refid="index_1bso_ssecgeneral_polygon_concept" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">General Polygon Set Traits Adapter</ref> for more details on the traits-class adaptor <computeroutput><ref refid="classCGAL_1_1Gps__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">Gps_traits_2</ref></computeroutput>), which represents the exact offset polygon.</para><para>The following example demonstrates the construction of the offset of the same polygon that serves as an input for the example program <ref refid="Minkowski_sum_2_2approx_offset_8cpp-example" kindref="compound">Minkowski_sum_2/approx_offset.cpp</ref>, presented in the previous subsection (see also <ref refid="index_1fig__mink_figex_offset" kindref="member">fig__mink_figex_offset</ref>). Note that the resulting polygon is smaller than the one generated by the approximated-offset function (recall that each irrational line segment in this case is approximated by two rational line segments), but the offset computation is considerably slower:</para><para><linebreak/>
<bold>File</bold> <ref refid="Minkowski_sum_2_2exact_offset_8cpp-example" kindref="compound">Minkowski_sum_2/exact_offset.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Computing<sp/>the<sp/>exact<sp/>offset<sp/>of<sp/>a<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/timer.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Gps_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/offset_polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_conics.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Rat_kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Gps__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">CGAL::Gps_traits_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Gps_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Gps_traits::Polygon_with_holes_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Offset_polygon_with_holes_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file<sp/>and<sp/>read<sp/>the<sp/>input<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;spiked.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>the<sp/>input<sp/>file.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/><sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Read<sp/>an<sp/>input<sp/>polygon<sp/>with<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>P.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>offset<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::timer<sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Offset_polygon_with_holes_2<sp/>offset<sp/>=<sp/><ref refid="group__PkgMinkowskiSum2_1gabda2c65926cde6e2559c4203ae6b31c2" kindref="member">CGAL::offset_polygon_2</ref>(P,<sp/>5,<sp/>traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>secs<sp/>=<sp/>timer.elapsed();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>offset<sp/>polygon<sp/>has<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>offset.outer_boundary().size()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>offset.number_of_holes()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>holes.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Offset<sp/>computation<sp/>took<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>secs<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para><para></para><para>Both functions templates <computeroutput><ref refid="group__PkgMinkowskiSum2_1gaa5e4e711f2d098e97e6358a669e194aa" kindref="member">approximated_offset_2()</ref></computeroutput> and <computeroutput><ref refid="group__PkgMinkowskiSum2_1gabda2c65926cde6e2559c4203ae6b31c2" kindref="member">offset_polygon_2()</ref></computeroutput> also have overloaded versions that accept a decomposition strategy and use the polygon-decomposition approach to compute (or approximate) the offset. These functions are typically considerably slower than their counterparts that employ the convolution approach. However, similar to the functions that compute the general Minkowski sum, they are able to compute the offset of polygons with holes, given a decomposition strategy that handles polygons with holes, such as the <computeroutput><ref refid="classCGAL_1_1Polygon__vertical__decomposition__2" kindref="compound">Polygon_vertical_decomposition_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template. </para></sect2>
<sect2 id="index_1mink_ssec_inner_offset">
<title>Computing Inner Offsets</title>
<para>An operation closely related to the (outer) offset computation, is computing the <emphasis>inner offset</emphasis> of a polygon, or <emphasis>insetting</emphasis> it by a given radius. The inset of a polygon <formula id="0">$ P$</formula> with radius <formula id="1">$ r$</formula> is the set of points iside <formula id="0">$ P$</formula> the distance of which from the polygon boundary, denoted <formula id="115">$ \partial P$</formula>, is at least <formula id="1">$ r$</formula>, namely: <formula id="2">$ \{ p \in P \;|\; {\rm dist}(p, \partial P) \geq r \}$</formula>. Note that the resulting point set may be dicconnected when <formula id="0">$ P$</formula> is a non-convex polygon that has some narrow components. In such a case the resulting set is characterized by a (possibly empty) set of polygons the edges of which are line segments and circular arcs of radius <formula id="1">$ r$</formula>.</para><para>The inset can be computed using the convolution method traversing the polygon in a <emphasis>clockwise</emphasis> order (as oppose to the <emphasis>counterclockwise</emphasis> order applied in the case of ofsetting a polygon). As with the (outer) offset functions, the Minkowski-sum package contains two functions for insetting a simple polygon, namely, <computeroutput>approximated_inset_2(P, r, eps, oi)</computeroutput> and <computeroutput>inset_polygon_2(P, r, traits, oi)</computeroutput>.</para><para>The <ref refid="group__PkgMinkowskiSum2_1ga80e273611a4e3568a0208d5fb1551669" kindref="member"><computeroutput>approximated_inset_2(P, r, eps, oi)</computeroutput></ref> function template accepts a polygon <formula id="0">$ P$</formula>, an inset radius <formula id="1">$ r$</formula>, (a floating-point number) <formula id="113">$ \epsilon &gt; 0 $</formula>, and an output iterator <computeroutput>oi</computeroutput>, whose value-type must be an instance of the class template <computeroutput>Gps_circle_segment_traits_2::Polygon_2</computeroutput>. . It constructs an approximation of the inset of <formula id="0">$ P$</formula> by the radius <formula id="1">$ r$</formula>, where the approximation error is bounded by <formula id="116">$ \epsilon$</formula>. The function returns the polygons that approximate the inset polygon through the output iterator <computeroutput>oi</computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Minkowski_sum_2_2approx_inset_8cpp-example" kindref="compound">Minkowski_sum_2/approx_inset.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Computing<sp/>the<sp/>approximated<sp/>inset<sp/>of<sp/>a<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/timer.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/approximated_offset_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;bops_circular.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Linear_polygon;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file<sp/>and<sp/>read<sp/>a<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;tight.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>the<sp/>input<sp/>file.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>input<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Linear_polygon<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Read<sp/>an<sp/>input<sp/>polygon<sp/>with<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>P.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Approximate<sp/>the<sp/>offset<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Polygon_2&gt;<sp/>inset_polygons;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::timer<sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgMinkowskiSum2_1ga80e273611a4e3568a0208d5fb1551669" kindref="member">approximated_inset_2</ref>(P,<sp/>1,<sp/>0.00001,<sp/>std::back_inserter(inset_polygons));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>secs<sp/>=<sp/>timer.elapsed();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Polygon_2&gt;::iterator<sp/>it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>inset<sp/>comprises<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>inset_polygons.size()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>polygon(s).&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(it<sp/>=<sp/>inset_polygons.begin();<sp/>it<sp/>!=<sp/>inset_polygons.end();<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Polygon<sp/>with<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>it-&gt;size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Inset<sp/>computation<sp/>took<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>secs<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Similarly, the function template <ref refid="group__PkgMinkowskiSum2_1ga6ab5808d9bc7ba5e958b8b5bcb9e9824" kindref="member"><computeroutput>inset_polygon_2(P, r, traits, oi)</computeroutput> </ref> computes the exact inset of <formula id="0">$ P$</formula> with radius <formula id="1">$ r$</formula>, and returns its output through the given output iterator <computeroutput>oi</computeroutput>. The <computeroutput>traits</computeroutput> parameter must model the concept <computeroutput><ref refid="classArrangementTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">ArrangementTraits_2</ref></computeroutput> and it should be capable of handling conic arcs in an exact manner, whereas the value-type of <computeroutput>oi</computeroutput> must be an instance of <computeroutput>Gps_traits_2::Polygon_2</computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Minkowski_sum_2_2exact_inset_8cpp-example" kindref="compound">Minkowski_sum_2/exact_inset.cpp</ref> <programlisting><codeline><highlight class="comment">//<sp/>Computing<sp/>the<sp/>exact<sp/>inner<sp/>offset<sp/>of<sp/>a<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/timer.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Gps_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/offset_polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_conics.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Rat_kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Gps__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Boolean_set_operations_2.tag">CGAL::Gps_traits_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Gps_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Gps_traits::Polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Offset_polygon;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file<sp/>and<sp/>read<sp/>the<sp/>input<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;tight.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>the<sp/>input<sp/>file.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Read<sp/>an<sp/>input<sp/>polygon<sp/>with<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>P.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>inner<sp/>offset<sp/>of<sp/>the<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Offset_polygon&gt;<sp/>inset_polygons;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::timer<sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgMinkowskiSum2_1ga6ab5808d9bc7ba5e958b8b5bcb9e9824" kindref="member">inset_polygon_2</ref>(P,<sp/>1,<sp/>traits,<sp/>std::back_inserter(inset_polygons));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>secs<sp/>=<sp/>timer.elapsed();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Offset_polygon&gt;::iterator<sp/>it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>inset<sp/>comprises<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>inset_polygons.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>polygon(s).&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(it<sp/>=<sp/>inset_polygons.begin();<sp/>it<sp/>!=<sp/>inset_polygons.end();<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Polygon<sp/>with<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>it-&gt;size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Inset<sp/>computation<sp/>took<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>secs<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para><para>Unlike the functions that compute the offsets, there are no overloaded versions of the functions that compute the insets and use convex polygon decomposition, as decomposition approach cannot be easily generalized for inset computations.</para><para>The package also provides overloaded versions of the functions <ref refid="group__PkgMinkowskiSum2_1gaa5e4e711f2d098e97e6358a669e194aa" kindref="member"><computeroutput>approximated_offset_2(P, r, eps)</computeroutput></ref> and <ref refid="group__PkgMinkowskiSum2_1gabda2c65926cde6e2559c4203ae6b31c2" kindref="member"><computeroutput>offset_polygon_2(P, r, traits)</computeroutput></ref> that accept a <emphasis>polygon with holes</emphasis> <formula id="0">$ P$</formula> and compute its offset. This ofset is obtain by computing the outer offset of the outer boundary of <formula id="0">$ P$</formula>&apos;s, and computing the inner offsets of the holes of <formula id="0">$ P$</formula>. The former polygon defines the output boundary of <formula id="3">$ P \oplus B_r$</formula>, and the latter define the holes within the result.</para></sect2>
</sect1>
<sect1 id="index_1Minkoski_sum_2Design">
<title>Design and Implementation History</title>
<para>Eyal flato set the ground for the this package around the end of the previous millennium with his research work about Minkowski sum construction using the decomposition approach. However, it was only a few years later when Ron Wein developed the first version of this package, which was introduced with release 3.3. The first version of the package contained functionality for computeing the Minkowski sum of two polygons, computing the offset of a polygon by a disk, and approximating the offset of a polygon by a disk. Release 3.4 contained an enhancement of the offset computation, which allowed for polygon with holes as operands. Release 3.4 also featured new functionality for computing the inner offset of a polygon and approximating the inner offset. All this was also developed by Ron Wein. Release 3.7 contained an enhancement of the offset approximation for degenerate polygons such as line segments. This enhancement was developed by Efi Fogel, who also developed a new decomposition strategy, which can handle polygons with holes, essentially enabling the computation of Minkowski sum of two polygons with holes using the decomposition approach. The later was introduced with release 4.6. Ron Wein, Efi Fogel, Ophir Setter, Andreas Fabri, and Laurent Rineau helped maintaining the package applying bug fixes and other improvements. In particular, Andreas Fabri and Laurent Rineau helped tracing and solving several bugs in the approximated offset computation. They have also suggested a few algorithmic improvements that made their way into version 3.4, yielding a faster approximation scheme. During the <emphasis>Google Summer of Code</emphasis> 2014, Sebastian Morr, mentored by Michael Hemmer, implemented the reduced convolution approach, based on Alon Baram&apos;s master&apos;s thesis. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
