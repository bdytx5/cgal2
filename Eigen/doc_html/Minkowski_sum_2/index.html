<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Minkowski_sum_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Minkowski Sums: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Minkowski Sums
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Minkowski_Sums"></a> <a class="anchor" id="chapterMinkowskisum2"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Ron Wein, Alon Baram, Efi Fogel, Eyal Flato, Michael Hemmer, and Sebastian Morr</dd></dl>
<h1><a class="anchor" id="mink_secintro"></a>
Introduction</h1>
<p>Given two sets \( A,B \in \mathbb{R}^d\), their <em>Minkowski sum</em>, denoted by \( A \oplus B\), is their point-wise sum, namely the set \( \left\{ a + b ~|~ a \in A, b \in B \right\}\). Minkowski sums are used in many applications, such as motion planning and computer-aided design and manufacturing. This package contains functions that compute the planar Minkowski sums of two polygons. (Here, \( A\) and \( B\) are two closed polygons in \( \mathbb{R}^2\), which may have holes; see Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/index.html#Chapter_2D_Regularized_Boolean_Set-Operations">2D Regularized Boolean Set-Operations</a> for the precise definition of valid polygons), and the planar Minkowski sum of a simple polygon and a discâ€”an operation also referred to as <em>offsetting</em> or <em>dilating</em> a polygon.<span class="footnote">The family of valid types of summands is slightly broader for certain operations, e.g., a degenerate polygon consisting of line segments is a valid operand for the approximate-offsetting operation.</span> This package, like the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/index.html#Chapter_2D_Regularized_Boolean_Set-Operations">2D Regularized Boolean Set-Operations</a> package, is implemented on top of the arrangement infrastructure provided by the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#chapterArrangement_on_surface_2">2D Arrangements</a> package. The two packages are integrated well to allow mixed operations. For example, it is possible to apply Boolean set operations on objects that are the result of Minkowski sum computations.<span class="footnote">The operands of the Minkowski sum operations supported by this package must be (linear) polygons, as opposed to the operands of the Boolean set operations supported by the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/index.html#Chapter_2D_Regularized_Boolean_Set-Operations">2D Regularized Boolean Set-Operations</a> package. The latter belong to the broader family of general polygons.</span></p>
<h1><a class="anchor" id="mink_secsum_poly"></a>
Computing the Minkowski Sum of Two Polygons</h1>
<p><a class="anchor" id="fig__mink_figconvex"></a></p><div class="image">
<img src="ms_convex.png" alt="ms_convex.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__mink_figconvex">Figure 21.1</a>  </div>  <br />

<p>Computing the Minkowski sum of two convex polygons \( P\) and \( Q\) with \( m\) and \( n\) vertices, respectively, is rather easy. Observe that \( P \oplus Q\) is a convex polygon bounded by copies of the \( m + n\) edges ordered according to the angle they form with the \( x\)-axis. As the two input polygons are convex, their edges are already sorted by the angle they form with the \( x\)-axis; see the figure above. The Minkowski sum can therefore be computed using an operation similar to the merge step of the merge-sort algorithm<span class="footnote">See, for example, <a href="http://en.wikipedia.org/wiki/Merge_sort">http://en.wikipedia.org/wiki/Merge_sort</a>.</span> in \( O(m + n)\) time, starting from the two bottommost vertices in \( P\) and in \( Q\) and merging the ordered list of edges.</p>
<p><a class="anchor" id="fig__mink_figonecyc"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="ms_convex_polygon.png" alt="ms_convex_polygon.png" />
</div>
   </td><td><div class="image">
<img src="ms_concave_polygon.png" alt="ms_concave_polygon.png" />
</div>
   </td><td><div class="image">
<img src="ms_convolution.png" alt="ms_convolution.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__mink_figonecyc">Figure 21.2</a> The convolution of a convex polygon and a non-convex polygon. The convolution consists of a single self-intersecting cycle, drawn as a sequence of directed line segments. Each face of the arrangement induced by the segments forming the cycle contains its winding number. The Minkowski sum of the two polygons is shaded. Dotted edges are not part of the reduced convolution.  </div>  <br />

<p>If the polygons are not convex, you can utilize either the <em>Decomposition</em> or the <em>Convolution</em> approaches described below. Applications of some of the operations in this package are restricted to polygons that do not contain holes. (Resulting sums may contain holes though.)</p>
<dl>
<dt><b>Decomposition:</b></dt>
<dd><p class="startdd">We decompose \( P\) and \( Q\) into convex sub-polygons. Namely, we obtain two sets of convex polygons \( P_1, \ldots, P_k\) and \( Q_1, \ldots, Q_\ell\), such that \( \bigcup_{i = 1}^{k}{P_i} = P\) and \( \bigcup_{i = j}^{\ell}{Q_j} = Q\). We then calculate the pairwise sums \( S_{ij} = P_i \oplus Q_j\) using the simple procedure described above, and finally compute the union \( P \oplus Q = \bigcup_{ij}{S_{ij}}\); see <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/group__boolean__join.html#ref_bso_union">Union Functions</a>.</p>
<p>This approach relies on a successful decomposition of the input polygons into convex pieces, and its performance depends on the quality and performance of the decomposition. Some of the supplied decomposition methods do not handle polygons that contain holes.</p>
<p class="enddd"></p>
</dd>
<dt><b>Convolution:</b></dt>
<dd><p class="startdd">Let \( P = \left( p_0, \ldots, p_{m-1} \right)\) and \( Q = \left(q_0, \ldots, q_{n-1} \right)\) denote the vertices of the input polygons. We assume that both \( P\) and \( Q\) have positive orientations (i.e., their boundaries wind in a counterclockwise order around their interiors). The <em>convolution</em> of these two polygons <a class="el" href="citelist.html#CITEREF_grs-kfcg-83">[7]</a>, denoted \( P * Q\), is a collection of line segments of the form \( [p_i + q_j, p_{i+1} + q_j]\),<span class="footnote">Throughout this chapter, we increment or decrement an index of a vertex modulo the size of the polygon.</span> where the vector \( {\mathbf{p_i p_{i+1}}}\) lies between \( {\mathbf{q_{j-1} q_j}}\) and \( {\mathbf{q_j q_{j+1}}}\),<span class="footnote">We say that a vector \( {\mathbf v}\) lies between two vectors \( {\mathbf u}\) and \( {\mathbf w}\) if we reach \( {\mathbf v}\) strictly before reaching \( {\mathbf w}\) if we move all three vectors to the origin and rotate \( {\mathbf u}\) counterclockwise. Note that this also covers the case where \( {\mathbf u}\) has the same direction as \( {\mathbf v}\).</span> and, symmetrically, of segments of the form \( [p_i + q_j, p_i + q_{j+1}]\), where the vector \( {\mathbf{q_j q_{j+1}}}\) lies between \( {\mathbf{p_{i-1} p_i}}\) and \( {\mathbf{p_i p_{i+1}}}\).</p>
<p>The segments of the convolution form a number of closed (not necessarily simple) polygonal curves called <em>convolution cycles</em>. The Minkowski sum \( P \oplus Q\) is the set of points having a non-zero winding number with respect to the cycles of \( P * Q\).<span class="footnote">Informally speaking, the winding number of a point \( p \in\mathbb{R}^2\) with respect to some planar curve \( \gamma\) is an integer number counting how many times does \( \gamma\) wind in a counterclockwise direction around \( p\).</span> See <a class="el" href="index.html#fig__mink_figonecyc">Figure 21.2</a> for an illustration.</p>
<p>We construct the arrangement induced by the convolution cycles of \(P \) and \(Q \), then compute the winding numbers of the cells of the arrangement. Finally, we extract the Minkowski sum from the arrangement. This variant is referred to as the full-convolution method.</p>
<p>A segment \([p_i + q_j, p_{i+1} + q_j] \) (resp. \([p_i + q_j, p_i + q_{j+1}] \)) cannot possibly contribute to the boundary of the Minkowski sum if \(q_j \) (resp. \(p_i \)) is a reflex vertex (see dotted edges in <a class="el" href="index.html#fig__mink_figonecyc">Figure 21.2</a>). The remaining subset of convolution segments is called the <em>reduced convolution</em> <a class="el" href="citelist.html#CITEREF_cgal:bl-frmsurc-11">[3]</a>. This subset is still a superset of the Minkowski sum boundary, but the winding number property does not apply any longer as there are no closed cycles anymore. We apply two different filters, which identify holes in the Minkowski sum: </p><ol>
<li>
A loop that is on the Minkowski sum boundary has to be orientable; that is, all normal directions of its edges have to point either inward or outward. </li>
<li>
For any point \(x\) inside of a hole of the Minkowski sum, the following condition holds: \((-P + x) \cap Q = \emptyset\). If, on the other hand, the inversed version of \(P\), translated by \(x\), overlaps \(Q\), the loop is a <em>false</em> hole and is in the interior of the Minkowski sum. </li>
</ol>
<p class="enddd">After applying these two filters, only those segments which constitute the Minkowski sum boundary remain. This variant is referred to as the reduced-convolution method. </p>
</dd>
</dl>
<p>The number of segments in the convolution of two polygons is usually smaller than the number of segments that constitute the boundaries of the sub-sums \( S_{ij}\) when using the decomposition approach. As both approaches construct the arrangement of these segments and extract the sum from this arrangement, computing Minkowski sum using the convolution approach usually generates a smaller intermediate arrangement; hence it is faster and consumes less space. In most cases, the reduced convolution method is faster than the full convolution method, as the respective induced arrangement is usually much smaller. However, in degenerate cases with many holes in the Minkowski sum, the full convolution method can be preferable, as it avoids costly intersection tests.</p>
<h2><a class="anchor" id="mink_ssec_hole_filter"></a>
Filtering Out Holes</h2>
<p>If a hole in one polygon is relatively small compared to the other polygon, the hole is irrelevant for the computation of \(P\oplus Q \) <a class="el" href="citelist.html#CITEREF_bfhhm-epsph-15">[2]</a>; It implies that the hole can be removed (that is, filled up) before the main computation starts. Theoretically, we can always fill up all the holes of at least one polygon, transforming it into a simple polygon, and still obtain exactly the same Minkowski sum. Practically, we remove all holes in one polygon whose bounding boxes are, in \(x \)- or \(y \)-direction, smaller than, or as large as, the bounding box of the other polygon. Obliterating holes in the input summands speeds up the computation of Minkowski sums, regardless of the approach used to compute the Minkowski sum.</p>
<h2><a class="anchor" id="mink_ssec_conv"></a>
Computing Minkowski Sum using Convolutions</h2>
<p>The function template <a class="el" href="group__PkgMinkowskiSum2.html#ga5ce6e837bdb4ea8973c8120c38301d7b"><code>minkowski_sum_2(P, Q)</code></a> accepts two polygons \( P\) and \( Q\) and computes their Minkowski sum \( S = P \oplus Q\) using the convolution approach. The call <a class="el" href="group__PkgMinkowskiSum2.html#ga5ce6e837bdb4ea8973c8120c38301d7b"><code>minkowski_sum_2(P, Q)</code></a> defaults to the call <a class="el" href="group__PkgMinkowskiSum2.html#gad3220ac962eacdaad0c3ad538e7d97af"><code>minkowski_sum_by_reduced_convolution_2(P, Q)</code></a>, which applies the reduced convolution aforementioned method. Explicitly call <a class="el" href="group__PkgMinkowskiSum2.html#ga09275e94b4a9016406f552b612c6335c"><code>minkowski_sum_by_full_convolution_2(P, Q)</code></a> to apply the full convolution method. The types of the operands accepted by the function <a class="el" href="group__PkgMinkowskiSum2.html#ga09275e94b4a9016406f552b612c6335c"><code>minkowski_sum_by_full_convolution_2(P, Q)</code></a> are instances of the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html"><code>Polygon_2</code></a> class template. The types of operands accepted by the function <a class="el" href="group__PkgMinkowskiSum2.html#gad3220ac962eacdaad0c3ad538e7d97af"><code>minkowski_sum_by_reduced_convolution_2(P, Q)</code></a> (and by the function <a class="el" href="group__PkgMinkowskiSum2.html#ga5ce6e837bdb4ea8973c8120c38301d7b"><code>minkowski_sum_2(P, Q)</code></a>) are instances of either the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html"><code>Polygon_2</code></a> or <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html"><code>Polygon_with_holes_2</code></a> class templates. Even when the input polygons are restricted to be simple polygons, they still may not be convex; thus, their Minkowski sum may not be simply connected and may contain polygonal holes; see for example <a class="el" href="index.html#fig__mink_figonecyc">Figure 21.2</a>. The type of the returned object \( S \) is therefore an instance of the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html"><code>Polygon_with_holes_2</code></a> class template in all cases. Recall that the outer boundary of \(S \) is a polygon that can be accessed using <code>S.outer_boundary()</code>, and its polygonal holes are given by the range [<code>S.holes_begin()</code>, <code>S.holes_end()</code>) (where \( S \) contains <code>S.number_of_holes()</code> holes in its interior).</p>
<p><a class="anchor" id="fig__mink_figsum_tri_sqr"></a></p><div class="image">
<img src="ms_sum_triangle_square.png" alt="ms_sum_triangle_square.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__mink_figsum_tri_sqr">Figure 21.3</a> The Minkowski sum of a triangle and a square, as computed by the example program <a class="el" href="Minkowski_sum_2_2sum_triangle_square_8cpp-example.html">Minkowski_sum_2/sum_triangle_square.cpp</a>.  </div>  <br />

<p>The example program below constructs the Minkowski sum of a triangle and a square, as depicted in <a class="el" href="index.html#fig__mink_figsum_tri_sqr">Figure 21.3</a>. The result in this case is a convex hexagon. This program, like other example programs in this package, includes the header file <code>bops_linear.h</code>, which defines the polygon types.</p>
<p><br />
<b>File</b> <a class="el" href="Minkowski_sum_2_2sum_triangle_square_8cpp-example.html">Minkowski_sum_2/sum_triangle_square.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Computing the Minkowski sum of a triangle and a square.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/minkowski_sum_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "bops_linear.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the triangle.</span></div><div class="line">  Polygon_2   P;</div><div class="line">  P.push_back(Point_2(-1, -1));  P.push_back(Point_2(1, -1));</div><div class="line">  P.push_back(Point_2(0, 1));</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"P = "</span> &lt;&lt; P &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Construct the square.</span></div><div class="line">  Polygon_2   Q;</div><div class="line">  Q.push_back(Point_2(3, -1));  Q.push_back(Point_2(5, -1));</div><div class="line">  Q.push_back(Point_2(5, 1));   Q.push_back(Point_2(3,  1));</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Q = "</span> &lt;&lt; Q &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Compute the Minkowski sum.</span></div><div class="line">  Polygon_with_holes_2  sum = <a class="code" href="group__PkgMinkowskiSum2.html#ga5ce6e837bdb4ea8973c8120c38301d7b">CGAL::minkowski_sum_2</a>(P, Q);</div><div class="line">  CGAL_assertion(sum.number_of_holes() == 0);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"P (+) Q = "</span> &lt;&lt; sum.outer_boundary() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__mink_figsum_holes"></a></p><div class="image">
<img src="ms_tight.png" alt="ms_tight.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__mink_figsum_holes">Figure 21.4</a> The Minkowski sum of two non-convex polygons \( P\) and \( Q\), as computed by the example programs <a class="el" href="Minkowski_sum_2_2sum_with_holes_8cpp-example.html">Minkowski_sum_2/sum_with_holes.cpp</a> and <a class="el" href="Minkowski_sum_2_2sum_by_decomposition_8cpp-example.html">Minkowski_sum_2/sum_by_decomposition.cpp</a>.  </div>  <br />

<p>The program below computes the Minkowski sum of two polygons that are read from an input file. In this case the sum may contain holes. The Minkowski sum, for example, of the polygons described in the default input file <code>room_star.dat</code> is not simple and contains four holes, as illustrated in Figure <a class="el" href="index.html#fig__mink_figsum_holes">Figure 21.4</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Minkowski_sum_2_2sum_with_holes_8cpp-example.html">Minkowski_sum_2/sum_with_holes.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Computing the Minkowski sum of two non-convex polygons read from a file.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/minkowski_sum_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "bops_linear.h"</span></div><div class="line"><span class="preprocessor">#include "pgn_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Open the input file and read the two polygons from it.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"rooms_star.dat"</span>;</div><div class="line">  std::ifstream    in_file(filename);</div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open the input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line">  Polygon_2   P, Q;</div><div class="line">  in_file &gt;&gt; P &gt;&gt; Q;</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Compute and print the Minkowski sum.</span></div><div class="line">  Polygon_with_holes_2  sum = <a class="code" href="group__PkgMinkowskiSum2.html#ga5ce6e837bdb4ea8973c8120c38301d7b">CGAL::minkowski_sum_2</a>(P, Q);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"P (+) Q = "</span>;</div><div class="line">  print_polygon_with_holes(sum);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>While in general the convolution approach to computing Minkowski sums runs faster, we observed that when the proportion of reflex vertices in both summands is large, the decomposition approach runs faster. In the following we describe how to employ the decomposition-based Minkowski sum procedure.</p>
<h2><a class="anchor" id="mink_ssec_decomp_strategies"></a>
Decomposition Strategies</h2>
<p>In order to compute Minkowski sums of two polygon \( P \) and \( Q \) using the decomposition method, issue the call <a class="el" href="group__PkgMinkowskiSum2.html#ga5ce6e837bdb4ea8973c8120c38301d7b"><code>minkowski_sum_2(P, Q, decompP, decompQ)</code></a>, where each of \(P \) and \(Q \) is either a simple polygon or a polygon with holes. If \(P \) is a simple polygon, <code>decompP</code> must be an object of a type that models the concept <code><a class="el" href="classPolygonConvexDecomposition__2.html" title="A model of the PolygonConvexDecomposition_2 concept is capable of decomposing an input polygon  into ...">PolygonConvexDecomposition_2</a></code>. If \(P \) is a polygon with holes, them <code>decompP</code> is an object of a type that models the concept <code><a class="el" href="classPolygonWithHolesConvexDecomposition__2.html" title="A model of the PolygonWithHolesConvexDecomposition_2 concept is capable of decomposing an input polyg...">PolygonWithHolesConvexDecomposition_2</a></code>, which refines the concept <code><a class="el" href="classPolygonConvexDecomposition__2.html" title="A model of the PolygonConvexDecomposition_2 concept is capable of decomposing an input polygon  into ...">PolygonConvexDecomposition_2</a></code>. The same holds for \(Q \). The two concepts <code><a class="el" href="classPolygonConvexDecomposition__2.html" title="A model of the PolygonConvexDecomposition_2 concept is capable of decomposing an input polygon  into ...">PolygonConvexDecomposition_2</a></code> and <code><a class="el" href="classPolygonWithHolesConvexDecomposition__2.html" title="A model of the PolygonWithHolesConvexDecomposition_2 concept is capable of decomposing an input polyg...">PolygonWithHolesConvexDecomposition_2</a></code> refine a <code>Functor</code> concept variant. Namely, they both require the provision of a function operator (<code>operator()</code>). The function operator of the model of the concept <code><a class="el" href="classPolygonConvexDecomposition__2.html" title="A model of the PolygonConvexDecomposition_2 concept is capable of decomposing an input polygon  into ...">PolygonConvexDecomposition_2</a></code> accepts a planar simple polygon, while the function operator of the model of the concept <code><a class="el" href="classPolygonWithHolesConvexDecomposition__2.html" title="A model of the PolygonWithHolesConvexDecomposition_2 concept is capable of decomposing an input polyg...">PolygonWithHolesConvexDecomposition_2</a></code> accepts a planar polygon with holes. Both return a range of convex polygons that represents the convex decomposition of the input polygon. If the decomposition strategy that decomposes \(P \) is the same as the strategy that decomposes \(Q \), you can omit the forth argument, and issue the call <a class="el" href="group__PkgMinkowskiSum2.html#ga5ce6e837bdb4ea8973c8120c38301d7b"><code>minkowski_sum_2(P, Q, decomp)</code></a>, where <code>decomp</code> is an object that represents the common strategy. The class template <code><a class="el" href="classCGAL_1_1Polygon__nop__decomposition__2.html" title="The Polygon_nop_decomposition_2 class implements a convex decomposition of a polygon, which merely passes the input polygon to the list of output convex polygons. ">Polygon_nop_decomposition_2</a></code>, which models the concept <code><a class="el" href="classPolygonConvexDecomposition__2.html" title="A model of the PolygonConvexDecomposition_2 concept is capable of decomposing an input polygon  into ...">PolygonConvexDecomposition_2</a></code>, is a trivial convex decomposition strategy referred to as the <em>nop</em> strategy; it merely passes the input polygon to the next stage intact; use it in cases you know that the corresponding input polygon is convex to start with. If both \(P \) and \(Q \) are known to be convex, you can issue the call <a class="el" href="group__PkgMinkowskiSum2.html#ga5ce6e837bdb4ea8973c8120c38301d7b"><code>minkowski_sum_2(P, Q, nop)</code></a>, where <code>nop</code> is an object that represents the nop strategy.</p>
<p>The Minkowski-sum package includes four models of the concept <code><a class="el" href="classPolygonConvexDecomposition__2.html" title="A model of the PolygonConvexDecomposition_2 concept is capable of decomposing an input polygon  into ...">PolygonConvexDecomposition_2</a></code> (besides the trivial model <code><a class="el" href="classCGAL_1_1Polygon__nop__decomposition__2.html" title="The Polygon_nop_decomposition_2 class implements a convex decomposition of a polygon, which merely passes the input polygon to the list of output convex polygons. ">Polygon_nop_decomposition_2</a></code>) and two models of the refined concept <code><a class="el" href="classPolygonWithHolesConvexDecomposition__2.html" title="A model of the PolygonWithHolesConvexDecomposition_2 concept is capable of decomposing an input polyg...">PolygonWithHolesConvexDecomposition_2</a></code> as described below. The first three are class templates that wrap the corresponding decomposition functions included in the <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/index.html#Chapter_2D_Polygon">Planar Polygon Partitioning</a> package.</p>
<ul>
<li>
<p class="startli">The <code><a class="el" href="classCGAL_1_1Optimal__convex__decomposition__2.html" title="The Optimal_convex_decomposition_2 class provides an implementation of Greene's dynamic programming a...">Optimal_convex_decomposition_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template uses the dynamic-programming algorithm of Greene <a class="el" href="citelist.html#CITEREF_g-dpcp-83">[6]</a> for computing an optimal decomposition of a polygon into a minimal number of convex sub-polygons. While this algorithm results in a small number of convex polygons, it consumes rather many resources, as it runs in \( O(n^4) \) time and \( O(n^3) \) space in the worst case, where \( n \) is the number of vertices in the input polygon.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The <code><a class="el" href="classCGAL_1_1Hertel__Mehlhorn__convex__decomposition__2.html" title="The Hertel_Mehlhorn_convex_decomposition_2 class implements the approximation algorithm of Hertel and...">Hertel_Mehlhorn_convex_decomposition_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template implements the approximation algorithm suggested by Hertel and Mehlhorn <a class="el" href="citelist.html#CITEREF_hm-ftsp-83">[8]</a>, which triangulates the input polygon and then discards unnecessary triangulation edges. After triangulation (carried out by the constrained-triangulation procedure of <a class="el" href="namespaceCGAL.html">CGAL</a>) the algorithm runs in \( O(n) \) time and space, and guarantees that the number of sub-polygons it generates is not more than four times the optimum.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The <code><a class="el" href="classCGAL_1_1Greene__convex__decomposition__2.html" title="The Greene_convex_decomposition_2 class implements the approximation algorithm of Greene for the deco...">Greene_convex_decomposition_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template is an implementation of Greene's approximation algorithm <a class="el" href="citelist.html#CITEREF_g-dpcp-83">[6]</a>, which computes a convex decomposition of the polygon based on its partitioning into \( y\)-monotone polygons. This algorithm runs in \( O(n \log n)\) time and \( O(n)\) space, and has the same guarantee on the quality of approximation as Hertel and Mehlhorn's algorithm.</p>
<p class="endli"></p>
</li>
<li>
The <code><a class="el" href="classCGAL_1_1Small__side__angle__bisector__decomposition__2.html" title="The Small_side_angle_bisector_decomposition_2 class implements a simple yet efficient heuristic for d...">Small_side_angle_bisector_decomposition_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template is an implementation of a decomposition algorithm introduced in <a class="el" href="citelist.html#CITEREF_cgal:afh-pdecm-02">[1]</a>. It is based on the angle-bisector decomposition method suggested by Chazelle and Dobkin <a class="el" href="citelist.html#CITEREF_cd-ocd-85">[4]</a>, which runs in \( O(n^2)\) time. In addition, it applies a heuristic by Flato that reduces the number of output polygons in many common cases. The convex decompositions that it produces usually yield efficient running times for Minkowski sum computations. It starts by examining each pair of reflex vertices in the input polygon, such that the entire interior of the diagonal connecting these vertices is contained in the polygon. Out of all available pairs, the vertices \( p_i\) and \( p_j\) are selected, such that the number of reflex vertices encountered when traversing the boundary of the polygon from \( p_i\) to \( p_j\) in clockwise order is minimal. The polygon is split by the diagonal \( p_i p_j\). This process is repeated recursively on both resulting sub-polygons. In case it is not possible to eliminate two reflex vertices at once any more, each reflex vertex is eliminated by a diagonal that is closest to the angle bisector emanating from this vertex and having rational-coordinate endpoints on both sides. </li>
</ul>
<p>The following are two models of the refined concept <code><a class="el" href="classPolygonWithHolesConvexDecomposition__2.html" title="A model of the PolygonWithHolesConvexDecomposition_2 concept is capable of decomposing an input polyg...">PolygonWithHolesConvexDecomposition_2</a></code>. An instance of any one these two types can be used to decompose a polygon with holes. </p><ul>
<li>
<p class="startli">The <code><a class="el" href="classCGAL_1_1Polygon__vertical__decomposition__2.html" title="The Polygon_vertical_decomposition_2 class implements a convex decompistion of a polygon or a polygon...">Polygon_vertical_decomposition_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template uses vertical decomposition to decompose the underlying arrangement; see <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#chapterArrangement_on_surface_2">2D Arrangements</a> package.</p>
<p class="endli"></p>
</li>
<li>
The <code><a class="el" href="classCGAL_1_1Polygon__triangulation__decomposition__2.html" title="The Polygon_triangulation_decomposition_2 class implements a convex decomposition of a polygon or a p...">Polygon_triangulation_decomposition_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template uses constrained triangulation to decompose the input polygons, which may have holes, into triangles. </li>
</ul>
<p>The example below demonstrates the computation of the Minkowski sum of the same input polygons used in <a class="el" href="Minkowski_sum_2_2sum_with_holes_8cpp-example.html">Minkowski_sum_2/sum_with_holes.cpp</a> (depicted in Figure <a class="el" href="index.html#fig__mink_figsum_holes">Figure 21.4</a>), using the small-side angle-bisector decomposition strategy.</p>
<p><br />
<b>File</b> <a class="el" href="Minkowski_sum_2_2sum_by_decomposition_8cpp-example.html">Minkowski_sum_2/sum_by_decomposition.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Computing the Minkowski sum of two non-convex polygons read from a file</span></div><div class="line"><span class="comment">// using the small-side angle-bisector decomposition strategy.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/minkowski_sum_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Small_side_angle_bisector_decomposition_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "pgn_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                   Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Kernel&gt;</a>                           Polygon_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">CGAL::Polygon_with_holes_2&lt;Kernel&gt;</a>                Polygon_with_holes_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Open the input file and read two polygons from it.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"rooms_star.dat"</span>;</div><div class="line">  std::ifstream    in_file(filename);</div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open the input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line">  Polygon_2   P, Q;</div><div class="line">  in_file &gt;&gt; P &gt;&gt; Q;</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Compute the Minkowski sum using the decomposition approach.</span></div><div class="line">  <a class="code" href="classCGAL_1_1Small__side__angle__bisector__decomposition__2.html">CGAL::Small_side_angle_bisector_decomposition_2&lt;Kernel&gt;</a>  ssab_decomp;</div><div class="line">  Polygon_with_holes_2  sum = <a class="code" href="group__PkgMinkowskiSum2.html#ga5ce6e837bdb4ea8973c8120c38301d7b">CGAL::minkowski_sum_2</a>(P, Q, ssab_decomp);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"P (+) Q = "</span>; print_polygon_with_holes(sum);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="mink_ssec_optimal_decomp"></a>
Optimal Decomposition</h2>
<p>Decomposition methods that handle polygons with holes are typically more costly than decomposition methods that handle only simple polygons. The hole filtration (see <a class="el" href="index.html#mink_ssec_hole_filter">Filtering Out Holes</a>) is applied before the actual construction starts (be it convolution based or decomposition based). The filteration may result with a polygon that does not have holes, or even a convex polygon, but this is unkown at the time of the call. To this end, we introduce the overloaded function template <a class="el" href="group__PkgMinkowskiSum2.html#ga06670e5f096d0fcbf4da539b6148c55f"><code>minkowski_sum_by_decomposition_2(P, Q, no_holes_decomp, with_holes_decomp)</code></a>, where <code>no_holes_decomp</code> and <code>with_holes_decomp</code> are objects that model the concepts <code><a class="el" href="classPolygonConvexDecomposition__2.html" title="A model of the PolygonConvexDecomposition_2 concept is capable of decomposing an input polygon  into ...">PolygonConvexDecomposition_2</a></code> and <code><a class="el" href="classPolygonWithHolesConvexDecomposition__2.html" title="A model of the PolygonWithHolesConvexDecomposition_2 concept is capable of decomposing an input polyg...">PolygonWithHolesConvexDecomposition_2</a></code>, respectively. If after the application of the hole filtration \(P\) remains a polygon with holes, then the strategy represented by the object <code>with_holes_decomp</code> is applied to it. If, however, \(P\) turns into a polygon without holes, then the strategy represented by the object <code>no_holes_decomp</code> is applied to it, unless the result is a convex polygon, in which case the nop strategy is applied. If \(P\) is a polygon without holes to start with, then only convexity is checked. (Checking whether the result is convex inccurs a small overhead though.) The same holds for \(Q\).</p>
<h1><a class="anchor" id="mink_secoffset"></a>
Offsetting a Polygon</h1>
<p>The operation of computing the Minkowski sum \( P \oplus B_r\) of a polygon \( P\) with a disc \( b_r\) of radius \( r\) centered at the origin is widely known as <em>offsetting</em> the polygon \( P\) by a radius \( r\).</p>
<p><a class="anchor" id="fig__mink_figpgn_offset"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="ms_offset_convex.png" alt="ms_offset_convex.png" />
</div>
   </td><td><div class="image">
<img src="ms_offset_nonconvex.png" alt="ms_offset_nonconvex.png" />
</div>
   </td><td><div class="image">
<img src="ms_offset_convolution.png" alt="ms_offset_convolution.png" />
</div>
   </td></tr>
<tr align="center">
<td>(a)</td><td>(b)</td><td>(c) </td></tr>
</table>
</center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__mink_figpgn_offset">Figure 21.5</a> (a) The offset of a convex polygon. (b) The offset of a non-convex polygon as computed by decomposing it into two convex sub-polygons. (c) The offset of a non-convex polygon as computed using the convolution approach. The convolution cycle induces an arrangement with three faces, whose winding numbers are indicated.  </div>  <br />

<p>Let \( P \) be a simple polygon, and let \( p_0, \ldots, p_{n - 1} \) be the vertices of \( P \) oriented counterclockwise around the interior of \( P \). If \( P\) is a convex polygon the offset is easily computed by shifting each polygon edge by \( r\) away from the polygon, namely to the right side of the edge. As a result we obtain a collection of \( n\) disconnected <em>offset edges</em>. Each pair of adjacent offset edges, induced by \( p_{i-1} p_i\) and \( p_i p_{i+1}\), are connected by a circular arc of radius \( r\), whose supporting circle is centered at \( p_i\). The angle that defines such a circular arc equals \( 180^{\circ} - \angle (p_{i-1}, p_i, p_{i+1})\); see <a class="el" href="index.html#fig__mink_figpgn_offset">Figure 21.5</a> (a) for an illustration. The running time of this simple process is naturally linear with respect to the size of the polygon.</p>
<p>If \( P\) is not convex, its offset can be obtained by decomposing it into convex sub-polygons \( P_1, \ldots P_m\) such that \( \bigcup_{i=1}^{m}{P_i} = P\), computing the offset of each sub-polygon, and finally calculating the union of these offsets sub-polygons; see <a class="el" href="index.html#fig__mink_figpgn_offset">Figure 21.5</a> (b). However, as with the case of the Minkowski sum of a pair of polygons, it is also more efficient to compute the <em>convolution cycle</em> of the polygon and the disc \( B_r\),<span class="footnote">As the disc is convex, it is guaranteed that the convolution curve comprises a single cycle.</span> which can be constructed by applying the process described in the previous paragraph for convex polygons: The only difference is that a circular arc induced by a reflex vertex \( p_i\) is defined by an angle \( 180^{\circ} + \measuredangle p_{i-1} p_i p_{i+1}\); see <a class="el" href="index.html#fig__mink_figpgn_offset">Figure 21.5</a> (c) for an illustration. Recall that the last step consists of computing the winding numbers of the faces of the arrangement induced by the convolution cycle and discarding the faces with zero winding numbers.</p>
<h2><a class="anchor" id="mink_ssec_approx_offset"></a>
Approximating the Offset with a Guaranteed Error Bound</h2>
<p>Let \( P \) be a counterclockwise-oriented simple polygon all vertices of which \( p_0, \ldots, p_{n-1} \) have rational coordinates, i.e., for each vertex \( p_i = (x_i, y_i)\) we have \( x_i, y_i \in {\mathbb Q}\). Consider the Minkowski sum of \( P \) with a disc of radius \( r\), where \( r\) is also a rational number. The boundary of this sum is comprised line segments and circular arcs, where: </p><ul>
<li>
Each circular arc is supported by a circle of radius \( r\) centered at a polygon vertex \( p_i \). The equation of this circle, \( (x - x_i)^2 + (y - y_i)^2 = r^2\), has only rational coefficients. </li>
<li>
<p class="startli">Each line segment is supported by a line parallel to a polygon edge \( p_i p_{i+1}\) at distance \( r\) from this edge. Let \( A, B, C \in {\mathbb Q}\) denote the coefficients of the equation \( p_i p_{i+1}\) by \( Ax + By + C = 0 \) of the supporting line of \( p_i p_{i+1} \).</p>
<p class="endli">The locus of all points that lie at distance \(r \) from the line \( Ax + By + C = 0 \) is given by: </p><p class="formulaDsp">
\[ \frac{(Ax + By + C)^2}{A^2 + B^2} = r^2 \ .\]
</p>
<p> Thus, the linear offset edges are segments of an algebraic curve of degree \( 2 \) (a conic curve) with rational coefficients. This curve is actually a pair of the parallel lines \( Ax + By + (C \pm r \cdot \sqrt{A/B+1}) = 0 \). The offset edge is supported by the line \( Ax + By + C' = 0 \), where \( C' = C + r \cdot \sqrt{A/B+1} \) is in general <em>not</em> a rational number. Therefore, the line segments that compose the offset boundaries cannot be represented as segments of lines with rational coefficients. In Section <a class="el" href="index.html#mink_ssec_exact_offset">Computing the Exact Offset</a> we use the line-pair representation to construct the offset polygonin an exact manner using the traits class for conic arcs. </p>
</li>
</ul>
<p><a class="anchor" id="fig__mink_figapprox_offset"></a></p><div class="image">
<img src="ms_approx_offset.png" alt="ms_approx_offset.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__mink_figapprox_offset">Figure 21.6</a> Approximating the offset edge \( o_1 o_2\) induced by the polygon edge \( p_1 p_2\) by two line segments \( o'_1 q'\) and \( q' o'_2\).  </div>  <br />

<p>The class-template <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classCGAL_1_1Gps__circle__segment__traits__2.html">Gps_circle_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code>, included in the Boolean Set-Operations package, is used for representing generalized polygons the edges of which are circular arcs or line segments, and for applying Boolean set operations (e.g., intersection and union) on such generalized polygons. When it is instantiated, the template parameter '<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>' must be substituted with a geometric kernel that employs exact rational arithmetic. The curves that compose the polygon edges should are then arcs of circles with rational coefficients or segments of lines with rational coefficients. However, the line segments that result from the (exact) offsetting operation may be irrational. As we still wish to use the polygons defined by the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classCGAL_1_1Gps__circle__segment__traits__2.html">Gps_circle_segment_traits_2</a></code> class template to compute Boolean set operations more efficiently, we apply a simple approximation scheme such that each irrational line segment is approximated by two rational segments.</p>
<p>Consider the example depicted in Figure <a class="el" href="index.html#fig__mink_figapprox_offset">Figure 21.6</a>, where the exact offset edge \( o_1 o_2\) is obtained by shifting the polygon edge \( p_1 p_2\) by a vector of length \( r\) that forms an angle \( \phi\) with the \( x\)-axis. We select two points \( o'_1\) and \( o'_2\) with rational coordinates that lie on the two circles of radius \( r \) centered at \( p_1\) and \( p_2\), respectively. These points are selected such that \( \phi'_1 &lt; \phi &lt; \phi'_2 \), where \( \phi'_j, j = 1,2 \) is the angle that the vector \( \overrightarrow{p_j o_j} \) forms with the $x$-axis. Then, we construct two tangents to the two circles at \( o'_1\) and \( o'_2\), respectively. The tangent lines have rational coefficients. Finally, we compute the intersection point of the two tangents, denoted by \( q'\). The two line segments \( o'_1 q'\) and \( q' o'_2\) approximate the original offset edge \( o_1 o_2\).</p>
<p>The <a class="el" href="group__PkgMinkowskiSum2.html#gaa5e4e711f2d098e97e6358a669e194aa"><code>approximated_offset_2(P, r, epsilon)</code></a> function template accepts a polygon \( P\) that is either simple or degenerate (consisting of two points only), an offset radius \( r\), and (a floating-point number) \( \epsilon &gt; 0 \). It constructs an approximation of the offset of \( P\) by the radius \( r\) using the procedure described above. Furthermore, it is guaranteed that the approximation error, namely the distance of the point \( q'\) from \( o_1 o_2\), is bounded by \( \epsilon \). Using this function, it is possible to use the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classCGAL_1_1Gps__circle__segment__traits__2.html">Gps_circle_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template, which considerably speeds up the (approximate) construction of the offset polygon and the application of Boolean set operations on such polygons; see Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_ssectr_circ_seg">A Traits Class for Circular Arcs and Line Segments</a> for the exploitation of the efficient square root extension number type. The function returns an object of the nested type <code>Gps_circle_segment_traits_2::Polygon_with_holes_2</code> representing the approximated offset polygon. Recall that if \( P\) is not convex, its offset may not be simple and may contain holes, the boundaries of which are also formed by line segments and circular arcs.</p>
<p><a class="anchor" id="fig__mink_figex_offset"></a></p><div class="image">
<img src="ms_exact_offset.png" alt="ms_exact_offset.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__mink_figex_offset">Figure 21.7</a> The offset computation performed by the example programs <a class="el" href="Minkowski_sum_2_2approx_offset_8cpp-example.html">Minkowski_sum_2/approx_offset.cpp</a> and <a class="el" href="Minkowski_sum_2_2exact_offset_8cpp-example.html">Minkowski_sum_2/exact_offset.cpp</a>. The input polygon is shaded and the boundary of its offset is drawn in a thick black line.  </div>  <br />

<p>The example below demonstrates the construction of an approximated offset of a non-convex polygon, as depicted in Figure <a class="el" href="index.html#fig__mink_figex_offset">Figure 21.7</a>. The program uses types defined in the header file <code>bops_circular.h</code>, which defines the polygon types.</p>
<p><br />
<b>File</b> <a class="el" href="Minkowski_sum_2_2approx_offset_8cpp-example.html">Minkowski_sum_2/approx_offset.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Computing the approximated offset of a polygon.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/timer.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/approximated_offset_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "bops_circular.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Kernel&gt;</a>                         Linear_polygon;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Open the input file and read a polygon.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"spiked.dat"</span>;</div><div class="line">  std::ifstream in_file(filename);</div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open the input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line">  Linear_polygon  P;</div><div class="line">  in_file &gt;&gt; P;</div><div class="line">  in_file.close();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read an input polygon with "</span> &lt;&lt; P.size() &lt;&lt; <span class="stringliteral">" vertices."</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Approximate the offset polygon with radius 5 and error bound 0.00001.</span></div><div class="line">  boost::timer timer;</div><div class="line">  Polygon_with_holes_2 offset = <a class="code" href="group__PkgMinkowskiSum2.html#gaa5e4e711f2d098e97e6358a669e194aa">CGAL::approximated_offset_2</a>(P, 5, 0.00001);</div><div class="line">  <span class="keywordtype">double</span> secs = timer.elapsed();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The offset polygon has "</span> &lt;&lt; offset.outer_boundary().size()</div><div class="line">            &lt;&lt; <span class="stringliteral">" vertices, "</span> &lt;&lt; offset.number_of_holes() &lt;&lt; <span class="stringliteral">" holes."</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Offset computation took "</span> &lt;&lt; secs &lt;&lt; <span class="stringliteral">" seconds."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="mink_ssec_exact_offset"></a>
Computing the Exact Offset</h2>
<p>As mentioned in the previous section, it is possible to represent offset polygons in an exact manner if the edges of the polygons are represented as arcs of conic curves with rational coefficients. The <a class="el" href="group__PkgMinkowskiSum2.html#gabda2c65926cde6e2559c4203ae6b31c2"><code>offset_polygon_2(P, r, traits)</code></a> function template computes the offset of a given polygon \( P\) by a rational radius \( r\) in an exact manner. The input polygon \( P\) must be either simple or degenerate consisting of two vertices (representing a line segment). The <code>traits</code> argument must model the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classArrangementTraits__2.html">ArrangementTraits_2</a></code> and it should be capable of handling conic arcs in an exact mannerâ€”using an instance of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__conic__traits__2.html">Arr_conic_traits_2</a></code> class template with the number types provided by the <span class="textsc">Core</span> library is the preferred option; see <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_ssectr_conic">A Traits Class for Conic Arcs</a> for more details. The function template returns an object of the nested type <code>Gps_traits_2::Polygons_with_holes_2</code> (see <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/index.html#bso_ssecgeneral_polygon_concept">General Polygon Set Traits Adapter</a> for more details on the traits-class adaptor <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classCGAL_1_1Gps__traits__2.html">Gps_traits_2</a></code>), which represents the exact offset polygon.</p>
<p>The following example demonstrates the construction of the offset of the same polygon that serves as an input for the example program <a class="el" href="Minkowski_sum_2_2approx_offset_8cpp-example.html">Minkowski_sum_2/approx_offset.cpp</a>, presented in the previous subsection (see also <a class="el" href="index.html#fig__mink_figex_offset">Figure 21.7</a>). Note that the resulting polygon is smaller than the one generated by the approximated-offset function (recall that each irrational line segment in this case is approximated by two rational line segments), but the offset computation is considerably slower:</p>
<p><br />
<b>File</b> <a class="el" href="Minkowski_sum_2_2exact_offset_8cpp-example.html">Minkowski_sum_2/exact_offset.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Computing the exact offset of a polygon.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef CGAL_USE_CORE</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE ..."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/timer.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Gps_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/offset_polygon_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_conics.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Rat_kernel&gt;</a>             Polygon_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classCGAL_1_1Gps__traits__2.html">CGAL::Gps_traits_2&lt;Traits&gt;</a>              Gps_traits;</div><div class="line"><span class="keyword">typedef</span> Gps_traits::Polygon_with_holes_2        Offset_polygon_with_holes_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Open the input file and read the input polygon.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"spiked.dat"</span>;</div><div class="line">  std::ifstream in_file(filename);</div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open the input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line">  Polygon_2  P;</div><div class="line">  in_file &gt;&gt; P;</div><div class="line">  in_file.close();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read an input polygon with "</span> &lt;&lt; P.size() &lt;&lt; <span class="stringliteral">" vertices."</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Compute the offset polygon.</span></div><div class="line">  Traits traits;</div><div class="line">  boost::timer timer;</div><div class="line">  Offset_polygon_with_holes_2 offset = <a class="code" href="group__PkgMinkowskiSum2.html#gabda2c65926cde6e2559c4203ae6b31c2">CGAL::offset_polygon_2</a>(P, 5, traits);</div><div class="line">  <span class="keywordtype">double</span> secs = timer.elapsed();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The offset polygon has "</span> &lt;&lt; offset.outer_boundary().size()</div><div class="line">            &lt;&lt; <span class="stringliteral">" vertices, "</span> &lt;&lt; offset.number_of_holes() &lt;&lt; <span class="stringliteral">" holes."</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Offset computation took "</span> &lt;&lt; secs &lt;&lt; <span class="stringliteral">" seconds."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>Both functions templates <code><a class="el" href="group__PkgMinkowskiSum2.html#gaa5e4e711f2d098e97e6358a669e194aa" title="Provides a guaranteed approximation of the offset of the given polygon P by a given radius r - namely...">approximated_offset_2()</a></code> and <code><a class="el" href="group__PkgMinkowskiSum2.html#gabda2c65926cde6e2559c4203ae6b31c2" title="Computes the offset of the given polygon P by a given radius r - namely, the function computes the Mi...">offset_polygon_2()</a></code> also have overloaded versions that accept a decomposition strategy and use the polygon-decomposition approach to compute (or approximate) the offset. These functions are typically considerably slower than their counterparts that employ the convolution approach. However, similar to the functions that compute the general Minkowski sum, they are able to compute the offset of polygons with holes, given a decomposition strategy that handles polygons with holes, such as the <code><a class="el" href="classCGAL_1_1Polygon__vertical__decomposition__2.html" title="The Polygon_vertical_decomposition_2 class implements a convex decompistion of a polygon or a polygon...">Polygon_vertical_decomposition_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template.  </p></div> 
<h2><a class="anchor" id="mink_ssec_inner_offset"></a>
Computing Inner Offsets</h2>
<p>An operation closely related to the (outer) offset computation, is computing the <em>inner offset</em> of a polygon, or <em>insetting</em> it by a given radius. The inset of a polygon \( P\) with radius \( r\) is the set of points iside \( P\) the distance of which from the polygon boundary, denoted \( \partial P\), is at least \( r\), namely: \( \{ p \in P \;|\; {\rm dist}(p, \partial P) \geq r \}\). Note that the resulting point set may be dicconnected when \( P\) is a non-convex polygon that has some narrow components. In such a case the resulting set is characterized by a (possibly empty) set of polygons the edges of which are line segments and circular arcs of radius \( r\).</p>
<p>The inset can be computed using the convolution method traversing the polygon in a <em>clockwise</em> order (as oppose to the <em>counterclockwise</em> order applied in the case of ofsetting a polygon). As with the (outer) offset functions, the Minkowski-sum package contains two functions for insetting a simple polygon, namely, <code>approximated_inset_2(P, r, eps, oi)</code> and <code>inset_polygon_2(P, r, traits, oi)</code>.</p>
<p>The <a class="el" href="group__PkgMinkowskiSum2.html#ga80e273611a4e3568a0208d5fb1551669"><code>approximated_inset_2(P, r, eps, oi)</code></a> function template accepts a polygon \( P\), an inset radius \( r\), (a floating-point number) \( \epsilon &gt; 0 \), and an output iterator <code>oi</code>, whose value-type must be an instance of the class template <code>Gps_circle_segment_traits_2::Polygon_2</code>. . It constructs an approximation of the inset of \( P\) by the radius \( r\), where the approximation error is bounded by \( \epsilon\). The function returns the polygons that approximate the inset polygon through the output iterator <code>oi</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Minkowski_sum_2_2approx_inset_8cpp-example.html">Minkowski_sum_2/approx_inset.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Computing the approximated inset of a polygon.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/timer.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/approximated_offset_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "bops_circular.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Kernel&gt;</a>                         Linear_polygon;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Open the input file and read a polygon.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"tight.dat"</span>;</div><div class="line">  std::ifstream in_file(filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open the input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Read the input polygon.</span></div><div class="line">  Linear_polygon P;</div><div class="line">  in_file &gt;&gt; P;</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read an input polygon with "</span> &lt;&lt; P.size() &lt;&lt; <span class="stringliteral">" vertices."</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Approximate the offset polygon.</span></div><div class="line">  std::list&lt;Polygon_2&gt; inset_polygons;</div><div class="line">  boost::timer timer;</div><div class="line">  <a class="code" href="group__PkgMinkowskiSum2.html#ga80e273611a4e3568a0208d5fb1551669">approximated_inset_2</a>(P, 1, 0.00001, std::back_inserter(inset_polygons));</div><div class="line">  <span class="keywordtype">double</span> secs = timer.elapsed();</div><div class="line"></div><div class="line">  std::list&lt;Polygon_2&gt;::iterator it;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The inset comprises "</span> &lt;&lt; inset_polygons.size()</div><div class="line">            &lt;&lt; <span class="stringliteral">" polygon(s)."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (it = inset_polygons.begin(); it != inset_polygons.end(); ++it)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"    Polygon with "</span> &lt;&lt; it-&gt;size() &lt;&lt; <span class="stringliteral">" vertices."</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Inset computation took "</span> &lt;&lt; secs &lt;&lt; <span class="stringliteral">" seconds."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Similarly, the function template <a class="el" href="group__PkgMinkowskiSum2.html#ga6ab5808d9bc7ba5e958b8b5bcb9e9824"><code>inset_polygon_2(P, r, traits, oi)</code> </a> computes the exact inset of \( P\) with radius \( r\), and returns its output through the given output iterator <code>oi</code>. The <code>traits</code> parameter must model the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classArrangementTraits__2.html">ArrangementTraits_2</a></code> and it should be capable of handling conic arcs in an exact manner, whereas the value-type of <code>oi</code> must be an instance of <code>Gps_traits_2::Polygon_2</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Minkowski_sum_2_2exact_inset_8cpp-example.html">Minkowski_sum_2/exact_inset.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Computing the exact inner offset of a polygon.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef CGAL_USE_CORE</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE ..."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/timer.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Gps_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/offset_polygon_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_conics.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Rat_kernel&gt;</a>             Polygon_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classCGAL_1_1Gps__traits__2.html">CGAL::Gps_traits_2&lt;Traits&gt;</a>              Gps_traits;</div><div class="line"><span class="keyword">typedef</span> Gps_traits::Polygon_2                   Offset_polygon;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Open the input file and read the input polygon.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"tight.dat"</span>;</div><div class="line">  std::ifstream in_file(filename);</div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open the input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line">  Polygon_2 P;</div><div class="line">  in_file &gt;&gt; P;</div><div class="line">  in_file.close();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read an input polygon with "</span> &lt;&lt; P.size() &lt;&lt; <span class="stringliteral">" vertices."</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Compute the inner offset of the polygon.</span></div><div class="line">  Traits traits;</div><div class="line">  std::list&lt;Offset_polygon&gt; inset_polygons;</div><div class="line">  boost::timer timer;</div><div class="line">  <a class="code" href="group__PkgMinkowskiSum2.html#ga6ab5808d9bc7ba5e958b8b5bcb9e9824">inset_polygon_2</a>(P, 1, traits, std::back_inserter(inset_polygons));</div><div class="line">  <span class="keywordtype">double</span> secs = timer.elapsed();</div><div class="line"></div><div class="line">  std::list&lt;Offset_polygon&gt;::iterator it;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The inset comprises "</span></div><div class="line">            &lt;&lt; inset_polygons.size() &lt;&lt; <span class="stringliteral">" polygon(s)."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (it = inset_polygons.begin(); it != inset_polygons.end(); ++it)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"    Polygon with "</span> &lt;&lt; it-&gt;size() &lt;&lt; <span class="stringliteral">" vertices."</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Inset computation took "</span> &lt;&lt; secs &lt;&lt; <span class="stringliteral">" seconds."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Unlike the functions that compute the offsets, there are no overloaded versions of the functions that compute the insets and use convex polygon decomposition, as decomposition approach cannot be easily generalized for inset computations.</p>
<p>The package also provides overloaded versions of the functions <a class="el" href="group__PkgMinkowskiSum2.html#gaa5e4e711f2d098e97e6358a669e194aa"><code>approximated_offset_2(P, r, eps)</code></a> and <a class="el" href="group__PkgMinkowskiSum2.html#gabda2c65926cde6e2559c4203ae6b31c2"><code>offset_polygon_2(P, r, traits)</code></a> that accept a <em>polygon with holes</em> \( P\) and compute its offset. This ofset is obtain by computing the outer offset of the outer boundary of \( P\)'s, and computing the inner offsets of the holes of \( P\). The former polygon defines the output boundary of \( P \oplus B_r\), and the latter define the holes within the result.</p>
<h1><a class="anchor" id="Minkoski_sum_2Design"></a>
Design and Implementation History</h1>
<p>Eyal flato set the ground for the this package around the end of the previous millennium with his research work about Minkowski sum construction using the decomposition approach. However, it was only a few years later when Ron Wein developed the first version of this package, which was introduced with release 3.3. The first version of the package contained functionality for computeing the Minkowski sum of two polygons, computing the offset of a polygon by a disk, and approximating the offset of a polygon by a disk. Release 3.4 contained an enhancement of the offset computation, which allowed for polygon with holes as operands. Release 3.4 also featured new functionality for computing the inner offset of a polygon and approximating the inner offset. All this was also developed by Ron Wein. Release 3.7 contained an enhancement of the offset approximation for degenerate polygons such as line segments. This enhancement was developed by Efi Fogel, who also developed a new decomposition strategy, which can handle polygons with holes, essentially enabling the computation of Minkowski sum of two polygons with holes using the decomposition approach. The later was introduced with release 4.6. Ron Wein, Efi Fogel, Ophir Setter, Andreas Fabri, and Laurent Rineau helped maintaining the package applying bug fixes and other improvements. In particular, Andreas Fabri and Laurent Rineau helped tracing and solving several bugs in the approximated offset computation. They have also suggested a few algorithmic improvements that made their way into version 3.4, yielding a faster approximation scheme. During the <em>Google Summer of Code</em> 2014, Sebastian Morr, mentored by Michael Hemmer, implemented the reduced convolution approach, based on Alon Baram's master's thesis. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:56 for CGAL 4.13 - 2D Minkowski Sums by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
