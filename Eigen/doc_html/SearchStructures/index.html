<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/SearchStructures/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - dD Range and Segment Trees: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - dD Range and Segment Trees
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_dD_Range_and_Segment_Trees"></a><a class="anchor" id="Trees"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Gabriele Neyer</dd></dl>
<h1><a class="anchor" id="SearchStructuresIntroduction"></a>
Introduction</h1>
<p>This chapter presents the <span style="font-variant: small-caps;">CGAL</span> range tree and segment tree data structures.</p>
<h1><a class="anchor" id="SearchStructuresDefinitions"></a>
Definitions</h1>
<p>This section presents <code>d</code>-dimensional range and segment trees. A one-dimensional range tree is a binary search tree on <em>one-dimensional point data</em>. Here we call all one-dimensional data types having a strict ordering (like integer and double) <em>point data</em>. <em><code>d</code>-dimensional point data</em> are <code>d</code>-tuples of one-dimensional point data.</p>
<p>A one-dimensional segment tree is a binary search tree as well, but with <em>one-dimensional interval data</em> as input data. One-dimensional interval data is a pair (i.e., 2-tuple) <code>(a,b)</code>, where <code>a</code> and <code>b</code> are one-dimensional point data of the same type and <code>a&lt; b</code>. The pair <code>(a,b)</code> represents a half open interval <code>[a,b)</code>. Analogously, a <code>d</code>-dimensional interval is represented by a <code>d</code>-tuple of one-dimensional intervals.</p>
<p>The <em>input data type</em> for a <code>d</code>-dimensional tree is a container class consisting of a <code>d</code>-dimensional point data type, interval data type or a mixture of both, and optionally a <em>value type</em>, which can be used to store arbitrary data. E.g., the <code>d</code>-dimensional bounding box of a <code>d</code>-dimensional polygon may define the interval data of a <code>d</code>-dimensional segment tree and the polygon itself can be stored as its value. An <em>input data item</em> is an instance of an input data type.</p>
<p>The range and segment tree classes are fully generic in the sense that they can be used to define <em>multilayer trees</em>. A multilayer tree of dimension (number of layers) <code>d</code> is a simple tree in the <code>d</code>-th layer, whereas the <code>k</code>-th layer, <code>1 &lt;= k &lt;= d-1</code>, of the tree defines a tree where each (inner) vertex contains a multilayer tree of dimension <code>d-k+1</code>. The <code>k-1</code>-dimensional tree which is nested in the <code>k</code>-dimensional tree (<code>T</code>) is called the <em>sublayer tree</em> (of <code>T</code>). For example, a <code>d</code>-dim tree can be a range tree on the first layer, constructed with respect to the first dimension of <code>d</code>-dimensional data items. On all the data items in each subtree, a <code>(d-1)</code>-dimensional tree is built, either a range or a segment tree, with respect to the second dimension of the data items. And so on.</p>
<p>The figures in Sections <a class="el" href="index.html#secrange_trees">Range Trees</a> and <a class="el" href="index.html#secsegment_trees">Segment Trees</a> illustrate the means of a sublayer tree graphically.</p>
<p>After creation of the tree, further insertions or deletions of data items are disallowed. The tree class does neither depend on the type of data nor on the concrete physical representation of the data items. E.g., let a multilayer tree be a segment tree for which each vertex defines a range tree. We can choose the data items to consist of intervals of type <code>double</code> and the point data of type <code>integer</code>. As value type we can choose <code>string</code>.</p>
<p>For this generality we have to define what the tree of each dimension looks like and how the input data is organized. For dimension <code>k</code>, <code>1 &lt; k &lt; 4</code>, <span style="font-variant: small-caps;">CGAL</span> provides ready-to-use range and segment trees that can store k-dimensional keys (intervals resp.). Examples illustrating the use of these classes are given in Sections <a class="el" href="index.html#secrange_tree_ex">Example for Range Tree on Map-like Data</a> and <a class="el" href="index.html#secsegment_tree_ex">Example for Segment Tree on Map-like Data</a>. The description of the functionality of these classes as well as the definition of higher dimensional trees and mixed multilayer trees is given in the reference manual.</p>
<p>In the following two sections we give short definitions of the version of the range tree and segment tree implemented here together with some examples. The presentation closely follows <a class="el" href="citelist.html#CITEREF_bkos-cgaa-97">[1]</a>.</p>
<h1><a class="anchor" id="SearchStructuresSoftware"></a>
Software Design</h1>
<p>In order to be able to define a multilayer tree we first designed the range and segment tree to have a template argument defining the type of the sublayer tree. With this sublayer tree type information the sublayers could be created. This approach lead to nested template arguments, since the sublayer tree can again have a template argument defining the sublayer. Therefore, the internal class and function identifiers got longer than a compiler-dependent limit. This happend already for <code>d=2</code>.</p>
<p>Therefore, we chose another, object oriented, design. We defined a pure virtual base class called <code>Tree_base</code> from which we derived the classes <code><a class="el" href="classCGAL_1_1Range__tree__d.html" title="A -dimensional range tree stores points and can be used to determine all points that lie inside a giv...">Range_tree_d</a></code> and <code><a class="el" href="classCGAL_1_1Segment__tree__d.html" title="A -dimensional segment tree stores -dimensional intervals and can be used to find all intervals that ...">Segment_tree_d</a></code>. The constructor of these classes expects an argument called <code>sublayer_prototype</code> of type <code>Tree_base</code>. Since class <code><a class="el" href="classCGAL_1_1Range__tree__d.html" title="A -dimensional range tree stores points and can be used to determine all points that lie inside a giv...">Range_tree_d</a></code> and class <code><a class="el" href="classCGAL_1_1Segment__tree__d.html" title="A -dimensional segment tree stores -dimensional intervals and can be used to find all intervals that ...">Segment_tree_d</a></code> are derived from class <code>Tree_base</code>, one can use an instantiation of class <code><a class="el" href="classCGAL_1_1Range__tree__d.html" title="A -dimensional range tree stores points and can be used to determine all points that lie inside a giv...">Range_tree_d</a></code> or class <code><a class="el" href="classCGAL_1_1Segment__tree__d.html" title="A -dimensional segment tree stores -dimensional intervals and can be used to find all intervals that ...">Segment_tree_d</a></code> as constructor argument. This argument defines the sublayer tree of the tree. E.g., you can construct a <code><a class="el" href="classCGAL_1_1Range__tree__d.html" title="A -dimensional range tree stores points and can be used to determine all points that lie inside a giv...">Range_tree_d</a></code> with an instantiation of class <code><a class="el" href="classCGAL_1_1Segment__tree__d.html" title="A -dimensional segment tree stores -dimensional intervals and can be used to find all intervals that ...">Segment_tree_d</a></code> as constructor argument. You then have defined a range tree with a segment tree as sublayer tree. Since both classes <code><a class="el" href="classCGAL_1_1Range__tree__d.html" title="A -dimensional range tree stores points and can be used to determine all points that lie inside a giv...">Range_tree_d</a></code> and <code><a class="el" href="classCGAL_1_1Segment__tree__d.html" title="A -dimensional segment tree stores -dimensional intervals and can be used to find all intervals that ...">Segment_tree_d</a></code> expect a sublayer tree in their constructor we had to derive a third class called <code><a class="el" href="classCGAL_1_1Tree__anchor.html" title="Tree_anchor is also derived from Tree_base. ">Tree_anchor</a></code> from class <code>Tree_base</code> which does not expect a constructor argument. An instantiation of this class is used as constructor argument of class <code><a class="el" href="classCGAL_1_1Range__tree__d.html" title="A -dimensional range tree stores points and can be used to determine all points that lie inside a giv...">Range_tree_d</a></code> or <code><a class="el" href="classCGAL_1_1Segment__tree__d.html" title="A -dimensional segment tree stores -dimensional intervals and can be used to find all intervals that ...">Segment_tree_d</a></code> in order to stop the recursion.</p>
<p>All classes provide a <code>clone()</code> function which returns an instance (a copy) of the same tree type. The <code>clone()</code> function of the <code>sublayer_prototype</code> is called in the construction of the tree. In case that the sublayer tree again has a sublayer, it also has a <code>sublayer_prototype</code> which is also cloned and so on. Thus, a call to the <code>clone()</code> function generates a sublayer tree which has the complete knowledge about its sublayer tree.</p>
<p>The trees allow to perform window queries, enclosing queries, and inverse range queries on the keys. Clearly, an inverse range query makes only sense in the segment tree. In order to perform an inverse range query, a range query of \( \epsilon\) width has to be performed. We prefered not to offer an extra function for this sort of query, since the inverse range query is a special case of the range query. Furthermore, offering an inverse range query in the segment tree class implies offering this function also in the range tree class and having an extra item in the traits class that accesses the inverse range query point.</p>
<p>The trees are templatized with three arguments: <code>Data, Window</code> and <code>Traits</code>. Type <code>Data</code> defines the input data type and type <code>Window</code> defines the query window type. The tree uses a well defined set of functions in order to access data. These functions have to be provided by class <code>Traits</code>.</p>
<p>The design partly follows the <em>prototype design pattern</em> in <a class="el" href="citelist.html#CITEREF_cgal:ghjv-dpero-95">[2]</a>. In comparison to our first approach using templates we want to note the following: In this approach the sublayer type is defined in use of object oriented programming at run time, while in the approach using templates, the sublayer type is defined at compile time.</p>
<p>The runtime overhead caused in use of virtual member functions in this object oriented design is negligible since all virtual functions are non trivial.</p>
<p>The design concept is illustrated in the figure below.</p>
<p><a class="anchor" id="fig__Search_rsd"></a></p><div class="image">
<img src="rsd.png" alt="rsd.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Search_rsd">Figure 79.1</a> Design of the range and segment tree data structure. The symbol triangle means that the lower class is derived from the upper class.  </div>  <br />

<p>E.g. in order to define a two dimensional multilayer tree, which consists of a range tree in the first dimension and a segment tree in the second dimension we proceed as follows: We construct an object of type <code><a class="el" href="classCGAL_1_1Tree__anchor.html" title="Tree_anchor is also derived from Tree_base. ">Tree_anchor</a></code> which stops the recursion. Then we construct an object of type <code><a class="el" href="classCGAL_1_1Segment__tree__d.html" title="A -dimensional segment tree stores -dimensional intervals and can be used to find all intervals that ...">Segment_tree_d</a></code>, which gets as prototype argument our object of type <code><a class="el" href="classCGAL_1_1Tree__anchor.html" title="Tree_anchor is also derived from Tree_base. ">Tree_anchor</a></code>. After that, we define an object of type <code><a class="el" href="classCGAL_1_1Range__tree__d.html" title="A -dimensional range tree stores points and can be used to determine all points that lie inside a giv...">Range_tree_d</a></code> which is constructed with the object of type <code><a class="el" href="classCGAL_1_1Segment__tree__d.html" title="A -dimensional segment tree stores -dimensional intervals and can be used to find all intervals that ...">Segment_tree_d</a></code> as prototype argument. The following piece of code illustrates the construction of the two-dimensional multilayer tree.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">  Tree_Anchor *anchor=<span class="keyword">new</span> Tree_Anchor;</div><div class="line">  Segment_Tree_d *segment_tree = <span class="keyword">new</span> Segment_Tree_d(*anchor);</div><div class="line">  Range_Tree_d *range_segment_tree = <span class="keyword">new</span> Range_Tree_d(*segment_tree);</div><div class="line">  <span class="comment">// let data_items be a list of Data items</span></div><div class="line">  range_segment_tree-&gt;make_tree(data_items.begin(),data_items.end());</div><div class="line">}</div></div><!-- fragment --><p>Here, class <code>Tree_Anchor, Segment_Tree_d</code>, and<code>Range_Tree_d</code> are defined by <code>typedef</code>s:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> Tree_anchor&lt;Data,Window&gt; Tree_Anchor;</div><div class="line"><span class="keyword">typedef</span> Segment_tree_d&lt;Data,Window,Interval_traits&gt; Segment_Tree_d;</div><div class="line"><span class="keyword">typedef</span> Range_tree_d&lt;Data,Window,Point_traits&gt; Range_Tree_d;</div></div><!-- fragment --><p>Class <code>Tree_base</code> and class <code><a class="el" href="classCGAL_1_1Tree__anchor.html" title="Tree_anchor is also derived from Tree_base. ">Tree_anchor</a></code> get two template arguments: a class <code>Data</code> which defines the type of data that is stored in the tree, and a class <code>Window</code> which defines the type of a query range. The derived classes <code><a class="el" href="classCGAL_1_1Range__tree__d.html" title="A -dimensional range tree stores points and can be used to determine all points that lie inside a giv...">Range_tree_d</a></code> and <code><a class="el" href="classCGAL_1_1Segment__tree__d.html" title="A -dimensional segment tree stores -dimensional intervals and can be used to find all intervals that ...">Segment_tree_d</a></code> additionally get an argument called <code>Tree_traits</code> which defines the interface between the <code>Data</code> and the tree. Let the <code>Data</code> type be a <code>d</code>-dimensional tuple, which is either a point data or an interval data in each dimension. Then, the class <code>Tree_traits</code> provides accessors to the point (resp. interval) data of that tree layer and a compare function. Remind our example of the two-dimensional tree which is a range tree in the first dimension and a segment tree in the second dimension. Then, the <code>Tree_traits</code> class template argument of class <code><a class="el" href="classCGAL_1_1Segment__tree__d.html" title="A -dimensional segment tree stores -dimensional intervals and can be used to find all intervals that ...">Segment_tree_d</a></code> defines an accessor to the interval data of the <code>Data</code>, and the <code>Tree_traits</code> class template argument of class <code><a class="el" href="classCGAL_1_1Range__tree__d.html" title="A -dimensional range tree stores points and can be used to determine all points that lie inside a giv...">Range_tree_d</a></code> defines an accessor to the point data of <code>Data</code>. An example implementation for these classes is listed below.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Data{</div><div class="line">  <span class="keywordtype">int</span> min,max; <span class="comment">// interval data</span></div><div class="line">  <span class="keywordtype">double</span> point; <span class="comment">// point data</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Window{</div><div class="line">  <span class="keywordtype">int</span> min,max;</div><div class="line">  <span class="keywordtype">double</span> min_point, max_point;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Point_traits{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span> Key;</div><div class="line">  Key get_key(Data&amp; d){<span class="keywordflow">return</span> d.point;} <span class="comment">// key accesso</span></div><div class="line">  Key get_left(Window&amp; w){<span class="keywordflow">return</span> w.min_point;}</div><div class="line">  Key get_right(Window&amp; w){<span class="keywordflow">return</span> w.max_point;}</div><div class="line">  <span class="keywordtype">bool</span> comp(Key&amp; key1, Key&amp; key2){<span class="keywordflow">return</span> (key1 &lt; key2);} </div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Interval_traits{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">int</span> Key;</div><div class="line">  Key get_left(Data&amp; d){<span class="keywordflow">return</span> d.min;}</div><div class="line">  Key get_right(Data&amp; d){<span class="keywordflow">return</span> d.max;}</div><div class="line">  Key get_left_win(Window&amp; w){<span class="keywordflow">return</span> w.min;}</div><div class="line">  Key get_right_win(Window&amp; w){<span class="keywordflow">return</span> w.max;}</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span> comp(Key&amp; key1, Key&amp; key2){<span class="keywordflow">return</span> (key1 &lt; key2);} </div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="general"></a>
Creating an Arbitrary Multilayer Tree</h1>
<p>Now let us have a closer look on how a multilayer tree is built. In case of creating a <code>d</code>-dimensional tree, we handle a sequence of arbitrary data items, where each item defines a <code>d</code>-dimensional interval, point or other object. The tree is constructed with an iterator over this structure. In the <code>i</code>-th layer, the tree is built with respect to the data slot that defines the <code>i</code>-th dimension. Therefore, we need to define which data slot corresponds to which dimension. In addition we want our tree to work with arbitrary data items. This requires an adaptor between the algorithm and the data item. This is resolved by the use of traits classes, implemented in form of a traits class using function objects. These classes provide access functions to a specified data slot of a data item. A <code>d</code>-dimensional tree is then defined separately for each layer by defining a traits class for each layer.</p>
<h1><a class="anchor" id="secrange_trees"></a>
Range Trees</h1>
<p>A one-dimensional range tree is a binary search tree on one-dimensional point data. The point data of the tree is stored in the leaves. Each inner vertex stores the highest entry of its left subtree. The version of a range tree implemented here is static, which means that after construction of the tree, no elements be inserted or deleted. A <code>d</code>-dimensional range tree is a binary leaf search tree according to the first dimension of the <code>d</code>-dimensional point data, where each vertex contains a <code>(d-1)</code>-dimensional search tree of the points in the subtree (sublayer tree) with respect to the second dimension. See <a class="el" href="citelist.html#CITEREF_bkos-cgaa-97">[1]</a> and <a class="el" href="citelist.html#CITEREF_s-dasds-90">[3]</a> for more detailed information.</p>
<p>A <code>d</code>-dimensional range tree can be used to determine all <code>d</code>-dimensional points that lie inside a given <code>d</code>-dimensional interval (<code>window_query</code>).</p>
<p>The pictures below show a two-dimensional and a <code>d</code>-dimensional range tree.</p>
<p><a class="anchor" id="fig__Search_range2"></a></p><div class="image">
<img src="range2.png" alt="range2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Search_range2">Figure 79.2</a> A two and a d-dimensional range tree.  </div>  <br />

<p>The 2-dimensional tree is a binary search tree on the first dimension. Each sublayer tree of a vertex <code>v</code> is a binary search tree on the second dimension. The data items in a sublayer tree of <code>v</code> are all data items of the subtree of <code>v</code>.</p>
<p>For the d-dimensional range tree, the figure shows one sublayer tree for each layer of the tree.</p>
<p>The tree can be built in \( O(n\log^{d-1} n)\) time and needs \( O(n\log^{d-1} n)\) space. The <code>d</code>-dimensional points that lie in the <code>d</code>-dimensional query interval can be reported in \( O(\log^dn+k)\) time, where <code>n</code> is the total number of points and <code>k</code> is the number of reported points.</p>
<h2><a class="anchor" id="secrange_tree_ex"></a>
Example for Range Tree on Map-like Data</h2>
<p>The following example program uses the predefined <code>Range_tree_2</code> data structure together with the predefined traits class <code>Range_tree_map_traits_2</code> which has two template arguments specifying the type of the point data in each dimension (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a>&lt;double&gt;</code>) and the value type of the 2-dimensional point data (<code>char</code>). Therefore the <code>Range_tree_2</code> is defined on 2-dimensional point data each of which is associated with a character. Then, a few data items are created and put into a list. After that the tree is constructed according to that list, a window query is performed, and the query elements are given out.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Range_segment_tree_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Range_tree_k.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> CGAL::Range_tree_map_traits_2&lt;K, char&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::Range_tree_2&lt;Traits&gt; Range_tree_2_type;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Traits::Key Key; </div><div class="line">  <span class="keyword">typedef</span> Traits::Interval Interval; </div><div class="line"></div><div class="line">  std::vector&lt;Key&gt; InputList, OutputList;</div><div class="line">  InputList.push_back(Key(K::Point_2(8,5.1), <span class="charliteral">'a'</span>));</div><div class="line">  InputList.push_back(Key(K::Point_2(1,1.1), <span class="charliteral">'b'</span>));</div><div class="line">  InputList.push_back(Key(K::Point_2(3,2.1), <span class="charliteral">'c'</span>));</div><div class="line">  </div><div class="line">  Range_tree_2_type Range_tree_2(InputList.begin(),InputList.end());</div><div class="line">  Interval win(Interval(K::Point_2(4,8.1),K::Point_2(5,8.2)));</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\n Window Query:\n "</span>;</div><div class="line">  Range_tree_2.window_query(win, std::back_inserter(OutputList));</div><div class="line">  std::vector&lt;Key&gt;::iterator current=OutputList.begin();</div><div class="line">  <span class="keywordflow">while</span>(current!=OutputList.end()){</div><div class="line">    std::cout &lt;&lt; (*current).first.x() &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; (*current).first.y()</div><div class="line">              &lt;&lt; <span class="stringliteral">":"</span> &lt;&lt; (*current++).second &lt;&lt; std::endl;</div><div class="line">}</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="SearchStructuresExampleforRangeTreeonSetlike"></a>
Example for Range Tree on Set-like Data</h2>
<p>This example illustrates the use of the range tree on 2-dimensional point data (no value is associated to a data item). After the definition of the tree, some input data items are created and the tree is constructed according to the input data items. After that, a window query is performed and the query elements are given to standard out.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Range_segment_tree_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Range_tree_k.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> CGAL::Range_segment_tree_set_traits_2&lt;K&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::Range_tree_2&lt;Traits&gt; Range_tree_2_type;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Traits::Key Key;</div><div class="line">  <span class="keyword">typedef</span> Traits::Interval Interval;</div><div class="line">  std::vector&lt;Key&gt; InputList, OutputList;</div><div class="line">  std::vector&lt;Key&gt;::iterator first, last, current;</div><div class="line">  </div><div class="line">  InputList.push_back(Key(8,5.1));</div><div class="line">  InputList.push_back(Key(1,1.1));</div><div class="line">  InputList.push_back(Key(3,2.1));</div><div class="line">  </div><div class="line">  Range_tree_2_type Range_tree_2(InputList.begin(),InputList.end());</div><div class="line">  </div><div class="line">  Interval win=Interval(Key(4,8.1),Key(5,8.2));</div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"Window Query: lower left point: (4.0,5.0),"</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"upper right point: (8.1,8.2)"</span> &lt;&lt; std::endl;</div><div class="line">  Range_tree_2.window_query(win, std::back_inserter(OutputList));</div><div class="line">  current=OutputList.begin();</div><div class="line">  <span class="keywordflow">while</span>(current!=OutputList.end()){</div><div class="line">    std::cout &lt;&lt; (*current).x()&lt;&lt; <span class="stringliteral">"-"</span> &lt;&lt; (*current).y() &lt;&lt; std::endl;</div><div class="line">    current++;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="secsegment_trees"></a>
Segment Trees</h1>
<p>A segment tree is a static binary search tree for a given set of coordinates. The set of coordinates is defined by the endpoints of the input data intervals. Any two adjacent coordinates build an elementary interval. Every leaf corresponds to an elementary interval. Inner vertices correspond to the union of the subtree intervals of the vertex. Each vertex or leaf <code>v</code> contains a sublayer type (or a list, if it is one-dimensional) that will contain all intervals <code>I</code>, such that <code>I</code> contains the interval of vertex <code>v</code> but not the interval of the parent vertex of <code>v</code>.</p>
<p>A <code>d</code>-dimensional segment tree can be used to solve the following problems: </p><ul>
<li>
Determine all <code>d</code>-dimensional intervals that contain a <code>d</code>-dimensional point. This query type is called <em>inverse range query</em>. </li>
<li>
Determine all <code>d</code>-dimensional intervals that enclose a given <code>d</code>-dimensional interval (<em>enclosing query</em>). </li>
<li>
Determine all <code>d</code>-dimensional intervals that partially overlap or are contained in a given <code>d</code>-dimensional interval (<em>window query</em>). </li>
</ul>
<p>An example of a one-dimensional segment tree and an example of a two-dimensional segment tree are shown below.</p>
<p><a class="anchor" id="fig__Search_segment2"></a></p><div class="image">
<img src="segment2.png" alt="segment2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Search_segment2">Figure 79.3</a> A one and a two dimensional segment tree  </div>  <br />

<p>For the one-dimensional segment tree the segments and the corresponding elementary intervals are shown below the tree. The arcs from the nodes point to their subsets.</p>
<p>For the two-dimensional segment tree we see that the first layer of the tree is built according to the elementary intervals of the first dimension. Each sublayer tree of a vertex <code>v</code> is a segment tree according to the second dimension of all data items of <code>v</code>.</p>
<p>The tree can be built in \( O(n\log^{d} n)\) time and needs \( O(n\log^{d} n)\) space. The processing time for inverse range queries in an <code>d</code>-dimensional segment tree is \( O(\log^d n +k)\) time, where <code>n</code> is the total number of intervals and <code>k</code> is the number of reported intervals.</p>
<p>One possible application of a two-dimensional segment tree is the following. Given a set of convex polygons in two-dimensional space (Polygon_2), we want to determine all polygons that intersect a given rectangular query window. Therefore, we define a two-dimensional segment tree, where the two-dimensional interval of a data item corresponds to the bounding box of a polygon and the value type corresponds to the polygon itself. The segment tree is created with a sequence of all data items, and a window query is performed. The polygons of the resulting data items are finally tested independently for intersections.</p>
<h2><a class="anchor" id="secsegment_tree_ex"></a>
Example for Segment Tree on Map-like Data</h2>
<p>The following example program uses the predefined <code>Segment_tree_2</code> data structure together with the predefined traits class <code>Segment_tree_map_traits_2</code> which has two template arguments specifying the type of the point data in each dimension (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a>&lt;double&gt;</code>) and the value type of the 2-dimensional point data (<code>char</code>). Therefore the <code>Segment_tree_2</code> is defined on 2-dimensional point data (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a>&lt;double&gt; &gt;</code>) each of which is associated with a character. Then, a few data items are created and put into a list. After that the tree is constructed according to that list, a window query is performed, and the query elements are given out.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_tree_k.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Range_segment_tree_traits.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> CGAL::Segment_tree_map_traits_2&lt;K, char&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::Segment_tree_2&lt;Traits &gt; Segment_tree_2_type;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Traits::Interval Interval;</div><div class="line">  <span class="keyword">typedef</span> Traits::Pure_interval Pure_interval;</div><div class="line">  <span class="keyword">typedef</span> Traits::Key Key;</div><div class="line">  std::list&lt;Interval&gt; InputList, OutputList1, OutputList2;</div><div class="line">  </div><div class="line">  InputList.push_back(Interval(Pure_interval(Key(1,5), Key(2,7)),<span class="charliteral">'a'</span>));</div><div class="line">  InputList.push_back(Interval(Pure_interval(Key(2,7), Key(3,8)),<span class="charliteral">'b'</span>));</div><div class="line">  InputList.push_back(Interval(Pure_interval(Key(6,9), Key(9,13)),<span class="charliteral">'c'</span>));</div><div class="line">  InputList.push_back(Interval(Pure_interval(Key(1,3), Key(3,9)),<span class="charliteral">'d'</span>));</div><div class="line">  </div><div class="line">  Segment_tree_2_type Segment_tree_2(InputList.begin(),InputList.end());</div><div class="line">  </div><div class="line">  Interval a=Interval(Pure_interval(Key(3,6), Key(7,12)),<span class="charliteral">'e'</span>);</div><div class="line">  Segment_tree_2.window_query(a,std::back_inserter(OutputList1));</div><div class="line">  </div><div class="line">  std::list&lt;Interval&gt;::iterator j = OutputList1.begin();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\n window_query (3,6),(7,12)\n"</span>;</div><div class="line">  <span class="keywordflow">while</span>(j!=OutputList1.end()){</div><div class="line">    std::cout &lt;&lt; (*j).first.first.x() &lt;&lt; <span class="stringliteral">"-"</span> &lt;&lt; (*j).first.second.x() &lt;&lt; <span class="stringliteral">" "</span> </div><div class="line">              &lt;&lt; (*j).first.first.y() &lt;&lt; <span class="stringliteral">"-"</span> &lt;&lt; (*j).first.second.y() &lt;&lt; std::endl; </div><div class="line">    j++;</div><div class="line">  }</div><div class="line">  </div><div class="line">  Interval b=Interval(Pure_interval(Key(6,10),Key(7,11)), <span class="charliteral">'f'</span>);</div><div class="line">  Segment_tree_2.enclosing_query(b,std::back_inserter(OutputList2));</div><div class="line">  j = OutputList2.begin();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\n enclosing_query (6,10),(7,11)\n"</span>;</div><div class="line">  <span class="keywordflow">while</span>(j!=OutputList2.end()){</div><div class="line">    std::cout &lt;&lt; (*j).first.first.x() &lt;&lt; <span class="stringliteral">"-"</span> &lt;&lt; (*j).first.second.x() &lt;&lt; <span class="stringliteral">" "</span> </div><div class="line">              &lt;&lt; (*j).first.first.y() &lt;&lt; <span class="stringliteral">"-"</span> &lt;&lt; (*j).first.second.y() &lt;&lt; std::endl; </div><div class="line">    j++;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0; </div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="SearchStructuresExampleforSegmentTreeonSetlike"></a>
Example for Segment Tree on Set-like Data</h2>
<p>This example illustrates the use of the predefined segment tree on 3-dimensional interval data (with no value associated). After the definition of the traits type and tree type, some intervals are constructed and the tree is build according to the intervals. Then, a window query is performed and the query elements are given out.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Segment_tree_k.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Range_segment_tree_traits.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;int&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> CGAL::Range_segment_tree_set_traits_3&lt;K&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::Segment_tree_3&lt;Traits &gt; Segment_tree_3_type;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Traits::Interval Interval;</div><div class="line">  <span class="keyword">typedef</span> Traits::Key Key;</div><div class="line">  std::list&lt;Interval&gt; InputList, OutputList;</div><div class="line">  </div><div class="line">  InputList.push_back(Interval(Key(1,5,7), Key(2,7,9)));</div><div class="line">  InputList.push_back(Interval(Key(2,7,6), Key(3,8,9)));</div><div class="line">  InputList.push_back(Interval(Key(6,9,5), Key(9,13,8)));</div><div class="line">  InputList.push_back(Interval(Key(1,3,4), Key(3,9,8)));</div><div class="line">  </div><div class="line">  Segment_tree_3_type Segment_tree_3(InputList.begin(),InputList.end());</div><div class="line">  </div><div class="line">  Interval a(Key(3,6,5), Key(7,12,8));</div><div class="line">  Segment_tree_3.window_query(a,std::back_inserter(OutputList));</div><div class="line">  std::list&lt;Interval&gt;::iterator j = OutputList1.begin();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\n window_query (3,6,5),(7,12,8) \n"</span>;</div><div class="line">  <span class="keywordflow">while</span>(j!=OutputList.end()){</div><div class="line">    std::cout &lt;&lt; (*j).first.x() &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; (*j).first.y() &lt;&lt; <span class="stringliteral">","</span>;</div><div class="line">    std::cout &lt;&lt; (*j).first.z() &lt;&lt;<span class="stringliteral">", "</span> &lt;&lt; (*j).second.x() &lt;&lt; <span class="stringliteral">","</span>;</div><div class="line">    std::cout &lt;&lt; (*j).second.y() &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; (*j).second.z() &lt;&lt; std::endl; </div><div class="line">    j++;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:05 for CGAL 4.13 - dD Range and Segment Trees by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
