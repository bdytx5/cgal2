<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_Profiling_Tools_Hash_Map_Union-find_Modifiers"/> <anchor id="index_1chapMiscellany"/> <simplesect kind="authors"><para>Lutz Kettner, Sylvain Pion, and Michael Seel</para></simplesect>
</para><sect1 id="index_1MiscellanyTimers">
<title>Timers</title>
<para>CGAL provides classes for measuring the user process time and the real time. The class <computeroutput><ref refid="classCGAL_1_1Timer" kindref="compound">Timer</ref></computeroutput> is the version for the user process time and the class <computeroutput><ref refid="classCGAL_1_1Real__timer" kindref="compound">Real_timer</ref></computeroutput> is the version for the real time.</para><para>Instantiations of both classes are objects with a state. The state is either <emphasis>running</emphasis> or it is <emphasis>stopped</emphasis>. The state of an object <computeroutput>t</computeroutput> is controlled with <computeroutput>t.start()</computeroutput> and <computeroutput>t.stop()</computeroutput>. The timer counts the time elapsed since its creation or last reset. It counts only the time where it is in the running state. The time information is given in seconds. The timer counts also the number of intervals it was running, i.e. it counts the number of calls of the <computeroutput>start()</computeroutput> member function since the last reset. If the reset occurs while the timer is running it counts as the first interval.</para></sect1>
<sect1 id="index_1MiscellanyMemory">
<title>Memory Size</title>
<para>CGAL provides access to the memory size used by the program with the <computeroutput><ref refid="structCGAL_1_1Memory__sizer" kindref="compound">Memory_sizer</ref></computeroutput> class. Both the virtual memory size and the resident size are available (the resident size does not account for swapped out memory nor for the memory which is not yet paged-in).</para></sect1>
<sect1 id="index_1MiscellanyProfiling">
<title>Profiling</title>
<para>CGAL provides a way to count the number of times a given line of code is executed during the execution of a program. Such <computeroutput><ref refid="structCGAL_1_1Profile__counter" kindref="compound">Profile_counter</ref></computeroutput> counters can be added at critical place in the code, and at the end of the execution of a program, the count is printed on <computeroutput>std::cerr</computeroutput>. A macro <computeroutput>CGAL_PROFILER</computeroutput> can be used to conveniently place these counters anywhere. They are disabled by default and activated by the global macro <computeroutput>CGAL_PROFILE</computeroutput>.</para></sect1>
<sect1 id="index_1MiscellanyUnique">
<title>Unique Hash Map</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Unique__hash__map" kindref="compound">Unique_hash_map</ref></computeroutput> implements an injective mapping between a set of unique keys and a set of data values. This is implemented using a chained hashing scheme and access operations take <formula id="5">$ O(1)$</formula> expected time. Such a mapping is useful, for example, when keys are pointers, handles, iterators or circulators that refer to unique memory locations. In this case, the default hash function is <computeroutput><ref refid="structCGAL_1_1Handle__hash__function" kindref="compound">Handle_hash_function</ref></computeroutput>.</para></sect1>
<sect1 id="index_1MiscellanyUnion">
<title>Union-find</title>
<para>CGAL also provides a class <computeroutput><ref refid="classCGAL_1_1Union__find" kindref="compound">Union_find</ref></computeroutput> that implements a partition of values into disjoint sets. This is implemented with union by rank and path compression. The running time for <formula id="0">$ m$</formula> set operations on <formula id="1">$ n$</formula> elements is <formula id="6">$ O(n\alpha(m,n))$</formula> where <formula id="3">$ \alpha(m,n)$</formula> is the extremely slowly growing inverse of Ackermann&apos;s function.</para></sect1>
<sect1 id="index_1MiscellanyProtected">
<title>Protected Access to Internal Representations</title>
<para>High level data structures typically maintain integrity of an internal data representation, which they protect from the user. A minimal while complete interface of the data structure allows manipulations in the domain of valid representations. Additional operations might benefit from being allowed to access the internal data representation directly. An example are intermediate steps within an algorithm where the internal representation would be invalid. We present a general method to accomplish access in a safe manner, such that the high level data structures can guarantee validity after the possibly compromising algorithm has finished its work. An example are polyhedral surfaces, where a construction process like for a file scanner could be performed more efficiently on the internal halfedge data structure than by using the high-level Euler operators of the polyhedron.</para><para><anchor id="index_1fig__figureModifierDesign"/><image type="html" name="modifier_small.png"></image>
 <image type="latex" name="modifier_small.png" width="15cm"></image>
  <ref refid="index_1fig__figureModifierDesign" kindref="member">fig__figureModifierDesign</ref> Class diagram for the modifier. It illustrates the safe access to an internal representation through an high-level interface.  <linebreak/>
</para><para>The solution provided here is inspired by the strategy pattern <ref refid="citelist_1CITEREF_cgal:ghjv-dpero-95" kindref="member">[1]</ref>, though it serves a different intent. The abstract base class <computeroutput><ref refid="classCGAL_1_1Modifier__base" kindref="compound">Modifier_base</ref>&lt;R&gt;</computeroutput> declares a pure virtual member function <computeroutput>operator()</computeroutput> that accepts a single reference parameter of the internal representation type. The member function <computeroutput>delegate()</computeroutput> of the high-level interface calls this <computeroutput>operator()</computeroutput> with its internal representation. An actual modifier implements this virtual function, thus gaining access to the internal representation. Once, the modifier has finished its work, the member function <computeroutput>delegate()</computeroutput> is back in control and can check the validity of the internal representation. Summarizing, a user can implement and apply arbitrary functions based on the internal representation and keeps the benefit if a protected high-level interface. User provided modifiers must in any case return a valid internal representation or the checker in the high-level interface is allowed (and supposed) to abort the program. The indirection via the virtual function invocation is negligible for operations that consists of more than a pointer update or integer addition. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
