<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_dD_Spatial_Searching"/><anchor id="index_1ChapterUserSpatialSearching"/> <simplesect kind="authors"><para>Hans Tangelder and Andreas Fabri</para></simplesect>
</para><sect1 id="index_1Spatial_searchingIntroduction">
<title>Introduction</title>
<para>The spatial searching package implements exact and approximate distance browsing by providing implementations of algorithms supporting</para><para><itemizedlist>
<listitem>
<para>both nearest and furthest neighbor searching</para><para></para></listitem>
<listitem>
<para>both exact and approximate searching</para><para></para></listitem>
<listitem>
<para>(approximate) range searching</para><para></para></listitem>
<listitem>
<para>(approximate) <computeroutput>k</computeroutput>-nearest and <computeroutput>k</computeroutput>-furthest neighbor searching</para><para></para></listitem>
<listitem>
<para>(approximate) incremental nearest and incremental furthest neighbor searching</para><para></para></listitem>
<listitem>
<para>query items representing points and spatial objects.</para><para></para></listitem>
</itemizedlist>
</para><para>In these searching problems a set <computeroutput>P</computeroutput> of data points in <computeroutput>d</computeroutput>-dimensional space is given. The points can be represented by Cartesian coordinates or homogeneous coordinates. These points are preprocessed into a tree data structure, so that given any query item <computeroutput>q</computeroutput> the points of <computeroutput>P</computeroutput> can be browsed efficiently. The approximate spatial searching package is designed for data sets that are small enough to store the search structure in main memory (in contrast to approaches from databases that assume that the data reside in secondary storage).</para><sect2 id="index_1Spatial_searchingNeighborSearching">
<title>Neighbor Searching</title>
<para>Spatial searching supports browsing through a collection of <computeroutput>d</computeroutput>-dimensional spatial objects stored in a spatial data structure on the basis of their distances to a query object. The query object may be a point or an arbitrary spatial object, e.g, a <computeroutput>d</computeroutput>-dimensional sphere. The objects in the spatial data structure are <computeroutput>d</computeroutput>-dimensional points.</para><para>Often the number of the neighbors to be computed is not know beforehand, e.g., because the number may depend on some properties of the neighbors (for example when querying for the nearest city to Paris with population greater than a million) or the distance to the query point. The conventional approach is <computeroutput>k</computeroutput>-nearest neighbor searching that makes use of a <computeroutput>k</computeroutput>-nearest neighbor algorithm, where <computeroutput>k</computeroutput> is known prior to the invocation of the algorithm. Hence, the number of nearest neighbors has to be guessed. If the guess is too large redundant computations are performed. If the number is too small the computation has to be re-invoked for a larger number of neighbors, thereby performing redundant computations. Therefore, Hjaltason and Samet <ref refid="citelist_1CITEREF_hs-rsd-95" kindref="member">[5]</ref> introduced <emphasis>incremental nearest neighbor searching</emphasis> in the sense that having obtained the <computeroutput>k</computeroutput> nearest neighbors, the <computeroutput>k + 1</computeroutput>st neighbor can be obtained without having to calculate the <computeroutput>k + 1</computeroutput> nearest neighbor from scratch.</para><para>Spatial searching typically consists of a preprocessing phase and a searching phase. In the preprocessing phase one builds a search structure and in the searching phase one makes the queries. In the preprocessing phase the user builds a tree data structure storing the spatial data. In the searching phase the user invokes a searching method to browse the spatial data.</para><para>With relatively minor modifications, nearest neighbor searching algorithms can be used to find the furthest object from the query object. Therefore, <emphasis>furthest neighbor searching</emphasis> is also supported by the spatial searching package.</para><para>The execution time for exact neighbor searching can be reduced by relaxing the requirement that the neighbors should be computed exactly. If the distances of two objects to the query object are approximately the same, instead of computing the nearest/furthest neighbor exactly, one of these objects may be returned as the approximate nearest/furthest neighbor. I.e., given some non-negative constant <formula id="6">$ \epsilon$</formula> the distance of an object returned as an approximate <computeroutput>k</computeroutput>-nearest neighbor must not be larger than <formula id="24">$ (1+\epsilon)r$</formula>, where <formula id="7">$ r$</formula> denotes the distance to the real <computeroutput>k</computeroutput>th nearest neighbor. Similar the distance of an approximate <computeroutput>k</computeroutput>-furthest neighbor must not be smaller than <formula id="25">$ r/(1+\epsilon)$</formula>. Obviously, for <formula id="26">$ \epsilon=0$</formula> we get the exact result, and the larger <formula id="6">$ \epsilon$</formula> is, the less exact the result.</para><para>While searching the nearest neighbor the algorithm descends the kd-tree and has to decide two things for each node : Which child node should be visited first and could there be possible nearest neighbors in the other child. This basically comes down to computing the distance to the further child, because the distance to the closer child is the same as the one to the parent. There are two options now:<linebreak/>
<orderedlist>
<listitem><para>In general, we compute the distance with the given metric. This is the <emphasis>k-neighbor search</emphasis> with a <emphasis>general distance</emphasis> class.</para></listitem><listitem><para>For point queries we can &quot;update&quot; the distance, because it is only changed in one dimension at a time. This is the <emphasis>orthogonal k-neighbor search</emphasis> with an <emphasis>orthogonal distance</emphasis> class. The following example shows the orthogonal distance computation in detail:</para></listitem></orderedlist>
</para><para><anchor id="index_1fig__Spatial_searchingorthogonaldistance"/><image type="html" name="orthogonalDistance.svg"></image>
 <image type="latex" name="orthogonalDistance.svg" width="15cm"></image>
  <ref refid="index_1fig__Spatial_searchingorthogonaldistance" kindref="member">fig__Spatial_searchingorthogonaldistance</ref> Orthogonal distance computation technique  <linebreak/>
</para><para>Assume we are searching the nearest neighbor, descending the kd-tree, with <formula id="27">$ R_{p} $</formula> as the parent rectangle and <formula id="28">$ R_{lo} $</formula> and <formula id="29">$ R_{hi}$</formula> as its childs in the current step. Further assume <formula id="28">$ R_{lo} $</formula> is closer to query point <formula id="30">$q$</formula>. Let <formula id="31">$cd$</formula> denote the cutting dimension and let <formula id="32">$cv$</formula> denote the cutting value. At this point we already know the distance <formula id="33">$rd_{p}$</formula> to the parent rectangle and need to check if <formula id="34">$R_{hi}$</formula> could contain nearest neighbors. Because <formula id="35">$R_{lo}$</formula> is the closer rectangle, its distance to <formula id="30">$q$</formula>, <formula id="36">$rd_{lo}$</formula>, is the same as <formula id="33">$rd_{p}$</formula>. Notice that for each dimension <formula id="37">$i \neq cd $</formula>, <formula id="38">$ \mathrm{dists}_{lo}[i] = \mathrm{dists}_{hi}[i]$</formula>, since these coordinates are not affected by the current cut. So the new distance along the cutting dimension is <formula id="39">$ \mathrm{dists}_{hi}[cd] = cv - q[cd]$</formula>. Now we can compute <formula id="40">$rd_{hi}$</formula> in constant time (independent of dimension) with <formula id="41">$rd_{hi} = rd_{p} - \mathrm{dists}_{lo}[cd]^2 + (cv - q[cd])^2$</formula>.<linebreak/>
 This strategy can be used if and only if the distance changes only in one dimension at a time, which is the case for point queries.</para><para>The following two classes implement the standard search strategy for orthogonal distances like the weighted Minkowski distance. The second one is a specialization for incremental neighbor searching and distance browsing. Both require extendes nodes.</para><para><computeroutput><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search" kindref="compound">Orthogonal_k_neighbor_search</ref>&lt;Traits, <ref refid="classOrthogonalDistance" kindref="compound">OrthogonalDistance</ref>, <ref refid="classSplitter" kindref="compound">Splitter</ref>, <ref refid="classSpatialTree" kindref="compound">SpatialTree</ref>&gt;</computeroutput></para><para><computeroutput><ref refid="classCGAL_1_1Orthogonal__incremental__neighbor__search" kindref="compound">Orthogonal_incremental_neighbor_search</ref>&lt;Traits, <ref refid="classOrthogonalDistance" kindref="compound">OrthogonalDistance</ref>, <ref refid="classSplitter" kindref="compound">Splitter</ref>, <ref refid="classSpatialTree" kindref="compound">SpatialTree</ref>&gt;</computeroutput></para><para>The other two classes implement the standard search strategy for general distances like the Manhattan distance for iso-rectangle queries. Again, the second one is a specialization for incremental neighbor searching and distance browsing .</para><para><computeroutput><ref refid="classCGAL_1_1K__neighbor__search" kindref="compound">K_neighbor_search</ref>&lt;Traits, <ref refid="classGeneralDistance" kindref="compound">GeneralDistance</ref>, <ref refid="classSplitter" kindref="compound">Splitter</ref>, <ref refid="classSpatialTree" kindref="compound">SpatialTree</ref>&gt;</computeroutput></para><para><computeroutput><ref refid="classCGAL_1_1Incremental__neighbor__search" kindref="compound">Incremental_neighbor_search</ref>&lt;Traits, <ref refid="classGeneralDistance" kindref="compound">GeneralDistance</ref>, <ref refid="classSplitter" kindref="compound">Splitter</ref>, <ref refid="classSpatialTree" kindref="compound">SpatialTree</ref>&gt;</computeroutput></para></sect2>
<sect2 id="index_1Spatial_searchingRangeSearching">
<title>Range Searching</title>
<para><emphasis>Exact range searching</emphasis> and <emphasis>approximate range searching</emphasis> are supported using exact or fuzzy <computeroutput>d</computeroutput>-dimensional objects enclosing a region. The fuzziness of the query object is specified by a parameter <formula id="6">$ \epsilon$</formula> used to define <emphasis>inner</emphasis> and <emphasis>outer</emphasis> approximations of the object. For example, in the class <computeroutput><ref refid="classCGAL_1_1Fuzzy__sphere" kindref="compound">Fuzzy_sphere</ref></computeroutput>, the <formula id="6">$ \epsilon$</formula>-inner and outer approximations of a sphere of radius <formula id="7">$ r$</formula> are defined as the spheres of radius <formula id="8">$ r-\epsilon$</formula> and <formula id="9">$ r+\epsilon$</formula>, respectively. When using fuzzy items, queries are reported as follows:<itemizedlist>
<listitem><para>Points that are within the inner approximation are always reported.</para></listitem><listitem><para>Points that are within the outer approximation but not within the inner approximation might or might not be reported.</para></listitem><listitem><para>Points thare not within the outer approximation are never reported.</para></listitem></itemizedlist>
</para><para>For exact range searching the fuzziness parameter <formula id="6">$ \epsilon$</formula> is set to zero.</para><para>The class <computeroutput><ref refid="classCGAL_1_1Kd__tree" kindref="compound">Kd_tree</ref></computeroutput> implements range searching in the method <computeroutput>search</computeroutput>, which is a template method with an output iterator and a model of the concept <computeroutput><ref refid="classFuzzyQueryItem" kindref="compound">FuzzyQueryItem</ref></computeroutput> such as <computeroutput><ref refid="classCGAL_1_1Fuzzy__iso__box" kindref="compound">Fuzzy_iso_box</ref></computeroutput> or <computeroutput><ref refid="classCGAL_1_1Fuzzy__sphere" kindref="compound">Fuzzy_sphere</ref></computeroutput>. For range searching of large data sets, the user may set the parameter <computeroutput>bucket_size</computeroutput> used in building the <computeroutput>kd</computeroutput> tree to a large value (e.g. 100), because in general the query time will be less than using the default value.</para></sect2>
</sect1>
<sect1 id="index_1Spatial_SearchingSplitting_rule_section">
<title>Splitting Rules</title>
<para>Instead of using the default splitting rule <computeroutput><ref refid="classCGAL_1_1Sliding__midpoint" kindref="compound">Sliding_midpoint</ref></computeroutput> described below, a user may, depending upon the data, select one from the following splitting rules, which determine how a separating hyperplane is computed. Every splitter has degenerated worst cases, which may lead to a linear tree and a stack overflow. Switching the splitting rule to one of a different kind will solve the problem.</para><para><variablelist>
<varlistentry><term><bold> <computeroutput><ref refid="classCGAL_1_1Midpoint__of__rectangle" kindref="compound">Midpoint_of_rectangle</ref></computeroutput></bold></term></varlistentry>
<listitem><para></para><para>This splitting rule cuts a rectangle through its midpoint orthogonal to the longest side.</para><para></para></listitem>
<varlistentry><term><bold> <computeroutput><ref refid="classCGAL_1_1Midpoint__of__max__spread" kindref="compound">Midpoint_of_max_spread</ref></computeroutput></bold></term></varlistentry>
<listitem><para></para><para>This splitting rule cuts a rectangle through <formula id="11">$ (\mathrm{Mind}+\mathrm{Maxd})/2$</formula> orthogonal to the dimension with the maximum point spread <formula id="42">$ [\mathrm{Mind},\mathrm{Maxd}]$</formula>.</para><para></para></listitem>
<varlistentry><term><bold> <computeroutput><ref refid="classCGAL_1_1Sliding__midpoint" kindref="compound">Sliding_midpoint</ref></computeroutput></bold></term></varlistentry>
<listitem><para></para><para>This is a modification of the midpoint of rectangle splitting rule. It first attempts to perform a midpoint of rectangle split as described above. If data points lie on both sides of the separating plane the sliding midpoint rule computes the same separator as the midpoint of rectangle rule. If the data points lie only on one side it avoids this by sliding the separator, computed by the midpoint of rectangle rule, to the nearest data point. </para></listitem>
</variablelist>
</para><para>As all the midpoint rules cut the bounding box in the middle of the longest side, the tree will become linear for a dataset with exponential increasing distances in one dimension.</para><para><anchor id="index_1fig__Spatial_searchingslidingworstcase"/><image type="html" name="Sliding_worst_case.jpg"></image>
 <image type="latex" name="Sliding_worst_case.jpg" width="15cm"></image>
  <ref refid="index_1fig__Spatial_searchingslidingworstcase" kindref="member">fig__Spatial_searchingslidingworstcase</ref> Midpoint worst case point set in 2d.  <linebreak/>
</para><para><variablelist>
<varlistentry><term><bold> <computeroutput><ref refid="classCGAL_1_1Median__of__rectangle" kindref="compound">Median_of_rectangle</ref></computeroutput></bold></term></varlistentry>
<listitem><para></para><para>The splitting dimension is the dimension of the longest side of the rectangle. The splitting value is defined by the median of the coordinates of the data points along this dimension.</para><para></para></listitem>
<varlistentry><term><bold> <computeroutput><ref refid="classCGAL_1_1Median__of__max__spread" kindref="compound">Median_of_max_spread</ref></computeroutput></bold></term></varlistentry>
<listitem><para></para><para>The splitting dimension is the dimension of the longest side of the rectangle. The splitting value is defined by the median of the coordinates of the data points along this dimension. </para></listitem>
</variablelist>
</para><para>The tree can become linear for the median rules, if many points are collinear in a dimension which is not the cutting dimension. <anchor id="index_1fig__Spatial_searchingmedianworstcase"/><image type="html" name="Median_worst_case.jpg"></image>
 <image type="latex" name="Median_worst_case.jpg" width="15cm"></image>
  <ref refid="index_1fig__Spatial_searchingmedianworstcase" kindref="member">fig__Spatial_searchingmedianworstcase</ref> Median worst case point set in 2d.<linebreak/>
a is longer than b, so this will be the cutting dimension.  <linebreak/>
</para><para><variablelist>
<varlistentry><term><bold> <computeroutput><ref refid="classCGAL_1_1Fair" kindref="compound">Fair</ref></computeroutput></bold></term></varlistentry>
<listitem><para></para><para>This splitting rule is a compromise between the median of rectangle splitting rule and the midpoint of rectangle splitting rule. This splitting rule maintains an upper bound on the maximal allowed ratio of the longest and shortest side of a rectangle (the value of this upper bound is set in the constructor of the fair splitting rule). Among the splits that satisfy this bound, it selects the one in which the points have the largest spread. It then splits the points in the most even manner possible, subject to maintaining the bound on the ratio of the resulting rectangles.</para><para></para></listitem>
<varlistentry><term><bold> <computeroutput><ref refid="classCGAL_1_1Sliding__fair" kindref="compound">Sliding_fair</ref></computeroutput></bold></term></varlistentry>
<listitem><para></para><para>This splitting rule is a compromise between the fair splitting rule and the sliding midpoint rule. Sliding fair-split is based on the theory that there are two types of splits that are good: balanced splits that produce fat rectangles, and unbalanced splits provided the rectangle with fewer points is fat.</para><para>Also, this splitting rule maintains an upper bound on the maximal allowed ratio of the longest and shortest side of a rectangle (the value of this upper bound is set in the constructor of the fair splitting rule). Among the splits that satisfy this bound, it selects the one one in which the points have the largest spread. It then considers the most extreme cuts that would be allowed by the aspect ratio bound. This is done by dividing the longest side of the rectangle by the aspect ratio bound. If the median cut lies between these extreme cuts, then we use the median cut. If not, then consider the extreme cut that is closer to the median. If all the points lie to one side of this cut, then we slide the cut until it hits the first point. This may violate the aspect ratio bound, but will never generate empty cells.</para><para></para></listitem>
</variablelist>
</para></sect1>
<sect1 id="index_1Spatial_searchingExample">
<title>Example Programs</title>
<para>We give seven examples. The first example illustrates k nearest neighbor searching, and the second example incremental neighbor searching. The third is an example of approximate furthest neighbor searching using a <computeroutput>d</computeroutput>-dimensional iso-rectangle as an query object. Approximate range searching is illustrated by the fourth example. The fifth example illustrates k neighbor searching for a user defined point class. The sixth example shows how to choose another splitting rule in the <computeroutput>kd</computeroutput> tree that is used as search tree. The last example shows two worst-case scenarios for different splitter types.</para><sect2 id="index_1Spatial_searchingExampleforKNeighborSearching">
<title>Example for K Neighbor Searching</title>
<para>The first example illustrates k neighbor searching with an Euclidean distance and 2-dimensional points. The generated random data points are inserted in a search tree. We then initialize the k neighbor search object with the origin as query. Finally, we obtain the result of the computation in the form of an iterator range. The value of the iterator is a pair of a point and its square distance to the query point. We use square distances, or <emphasis>transformed distances</emphasis> for other distance classes, as they are computationally cheaper.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2nearest_neighbor_searching_8cpp-example" kindref="compound">Spatial_searching/nearest_neighbor_searching.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cmath&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/>Point_d;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__2" kindref="compound">CGAL::Search_traits_2&lt;K&gt;</ref><sp/>TreeTraits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search" kindref="compound">CGAL::Orthogonal_k_neighbor_search&lt;TreeTraits&gt;</ref><sp/>Neighbor_search;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Neighbor_search::Tree<sp/>Tree;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point_d&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_d(0,0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree<sp/>tree(points.begin(),<sp/>points.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_d<sp/>query(0,0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>the<sp/>search<sp/>structure,<sp/>and<sp/>search<sp/>all<sp/>N<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighbor_search<sp/>search(tree,<sp/>query,<sp/>N);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>report<sp/>the<sp/>N<sp/>nearest<sp/>neighbors<sp/>and<sp/>their<sp/>distance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>should<sp/>sort<sp/>all<sp/>N<sp/>points<sp/>by<sp/>increasing<sp/>distance<sp/>from<sp/>origin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Neighbor_search::iterator<sp/>it<sp/>=<sp/>search.begin();<sp/>it<sp/>!=<sp/>search.end();<sp/>++it){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>it-&gt;first<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">std::sqrt</ref>(it-&gt;second)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Spatial_searchingExampleforIncrementalSearching">
<title>Example for Incremental Searching</title>
<para>This example program illustrates incremental searching for the closest point with a positive first coordinate. We can use the orthogonal incremental neighbor search class, as the query is also a point and as the distance is the Euclidean distance.</para><para>As for the <computeroutput>k</computeroutput> neighbor search, we first initialize the search tree with the data. We then create the search object, and finally obtain the iterator with the <computeroutput>begin()</computeroutput> method. Note that the iterator is of the input iterator category, that is one can make only one pass over the data.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2distance_browsing_8cpp-example" kindref="compound">Spatial_searching/distance_browsing.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Orthogonal_incremental_neighbor_search.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/>Point_d;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__2" kindref="compound">CGAL::Search_traits_2&lt;K&gt;</ref><sp/>TreeTraits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Orthogonal__incremental__neighbor__search" kindref="compound">CGAL::Orthogonal_incremental_neighbor_search&lt;TreeTraits&gt;</ref><sp/>NN_incremental_search;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>NN_incremental_search::iterator<sp/>NN_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>NN_incremental_search::Tree<sp/>Tree;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>functor<sp/>that<sp/>returns<sp/>true,<sp/>iff<sp/>the<sp/>x-coordinate<sp/>of<sp/>a<sp/>dD<sp/>point<sp/>is<sp/>not<sp/>positive</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">X_not_positive<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>NN_iterator&amp;<sp/>it)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>((*it).first)[0]&lt;0;<sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>An<sp/>iterator<sp/>that<sp/>only<sp/>enumerates<sp/>dD<sp/>points<sp/>with<sp/>positive<sp/>x-coordinate</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Filter__iterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Filter_iterator&lt;NN_iterator, X_not_positive&gt;</ref><sp/>NN_positive_x_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree<sp/>tree;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree.insert(Point_d(0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree.insert(Point_d(1,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree.insert(Point_d(0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree.insert(Point_d(10,110));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree.insert(Point_d(45,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree.insert(Point_d(0,2340));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree.insert(Point_d(0,30));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_d<sp/>query(0,0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NN_incremental_search<sp/>NN(tree,<sp/>query);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NN_positive_x_iterator<sp/>it(NN.end(),<sp/>X_not_positive(),<sp/>NN.begin()),<sp/>end(NN.end(),<sp/>X_not_positive());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;The<sp/>first<sp/>5<sp/>nearest<sp/>neighbours<sp/>with<sp/>positive<sp/>x-coord<sp/>are:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j=0;<sp/>(j<sp/>&lt;<sp/>5)&amp;&amp;(it!=end);<sp/>++j,++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/><sp/><sp/>(*it).first<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>at<sp/>squared<sp/>distance<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(*it).second<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Spatial_searchingExampleforGeneralNeighbor">
<title>Example for General Neighbor Searching</title>
<para>This example program illustrates approximate nearest and furthest neighbor searching using 4-dimensional Cartesian coordinates. Five approximate furthest neighbors of the query rectangle <formula id="43">$ [0.1,0.2]^4$</formula> are computed. Because the query object is a rectangle we cannot use the orthogonal neighbor search. As in the previous examples we first initialize a search tree, create the search object with the query, and obtain the result of the search as iterator range.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2general_neighbor_searching_8cpp-example" kindref="compound">Spatial_searching/general_neighbor_searching.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Epick_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Manhattan_distance_iso_box_point.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/K_neighbor_search.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Epick__d" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_d.tag">CGAL::Epick_d&lt;CGAL::Dimension_tag&lt;4&gt;</ref><sp/>&gt;<sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::Point_d<sp/>Point_d;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_cube_d&lt;Point_d&gt;<sp/>Random_points_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::Iso_box_d<sp/>Iso_box_d;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel<sp/>TreeTraits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Manhattan__distance__iso__box__point" kindref="compound">CGAL::Manhattan_distance_iso_box_point&lt;TreeTraits&gt;</ref><sp/>Distance;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1K__neighbor__search" kindref="compound">CGAL::K_neighbor_search&lt;TreeTraits, Distance&gt;</ref><sp/>Neighbor_search;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Neighbor_search::Tree<sp/>Tree;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>1000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>K<sp/>=<sp/>10;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree<sp/>tree;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Random_points_iterator<sp/>rpit(4,1000.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>N;<sp/>i++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tree.insert(*rpit++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_d<sp/>pp(0.1,0.1,0.1,0.1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_d<sp/>qq(0.2,0.2,0.2,0.2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Iso_box_d<sp/>query(pp,qq);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Distance<sp/>tr_dist;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighbor_search<sp/>N1(tree,<sp/>query,<sp/>5,<sp/>10.0,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);<sp/></highlight><highlight class="comment">//<sp/>eps=10.0,<sp/>nearest=false</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;For<sp/>query<sp/>rectangle<sp/>=<sp/>[0.1,<sp/>0.2]^4<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;the<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>K<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>approximate<sp/>furthest<sp/>neighbors<sp/>are:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Neighbor_search::iterator<sp/>it<sp/>=<sp/>N1.begin();it<sp/>!=<sp/>N1.end();it++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>Point<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>it-&gt;first<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>at<sp/>distance<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>tr_dist.inverse_of_transformed_distance(it-&gt;second)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Spatial_searchingExampleforaRangeQuery">
<title>Example for a Range Query</title>
<para>This example program illustrates approximate range querying for 4-dimensional fuzzy iso-rectangles and spheres using the higher dimensional kernel <computeroutput><ref refid="structCGAL_1_1Epick__d" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_d.tag">Epick_d</ref></computeroutput>. The range queries are member functions of the <computeroutput>kd</computeroutput> tree class.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2fuzzy_range_query_8cpp-example" kindref="compound">Spatial_searching/fuzzy_range_query.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Epick_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Kd_tree.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Fuzzy_sphere.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Fuzzy_iso_box.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>D<sp/>=<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Epick__d" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_d.tag">CGAL::Epick_d&lt;CGAL::Dimension_tag&lt;D&gt;</ref><sp/>&gt;<sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_d<sp/>Point_d;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__d" kindref="compound">CGAL::Search_traits_d&lt;K,CGAL::Dimension_tag&lt;D&gt;</ref><sp/>&gt;<sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_cube_d&lt;Point_d&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>Random_points_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Counting__iterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Counting_iterator&lt;Random_points_iterator&gt;</ref><sp/>N_Random_points_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Kd__tree" kindref="compound">CGAL::Kd_tree&lt;Traits&gt;</ref><sp/>Tree;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Fuzzy__sphere" kindref="compound">CGAL::Fuzzy_sphere&lt;Traits&gt;</ref><sp/>Fuzzy_sphere;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Fuzzy__iso__box" kindref="compound">CGAL::Fuzzy_iso_box&lt;Traits&gt;</ref><sp/>Fuzzy_iso_box;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>1000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>generator<sp/>for<sp/>random<sp/>data<sp/>points<sp/>in<sp/>the<sp/>square<sp/>(<sp/>(-1000,-1000),<sp/>(1000,1000)<sp/>)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Random_points_iterator<sp/>rpit(4,<sp/>1000.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>N<sp/>points<sp/>in<sp/>the<sp/>tree</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree<sp/>tree(N_Random_points_iterator(rpit,0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>N_Random_points_iterator(rpit,N));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>define<sp/>range<sp/>query<sp/>objects</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/>pcoord[D]<sp/>=<sp/>{<sp/>300,<sp/>300,<sp/>300,<sp/>300<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/>qcoord[D]<sp/>=<sp/>{<sp/>900.0,<sp/>900.0,<sp/>900.0,<sp/>900.0<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_d<sp/>p(D,<sp/>pcoord+0,<sp/>pcoord+D);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_d<sp/>q(D,<sp/>qcoord+0,<sp/>qcoord+D);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Fuzzy_sphere<sp/>fs(p,<sp/>700.0,<sp/>100.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Fuzzy_iso_box<sp/>fib(p,<sp/>q,<sp/>100.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;points<sp/>approximately<sp/>in<sp/>fuzzy<sp/>spherical<sp/>range<sp/>query&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;with<sp/>center<sp/>(300,<sp/>300,<sp/>300,<sp/>300)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;and<sp/>fuzzy<sp/>radius<sp/>[600,<sp/>800]<sp/>are:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree.search(std::ostream_iterator&lt;Point_d&gt;(std::cout,<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">),<sp/>fs);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;points<sp/>approximately<sp/>in<sp/>fuzzy<sp/>rectangular<sp/>range<sp/>query<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[[200,<sp/>400],<sp/>[800,1000]]^4<sp/>are:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree.search(std::ostream_iterator&lt;Point_d&gt;(std::cout,<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">),<sp/>fib);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Spatial_searchingExampleforUserDefinedPoint">
<title>Example for User Defined Point and Distance Class</title>
<para>The neighbor searching works with all CGAL kernels, as well as with user defined points and distance classes. In this example we assume that the user provides the following 3-dimensional points class.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2Point_8h-example" kindref="compound">Spatial_searching/Point.h</ref> <programlisting><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Point<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>vec[3];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point()<sp/>{<sp/>vec[0]=<sp/>vec[1]<sp/>=<sp/>vec[2]<sp/>=<sp/>0;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>z)<sp/>{<sp/>vec[0]=x;<sp/>vec[1]=y;<sp/>vec[2]=z;<sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>vec[<sp/>0<sp/>];<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>vec[<sp/>1<sp/>];<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>z()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>vec[<sp/>2<sp/>];<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&amp;<sp/>x()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>vec[<sp/>0<sp/>];<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&amp;<sp/>y()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>vec[<sp/>1<sp/>];<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&amp;<sp/>z()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>vec[<sp/>2<sp/>];<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator==(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(x()<sp/>==<sp/>p.x())<sp/>&amp;&amp;<sp/>(y()<sp/>==<sp/>p.y())<sp/>&amp;&amp;<sp/>(z()<sp/>==<sp/>p.z())<sp/><sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><sp/>operator!=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!<sp/>(*</highlight><highlight class="keyword">this</highlight><highlight class="normal"><sp/>==<sp/>p);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};<sp/></highlight><highlight class="comment">//end<sp/>of<sp/>class</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Construct_coord_iterator<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>result_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keyword">const<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(p.vec);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)</highlight><highlight class="keyword"><sp/><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keyword">const<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(p.vec+3);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>We have put the glue layer in this file as well, that is a class that allows to iterate over the Cartesian coordinates of the point, and a class to construct such an iterator for a point. We next need a distance class <linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2Distance_8h-example" kindref="compound">Spatial_searching/Distance.h</ref> <programlisting><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Distance<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point<sp/>Query_item;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Dimension__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Dimension_tag&lt;3&gt;</ref><sp/>D;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>transformed_distance(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p2)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>distx=<sp/>p1.x()-p2.x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>disty=<sp/>p1.y()-p2.y();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>distz=<sp/>p1.z()-p2.z();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>distx*distx+disty*disty+distz*distz;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>min_distance_to_rectangle(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Kd__tree__rectangle" kindref="compound">CGAL::Kd_tree_rectangle&lt;FT,D&gt;</ref>&amp;<sp/>b)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>distance(0.0),<sp/>h<sp/>=<sp/>p.x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&lt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(0))<sp/>distance<sp/>+=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(0)-h)*(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(0)-h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&gt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(0))<sp/>distance<sp/>+=<sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(0))*(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h=p.y();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&lt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(1))<sp/>distance<sp/>+=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(1)-h)*(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(1)-h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&gt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(1))<sp/>distance<sp/>+=<sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(1))*(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h=p.z();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&lt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(2))<sp/>distance<sp/>+=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(2)-h)*(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(2)-h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&gt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(2))<sp/>distance<sp/>+=<sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(2))*(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>distance;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>min_distance_to_rectangle(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Kd__tree__rectangle" kindref="compound">CGAL::Kd_tree_rectangle&lt;FT,D&gt;</ref>&amp;<sp/>b,std::vector&lt;double&gt;&amp;<sp/>dists){<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>distance(0.0),<sp/>h<sp/>=<sp/>p.x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&lt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(0)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dists[0]<sp/>=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(0)-h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>distance<sp/>+=<sp/>dists[0]*dists[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&gt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(0)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dists[0]<sp/>=<sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>distance<sp/>+=<sp/>dists[0]*dists[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h=p.y();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&lt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(1)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dists[1]<sp/>=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(1)-h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>distance<sp/>+=<sp/>dists[1]*dists[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&gt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(1)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dists[1]<sp/>=<sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>distance<sp/>+=<sp/>dists[1]*dists[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h=p.z();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&lt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(2)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dists[2]<sp/>=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(2)-h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>distance<sp/>+=<sp/>dists[2]*dists[2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h<sp/>&gt;<sp/>b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(2)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dists[2]<sp/>=<sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>distance<sp/>+=<sp/>dists[2]*dists[2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>distance;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>max_distance_to_rectangle(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Kd__tree__rectangle" kindref="compound">CGAL::Kd_tree_rectangle&lt;FT,D&gt;</ref>&amp;<sp/>b)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>h<sp/>=<sp/>p.x();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>d0<sp/>=<sp/>(h<sp/>&gt;=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(0)+b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(0))/2.0)<sp/>?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(0))*(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(0))<sp/>:<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(0)-h)*(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(0)-h);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h=p.y();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>d1<sp/>=<sp/>(h<sp/>&gt;=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(1)+b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(1))/2.0)<sp/>?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(1))*(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(1))<sp/>:<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(1)-h)*(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(1)-h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h=p.z();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>d2<sp/>=<sp/>(h<sp/>&gt;=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(2)+b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(2))/2.0)<sp/>?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(2))*(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(2))<sp/>:<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(2)-h)*(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(2)-h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>d0<sp/>+<sp/>d1<sp/>+<sp/>d2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>max_distance_to_rectangle(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Kd__tree__rectangle" kindref="compound">CGAL::Kd_tree_rectangle&lt;FT,D&gt;</ref>&amp;<sp/>b,std::vector&lt;double&gt;&amp;<sp/>dists){<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>h<sp/>=<sp/>p.x();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dists[0]<sp/>=<sp/>(h<sp/>&gt;=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(0)+b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(0))/2.0)<sp/>?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(0))<sp/>:<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(0)-h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h=p.y();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dists[1]<sp/>=<sp/>(h<sp/>&gt;=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(1)+b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(1))/2.0)<sp/>?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(1))<sp/>:<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(1)-h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h=p.z();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dists[2]<sp/>=<sp/>(h<sp/>&gt;=<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(2)+b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(2))/2.0)<sp/>?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(h-b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1ac23671b8977b090392b945483d788389" kindref="member">min_coord</ref>(2))<sp/>:<sp/>(b.<ref refid="classCGAL_1_1Kd__tree__rectangle_1a7e2867b92e3f31a934c485b4a80f0156" kindref="member">max_coord</ref>(2)-h);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>dists[0]<sp/>*<sp/>dists[0]<sp/>+<sp/>dists[1]<sp/>*<sp/>dists[1]<sp/>+<sp/>dists[2]<sp/>*<sp/>dists[2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>new_distance(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&amp;<sp/>dist,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>old_off,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>new_off,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">/*<sp/>cutting_dimension<sp/>*/</highlight><highlight class="normal">)</highlight><highlight class="keyword"><sp/><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>dist<sp/>+<sp/>new_off*new_off<sp/>-<sp/>old_off*old_off;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>transformed_distance(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>d)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>d*d;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>inverse_of_transformed_distance(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>d)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">std::sqrt</ref>(d);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};<sp/></highlight><highlight class="comment">//<sp/>end<sp/>of<sp/>struct<sp/>Distance</highlight><highlight class="normal"></highlight></codeline>
</programlisting></para><para>We are ready to put the pieces together. The class <computeroutput><ref refid="classCGAL_1_1Search__traits" kindref="compound">Search_traits</ref>&lt;..&gt;</computeroutput> ,which you see in the next file, is a mere wrapper for all our defined types. The searching itself works exactly as for CGAL kernels.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2user_defined_point_and_distance_8cpp-example" kindref="compound">Spatial_searching/user_defined_point_and_distance.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;Point.h&quot;</highlight><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>defines<sp/>types<sp/>Point,<sp/>Construct_coord_iterator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;Distance.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_3&lt;double,Point&gt;</ref><sp/>Point_creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_cube_3&lt;Point,<sp/>Point_creator&gt;<sp/>Random_points_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Counting__iterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Counting_iterator&lt;Random_points_iterator&gt;</ref><sp/>N_Random_points_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Dimension__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Dimension_tag&lt;3&gt;</ref><sp/>D;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits" kindref="compound">CGAL::Search_traits&lt;double, Point, const double*, Construct_coord_iterator, D&gt;</ref><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search" kindref="compound">CGAL::Orthogonal_k_neighbor_search&lt;Traits, Distance&gt;</ref><sp/>K_neighbor_search;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1K__neighbor__search_1a3b06c8cef57e8bab082134470343c7e2" kindref="member">K_neighbor_search::Tree</ref><sp/>Tree;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>1000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>K<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>generator<sp/>for<sp/>random<sp/>data<sp/>points<sp/>in<sp/>the<sp/>cube<sp/>(<sp/>(-1,-1,-1),<sp/>(1,1,1)<sp/>)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Random_points_iterator<sp/>rpit(<sp/>1.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>number_of_data_points<sp/>in<sp/>the<sp/>tree</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree<sp/>tree(N_Random_points_iterator(rpit,0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>N_Random_points_iterator(N));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>query(0.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Distance<sp/>tr_dist;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>search<sp/>K<sp/>nearest<sp/>neighbours</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>K_neighbor_search<sp/>search(tree,<sp/>query,<sp/>K);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<ref refid="classCGAL_1_1K__neighbor__search_1ad26a3d2c9da3788a3bd087b1b05ad7eb" kindref="member">K_neighbor_search::iterator</ref><sp/>it<sp/>=<sp/>search.begin();<sp/>it<sp/>!=<sp/>search.end();<sp/>it++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>d(q,<sp/>nearest<sp/>neighbor)=<sp/><sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>tr_dist.inverse_of_transformed_distance(it-&gt;second)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>search<sp/>K<sp/>furthest<sp/>neighbour<sp/>searching,<sp/>with<sp/>eps=0,<sp/>search_nearest=false</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>K_neighbor_search<sp/>search2(tree,<sp/>query,<sp/>K,<sp/>0.0,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<ref refid="classCGAL_1_1K__neighbor__search_1ad26a3d2c9da3788a3bd087b1b05ad7eb" kindref="member">K_neighbor_search::iterator</ref><sp/>it<sp/>=<sp/>search2.begin();<sp/>it<sp/>!=<sp/>search2.end();<sp/>it++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>d(q,<sp/>furthest<sp/>neighbor)=<sp/><sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>tr_dist.inverse_of_transformed_distance(it-&gt;second)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Spatial_searchingExamplesforUsinganArbitrary">
<title>Examples for Using an Arbitrary Point Type with Point Property Maps</title>
<para>The following four example programs illustrate how to use the classes <computeroutput><ref refid="classCGAL_1_1Search__traits__adapter" kindref="compound">Search_traits_adapter</ref>&lt;Key,PointPropertyMap,BaseTraits&gt;</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Distance__adapter" kindref="compound">Distance_adapter</ref>&lt;Key,PointPropertyMap,Base_distance&gt;</computeroutput> to store in the kd-tree objects of an arbitrary key type. Points are accessed through a point <ulink url="http://www.boost.org/doc/libs/release/libs/property_map/index.html">property map</ulink>. This enables to associate information to a point or to reduce the size of the search structure.</para><sect3 id="index_1Spatial_searchingUsingaPointandanInteger">
<title>Using a Point and an Integer as Key Type</title>
<para>In this example program, the search tree stores tuples of point and integer. The value type of the iterator of the neighbor searching algorithm is this tuple type.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2searching_with_point_with_info_8cpp-example" kindref="compound">Spatial_searching/searching_with_point_with_info.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_adapter.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/iterator/zip_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::tuple&lt;Point_3,int&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_and_int;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_cube_3&lt;Point_3&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Random_points_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__3" kindref="compound">CGAL::Search_traits_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_base;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__adapter" kindref="compound">CGAL::Search_traits_adapter</ref>&lt;Point_and_int,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Nth_of_tuple_property_map&lt;0,<sp/>Point_and_int&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits_base&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search" kindref="compound">CGAL::Orthogonal_k_neighbor_search&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K_neighbor_search;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1K__neighbor__search_1a3b06c8cef57e8bab082134470343c7e2" kindref="member">K_neighbor_search::Tree</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tree;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1K__neighbor__search_1a788fb89a2e01dec4bb2463ac209ac713" kindref="member">K_neighbor_search::Distance</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Distance;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>K<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>generator<sp/>for<sp/>random<sp/>data<sp/>points<sp/>in<sp/>the<sp/>cube<sp/>(<sp/>(-1,-1,-1),<sp/>(1,1,1)<sp/>)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Random_points_iterator<sp/>rpit(<sp/>1.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_3&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;int&gt;<sp/><sp/><sp/><sp/><sp/>indices;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>indices.push_back(6);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>number_of_data_points<sp/>in<sp/>the<sp/>tree</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree<sp/>tree(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::make_zip_iterator(boost::make_tuple(<sp/>points.begin(),indices.begin()<sp/>)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::make_zip_iterator(boost::make_tuple(<sp/>points.end(),indices.end()<sp/>)<sp/>)<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_3<sp/>query(0.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Distance<sp/>tr_dist;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>search<sp/>K<sp/>nearest<sp/>neighbours</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>K_neighbor_search<sp/>search(tree,<sp/>query,<sp/>K);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<ref refid="classCGAL_1_1K__neighbor__search_1ad26a3d2c9da3788a3bd087b1b05ad7eb" kindref="member">K_neighbor_search::iterator</ref><sp/>it<sp/>=<sp/>search.begin();<sp/>it<sp/>!=<sp/>search.end();<sp/>it++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>d(q,<sp/>nearest<sp/>neighbor)=<sp/><sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>tr_dist.inverse_of_transformed_distance(it-&gt;second)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>boost::get&lt;0&gt;(it-&gt;first)&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>boost::get&lt;1&gt;(it-&gt;first)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1Spatial_searchingUsinganIntegerasKeyType">
<title>Using an Integer as Key Type</title>
<para>In this example program, the search tree stores only integers that refer to points stored within a user vector. The point type of the search traits is <computeroutput>std::size_t</computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2searching_with_point_with_info_inplace_8cpp-example" kindref="compound">Spatial_searching/searching_with_point_with_info_inplace.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_adapter.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/iterator/counting_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//definition<sp/>of<sp/>a<sp/>non-mutable<sp/>lvalue<sp/>property<sp/>map,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//with<sp/>the<sp/>get<sp/>function<sp/>as<sp/>a<sp/>friend<sp/>function<sp/>to<sp/>give<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//access<sp/>to<sp/>the<sp/>private<sp/>member</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_point_property_map{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_3&gt;&amp;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Point_3<sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>value_type&amp;<sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::size_t<sp/>key_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::lvalue_property_map_tag<sp/>category;<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_point_property_map(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_3&gt;&amp;<sp/>pts):points(pts){}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>reference<sp/>operator[](key_type<sp/>k)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>points[k];}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/>reference<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>My_point_property_map&amp;<sp/>ppmap,key_type<sp/>i)<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ppmap[i];}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_cube_3&lt;Point_3&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Random_points_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__3" kindref="compound">CGAL::Search_traits_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_base;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__adapter" kindref="compound">CGAL::Search_traits_adapter&lt;std::size_t,My_point_property_map,Traits_base&gt;</ref><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search" kindref="compound">CGAL::Orthogonal_k_neighbor_search&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K_neighbor_search;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1K__neighbor__search_1a3b06c8cef57e8bab082134470343c7e2" kindref="member">K_neighbor_search::Tree</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tree;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Tree::Splitter<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Splitter;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1K__neighbor__search_1a788fb89a2e01dec4bb2463ac209ac713" kindref="member">K_neighbor_search::Distance</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Distance;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>K<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>generator<sp/>for<sp/>random<sp/>data<sp/>points<sp/>in<sp/>the<sp/>cube<sp/>(<sp/>(-1,-1,-1),<sp/>(1,1,1)<sp/>)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Random_points_iterator<sp/>rpit(<sp/>1.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_3&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points.push_back(Point_3(*rpit++));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_point_property_map<sp/>ppmap(points);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>number_of_data_points<sp/>in<sp/>the<sp/>tree</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree<sp/>tree(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::counting_iterator&lt;std::size_t&gt;(0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::counting_iterator&lt;std::size_t&gt;(points.size()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Splitter(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Traits(ppmap)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_3<sp/>query(0.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Distance<sp/>tr_dist(ppmap);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>search<sp/>K<sp/>nearest<sp/>neighbours</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>K_neighbor_search<sp/>search(tree,<sp/>query,<sp/>K,0,</highlight><highlight class="keyword">true</highlight><highlight class="normal">,tr_dist);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<ref refid="classCGAL_1_1K__neighbor__search_1ad26a3d2c9da3788a3bd087b1b05ad7eb" kindref="member">K_neighbor_search::iterator</ref><sp/>it<sp/>=<sp/>search.begin();<sp/>it<sp/>!=<sp/>search.end();<sp/>it++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>d(q,<sp/>nearest<sp/>neighbor)=<sp/><sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>tr_dist.inverse_of_transformed_distance(it-&gt;second)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>points[it-&gt;first]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>it-&gt;first<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1Spatial_searchingUsingaModelofLvalueProperty">
<title>Using a Model of L-value Property Map Concept</title>
<para>This example programs uses a model of <computeroutput><ref refid="classLvaluePropertyMap" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">LvaluePropertyMap</ref></computeroutput>. Points are read from a <computeroutput>std::map</computeroutput>. The search tree stores integers of type <computeroutput>std::size_t</computeroutput>. The value type of the iterator of the neighbor searching algorithm is <computeroutput>std::size_t</computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2searching_with_point_with_info_pmap_8cpp-example" kindref="compound">Spatial_searching/searching_with_point_with_info_pmap.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_adapter.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/iterator/counting_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::const_associative_property_map&lt;std::map&lt;std::size_t,Point_3&gt;<sp/>&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>My_point_property_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_cube_3&lt;Point_3&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Random_points_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__3" kindref="compound">CGAL::Search_traits_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_base;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__adapter" kindref="compound">CGAL::Search_traits_adapter&lt;std::size_t,My_point_property_map,Traits_base&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search" kindref="compound">CGAL::Orthogonal_k_neighbor_search&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K_neighbor_search;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1K__neighbor__search_1a3b06c8cef57e8bab082134470343c7e2" kindref="member">K_neighbor_search::Tree</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tree;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Tree::Splitter<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Splitter;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1K__neighbor__search_1a788fb89a2e01dec4bb2463ac209ac713" kindref="member">K_neighbor_search::Distance</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Distance;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>K<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>generator<sp/>for<sp/>random<sp/>data<sp/>points<sp/>in<sp/>the<sp/>cube<sp/>(<sp/>(-1,-1,-1),<sp/>(1,1,1)<sp/>)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Random_points_iterator<sp/>rpit(<sp/>1.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::map&lt;std::size_t,Point_3&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points[0]=Point_3(*rpit++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points[1]=Point_3(*rpit++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points[2]=Point_3(*rpit++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points[3]=Point_3(*rpit++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points[4]=Point_3(*rpit++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points[5]=Point_3(*rpit++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points[6]=Point_3(*rpit++);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_point_property_map<sp/>ppmap(points);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>number_of_data_points<sp/>in<sp/>the<sp/>tree</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree<sp/>tree(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::counting_iterator&lt;std::size_t&gt;(0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::counting_iterator&lt;std::size_t&gt;(points.size()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Splitter(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Traits(ppmap)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_3<sp/>query(0.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Distance<sp/>tr_dist(ppmap);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>search<sp/>K<sp/>nearest<sp/>neighbours</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>K_neighbor_search<sp/>search(tree,<sp/>query,<sp/>K,0,</highlight><highlight class="keyword">true</highlight><highlight class="normal">,tr_dist);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<ref refid="classCGAL_1_1K__neighbor__search_1ad26a3d2c9da3788a3bd087b1b05ad7eb" kindref="member">K_neighbor_search::iterator</ref><sp/>it<sp/>=<sp/>search.begin();<sp/>it<sp/>!=<sp/>search.end();<sp/>it++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>d(q,<sp/>nearest<sp/>neighbor)=<sp/><sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>tr_dist.inverse_of_transformed_distance(it-&gt;second)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>points[it-&gt;first]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>it-&gt;first<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1Spatial_searchingUsingSurfaceMesh">
<title>Using a Point Property Map of a Polygonal Mesh</title>
<para>This example programs shows how to search the closest vertices of a <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput> or, quite similar, of a <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polyhedron.tag">Polyhedron_3</ref></computeroutput>. Points are stored in the polygonal mesh. The search tree stores vertex descriptors. The value type of the iterator of the neighbor searching algorithm is <ref refid="group__PkgBGLTraits_1BGLSMGT" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/BGL.tag"><computeroutput>boost::graph_traits&lt;Surface_mesh&gt;::vertex_descriptor</computeroutput> </ref>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2searching_surface_mesh_vertices_8cpp-example" kindref="compound">Spatial_searching/searching_surface_mesh_vertices.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_adapter.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Point_3&gt;</ref><sp/>Mesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Mesh&gt;::vertex_descriptor<sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::graph_traits&lt;Mesh&gt;::vertices_size_type<sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::property_map&lt;Mesh,CGAL::vertex_point_t&gt;::type<sp/>Vertex_point_pmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__3" kindref="compound">CGAL::Search_traits_3&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_base;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__adapter" kindref="compound">CGAL::Search_traits_adapter&lt;Point,Vertex_point_pmap,Traits_base&gt;</ref><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search" kindref="compound">CGAL::Orthogonal_k_neighbor_search&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K_neighbor_search;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1K__neighbor__search_1a3b06c8cef57e8bab082134470343c7e2" kindref="member">K_neighbor_search::Tree</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tree;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Tree::Splitter<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Splitter;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1K__neighbor__search_1a788fb89a2e01dec4bb2463ac209ac713" kindref="member">K_neighbor_search::Distance</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Distance;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mesh<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>argc<sp/>&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in((argc&gt;1)?argv[1]:</highlight><highlight class="stringliteral">&quot;data/tripod.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/><sp/>&gt;&gt;<sp/>mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>K<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_point_pmap<sp/>vppmap<sp/>=<sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(CGAL::vertex_point,mesh);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>number_of_data_points<sp/>in<sp/>the<sp/>tree</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree<sp/>tree(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vertices(mesh).begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vertices(mesh).end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Splitter(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits(vppmap)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_3<sp/>query(0.0,<sp/>0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Distance<sp/>tr_dist(vppmap);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>search<sp/>K<sp/>nearest<sp/>neighbours</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>K_neighbor_search<sp/>search(tree,<sp/>query,<sp/>K,0,</highlight><highlight class="keyword">true</highlight><highlight class="normal">,tr_dist);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;The<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/>K<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>nearest<sp/>vertices<sp/>to<sp/>the<sp/>query<sp/>point<sp/>at<sp/>(0,0,0)<sp/>are:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<ref refid="classCGAL_1_1K__neighbor__search_1ad26a3d2c9da3788a3bd087b1b05ad7eb" kindref="member">K_neighbor_search::iterator</ref><sp/>it<sp/>=<sp/>search.begin();<sp/>it<sp/>!=<sp/>search.end();<sp/>it++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;vertex<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>it-&gt;first<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vppmap[it-&gt;first]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>at<sp/>distance<sp/>&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>tr_dist.inverse_of_transformed_distance(it-&gt;second)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
</sect2>
<sect2 id="index_1Spatial_searchingExampleforSelectingaSplitting">
<title>Example for Selecting a Splitting Rule and Setting the Bucket Size</title>
<para>This example program illustrates selecting a splitting rule and setting the maximal allowed bucket size. The only differences with the first example are the declaration of the <emphasis><ref refid="classCGAL_1_1Fair" kindref="compound">Fair</ref></emphasis> splitting rule, needed to set the maximal allowed bucket size.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2using_fair_splitting_rule_8cpp-example" kindref="compound">Spatial_searching/using_fair_splitting_rule.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cmath&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/>R;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>R::Point_2<sp/>Point_d;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_square_2&lt;Point_d&gt;<sp/>Random_points_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Counting__iterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">CGAL::Counting_iterator&lt;Random_points_iterator&gt;</ref><sp/>N_Random_points_iterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__2" kindref="compound">CGAL::Search_traits_2&lt;R&gt;</ref><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Euclidean__distance" kindref="compound">CGAL::Euclidean_distance&lt;Traits&gt;</ref><sp/>Distance;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Fair" kindref="compound">CGAL::Fair&lt;Traits&gt;</ref><sp/>Fair;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search" kindref="compound">CGAL::Orthogonal_k_neighbor_search&lt;Traits,Distance,Fair&gt;</ref><sp/>Neighbor_search;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Neighbor_search::Tree<sp/>Tree;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>1000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>generator<sp/>for<sp/>random<sp/>data<sp/>points<sp/>in<sp/>the<sp/>square<sp/>(<sp/>(-1,-1),<sp/>(1,1)<sp/>)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Random_points_iterator<sp/>rpit(<sp/>1.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Fair<sp/>fair(5);<sp/></highlight><highlight class="comment">//<sp/>bucket<sp/>size=5</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>number_of_data_points<sp/>in<sp/>the<sp/>tree</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree<sp/>tree(N_Random_points_iterator(rpit,0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>N_Random_points_iterator(N),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fair);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_d<sp/>query(0,0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>the<sp/>search<sp/>structure,<sp/>and<sp/>search<sp/>all<sp/>N<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighbor_search<sp/>search(tree,<sp/>query,<sp/>N);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>report<sp/>the<sp/>N<sp/>nearest<sp/>neighbors<sp/>and<sp/>their<sp/>distance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>should<sp/>sort<sp/>all<sp/>N<sp/>points<sp/>by<sp/>increasing<sp/>distance<sp/>from<sp/>origin</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Neighbor_search::iterator<sp/>it<sp/>=<sp/>search.begin();<sp/>it<sp/>!=<sp/>search.end();<sp/>++it){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>it-&gt;first<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundations_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Algebraic_foundations.tag">std::sqrt</ref>(it-&gt;second)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1Spatial_searchingExampleforWorstCaseScenarios">
<title>Example for Worst-Case Scenarios for Different Splitters</title>
<para>This example program has two 2-dimensional data sets: The first one containing collinear points with exponential increasing distances and the second one with collinear points in the firstdimension and one point with a distance exceeding the spread of the other points in the second dimension. These are the worst cases for the midpoint/median rules and can also occur in higher dimensions.</para><para><linebreak/>
<bold>File</bold> <ref refid="Spatial_searching_2splitter_worst_cases_8cpp-example" kindref="compound">Spatial_searching/splitter_worst_cases.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Search_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Search__traits__2" kindref="compound">CGAL::Search_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Sliding__midpoint" kindref="compound">CGAL::Sliding_midpoint&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Sliding_midpoint;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Median__of__rectangle" kindref="compound">CGAL::Median_of_rectangle&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Median_of_rectangle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Euclidean__distance" kindref="compound">CGAL::Euclidean_distance&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Distance;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search" kindref="compound">CGAL::Orthogonal_k_neighbor_search&lt;Traits_2,Distance,Sliding_midpoint&gt;</ref><sp/><sp/><sp/><sp/><sp/>Neighbor_search_sliding;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Orthogonal__k__neighbor__search" kindref="compound">CGAL::Orthogonal_k_neighbor_search&lt;Traits_2,Distance,Median_of_rectangle&gt;</ref><sp/><sp/>Neighbor_search_median;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Neighbor_search_sliding::Tree<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tree_sliding;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Neighbor_search_median::Tree<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tree_median;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Points;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Points<sp/>sliding_worst_case;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0<sp/>,j<sp/>=<sp/>1;<sp/>i<sp/>&lt;<sp/>10<sp/>;<sp/>++i<sp/>,<sp/>j<sp/>*=<sp/>2){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sliding_worst_case.push_back(Point_2(((</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)i)/10<sp/>,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sliding_worst_case.push_back(Point_2(<sp/>(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)j<sp/>,<sp/>0));<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sliding_midpoint<sp/>sliding(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Median_of_rectangle<sp/>median(10);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree_sliding<sp/>tree1(sliding_worst_case.begin(),<sp/>sliding_worst_case.end()<sp/>,<sp/>sliding);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree1.build();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Worst<sp/>case<sp/>tree<sp/>for<sp/>Sliding<sp/>midpoint<sp/>and<sp/>Midpoint<sp/>of<sp/>max<sp/>spread<sp/>:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree1.statistics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree1.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;std::endl&lt;&lt;</highlight><highlight class="stringliteral">&quot;Same<sp/>data<sp/>with<sp/>median<sp/>splitter:&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree_median<sp/>tree2(sliding_worst_case.begin(),<sp/>sliding_worst_case.end()<sp/>,<sp/>median<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree2.statistics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree2.clear();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Points<sp/>median_worst_case;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0<sp/>;<sp/>i<sp/>&lt;<sp/>19<sp/>;<sp/>++i){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>median_worst_case.push_back(Point_2(<sp/>0<sp/>,<sp/>i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>median_worst_case.push_back(Point_2(20,0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree_median<sp/>tree3(median_worst_case.begin()<sp/>,<sp/>median_worst_case.end()<sp/>,<sp/>median);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree3.build();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;std::endl&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Worst<sp/>case<sp/>tree<sp/>for<sp/>Median<sp/>of<sp/>rectangle,<sp/>Median<sp/>of<sp/>max<sp/>spread<sp/>:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree3.statistics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree3.clear();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;std::endl&lt;&lt;</highlight><highlight class="stringliteral">&quot;Same<sp/>data<sp/>with<sp/>midpoint<sp/>splitter:&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tree_sliding<sp/>tree4(median_worst_case.begin()<sp/>,<sp/>median_worst_case.end()<sp/>,<sp/>sliding);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree4.build();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree4.statistics(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tree4.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1Performance">
<title>Performance</title>
<sect2 id="index_1OrthogonalPerfomance">
<title>Performance of the Orthogonal Search</title>
<para>We took the gargoyle data set (Surface) from aim@shape, and generated the same number of random points in the bbox of the gargoyle (Random). We then consider three scenarios as data/queries. The data set contains 800K points. For each query point we compute the K=10,20,30 closest points, with the default splitter and for the bucket size 10 (default) and 20.</para><para>The results were produced with the release 4.6 of CGAL, on an Intel i7 2.7 Ghz laptop with 16 GB RAM, compiled with Visual C++ 2012 with the /O2 option.</para><para>The values are the average of ten tests each.</para><para><center> <table rows="7" cols="5"><row>
<entry thead="yes"><para>k </para></entry><entry thead="yes"><para>bucket size </para></entry><entry thead="yes"><para>Surface/Surface </para></entry><entry thead="yes"><para>Surface/Random </para></entry><entry thead="yes"><para>Random/Random  </para></entry></row>
<row>
<entry thead="no"><para>10</para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>0.89 </para></entry><entry thead="no"><para>11.48 </para></entry><entry thead="no"><para>2.63 </para></entry></row>
<row>
<entry thead="no"><para>10</para></entry><entry thead="no"><para>20 </para></entry><entry thead="no"><para>0.89 </para></entry><entry thead="no"><para>9.80 </para></entry><entry thead="no"><para>2.25 </para></entry></row>
<row>
<entry thead="no"><para>20</para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>1.60 </para></entry><entry thead="no"><para>13.41 </para></entry><entry thead="no"><para>4.06 </para></entry></row>
<row>
<entry thead="no"><para>20</para></entry><entry thead="no"><para>20 </para></entry><entry thead="no"><para>1.59 </para></entry><entry thead="no"><para>11.62 </para></entry><entry thead="no"><para>3.46 </para></entry></row>
<row>
<entry thead="no"><para>30</para></entry><entry thead="no"><para>10 </para></entry><entry thead="no"><para>2.35 </para></entry><entry thead="no"><para>15.52 </para></entry><entry thead="no"><para>5.42 </para></entry></row>
<row>
<entry thead="no"><para>30</para></entry><entry thead="no"><para>20 </para></entry><entry thead="no"><para>2.33 </para></entry><entry thead="no"><para>13.50 </para></entry><entry thead="no"><para>4.61 </para></entry></row>
</table>
</center></para><para><anchor id="index_1fig__Spatial_searchingfigbenchmark"/><image type="html" name="gargoyle.png"></image>
 <image type="latex" name="gargoyle.png" width="15cm"></image>
  <ref refid="index_1fig__Spatial_searchingfigbenchmark" kindref="member">fig__Spatial_searchingfigbenchmark</ref> Benchmark dataset (downsampled for visualization).<linebreak/>
Blue: Gargoyle surface. Green: Gargoyle bbox random.  <linebreak/>
</para></sect2>
</sect1>
<sect1 id="index_1Spatial_searchingSoftware">
<title>Software Design</title>
<sect2 id="index_1Kd_tree_subsection">
<title>The kd Tree</title>
<para>Bentley <ref refid="citelist_1CITEREF_b-mbstu-75" kindref="member">[3]</ref> introduced the <computeroutput>kd</computeroutput> tree as a generalization of the binary search tree in higher dimensions. <computeroutput>kd</computeroutput> trees hierarchically decompose space into a relatively small number of rectangles such that no rectangle contains too many input objects. For our purposes, a <emphasis>rectangle</emphasis> in real <computeroutput>d</computeroutput> dimensional space, <formula id="44">$ \mathbb{R}^d$</formula>, is the product of <computeroutput>d</computeroutput> closed intervals on the coordinate axes. <computeroutput>kd</computeroutput> trees are obtained by partitioning point sets in <formula id="44">$ \mathbb{R}^d$</formula> using <computeroutput>(d-1)</computeroutput>-dimensional hyperplanes. Each node in the tree is split into two children by one such separating hyperplane. Several splitting rules (see Section <ref refid="index_1Spatial_SearchingSplitting_rule_section" kindref="member">Splitting Rules</ref> can be used to compute a separating <computeroutput>(d-1)</computeroutput>-dimensional hyperplane.</para><para>Each internal node of the <computeroutput>kd</computeroutput> tree is associated with a rectangle and a hyperplane orthogonal to one of the coordinate axis, which splits the rectangle into two parts. Therefore, such a hyperplane, defined by a splitting dimension and a splitting value, is called a separator. These two parts are then associated with the two child nodes in the tree. The process of partitioning space continues until the number of data points in the rectangle falls below some given threshold. The rectangles associated with the leaf nodes are called <emphasis>buckets</emphasis>, and they define a subdivision of the space into rectangles. Data points are only stored in the leaf nodes of the tree, not in the internal nodes.</para><para>Friedmann, Bentley and Finkel <ref refid="citelist_1CITEREF_fbf-afbml-77" kindref="member">[4]</ref> described the standard search algorithm to find the <computeroutput>k</computeroutput>th nearest neighbor by searching a <computeroutput>kd</computeroutput> tree recursively.</para><para>When encountering a node of the tree, the algorithm first visits the child that is closest to the query point. On return, if the rectangle containing the other child lies within 1/ (1+ <formula id="6">$ \epsilon$</formula>) times the distance to the <computeroutput>k</computeroutput>th nearest neighbors so far, then the other child is visited recursively. Priority search <ref refid="citelist_1CITEREF_am-annqf-93" kindref="member">[2]</ref> visits the nodes in increasing order of distance from the queue with help of a priority queue. The search stops when the distance of the query point to the nearest nodes exceeds the distance to the nearest point found with a factor 1/ (1+ <formula id="6">$ \epsilon$</formula>). Priority search supports next neighbor search, standard search does not.</para><para>In order to speed-up the internal distance computations in nearest neighbor searching in high dimensional space, the approximate searching package supports orthogonal distance computation. Orthogonal distance computation implements the efficient incremental distance computation technique introduced by Arya and Mount <ref refid="citelist_1CITEREF_am-afvq-93" kindref="member">[1]</ref>. This technique works only for neighbor queries with query items represented as points and with a quadratic form distance, defined by <formula id="45">$ d_A(x,y)= (x-y)A(x-y)^T$</formula>, where the matrix <formula id="46">$ A$</formula> is positive definite, i.e. <formula id="47">$ d_A(x,y) \geq 0$</formula>. An important class of quadratic form distances are weighted Minkowski distances. Given a parameter <formula id="48">$ p&gt;0$</formula> and parameters <formula id="49">$ w_i \geq 0, 0 &lt; i \leq d$</formula>, the weighted Minkowski distance is defined by <formula id="13">$ l_p(w)(r,q)= ({\Sigma_{i=1}^{i=d} \, w_i(r_i-q_i)^p})^{1/p}$</formula> for <formula id="14">$ 0 &lt; p &lt;\infty$</formula> and defined by <formula id="15">$ l_{\infty}(w)(r,q)=max \{w_i |r_i-q_i| \mid 1 \leq i \leq d\}$</formula>. The Manhattan distance ( <formula id="50">$ p=1$</formula>, <formula id="51">$ w_i=1$</formula>) and the Euclidean distance ( <formula id="52">$ p=2$</formula>, <formula id="51">$ w_i=1$</formula>) are examples of a weighted Minkowski metric.</para><para>To speed up distance computations also transformed distances are used instead of the distance itself. For instance for the Euclidean distance, to avoid the expensive computation of square roots, squared distances are used instead of the Euclidean distance itself.</para></sect2>
</sect1>
<sect1 id="index_1Spatial_searchingImplementationHistory">
<title>Implementation History</title>
<para>The initial implementation of this package was done by Hans Tangelder and Andreas Fabri. It was optimized in speed and memory consumption by Markus Overtheil during an internship at GeometryFactory in 2014. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
