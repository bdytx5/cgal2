<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Spatial_searching/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - dD Spatial Searching: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - dD Spatial Searching
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_dD_Spatial_Searching"></a><a class="anchor" id="ChapterUserSpatialSearching"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Hans Tangelder and Andreas Fabri</dd></dl>
<h1><a class="anchor" id="Spatial_searchingIntroduction"></a>
Introduction</h1>
<p>The spatial searching package implements exact and approximate distance browsing by providing implementations of algorithms supporting</p>
<ul>
<li>
<p class="startli">both nearest and furthest neighbor searching</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">both exact and approximate searching</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">(approximate) range searching</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">(approximate) <code>k</code>-nearest and <code>k</code>-furthest neighbor searching</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">(approximate) incremental nearest and incremental furthest neighbor searching</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">query items representing points and spatial objects.</p>
<p class="endli"></p>
</li>
</ul>
<p>In these searching problems a set <code>P</code> of data points in <code>d</code>-dimensional space is given. The points can be represented by Cartesian coordinates or homogeneous coordinates. These points are preprocessed into a tree data structure, so that given any query item <code>q</code> the points of <code>P</code> can be browsed efficiently. The approximate spatial searching package is designed for data sets that are small enough to store the search structure in main memory (in contrast to approaches from databases that assume that the data reside in secondary storage).</p>
<h2><a class="anchor" id="Spatial_searchingNeighborSearching"></a>
Neighbor Searching</h2>
<p>Spatial searching supports browsing through a collection of <code>d</code>-dimensional spatial objects stored in a spatial data structure on the basis of their distances to a query object. The query object may be a point or an arbitrary spatial object, e.g, a <code>d</code>-dimensional sphere. The objects in the spatial data structure are <code>d</code>-dimensional points.</p>
<p>Often the number of the neighbors to be computed is not know beforehand, e.g., because the number may depend on some properties of the neighbors (for example when querying for the nearest city to Paris with population greater than a million) or the distance to the query point. The conventional approach is <code>k</code>-nearest neighbor searching that makes use of a <code>k</code>-nearest neighbor algorithm, where <code>k</code> is known prior to the invocation of the algorithm. Hence, the number of nearest neighbors has to be guessed. If the guess is too large redundant computations are performed. If the number is too small the computation has to be re-invoked for a larger number of neighbors, thereby performing redundant computations. Therefore, Hjaltason and Samet <a class="el" href="citelist.html#CITEREF_hs-rsd-95">[5]</a> introduced <em>incremental nearest neighbor searching</em> in the sense that having obtained the <code>k</code> nearest neighbors, the <code>k + 1</code>st neighbor can be obtained without having to calculate the <code>k + 1</code> nearest neighbor from scratch.</p>
<p>Spatial searching typically consists of a preprocessing phase and a searching phase. In the preprocessing phase one builds a search structure and in the searching phase one makes the queries. In the preprocessing phase the user builds a tree data structure storing the spatial data. In the searching phase the user invokes a searching method to browse the spatial data.</p>
<p>With relatively minor modifications, nearest neighbor searching algorithms can be used to find the furthest object from the query object. Therefore, <em>furthest neighbor searching</em> is also supported by the spatial searching package.</p>
<p>The execution time for exact neighbor searching can be reduced by relaxing the requirement that the neighbors should be computed exactly. If the distances of two objects to the query object are approximately the same, instead of computing the nearest/furthest neighbor exactly, one of these objects may be returned as the approximate nearest/furthest neighbor. I.e., given some non-negative constant \( \epsilon\) the distance of an object returned as an approximate <code>k</code>-nearest neighbor must not be larger than \( (1+\epsilon)r\), where \( r\) denotes the distance to the real <code>k</code>th nearest neighbor. Similar the distance of an approximate <code>k</code>-furthest neighbor must not be smaller than \( r/(1+\epsilon)\). Obviously, for \( \epsilon=0\) we get the exact result, and the larger \( \epsilon\) is, the less exact the result.</p>
<p>While searching the nearest neighbor the algorithm descends the kd-tree and has to decide two things for each node : Which child node should be visited first and could there be possible nearest neighbors in the other child. This basically comes down to computing the distance to the further child, because the distance to the closer child is the same as the one to the parent. There are two options now:<br />
</p><ol type="1">
<li>In general, we compute the distance with the given metric. This is the <em>k-neighbor search</em> with a <em>general distance</em> class.</li>
<li>For point queries we can "update" the distance, because it is only changed in one dimension at a time. This is the <em>orthogonal k-neighbor search</em> with an <em>orthogonal distance</em> class. The following example shows the orthogonal distance computation in detail:</li>
</ol>
<p><a class="anchor" id="fig__Spatial_searchingorthogonaldistance"></a></p><div class="image">
<object type="image/svg+xml" data="orthogonalDistance.svg">orthogonalDistance.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Spatial_searchingorthogonaldistance">Figure 78.1</a> Orthogonal distance computation technique  </div>  <br />

<p>Assume we are searching the nearest neighbor, descending the kd-tree, with \( R_{p} \) as the parent rectangle and \( R_{lo} \) and \( R_{hi}\) as its childs in the current step. Further assume \( R_{lo} \) is closer to query point \(q\). Let \(cd\) denote the cutting dimension and let \(cv\) denote the cutting value. At this point we already know the distance \(rd_{p}\) to the parent rectangle and need to check if \(R_{hi}\) could contain nearest neighbors. Because \(R_{lo}\) is the closer rectangle, its distance to \(q\), \(rd_{lo}\), is the same as \(rd_{p}\). Notice that for each dimension \(i \neq cd \), \( \mathrm{dists}_{lo}[i] = \mathrm{dists}_{hi}[i]\), since these coordinates are not affected by the current cut. So the new distance along the cutting dimension is \( \mathrm{dists}_{hi}[cd] = cv - q[cd]\). Now we can compute \(rd_{hi}\) in constant time (independent of dimension) with \(rd_{hi} = rd_{p} - \mathrm{dists}_{lo}[cd]^2 + (cv - q[cd])^2\).<br />
 This strategy can be used if and only if the distance changes only in one dimension at a time, which is the case for point queries.</p>
<p>The following two classes implement the standard search strategy for orthogonal distances like the weighted Minkowski distance. The second one is a specialization for incremental neighbor searching and distance browsing. Both require extendes nodes.</p>
<p><code><a class="el" href="classCGAL_1_1Orthogonal__k__neighbor__search.html" title="The class Orthogonal_k_neighbor_search implements approximatek-nearest and k-furthest neighbor search...">Orthogonal_k_neighbor_search</a>&lt;Traits, <a class="el" href="classOrthogonalDistance.html" title="Requirements of an orthogonal distance class supporting incremental distance updates. To optimize distance computations transformed distances are used. E.g., for an Euclidean distance the transformed distance is the squared Euclidean distance. ">OrthogonalDistance</a>, <a class="el" href="classSplitter.html" title=" &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; The concept Splitter defines the requirements for a f...">Splitter</a>, <a class="el" href="classSpatialTree.html" title="The concept SpatialTree defines the requirements for a tree supporting both neighbor searching and ap...">SpatialTree</a>&gt;</code></p>
<p><code><a class="el" href="classCGAL_1_1Orthogonal__incremental__neighbor__search.html" title="The class Orthogonal_incremental_neighbor_search implements incremental nearest and furthest neighbor...">Orthogonal_incremental_neighbor_search</a>&lt;Traits, <a class="el" href="classOrthogonalDistance.html" title="Requirements of an orthogonal distance class supporting incremental distance updates. To optimize distance computations transformed distances are used. E.g., for an Euclidean distance the transformed distance is the squared Euclidean distance. ">OrthogonalDistance</a>, <a class="el" href="classSplitter.html" title=" &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; The concept Splitter defines the requirements for a f...">Splitter</a>, <a class="el" href="classSpatialTree.html" title="The concept SpatialTree defines the requirements for a tree supporting both neighbor searching and ap...">SpatialTree</a>&gt;</code></p>
<p>The other two classes implement the standard search strategy for general distances like the Manhattan distance for iso-rectangle queries. Again, the second one is a specialization for incremental neighbor searching and distance browsing .</p>
<p><code><a class="el" href="classCGAL_1_1K__neighbor__search.html" title="The class K_neighbor_search implements approximate k-nearest and k-furthest neighbor searching using ...">K_neighbor_search</a>&lt;Traits, <a class="el" href="classGeneralDistance.html" title="Requirements of a distance class defining a distance between a query item denoting a spatial object a...">GeneralDistance</a>, <a class="el" href="classSplitter.html" title=" &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; The concept Splitter defines the requirements for a f...">Splitter</a>, <a class="el" href="classSpatialTree.html" title="The concept SpatialTree defines the requirements for a tree supporting both neighbor searching and ap...">SpatialTree</a>&gt;</code></p>
<p><code><a class="el" href="classCGAL_1_1Incremental__neighbor__search.html" title="The class Incremental_neighbor_search implements incremental nearest and furthest neighbor searching ...">Incremental_neighbor_search</a>&lt;Traits, <a class="el" href="classGeneralDistance.html" title="Requirements of a distance class defining a distance between a query item denoting a spatial object a...">GeneralDistance</a>, <a class="el" href="classSplitter.html" title=" &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; The concept Splitter defines the requirements for a f...">Splitter</a>, <a class="el" href="classSpatialTree.html" title="The concept SpatialTree defines the requirements for a tree supporting both neighbor searching and ap...">SpatialTree</a>&gt;</code></p>
<h2><a class="anchor" id="Spatial_searchingRangeSearching"></a>
Range Searching</h2>
<p><em>Exact range searching</em> and <em>approximate range searching</em> are supported using exact or fuzzy <code>d</code>-dimensional objects enclosing a region. The fuzziness of the query object is specified by a parameter \( \epsilon\) used to define <em>inner</em> and <em>outer</em> approximations of the object. For example, in the class <code><a class="el" href="classCGAL_1_1Fuzzy__sphere.html" title="The class Fuzzy_sphere implements fuzzy d-dimensional spheres. ">Fuzzy_sphere</a></code>, the \( \epsilon\)-inner and outer approximations of a sphere of radius \( r\) are defined as the spheres of radius \( r-\epsilon\) and \( r+\epsilon\), respectively. When using fuzzy items, queries are reported as follows:</p><ul>
<li>Points that are within the inner approximation are always reported.</li>
<li>Points that are within the outer approximation but not within the inner approximation might or might not be reported.</li>
<li>Points thare not within the outer approximation are never reported.</li>
</ul>
<p>For exact range searching the fuzziness parameter \( \epsilon\) is set to zero.</p>
<p>The class <code><a class="el" href="classCGAL_1_1Kd__tree.html" title="The class Kd_tree defines a k-d tree. ">Kd_tree</a></code> implements range searching in the method <code>search</code>, which is a template method with an output iterator and a model of the concept <code><a class="el" href="classFuzzyQueryItem.html" title="The concept FuzzyQueryItem describes the requirements for fuzzy d-dimensional spatial objects...">FuzzyQueryItem</a></code> such as <code><a class="el" href="classCGAL_1_1Fuzzy__iso__box.html" title="The class Fuzzy_iso_box implements fuzzy d-dimensional (closed) iso boxes. ">Fuzzy_iso_box</a></code> or <code><a class="el" href="classCGAL_1_1Fuzzy__sphere.html" title="The class Fuzzy_sphere implements fuzzy d-dimensional spheres. ">Fuzzy_sphere</a></code>. For range searching of large data sets, the user may set the parameter <code>bucket_size</code> used in building the <code>kd</code> tree to a large value (e.g. 100), because in general the query time will be less than using the default value.</p>
<h1><a class="anchor" id="Spatial_SearchingSplitting_rule_section"></a>
Splitting Rules</h1>
<p>Instead of using the default splitting rule <code><a class="el" href="classCGAL_1_1Sliding__midpoint.html" title="Implements the sliding midpoint splitting rule. ">Sliding_midpoint</a></code> described below, a user may, depending upon the data, select one from the following splitting rules, which determine how a separating hyperplane is computed. Every splitter has degenerated worst cases, which may lead to a linear tree and a stack overflow. Switching the splitting rule to one of a different kind will solve the problem.</p>
<dl>
<dt><b> <code><a class="el" href="classCGAL_1_1Midpoint__of__rectangle.html" title="Implements the midpoint of rectangle splitting rule. ">Midpoint_of_rectangle</a></code></b></dt>
<dd><p class="startdd"></p>
<p>This splitting rule cuts a rectangle through its midpoint orthogonal to the longest side.</p>
<p class="enddd"></p>
</dd>
<dt><b> <code><a class="el" href="classCGAL_1_1Midpoint__of__max__spread.html" title="Implements the midpoint of max spread splitting rule. ">Midpoint_of_max_spread</a></code></b></dt>
<dd><p class="startdd"></p>
<p>This splitting rule cuts a rectangle through \( (\mathrm{Mind}+\mathrm{Maxd})/2\) orthogonal to the dimension with the maximum point spread \( [\mathrm{Mind},\mathrm{Maxd}]\).</p>
<p class="enddd"></p>
</dd>
<dt><b> <code><a class="el" href="classCGAL_1_1Sliding__midpoint.html" title="Implements the sliding midpoint splitting rule. ">Sliding_midpoint</a></code></b></dt>
<dd><p class="startdd"></p>
<p class="enddd">This is a modification of the midpoint of rectangle splitting rule. It first attempts to perform a midpoint of rectangle split as described above. If data points lie on both sides of the separating plane the sliding midpoint rule computes the same separator as the midpoint of rectangle rule. If the data points lie only on one side it avoids this by sliding the separator, computed by the midpoint of rectangle rule, to the nearest data point. </p>
</dd>
</dl>
<p>As all the midpoint rules cut the bounding box in the middle of the longest side, the tree will become linear for a dataset with exponential increasing distances in one dimension.</p>
<p><a class="anchor" id="fig__Spatial_searchingslidingworstcase"></a></p><div class="image">
<img src="Sliding_worst_case.jpg" alt="Sliding_worst_case.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Spatial_searchingslidingworstcase">Figure 78.2</a> Midpoint worst case point set in 2d.  </div>  <br />

<dl>
<dt><b> <code><a class="el" href="classCGAL_1_1Median__of__rectangle.html" title="Implements the median of rectangle splitting rule. ">Median_of_rectangle</a></code></b></dt>
<dd><p class="startdd"></p>
<p>The splitting dimension is the dimension of the longest side of the rectangle. The splitting value is defined by the median of the coordinates of the data points along this dimension.</p>
<p class="enddd"></p>
</dd>
<dt><b> <code><a class="el" href="classCGAL_1_1Median__of__max__spread.html" title="Implements the median of max spread splitting rule. ">Median_of_max_spread</a></code></b></dt>
<dd><p class="startdd"></p>
<p class="enddd">The splitting dimension is the dimension of the longest side of the rectangle. The splitting value is defined by the median of the coordinates of the data points along this dimension. </p>
</dd>
</dl>
<p>The tree can become linear for the median rules, if many points are collinear in a dimension which is not the cutting dimension. <a class="anchor" id="fig__Spatial_searchingmedianworstcase"></a></p><div class="image">
<img src="Median_worst_case.jpg" alt="Median_worst_case.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Spatial_searchingmedianworstcase">Figure 78.3</a> Median worst case point set in 2d.<br />
a is longer than b, so this will be the cutting dimension.  </div>  <br />

<dl>
<dt><b> <code><a class="el" href="classCGAL_1_1Fair.html" title="Implements the fair splitting rule. ">Fair</a></code></b></dt>
<dd><p class="startdd"></p>
<p>This splitting rule is a compromise between the median of rectangle splitting rule and the midpoint of rectangle splitting rule. This splitting rule maintains an upper bound on the maximal allowed ratio of the longest and shortest side of a rectangle (the value of this upper bound is set in the constructor of the fair splitting rule). Among the splits that satisfy this bound, it selects the one in which the points have the largest spread. It then splits the points in the most even manner possible, subject to maintaining the bound on the ratio of the resulting rectangles.</p>
<p class="enddd"></p>
</dd>
<dt><b> <code><a class="el" href="classCGAL_1_1Sliding__fair.html" title="Implements the sliding fair splitting rule. ">Sliding_fair</a></code></b></dt>
<dd><p class="startdd"></p>
<p>This splitting rule is a compromise between the fair splitting rule and the sliding midpoint rule. Sliding fair-split is based on the theory that there are two types of splits that are good: balanced splits that produce fat rectangles, and unbalanced splits provided the rectangle with fewer points is fat.</p>
<p>Also, this splitting rule maintains an upper bound on the maximal allowed ratio of the longest and shortest side of a rectangle (the value of this upper bound is set in the constructor of the fair splitting rule). Among the splits that satisfy this bound, it selects the one one in which the points have the largest spread. It then considers the most extreme cuts that would be allowed by the aspect ratio bound. This is done by dividing the longest side of the rectangle by the aspect ratio bound. If the median cut lies between these extreme cuts, then we use the median cut. If not, then consider the extreme cut that is closer to the median. If all the points lie to one side of this cut, then we slide the cut until it hits the first point. This may violate the aspect ratio bound, but will never generate empty cells.</p>
<p class="enddd"></p>
</dd>
</dl>
<h1><a class="anchor" id="Spatial_searchingExample"></a>
Example Programs</h1>
<p>We give seven examples. The first example illustrates k nearest neighbor searching, and the second example incremental neighbor searching. The third is an example of approximate furthest neighbor searching using a <code>d</code>-dimensional iso-rectangle as an query object. Approximate range searching is illustrated by the fourth example. The fifth example illustrates k neighbor searching for a user defined point class. The sixth example shows how to choose another splitting rule in the <code>kd</code> tree that is used as search tree. The last example shows two worst-case scenarios for different splitter types.</p>
<h2><a class="anchor" id="Spatial_searchingExampleforKNeighborSearching"></a>
Example for K Neighbor Searching</h2>
<p>The first example illustrates k neighbor searching with an Euclidean distance and 2-dimensional points. The generated random data points are inserted in a search tree. We then initialize the k neighbor search object with the origin as query. Finally, we obtain the result of the computation in the form of an iterator range. The value of the iterator is a pair of a point and its square distance to the query point. We use square distances, or <em>transformed distances</em> for other distance classes, as they are computationally cheaper.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2nearest_neighbor_searching_8cpp-example.html">Spatial_searching/nearest_neighbor_searching.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2 Point_d;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__2.html">CGAL::Search_traits_2&lt;K&gt;</a> TreeTraits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Orthogonal__k__neighbor__search.html">CGAL::Orthogonal_k_neighbor_search&lt;TreeTraits&gt;</a> Neighbor_search;</div><div class="line"><span class="keyword">typedef</span> Neighbor_search::Tree Tree;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = 1;</div><div class="line"></div><div class="line">  std::list&lt;Point_d&gt; points;</div><div class="line">  points.push_back(Point_d(0,0));</div><div class="line"></div><div class="line">  Tree tree(points.begin(), points.end());</div><div class="line"></div><div class="line">  Point_d query(0,0);</div><div class="line"></div><div class="line">  <span class="comment">// Initialize the search structure, and search all N points</span></div><div class="line"></div><div class="line">  Neighbor_search search(tree, query, N);</div><div class="line"></div><div class="line">   <span class="comment">// report the N nearest neighbors and their distance</span></div><div class="line">  <span class="comment">// This should sort all N points by increasing distance from origin</span></div><div class="line">  <span class="keywordflow">for</span>(Neighbor_search::iterator it = search.begin(); it != search.end(); ++it){</div><div class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">" "</span>&lt;&lt; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(it-&gt;second) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Spatial_searchingExampleforIncrementalSearching"></a>
Example for Incremental Searching</h2>
<p>This example program illustrates incremental searching for the closest point with a positive first coordinate. We can use the orthogonal incremental neighbor search class, as the query is also a point and as the distance is the Euclidean distance.</p>
<p>As for the <code>k</code> neighbor search, we first initialize the search tree with the data. We then create the search object, and finally obtain the iterator with the <code>begin()</code> method. Note that the iterator is of the input iterator category, that is one can make only one pass over the data.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2distance_browsing_8cpp-example.html">Spatial_searching/distance_browsing.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Orthogonal_incremental_neighbor_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2 Point_d;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__2.html">CGAL::Search_traits_2&lt;K&gt;</a> TreeTraits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Orthogonal__incremental__neighbor__search.html">CGAL::Orthogonal_incremental_neighbor_search&lt;TreeTraits&gt;</a> NN_incremental_search;</div><div class="line"><span class="keyword">typedef</span> NN_incremental_search::iterator NN_iterator;</div><div class="line"><span class="keyword">typedef</span> NN_incremental_search::Tree Tree;</div><div class="line"></div><div class="line"><span class="comment">// A functor that returns true, iff the x-coordinate of a dD point is not positive</span></div><div class="line"><span class="keyword">struct </span>X_not_positive {</div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> NN_iterator&amp; it) { <span class="keywordflow">return</span> ((*it).first)[0]&lt;0;  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// An iterator that only enumerates dD points with positive x-coordinate</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Filter__iterator.html">CGAL::Filter_iterator&lt;NN_iterator, X_not_positive&gt;</a> NN_positive_x_iterator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Tree tree;</div><div class="line">  tree.insert(Point_d(0,0));</div><div class="line">  tree.insert(Point_d(1,1));</div><div class="line">  tree.insert(Point_d(0,1));</div><div class="line">  tree.insert(Point_d(10,110));</div><div class="line">  tree.insert(Point_d(45,0));</div><div class="line">  tree.insert(Point_d(0,2340));</div><div class="line">  tree.insert(Point_d(0,30));</div><div class="line"></div><div class="line">  Point_d query(0,0);</div><div class="line"></div><div class="line">  NN_incremental_search NN(tree, query);</div><div class="line">  NN_positive_x_iterator it(NN.end(), X_not_positive(), NN.begin()), end(NN.end(), X_not_positive());</div><div class="line"></div><div class="line">  std::cout &lt;&lt;  <span class="stringliteral">"The first 5 nearest neighbours with positive x-coord are: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; (j &lt; 5)&amp;&amp;(it!=end); ++j,++it)</div><div class="line">    std::cout &lt;&lt;   (*it).first &lt;&lt; <span class="stringliteral">"  at squared distance = "</span> &lt;&lt; (*it).second &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Spatial_searchingExampleforGeneralNeighbor"></a>
Example for General Neighbor Searching</h2>
<p>This example program illustrates approximate nearest and furthest neighbor searching using 4-dimensional Cartesian coordinates. Five approximate furthest neighbors of the query rectangle \( [0.1,0.2]^4\) are computed. Because the query object is a rectangle we cannot use the orthogonal neighbor search. As in the previous examples we first initialize a search tree, create the search object with the query, and obtain the result of the search as iterator range.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2general_neighbor_searching_8cpp-example.html">Spatial_searching/general_neighbor_searching.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Epick_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Manhattan_distance_iso_box_point.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/K_neighbor_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_d.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/structCGAL_1_1Epick__d.html">CGAL::Epick_d&lt;CGAL::Dimension_tag&lt;4&gt;</a> &gt; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> Kernel::Point_d Point_d;</div><div class="line"><span class="keyword">typedef</span> CGAL::Random_points_in_cube_d&lt;Point_d&gt; Random_points_iterator;</div><div class="line"><span class="keyword">typedef</span> Kernel::Iso_box_d Iso_box_d;</div><div class="line"><span class="keyword">typedef</span> Kernel TreeTraits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Manhattan__distance__iso__box__point.html">CGAL::Manhattan_distance_iso_box_point&lt;TreeTraits&gt;</a> Distance;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1K__neighbor__search.html">CGAL::K_neighbor_search&lt;TreeTraits, Distance&gt;</a> Neighbor_search;</div><div class="line"><span class="keyword">typedef</span> Neighbor_search::Tree Tree;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span>  main() {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 1000;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> K = 10;</div><div class="line"></div><div class="line">  Tree tree;</div><div class="line">  Random_points_iterator rpit(4,1000.0);</div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; N; i++){</div><div class="line">    tree.insert(*rpit++);</div><div class="line">  }</div><div class="line">  Point_d pp(0.1,0.1,0.1,0.1);</div><div class="line">  Point_d qq(0.2,0.2,0.2,0.2);</div><div class="line">  Iso_box_d query(pp,qq);</div><div class="line"></div><div class="line">  Distance tr_dist;</div><div class="line">  Neighbor_search N1(tree, query, 5, 10.0, <span class="keyword">false</span>); <span class="comment">// eps=10.0, nearest=false</span></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"For query rectangle = [0.1, 0.2]^4 "</span> &lt;&lt; std::endl</div><div class="line">        &lt;&lt;  <span class="stringliteral">"the "</span> &lt;&lt; K &lt;&lt; <span class="stringliteral">" approximate furthest neighbors are: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (Neighbor_search::iterator it = N1.begin();it != N1.end();it++) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" Point "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">" at distance  "</span> &lt;&lt; tr_dist.inverse_of_transformed_distance(it-&gt;second) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Spatial_searchingExampleforaRangeQuery"></a>
Example for a Range Query</h2>
<p>This example program illustrates approximate range querying for 4-dimensional fuzzy iso-rectangles and spheres using the higher dimensional kernel <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/structCGAL_1_1Epick__d.html">Epick_d</a></code>. The range queries are member functions of the <code>kd</code> tree class.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2fuzzy_range_query_8cpp-example.html">Spatial_searching/fuzzy_range_query.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Epick_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_d.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Kd_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Fuzzy_sphere.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Fuzzy_iso_box.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_d.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> D = 4;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_d.tag:../Kernel_d/" href="../Kernel_d/structCGAL_1_1Epick__d.html">CGAL::Epick_d&lt;CGAL::Dimension_tag&lt;D&gt;</a> &gt; K;</div><div class="line"><span class="keyword">typedef</span> K::Point_d Point_d;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__d.html">CGAL::Search_traits_d&lt;K,CGAL::Dimension_tag&lt;D&gt;</a> &gt;  Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::Random_points_in_cube_d&lt;Point_d&gt;       Random_points_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Counting__iterator.html">CGAL::Counting_iterator&lt;Random_points_iterator&gt;</a> N_Random_points_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Kd__tree.html">CGAL::Kd_tree&lt;Traits&gt;</a> Tree;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Fuzzy__sphere.html">CGAL::Fuzzy_sphere&lt;Traits&gt;</a> Fuzzy_sphere;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Fuzzy__iso__box.html">CGAL::Fuzzy_iso_box&lt;Traits&gt;</a> Fuzzy_iso_box;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 1000;</div><div class="line">  <span class="comment">// generator for random data points in the square ( (-1000,-1000), (1000,1000) )</span></div><div class="line">  Random_points_iterator rpit(4, 1000.0);</div><div class="line"></div><div class="line">  <span class="comment">// Insert N points in the tree</span></div><div class="line">  Tree tree(N_Random_points_iterator(rpit,0),</div><div class="line">        N_Random_points_iterator(rpit,N));</div><div class="line"></div><div class="line">  <span class="comment">// define range query objects</span></div><div class="line">  <span class="keywordtype">double</span>  pcoord[D] = { 300, 300, 300, 300 };</div><div class="line">  <span class="keywordtype">double</span>  qcoord[D] = { 900.0, 900.0, 900.0, 900.0 };</div><div class="line">  Point_d p(D, pcoord+0, pcoord+D);</div><div class="line">  Point_d q(D, qcoord+0, qcoord+D);</div><div class="line">  Fuzzy_sphere fs(p, 700.0, 100.0);</div><div class="line">  Fuzzy_iso_box fib(p, q, 100.0);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"points approximately in fuzzy spherical range query"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"with center (300, 300, 300, 300)"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"and fuzzy radius [600, 800] are:"</span> &lt;&lt; std::endl;</div><div class="line">  tree.search(std::ostream_iterator&lt;Point_d&gt;(std::cout, <span class="stringliteral">"\n"</span>), fs);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"points approximately in fuzzy rectangular range query "</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"[[200, 400], [800,1000]]^4 are:"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  tree.search(std::ostream_iterator&lt;Point_d&gt;(std::cout, <span class="stringliteral">"\n"</span>), fib);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Spatial_searchingExampleforUserDefinedPoint"></a>
Example for User Defined Point and Distance Class</h2>
<p>The neighbor searching works with all <span style="font-variant: small-caps;">CGAL</span> kernels, as well as with user defined points and distance classes. In this example we assume that the user provides the following 3-dimensional points class.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2Point_8h-example.html">Spatial_searching/Point.h</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Point {</div><div class="line">  <span class="keywordtype">double</span> vec[3];</div><div class="line"></div><div class="line"></div><div class="line">  Point() { vec[0]= vec[1] = vec[2] = 0; }</div><div class="line">  Point (<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> z) { vec[0]=x; vec[1]=y; vec[2]=z;  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> x()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> vec[ 0 ]; }</div><div class="line">  <span class="keywordtype">double</span> y()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> vec[ 1 ]; }</div><div class="line">  <span class="keywordtype">double</span> z()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> vec[ 2 ]; }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>&amp; x() { <span class="keywordflow">return</span> vec[ 0 ]; }</div><div class="line">  <span class="keywordtype">double</span>&amp; y() { <span class="keywordflow">return</span> vec[ 1 ]; }</div><div class="line">  <span class="keywordtype">double</span>&amp; z() { <span class="keywordflow">return</span> vec[ 2 ]; }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> Point&amp; p)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (x() == p.x()) &amp;&amp; (y() == p.y()) &amp;&amp; (z() == p.z())  ;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span>  operator!=(<span class="keyword">const</span> Point&amp; p)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ! (*<span class="keyword">this</span> == p); }</div><div class="line">}; <span class="comment">//end of class</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Construct_coord_iterator {</div><div class="line">  <span class="keyword">typedef</span>  <span class="keyword">const</span> <span class="keywordtype">double</span>* result_type;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>* operator()(<span class="keyword">const</span> Point&amp; p)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(p.vec); }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>* operator()(<span class="keyword">const</span> Point&amp; p, <span class="keywordtype">int</span>)<span class="keyword">  const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(p.vec+3); }</div><div class="line">};</div></div><!-- fragment --><p>We have put the glue layer in this file as well, that is a class that allows to iterate over the Cartesian coordinates of the point, and a class to construct such an iterator for a point. We next need a distance class <br />
<b>File</b> <a class="el" href="Spatial_searching_2Distance_8h-example.html">Spatial_searching/Distance.h</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Distance {</div><div class="line">  <span class="keyword">typedef</span> Point Query_item;</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span> FT;</div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dimension__tag.html">CGAL::Dimension_tag&lt;3&gt;</a> D;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> transformed_distance(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordtype">double</span> distx= p1.x()-p2.x();</div><div class="line">    <span class="keywordtype">double</span> disty= p1.y()-p2.y();</div><div class="line">    <span class="keywordtype">double</span> distz= p1.z()-p2.z();</div><div class="line">    <span class="keywordflow">return</span> distx*distx+disty*disty+distz*distz;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> min_distance_to_rectangle(<span class="keyword">const</span> Point&amp; p,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classCGAL_1_1Kd__tree__rectangle.html">CGAL::Kd_tree_rectangle&lt;FT,D&gt;</a>&amp; b)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordtype">double</span> distance(0.0), h = p.x();</div><div class="line">    <span class="keywordflow">if</span> (h &lt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(0)) distance += (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(0)-h)*(b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(0)-h);</div><div class="line">    <span class="keywordflow">if</span> (h &gt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(0)) distance += (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(0))*(h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(0));</div><div class="line">    h=p.y();</div><div class="line">    <span class="keywordflow">if</span> (h &lt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(1)) distance += (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(1)-h)*(b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(1)-h);</div><div class="line">    <span class="keywordflow">if</span> (h &gt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(1)) distance += (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(1))*(h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(1));</div><div class="line">    h=p.z();</div><div class="line">    <span class="keywordflow">if</span> (h &lt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(2)) distance += (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(2)-h)*(b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(2)-h);</div><div class="line">    <span class="keywordflow">if</span> (h &gt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(2)) distance += (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(2))*(h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(2));</div><div class="line">    <span class="keywordflow">return</span> distance;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> min_distance_to_rectangle(<span class="keyword">const</span> Point&amp; p,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classCGAL_1_1Kd__tree__rectangle.html">CGAL::Kd_tree_rectangle&lt;FT,D&gt;</a>&amp; b,std::vector&lt;double&gt;&amp; dists){   </div><div class="line">    <span class="keywordtype">double</span> distance(0.0), h = p.x();</div><div class="line">    <span class="keywordflow">if</span> (h &lt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(0)){</div><div class="line">      dists[0] = (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(0)-h);</div><div class="line">      distance += dists[0]*dists[0];</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (h &gt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(0)){</div><div class="line">      dists[0] = (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(0));</div><div class="line">      distance += dists[0]*dists[0];</div><div class="line">    }</div><div class="line">    h=p.y();</div><div class="line">    <span class="keywordflow">if</span> (h &lt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(1)){</div><div class="line">      dists[1] = (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(1)-h);</div><div class="line">      distance += dists[1]*dists[1];</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (h &gt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(1)){</div><div class="line">      dists[1] = (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(1));</div><div class="line">      distance += dists[1]*dists[1];</div><div class="line">    }</div><div class="line">    h=p.z();</div><div class="line">    <span class="keywordflow">if</span> (h &lt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(2)){</div><div class="line">      dists[2] = (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(2)-h);</div><div class="line">      distance += dists[2]*dists[2];</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (h &gt; b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(2)){</div><div class="line">      dists[2] = (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(2));</div><div class="line">      distance += dists[2]*dists[2];</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> distance;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_distance_to_rectangle(<span class="keyword">const</span> Point&amp; p,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classCGAL_1_1Kd__tree__rectangle.html">CGAL::Kd_tree_rectangle&lt;FT,D&gt;</a>&amp; b)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordtype">double</span> h = p.x();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d0 = (h &gt;= (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(0)+b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(0))/2.0) ?</div><div class="line">                (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(0))*(h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(0)) : (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(0)-h)*(b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(0)-h);</div><div class="line"></div><div class="line">    h=p.y();</div><div class="line">    <span class="keywordtype">double</span> d1 = (h &gt;= (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(1)+b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(1))/2.0) ?</div><div class="line">                (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(1))*(h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(1)) : (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(1)-h)*(b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(1)-h);</div><div class="line">    h=p.z();</div><div class="line">    <span class="keywordtype">double</span> d2 = (h &gt;= (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(2)+b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(2))/2.0) ?</div><div class="line">                (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(2))*(h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(2)) : (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(2)-h)*(b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(2)-h);</div><div class="line">    <span class="keywordflow">return</span> d0 + d1 + d2;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_distance_to_rectangle(<span class="keyword">const</span> Point&amp; p,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classCGAL_1_1Kd__tree__rectangle.html">CGAL::Kd_tree_rectangle&lt;FT,D&gt;</a>&amp; b,std::vector&lt;double&gt;&amp; dists){   </div><div class="line">    <span class="keywordtype">double</span> h = p.x();</div><div class="line"></div><div class="line">    dists[0] = (h &gt;= (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(0)+b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(0))/2.0) ?</div><div class="line">                (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(0)) : (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(0)-h);</div><div class="line">    </div><div class="line">    h=p.y();</div><div class="line">    dists[1] = (h &gt;= (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(1)+b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(1))/2.0) ?</div><div class="line">                (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(1)) : (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(1)-h);</div><div class="line">    h=p.z();</div><div class="line">    dists[2] = (h &gt;= (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(2)+b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(2))/2.0) ?</div><div class="line">                (h-b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#ac23671b8977b090392b945483d788389">min_coord</a>(2)) : (b.<a class="code" href="classCGAL_1_1Kd__tree__rectangle.html#a7e2867b92e3f31a934c485b4a80f0156">max_coord</a>(2)-h);</div><div class="line">    <span class="keywordflow">return</span> dists[0] * dists[0] + dists[1] * dists[1] + dists[2] * dists[2];</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> new_distance(<span class="keywordtype">double</span>&amp; dist, <span class="keywordtype">double</span> old_off, <span class="keywordtype">double</span> new_off,</div><div class="line">              <span class="keywordtype">int</span> <span class="comment">/* cutting_dimension */</span>)<span class="keyword">  const </span>{</div><div class="line">    <span class="keywordflow">return</span> dist + new_off*new_off - old_off*old_off;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> transformed_distance(<span class="keywordtype">double</span> d)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d*d; }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> inverse_of_transformed_distance(<span class="keywordtype">double</span> d) { <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(d); }</div><div class="line"></div><div class="line">}; <span class="comment">// end of struct Distance</span></div></div><!-- fragment --><p>We are ready to put the pieces together. The class <code><a class="el" href="classCGAL_1_1Search__traits.html" title="The class Search_traits can be used as a template parameter of the kd tree and the search classes...">Search_traits</a>&lt;..&gt;</code> ,which you see in the next file, is a mere wrapper for all our defined types. The searching itself works exactly as for <span style="font-variant: small-caps;">CGAL</span> kernels.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2user_defined_point_and_distance_8cpp-example.html">Spatial_searching/user_defined_point_and_distance.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include "Point.h"</span>  <span class="comment">// defines types Point, Construct_coord_iterator</span></div><div class="line"><span class="preprocessor">#include "Distance.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Creator__uniform__3.html">CGAL::Creator_uniform_3&lt;double,Point&gt;</a> Point_creator;</div><div class="line"><span class="keyword">typedef</span> CGAL::Random_points_in_cube_3&lt;Point, Point_creator&gt; Random_points_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Counting__iterator.html">CGAL::Counting_iterator&lt;Random_points_iterator&gt;</a> N_Random_points_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dimension__tag.html">CGAL::Dimension_tag&lt;3&gt;</a> D;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits.html">CGAL::Search_traits&lt;double, Point, const double*, Construct_coord_iterator, D&gt;</a> Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Orthogonal__k__neighbor__search.html">CGAL::Orthogonal_k_neighbor_search&lt;Traits, Distance&gt;</a> K_neighbor_search;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1K__neighbor__search.html#a3b06c8cef57e8bab082134470343c7e2">K_neighbor_search::Tree</a> Tree;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 1000;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> K = 5;</div><div class="line">  <span class="comment">// generator for random data points in the cube ( (-1,-1,-1), (1,1,1) )</span></div><div class="line">  Random_points_iterator rpit( 1.0);</div><div class="line"></div><div class="line">  <span class="comment">// Insert number_of_data_points in the tree</span></div><div class="line">  Tree tree(N_Random_points_iterator(rpit,0),</div><div class="line">        N_Random_points_iterator(N));</div><div class="line"></div><div class="line">  Point query(0.0, 0.0, 0.0);</div><div class="line">  Distance tr_dist;</div><div class="line"></div><div class="line">  <span class="comment">// search K nearest neighbours</span></div><div class="line">  K_neighbor_search search(tree, query, K);</div><div class="line">  <span class="keywordflow">for</span>(<a class="code" href="classCGAL_1_1K__neighbor__search.html#ad26a3d2c9da3788a3bd087b1b05ad7eb">K_neighbor_search::iterator</a> it = search.begin(); it != search.end(); it++){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" d(q, nearest neighbor)=  "</span></div><div class="line">          &lt;&lt; tr_dist.inverse_of_transformed_distance(it-&gt;second) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="comment">// search K furthest neighbour searching, with eps=0, search_nearest=false</span></div><div class="line">  K_neighbor_search search2(tree, query, K, 0.0, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<a class="code" href="classCGAL_1_1K__neighbor__search.html#ad26a3d2c9da3788a3bd087b1b05ad7eb">K_neighbor_search::iterator</a> it = search2.begin(); it != search2.end(); it++){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" d(q, furthest neighbor)=  "</span></div><div class="line">          &lt;&lt; tr_dist.inverse_of_transformed_distance(it-&gt;second) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Spatial_searchingExamplesforUsinganArbitrary"></a>
Examples for Using an Arbitrary Point Type with Point Property Maps</h2>
<p>The following four example programs illustrate how to use the classes <code><a class="el" href="classCGAL_1_1Search__traits__adapter.html" title="The class Search_traits_adapter can be used as a template parameter of the kd tree and the search cla...">Search_traits_adapter</a>&lt;Key,PointPropertyMap,BaseTraits&gt;</code> and <code><a class="el" href="classCGAL_1_1Distance__adapter.html" title="A class that uses a point property map to adapt a distance class to work on a key as point type...">Distance_adapter</a>&lt;Key,PointPropertyMap,Base_distance&gt;</code> to store in the kd-tree objects of an arbitrary key type. Points are accessed through a point <a href="http://www.boost.org/doc/libs/release/libs/property_map/index.html">property map</a>. This enables to associate information to a point or to reduce the size of the search structure.</p>
<h3><a class="anchor" id="Spatial_searchingUsingaPointandanInteger"></a>
Using a Point and an Integer as Key Type</h3>
<p>In this example program, the search tree stores tuples of point and integer. The value type of the iterator of the neighbor searching algorithm is this tuple type.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2searching_with_point_with_info_8cpp-example.html">Spatial_searching/searching_with_point_with_info.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_adapter.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iterator/zip_iterator.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                     Point_3;</div><div class="line"><span class="keyword">typedef</span> boost::tuple&lt;Point_3,int&gt;                           Point_and_int;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Random_points_in_cube_3&lt;Point_3&gt;              Random_points_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__3.html">CGAL::Search_traits_3&lt;Kernel&gt;</a>                       Traits_base;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__adapter.html">CGAL::Search_traits_adapter</a>&lt;Point_and_int,</div><div class="line">  CGAL::Nth_of_tuple_property_map&lt;0, Point_and_int&gt;,</div><div class="line">  Traits_base&gt;                                              Traits;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Orthogonal__k__neighbor__search.html">CGAL::Orthogonal_k_neighbor_search&lt;Traits&gt;</a>          K_neighbor_search;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1K__neighbor__search.html#a3b06c8cef57e8bab082134470343c7e2">K_neighbor_search::Tree</a>                             Tree;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1K__neighbor__search.html#a788fb89a2e01dec4bb2463ac209ac713">K_neighbor_search::Distance</a>                         Distance;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> K = 5;</div><div class="line">  <span class="comment">// generator for random data points in the cube ( (-1,-1,-1), (1,1,1) )</span></div><div class="line">  Random_points_iterator rpit( 1.0);</div><div class="line">  std::vector&lt;Point_3&gt; points;</div><div class="line">  std::vector&lt;int&gt;     indices;</div><div class="line">  </div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line"></div><div class="line">  indices.push_back(0);</div><div class="line">  indices.push_back(1);</div><div class="line">  indices.push_back(2);</div><div class="line">  indices.push_back(3);</div><div class="line">  indices.push_back(4);</div><div class="line">  indices.push_back(5);</div><div class="line">  indices.push_back(6);</div><div class="line"></div><div class="line">  <span class="comment">// Insert number_of_data_points in the tree</span></div><div class="line">  Tree tree(</div><div class="line">    boost::make_zip_iterator(boost::make_tuple( points.begin(),indices.begin() )),</div><div class="line">    boost::make_zip_iterator(boost::make_tuple( points.end(),indices.end() ) )  </div><div class="line">  );</div><div class="line">  Point_3 query(0.0, 0.0, 0.0);</div><div class="line">  Distance tr_dist;</div><div class="line"></div><div class="line">  <span class="comment">// search K nearest neighbours</span></div><div class="line">  K_neighbor_search search(tree, query, K);</div><div class="line">  <span class="keywordflow">for</span>(<a class="code" href="classCGAL_1_1K__neighbor__search.html#ad26a3d2c9da3788a3bd087b1b05ad7eb">K_neighbor_search::iterator</a> it = search.begin(); it != search.end(); it++){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" d(q, nearest neighbor)=  "</span></div><div class="line">          &lt;&lt; tr_dist.inverse_of_transformed_distance(it-&gt;second) &lt;&lt; <span class="stringliteral">" "</span> </div><div class="line">              &lt;&lt; boost::get&lt;0&gt;(it-&gt;first)&lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; boost::get&lt;1&gt;(it-&gt;first) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Spatial_searchingUsinganIntegerasKeyType"></a>
Using an Integer as Key Type</h3>
<p>In this example program, the search tree stores only integers that refer to points stored within a user vector. The point type of the search traits is <code>std::size_t</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2searching_with_point_with_info_inplace_8cpp-example.html">Spatial_searching/searching_with_point_with_info_inplace.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_adapter.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/iterator/counting_iterator.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="comment">//definition of a non-mutable lvalue property map,</span></div><div class="line"><span class="comment">//with the get function as a friend function to give it</span></div><div class="line"><span class="comment">//access to the private member</span></div><div class="line"><span class="keyword">class </span>My_point_property_map{</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; points;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> Point_3 value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; reference;</div><div class="line">  <span class="keyword">typedef</span> std::size_t key_type;</div><div class="line">  <span class="keyword">typedef</span> boost::lvalue_property_map_tag category;  </div><div class="line"></div><div class="line">  My_point_property_map(<span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; pts):points(pts){}</div><div class="line"></div><div class="line">  reference operator[](key_type k)<span class="keyword"> const </span>{<span class="keywordflow">return</span> points[k];}</div><div class="line"></div><div class="line">  <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> My_point_property_map&amp; ppmap,key_type i) </div><div class="line">  {<span class="keywordflow">return</span> ppmap[i];}</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Random_points_in_cube_3&lt;Point_3&gt;                               Random_points_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__3.html">CGAL::Search_traits_3&lt;Kernel&gt;</a>                                        Traits_base;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__adapter.html">CGAL::Search_traits_adapter&lt;std::size_t,My_point_property_map,Traits_base&gt;</a> Traits;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Orthogonal__k__neighbor__search.html">CGAL::Orthogonal_k_neighbor_search&lt;Traits&gt;</a>                      K_neighbor_search;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1K__neighbor__search.html#a3b06c8cef57e8bab082134470343c7e2">K_neighbor_search::Tree</a>                                         Tree;</div><div class="line"><span class="keyword">typedef</span> Tree::Splitter                                                  <a class="code" href="classSplitter.html">Splitter</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1K__neighbor__search.html#a788fb89a2e01dec4bb2463ac209ac713">K_neighbor_search::Distance</a>                                     Distance;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> K = 5;</div><div class="line">  <span class="comment">// generator for random data points in the cube ( (-1,-1,-1), (1,1,1) )</span></div><div class="line">  Random_points_iterator rpit( 1.0);</div><div class="line">  std::vector&lt;Point_3&gt; points;</div><div class="line">  </div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line">  points.push_back(Point_3(*rpit++));</div><div class="line"></div><div class="line">  My_point_property_map ppmap(points);</div><div class="line"></div><div class="line">  <span class="comment">// Insert number_of_data_points in the tree</span></div><div class="line">  Tree tree(</div><div class="line">    boost::counting_iterator&lt;std::size_t&gt;(0),</div><div class="line">    boost::counting_iterator&lt;std::size_t&gt;(points.size()),</div><div class="line">    Splitter(),</div><div class="line">    Traits(ppmap)</div><div class="line">  );</div><div class="line">  Point_3 query(0.0, 0.0, 0.0);</div><div class="line">  Distance tr_dist(ppmap);</div><div class="line"></div><div class="line">  <span class="comment">// search K nearest neighbours</span></div><div class="line">  K_neighbor_search search(tree, query, K,0,<span class="keyword">true</span>,tr_dist);</div><div class="line">  <span class="keywordflow">for</span>(<a class="code" href="classCGAL_1_1K__neighbor__search.html#ad26a3d2c9da3788a3bd087b1b05ad7eb">K_neighbor_search::iterator</a> it = search.begin(); it != search.end(); it++){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" d(q, nearest neighbor)=  "</span></div><div class="line">          &lt;&lt; tr_dist.inverse_of_transformed_distance(it-&gt;second) &lt;&lt; <span class="stringliteral">" "</span> </div><div class="line">              &lt;&lt; points[it-&gt;first] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; it-&gt;first &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Spatial_searchingUsingaModelofLvalueProperty"></a>
Using a Model of L-value Property Map Concept</h3>
<p>This example programs uses a model of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classLvaluePropertyMap.html">LvaluePropertyMap</a></code>. Points are read from a <code>std::map</code>. The search tree stores integers of type <code>std::size_t</code>. The value type of the iterator of the neighbor searching algorithm is <code>std::size_t</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2searching_with_point_with_info_pmap_8cpp-example.html">Spatial_searching/searching_with_point_with_info_pmap.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_adapter.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/iterator/counting_iterator.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::const_associative_property_map&lt;std::map&lt;std::size_t,Point_3&gt; &gt;           My_point_property_map;</div><div class="line">  </div><div class="line"><span class="keyword">typedef</span> CGAL::Random_points_in_cube_3&lt;Point_3&gt;                                          Random_points_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__3.html">CGAL::Search_traits_3&lt;Kernel&gt;</a>                                                   Traits_base;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__adapter.html">CGAL::Search_traits_adapter&lt;std::size_t,My_point_property_map,Traits_base&gt;</a>      Traits;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Orthogonal__k__neighbor__search.html">CGAL::Orthogonal_k_neighbor_search&lt;Traits&gt;</a>                      K_neighbor_search;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1K__neighbor__search.html#a3b06c8cef57e8bab082134470343c7e2">K_neighbor_search::Tree</a>                                         Tree;</div><div class="line"><span class="keyword">typedef</span> Tree::Splitter                                                  Splitter;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1K__neighbor__search.html#a788fb89a2e01dec4bb2463ac209ac713">K_neighbor_search::Distance</a>                                     Distance;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> K = 5;</div><div class="line">  <span class="comment">// generator for random data points in the cube ( (-1,-1,-1), (1,1,1) )</span></div><div class="line">  Random_points_iterator rpit( 1.0);</div><div class="line">  std::map&lt;std::size_t,Point_3&gt; points;</div><div class="line">  </div><div class="line">  points[0]=Point_3(*rpit++);</div><div class="line">  points[1]=Point_3(*rpit++);</div><div class="line">  points[2]=Point_3(*rpit++);</div><div class="line">  points[3]=Point_3(*rpit++);</div><div class="line">  points[4]=Point_3(*rpit++);</div><div class="line">  points[5]=Point_3(*rpit++);</div><div class="line">  points[6]=Point_3(*rpit++);</div><div class="line"></div><div class="line">  My_point_property_map ppmap(points);</div><div class="line"></div><div class="line">  <span class="comment">// Insert number_of_data_points in the tree</span></div><div class="line">  Tree tree(</div><div class="line">    boost::counting_iterator&lt;std::size_t&gt;(0),</div><div class="line">    boost::counting_iterator&lt;std::size_t&gt;(points.size()),</div><div class="line">    Splitter(),</div><div class="line">    Traits(ppmap)</div><div class="line">  );</div><div class="line">  Point_3 query(0.0, 0.0, 0.0);</div><div class="line">  Distance tr_dist(ppmap);</div><div class="line"></div><div class="line">  <span class="comment">// search K nearest neighbours</span></div><div class="line">  K_neighbor_search search(tree, query, K,0,<span class="keyword">true</span>,tr_dist);</div><div class="line">  <span class="keywordflow">for</span>(<a class="code" href="classCGAL_1_1K__neighbor__search.html#ad26a3d2c9da3788a3bd087b1b05ad7eb">K_neighbor_search::iterator</a> it = search.begin(); it != search.end(); it++){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" d(q, nearest neighbor)=  "</span></div><div class="line">          &lt;&lt; tr_dist.inverse_of_transformed_distance(it-&gt;second) &lt;&lt; <span class="stringliteral">" "</span></div><div class="line">              &lt;&lt; points[it-&gt;first] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; it-&gt;first &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Spatial_searchingUsingSurfaceMesh"></a>
Using a Point Property Map of a Polygonal Mesh</h3>
<p>This example programs shows how to search the closest vertices of a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> or, quite similar, of a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code>. Points are stored in the polygonal mesh. The search tree stores vertex descriptors. The value type of the iterator of the neighbor searching algorithm is <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLTraits.html#BGLSMGT"><code>boost::graph_traits&lt;Surface_mesh&gt;::vertex_descriptor</code> </a>.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2searching_surface_mesh_vertices_8cpp-example.html">Spatial_searching/searching_surface_mesh_vertices.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_adapter.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> Mesh;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor Point;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertices_size_type size_type;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::property_map&lt;Mesh,CGAL::vertex_point_t&gt;::type Vertex_point_pmap;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__3.html">CGAL::Search_traits_3&lt;Kernel&gt;</a>                                    Traits_base;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__adapter.html">CGAL::Search_traits_adapter&lt;Point,Vertex_point_pmap,Traits_base&gt;</a> Traits;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Orthogonal__k__neighbor__search.html">CGAL::Orthogonal_k_neighbor_search&lt;Traits&gt;</a>                      K_neighbor_search;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1K__neighbor__search.html#a3b06c8cef57e8bab082134470343c7e2">K_neighbor_search::Tree</a>                                         Tree;</div><div class="line"><span class="keyword">typedef</span> Tree::Splitter                                                  Splitter;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1K__neighbor__search.html#a788fb89a2e01dec4bb2463ac209ac713">K_neighbor_search::Distance</a>                                     Distance;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line">  Mesh mesh;</div><div class="line">  std::cerr &lt;&lt; argc &lt;&lt;std::endl;</div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<span class="stringliteral">"data/tripod.off"</span>);</div><div class="line">  in  &gt;&gt; mesh;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> K = 5;</div><div class="line"></div><div class="line">  Vertex_point_pmap vppmap = <span class="keyword">get</span>(CGAL::vertex_point,mesh);</div><div class="line"></div><div class="line">  <span class="comment">// Insert number_of_data_points in the tree</span></div><div class="line">  Tree tree(</div><div class="line">            vertices(mesh).begin(),</div><div class="line">            vertices(mesh).end(),</div><div class="line">            Splitter(),</div><div class="line">            Traits(vppmap)</div><div class="line">  );</div><div class="line">  Point_3 query(0.0, 0.0, 0.0);</div><div class="line">  Distance tr_dist(vppmap);</div><div class="line"></div><div class="line">  <span class="comment">// search K nearest neighbours</span></div><div class="line">  K_neighbor_search search(tree, query, K,0,<span class="keyword">true</span>,tr_dist);</div><div class="line">  std::cout &lt;&lt;<span class="stringliteral">"The "</span>&lt;&lt; K &lt;&lt; <span class="stringliteral">" nearest vertices to the query point at (0,0,0) are:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(<a class="code" href="classCGAL_1_1K__neighbor__search.html#ad26a3d2c9da3788a3bd087b1b05ad7eb">K_neighbor_search::iterator</a> it = search.begin(); it != search.end(); it++){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"vertex "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">" : "</span> &lt;&lt; vppmap[it-&gt;first] &lt;&lt; <span class="stringliteral">" at distance "</span> </div><div class="line">          &lt;&lt; tr_dist.inverse_of_transformed_distance(it-&gt;second) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Spatial_searchingExampleforSelectingaSplitting"></a>
Example for Selecting a Splitting Rule and Setting the Bucket Size</h2>
<p>This example program illustrates selecting a splitting rule and setting the maximal allowed bucket size. The only differences with the first example are the declaration of the <em><a class="el" href="classCGAL_1_1Fair.html" title="Implements the fair splitting rule. ">Fair</a></em> splitting rule, needed to set the maximal allowed bucket size.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2using_fair_splitting_rule_8cpp-example.html">Spatial_searching/using_fair_splitting_rule.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> R;</div><div class="line"><span class="keyword">typedef</span> R::Point_2 Point_d;</div><div class="line"><span class="keyword">typedef</span> CGAL::Random_points_in_square_2&lt;Point_d&gt; Random_points_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Counting__iterator.html">CGAL::Counting_iterator&lt;Random_points_iterator&gt;</a> N_Random_points_iterator;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__2.html">CGAL::Search_traits_2&lt;R&gt;</a> Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Euclidean__distance.html">CGAL::Euclidean_distance&lt;Traits&gt;</a> Distance;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Fair.html">CGAL::Fair&lt;Traits&gt;</a> Fair;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Orthogonal__k__neighbor__search.html">CGAL::Orthogonal_k_neighbor_search&lt;Traits,Distance,Fair&gt;</a> Neighbor_search;</div><div class="line"><span class="keyword">typedef</span> Neighbor_search::Tree Tree;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = 1000;</div><div class="line">  <span class="comment">// generator for random data points in the square ( (-1,-1), (1,1) )</span></div><div class="line">  Random_points_iterator rpit( 1.0);</div><div class="line"></div><div class="line">  Fair fair(5); <span class="comment">// bucket size=5</span></div><div class="line">  <span class="comment">// Insert number_of_data_points in the tree</span></div><div class="line">  Tree tree(N_Random_points_iterator(rpit,0),</div><div class="line">        N_Random_points_iterator(N),</div><div class="line">        fair);</div><div class="line"></div><div class="line">  Point_d query(0,0);</div><div class="line"></div><div class="line">  <span class="comment">// Initialize the search structure, and search all N points</span></div><div class="line">  Neighbor_search search(tree, query, N);</div><div class="line"></div><div class="line">  <span class="comment">// report the N nearest neighbors and their distance</span></div><div class="line">  <span class="comment">// This should sort all N points by increasing distance from origin</span></div><div class="line">  <span class="keywordflow">for</span>(Neighbor_search::iterator it = search.begin(); it != search.end(); ++it){</div><div class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">" "</span>&lt;&lt; <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundations.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(it-&gt;second) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Spatial_searchingExampleforWorstCaseScenarios"></a>
Example for Worst-Case Scenarios for Different Splitters</h2>
<p>This example program has two 2-dimensional data sets: The first one containing collinear points with exponential increasing distances and the second one with collinear points in the firstdimension and one point with a distance exceeding the spread of the other points in the second dimension. These are the worst cases for the midpoint/median rules and can also occur in higher dimensions.</p>
<p><br />
<b>File</b> <a class="el" href="Spatial_searching_2splitter_worst_cases_8cpp-example.html">Spatial_searching/splitter_worst_cases.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Orthogonal_k_neighbor_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Search_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Search__traits__2.html">CGAL::Search_traits_2&lt;Kernel&gt;</a>                 Traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                               Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Sliding__midpoint.html">CGAL::Sliding_midpoint&lt;Traits_2&gt;</a>              Sliding_midpoint;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Median__of__rectangle.html">CGAL::Median_of_rectangle&lt;Traits_2&gt;</a>           Median_of_rectangle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Euclidean__distance.html">CGAL::Euclidean_distance&lt;Traits_2&gt;</a>            Distance;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Orthogonal__k__neighbor__search.html">CGAL::Orthogonal_k_neighbor_search&lt;Traits_2,Distance,Sliding_midpoint&gt;</a>     Neighbor_search_sliding;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Orthogonal__k__neighbor__search.html">CGAL::Orthogonal_k_neighbor_search&lt;Traits_2,Distance,Median_of_rectangle&gt;</a>  Neighbor_search_median;</div><div class="line"><span class="keyword">typedef</span> Neighbor_search_sliding::Tree                 Tree_sliding;</div><div class="line"><span class="keyword">typedef</span> Neighbor_search_median::Tree                  Tree_median;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_2&gt;                          Points;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Points sliding_worst_case;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ,j = 1; i &lt; 10 ; ++i , j *= 2){</div><div class="line">    sliding_worst_case.push_back(Point_2(((<span class="keywordtype">double</span>)i)/10 , 0));</div><div class="line">    sliding_worst_case.push_back(Point_2( (<span class="keywordtype">double</span>)j , 0));    </div><div class="line">  }</div><div class="line"></div><div class="line">  Sliding_midpoint sliding(10);</div><div class="line">  Median_of_rectangle median(10);</div><div class="line"></div><div class="line">  Tree_sliding tree1(sliding_worst_case.begin(), sliding_worst_case.end() , sliding);</div><div class="line">  tree1.build();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Worst case tree for Sliding midpoint and Midpoint of max spread : "</span>&lt;&lt;std::endl;</div><div class="line">  tree1.statistics(std::cout);</div><div class="line">  tree1.clear();</div><div class="line">  std::cout&lt;&lt;std::endl&lt;&lt;<span class="stringliteral">"Same data with median splitter:"</span>&lt;&lt;std::endl;</div><div class="line"></div><div class="line">  Tree_median tree2(sliding_worst_case.begin(), sliding_worst_case.end() , median );</div><div class="line">  tree2.statistics(std::cout);</div><div class="line">  tree2.clear();</div><div class="line"></div><div class="line">  Points median_worst_case;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0 ; i &lt; 19 ; ++i){</div><div class="line">    median_worst_case.push_back(Point_2( 0 , i));</div><div class="line">  }</div><div class="line">  median_worst_case.push_back(Point_2(20,0));</div><div class="line"></div><div class="line"> </div><div class="line">  Tree_median tree3(median_worst_case.begin() , median_worst_case.end() , median);</div><div class="line"></div><div class="line">  tree3.build();</div><div class="line">  std::cout &lt;&lt;std::endl&lt;&lt; <span class="stringliteral">"Worst case tree for Median of rectangle, Median of max spread : "</span>&lt;&lt;std::endl;</div><div class="line">  tree3.statistics(std::cout);</div><div class="line">  tree3.clear();</div><div class="line"></div><div class="line">  std::cout&lt;&lt;std::endl&lt;&lt;<span class="stringliteral">"Same data with midpoint splitter:"</span>&lt;&lt;std::endl;</div><div class="line"></div><div class="line">  Tree_sliding tree4(median_worst_case.begin() , median_worst_case.end() , sliding);</div><div class="line"></div><div class="line">  tree4.build();</div><div class="line">  tree4.statistics(std::cout);</div><div class="line">  tree4.clear();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Performance"></a>
Performance</h1>
<h2><a class="anchor" id="OrthogonalPerfomance"></a>
Performance of the Orthogonal Search</h2>
<p>We took the gargoyle data set (Surface) from aim@shape, and generated the same number of random points in the bbox of the gargoyle (Random). We then consider three scenarios as data/queries. The data set contains 800K points. For each query point we compute the K=10,20,30 closest points, with the default splitter and for the bucket size 10 (default) and 20.</p>
<p>The results were produced with the release 4.6 of <span style="font-variant: small-caps;">CGAL</span>, on an Intel i7 2.7 Ghz laptop with 16 GB RAM, compiled with Visual C++ 2012 with the /O2 option.</p>
<p>The values are the average of ten tests each.</p>
<center> <table class="doxtable">
<tr>
<th>k </th><th align="right">bucket size </th><th align="right">Surface/Surface </th><th align="right">Surface/Random </th><th align="right">Random/Random  </th></tr>
<tr>
<td>10</td><td align="right">10 </td><td align="right">0.89 </td><td align="right">11.48 </td><td align="right">2.63 </td></tr>
<tr>
<td>10</td><td align="right">20 </td><td align="right">0.89 </td><td align="right">9.80 </td><td align="right">2.25 </td></tr>
<tr>
<td>20</td><td align="right">10 </td><td align="right">1.60 </td><td align="right">13.41 </td><td align="right">4.06 </td></tr>
<tr>
<td>20</td><td align="right">20 </td><td align="right">1.59 </td><td align="right">11.62 </td><td align="right">3.46 </td></tr>
<tr>
<td>30</td><td align="right">10 </td><td align="right">2.35 </td><td align="right">15.52 </td><td align="right">5.42 </td></tr>
<tr>
<td>30</td><td align="right">20 </td><td align="right">2.33 </td><td align="right">13.50 </td><td align="right">4.61 </td></tr>
</table>
</center><p><a class="anchor" id="fig__Spatial_searchingfigbenchmark"></a></p><div class="image">
<img src="gargoyle.png" alt="gargoyle.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Spatial_searchingfigbenchmark">Figure 78.4</a> Benchmark dataset (downsampled for visualization).<br />
Blue: Gargoyle surface. Green: Gargoyle bbox random.  </div>  <br />

<h1><a class="anchor" id="Spatial_searchingSoftware"></a>
Software Design</h1>
<h2><a class="anchor" id="Kd_tree_subsection"></a>
The kd Tree</h2>
<p>Bentley <a class="el" href="citelist.html#CITEREF_b-mbstu-75">[3]</a> introduced the <code>kd</code> tree as a generalization of the binary search tree in higher dimensions. <code>kd</code> trees hierarchically decompose space into a relatively small number of rectangles such that no rectangle contains too many input objects. For our purposes, a <em>rectangle</em> in real <code>d</code> dimensional space, \( \mathbb{R}^d\), is the product of <code>d</code> closed intervals on the coordinate axes. <code>kd</code> trees are obtained by partitioning point sets in \( \mathbb{R}^d\) using <code>(d-1)</code>-dimensional hyperplanes. Each node in the tree is split into two children by one such separating hyperplane. Several splitting rules (see Section <a class="el" href="index.html#Spatial_SearchingSplitting_rule_section">Splitting Rules</a> can be used to compute a separating <code>(d-1)</code>-dimensional hyperplane.</p>
<p>Each internal node of the <code>kd</code> tree is associated with a rectangle and a hyperplane orthogonal to one of the coordinate axis, which splits the rectangle into two parts. Therefore, such a hyperplane, defined by a splitting dimension and a splitting value, is called a separator. These two parts are then associated with the two child nodes in the tree. The process of partitioning space continues until the number of data points in the rectangle falls below some given threshold. The rectangles associated with the leaf nodes are called <em>buckets</em>, and they define a subdivision of the space into rectangles. Data points are only stored in the leaf nodes of the tree, not in the internal nodes.</p>
<p>Friedmann, Bentley and Finkel <a class="el" href="citelist.html#CITEREF_fbf-afbml-77">[4]</a> described the standard search algorithm to find the <code>k</code>th nearest neighbor by searching a <code>kd</code> tree recursively.</p>
<p>When encountering a node of the tree, the algorithm first visits the child that is closest to the query point. On return, if the rectangle containing the other child lies within 1/ (1+ \( \epsilon\)) times the distance to the <code>k</code>th nearest neighbors so far, then the other child is visited recursively. Priority search <a class="el" href="citelist.html#CITEREF_am-annqf-93">[2]</a> visits the nodes in increasing order of distance from the queue with help of a priority queue. The search stops when the distance of the query point to the nearest nodes exceeds the distance to the nearest point found with a factor 1/ (1+ \( \epsilon\)). Priority search supports next neighbor search, standard search does not.</p>
<p>In order to speed-up the internal distance computations in nearest neighbor searching in high dimensional space, the approximate searching package supports orthogonal distance computation. Orthogonal distance computation implements the efficient incremental distance computation technique introduced by Arya and Mount <a class="el" href="citelist.html#CITEREF_am-afvq-93">[1]</a>. This technique works only for neighbor queries with query items represented as points and with a quadratic form distance, defined by \( d_A(x,y)= (x-y)A(x-y)^T\), where the matrix \( A\) is positive definite, i.e. \( d_A(x,y) \geq 0\). An important class of quadratic form distances are weighted Minkowski distances. Given a parameter \( p&gt;0\) and parameters \( w_i \geq 0, 0 &lt; i \leq d\), the weighted Minkowski distance is defined by \( l_p(w)(r,q)= ({\Sigma_{i=1}^{i=d} \, w_i(r_i-q_i)^p})^{1/p}\) for \( 0 &lt; p &lt;\infty\) and defined by \( l_{\infty}(w)(r,q)=max \{w_i |r_i-q_i| \mid 1 \leq i \leq d\}\). The Manhattan distance ( \( p=1\), \( w_i=1\)) and the Euclidean distance ( \( p=2\), \( w_i=1\)) are examples of a weighted Minkowski metric.</p>
<p>To speed up distance computations also transformed distances are used instead of the distance itself. For instance for the Euclidean distance, to avoid the expensive computation of square roots, squared distances are used instead of the Euclidean distance itself.</p>
<h1><a class="anchor" id="Spatial_searchingImplementationHistory"></a>
Implementation History</h1>
<p>The initial implementation of this package was done by Hans Tangelder and Andreas Fabri. It was optimized in speed and memory consumption by Markus Overtheil during an internship at GeometryFactory in 2014. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:59:09 for CGAL 4.13 - dD Spatial Searching by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
