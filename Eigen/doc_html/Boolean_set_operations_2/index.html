<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Boolean_set_operations_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 4.13 - 2D Regularized Boolean Set-Operations: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<!-- Custom mathjax -->
<!-- TODO: Remove this with MATHJAX_CODEFILE -->
<span style="display:none">\( \newcommand{\E}{\mathrm{E}} \) \( \newcommand{\A}{\mathrm{A}} \)
\( \newcommand{\R}{\mathrm{R}} \) \( \newcommand{\N}{\mathrm{N}} \) \( \newcommand{\Q}{\mathrm{Q}} \) \( \newcommand{\Z}{\mathrm{Z}} \)
\(
\def\ccSum #1#2#3{
  \sum_{#1}^{#2}{#3}
}
\def\ccProd #1#2#3{
  \sum_{#1}^{#2}{#3}
}\)
</span>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 4.13 - 2D Regularized Boolean Set-Operations
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Regularized_Boolean_Set-Operations"></a> <a class="anchor" id="chapter_Boolean_set_operations_2"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Efi Fogel, Ophir Setter, Ron Wein, Guy Zucker, Baruch Zukerman, and Dan Halperin</dd></dl>
<h1><a class="anchor" id="bso_secintro"></a>
Introduction</h1>
<p><a class="anchor" id="fig__figteaser"></a></p><div class="image">
<img src="teaser.png" alt="teaser.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figteaser">Figure 16.1</a> Examples of Boolean set-operations on general polygons.  </div>  <br />

<p>This package consists of the implementation of Boolean set-operations on point sets bounded by weakly \( x\)-monotone curves<span class="footnote">A continuous planar curve \( C\) is <em>weakly \( x\)-monotone</em> if every vertical line intersects it at most once, or if it is vertical. Hereafter we refer to weakly \( x\)-monotone curves as \( x\)-monotone curves.</span> in 2-dimensional Euclidean space. In particular, it contains the implementation of <em>regularized</em> Boolean set-operations, intersection predicates, and point containment predicates. <a class="el" href="index.html#fig__figteaser">Figure 16.1</a> shows simple examples of such operations.</p>
<p>Ordinary Boolean set-operations, which distinguish between the interior and the boundary of a polygon, are not implemented within this package. The Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgNef2Summary">2D Boolean Operations on Nef Polygons</a> supports these operations for (linear) polygons.</p>
<p>In the rest of this chapter we use, unless otherwise stated, the traditional notation to denote regularized operations; e.g., \( P \cap Q\) means the <em>regularized</em> intersection of \( P\) and \( Q\).</p>
<p>Our package supports the following Boolean set-operations on two point sets \( P\) and \( Q\) that each is the union of one or more general polygons: </p><dl>
<dt><b>Intersection</b></dt>
<dd>computes the intersection \( R = P \cap Q\). </dd>
<dt><b>Join</b></dt>
<dd>computes the union \( R = P \cup Q\). </dd>
<dt><b>Difference</b></dt>
<dd>computes the difference \( R = P \setminus Q\). </dd>
<dt><b>Symmetric Difference</b></dt>
<dd>computes the symmetric difference \( P = P \oplus Q = (P \setminus Q) \cup (Q \setminus P)\). </dd>
<dt><b>Complement</b></dt>
<dd>computes the complement \(R = \overline{P}\). </dd>
<dt><b>Intersection predicate</b></dt>
<dd>tests whether the two sets \( P\) and \( Q\) overlap, distinguishing three possible scenarios: (i) the two sets intersect on their interior (that is, their regularized intersection is not empty \( P \cap Q \neq \emptyset\)); (ii) the boundaries of two sets intersect but their interiors are disjoint; namely they have a finite number of common points or even share a boundary curve (still in this case \( P \cap Q = \emptyset\); and (iii) the two sets are disjoint. </dd>
</dl>
<p>In general, the set \( R\), resulting from a regularized Boolean set-operation, is considered as being a closed point-set; see definition of regularized boolean set operations below.</p>
<p>In the rest of this chapter we review the Boolean set-operations package in more depth. In Section <a class="el" href="index.html#bso_secbso_lin">Boolean Set-Operations on Linear Polygons</a> we focus on Boolean set-operations on linear polygons, introducing the notion of polygons with holes and of a general polygon set. Section <a class="el" href="index.html#bso_secbso_gen">Boolean Set-Operations on General Polygons</a> introduces general polygons. We first discuss polygons whose edges are either line segments or circular arcs and then explain how to construct and use general polygons whose edges can be arbitrary weakly \( x\)-monotone curves.</p>
<h1><a class="anchor" id="bso_secbso_def"></a>
Terms and Definitions</h1>
<p><a class="anchor" id="fig__simpleDefsExamples"></a></p><div class="image">
<img src="simpleDefsExamples.png" alt="simpleDefsExamples.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__simpleDefsExamples">Figure 16.2</a> Examples of polygons. (a) A simple polygon. (b) A relatively simple polygon (c) A polygon that is neither simple nor relatively simple.  </div>  <br />

<ul>
<li>
<p class="startli">The counterclockwise cyclic sequence of alternating polygon edges and polygon vertices is referred to as the polygon <b>(outer) boundary</b>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A polygon whose curves are pairwise disjoint in their interior, and whose vertices' degree equals two is defined as a <b>Simple polygon</b>. Such a polygon has a well-defined interior and exterior and is topologically equivalent to a disk. Note that while traversing the edges of the relatively simple polygon illustrated above (B), no curve is crossed over.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A <b>Relatively simple</b> polygon allows vertices with a degree \(\gt 2\), but all of its edges are disjoint in their interior. Furthermore, it must be an orientable polygon. Namely when it is inserted into an arrangement and its outer boundary is traversed, the same face is adjacent to all of the halfedges (no crossing over any curve during the traversal). Note that while polygon C has the same curves as polygon B, traversal of the curves leads to crossing over a previously traversed curve, and is therefore neither simple nor relatively simple.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A polygon in our context must be relatively simple and its outer boundary vertices must be ordered in a counterclockwise direction around the interior of the polygon. We extend the notion of a polygon to a <b>point set</b> in \( \mathbb{R}^2\) that has a topology of a polygon and its boundary edges must map to \( x\)-monotone curves, and refer to it as a <b>general polygon</b>. We sometimes use the term <em>polygon</em> instead of general polygon for simplicity hereafter.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A <b>polygon with holes</b> represents a point set that may be bounded or unbounded. In case of a bounded set, its <em>outer boundary</em> is represented as a <em>relatively simple </em> (but not necessarily simple) polygon, whose vertices are oriented in a <em>counterclockwise </em> order around the interior of the set. In addition, the set may contain <em>holes</em>, where each hole is represented as a <em>simple</em> polygon, whose vertices are oriented in a <em>clockwise</em> order around the interior of the hole. Note that an unbounded polygon without holes spans the entire plane. Vertices of holes may coincide with vertices of the boundary.</p>
<p class="endli"></p>
</li>
<li>
A <b>regularized Boolean set-operation</b> \( \mbox{op}^*\) can be obtained by first taking the interior of the resultant point set of an <em>ordinary</em> Boolean set-operation \( (P\ \mbox{op}\ Q)\) and then by taking the closure <a class="el" href="citelist.html#CITEREF_cgal:h-sm-04">[1]</a>. That is, \( P\ \mbox{op}^*\ Q = \mbox{closure}(\mbox{interior} (P\ \mbox{op}\ Q))\). Regularized Boolean set-operations appear in Constructive Solid Geometry (CSG), because regular sets are closed under regularized Boolean set-operations, and because regularization eliminates lower dimensional features, namely isolated vertices and antennas, thus simplifying and restricting the representation to physically meaningful solids. Our package provides regularized operations on polygons and general polygons, where the edges of a general polygon may be general \( x\)-monotone curves, rather than being simple line segments. </li>
</ul>
<h2><a class="anchor" id="bso_ssecpolygon_validation"></a>
Conditions for Valid Polygons</h2>
<p>In our context, a polygon must uphold the following conditions:</p>
<ol>
<li>
<em>Closed Boundary</em> - the polygon's outer boundary must be a connected sequence of curves, that start and end at the same vertex. </li>
<li>
<em>Simplicity</em> - the polygon must be simple. </li>
<li>
<em>Orientation</em> - the polygon's outer boundary must be <em>counter-clockwise oriented</em>. </li>
</ol>
<h2><a class="anchor" id="bso_ssecpolygon_with_holes_validation"></a>
Conditions for Valid Polygons with Holes</h2>
<p>In our context, a polygon with holes must uphold the following conditions:</p>
<ol>
<li>
<em>Closed Boundary</em> - both the outer boundary and the holes must be closed polygons as defined above. </li>
<li>
<em>Simplicity</em> - the outer boundary must be a <em></em><b><em>relatively</em></b><em> simple</em> polygon (as defined above). Every hole must be a <em>simple</em> polygon. </li>
<li>
<em>Orientation</em> - The polygon with holes must have an outer boundary with <em>counter clockwise orientation</em>. Every hole's outer boundary should have <em>clockwise orientation</em>. </li>
<li>
<em>The holes and the outer boundary must be pairwise disjoint,except maybe on vertices</em>. <ul>
<li>
<em>All holes are contained in the outer boundary</em> - holes must be contained inside the outer boundary and must be disjoint from it (except on vertices). </li>
<li>
<p class="startli"><em>Pairwise disjoint holes (on interior)</em> - the polygon's holes must be <em>pairwise disjoint</em>, except for intersection on a joint vertex/vertices.</p>
<p class="endli"></p>
</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="bso_secbso_lin"></a>
Boolean Set-Operations on Linear Polygons</h1>
<p>The basic library of <span style="font-variant: small-caps;">CGAL</span> includes the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">Polygon_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>,Container&gt;</code> class-template that represents a linear polygon in the plane. The polygon is represented by its vertices stored in a container of objects of type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></code>. The polygon edges are line segments (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> objects) between adjacent points in the container. By default, the <code>Container</code> is a vector of <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></code> objects.</p>
<p>The following function demonstrates how to use the basic access functions of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">Polygon_2</a></code> class. It accepts a polygon \( P\) and prints it in a readable format: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Kernel, <span class="keyword">class</span> Container&gt;</div><div class="line"><span class="keywordtype">void</span> print_polygon (<span class="keyword">const</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Kernel, Container&gt;</a>&amp; P)</div><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Kernel, Container&gt;::Vertex_const_iterator</a> vit;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"[ "</span> &lt;&lt; P.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html#a52bab6b64430d70d6756f4dda5944bac">size</a>() &lt;&lt; <span class="stringliteral">" vertices:"</span>;</div><div class="line">  <span class="keywordflow">for</span> (vit = P.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html#a20ae65167d8950c803667a47c30649f6">vertices_begin</a>(); vit != P.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html#a46168a01e53aa7d1ced7b9d73821227a">vertices_end</a>(); ++vit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; *vit &lt;&lt; <span class="charliteral">')'</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" ]"</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>In this section we use the term <em>polygon</em> to indicate a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">Polygon_2</a></code> instance, namely, a polygon having linear edges. General polygons are only discussed in Section <a class="el" href="index.html#bso_secbso_gen">Boolean Set-Operations on General Polygons</a>.</p>
<p>The basic components of our package are the free (global) functions <code><a class="el" href="group__boolean__complement.html#ga45629253bda87736f21251bfee532665" title="writes the complement of the polygon pgn into the polygon with holes res. ">complement()</a></code> that accepts a single <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">Polygon_2</a></code> object, and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__intersection__linear__grp.html#gab77f3cd98c4c4ff7acff59c98ab88ff0">intersection()</a></code>, <code><a class="el" href="group__boolean__join.html#gafca2f0759f989fe95d1c56b0428a0f16" title="writes the union of the polygons p1 and p2 into the polygon with holes res. ">join()</a></code>,<span class="footnote">The function that computes the union of two polygons is called <code><a class="el" href="group__boolean__join.html#gafca2f0759f989fe95d1c56b0428a0f16" title="writes the union of the polygons p1 and p2 into the polygon with holes res. ">join()</a></code>, since the word <code>union</code> is reserved in <span style="font-variant: small-caps;">C++</span>.</span> <code><a class="el" href="group__boolean__difference.html#ga525c4a75749027346fcf444a8fbb31b7" title="writes the difference of the polygons p1 and p2 into the output iterator oi. ">difference()</a></code>, <code><a class="el" href="group__boolean__symmetric__difference.html#ga16f709a3037b2d4ae61141eda60f72e7">symmetric_difference()</a></code> and the predicate <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__do__intersect__linear__grp.html#ga9514a218a097ac392d21775368d3dd0d">do_intersect()</a></code> that accept two <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">Polygon_2</a></code> objects as their input. We explain how these functions should be used through several examples in the following sections.</p>
<h2><a class="anchor" id="Boolean_set_operations_2ASimpleExample"></a>
A Simple Example</h2>
<div class="image">
<img src="triangles.png" alt="triangles.png" />
</div>
 <p>Testing whether two polygons intersect results with a Boolean value, and does not require any additional data beyond the provision of the two input polygons. The example listed below tests whether the two triangles depicted on the right intersect. It uses, as do the other example programs in this chapter, the auxiliary header file <code>bso_rational_nt.h</code>, which defines the type <code>Number_type</code> as <span class="textsc">Gmp</span>'s rational number-type (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">Gmpq</a></code>), or as the number type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1MP__Float.html">MP_Float</a>&gt;</code> that is included in the support library of <span style="font-variant: small-caps;">CGAL</span>, based on whether the <span class="textsc">Gmp</span> library is installed or not. It also uses the function <code>print_polygon.h</code> listed above, which is located in the header file <code>print_utils.h</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Boolean_set_operations_2_2do_intersect_8cpp-example.html">Boolean_set_operations_2/do_intersect.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Boolean_set_operations_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                   Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Kernel&gt;</a>                           Polygon_2;</div><div class="line"></div><div class="line"><span class="preprocessor">#include "print_utils.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  Polygon_2 P;</div><div class="line">  P.<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html#a66ff561172016056897409f26f23add1">push_back</a> (Point_2 (-1,1));</div><div class="line">  P.push_back (Point_2 (0,-1));</div><div class="line">  P.push_back (Point_2 (1,1));</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"P = "</span>; print_polygon (P);</div><div class="line"></div><div class="line">  Polygon_2 Q;</div><div class="line">  Q.push_back(Point_2 (-1,-1));</div><div class="line">  Q.push_back(Point_2 (1,-1));</div><div class="line">  Q.push_back(Point_2 (0,1));</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Q = "</span>; print_polygon (Q);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ((<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__do__intersect__linear__grp.html#ga9514a218a097ac392d21775368d3dd0d">CGAL::do_intersect</a> (P, Q)))</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The two polygons intersect in their interior."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The two polygons do not intersect."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="bso_ssecpolygons_with_holes"></a>
Polygons with Holes</h2>
<p><a class="anchor" id="fig__figsimple"></a></p><div class="image">
<img src="simple.png" alt="simple.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figsimple">Figure 16.3</a> Operations on simple polygons. (a) The union of two polygons, resulting in a point set whose outer boundary is defined by a simple polygon and contains a polygonal hole in its interior. (b) The intersection (darkly shaded) of two polygons (lightly shaded), resulting in two disjoint polygons. (c) The complement (darkly shaded) of a simple polygon (lightly shaded).  </div>  <br />

<p>In many cases a binary operation that operates on two simple polygons that have no holes may result in a set of polygons that contain holes in their interior (see <a class="el" href="index.html#fig__figsimple">Figure 16.3</a> (a)), or a set of disjoint polygons (see <a class="el" href="index.html#fig__figsimple">Figure 16.3</a> (b); a similar set may result from the union, or the symmetric difference, of two disjoint polygons). Moreover, the complement of a simple polygon is an unbounded set that contains a hole; see <a class="el" href="index.html#fig__figsimple">Figure 16.3</a> (c).</p>
<p>Regular sets are closed under regularized Boolean set-operations. These operations accept as input, and may result as output, polygons with holes. A <em>polygon with holes</em> represents a point set that may be bounded or unbounded. In case of a bounded set, its <em>outer boundary</em> is represented as a relatively simple (but not necessarily simple) polygon, whose vertices are oriented in a counterclockwise order around the interior of the set. In addition, the set may contain <em>holes</em>, where each hole is represented as a simple polygon, whose vertices are oriented in a clockwise order around the interior of the hole. Note that an unbounded polygon without holes spans the entire plane. Vertices of holes may coincide with vertices of the boundary; see below for an example.</p>
<p>A point set represented by a polygon with holes is considered to be closed. Therefore, the boundaries of the holes are parts of the set (and not part of the holes). The exact definition of the obtained polygon with holes as a result of a Boolean set-operation or a sequence of such operations is closely related to the definition of regularized Boolean set-operations, being the closure of the interior of the corresponding ordinary operation as explained next.</p>
<div class="image">
<img src="unique.png" alt="unique.png" />
</div>
 <p>Consider, for example, the regular set depicted on the right, which is the result of the union of three small triangles translated appropriately. Alternatively, the same set can be reached by taking the difference between a large triangle and a small upside-down triangle. In general, there are many ways to arrive at a particular point set. However, the set of polygons with holes obtained through the application of any sequence of operations is unique. The set depicted on the right is represented as a single polygon having a triangular outer boundary with a single triangular hole in its interior - and not as three triangles that have no holes at all. As a general rule, if two point sets are connected, then they belong to the same polygon with holes.</p>
<p>The class template <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">Polygon_with_holes_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>,Container&gt;</code> represents polygons with holes as described above, where the outer boundary and the hole boundaries are realized as <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">Polygon_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>,Container&gt;</code> objects. Given an instance \( P\) of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">Polygon_with_holes_2</a></code> class, you can use the predicate <code>is_unbounded()</code> to check whether \( P\) is a unbounded set. If it is bounded, you can obtain the counterclockwise-oriented polygon that represents its outer boundary through the member function <code>outer_boundary()</code>. You can also traverse the holes of \( P\) through <code>holes_begin()</code> and <code>holes_end()</code>. The two functions return iterators of the nested type <code>Polygon_with_holes_2::Hole_const_iterator</code> that defines the valid range of \( P\)'s holes. The value type of this iterator is <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">Polygon_2</a></code>.</p>
<p>The following function demonstrates how to traverse a polygon with holes. It accepts a <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">Polygon_with_holes_2</a></code> object and uses the auxiliary function <code>print_polygon()</code> to prints all its components in a readable format: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Kernel, <span class="keyword">class</span> Container&gt;</div><div class="line"><span class="keywordtype">void</span> print_polygon_with_holes(<span class="keyword">const</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">CGAL::Polygon_with_holes_2&lt;Kernel, Container&gt;</a> &amp; pwh)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (! pwh.is_unbounded()) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"{ Outer boundary = "</span>; </div><div class="line">    print_polygon (pwh.outer_boundary());</div><div class="line">  } <span class="keywordflow">else</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"{ Unbounded polygon."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">CGAL::Polygon_with_holes_2&lt;Kernel,Container&gt;::Hole_const_iterator</a> hit;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 1;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; pwh.number_of_holes() &lt;&lt; <span class="stringliteral">" holes:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (hit = pwh.holes_begin(); hit != pwh.holes_end(); ++hit, ++k) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" Hole #"</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" = "</span>;</div><div class="line">    print_polygon (*hit);</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" }"</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The simple versions of the free functions mentioned therefore accept two <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">Polygon_2</a></code> object \( P\) and \( Q\) as their input, while their output is given using polygon with holes instances: </p><ul>
<li>
The complement of a simple polygon \( P\) is always an unbounded set with a single polygonal hole. The function <code>complement(P)</code> therefore returns a polygon-with-holes object that represents the complement of \( P\). </li>
<li>
The union of two polygons \( P\) and \( Q\) is always a single connected set, unless of course the two input polygons are completely disjoint. In the latter case \( P \cup Q\) trivially consists of the two input polygons. The free function <code>join(P, Q, R)</code> therefore returns a Boolean value indicating whether \( P \cap Q \neq \emptyset\). If the two polygons are not disjoint, it assigns the polygon with holes object \( R\) (which it accepts by reference) with the union of the regularized union operation \( P \cup Q\). </li>
<li>
The other three functions, namely <code>intersection(P, Q, oi)</code>, <code>difference(P, Q, oi)</code> and <code>symmetric_difference(P, Q, oi)</code>, all have a similar interface. As the result of these operation may consist of several disconnected components, they all accept an output iterator <code>oi</code>, whose value type is <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">Polygon_with_holes_2</a></code>, and adds the output polygons to its associated container. </li>
</ul>
<h2><a class="anchor" id="bso_sssecex_simple_bops"></a>
Example - Joining and Intersecting Simple Polygons</h2>
<p>The following example demonstrates the usage of the free functions <code><a class="el" href="group__boolean__join.html#gafca2f0759f989fe95d1c56b0428a0f16" title="writes the union of the polygons p1 and p2 into the polygon with holes res. ">join()</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__intersection__linear__grp.html#gab77f3cd98c4c4ff7acff59c98ab88ff0">intersection()</a></code> for computing the union and the intersection of the two simple polygons depicted in <a class="el" href="index.html#fig__figsimple">Figure 16.3</a> (b). The example uses the auxiliary function <code>print_polygon_with_holes()</code> listed above, which is located in the header file <code>print_utils.h</code> under the examples folder.</p>
<p><br />
<b>File</b> <a class="el" href="Boolean_set_operations_2_2simple_join_intersect_8cpp-example.html">Boolean_set_operations_2/simple_join_intersect.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Boolean_set_operations_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                   Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Kernel&gt;</a>                           Polygon_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">CGAL::Polygon_with_holes_2&lt;Kernel&gt;</a>                Polygon_with_holes_2;</div><div class="line"><span class="keyword">typedef</span> std::list&lt;Polygon_with_holes_2&gt;                   Pwh_list_2;</div><div class="line"></div><div class="line"><span class="preprocessor">#include "print_utils.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the two input polygons.</span></div><div class="line">  Polygon_2 P;</div><div class="line">  P.push_back (Point_2 (0, 0));</div><div class="line">  P.push_back (Point_2 (5, 0));</div><div class="line">  P.push_back (Point_2 (3.5, 1.5));</div><div class="line">  P.push_back (Point_2 (2.5, 0.5));</div><div class="line">  P.push_back (Point_2 (1.5, 1.5));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"P = "</span>; print_polygon (P);</div><div class="line"></div><div class="line">  Polygon_2 Q;</div><div class="line">  Q.push_back (Point_2 (0, 2));</div><div class="line">  Q.push_back (Point_2 (1.5, 0.5));</div><div class="line">  Q.push_back (Point_2 (2.5, 1.5));</div><div class="line">  Q.push_back (Point_2 (3.5, 0.5));</div><div class="line">  Q.push_back (Point_2 (5, 2));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Q = "</span>; print_polygon (Q);</div><div class="line"></div><div class="line">  <span class="comment">// Compute the union of P and Q.</span></div><div class="line">  Polygon_with_holes_2 unionR;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__boolean__join.html#gafca2f0759f989fe95d1c56b0428a0f16">CGAL::join</a> (P, Q, unionR)) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The union: "</span>;</div><div class="line">    print_polygon_with_holes (unionR);</div><div class="line">  } <span class="keywordflow">else</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"P and Q are disjoint and their union is trivial."</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Compute the intersection of P and Q.</span></div><div class="line">  Pwh_list_2                  intR;</div><div class="line">  Pwh_list_2::const_iterator  it;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__intersection__linear__grp.html#gab77f3cd98c4c4ff7acff59c98ab88ff0">CGAL::intersection</a> (P, Q, std::back_inserter(intR));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The intersection:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (it = intR.begin(); it != intR.end(); ++it) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"--&gt; "</span>;</div><div class="line">    print_polygon_with_holes (*it);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="bso_sssecpwh_bops"></a>
Operations on Polygons with Holes</h2>
<p>We have demonstrated that free functions that perform boolean set operations on simple polygons may output polygons with holes. In addition to these functions, the Boolean set-operations package provides the following overridden free functions that accept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1General__polygon__with__holes__2.html">General_polygon_with_holes_2</a></code> objects as their input - <code><a class="el" href="group__boolean__complement.html#ga45629253bda87736f21251bfee532665" title="writes the complement of the polygon pgn into the polygon with holes res. ">complement()</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__intersection__linear__grp.html#gab77f3cd98c4c4ff7acff59c98ab88ff0">intersection()</a></code>, <code><a class="el" href="group__boolean__join.html#gafca2f0759f989fe95d1c56b0428a0f16" title="writes the union of the polygons p1 and p2 into the polygon with holes res. ">join()</a></code>, <code><a class="el" href="group__boolean__difference.html#ga525c4a75749027346fcf444a8fbb31b7" title="writes the difference of the polygons p1 and p2 into the output iterator oi. ">difference()</a></code>, <code><a class="el" href="group__boolean__symmetric__difference.html#ga16f709a3037b2d4ae61141eda60f72e7">symmetric_difference()</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__do__intersect__linear__grp.html#ga9514a218a097ac392d21775368d3dd0d">do_intersect()</a></code> The prototypes of most functions is the same as of their simpler counterparts that operate on simple polygons. The only exception is <code>complement(P, oi)</code>, which outputs a range of polygons with holes that represents the complement of the polygon with holes \( P\).</p>
<div class="image">
<img src="symm_diff.png" alt="symm_diff.png" />
</div>
 <p>The following example demonstrates how to compute the symmetric difference between two sets that contain holes. Each set is a rectangle that contains a rectangular hole in its interior, such that the symmetric difference between the two sets is a single polygon that contains of five holes:</p>
<p><br />
<b>File</b> <a class="el" href="Boolean_set_operations_2_2symmetric_difference_8cpp-example.html">Boolean_set_operations_2/symmetric_difference.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Boolean_set_operations_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                   Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Kernel&gt;</a>                           Polygon_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">CGAL::Polygon_with_holes_2&lt;Kernel&gt;</a>                Polygon_with_holes_2;</div><div class="line"><span class="keyword">typedef</span> std::list&lt;Polygon_with_holes_2&gt;                   Pwh_list_2;</div><div class="line"></div><div class="line"><span class="preprocessor">#include "print_utils.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct P - a bounded rectangle that contains a rectangular hole.</span></div><div class="line">  Polygon_2 outP;</div><div class="line">  Polygon_2 holesP[1];</div><div class="line"></div><div class="line">  outP.push_back (Point_2 (-3, -5));  outP.push_back (Point_2 (3, -5));</div><div class="line">  outP.push_back (Point_2 (3, 5));    outP.push_back (Point_2 (-3, 5));</div><div class="line">  holesP[0].push_back (Point_2 (-1, -3));</div><div class="line">  holesP[0].push_back (Point_2 (-1, 3));</div><div class="line">  holesP[0].push_back (Point_2 (1, 3));</div><div class="line">  holesP[0].push_back (Point_2 (1, -3));</div><div class="line"></div><div class="line">  Polygon_with_holes_2  P (outP, holesP, holesP + 1);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"P = "</span>; print_polygon_with_holes (P);</div><div class="line"></div><div class="line">  <span class="comment">// Construct Q - a bounded rectangle that contains a rectangular hole.</span></div><div class="line">  Polygon_2 outQ;</div><div class="line">  Polygon_2 holesQ[1];</div><div class="line"></div><div class="line">  outQ.push_back (Point_2 (-5, -3));  outQ.push_back (Point_2 (5, -3));</div><div class="line">  outQ.push_back (Point_2 (5, 3));    outQ.push_back (Point_2 (-5, 3));</div><div class="line">  holesQ[0].push_back (Point_2 (-3, -1));</div><div class="line">  holesQ[0].push_back (Point_2 (-3, 1));</div><div class="line">  holesQ[0].push_back (Point_2 (3, 1));</div><div class="line">  holesQ[0].push_back (Point_2 (3, -1));</div><div class="line"></div><div class="line">  Polygon_with_holes_2  Q (outQ, holesQ, holesQ + 1);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Q = "</span>; print_polygon_with_holes (Q);</div><div class="line"></div><div class="line">  <span class="comment">// Compute the symmetric difference of P and Q.</span></div><div class="line">  Pwh_list_2 symmR;</div><div class="line">  Pwh_list_2::const_iterator it;</div><div class="line"></div><div class="line">  <a class="code" href="group__boolean__symmetric__difference.html#ga16f709a3037b2d4ae61141eda60f72e7">CGAL::symmetric_difference</a> (P, Q, std::back_inserter(symmR));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The symmetric difference:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (it = symmR.begin(); it != symmR.end(); ++it) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"--&gt; "</span>;</div><div class="line">    print_polygon_with_holes (*it);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>In some cases it is convenient to connect the outer boundary of a polygon with holes with the holes inside it. The function <code><a class="el" href="group__boolean__connect__holes.html#ga0c649fa14a7f93957b231d9a6bee29ae" title="Connects the holes of pwh with its outer boundary. ">connect_holes()</a></code> accepts a polygon with holes, and connects the topmost vertex in each hole with the polygon feature located directly above it (a vertex or an edge of the outer boundary, or of another hole). It produces an output sequence of points that match the traversal of all vertices in the connected polygon (note that there are additional vertices, induced by the vertical walls).</p>
<p><br />
<b>File</b> <a class="el" href="Boolean_set_operations_2_2connect_polygon_8cpp-example.html">Boolean_set_operations_2/connect_polygon.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/connect_holes.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                   Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Kernel&gt;</a>                           Polygon_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">CGAL::Polygon_with_holes_2&lt;Kernel&gt;</a>                Polygon_with_holes_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  </div><div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div><div class="line">  <span class="comment">// pgn_holes.dat file if no command-line parameters are given.</span></div><div class="line">  <span class="comment">//more data files can be found under test data</span></div><div class="line">  <span class="comment">//boundary no other connections are made.  </span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"pgn_holes.dat"</span>;  </div><div class="line">  std::ifstream input_file (filename);</div><div class="line">  <span class="keywordflow">if</span> (! input_file.is_open())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open the "</span> &lt;&lt; filename &lt;&lt;std::endl;</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Read a polygon with holes from a file.</span></div><div class="line">  Polygon_2               outerP;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            num_holes;</div><div class="line"></div><div class="line">  input_file &gt;&gt; outerP;</div><div class="line">  input_file &gt;&gt; num_holes;</div><div class="line"></div><div class="line">  std::vector&lt;Polygon_2&gt;  holes (num_holes);</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            k;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (k = 0; k &lt; num_holes; k++)</div><div class="line">    input_file &gt;&gt; holes[k];</div><div class="line"></div><div class="line">  Polygon_with_holes_2    P (outerP, holes.begin(), holes.end());</div><div class="line"></div><div class="line">  <span class="comment">// Connect the outer boundary of the polygon with its holes.</span></div><div class="line">  std::list&lt;Point_2&gt;            pts;</div><div class="line">  std::list&lt;Point_2&gt;::iterator  pit;</div><div class="line"></div><div class="line">  <a class="code" href="group__boolean__connect__holes.html#ga0c649fa14a7f93957b231d9a6bee29ae">connect_holes</a> (P, std::back_inserter (pts));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (pit = pts.begin(); pit != pts.end(); ++pit)</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">'('</span> &lt;&lt; *pit &lt;&lt; <span class="stringliteral">")  "</span>;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (0);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="bso_ssecmain_component"></a>
Operating on Polygon Sets</h2>
<p>We argue that the result of a regularized operations on two polygons (or polygons with holes) \( P\) and \( Q\) is typically a collection of several disconnected polygons with holes. It is only natural to represent such a collection in terms of a class, making it possible to operate on the set resulting from computing, for example, \( P \setminus Q\).</p>
<p>A central component in the Boolean set-operations package is the <code><a class="el" href="classCGAL_1_1Polygon__set__2.html" title="The class Polygon_set_2 represents sets of linear polygons with holes. ">Polygon_set_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>, Container, Dcel&gt;</code> class-template. An instance of this class represents a point set formed by the collection of several disconnected polygons with holes. It employs the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class to represent this point set in the plane as a planar arrangement; see Chapter <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#chapterArrangement_on_surface_2">2D Arrangements</a>. The instantiated <code>Dcel</code> type is used to represent the underlying internal arrangement. It must model the concept <code><a class="el" href="classGeneralPolygonSetDcel.html" title="A doubly-connected edge-list (Dcel for short) data-structure. It consists of three containers of reco...">GeneralPolygonSetDcel</a></code>, and defaults to <code><a class="el" href="classCGAL_1_1Gps__default__dcel.html" title="The default Dcel class template used by the General_polygon_set_2 and General_polygon_with_holes_2 cl...">Gps_default_dcel</a></code>. You can override this default, with a different <span class="textsc">Dcel</span> class, typically an extension of the default. Overriding the default is necessary only if you intend to obtain the underlying internal arrangement and process it further.</p>
<p>An instance \( S\) of a <code><a class="el" href="classCGAL_1_1Polygon__set__2.html" title="The class Polygon_set_2 represents sets of linear polygons with holes. ">Polygon_set_2</a></code> class usually represents the result of a sequence of operations that were applied on some input polygons. The representation of \( S\) is unique, regardless of the particular sequence of operations that were applied in order to arrive at it.</p>
<p>In addition, a polygon-set object can be constructed from a single polygon object or from a polygon-with-holes object. Once constructed, it is possible to insert new polygons (or polygons with holes) into the set using the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangement2Insert.html#gaa6e1d86b9725db5998dfb358ab1985f9">insert()</a></code> method, as long as the inserted polygons and the existing polygons in the set are disjoint. The <code><a class="el" href="classCGAL_1_1Polygon__set__2.html" title="The class Polygon_set_2 represents sets of linear polygons with holes. ">Polygon_set_2</a></code> class also provides access functions for accessing the polygons with holes it contains, and a few queries. The most important query is <code>S.oriented_side(q)</code>, which determined whether the query point \( q\) is contained in the interior of the set \( S\), lies on the boundary of the set, or neither.</p>
<p>The <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a></code> class defines the predicate <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__do__intersect__linear__grp.html#ga9514a218a097ac392d21775368d3dd0d">do_intersect()</a></code> and the methods <code><a class="el" href="group__boolean__complement.html#ga45629253bda87736f21251bfee532665" title="writes the complement of the polygon pgn into the polygon with holes res. ">complement()</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__intersection__linear__grp.html#gab77f3cd98c4c4ff7acff59c98ab88ff0">intersection()</a></code>, <code><a class="el" href="group__boolean__join.html#gafca2f0759f989fe95d1c56b0428a0f16" title="writes the union of the polygons p1 and p2 into the polygon with holes res. ">join()</a></code>, <code><a class="el" href="group__boolean__difference.html#ga525c4a75749027346fcf444a8fbb31b7" title="writes the difference of the polygons p1 and p2 into the output iterator oi. ">difference()</a></code> and <code><a class="el" href="group__boolean__symmetric__difference.html#ga16f709a3037b2d4ae61141eda60f72e7">symmetric_difference()</a></code> as member functions. The operands to these functions may be simple polygons (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">Polygon_2</a></code> object), polygons with holes (<code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1General__polygon__with__holes__2.html">General_polygon_with_holes_2</a></code> objects), or polygon sets (<code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a></code> objects). Thus, each of the function mentioned above is actually realized by a set overriding member functions.</p>
<p>Member functions of the <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a></code> that perform Boolean set-operations come in two flavors: for example, <code>S.join(P, Q)</code> computes the union of \( P\) and \( Q\) and assigned the result to \( S\), while <code>S.join(P)</code> performs the operation \( S \longleftarrow S \cup P\). Similarly, <code>S.complement(P)</code> sets \( S\) to be the complement of \( P\), while <code><a class="el" href="group__boolean__complement.html#ga45629253bda87736f21251bfee532665" title="writes the complement of the polygon pgn into the polygon with holes res. ">S.complement()</a></code> simply negates the set \( S\).</p>
<h2><a class="anchor" id="bso_sssecsequence"></a>
A Sequence of Set Operations</h2>
<p>The free functions reviewed in Section <a class="el" href="index.html#bso_ssecpolygons_with_holes">Polygons with Holes</a> serve as a wrapper for the polygon-set class, and are only provided for convenience. A typical such function constructs a pair of <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a></code> objects, invokes the appropriate method to apply the desired Boolean operation, and transforms the resulting polygon set to the required output format. Thus, when several operations are performed in a sequence, it is much more efficient to use the member functions of the <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a></code> type directly, as the extraction of the polygons from the internal representation for some operation, and the reconstruction of the internal representation for the succeeding operation could be time consuming.</p>
<div class="image">
<img src="sequence.png" alt="sequence.png" />
</div>
 <p>The next example performs a sequence of three Boolean set-operations. First, it computes the union of two simple polygons depicted in <a class="el" href="index.html#fig__figsimple">Figure 16.3</a> (a). It then computes the complement of the result of the union operation. Finally, it computes the intersection of the result of the complement operation with a rectangle, confining the final result to the area of the rectangle. The resulting set \( S\) is comprised of two components: a polygon with a hole, and a simple polygon contained in the interior of this hole.</p>
<p><br />
<b>File</b> <a class="el" href="Boolean_set_operations_2_2sequence_8cpp-example.html">Boolean_set_operations_2/sequence.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_with_holes_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_set_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                   Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">CGAL::Polygon_2&lt;Kernel&gt;</a>                           Polygon_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">CGAL::Polygon_with_holes_2&lt;Kernel&gt;</a>                Polygon_with_holes_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Polygon__set__2.html">CGAL::Polygon_set_2&lt;Kernel&gt;</a>                       Polygon_set_2;</div><div class="line"></div><div class="line"><span class="preprocessor">#include "print_utils.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct the two initial polygons and the clipping rectangle.</span></div><div class="line">  Polygon_2 P;</div><div class="line">  P.push_back (Point_2 (0, 1));</div><div class="line">  P.push_back (Point_2 (2, 0));</div><div class="line">  P.push_back (Point_2 (1, 1));</div><div class="line">  P.push_back (Point_2 (2, 2));</div><div class="line"></div><div class="line">  Polygon_2 Q;</div><div class="line">  Q.push_back (Point_2 (3, 1));</div><div class="line">  Q.push_back (Point_2 (1, 2));</div><div class="line">  Q.push_back (Point_2 (2, 1));</div><div class="line">  Q.push_back (Point_2 (1, 0));</div><div class="line"></div><div class="line">  Polygon_2 rect;</div><div class="line">  rect.push_back (Point_2 (0, 0));</div><div class="line">  rect.push_back (Point_2 (3, 0));</div><div class="line">  rect.push_back (Point_2 (3, 2));</div><div class="line">  rect.push_back (Point_2 (0, 2));</div><div class="line"></div><div class="line">  <span class="comment">// Perform a sequence of operations.</span></div><div class="line">  Polygon_set_2 S;</div><div class="line">  S.<a class="code" href="classCGAL_1_1General__polygon__set__2.html#a9d41f55871a2b65d1b421f19f155e6d4">insert</a> (P);</div><div class="line">  S.join (Q);                   <span class="comment">// Compute the union of P and Q.</span></div><div class="line">  S.complement();               <span class="comment">// Compute the complement.</span></div><div class="line">  S.intersection (rect);        <span class="comment">// Intersect with the clipping rectangle.</span></div><div class="line"></div><div class="line">  <span class="comment">// Print the result.</span></div><div class="line">  std::list&lt;Polygon_with_holes_2&gt; res;</div><div class="line">  std::list&lt;Polygon_with_holes_2&gt;::const_iterator it;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The result contains "</span> &lt;&lt; S.number_of_polygons_with_holes()</div><div class="line">            &lt;&lt; <span class="stringliteral">" components:"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  S.polygons_with_holes (std::back_inserter (res));</div><div class="line">  <span class="keywordflow">for</span> (it = res.begin(); it != res.end(); ++it) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"--&gt; "</span>;</div><div class="line">    print_polygon_with_holes (*it);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="bso_ssecinsert_ni"></a>
Inserting Non Intersecting Polygons</h2>
<p>If you want to compute the union of a polygon \( P\) ( \( P\) may be a simple polygon or a polygon-with-holes object) with a general-polygon set \( R\), and store the result in \( R\), you can construct a polygon set \( S(P)\), and apply the <em>union</em> operation as follows: </p><div class="fragment"><div class="line">General_polygon_2 S (P);</div><div class="line">R.join (S);</div></div><!-- fragment --><p>As a matter of fact, you can apply the union operation directly: </p><div class="fragment"><div class="line">R.join (P);</div></div><!-- fragment --><p>However, if you know that the polygon does not intersect any one of the polygons represented by \( R\), you can use the more efficient method <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangement2Insert.html#gaa6e1d86b9725db5998dfb358ab1985f9">insert()</a></code>: </p><div class="fragment"><div class="line">R.insert (P);</div></div><!-- fragment --><p>As <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangement2Insert.html#gaa6e1d86b9725db5998dfb358ab1985f9">insert()</a></code> assumes that \( P \cap R = \emptyset\), it does not try to compute intersections between the boundaries of \( P\) and of \( R\). This fact significantly speeds up the insertion process in comparison with the insertion of a non-disjoint polygon that intersects \( R\).</p>
<p>The <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangement2Insert.html#gaa6e1d86b9725db5998dfb358ab1985f9">insert()</a></code> function is also overloaded, so it can also accept a range of polygons. When a range of polygons are inserted into a polygon set \( S\), all the polygons in the range and the polygons represented by \( S\) must be pairwise disjoint in their interiors.</p>
<h2><a class="anchor" id="bso_ssecagg_ops"></a>
Performing Aggregated Operations</h2>
<p>There are a few options to compute the union of a set of polygons \( P_1, \ldots P_m\). You can do it incrementally as follows. At each step compute the union of \( S_{k-1} = \bigcup_{i=1}^{k-1}{P_i}\) with \( P_{k}\) and obtain \( S_k\). Namely, if the polygon set is given as a pair of iterator <code>[begin, end)</code>, the following loop computes their union in \( S\). </p><div class="fragment"><div class="line"><a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Manual.tag:../Manual/" href="../Manual/classInputIterator.html">InputIterator</a> iter = begin;</div><div class="line">Polygon_set_2 S (*iter);</div><div class="line"></div><div class="line"><span class="keywordflow">while</span> (++iter != end) {</div><div class="line">  S.join (*iter);</div><div class="line">  ++iter;</div><div class="line">}</div></div><!-- fragment --><p> A second option is to use a divide-and-conquer approach. You bisect the set of polygons into two sets. Compute the union of each set recursively and obtain the partial results in \( S_1\) and \( S_2\), and finally, you compute the union \( S_1 \cup S_2\). However, the union operation can be done more efficiently for sparse polygons, having a relatively small number of intersections, using a third option that simultaneously computes the union of all polygons. This is done by constructing a planar arrangement of all input polygons, utilizing the sweep-line algorithm, then extracting the result from the arrangement. Similarly, it is also possible to aggregately compute the intersection \( \bigcap_{i=1}^{m}{P_i}\) of a set of input polygons.</p>
<p>Our package provides the free overloaded functions <code><a class="el" href="group__boolean__join.html#gafca2f0759f989fe95d1c56b0428a0f16" title="writes the union of the polygons p1 and p2 into the polygon with holes res. ">join()</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__intersection__linear__grp.html#gab77f3cd98c4c4ff7acff59c98ab88ff0">intersection()</a></code> that aggregately compute the union and the intersection of a range of input polygons. There is no restriction on the polygons in the range - naturally, they may intersect each other. The package provides the overloaded free function <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__do__intersect__linear__grp.html#ga9514a218a097ac392d21775368d3dd0d">do_intersect(begin, end)</a> that determines whether the polygons in the range defined by the two input iterators <code>[begin, end)</code> intersect.</p>
<p>The class <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a></code> also provides equivalent member functions that aggregately operate on a range of input polygons or polygons with holes. When such a member function is called, the general polygons represented by the current object are considered operands as well. Thus, you can easily compute the union of our polygon range as follows: </p><div class="fragment"><div class="line">Polygon_set_2 S;</div><div class="line">S.join (begin, end);</div></div><!-- fragment --><h1><a class="anchor" id="bso_secbso_gen"></a>
Boolean Set-Operations on General Polygons</h1>
<div class="image">
<img src="general_polygon.png" alt="general_polygon.png" />
</div>
 <p>In previous sections only ordinary (linear) polygons were dealt with. Namely, closed point sets bounded by piecewise linear curves. The Boolean set-operations package allows a more general geometric mapping of the polygon edges. The operations provided by the package operate on point sets bounded by \( x\)-monotone segments of general curves (e.g., conic arcs and segments of polynomial functions). For example, the point set depicted on the right is a general polygon bounded by two \( x\)-monotone circular arcs that correspond to the lower half and the upper half of a circle, respectively.</p>
<p>Using the topological terminology, a general polygon can represent any simply-connected point set whose boundary is a strictly simple curve. Such a polygon is a model of the <code><a class="el" href="classGeneralPolygon__2.html">GeneralPolygon_2</a></code> concept. A model of this concept must fulfill the following requirements: </p><ul>
<li>
A general polygon is constructible from a range of pairwise interior disjoint \( x\)-monotone curves \( c_1, \ldots, c_n\). The target point of the \( k\)th curve \( c_k\) and the source point of the next curve in the range (in a cyclic order) must coincide, such that this point defines the \( k\)th polygon vertex. </li>
<li>
It is possible to traverse the \( x\)-monotone curves that form the edges of a general polygon. </li>
</ul>
<div class="image">
<img src="general_polygon_with_holes.png" alt="general_polygon_with_holes.png" />
</div>
 <p>The concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classGeneralPolygonWithHoles__2.html">GeneralPolygonWithHoles_2</a></code> is defined in an analogous way to the definition of linear polygons with holes. A model of this concept represent a bounded or an unbounded set that may not be simply connected, and must provide the following operations:</p>
<ul>
<li>
Construction for a general polygon that represent the outer boundary and a range of general polygons that represent the holes. </li>
<li>
Accessing the general polygons that represents the outer boundary (in case of a bounded set). </li>
<li>
Traversing the holes. </li>
</ul>
<p>In Section <a class="el" href="index.html#bso_secbso_lin">Boolean Set-Operations on Linear Polygons</a> we introduce the classes <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__2.html">Polygon_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classCGAL_1_1Polygon__with__holes__2.html">Polygon_with_holes_2</a></code> that model the concepts <code><a class="el" href="classGeneralPolygon__2.html">GeneralPolygon_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classGeneralPolygonWithHoles__2.html">GeneralPolygonWithHoles_2</a></code> respectively. In this section we introduce other models of these two concepts.</p>
<p>The central class-template <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a>&lt;Traits,Dcel&gt;</code> is used to represent point sets that are comprised of a finite number of pairwise disjoint general polygons with holes, and provides various Boolean set-operations on such sets. It is parameterized by a <em>traits</em> class and a <span class="textsc">Dcel</span> class. The former defines the type of points used to represent polygon vertices and the type of \( x\)-monotone curves that represent the polygon edges. The traits class also provides primitive geometric operations that operate on objects of these types. The <span class="textsc">Dcel</span> class is used to represent the underlying internal <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> data structure. The instantiated <code>Dcel</code> type is used to represent the underlying internal arrangement. It must model the concept <code><a class="el" href="classGeneralPolygonSetDcel.html" title="A doubly-connected edge-list (Dcel for short) data-structure. It consists of three containers of reco...">GeneralPolygonSetDcel</a></code>, and defaults to <code><a class="el" href="classCGAL_1_1Gps__default__dcel.html" title="The default Dcel class template used by the General_polygon_set_2 and General_polygon_with_holes_2 cl...">Gps_default_dcel</a></code>. You can override this default, with a different <span class="textsc">Dcel</span> class, typically an extension of the default. Overriding the default is necessary only if you intend to obtain the underlying internal arrangement and process it further.</p>
<p>An instantiated <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a></code> class defines the nested types <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a>&lt;Traits,Dcel&gt;::Polygon_2</code> and <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a>&lt;Traits,Dcel&gt;::Polygon_with_holes_2</code>, which model the concepts <code><a class="el" href="classGeneralPolygon__2.html">GeneralPolygon_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Polygon.tag:../Polygon/" href="../Polygon/classGeneralPolygonWithHoles__2.html">GeneralPolygonWithHoles_2</a></code> respectively.</p>
<h2><a class="anchor" id="bso_ssectraits_concepts"></a>
The Traits-Class Concepts</h2>
<p>The traits class used to instantiate the <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a></code> class template must model the concept <code><a class="el" href="classGeneralPolygonSetTraits__2.html" title="This concept defines the minimal set of geometric predicates needed to perform the Boolean-set operat...">GeneralPolygonSetTraits_2</a></code>, and is tailored to handle a specific family of curves. The concept <code><a class="el" href="classGeneralPolygonSetTraits__2.html" title="This concept defines the minimal set of geometric predicates needed to perform the Boolean-set operat...">GeneralPolygonSetTraits_2</a></code> refines the concept <code><a class="el" href="classArrangementDirectionalXMonotoneTraits__2.html" title="This concept refines the basic arrangement -monotone traits concept. A model of this concept is able ...">ArrangementDirectionalXMonotoneTraits_2</a></code> specified next.</p>
<p>The concept <code><a class="el" href="classArrangementDirectionalXMonotoneTraits__2.html" title="This concept refines the basic arrangement -monotone traits concept. A model of this concept is able ...">ArrangementDirectionalXMonotoneTraits_2</a></code> refines the concept <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classArrangementXMonotoneTraits__2.html">ArrangementXMonotoneTraits_2</a></code> (see Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_sssecinsert_x_mon">Inserting x-Monotone Curves</a> in the 2D Arrangements chapter). Thus, a model of this concept must define the type <code>X_monotone_curve_2</code>, which represents an \( x\)-monotone curve, and the type <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code>, with represents a planar point. Such a point may be an endpoint of an \( x\)-monotone curve or an intersection point between two curves. It must also provide various geometric predicates and operations on these types listed by the base concept, such as determining whether a point lies above or below an \( x\)-monotone curve, computing the intersections between two curves, etc. Note that the base concept does not assume that \( x\)-monotone curves are directed: an \( x\)-monotone curve is not required to have a designated <em>source</em> and <em>target</em>, it is only required to determine the left (lexicographically smaller) and the right (lexicographically larger) endpoints of a given curve.</p>
<p>The <code><a class="el" href="classArrangementDirectionalXMonotoneTraits__2.html" title="This concept refines the basic arrangement -monotone traits concept. A model of this concept is able ...">ArrangementDirectionalXMonotoneTraits_2</a></code> concept treats its \( x\)-monotone curves as directed objects. It thus requires two additional operations on \( x\)-monotone curves: </p><ul>
<li>
Given an \( x\)-monotone curve, compare its source and target points lexicographically. </li>
<li>
Given an \( x\)-monotone curve, construct its opposite curve (namely, swap its source and target points). </li>
</ul>
<p>The traits classes <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__segment__traits__2.html">Arr_segment_traits_2</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__non__caching__segment__traits__2.html">Arr_non_caching_segment_traits_2</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__circle__segment__traits__2.html">Arr_circle_segment_traits_2</a></code>, <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__conic__traits__2.html">Arr_conic_traits_2</a></code> and <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__rational__function__traits__2.html">Arr_rational_function_traits_2</a></code>, which are bundled in the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> package and distributed with <span style="font-variant: small-caps;">CGAL</span>, are all models of the refined concept <code><a class="el" href="classArrangementDirectionalXMonotoneTraits__2.html" title="This concept refines the basic arrangement -monotone traits concept. A model of this concept is able ...">ArrangementDirectionalXMonotoneTraits_2</a></code>.<span class="footnote">The <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__polyline__traits__2.html">Arr_polyline_traits_2</a></code> class is <em>not</em> a model of the, <code><a class="el" href="classArrangementDirectionalXMonotoneTraits__2.html" title="This concept refines the basic arrangement -monotone traits concept. A model of this concept is able ...">ArrangementDirectionalXMonotoneTraits_2</a></code> concept, as the \( x\)-monotone curve it defines is always directed from left to right. Thus, an opposite curve cannot be constructed. However, it is not very useful to construct a polygon whose edges are polylines, as an ordinary polygon with linear edges can represent the same entity.</span></p>
<p>Just as with the case of computations using models of the <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classArrangementXMonotoneTraits__2.html">ArrangementXMonotoneTraits_2</a></code> concept, operations are robust only when exact arithmetic is used. When inexact arithmetic is used, (nearly) degenerate configurations may result in abnormal termination of the program or even incorrect results.</p>
<h2><a class="anchor" id="bso_sseccirc_seg"></a>
Operating on Polygons with Circular Arcs</h2>
<p>Two traits classes are distributed with <span style="font-variant: small-caps;">CGAL</span>. The first one is named <code><a class="el" href="classCGAL_1_1Gps__segment__traits__2.html">Gps_segment_traits_2</a></code>, and it is used to perform Boolean set-operations on ordinary polygons and polygons with holes. In fact, the class <code><a class="el" href="classCGAL_1_1Polygon__set__2.html" title="The class Polygon_set_2 represents sets of linear polygons with holes. ">Polygon_set_2</a></code> introduced in Section <a class="el" href="index.html#bso_ssecmain_component">Operating on Polygon Sets</a> is a specialization of <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a>&lt;<a class="el" href="classCGAL_1_1Gps__segment__traits__2.html">Gps_segment_traits_2</a>&gt;</code>. This class defined its polygon and polygon with holes types, such that the usage of this traits class is encapsulated in the polygon-set class.</p>
<p>The other predefined traits class is named <code><a class="el" href="classCGAL_1_1Gps__circle__segment__traits__2.html" title="The traits class Gps_circle_segment_traits_2 models the GeneralPolygonSetTraits_2 concept...">Gps_circle_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> and is parameterized by a geometric <span style="font-variant: small-caps;">CGAL</span> kernel. By instantiating the <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a></code> with this traits class, we obtain the representation of a polygon whose boundary may be comprised of line segments and circular arcs. The circle-segment traits class provides predicates and constructions on non-linear objects; yet, it uses only rational arithmetic and is very efficient as a consequence.</p>
<div class="image">
<img src="circles_rects.png" alt="circles_rects.png" />
</div>
 <p>The following example uses the <code><a class="el" href="classCGAL_1_1Gps__circle__segment__traits__2.html" title="The traits class Gps_circle_segment_traits_2 models the GeneralPolygonSetTraits_2 concept...">Gps_circle_segment_traits_2</a></code> class to compute the union of four rectangles and four circles. Each circle is represented as a general polygon having two \( x\)-monotone circular arcs. The union is computed incrementally, resulting with a single polygon with a single hole, as depicted on the right. Note that as the four circles are disjoint, their union is computed with the <code>insert</code> method, while the union with the rectangles is computed with the <code>join</code> operator.</p>
<p><br />
<b>File</b> <a class="el" href="Boolean_set_operations_2_2circle_segment_8cpp-example.html">Boolean_set_operations_2/circle_segment.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Gps_circle_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/General_polygon_set_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Lazy__exact__nt_8h.html">CGAL/Lazy_exact_nt.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                   Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Circle__2.html">Kernel::Circle_2</a>                                  Circle_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Gps__circle__segment__traits__2.html">CGAL::Gps_circle_segment_traits_2&lt;Kernel&gt;</a>         Traits_2;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1General__polygon__set__2.html">CGAL::General_polygon_set_2&lt;Traits_2&gt;</a>             Polygon_set_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::General_polygon_2                       Polygon_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::General_polygon_with_holes_2            Polygon_with_holes_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                                 Curve_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                      X_monotone_curve_2;</div><div class="line"></div><div class="line"><span class="comment">// Construct a polygon from a circle.</span></div><div class="line">Polygon_2 construct_polygon (<span class="keyword">const</span> Circle_2&amp; circle)</div><div class="line">{</div><div class="line">  <span class="comment">// Subdivide the circle into two x-monotone arcs.</span></div><div class="line">  Traits_2 traits;</div><div class="line">  Curve_2 curve (circle);</div><div class="line">  std::list&lt;CGAL::Object&gt;  objects;</div><div class="line">  traits.make_x_monotone_2_object() (curve, std::back_inserter(objects));</div><div class="line">  CGAL_assertion (objects.size() == 2);</div><div class="line"></div><div class="line">  <span class="comment">// Construct the polygon.</span></div><div class="line">  Polygon_2 pgn;</div><div class="line">  X_monotone_curve_2 arc;</div><div class="line">  std::list&lt;CGAL::Object&gt;::iterator iter;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (iter = objects.begin(); iter != objects.end(); ++iter) {</div><div class="line">    CGAL::assign (arc, *iter);</div><div class="line">    pgn.push_back (arc);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> pgn;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Construct a polygon from a rectangle.</span></div><div class="line">Polygon_2 construct_polygon (<span class="keyword">const</span> Point_2&amp; p1, <span class="keyword">const</span> Point_2&amp; p2,</div><div class="line">                             <span class="keyword">const</span> Point_2&amp; p3, <span class="keyword">const</span> Point_2&amp; p4)</div><div class="line">{</div><div class="line">  Polygon_2 pgn;</div><div class="line">  X_monotone_curve_2 s1(p1, p2);    pgn.push_back(s1);</div><div class="line">  X_monotone_curve_2 s2(p2, p3);    pgn.push_back(s2);</div><div class="line">  X_monotone_curve_2 s3(p3, p4);    pgn.push_back(s3);</div><div class="line">  X_monotone_curve_2 s4(p4, p1);    pgn.push_back(s4);</div><div class="line">  <span class="keywordflow">return</span> pgn;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// The main program:</span></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="comment">// Insert four non-intersecting circles.</span></div><div class="line">  Polygon_set_2 S;</div><div class="line">  Polygon_2 circ1, circ2, circ3, circ4;</div><div class="line"></div><div class="line">  circ1 = construct_polygon(Circle_2(Point_2(1, 1), 1));  S.insert(circ1);</div><div class="line">  circ2 = construct_polygon(Circle_2(Point_2(5, 1), 1));  S.insert(circ2);</div><div class="line">  circ3 = construct_polygon(Circle_2(Point_2(5, 5), 1));  S.insert(circ3);</div><div class="line">  circ4 = construct_polygon(Circle_2(Point_2(1, 5), 1));  S.insert(circ4);</div><div class="line"></div><div class="line">  <span class="comment">// Compute the union with four rectangles incrementally.</span></div><div class="line">  Polygon_2 rect1, rect2, rect3, rect4;</div><div class="line"></div><div class="line">  rect1 = construct_polygon(Point_2(1, 0), Point_2(5, 0),</div><div class="line">                            Point_2(5, 2), Point_2(1, 2));</div><div class="line">  S.join (rect1);</div><div class="line"></div><div class="line">  rect2 = construct_polygon(Point_2(1, 4), Point_2(5, 4),</div><div class="line">                            Point_2(5, 6), Point_2(1, 6));</div><div class="line">  S.join (rect2);</div><div class="line"></div><div class="line">  rect3 = construct_polygon(Point_2(0, 1), Point_2(2, 1),</div><div class="line">                            Point_2(2, 5), Point_2(0, 5));</div><div class="line">  S.join (rect3);</div><div class="line"></div><div class="line">  rect4 = construct_polygon(Point_2(4, 1), Point_2(6, 1),</div><div class="line">                            Point_2(6, 5), Point_2(4, 5));</div><div class="line">  S.join (rect4);</div><div class="line"></div><div class="line">  <span class="comment">// Print the output.</span></div><div class="line">  std::list&lt;Polygon_with_holes_2&gt; res;</div><div class="line">  S.polygons_with_holes (std::back_inserter (res));</div><div class="line"></div><div class="line">  std::copy (res.begin(), res.end(),</div><div class="line">             std::ostream_iterator&lt;Polygon_with_holes_2&gt;(std::cout, <span class="stringliteral">"\n"</span>));</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="bso_ssecgeneral_polygon_concept"></a>
General Polygon Set Traits Adapter</h2>
<p>The concept <code><a class="el" href="classGeneralPolygon__2.html">GeneralPolygon_2</a></code> and its generic model <code><a class="el" href="classCGAL_1_1General__polygon__2.html" title="The class General_polygon_2 models the concept GeneralPolygon_2. ">General_polygon_2</a>&lt;ArrDirectionalXMonotoneTraits&gt;</code> facilitate the production of general-polygon set traits classes. A model of the concept <code><a class="el" href="classGeneralPolygon__2.html">GeneralPolygon_2</a></code> represents a simple point-set in the plane bounded by \( x\)-monotone curves. As opposed to the plain <code>Traits::Polygon_2</code> type defined by any traits class, it must define the type <code>X_monotone_curve_2</code>, which represents an \( x\)-monotone curve of the point-set boundary. It must provide a constructor from a range of such curves, and a pair of methods, namely <code>curves_begin()</code> and <code>curves_end()</code>, that can be used to iterate over the point-set boundary curves.</p>
<p>The class-template <code><a class="el" href="classCGAL_1_1General__polygon__2.html" title="The class General_polygon_2 models the concept GeneralPolygon_2. ">General_polygon_2</a>&lt;ArrDirectionalXMonotoneTraits&gt;</code> models the concept <code><a class="el" href="classGeneralPolygon__2.html">GeneralPolygon_2</a></code>. Its sole template parameter must be instantiated with a model of the concept <code><a class="el" href="classArrangementDirectionalXMonotoneTraits__2.html" title="This concept refines the basic arrangement -monotone traits concept. A model of this concept is able ...">ArrangementDirectionalXMonotoneTraits_2</a></code> from which it obtains the <code>X_monotone_curve_2</code> type. It uses the geometric operations on this type provided by such a model to maintain a container of directed curves of type <code>X_monotone_curve_2</code>, which represents a boundary of the general polygon.</p>
<p>The class-template <code><a class="el" href="classCGAL_1_1Gps__traits__2.html" title="The traits class Gps_traits_2 models the concept GeneralPolygonSetTraits_2. ">Gps_traits_2</a>&lt;ArrDirectionalXMonotoneTraits,GeneralPolygon&gt;</code> models the concept <code><a class="el" href="classGeneralPolygonSetTraits__2.html" title="This concept defines the minimal set of geometric predicates needed to perform the Boolean-set operat...">GeneralPolygonSetTraits_2</a></code>, and can be used to instantiate the class template <code><a class="el" href="classCGAL_1_1General__polygon__set__2.html" title="An object of the General_polygon_set_2 class-template represents a point set in the plane bounded by ...">General_polygon_set_2</a></code>. It serves as an adapter for a geometric traits class, which models the concept <code><a class="el" href="classArrangementDirectionalXMonotoneTraits__2.html" title="This concept refines the basic arrangement -monotone traits concept. A model of this concept is able ...">ArrangementDirectionalXMonotoneTraits_2</a></code>. It can be used for performing set-operations on general polygons. The implementation of the adapter is rather simple, as it is derived from the instantiated template-parameter <code>ArrXMonotoneTraits_2</code> inheriting its necessary types and methods. It further exploits the methods provided by the instantiated parameter <code>GeneralPolygon</code>, which is a model of the concept <code><a class="el" href="classGeneralPolygon__2.html">GeneralPolygon_2</a></code>. By default, the <code>GeneralPolygon</code> parameter is defined as <code><a class="el" href="classCGAL_1_1General__polygon__2.html" title="The class General_polygon_2 models the concept GeneralPolygon_2. ">General_polygon_2</a>&lt;<a class="el" href="classArrangementDirectionalXMonotoneTraits__2.html" title="This concept refines the basic arrangement -monotone traits concept. A model of this concept is able ...">ArrangementDirectionalXMonotoneTraits_2</a>&gt;</code>.</p>
<p>The code excerpt listed below defines a general-polygon set type that can be used to perform Boolean set-operations on point sets bounded by the \( x\)-monotone curve type defined by the arrangement-traits class <code>Arr_traits_2</code>, which is some representative model of the concept <code><a class="el" href="classArrangementDirectionalXMonotoneTraits__2.html" title="This concept refines the basic arrangement -monotone traits concept. A model of this concept is able ...">ArrangementDirectionalXMonotoneTraits_2</a></code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/General_polygon_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Gps_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1General__polygon__2.html">CGAL::General_polygon_2&lt;Arr_traits_2&gt;</a> General_polygon_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Gps__traits__2.html">CGAL::Gps_traits_2&lt;Arr_traits_2, General_polygon_2&gt;</a> Traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1General__polygon__set__2.html">CGAL::General_polygon_set_2&lt;Traits_2&gt;</a> General_polygon_set_2;</div></div><!-- fragment --><div class="image">
<img src="tnr_m_g.png" alt="tnr_m_g.png" />
</div>
 <p>Instantiating the arrangement-traits <code>Arr_traits_2</code> above with the traits class that handle Bzier curves <code><a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__Bezier__curve__traits__2.html">Arr_Bezier_curve_traits_2</a></code>, results with the definition of a general-polygon set type that can be used to perform Boolean set-operations on point sets bounded by Bzier curves.</p>
<p>The next example computes the intersection of two general polygons bounded by Bzier curves read from two input files respectively. The default input files our example uses (<code>char_g.dat</code> and <code>char_m.dat</code>) define two general polygons shaped in the form of the characters <b>g</b> and <b>m</b> in the Times New Roman font respectively. Their intersection comprises nine simple polygons, as depicted to the right.</p>
<p>Recall that every Bzier curve is defined by a sequence of control points that form chains (see Section <a class="elRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_ssectr_bez">A Traits Class for Planar Bzier Curves</a>. The last control point of every curve must be identical to the first control point of its successor. The function <code>read_Bezier_polygon()</code> included in the example reads the curves from an input file until they form a closed chain, which is assumed to be the outer boundary of the polygon. If more curves are available, its starts constructing polygons that correspond to holes in the area bounded by the outer boundary. Note that this function is also responsible for subdividing the input Bzier curves into \( x\)-monotone subcurves, as required by the <code><a class="el" href="classCGAL_1_1Gps__traits__2.html" title="The traits class Gps_traits_2 models the concept GeneralPolygonSetTraits_2. ">Gps_traits_2</a></code> adapter.</p>
<p><br />
<b>File</b> <a class="el" href="Boolean_set_operations_2_2bezier_traits_adapter_8cpp-example.html">Boolean_set_operations_2/bezier_traits_adapter.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef CGAL_USE_CORE</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE ..."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> (0);</div><div class="line">}</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/CORE_algebraic_number_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_Bezier_curve_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Gps_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Boolean_set_operations_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::CORE_algebraic_number_traits              Nt_traits;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Rational                             Rational;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Algebraic                            Algebraic;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Rational&gt;</a>                       Rat_kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Algebraic&gt;</a>                      Alg_kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__Bezier__curve__traits__2.html">CGAL::Arr_Bezier_curve_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</a></div><div class="line">                                                        Traits_2;</div><div class="line">  </div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Point_2                             Rat_point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                               Bezier_curve_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                    X_monotone_curve_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Gps__traits__2.html">CGAL::Gps_traits_2&lt;Traits_2&gt;</a>                    Gps_traits_2;</div><div class="line"><span class="keyword">typedef</span> Gps_traits_2::General_polygon_2                 Polygon_2;</div><div class="line"><span class="keyword">typedef</span> Gps_traits_2::General_polygon_with_holes_2      Polygon_with_holes_2;</div><div class="line"><span class="keyword">typedef</span> std::list&lt;Polygon_with_holes_2&gt;                 Polygon_set;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> read_Bezier_polygon(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, Polygon_with_holes_2&amp; P)</div><div class="line">{</div><div class="line">  <span class="comment">// Open the input file.</span></div><div class="line">  std::ifstream   in_file(filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open())</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">  </div><div class="line">  <span class="comment">// Read the number of curves.</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      n_curves;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      k;</div><div class="line"></div><div class="line">  in_file &gt;&gt; n_curves;</div><div class="line"></div><div class="line">  <span class="comment">// Read the curves one by one, and construct the general polygon these</span></div><div class="line">  <span class="comment">// curve form (the outer boundary and the holes inside it).</span></div><div class="line">  Traits_2                    traits;</div><div class="line">  Traits_2::Make_x_monotone_2 mk_x_monotone = traits.make_x_monotone_2_object();</div><div class="line">  <span class="keywordtype">bool</span>                        first = <span class="keyword">true</span>;</div><div class="line">  Rat_point_2                 p_0;</div><div class="line">  std::list&lt;X_monotone_curve_2&gt;  xcvs;</div><div class="line">  Rat_kernel                  ker;</div><div class="line">  Rat_kernel::Equal_2         equal = ker.equal_2_object();</div><div class="line">  std::list&lt;Polygon_2&gt;        pgns;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (k = 0; k &lt; n_curves; k++) {</div><div class="line">    <span class="comment">// Read the current curve and subdivide it into x-monotone subcurves.</span></div><div class="line">    Bezier_curve_2                           B;</div><div class="line">    std::list&lt;CGAL::Object&gt;                  x_objs;</div><div class="line">    std::list&lt;CGAL::Object&gt;::const_iterator  xoit;</div><div class="line">    X_monotone_curve_2                       xcv;</div><div class="line"></div><div class="line">    in_file &gt;&gt; B;</div><div class="line">    mk_x_monotone(B, std::back_inserter(x_objs));</div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (xoit = x_objs.begin(); xoit != x_objs.end(); ++xoit) {</div><div class="line">      <span class="keywordflow">if</span> (CGAL::assign(xcv, *xoit))</div><div class="line">        xcvs.push_back(xcv);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// Check if the current curve closes a polygon, namely whether it target</span></div><div class="line">    <span class="comment">// point (the last control point) equals the source of the first curve in</span></div><div class="line">    <span class="comment">// the current chain.</span></div><div class="line">    <span class="keywordflow">if</span> (! first) {</div><div class="line">      <span class="keywordflow">if</span> (equal(p_0, B.control_point(B.number_of_control_points() - 1))) {</div><div class="line">        <span class="comment">// Push a new polygon into the polygon list. Make sure that the polygon</span></div><div class="line">        <span class="comment">// is counterclockwise oriented if it represents the outer boundary</span></div><div class="line">        <span class="comment">// and clockwise oriented if it represents a hole.</span></div><div class="line">        Polygon_2          pgn(xcvs.begin(), xcvs.end());</div><div class="line">        <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga59bee58a806ccde81562ea315ff75525">CGAL::Orientation</a>  orient = pgn.orientation();</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> ((pgns.empty() &amp;&amp; (orient == <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>)) ||</div><div class="line">            (! pgns.empty() &amp;&amp; (orient == <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga39fcfbab0b0f0ce9139ad1613e21d60d">CGAL::COUNTERCLOCKWISE</a>)))</div><div class="line">          pgn.reverse_orientation();</div><div class="line">        </div><div class="line">        pgns.push_back(pgn);</div><div class="line">        xcvs.clear();</div><div class="line">        first = <span class="keyword">true</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">      <span class="comment">// This is the first curve in the chain - store its source point.</span></div><div class="line">      p_0 = B.control_point(0);</div><div class="line">      first = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! xcvs.empty())</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Construct the polygon with holes.</span></div><div class="line">  std::list&lt;Polygon_2&gt;::iterator     pit = pgns.begin();</div><div class="line">  </div><div class="line">  ++pit;</div><div class="line">  P = Polygon_with_holes_2(pgns.front(), pit, pgns.end());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// The main program.</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Get the name of the input files from the command line, or use the default</span></div><div class="line">  <span class="comment">// char_g.dat and char_m.dat files if no command-line parameters are given.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename1 = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"char_g.dat"</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename2 = (argc &gt; 2) ? argv[2] : <span class="stringliteral">"char_m.dat"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Read the general polygons from the input files.</span></div><div class="line">  CGAL::Timer           timer;</div><div class="line">  Polygon_with_holes_2  P1, P2;</div><div class="line"></div><div class="line">  timer.start();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! read_Bezier_polygon(filename1, P1)) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to read "</span> &lt;&lt; filename1 &lt;&lt; <span class="stringliteral">" ..."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! read_Bezier_polygon(filename2, P2)) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to read "</span> &lt;&lt; filename2 &lt;&lt; <span class="stringliteral">" ..."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  timer.stop();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Constructed the input polygons in "</span> &lt;&lt; timer.time() </div><div class="line">            &lt;&lt; <span class="stringliteral">" seconds."</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  <span class="comment">// Compute the intersection of the two polygons.</span></div><div class="line">  Polygon_set                     R;</div><div class="line">  Polygon_set::const_iterator     rit;</div><div class="line"></div><div class="line">  timer.reset();</div><div class="line">  timer.start();</div><div class="line">  <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__intersection__linear__grp.html#gab77f3cd98c4c4ff7acff59c98ab88ff0">CGAL::intersection</a>(P1, P2, std::back_inserter(R));</div><div class="line">  timer.stop();</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The intersection polygons are of sizes: {"</span>;</div><div class="line">  <span class="keywordflow">for</span> (rit = R.begin(); rit != R.end(); ++rit)</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; rit-&gt;outer_boundary().size();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" }"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The intersection computation took "</span></div><div class="line">            &lt;&lt; timer.time() &lt;&lt; <span class="stringliteral">" seconds."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h2><a class="anchor" id="bso_ssecaggregated_gen_ops"></a>
Example - Aggregated Operations</h2>
<p>In Section <a class="el" href="index.html#bso_ssecagg_ops">Performing Aggregated Operations</a> we describe how aggregated union and intersection operations can be applied to a collection of ordinary polygons or polygons with holes. Naturally, the aggregated operations can be applied also to collections of general polygons. As was the case with ordinary polygons, using aggregated operations is recommended when the number of intersections of the input polygons is of the same order of magnitude as the complexity of the result. If this is not the case, computing the result incrementally may prove faster.</p>
<div class="image">
<img src="disks.png" alt="disks.png" />
</div>
 <p>The next example computes the union of eight unit discs whose centers are placed a unit distance from the origin, as depicted to the right. The example also allows users to provide a different number of discs through the command line.</p>
<p><br />
<b>File</b> <a class="el" href="Boolean_set_operations_2_2set_union_8cpp-example.html">Boolean_set_operations_2/set_union.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Gps_circle_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Boolean_set_operations_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/Lazy__exact__nt_8h.html">CGAL/Lazy_exact_nt.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                   Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Circle__2.html">Kernel::Circle_2</a>                                  Circle_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Gps__circle__segment__traits__2.html">CGAL::Gps_circle_segment_traits_2&lt;Kernel&gt;</a>         Traits_2;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1General__polygon__set__2.html">CGAL::General_polygon_set_2&lt;Traits_2&gt;</a>             Polygon_set_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Polygon_2                               Polygon_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Polygon_with_holes_2                    Polygon_with_holes_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Curve_2                                 Curve_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                      X_monotone_curve_2;</div><div class="line"></div><div class="line"><span class="comment">// Construct a polygon from a circle.</span></div><div class="line">Polygon_2 construct_polygon (<span class="keyword">const</span> Circle_2&amp; circle)</div><div class="line">{</div><div class="line">  <span class="comment">// Subdivide the circle into two x-monotone arcs.</span></div><div class="line">  Traits_2 traits;</div><div class="line">  Curve_2 curve (circle);</div><div class="line">  std::list&lt;CGAL::Object&gt; objects;</div><div class="line">  traits.make_x_monotone_2_object() (curve, std::back_inserter(objects));</div><div class="line">  CGAL_assertion (objects.size() == 2);</div><div class="line"></div><div class="line">  <span class="comment">// Construct the polygon.</span></div><div class="line">  Polygon_2 pgn;</div><div class="line">  X_monotone_curve_2 arc;</div><div class="line">  std::list&lt;CGAL::Object&gt;::iterator iter;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (iter = objects.begin(); iter != objects.end(); ++iter) {</div><div class="line">    CGAL::assign (arc, *iter);</div><div class="line">    pgn.push_back (arc);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> pgn;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// The main program:</span></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="comment">// Read the number of circles from the command line.</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_circles = 8;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) n_circles = std::atoi(argv[1]);</div><div class="line"></div><div class="line">  <span class="comment">// Create the circles, equally spaced of the circle x^2 + y^2 = 1.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pi = std::atan(1.0) * 4;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> n_circles_reciep = 1.0 / n_circles;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> radius = 1;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> frac = 2 * pi * n_circles_reciep;</div><div class="line">  std::list&lt;Polygon_2&gt; circles;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;</div><div class="line">  <span class="keywordflow">for</span> (k = 0; k &lt; n_circles; k++) {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="codeRef" doxygen="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/doc_1_8_13/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__angle__grp.html#ga529057989da53e549b38c5a88e82967b">angle</a> = frac * k;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x = radius * std::sin(angle);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = radius * std::cos(angle);</div><div class="line">    Point_2 center = Point_2(x, y);</div><div class="line">    Circle_2 circle(center, radius);</div><div class="line"></div><div class="line">    circles.push_back (construct_polygon (circle));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Compute the union aggregately.</span></div><div class="line">  std::list&lt;Polygon_with_holes_2&gt; res;</div><div class="line">  <a class="code" href="group__boolean__join.html#gafca2f0759f989fe95d1c56b0428a0f16">CGAL::join</a> (circles.begin(), circles.end(), std::back_inserter (res));</div><div class="line"></div><div class="line">  <span class="comment">// Print the result.</span></div><div class="line">  std::copy (res.begin(), res.end(),</div><div class="line">             std::ostream_iterator&lt;Polygon_with_holes_2&gt;(std::cout, <span class="stringliteral">"\n"</span>));</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 1 2018 11:58:51 for CGAL 4.13 - 2D Regularized Boolean Set-Operations by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
