<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Regularized_Boolean_Set-Operations"/> <anchor id="index_1chapter_Boolean_set_operations_2"/>  <simplesect kind="authors"><para>Efi Fogel, Ophir Setter, Ron Wein, Guy Zucker, Baruch Zukerman, and Dan Halperin</para></simplesect>
</para><sect1 id="index_1bso_secintro">
<title>Introduction</title>
<para><anchor id="index_1fig__figteaser"/><image type="html" name="teaser.png"></image>
 <image type="latex" name="teaser.png" width="15cm"></image>
  <ref refid="index_1fig__figteaser" kindref="member">fig__figteaser</ref> Examples of Boolean set-operations on general polygons.  <linebreak/>
</para><para>This package consists of the implementation of Boolean set-operations on point sets bounded by weakly <formula id="0">$ x$</formula>-monotone curvesA continuous planar curve <formula id="1">$ C$</formula> is <emphasis>weakly <formula id="0">$ x$</formula>-monotone</emphasis> if every vertical line intersects it at most once, or if it is vertical. Hereafter we refer to weakly <formula id="0">$ x$</formula>-monotone curves as <formula id="0">$ x$</formula>-monotone curves. in 2-dimensional Euclidean space. In particular, it contains the implementation of <emphasis>regularized</emphasis> Boolean set-operations, intersection predicates, and point containment predicates. <ref refid="index_1fig__figteaser" kindref="member">fig__figteaser</ref> shows simple examples of such operations.</para><para>Ordinary Boolean set-operations, which distinguish between the interior and the boundary of a polygon, are not implemented within this package. The Chapter <ref refid="packages_1PkgNef2Summary" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">2D Boolean Operations on Nef Polygons</ref> supports these operations for (linear) polygons.</para><para>In the rest of this chapter we use, unless otherwise stated, the traditional notation to denote regularized operations; e.g., <formula id="2">$ P \cap Q$</formula> means the <emphasis>regularized</emphasis> intersection of <formula id="3">$ P$</formula> and <formula id="4">$ Q$</formula>.</para><para>Our package supports the following Boolean set-operations on two point sets <formula id="3">$ P$</formula> and <formula id="4">$ Q$</formula> that each is the union of one or more general polygons: <variablelist>
<varlistentry><term><bold>Intersection</bold></term></varlistentry>
<listitem><para>computes the intersection <formula id="5">$ R = P \cap Q$</formula>. </para></listitem>
<varlistentry><term><bold>Join</bold></term></varlistentry>
<listitem><para>computes the union <formula id="6">$ R = P \cup Q$</formula>. </para></listitem>
<varlistentry><term><bold>Difference</bold></term></varlistentry>
<listitem><para>computes the difference <formula id="7">$ R = P \setminus Q$</formula>. </para></listitem>
<varlistentry><term><bold>Symmetric Difference</bold></term></varlistentry>
<listitem><para>computes the symmetric difference <formula id="8">$ P = P \oplus Q = (P \setminus Q) \cup (Q \setminus P)$</formula>. </para></listitem>
<varlistentry><term><bold>Complement</bold></term></varlistentry>
<listitem><para>computes the complement <formula id="9">$R = \overline{P}$</formula>. </para></listitem>
<varlistentry><term><bold>Intersection predicate</bold></term></varlistentry>
<listitem><para>tests whether the two sets <formula id="3">$ P$</formula> and <formula id="4">$ Q$</formula> overlap, distinguishing three possible scenarios: (i) the two sets intersect on their interior (that is, their regularized intersection is not empty <formula id="10">$ P \cap Q \neq \emptyset$</formula>); (ii) the boundaries of two sets intersect but their interiors are disjoint; namely they have a finite number of common points or even share a boundary curve (still in this case <formula id="11">$ P \cap Q = \emptyset$</formula>; and (iii) the two sets are disjoint. </para></listitem>
</variablelist>
In general, the set <formula id="12">$ R$</formula>, resulting from a regularized Boolean set-operation, is considered as being a closed point-set; see definition of regularized boolean set operations below.</para><para>In the rest of this chapter we review the Boolean set-operations package in more depth. In Section <ref refid="index_1bso_secbso_lin" kindref="member">Boolean Set-Operations on Linear Polygons</ref> we focus on Boolean set-operations on linear polygons, introducing the notion of polygons with holes and of a general polygon set. Section <ref refid="index_1bso_secbso_gen" kindref="member">Boolean Set-Operations on General Polygons</ref> introduces general polygons. We first discuss polygons whose edges are either line segments or circular arcs and then explain how to construct and use general polygons whose edges can be arbitrary weakly <formula id="0">$ x$</formula>-monotone curves.</para></sect1>
<sect1 id="index_1bso_secbso_def">
<title>Terms and Definitions</title>
<para><anchor id="index_1fig__simpleDefsExamples"/><image type="html" name="simpleDefsExamples.png"></image>
 <image type="latex" name="simpleDefsExamples.png" width="15cm"></image>
  <ref refid="index_1fig__simpleDefsExamples" kindref="member">fig__simpleDefsExamples</ref> Examples of polygons. (a) A simple polygon. (b) A relatively simple polygon (c) A polygon that is neither simple nor relatively simple.  <linebreak/>
</para><para><itemizedlist>
<listitem>
<para>The counterclockwise cyclic sequence of alternating polygon edges and polygon vertices is referred to as the polygon <bold>(outer) boundary</bold>.</para><para></para></listitem>
<listitem>
<para>A polygon whose curves are pairwise disjoint in their interior, and whose vertices&apos; degree equals two is defined as a <bold>Simple polygon</bold>. Such a polygon has a well-defined interior and exterior and is topologically equivalent to a disk. Note that while traversing the edges of the relatively simple polygon illustrated above (B), no curve is crossed over.</para><para></para></listitem>
<listitem>
<para>A <bold>Relatively simple</bold> polygon allows vertices with a degree <formula id="13">$\gt 2$</formula>, but all of its edges are disjoint in their interior. Furthermore, it must be an orientable polygon. Namely when it is inserted into an arrangement and its outer boundary is traversed, the same face is adjacent to all of the halfedges (no crossing over any curve during the traversal). Note that while polygon C has the same curves as polygon B, traversal of the curves leads to crossing over a previously traversed curve, and is therefore neither simple nor relatively simple.</para><para></para></listitem>
<listitem>
<para>A polygon in our context must be relatively simple and its outer boundary vertices must be ordered in a counterclockwise direction around the interior of the polygon. We extend the notion of a polygon to a <bold>point set</bold> in <formula id="14">$ \mathbb{R}^2$</formula> that has a topology of a polygon and its boundary edges must map to <formula id="0">$ x$</formula>-monotone curves, and refer to it as a <bold>general polygon</bold>. We sometimes use the term <emphasis>polygon</emphasis> instead of general polygon for simplicity hereafter.</para><para></para></listitem>
<listitem>
<para>A <bold>polygon with holes</bold> represents a point set that may be bounded or unbounded. In case of a bounded set, its <emphasis>outer boundary</emphasis> is represented as a <emphasis>relatively simple </emphasis> (but not necessarily simple) polygon, whose vertices are oriented in a <emphasis>counterclockwise </emphasis> order around the interior of the set. In addition, the set may contain <emphasis>holes</emphasis>, where each hole is represented as a <emphasis>simple</emphasis> polygon, whose vertices are oriented in a <emphasis>clockwise</emphasis> order around the interior of the hole. Note that an unbounded polygon without holes spans the entire plane. Vertices of holes may coincide with vertices of the boundary.</para><para></para></listitem>
<listitem>
<para>A <bold>regularized Boolean set-operation</bold> <formula id="15">$ \mbox{op}^*$</formula> can be obtained by first taking the interior of the resultant point set of an <emphasis>ordinary</emphasis> Boolean set-operation <formula id="16">$ (P\ \mbox{op}\ Q)$</formula> and then by taking the closure <ref refid="citelist_1CITEREF_cgal:h-sm-04" kindref="member">[1]</ref>. That is, <formula id="17">$ P\ \mbox{op}^*\ Q = \mbox{closure}(\mbox{interior} (P\ \mbox{op}\ Q))$</formula>. Regularized Boolean set-operations appear in Constructive Solid Geometry (CSG), because regular sets are closed under regularized Boolean set-operations, and because regularization eliminates lower dimensional features, namely isolated vertices and antennas, thus simplifying and restricting the representation to physically meaningful solids. Our package provides regularized operations on polygons and general polygons, where the edges of a general polygon may be general <formula id="0">$ x$</formula>-monotone curves, rather than being simple line segments. </para></listitem>
</itemizedlist>
</para><sect2 id="index_1bso_ssecpolygon_validation">
<title>Conditions for Valid Polygons</title>
<para>In our context, a polygon must uphold the following conditions:</para><para><orderedlist>
<listitem>
<para><emphasis>Closed Boundary</emphasis> - the polygon&apos;s outer boundary must be a connected sequence of curves, that start and end at the same vertex. </para></listitem>
<listitem>
<para><emphasis>Simplicity</emphasis> - the polygon must be simple. </para></listitem>
<listitem>
<para><emphasis>Orientation</emphasis> - the polygon&apos;s outer boundary must be <emphasis>counter-clockwise oriented</emphasis>. </para></listitem>
</orderedlist>
</para></sect2>
<sect2 id="index_1bso_ssecpolygon_with_holes_validation">
<title>Conditions for Valid Polygons with Holes</title>
<para>In our context, a polygon with holes must uphold the following conditions:</para><para><orderedlist>
<listitem>
<para><emphasis>Closed Boundary</emphasis> - both the outer boundary and the holes must be closed polygons as defined above. </para></listitem>
<listitem>
<para><emphasis>Simplicity</emphasis> - the outer boundary must be a <emphasis></emphasis><bold><emphasis>relatively</emphasis></bold><emphasis> simple</emphasis> polygon (as defined above). Every hole must be a <emphasis>simple</emphasis> polygon. </para></listitem>
<listitem>
<para><emphasis>Orientation</emphasis> - The polygon with holes must have an outer boundary with <emphasis>counter clockwise orientation</emphasis>. Every hole&apos;s outer boundary should have <emphasis>clockwise orientation</emphasis>. </para></listitem>
<listitem>
<para><emphasis>The holes and the outer boundary must be pairwise disjoint,except maybe on vertices</emphasis>. <itemizedlist>
<listitem>
<para><emphasis>All holes are contained in the outer boundary</emphasis> - holes must be contained inside the outer boundary and must be disjoint from it (except on vertices). </para></listitem>
<listitem>
<para><emphasis>Pairwise disjoint holes (on interior)</emphasis> - the polygon&apos;s holes must be <emphasis>pairwise disjoint</emphasis>, except for intersection on a joint vertex/vertices.</para><para></para></listitem>
</itemizedlist>
</para></listitem>
</orderedlist>
</para></sect2>
</sect1>
<sect1 id="index_1bso_secbso_lin">
<title>Boolean Set-Operations on Linear Polygons</title>
<para>The basic library of CGAL includes the <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>,Container&gt;</computeroutput> class-template that represents a linear polygon in the plane. The polygon is represented by its vertices stored in a container of objects of type <computeroutput><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref></computeroutput>. The polygon edges are line segments (<computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> objects) between adjacent points in the container. By default, the <computeroutput>Container</computeroutput> is a vector of <computeroutput><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref></computeroutput> objects.</para><para>The following function demonstrates how to use the basic access functions of the <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref></computeroutput> class. It accepts a polygon <formula id="3">$ P$</formula> and prints it in a readable format: <programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Kernel,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Container&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_polygon<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel, Container&gt;</ref>&amp;<sp/>P)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel, Container&gt;::Vertex_const_iterator</ref><sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>P.<ref refid="classCGAL_1_1Polygon__2_1a52bab6b64430d70d6756f4dda5944bac" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">size</ref>()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices:&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(vit<sp/>=<sp/>P.<ref refid="classCGAL_1_1Polygon__2_1a20ae65167d8950c803667a47c30649f6" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">vertices_begin</ref>();<sp/>vit<sp/>!=<sp/>P.<ref refid="classCGAL_1_1Polygon__2_1a46168a01e53aa7d1ced7b9d73821227a" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">vertices_end</ref>();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*vit<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;)&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>In this section we use the term <emphasis>polygon</emphasis> to indicate a <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref></computeroutput> instance, namely, a polygon having linear edges. General polygons are only discussed in Section <ref refid="index_1bso_secbso_gen" kindref="member">Boolean Set-Operations on General Polygons</ref>.</para><para>The basic components of our package are the free (global) functions <computeroutput><ref refid="group__boolean__complement_1ga45629253bda87736f21251bfee532665" kindref="member">complement()</ref></computeroutput> that accepts a single <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref></computeroutput> object, and <computeroutput><ref refid="group__intersection__linear__grp_1gab77f3cd98c4c4ff7acff59c98ab88ff0" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">intersection()</ref></computeroutput>, <computeroutput><ref refid="group__boolean__join_1gafca2f0759f989fe95d1c56b0428a0f16" kindref="member">join()</ref></computeroutput>,The function that computes the union of two polygons is called <computeroutput><ref refid="group__boolean__join_1gafca2f0759f989fe95d1c56b0428a0f16" kindref="member">join()</ref></computeroutput>, since the word <computeroutput>union</computeroutput> is reserved in C++. <computeroutput><ref refid="group__boolean__difference_1ga525c4a75749027346fcf444a8fbb31b7" kindref="member">difference()</ref></computeroutput>, <computeroutput><ref refid="group__boolean__symmetric__difference_1ga16f709a3037b2d4ae61141eda60f72e7" kindref="member">symmetric_difference()</ref></computeroutput> and the predicate <computeroutput><ref refid="group__do__intersect__linear__grp_1ga9514a218a097ac392d21775368d3dd0d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">do_intersect()</ref></computeroutput> that accept two <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref></computeroutput> objects as their input. We explain how these functions should be used through several examples in the following sections.</para><sect2 id="index_1Boolean_set_operations_2ASimpleExample">
<title>A Simple Example</title>
<para><image type="html" name="triangles.png"></image>
 <image type="latex" name="triangles.png"></image>
</para><para>Testing whether two polygons intersect results with a Boolean value, and does not require any additional data beyond the provision of the two input polygons. The example listed below tests whether the two triangles depicted on the right intersect. It uses, as do the other example programs in this chapter, the auxiliary header file <computeroutput>bso_rational_nt.h</computeroutput>, which defines the type <computeroutput>Number_type</computeroutput> as Gmp&apos;s rational number-type (<computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput>), or as the number type <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;<ref refid="classCGAL_1_1MP__Float" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">MP_Float</ref>&gt;</computeroutput> that is included in the support library of CGAL, based on whether the Gmp library is installed or not. It also uses the function <computeroutput>print_polygon.h</computeroutput> listed above, which is located in the header file <computeroutput>print_utils.h</computeroutput>.</para><para><linebreak/>
<bold>File</bold> <ref refid="Boolean_set_operations_2_2do_intersect_8cpp-example" kindref="compound">Boolean_set_operations_2/do_intersect.cpp</ref> <programlisting><codeline></codeline>
<codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Boolean_set_operations_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;print_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.<ref refid="classCGAL_1_1Polygon__2_1a66ff561172016056897409f26f23add1" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">push_back</ref><sp/>(Point_2<sp/>(-1,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back<sp/>(Point_2<sp/>(0,-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back<sp/>(Point_2<sp/>(1,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;P<sp/>=<sp/>&quot;</highlight><highlight class="normal">;<sp/>print_polygon<sp/>(P);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>Q;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back(Point_2<sp/>(-1,-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back(Point_2<sp/>(1,-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back(Point_2<sp/>(0,1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Q<sp/>=<sp/>&quot;</highlight><highlight class="normal">;<sp/>print_polygon<sp/>(Q);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((<ref refid="group__do__intersect__linear__grp_1ga9514a218a097ac392d21775368d3dd0d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::do_intersect</ref><sp/>(P,<sp/>Q)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>two<sp/>polygons<sp/>intersect<sp/>in<sp/>their<sp/>interior.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>two<sp/>polygons<sp/>do<sp/>not<sp/>intersect.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1bso_ssecpolygons_with_holes">
<title>Polygons with Holes</title>
<para><anchor id="index_1fig__figsimple"/><image type="html" name="simple.png"></image>
 <image type="latex" name="simple.png" width="15cm"></image>
  <ref refid="index_1fig__figsimple" kindref="member">fig__figsimple</ref> Operations on simple polygons. (a) The union of two polygons, resulting in a point set whose outer boundary is defined by a simple polygon and contains a polygonal hole in its interior. (b) The intersection (darkly shaded) of two polygons (lightly shaded), resulting in two disjoint polygons. (c) The complement (darkly shaded) of a simple polygon (lightly shaded).  <linebreak/>
</para><para>In many cases a binary operation that operates on two simple polygons that have no holes may result in a set of polygons that contain holes in their interior (see <ref refid="index_1fig__figsimple" kindref="member">fig__figsimple</ref> (a)), or a set of disjoint polygons (see <ref refid="index_1fig__figsimple" kindref="member">fig__figsimple</ref> (b); a similar set may result from the union, or the symmetric difference, of two disjoint polygons). Moreover, the complement of a simple polygon is an unbounded set that contains a hole; see <ref refid="index_1fig__figsimple" kindref="member">fig__figsimple</ref> (c).</para><para>Regular sets are closed under regularized Boolean set-operations. These operations accept as input, and may result as output, polygons with holes. A <emphasis>polygon with holes</emphasis> represents a point set that may be bounded or unbounded. In case of a bounded set, its <emphasis>outer boundary</emphasis> is represented as a relatively simple (but not necessarily simple) polygon, whose vertices are oriented in a counterclockwise order around the interior of the set. In addition, the set may contain <emphasis>holes</emphasis>, where each hole is represented as a simple polygon, whose vertices are oriented in a clockwise order around the interior of the hole. Note that an unbounded polygon without holes spans the entire plane. Vertices of holes may coincide with vertices of the boundary; see below for an example.</para><para>A point set represented by a polygon with holes is considered to be closed. Therefore, the boundaries of the holes are parts of the set (and not part of the holes). The exact definition of the obtained polygon with holes as a result of a Boolean set-operation or a sequence of such operations is closely related to the definition of regularized Boolean set-operations, being the closure of the interior of the corresponding ordinary operation as explained next.</para><para><image type="html" name="unique.png"></image>
 <image type="latex" name="unique.png"></image>
</para><para>Consider, for example, the regular set depicted on the right, which is the result of the union of three small triangles translated appropriately. Alternatively, the same set can be reached by taking the difference between a large triangle and a small upside-down triangle. In general, there are many ways to arrive at a particular point set. However, the set of polygons with holes obtained through the application of any sequence of operations is unique. The set depicted on the right is represented as a single polygon having a triangular outer boundary with a single triangular hole in its interior - and not as three triangles that have no holes at all. As a general rule, if two point sets are connected, then they belong to the same polygon with holes.</para><para>The class template <computeroutput><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_with_holes_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>,Container&gt;</computeroutput> represents polygons with holes as described above, where the outer boundary and the hole boundaries are realized as <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>,Container&gt;</computeroutput> objects. Given an instance <formula id="3">$ P$</formula> of the <computeroutput><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_with_holes_2</ref></computeroutput> class, you can use the predicate <computeroutput>is_unbounded()</computeroutput> to check whether <formula id="3">$ P$</formula> is a unbounded set. If it is bounded, you can obtain the counterclockwise-oriented polygon that represents its outer boundary through the member function <computeroutput>outer_boundary()</computeroutput>. You can also traverse the holes of <formula id="3">$ P$</formula> through <computeroutput>holes_begin()</computeroutput> and <computeroutput>holes_end()</computeroutput>. The two functions return iterators of the nested type <computeroutput>Polygon_with_holes_2::Hole_const_iterator</computeroutput> that defines the valid range of <formula id="3">$ P$</formula>&apos;s holes. The value type of this iterator is <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref></computeroutput>.</para><para>The following function demonstrates how to traverse a polygon with holes. It accepts a <computeroutput><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_with_holes_2</ref></computeroutput> object and uses the auxiliary function <computeroutput>print_polygon()</computeroutput> to prints all its components in a readable format: <programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Kernel,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Container&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_polygon_with_holes(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_with_holes_2&lt;Kernel, Container&gt;</ref><sp/>&amp;<sp/>pwh)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>pwh.is_unbounded())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;{<sp/>Outer<sp/>boundary<sp/>=<sp/>&quot;</highlight><highlight class="normal">;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_polygon<sp/>(pwh.outer_boundary());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;{<sp/>Unbounded<sp/>polygon.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_with_holes_2&lt;Kernel,Container&gt;::Hole_const_iterator</ref><sp/>hit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>pwh.number_of_holes()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>holes:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(hit<sp/>=<sp/>pwh.holes_begin();<sp/>hit<sp/>!=<sp/>pwh.holes_end();<sp/>++hit,<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>Hole<sp/>#&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>=<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_polygon<sp/>(*hit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>}&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The simple versions of the free functions mentioned therefore accept two <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref></computeroutput> object <formula id="3">$ P$</formula> and <formula id="4">$ Q$</formula> as their input, while their output is given using polygon with holes instances: <itemizedlist>
<listitem>
<para>The complement of a simple polygon <formula id="3">$ P$</formula> is always an unbounded set with a single polygonal hole. The function <computeroutput>complement(P)</computeroutput> therefore returns a polygon-with-holes object that represents the complement of <formula id="3">$ P$</formula>. </para></listitem>
<listitem>
<para>The union of two polygons <formula id="3">$ P$</formula> and <formula id="4">$ Q$</formula> is always a single connected set, unless of course the two input polygons are completely disjoint. In the latter case <formula id="18">$ P \cup Q$</formula> trivially consists of the two input polygons. The free function <computeroutput>join(P, Q, R)</computeroutput> therefore returns a Boolean value indicating whether <formula id="10">$ P \cap Q \neq \emptyset$</formula>. If the two polygons are not disjoint, it assigns the polygon with holes object <formula id="12">$ R$</formula> (which it accepts by reference) with the union of the regularized union operation <formula id="18">$ P \cup Q$</formula>. </para></listitem>
<listitem>
<para>The other three functions, namely <computeroutput>intersection(P, Q, oi)</computeroutput>, <computeroutput>difference(P, Q, oi)</computeroutput> and <computeroutput>symmetric_difference(P, Q, oi)</computeroutput>, all have a similar interface. As the result of these operation may consist of several disconnected components, they all accept an output iterator <computeroutput>oi</computeroutput>, whose value type is <computeroutput><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_with_holes_2</ref></computeroutput>, and adds the output polygons to its associated container. </para></listitem>
</itemizedlist>
</para></sect2>
<sect2 id="index_1bso_sssecex_simple_bops">
<title>Example - Joining and Intersecting Simple Polygons</title>
<para>The following example demonstrates the usage of the free functions <computeroutput><ref refid="group__boolean__join_1gafca2f0759f989fe95d1c56b0428a0f16" kindref="member">join()</ref></computeroutput> and <computeroutput><ref refid="group__intersection__linear__grp_1gab77f3cd98c4c4ff7acff59c98ab88ff0" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">intersection()</ref></computeroutput> for computing the union and the intersection of the two simple polygons depicted in <ref refid="index_1fig__figsimple" kindref="member">fig__figsimple</ref> (b). The example uses the auxiliary function <computeroutput>print_polygon_with_holes()</computeroutput> listed above, which is located in the header file <computeroutput>print_utils.h</computeroutput> under the examples folder.</para><para><linebreak/>
<bold>File</bold> <ref refid="Boolean_set_operations_2_2simple_join_intersect_8cpp-example" kindref="compound">Boolean_set_operations_2/simple_join_intersect.cpp</ref> <programlisting><codeline></codeline>
<codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Boolean_set_operations_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_with_holes_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_with_holes_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::list&lt;Polygon_with_holes_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Pwh_list_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;print_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>two<sp/>input<sp/>polygons.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back<sp/>(Point_2<sp/>(0,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back<sp/>(Point_2<sp/>(5,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back<sp/>(Point_2<sp/>(3.5,<sp/>1.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back<sp/>(Point_2<sp/>(2.5,<sp/>0.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back<sp/>(Point_2<sp/>(1.5,<sp/>1.5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;P<sp/>=<sp/>&quot;</highlight><highlight class="normal">;<sp/>print_polygon<sp/>(P);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>Q;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back<sp/>(Point_2<sp/>(0,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back<sp/>(Point_2<sp/>(1.5,<sp/>0.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back<sp/>(Point_2<sp/>(2.5,<sp/>1.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back<sp/>(Point_2<sp/>(3.5,<sp/>0.5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back<sp/>(Point_2<sp/>(5,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Q<sp/>=<sp/>&quot;</highlight><highlight class="normal">;<sp/>print_polygon<sp/>(Q);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>union<sp/>of<sp/>P<sp/>and<sp/>Q.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_with_holes_2<sp/>unionR;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__boolean__join_1gafca2f0759f989fe95d1c56b0428a0f16" kindref="member">CGAL::join</ref><sp/>(P,<sp/>Q,<sp/>unionR))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>union:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_polygon_with_holes<sp/>(unionR);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;P<sp/>and<sp/>Q<sp/>are<sp/>disjoint<sp/>and<sp/>their<sp/>union<sp/>is<sp/>trivial.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>intersection<sp/>of<sp/>P<sp/>and<sp/>Q.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Pwh_list_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intR;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Pwh_list_2::const_iterator<sp/><sp/>it;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__intersection__linear__grp_1gab77f3cd98c4c4ff7acff59c98ab88ff0" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::intersection</ref><sp/>(P,<sp/>Q,<sp/>std::back_inserter(intR));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>intersection:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(it<sp/>=<sp/>intR.begin();<sp/>it<sp/>!=<sp/>intR.end();<sp/>++it)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;--&gt;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_polygon_with_holes<sp/>(*it);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1bso_sssecpwh_bops">
<title>Operations on Polygons with Holes</title>
<para>We have demonstrated that free functions that perform boolean set operations on simple polygons may output polygons with holes. In addition to these functions, the Boolean set-operations package provides the following overridden free functions that accept <computeroutput><ref refid="classCGAL_1_1General__polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">General_polygon_with_holes_2</ref></computeroutput> objects as their input - <computeroutput><ref refid="group__boolean__complement_1ga45629253bda87736f21251bfee532665" kindref="member">complement()</ref></computeroutput>, <computeroutput><ref refid="group__intersection__linear__grp_1gab77f3cd98c4c4ff7acff59c98ab88ff0" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">intersection()</ref></computeroutput>, <computeroutput><ref refid="group__boolean__join_1gafca2f0759f989fe95d1c56b0428a0f16" kindref="member">join()</ref></computeroutput>, <computeroutput><ref refid="group__boolean__difference_1ga525c4a75749027346fcf444a8fbb31b7" kindref="member">difference()</ref></computeroutput>, <computeroutput><ref refid="group__boolean__symmetric__difference_1ga16f709a3037b2d4ae61141eda60f72e7" kindref="member">symmetric_difference()</ref></computeroutput> and <computeroutput><ref refid="group__do__intersect__linear__grp_1ga9514a218a097ac392d21775368d3dd0d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">do_intersect()</ref></computeroutput> The prototypes of most functions is the same as of their simpler counterparts that operate on simple polygons. The only exception is <computeroutput>complement(P, oi)</computeroutput>, which outputs a range of polygons with holes that represents the complement of the polygon with holes <formula id="3">$ P$</formula>.</para><para><image type="html" name="symm_diff.png"></image>
 <image type="latex" name="symm_diff.png"></image>
</para><para>The following example demonstrates how to compute the symmetric difference between two sets that contain holes. Each set is a rectangle that contains a rectangular hole in its interior, such that the symmetric difference between the two sets is a single polygon that contains of five holes:</para><para><linebreak/>
<bold>File</bold> <ref refid="Boolean_set_operations_2_2symmetric_difference_8cpp-example" kindref="compound">Boolean_set_operations_2/symmetric_difference.cpp</ref> <programlisting><codeline></codeline>
<codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Boolean_set_operations_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_with_holes_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_with_holes_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::list&lt;Polygon_with_holes_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Pwh_list_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;print_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>P<sp/>-<sp/>a<sp/>bounded<sp/>rectangle<sp/>that<sp/>contains<sp/>a<sp/>rectangular<sp/>hole.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>outP;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>holesP[1];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outP.push_back<sp/>(Point_2<sp/>(-3,<sp/>-5));<sp/><sp/>outP.push_back<sp/>(Point_2<sp/>(3,<sp/>-5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outP.push_back<sp/>(Point_2<sp/>(3,<sp/>5));<sp/><sp/><sp/><sp/>outP.push_back<sp/>(Point_2<sp/>(-3,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>holesP[0].push_back<sp/>(Point_2<sp/>(-1,<sp/>-3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>holesP[0].push_back<sp/>(Point_2<sp/>(-1,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>holesP[0].push_back<sp/>(Point_2<sp/>(1,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>holesP[0].push_back<sp/>(Point_2<sp/>(1,<sp/>-3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_with_holes_2<sp/><sp/>P<sp/>(outP,<sp/>holesP,<sp/>holesP<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;P<sp/>=<sp/>&quot;</highlight><highlight class="normal">;<sp/>print_polygon_with_holes<sp/>(P);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>Q<sp/>-<sp/>a<sp/>bounded<sp/>rectangle<sp/>that<sp/>contains<sp/>a<sp/>rectangular<sp/>hole.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>outQ;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>holesQ[1];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outQ.push_back<sp/>(Point_2<sp/>(-5,<sp/>-3));<sp/><sp/>outQ.push_back<sp/>(Point_2<sp/>(5,<sp/>-3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>outQ.push_back<sp/>(Point_2<sp/>(5,<sp/>3));<sp/><sp/><sp/><sp/>outQ.push_back<sp/>(Point_2<sp/>(-5,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>holesQ[0].push_back<sp/>(Point_2<sp/>(-3,<sp/>-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>holesQ[0].push_back<sp/>(Point_2<sp/>(-3,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>holesQ[0].push_back<sp/>(Point_2<sp/>(3,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>holesQ[0].push_back<sp/>(Point_2<sp/>(3,<sp/>-1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_with_holes_2<sp/><sp/>Q<sp/>(outQ,<sp/>holesQ,<sp/>holesQ<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Q<sp/>=<sp/>&quot;</highlight><highlight class="normal">;<sp/>print_polygon_with_holes<sp/>(Q);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>symmetric<sp/>difference<sp/>of<sp/>P<sp/>and<sp/>Q.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Pwh_list_2<sp/>symmR;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Pwh_list_2::const_iterator<sp/>it;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__boolean__symmetric__difference_1ga16f709a3037b2d4ae61141eda60f72e7" kindref="member">CGAL::symmetric_difference</ref><sp/>(P,<sp/>Q,<sp/>std::back_inserter(symmR));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>symmetric<sp/>difference:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(it<sp/>=<sp/>symmR.begin();<sp/>it<sp/>!=<sp/>symmR.end();<sp/>++it)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;--&gt;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_polygon_with_holes<sp/>(*it);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>In some cases it is convenient to connect the outer boundary of a polygon with holes with the holes inside it. The function <computeroutput><ref refid="group__boolean__connect__holes_1ga0c649fa14a7f93957b231d9a6bee29ae" kindref="member">connect_holes()</ref></computeroutput> accepts a polygon with holes, and connects the topmost vertex in each hole with the polygon feature located directly above it (a vertex or an edge of the outer boundary, or of another hole). It produces an output sequence of points that match the traversal of all vertices in the connected polygon (note that there are additional vertices, induced by the vertical walls).</para><para><linebreak/>
<bold>File</bold> <ref refid="Boolean_set_operations_2_2connect_polygon_8cpp-example" kindref="compound">Boolean_set_operations_2/connect_polygon.cpp</ref> <programlisting><codeline></codeline>
<codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/connect_holes.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_with_holes_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_with_holes_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>pgn_holes.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//more<sp/>data<sp/>files<sp/>can<sp/>be<sp/>found<sp/>under<sp/>test<sp/>data</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//boundary<sp/>no<sp/>other<sp/>connections<sp/>are<sp/>made.<sp/><sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;pgn_holes.dat&quot;</highlight><highlight class="normal">;<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>input_file<sp/>(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>input_file.is_open())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>the<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>a<sp/>polygon<sp/>with<sp/>holes<sp/>from<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outerP;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_holes;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input_file<sp/>&gt;&gt;<sp/>outerP;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input_file<sp/>&gt;&gt;<sp/>num_holes;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Polygon_2&gt;<sp/><sp/>holes<sp/>(num_holes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>k;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>num_holes;<sp/>k++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>input_file<sp/>&gt;&gt;<sp/>holes[k];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_with_holes_2<sp/><sp/><sp/><sp/>P<sp/>(outerP,<sp/>holes.begin(),<sp/>holes.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Connect<sp/>the<sp/>outer<sp/>boundary<sp/>of<sp/>the<sp/>polygon<sp/>with<sp/>its<sp/>holes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point_2&gt;::iterator<sp/><sp/>pit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__boolean__connect__holes_1ga0c649fa14a7f93957b231d9a6bee29ae" kindref="member">connect_holes</ref><sp/>(P,<sp/>std::back_inserter<sp/>(pts));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(pit<sp/>=<sp/>pts.begin();<sp/>pit<sp/>!=<sp/>pts.end();<sp/>++pit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;(&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*pit<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/><sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1bso_ssecmain_component">
<title>Operating on Polygon Sets</title>
<para>We argue that the result of a regularized operations on two polygons (or polygons with holes) <formula id="3">$ P$</formula> and <formula id="4">$ Q$</formula> is typically a collection of several disconnected polygons with holes. It is only natural to represent such a collection in terms of a class, making it possible to operate on the set resulting from computing, for example, <formula id="19">$ P \setminus Q$</formula>.</para><para>A central component in the Boolean set-operations package is the <computeroutput><ref refid="classCGAL_1_1Polygon__set__2" kindref="compound">Polygon_set_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>, Container, Dcel&gt;</computeroutput> class-template. An instance of this class represents a point set formed by the collection of several disconnected polygons with holes. It employs the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2</ref></computeroutput> class to represent this point set in the plane as a planar arrangement; see Chapter <ref refid="index_1chapterArrangement_on_surface_2" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">2D Arrangements</ref>. The instantiated <computeroutput>Dcel</computeroutput> type is used to represent the underlying internal arrangement. It must model the concept <computeroutput><ref refid="classGeneralPolygonSetDcel" kindref="compound">GeneralPolygonSetDcel</ref></computeroutput>, and defaults to <computeroutput><ref refid="classCGAL_1_1Gps__default__dcel" kindref="compound">Gps_default_dcel</ref></computeroutput>. You can override this default, with a different Dcel class, typically an extension of the default. Overriding the default is necessary only if you intend to obtain the underlying internal arrangement and process it further.</para><para>An instance <formula id="20">$ S$</formula> of a <computeroutput><ref refid="classCGAL_1_1Polygon__set__2" kindref="compound">Polygon_set_2</ref></computeroutput> class usually represents the result of a sequence of operations that were applied on some input polygons. The representation of <formula id="20">$ S$</formula> is unique, regardless of the particular sequence of operations that were applied in order to arrive at it.</para><para>In addition, a polygon-set object can be constructed from a single polygon object or from a polygon-with-holes object. Once constructed, it is possible to insert new polygons (or polygons with holes) into the set using the <computeroutput><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert()</ref></computeroutput> method, as long as the inserted polygons and the existing polygons in the set are disjoint. The <computeroutput><ref refid="classCGAL_1_1Polygon__set__2" kindref="compound">Polygon_set_2</ref></computeroutput> class also provides access functions for accessing the polygons with holes it contains, and a few queries. The most important query is <computeroutput>S.oriented_side(q)</computeroutput>, which determined whether the query point <formula id="21">$ q$</formula> is contained in the interior of the set <formula id="20">$ S$</formula>, lies on the boundary of the set, or neither.</para><para>The <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref></computeroutput> class defines the predicate <computeroutput><ref refid="group__do__intersect__linear__grp_1ga9514a218a097ac392d21775368d3dd0d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">do_intersect()</ref></computeroutput> and the methods <computeroutput><ref refid="group__boolean__complement_1ga45629253bda87736f21251bfee532665" kindref="member">complement()</ref></computeroutput>, <computeroutput><ref refid="group__intersection__linear__grp_1gab77f3cd98c4c4ff7acff59c98ab88ff0" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">intersection()</ref></computeroutput>, <computeroutput><ref refid="group__boolean__join_1gafca2f0759f989fe95d1c56b0428a0f16" kindref="member">join()</ref></computeroutput>, <computeroutput><ref refid="group__boolean__difference_1ga525c4a75749027346fcf444a8fbb31b7" kindref="member">difference()</ref></computeroutput> and <computeroutput><ref refid="group__boolean__symmetric__difference_1ga16f709a3037b2d4ae61141eda60f72e7" kindref="member">symmetric_difference()</ref></computeroutput> as member functions. The operands to these functions may be simple polygons (<computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref></computeroutput> object), polygons with holes (<computeroutput><ref refid="classCGAL_1_1General__polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">General_polygon_with_holes_2</ref></computeroutput> objects), or polygon sets (<computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref></computeroutput> objects). Thus, each of the function mentioned above is actually realized by a set overriding member functions.</para><para>Member functions of the <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref></computeroutput> that perform Boolean set-operations come in two flavors: for example, <computeroutput>S.join(P, Q)</computeroutput> computes the union of <formula id="3">$ P$</formula> and <formula id="4">$ Q$</formula> and assigned the result to <formula id="20">$ S$</formula>, while <computeroutput>S.join(P)</computeroutput> performs the operation <formula id="22">$ S \longleftarrow S \cup P$</formula>. Similarly, <computeroutput>S.complement(P)</computeroutput> sets <formula id="20">$ S$</formula> to be the complement of <formula id="3">$ P$</formula>, while <computeroutput><ref refid="group__boolean__complement_1ga45629253bda87736f21251bfee532665" kindref="member">S.complement()</ref></computeroutput> simply negates the set <formula id="20">$ S$</formula>.</para></sect2>
<sect2 id="index_1bso_sssecsequence">
<title>A Sequence of Set Operations</title>
<para>The free functions reviewed in Section <ref refid="index_1bso_ssecpolygons_with_holes" kindref="member">Polygons with Holes</ref> serve as a wrapper for the polygon-set class, and are only provided for convenience. A typical such function constructs a pair of <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref></computeroutput> objects, invokes the appropriate method to apply the desired Boolean operation, and transforms the resulting polygon set to the required output format. Thus, when several operations are performed in a sequence, it is much more efficient to use the member functions of the <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref></computeroutput> type directly, as the extraction of the polygons from the internal representation for some operation, and the reconstruction of the internal representation for the succeeding operation could be time consuming.</para><para><image type="html" name="sequence.png"></image>
 <image type="latex" name="sequence.png"></image>
</para><para>The next example performs a sequence of three Boolean set-operations. First, it computes the union of two simple polygons depicted in <ref refid="index_1fig__figsimple" kindref="member">fig__figsimple</ref> (a). It then computes the complement of the result of the union operation. Finally, it computes the intersection of the result of the complement operation with a rectangle, confining the final result to the area of the rectangle. The resulting set <formula id="20">$ S$</formula> is comprised of two components: a polygon with a hole, and a simple polygon contained in the interior of this hole.</para><para><linebreak/>
<bold>File</bold> <ref refid="Boolean_set_operations_2_2sequence_8cpp-example" kindref="compound">Boolean_set_operations_2/sequence.cpp</ref> <programlisting><codeline></codeline>
<codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygon_with_holes_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygon_set_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">CGAL::Polygon_with_holes_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_with_holes_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__set__2" kindref="compound">CGAL::Polygon_set_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_set_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;print_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>two<sp/>initial<sp/>polygons<sp/>and<sp/>the<sp/>clipping<sp/>rectangle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>P;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back<sp/>(Point_2<sp/>(0,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back<sp/>(Point_2<sp/>(2,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back<sp/>(Point_2<sp/>(1,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P.push_back<sp/>(Point_2<sp/>(2,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>Q;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back<sp/>(Point_2<sp/>(3,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back<sp/>(Point_2<sp/>(1,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back<sp/>(Point_2<sp/>(2,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Q.push_back<sp/>(Point_2<sp/>(1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>rect;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rect.push_back<sp/>(Point_2<sp/>(0,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rect.push_back<sp/>(Point_2<sp/>(3,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rect.push_back<sp/>(Point_2<sp/>(3,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rect.push_back<sp/>(Point_2<sp/>(0,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>a<sp/>sequence<sp/>of<sp/>operations.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_set_2<sp/>S;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S.<ref refid="classCGAL_1_1General__polygon__set__2_1a9d41f55871a2b65d1b421f19f155e6d4" kindref="member">insert</ref><sp/>(P);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S.join<sp/>(Q);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>union<sp/>of<sp/>P<sp/>and<sp/>Q.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S.complement();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>complement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S.intersection<sp/>(rect);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Intersect<sp/>with<sp/>the<sp/>clipping<sp/>rectangle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>result.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Polygon_with_holes_2&gt;<sp/>res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Polygon_with_holes_2&gt;::const_iterator<sp/>it;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>result<sp/>contains<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>S.number_of_polygons_with_holes()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>components:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S.polygons_with_holes<sp/>(std::back_inserter<sp/>(res));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(it<sp/>=<sp/>res.begin();<sp/>it<sp/>!=<sp/>res.end();<sp/>++it)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;--&gt;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_polygon_with_holes<sp/>(*it);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1bso_ssecinsert_ni">
<title>Inserting Non Intersecting Polygons</title>
<para>If you want to compute the union of a polygon <formula id="3">$ P$</formula> ( <formula id="3">$ P$</formula> may be a simple polygon or a polygon-with-holes object) with a general-polygon set <formula id="12">$ R$</formula>, and store the result in <formula id="12">$ R$</formula>, you can construct a polygon set <formula id="23">$ S(P)$</formula>, and apply the <emphasis>union</emphasis> operation as follows: <programlisting><codeline><highlight class="normal">General_polygon_2<sp/>S<sp/>(P);</highlight></codeline>
<codeline><highlight class="normal">R.join<sp/>(S);</highlight></codeline>
</programlisting></para><para>As a matter of fact, you can apply the union operation directly: <programlisting><codeline><highlight class="normal">R.join<sp/>(P);</highlight></codeline>
</programlisting></para><para>However, if you know that the polygon does not intersect any one of the polygons represented by <formula id="12">$ R$</formula>, you can use the more efficient method <computeroutput><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert()</ref></computeroutput>: <programlisting><codeline><highlight class="normal">R.insert<sp/>(P);</highlight></codeline>
</programlisting></para><para>As <computeroutput><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert()</ref></computeroutput> assumes that <formula id="24">$ P \cap R = \emptyset$</formula>, it does not try to compute intersections between the boundaries of <formula id="3">$ P$</formula> and of <formula id="12">$ R$</formula>. This fact significantly speeds up the insertion process in comparison with the insertion of a non-disjoint polygon that intersects <formula id="12">$ R$</formula>.</para><para>The <computeroutput><ref refid="group__PkgArrangement2Insert_1gaa6e1d86b9725db5998dfb358ab1985f9" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">insert()</ref></computeroutput> function is also overloaded, so it can also accept a range of polygons. When a range of polygons are inserted into a polygon set <formula id="20">$ S$</formula>, all the polygons in the range and the polygons represented by <formula id="20">$ S$</formula> must be pairwise disjoint in their interiors.</para></sect2>
<sect2 id="index_1bso_ssecagg_ops">
<title>Performing Aggregated Operations</title>
<para>There are a few options to compute the union of a set of polygons <formula id="25">$ P_1, \ldots P_m$</formula>. You can do it incrementally as follows. At each step compute the union of <formula id="26">$ S_{k-1} = \bigcup_{i=1}^{k-1}{P_i}$</formula> with <formula id="27">$ P_{k}$</formula> and obtain <formula id="28">$ S_k$</formula>. Namely, if the polygon set is given as a pair of iterator <computeroutput>[begin, end)</computeroutput>, the following loop computes their union in <formula id="20">$ S$</formula>. <programlisting><codeline><highlight class="normal"><ref refid="classInputIterator" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Manual.tag">InputIterator</ref><sp/>iter<sp/>=<sp/>begin;</highlight></codeline>
<codeline><highlight class="normal">Polygon_set_2<sp/>S<sp/>(*iter);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(++iter<sp/>!=<sp/>end)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S.join<sp/>(*iter);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>++iter;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> A second option is to use a divide-and-conquer approach. You bisect the set of polygons into two sets. Compute the union of each set recursively and obtain the partial results in <formula id="29">$ S_1$</formula> and <formula id="30">$ S_2$</formula>, and finally, you compute the union <formula id="31">$ S_1 \cup S_2$</formula>. However, the union operation can be done more efficiently for sparse polygons, having a relatively small number of intersections, using a third option that simultaneously computes the union of all polygons. This is done by constructing a planar arrangement of all input polygons, utilizing the sweep-line algorithm, then extracting the result from the arrangement. Similarly, it is also possible to aggregately compute the intersection <formula id="32">$ \bigcap_{i=1}^{m}{P_i}$</formula> of a set of input polygons.</para><para>Our package provides the free overloaded functions <computeroutput><ref refid="group__boolean__join_1gafca2f0759f989fe95d1c56b0428a0f16" kindref="member">join()</ref></computeroutput> and <computeroutput><ref refid="group__intersection__linear__grp_1gab77f3cd98c4c4ff7acff59c98ab88ff0" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">intersection()</ref></computeroutput> that aggregately compute the union and the intersection of a range of input polygons. There is no restriction on the polygons in the range - naturally, they may intersect each other. The package provides the overloaded free function <ref refid="group__do__intersect__linear__grp_1ga9514a218a097ac392d21775368d3dd0d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">do_intersect(begin, end)</ref> that determines whether the polygons in the range defined by the two input iterators <computeroutput>[begin, end)</computeroutput> intersect.</para><para>The class <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref></computeroutput> also provides equivalent member functions that aggregately operate on a range of input polygons or polygons with holes. When such a member function is called, the general polygons represented by the current object are considered operands as well. Thus, you can easily compute the union of our polygon range as follows: <programlisting><codeline><highlight class="normal">Polygon_set_2<sp/>S;</highlight></codeline>
<codeline><highlight class="normal">S.join<sp/>(begin,<sp/>end);</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1bso_secbso_gen">
<title>Boolean Set-Operations on General Polygons</title>
<para><image type="html" name="general_polygon.png"></image>
 <image type="latex" name="general_polygon.png"></image>
</para><para>In previous sections only ordinary (linear) polygons were dealt with. Namely, closed point sets bounded by piecewise linear curves. The Boolean set-operations package allows a more general geometric mapping of the polygon edges. The operations provided by the package operate on point sets bounded by <formula id="0">$ x$</formula>-monotone segments of general curves (e.g., conic arcs and segments of polynomial functions). For example, the point set depicted on the right is a general polygon bounded by two <formula id="0">$ x$</formula>-monotone circular arcs that correspond to the lower half and the upper half of a circle, respectively.</para><para>Using the topological terminology, a general polygon can represent any simply-connected point set whose boundary is a strictly simple curve. Such a polygon is a model of the <computeroutput><ref refid="classGeneralPolygon__2" kindref="compound">GeneralPolygon_2</ref></computeroutput> concept. A model of this concept must fulfill the following requirements: <itemizedlist>
<listitem>
<para>A general polygon is constructible from a range of pairwise interior disjoint <formula id="0">$ x$</formula>-monotone curves <formula id="33">$ c_1, \ldots, c_n$</formula>. The target point of the <formula id="34">$ k$</formula>th curve <formula id="35">$ c_k$</formula> and the source point of the next curve in the range (in a cyclic order) must coincide, such that this point defines the <formula id="34">$ k$</formula>th polygon vertex. </para></listitem>
<listitem>
<para>It is possible to traverse the <formula id="0">$ x$</formula>-monotone curves that form the edges of a general polygon. </para></listitem>
</itemizedlist>
</para><para><image type="html" name="general_polygon_with_holes.png"></image>
 <image type="latex" name="general_polygon_with_holes.png"></image>
</para><para>The concept <computeroutput><ref refid="classGeneralPolygonWithHoles__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">GeneralPolygonWithHoles_2</ref></computeroutput> is defined in an analogous way to the definition of linear polygons with holes. A model of this concept represent a bounded or an unbounded set that may not be simply connected, and must provide the following operations:</para><para><itemizedlist>
<listitem>
<para>Construction for a general polygon that represent the outer boundary and a range of general polygons that represent the holes. </para></listitem>
<listitem>
<para>Accessing the general polygons that represents the outer boundary (in case of a bounded set). </para></listitem>
<listitem>
<para>Traversing the holes. </para></listitem>
</itemizedlist>
In Section <ref refid="index_1bso_secbso_lin" kindref="member">Boolean Set-Operations on Linear Polygons</ref> we introduce the classes <computeroutput><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Polygon__with__holes__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">Polygon_with_holes_2</ref></computeroutput> that model the concepts <computeroutput><ref refid="classGeneralPolygon__2" kindref="compound">GeneralPolygon_2</ref></computeroutput> and <computeroutput><ref refid="classGeneralPolygonWithHoles__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">GeneralPolygonWithHoles_2</ref></computeroutput> respectively. In this section we introduce other models of these two concepts.</para><para>The central class-template <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref>&lt;Traits,Dcel&gt;</computeroutput> is used to represent point sets that are comprised of a finite number of pairwise disjoint general polygons with holes, and provides various Boolean set-operations on such sets. It is parameterized by a <emphasis>traits</emphasis> class and a Dcel class. The former defines the type of points used to represent polygon vertices and the type of <formula id="0">$ x$</formula>-monotone curves that represent the polygon edges. The traits class also provides primitive geometric operations that operate on objects of these types. The Dcel class is used to represent the underlying internal <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2</ref></computeroutput> data structure. The instantiated <computeroutput>Dcel</computeroutput> type is used to represent the underlying internal arrangement. It must model the concept <computeroutput><ref refid="classGeneralPolygonSetDcel" kindref="compound">GeneralPolygonSetDcel</ref></computeroutput>, and defaults to <computeroutput><ref refid="classCGAL_1_1Gps__default__dcel" kindref="compound">Gps_default_dcel</ref></computeroutput>. You can override this default, with a different Dcel class, typically an extension of the default. Overriding the default is necessary only if you intend to obtain the underlying internal arrangement and process it further.</para><para>An instantiated <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref></computeroutput> class defines the nested types <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref>&lt;Traits,Dcel&gt;::Polygon_2</computeroutput> and <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref>&lt;Traits,Dcel&gt;::Polygon_with_holes_2</computeroutput>, which model the concepts <computeroutput><ref refid="classGeneralPolygon__2" kindref="compound">GeneralPolygon_2</ref></computeroutput> and <computeroutput><ref refid="classGeneralPolygonWithHoles__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Polygon.tag">GeneralPolygonWithHoles_2</ref></computeroutput> respectively.</para><sect2 id="index_1bso_ssectraits_concepts">
<title>The Traits-Class Concepts</title>
<para>The traits class used to instantiate the <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref></computeroutput> class template must model the concept <computeroutput><ref refid="classGeneralPolygonSetTraits__2" kindref="compound">GeneralPolygonSetTraits_2</ref></computeroutput>, and is tailored to handle a specific family of curves. The concept <computeroutput><ref refid="classGeneralPolygonSetTraits__2" kindref="compound">GeneralPolygonSetTraits_2</ref></computeroutput> refines the concept <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput> specified next.</para><para>The concept <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput> refines the concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">ArrangementXMonotoneTraits_2</ref></computeroutput> (see Section <ref refid="index_1arr_sssecinsert_x_mon" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Inserting x-Monotone Curves</ref> in the 2D Arrangements chapter). Thus, a model of this concept must define the type <computeroutput>X_monotone_curve_2</computeroutput>, which represents an <formula id="0">$ x$</formula>-monotone curve, and the type <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Point_2</ref></computeroutput>, with represents a planar point. Such a point may be an endpoint of an <formula id="0">$ x$</formula>-monotone curve or an intersection point between two curves. It must also provide various geometric predicates and operations on these types listed by the base concept, such as determining whether a point lies above or below an <formula id="0">$ x$</formula>-monotone curve, computing the intersections between two curves, etc. Note that the base concept does not assume that <formula id="0">$ x$</formula>-monotone curves are directed: an <formula id="0">$ x$</formula>-monotone curve is not required to have a designated <emphasis>source</emphasis> and <emphasis>target</emphasis>, it is only required to determine the left (lexicographically smaller) and the right (lexicographically larger) endpoints of a given curve.</para><para>The <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput> concept treats its <formula id="0">$ x$</formula>-monotone curves as directed objects. It thus requires two additional operations on <formula id="0">$ x$</formula>-monotone curves: <itemizedlist>
<listitem>
<para>Given an <formula id="0">$ x$</formula>-monotone curve, compare its source and target points lexicographically. </para></listitem>
<listitem>
<para>Given an <formula id="0">$ x$</formula>-monotone curve, construct its opposite curve (namely, swap its source and target points). </para></listitem>
</itemizedlist>
</para><para>The traits classes <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_segment_traits_2</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_non_caching_segment_traits_2</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_circle_segment_traits_2</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_conic_traits_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_rational_function_traits_2</ref></computeroutput>, which are bundled in the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arrangement_2</ref></computeroutput> package and distributed with CGAL, are all models of the refined concept <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>.The <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_polyline_traits_2</ref></computeroutput> class is <emphasis>not</emphasis> a model of the, <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput> concept, as the <formula id="0">$ x$</formula>-monotone curve it defines is always directed from left to right. Thus, an opposite curve cannot be constructed. However, it is not very useful to construct a polygon whose edges are polylines, as an ordinary polygon with linear edges can represent the same entity.</para><para>Just as with the case of computations using models of the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">ArrangementXMonotoneTraits_2</ref></computeroutput> concept, operations are robust only when exact arithmetic is used. When inexact arithmetic is used, (nearly) degenerate configurations may result in abnormal termination of the program or even incorrect results.</para></sect2>
<sect2 id="index_1bso_sseccirc_seg">
<title>Operating on Polygons with Circular Arcs</title>
<para>Two traits classes are distributed with CGAL. The first one is named <computeroutput><ref refid="classCGAL_1_1Gps__segment__traits__2" kindref="compound">Gps_segment_traits_2</ref></computeroutput>, and it is used to perform Boolean set-operations on ordinary polygons and polygons with holes. In fact, the class <computeroutput><ref refid="classCGAL_1_1Polygon__set__2" kindref="compound">Polygon_set_2</ref></computeroutput> introduced in Section <ref refid="index_1bso_ssecmain_component" kindref="member">Operating on Polygon Sets</ref> is a specialization of <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref>&lt;<ref refid="classCGAL_1_1Gps__segment__traits__2" kindref="compound">Gps_segment_traits_2</ref>&gt;</computeroutput>. This class defined its polygon and polygon with holes types, such that the usage of this traits class is encapsulated in the polygon-set class.</para><para>The other predefined traits class is named <computeroutput><ref refid="classCGAL_1_1Gps__circle__segment__traits__2" kindref="compound">Gps_circle_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> and is parameterized by a geometric CGAL kernel. By instantiating the <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref></computeroutput> with this traits class, we obtain the representation of a polygon whose boundary may be comprised of line segments and circular arcs. The circle-segment traits class provides predicates and constructions on non-linear objects; yet, it uses only rational arithmetic and is very efficient as a consequence.</para><para><image type="html" name="circles_rects.png"></image>
 <image type="latex" name="circles_rects.png"></image>
</para><para>The following example uses the <computeroutput><ref refid="classCGAL_1_1Gps__circle__segment__traits__2" kindref="compound">Gps_circle_segment_traits_2</ref></computeroutput> class to compute the union of four rectangles and four circles. Each circle is represented as a general polygon having two <formula id="0">$ x$</formula>-monotone circular arcs. The union is computed incrementally, resulting with a single polygon with a single hole, as depicted on the right. Note that as the four circles are disjoint, their union is computed with the <computeroutput>insert</computeroutput> method, while the union with the rectangles is computed with the <computeroutput>join</computeroutput> operator.</para><para><linebreak/>
<bold>File</bold> <ref refid="Boolean_set_operations_2_2circle_segment_8cpp-example" kindref="compound">Boolean_set_operations_2/circle_segment.cpp</ref> <programlisting><codeline></codeline>
<codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Gps_circle_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/General_polygon_set_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Lazy__exact__nt_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Lazy_exact_nt.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Circle__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Circle_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Circle_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Gps__circle__segment__traits__2" kindref="compound">CGAL::Gps_circle_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">CGAL::General_polygon_set_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_set_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::General_polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::General_polygon_with_holes_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_with_holes_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>polygon<sp/>from<sp/>a<sp/>circle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Polygon_2<sp/>construct_polygon<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Circle_2&amp;<sp/>circle)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Subdivide<sp/>the<sp/>circle<sp/>into<sp/>two<sp/>x-monotone<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits_2<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve_2<sp/>curve<sp/>(circle);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;CGAL::Object&gt;<sp/><sp/>objects;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>traits.make_x_monotone_2_object()<sp/>(curve,<sp/>std::back_inserter(objects));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(objects.size()<sp/>==<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>pgn;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>arc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;CGAL::Object&gt;::iterator<sp/>iter;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(iter<sp/>=<sp/>objects.begin();<sp/>iter<sp/>!=<sp/>objects.end();<sp/>++iter)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::assign<sp/>(arc,<sp/>*iter);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pgn.push_back<sp/>(arc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pgn;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>polygon<sp/>from<sp/>a<sp/>rectangle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Polygon_2<sp/>construct_polygon<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_2&amp;<sp/>p1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_2&amp;<sp/>p2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_2&amp;<sp/>p3,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_2&amp;<sp/>p4)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>pgn;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>s1(p1,<sp/>p2);<sp/><sp/><sp/><sp/>pgn.push_back(s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>s2(p2,<sp/>p3);<sp/><sp/><sp/><sp/>pgn.push_back(s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>s3(p3,<sp/>p4);<sp/><sp/><sp/><sp/>pgn.push_back(s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>s4(p4,<sp/>p1);<sp/><sp/><sp/><sp/>pgn.push_back(s4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pgn;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>main<sp/>program:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>four<sp/>non-intersecting<sp/>circles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_set_2<sp/>S;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>circ1,<sp/>circ2,<sp/>circ3,<sp/>circ4;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>circ1<sp/>=<sp/>construct_polygon(Circle_2(Point_2(1,<sp/>1),<sp/>1));<sp/><sp/>S.insert(circ1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>circ2<sp/>=<sp/>construct_polygon(Circle_2(Point_2(5,<sp/>1),<sp/>1));<sp/><sp/>S.insert(circ2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>circ3<sp/>=<sp/>construct_polygon(Circle_2(Point_2(5,<sp/>5),<sp/>1));<sp/><sp/>S.insert(circ3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>circ4<sp/>=<sp/>construct_polygon(Circle_2(Point_2(1,<sp/>5),<sp/>1));<sp/><sp/>S.insert(circ4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>union<sp/>with<sp/>four<sp/>rectangles<sp/>incrementally.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>rect1,<sp/>rect2,<sp/>rect3,<sp/>rect4;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rect1<sp/>=<sp/>construct_polygon(Point_2(1,<sp/>0),<sp/>Point_2(5,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2(5,<sp/>2),<sp/>Point_2(1,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S.join<sp/>(rect1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rect2<sp/>=<sp/>construct_polygon(Point_2(1,<sp/>4),<sp/>Point_2(5,<sp/>4),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2(5,<sp/>6),<sp/>Point_2(1,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S.join<sp/>(rect2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rect3<sp/>=<sp/>construct_polygon(Point_2(0,<sp/>1),<sp/>Point_2(2,<sp/>1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2(2,<sp/>5),<sp/>Point_2(0,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S.join<sp/>(rect3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rect4<sp/>=<sp/>construct_polygon(Point_2(4,<sp/>1),<sp/>Point_2(6,<sp/>1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2(6,<sp/>5),<sp/>Point_2(4,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S.join<sp/>(rect4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>output.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Polygon_with_holes_2&gt;<sp/>res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>S.polygons_with_holes<sp/>(std::back_inserter<sp/>(res));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::copy<sp/>(res.begin(),<sp/>res.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ostream_iterator&lt;Polygon_with_holes_2&gt;(std::cout,<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1bso_ssecgeneral_polygon_concept">
<title>General Polygon Set Traits Adapter</title>
<para>The concept <computeroutput><ref refid="classGeneralPolygon__2" kindref="compound">GeneralPolygon_2</ref></computeroutput> and its generic model <computeroutput><ref refid="classCGAL_1_1General__polygon__2" kindref="compound">General_polygon_2</ref>&lt;ArrDirectionalXMonotoneTraits&gt;</computeroutput> facilitate the production of general-polygon set traits classes. A model of the concept <computeroutput><ref refid="classGeneralPolygon__2" kindref="compound">GeneralPolygon_2</ref></computeroutput> represents a simple point-set in the plane bounded by <formula id="0">$ x$</formula>-monotone curves. As opposed to the plain <computeroutput>Traits::Polygon_2</computeroutput> type defined by any traits class, it must define the type <computeroutput>X_monotone_curve_2</computeroutput>, which represents an <formula id="0">$ x$</formula>-monotone curve of the point-set boundary. It must provide a constructor from a range of such curves, and a pair of methods, namely <computeroutput>curves_begin()</computeroutput> and <computeroutput>curves_end()</computeroutput>, that can be used to iterate over the point-set boundary curves.</para><para>The class-template <computeroutput><ref refid="classCGAL_1_1General__polygon__2" kindref="compound">General_polygon_2</ref>&lt;ArrDirectionalXMonotoneTraits&gt;</computeroutput> models the concept <computeroutput><ref refid="classGeneralPolygon__2" kindref="compound">GeneralPolygon_2</ref></computeroutput>. Its sole template parameter must be instantiated with a model of the concept <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput> from which it obtains the <computeroutput>X_monotone_curve_2</computeroutput> type. It uses the geometric operations on this type provided by such a model to maintain a container of directed curves of type <computeroutput>X_monotone_curve_2</computeroutput>, which represents a boundary of the general polygon.</para><para>The class-template <computeroutput><ref refid="classCGAL_1_1Gps__traits__2" kindref="compound">Gps_traits_2</ref>&lt;ArrDirectionalXMonotoneTraits,GeneralPolygon&gt;</computeroutput> models the concept <computeroutput><ref refid="classGeneralPolygonSetTraits__2" kindref="compound">GeneralPolygonSetTraits_2</ref></computeroutput>, and can be used to instantiate the class template <computeroutput><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">General_polygon_set_2</ref></computeroutput>. It serves as an adapter for a geometric traits class, which models the concept <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>. It can be used for performing set-operations on general polygons. The implementation of the adapter is rather simple, as it is derived from the instantiated template-parameter <computeroutput>ArrXMonotoneTraits_2</computeroutput> inheriting its necessary types and methods. It further exploits the methods provided by the instantiated parameter <computeroutput>GeneralPolygon</computeroutput>, which is a model of the concept <computeroutput><ref refid="classGeneralPolygon__2" kindref="compound">GeneralPolygon_2</ref></computeroutput>. By default, the <computeroutput>GeneralPolygon</computeroutput> parameter is defined as <computeroutput><ref refid="classCGAL_1_1General__polygon__2" kindref="compound">General_polygon_2</ref>&lt;<ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound">ArrangementDirectionalXMonotoneTraits_2</ref>&gt;</computeroutput>.</para><para>The code excerpt listed below defines a general-polygon set type that can be used to perform Boolean set-operations on point sets bounded by the <formula id="0">$ x$</formula>-monotone curve type defined by the arrangement-traits class <computeroutput>Arr_traits_2</computeroutput>, which is some representative model of the concept <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>.</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/General_polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Gps_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1General__polygon__2" kindref="compound">CGAL::General_polygon_2&lt;Arr_traits_2&gt;</ref><sp/>General_polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Gps__traits__2" kindref="compound">CGAL::Gps_traits_2&lt;Arr_traits_2, General_polygon_2&gt;</ref><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">CGAL::General_polygon_set_2&lt;Traits_2&gt;</ref><sp/>General_polygon_set_2;</highlight></codeline>
</programlisting></para><para><image type="html" name="tnr_m_g.png"></image>
 <image type="latex" name="tnr_m_g.png"></image>
</para><para>Instantiating the arrangement-traits <computeroutput>Arr_traits_2</computeroutput> above with the traits class that handle B<eacute/>zier curves <computeroutput><ref refid="classCGAL_1_1Arr__Bezier__curve__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">Arr_Bezier_curve_traits_2</ref></computeroutput>, results with the definition of a general-polygon set type that can be used to perform Boolean set-operations on point sets bounded by B<eacute/>zier curves.</para><para>The next example computes the intersection of two general polygons bounded by B<eacute/>zier curves read from two input files respectively. The default input files our example uses (<computeroutput>char_g.dat</computeroutput> and <computeroutput>char_m.dat</computeroutput>) define two general polygons shaped in the form of the characters <bold>g</bold> and <bold>m</bold> in the Times New Roman font respectively. Their intersection comprises nine simple polygons, as depicted to the right.</para><para>Recall that every B<eacute/>zier curve is defined by a sequence of control points that form chains (see Section <ref refid="index_1arr_ssectr_bez" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">A Traits Class for Planar B<eacute/>zier Curves</ref>. The last control point of every curve must be identical to the first control point of its successor. The function <computeroutput>read_Bezier_polygon()</computeroutput> included in the example reads the curves from an input file until they form a closed chain, which is assumed to be the outer boundary of the polygon. If more curves are available, its starts constructing polygons that correspond to holes in the area bounded by the outer boundary. Note that this function is also responsible for subdividing the input B<eacute/>zier curves into <formula id="0">$ x$</formula>-monotone subcurves, as required by the <computeroutput><ref refid="classCGAL_1_1Gps__traits__2" kindref="compound">Gps_traits_2</ref></computeroutput> adapter.</para><para><linebreak/>
<bold>File</bold> <ref refid="Boolean_set_operations_2_2bezier_traits_adapter_8cpp-example" kindref="compound">Boolean_set_operations_2/bezier_traits_adapter.cpp</ref> <programlisting><codeline></codeline>
<codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/CORE_algebraic_number_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_Bezier_curve_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Gps_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Boolean_set_operations_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::CORE_algebraic_number_traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nt_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rational;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Algebraic<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Algebraic&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alg_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__Bezier__curve__traits__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Arrangement_on_surface_2.tag">CGAL::Arr_Bezier_curve_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rat_kernel::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bezier_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Gps__traits__2" kindref="compound">CGAL::Gps_traits_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Gps_traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Gps_traits_2::General_polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Gps_traits_2::General_polygon_with_holes_2<sp/><sp/><sp/><sp/><sp/><sp/>Polygon_with_holes_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::list&lt;Polygon_with_holes_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_set;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>read_Bezier_polygon(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename,<sp/>Polygon_with_holes_2&amp;<sp/>P)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/><sp/><sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>number<sp/>of<sp/>curves.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n_curves;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>k;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>n_curves;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>curves<sp/>one<sp/>by<sp/>one,<sp/>and<sp/>construct<sp/>the<sp/>general<sp/>polygon<sp/>these</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>curve<sp/>form<sp/>(the<sp/>outer<sp/>boundary<sp/>and<sp/>the<sp/>holes<sp/>inside<sp/>it).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits_2::Make_x_monotone_2<sp/>mk_x_monotone<sp/>=<sp/>traits.make_x_monotone_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>first<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p_0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;X_monotone_curve_2&gt;<sp/><sp/>xcvs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_kernel<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ker;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_kernel::Equal_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>equal<sp/>=<sp/>ker.equal_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Polygon_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pgns;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>n_curves;<sp/>k++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>current<sp/>curve<sp/>and<sp/>subdivide<sp/>it<sp/>into<sp/>x-monotone<sp/>subcurves.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Bezier_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>B;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::list&lt;CGAL::Object&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x_objs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::list&lt;CGAL::Object&gt;::const_iterator<sp/><sp/>xoit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xcv;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>B;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mk_x_monotone(B,<sp/>std::back_inserter(x_objs));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(xoit<sp/>=<sp/>x_objs.begin();<sp/>xoit<sp/>!=<sp/>x_objs.end();<sp/>++xoit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CGAL::assign(xcv,<sp/>*xoit))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xcvs.push_back(xcv);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>the<sp/>current<sp/>curve<sp/>closes<sp/>a<sp/>polygon,<sp/>namely<sp/>whether<sp/>it<sp/>target</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>point<sp/>(the<sp/>last<sp/>control<sp/>point)<sp/>equals<sp/>the<sp/>source<sp/>of<sp/>the<sp/>first<sp/>curve<sp/>in</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>current<sp/>chain.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>first)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(equal(p_0,<sp/>B.control_point(B.number_of_control_points()<sp/>-<sp/>1)))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Push<sp/>a<sp/>new<sp/>polygon<sp/>into<sp/>the<sp/>polygon<sp/>list.<sp/>Make<sp/>sure<sp/>that<sp/>the<sp/>polygon</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>is<sp/>counterclockwise<sp/>oriented<sp/>if<sp/>it<sp/>represents<sp/>the<sp/>outer<sp/>boundary</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>clockwise<sp/>oriented<sp/>if<sp/>it<sp/>represents<sp/>a<sp/>hole.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pgn(xcvs.begin(),<sp/>xcvs.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__kernel__enums_1ga59bee58a806ccde81562ea315ff75525" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Orientation</ref><sp/><sp/>orient<sp/>=<sp/>pgn.orientation();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((pgns.empty()<sp/>&amp;&amp;<sp/>(orient<sp/>==<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>))<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(!<sp/>pgns.empty()<sp/>&amp;&amp;<sp/>(orient<sp/>==<sp/><ref refid="group__kernel__enums_1ga39fcfbab0b0f0ce9139ad1613e21d60d" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::COUNTERCLOCKWISE</ref>)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pgn.reverse_orientation();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pgns.push_back(pgn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xcvs.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>first<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>is<sp/>the<sp/>first<sp/>curve<sp/>in<sp/>the<sp/>chain<sp/>-<sp/>store<sp/>its<sp/>source<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p_0<sp/>=<sp/>B.control_point(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>first<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>xcvs.empty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>polygon<sp/>with<sp/>holes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Polygon_2&gt;::iterator<sp/><sp/><sp/><sp/><sp/>pit<sp/>=<sp/>pgns.begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>++pit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>P<sp/>=<sp/>Polygon_with_holes_2(pgns.front(),<sp/>pit,<sp/>pgns.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>main<sp/>program.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>files<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>char_g.dat<sp/>and<sp/>char_m.dat<sp/>files<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename1<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;char_g.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename2<sp/>=<sp/>(argc<sp/>&gt;<sp/>2)<sp/>?<sp/>argv[2]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;char_m.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>general<sp/>polygons<sp/>from<sp/>the<sp/>input<sp/>files.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Timer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_with_holes_2<sp/><sp/>P1,<sp/>P2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.start();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>read_Bezier_polygon(filename1,<sp/>P1))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>read<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>read_Bezier_polygon(filename2,<sp/>P2))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>read<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename2<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Constructed<sp/>the<sp/>input<sp/>polygons<sp/>in<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>timer.time()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>intersection<sp/>of<sp/>the<sp/>two<sp/>polygons.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_set<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_set::const_iterator<sp/><sp/><sp/><sp/><sp/>rit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__intersection__linear__grp_1gab77f3cd98c4c4ff7acff59c98ab88ff0" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::intersection</ref>(P1,<sp/>P2,<sp/>std::back_inserter(R));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.stop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>intersection<sp/>polygons<sp/>are<sp/>of<sp/>sizes:<sp/>{&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(rit<sp/>=<sp/>R.begin();<sp/>rit<sp/>!=<sp/>R.end();<sp/>++rit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>rit-&gt;outer_boundary().size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>}&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>intersection<sp/>computation<sp/>took<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>timer.time()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1bso_ssecaggregated_gen_ops">
<title>Example - Aggregated Operations</title>
<para>In Section <ref refid="index_1bso_ssecagg_ops" kindref="member">Performing Aggregated Operations</ref> we describe how aggregated union and intersection operations can be applied to a collection of ordinary polygons or polygons with holes. Naturally, the aggregated operations can be applied also to collections of general polygons. As was the case with ordinary polygons, using aggregated operations is recommended when the number of intersections of the input polygons is of the same order of magnitude as the complexity of the result. If this is not the case, computing the result incrementally may prove faster.</para><para><image type="html" name="disks.png"></image>
 <image type="latex" name="disks.png"></image>
</para><para>The next example computes the union of eight unit discs whose centers are placed a unit distance from the origin, as depicted to the right. The example also allows users to provide a different number of discs through the command line.</para><para><linebreak/>
<bold>File</bold> <ref refid="Boolean_set_operations_2_2set_union_8cpp-example" kindref="compound">Boolean_set_operations_2/set_union.cpp</ref> <programlisting><codeline></codeline>
<codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Gps_circle_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Boolean_set_operations_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Lazy__exact__nt_8h" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Number_types.tag">CGAL/Lazy_exact_nt.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cmath&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Circle__2" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Kernel_23.tag">Kernel::Circle_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Circle_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Gps__circle__segment__traits__2" kindref="compound">CGAL::Gps_circle_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1General__polygon__set__2" kindref="compound">CGAL::General_polygon_set_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_set_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Polygon_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Polygon_with_holes_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_with_holes_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>polygon<sp/>from<sp/>a<sp/>circle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Polygon_2<sp/>construct_polygon<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Circle_2&amp;<sp/>circle)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Subdivide<sp/>the<sp/>circle<sp/>into<sp/>two<sp/>x-monotone<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits_2<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve_2<sp/>curve<sp/>(circle);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;CGAL::Object&gt;<sp/>objects;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>traits.make_x_monotone_2_object()<sp/>(curve,<sp/>std::back_inserter(objects));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion<sp/>(objects.size()<sp/>==<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>pgn;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve_2<sp/>arc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;CGAL::Object&gt;::iterator<sp/>iter;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(iter<sp/>=<sp/>objects.begin();<sp/>iter<sp/>!=<sp/>objects.end();<sp/>++iter)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::assign<sp/>(arc,<sp/>*iter);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pgn.push_back<sp/>(arc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pgn;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>main<sp/>program:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>number<sp/>of<sp/>circles<sp/>from<sp/>the<sp/>command<sp/>line.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n_circles<sp/>=<sp/>8;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>1)<sp/>n_circles<sp/>=<sp/>std::atoi(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>the<sp/>circles,<sp/>equally<sp/>spaced<sp/>of<sp/>the<sp/>circle<sp/>x^2<sp/>+<sp/>y^2<sp/>=<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>pi<sp/>=<sp/>std::atan(1.0)<sp/>*<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>n_circles_reciep<sp/>=<sp/>1.0<sp/>/<sp/>n_circles;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>radius<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>frac<sp/>=<sp/>2<sp/>*<sp/>pi<sp/>*<sp/>n_circles_reciep;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Polygon_2&gt;<sp/>circles;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>n_circles;<sp/>k++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>angle<sp/>=<sp/>frac<sp/>*<sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x<sp/>=<sp/>radius<sp/>*<sp/>std::sin(angle);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y<sp/>=<sp/>radius<sp/>*<sp/>std::cos(angle);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point_2<sp/>center<sp/>=<sp/>Point_2(x,<sp/>y);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Circle_2<sp/>circle(center,<sp/>radius);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>circles.push_back<sp/>(construct_polygon<sp/>(circle));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>union<sp/>aggregately.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Polygon_with_holes_2&gt;<sp/>res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__boolean__join_1gafca2f0759f989fe95d1c56b0428a0f16" kindref="member">CGAL::join</ref><sp/>(circles.begin(),<sp/>circles.end(),<sp/>std::back_inserter<sp/>(res));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>result.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::copy<sp/>(res.begin(),<sp/>res.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ostream_iterator&lt;Polygon_with_holes_2&gt;(std::cout,<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
