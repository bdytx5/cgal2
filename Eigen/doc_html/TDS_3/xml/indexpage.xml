<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <detaileddescription>
<para><anchor id="index_1Chapter_3D_Triangulation_Data_Structure"/><anchor id="index_1chapterTDS3"/>  <simplesect kind="authors"><para>Cl√©ment Jamin, Sylvain Pion and Monique Teillaud</para></simplesect>
A geometric triangulation has two aspects: the combinatorial structure, which gives the incidence and adjacency relations between faces, and the geometric information related to the position of vertices.</para><para>CGAL provides 3D geometric triangulations in which these two aspects are clearly separated. As described in Chapter <ref refid="index_1chapterTriangulation3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">3D Triangulations</ref>, a geometric triangulation of a set of points in <formula id="50">$ \mathbb{R}^d$</formula>, <formula id="51">$ d\leq 3$</formula> is a partition of the whole space <formula id="50">$ \mathbb{R}^d$</formula> into cells having <formula id="52">$ d+1$</formula> vertices. Some of them are infinite, they are obtained by linking an additional vertex at infinity to each facet of the convex hull of the points (see Section <ref refid="index_1Triangulation3secintro" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Representation</ref>). The underlying combinatorial graph of such a triangulation without boundary of <formula id="50">$ \mathbb{R}^d$</formula> can be seen as a triangulation of the topological sphere <formula id="10">$ S^d$</formula> in <formula id="11">$ \mathbb{R}^{d+1}$</formula>.</para><para>This chapter deals with 3D-triangulation data structures, meant to maintain the combinatorial information for 3D-geometric triangulations. The reader interested in geometric triangulations of <formula id="53">$ \mathbb{R}^3$</formula> is advised to read Chapter <ref refid="index_1chapterTriangulation3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">3D Triangulations</ref>.</para><sect1 id="index_1TDS3secintro">
<title>Representation</title>
<para>In CGAL, a 3D triangulation data structure is a container of cells ( <formula id="0">$ 3$</formula>-faces) and vertices ( <formula id="1">$ 0$</formula>-faces).</para><para>Following the standard vocabulary of simplicial complexes, an <formula id="2">$ i$</formula>-face <formula id="3">$ f_i$</formula> and a <formula id="4">$ j$</formula>-face <formula id="5">$ f_j$</formula> <formula id="6">$ (0 \leq j &lt; i \leq 3)$</formula> are said to be <emphasis>incident</emphasis> in the triangulation if <formula id="5">$ f_j$</formula> is a (sub)face of <formula id="3">$ f_i$</formula>, and two <formula id="2">$ i$</formula>-faces <formula id="7">$ (0 \leq i \leq 3)$</formula> are said to be <emphasis>adjacent</emphasis> if they share a commun incident (sub)face.</para><para>Each cell gives access to its four incident vertices and to its four adjacent cells. Each vertex gives direct access to one of its incident cells, which is sufficient to retrieve all the incident cells when needed.</para><para>The four vertices of a cell are indexed with 0, 1, 2 and 3. The neighbors of a cell are also indexed with 0, 1, 2, 3 in such a way that the neighbor indexed by <formula id="2">$ i$</formula> is opposite to the vertex with the same index (see <ref refid="index_1fig__TDS3figrepres" kindref="member">fig__TDS3figrepres</ref>).</para><para><anchor id="index_1fig__TDS3figrepres"/><image type="html" name="repres.png"></image>
 <image type="latex" name="repres.png" width="15cm"></image>
  <ref refid="index_1fig__TDS3figrepres" kindref="member">fig__TDS3figrepres</ref> Representation.  <linebreak/>
</para><para>Edges ( <formula id="8">$ 1$</formula>-faces) and facets ( <formula id="9">$ 2$</formula>-faces) are not explicitly represented: a facet is given by a cell and an index (the facet <computeroutput>i</computeroutput> of a cell <computeroutput>c</computeroutput> is the facet of <computeroutput>c</computeroutput> that is opposite to the vertex of index <computeroutput>i</computeroutput>) and an edge is given by a cell and two indices (the edge <computeroutput>(i,j)</computeroutput> of a cell <computeroutput>c</computeroutput> is the edge whose endpoints are the vertices of indices <computeroutput>i</computeroutput> and <computeroutput>j</computeroutput> of <computeroutput>c</computeroutput>).</para><para><bold>Degenerate Dimensions</bold></para><para>As CGAL explicitly deals with all degenerate cases, a 3D-triangulation data structure in CGAL can handle the cases when the dimension of the triangulation is lower than 3.</para><para>Thus, a 3D-triangulation data structure can store a triangulation of a topological sphere <formula id="10">$ S^d$</formula> of <formula id="11">$ \mathbb{R}^{d+1}$</formula>, for any <formula id="12">$ d \in \{-1,0,1,2,3\}$</formula>.</para><para>Let us give, for each dimension, the example corresponding to the triangulation data structure having a minimal number of vertices, i.e. a simplex. These examples are illustrated by presenting their usual geometric embedding. <itemizedlist>
<listitem>
<para><emphasis>dimension 3.</emphasis> The triangulation data structure consists of the boundary of a 4-dimensional simplex, which has 5 vertices. A geometric embedding consists in choosing one of these vertices to be infinite, thus four of the five 3-cells become infinite: the geometric triangulation has one finite tetrahedron remaining, each of its facets being incident to an infinite cell. See <ref refid="index_1fig__TDS3figtoposimplex4" kindref="member">fig__TDS3figtoposimplex4</ref>.</para><para><anchor id="index_1fig__TDS3figtoposimplex4"/><image type="html" name="topo-simplex4.png"></image>
 <image type="latex" name="topo-simplex4.png" width="15cm"></image>
  <ref refid="index_1fig__TDS3figtoposimplex4" kindref="member">fig__TDS3figtoposimplex4</ref> 4D simplex and a 3D geometric embedding.  <linebreak/>
</para><para></para></listitem>
<listitem>
<para><emphasis>dimension 2.</emphasis> We have 4 vertices forming one 3-dimensional simplex, i.e. the boundary of a tetrahedron. The geometric embedding in the plane results from choosing one of these vertices to be infinite, then the geometric triangulation has one finite triangle whose edges are incident to the infinite triangles. See <ref refid="index_1fig__TDS3figtoposimplex3" kindref="member">fig__TDS3figtoposimplex3</ref>.</para><para><anchor id="index_1fig__TDS3figtoposimplex3"/><image type="html" name="topo-simplex3.png"></image>
 <image type="latex" name="topo-simplex3.png" width="15cm"></image>
  <ref refid="index_1fig__TDS3figtoposimplex3" kindref="member">fig__TDS3figtoposimplex3</ref> 3D simplex and a 2D geometric embedding.  <linebreak/>
</para><para></para></listitem>
<listitem>
<para><emphasis>dimension 1.</emphasis> A 2-dimensional simplex (a triangle) has 3 vertices. The geometric embedding is an edge whose vertices are linked to an infinite point. See <ref refid="index_1fig__TDS3figtoposimplex2" kindref="member">fig__TDS3figtoposimplex2</ref>.</para><para><anchor id="index_1fig__TDS3figtoposimplex2"/><image type="html" name="topo-simplex2.png"></image>
 <image type="latex" name="topo-simplex2.png" width="15cm"></image>
  <ref refid="index_1fig__TDS3figtoposimplex2" kindref="member">fig__TDS3figtoposimplex2</ref> 2D simplex and a 1D geometric embedding.  <linebreak/>
</para><para></para></listitem>
</itemizedlist>
</para><para>The last three cases are defined uniquely: <itemizedlist>
<listitem>
<para><emphasis>dimension 0.</emphasis> A 0-dimensional triangulation is combinatorially equivalent to the boundary of a 1-dimensional simplex (an edge), which consists of 2 vertices. One of them becomes infinite in the geometric embedding, and there is only one finite vertex remaining. The two vertices are adjacent. </para></listitem>
<listitem>
<para><emphasis>dimension -1.</emphasis> This dimension is a convention to represent a 0-dimensional simplex, that is a sole vertex, which will be geometrically embedded as an &quot;empty&quot; triangulation, having only one infinite vertex. </para></listitem>
<listitem>
<para><emphasis>dimension -2.</emphasis> This is also a convention. The triangulation data structure has no vertex. There is no associated geometric triangulation. </para></listitem>
</itemizedlist>
</para><para>Note that the notion of infinite vertex has no meaning for the triangulation data structure. The infinite vertex of the geometric embedding is a vertex that cannot be distinguished from the other vertices in the combinatorial triangulation.</para><para>The same cell class is used in all cases: triangular faces in 2D can be considered as degenerate cells, having only three vertices (resp. neighbors) numbered <formula id="54">$ (0,1,2)$</formula>; edges in 1D have only two vertices (resp. neighbors) numbered <formula id="1">$ 0$</formula> and <formula id="8">$ 1$</formula>.</para><para>The implicit representation of facets (resp. edges) still holds for degenerate ( <formula id="55">$ &lt; 3$</formula>) dimensions : in dimension 2, each cell has only one facet of index 3, and 3 edges <formula id="13">$ (0,1)$</formula>, <formula id="14">$ (1,2)$</formula> and <formula id="15">$ (2,0)$</formula>; in dimension 1, each cell has one edge <formula id="13">$ (0,1)$</formula>.</para><para><bold>Validity</bold></para><para>A 3D combinatorial triangulation is said to be <computeroutput>locally valid</computeroutput> iff the following is true:</para><para><bold>(a)</bold> When a cell <formula id="56">$ c$</formula> has a neighbor pointer to another cell <formula id="57">$ c&apos;$</formula>, then reciprocally this cell <formula id="57">$ c&apos;$</formula> has a neighbor pointer to <formula id="56">$ c$</formula>, and <formula id="56">$ c$</formula> and <formula id="57">$ c&apos;$</formula> have three vertices in common. These cells are called adjacent.</para><para><bold>(b)</bold> The cells have a coherent orientation: if two cells <formula id="58">$ c_1$</formula> and <formula id="59">$ c_2$</formula> are adjacent and share a facet with vertices <formula id="60">$ u,v,w$</formula>, then the vertices of <formula id="58">$ c_1$</formula> are numbered <formula id="61">$ (v_0^1 = u, v_1^1 = v, v_2^1 = w, v_3^1)$</formula>, and the vertices of <formula id="59">$ c_2$</formula> are numbered <formula id="62">$ (v_0^2 = v, v_1^2 = u, v_2^2 = w, v_3^2)$</formula>, up to positive permutations of <formula id="63">$ (0,1,2,3)$</formula>. In other words, if we embed the triangulation in <formula id="53">$ \mathbb{R}^3$</formula>, then the fourth vertices <formula id="64">$ v_3^1$</formula> and <formula id="65">$ v_3^2$</formula> of <formula id="58">$ c_1$</formula> and <formula id="59">$ c_2$</formula> see the common facet in opposite orientations. See <ref refid="index_1fig__TDS3figcomborient" kindref="member">fig__TDS3figcomborient</ref>.</para><para>The set <formula id="66">$ \sigma$</formula> <formula id="67">$ _4$</formula> of permutations of <formula id="63">$ (0,1,2,3)$</formula> has cardinality 24, and the set of positive permutations <formula id="68">$ A_4$</formula> has cardinality 12. Thus, for a given orientation, there are up to 12 different orderings of the four vertices of a cell. Note that cyclic permutations are negative and so do not preserve the orientation of a cell.</para><para><anchor id="index_1fig__TDS3figcomborient"/><image type="html" name="comborient.png"></image>
 <image type="latex" name="comborient.png" width="15cm"></image>
  <ref refid="index_1fig__TDS3figcomborient" kindref="member">fig__TDS3figcomborient</ref> Coherent orientations of two cells (3-dimensional case).  <linebreak/>
</para><para>The method <computeroutput>Triangulation_data_structure_3::is_valid()</computeroutput> method checks the local validity of a given triangulation data structure.</para></sect1>
<sect1 id="index_1TDS3secdesign">
<title>Software Design</title>
<para>The 3D-triangulation data structure class of CGAL, <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound">Triangulation_data_structure_3</ref></computeroutput>, is designed to be used as a combinatorial layer upon which a geometric layer can be built <ref refid="citelist_1CITEREF_k-ddsps-98" kindref="member">[1]</ref>. This geometric layer is typically one of the 3D-triangulation classes of CGAL: <computeroutput><ref refid="classCGAL_1_1Triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Triangulation_3</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Delaunay_triangulation_3</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Regular__triangulation__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Regular_triangulation_3</ref></computeroutput>. This relation is described in more details in Chapter <ref refid="index_1chapterTriangulation3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">3D Triangulations</ref>, where the Section <ref refid="index_1Triangulation3secdesign" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Software Design</ref> explains other important parts of the design related to the geometry.</para><para>We focus here on the design of the triangulation data structure (TDS) itself, which the <ref refid="index_1fig__TDS3figlayers" kindref="member">fig__TDS3figlayers</ref> illustrates.</para><para><anchor id="index_1fig__TDS3figlayers"/><image type="html" name="design_tds.png"></image>
 <image type="latex" name="design_tds.png" width="15cm"></image>
  <ref refid="index_1fig__TDS3figlayers" kindref="member">fig__TDS3figlayers</ref> Triangulation Data Structure software design.  <linebreak/>
</para><sect2 id="index_1TDS_3FlexibilityoftheDesign">
<title>Flexibility of the Design</title>
<para>In order for the user to be able to add his own data in the vertices and cells, the design of the TDS is split into two layers:</para><para><itemizedlist>
<listitem>
<para>In the bottom layer, the (vertex and cell) base classes store elementary incidence and adjacency (and possibly geometric or other) information. These classes are parameterized by the TDS which provides the handle types. (They can also be parameterized by a geometric traits class or anything else.) A vertex stores a <computeroutput>Cell_handle</computeroutput>, and a cell stores four <computeroutput>Vertex_handle</computeroutput>s and four <computeroutput>Cell_handle</computeroutput>s.</para><para></para></listitem>
<listitem>
<para>The middle layer is the TDS, which is purely combinatorial. It provides operations such as insertion of a new vertex in a given cell, on a <formula id="8">$ 1$</formula> or <formula id="9">$ 2$</formula>-face. It also allows one, if the dimension of the triangulation is smaller than <formula id="0">$ 3$</formula>, to insert a vertex so that the dimension of the triangulation is increased by one. The TDS is responsible for the combinatorial integrity of the eventual geometric triangulation built on top of it (the upper layer, see Chapter <ref refid="index_1chapterTriangulation3" kindref="member" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">3D Triangulations</ref>). </para></listitem>
</itemizedlist>
</para><para>The user has several ways to add his own data in the vertex and cell base classes used by the TDS. He can either: <itemizedlist>
<listitem>
<para>use the classes <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__with__info__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Triangulation_vertex_base_with_info_3</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Triangulation__cell__base__with__info__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Triangulation_cell_base_with_info_3</ref></computeroutput>, which allow to add one data member of a user provided type, and give access to it. </para></listitem>
<listitem>
<para>derive his own classes from the default base classes <computeroutput><ref refid="classCGAL_1_1Triangulation__ds__vertex__base__3" kindref="compound">Triangulation_ds_vertex_base_3</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Triangulation__ds__cell__base__3" kindref="compound">Triangulation_ds_cell_base_3</ref></computeroutput> (or the geometric versions typically used by the geometric layer, <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Triangulation_vertex_base_3</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Triangulation__cell__base__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Triangulation_cell_base_3</ref></computeroutput>). </para></listitem>
<listitem>
<para>write his own base classes following the requirements given by the concepts <computeroutput><ref refid="classTriangulationCellBase__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">TriangulationCellBase_3</ref></computeroutput> and <computeroutput><ref refid="classTriangulationVertexBase__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">TriangulationVertexBase_3</ref></computeroutput>. </para></listitem>
</itemizedlist>
</para></sect2>
<sect2 id="index_1tds3cyclic">
<title>Cyclic Dependency</title>
<para>Since adjacency relations are stored in the vertices and cells, it means that the vertex and cell base classes have to be able to store handles (an entity akin to pointers) to their neighbors in the TDS. This in turns means that the vertex and cell base classes have to know the types of these handles, which are provided by the TDS. So in a sense, the base classes are parameterized by the TDS, and the TDS is parameterized by the vertex and cell base classes ! This is a cycle which cannot be resolved easily.</para><para>The solution that we have chosen is similar to the mechanism used by the standard class <computeroutput>std::allocator</computeroutput>: the vertex and cell base classes are initially given a fake or dummy TDS template parameter, whose unique purpose is to provide the types that can be used by the vertex and cell base classes (such as handles). Then, inside the TDS itself, these base classes are <emphasis>rebound</emphasis> to the real TDS type, that is we obtain the same vertex and cell base classes, but parameterized with the real TDS instead of the dummy one. Rebinding is performed by a nested template class of the vertex and cell base classes (see code below), which provides a type which is the rebound vertex or cell base classIt is logically equivalent to a mechanism that does not exist yet in the C++ language: <emphasis>template typedef</emphasis> or <emphasis>template aliasing</emphasis>.</para><para>Here is how it works, schematically:</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Vb,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Cb<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">TDS</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>TDS&lt;Vb,<sp/>Cb&gt;<sp/>Self;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Rebind<sp/>the<sp/>vertex<sp/>and<sp/>cell<sp/>base<sp/>to<sp/>the<sp/>actual<sp/>TDS<sp/>(Self).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::template<sp/>Rebind_TDS&lt;Self&gt;::Other<sp/>VertexBase;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Cb::template<sp/>Rebind_TDS&lt;Self&gt;::Other<sp/>CellBase;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>...<sp/>further<sp/>internal<sp/>machinery<sp/>leads<sp/>to<sp/>the<sp/>final<sp/>public<sp/>types:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>...<sp/>Vertex;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>...<sp/>Cell;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>...<sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>...<sp/>Cell_handle;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">TDS<sp/>=<sp/>...<sp/>&gt;<sp/></highlight><highlight class="comment">//<sp/>The<sp/>default<sp/>is<sp/>some<sp/>internal<sp/>type<sp/>faking<sp/>a<sp/>TDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Triangulation_ds_vertex_base_3</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>TDS2<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Rebind_TDS<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation_ds_vertex_base_3&lt;TDS2&gt;<sp/>Other;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>When derivation is used for the vertex or cell base classes, which is the case at the geometric level with <computeroutput><ref refid="classCGAL_1_1Triangulation__vertex__base__3" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/Triangulation_3.tag">Triangulation_vertex_base_3</ref></computeroutput>, then it gets slightly more involved because its base class has to be rebound as well:</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>GT,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Vb<sp/>=<sp/>Triangulation_ds_vertex_base_3&lt;&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Triangulation_vertex_base_3<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Vb</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>TDS2<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Rebind_TDS<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::template<sp/>Rebind_TDS&lt;TDS2&gt;::Other<sp/>Vb2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Triangulation_vertex_base_3&lt;GT,<sp/>Vb2&gt;<sp/>Other;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1tds3parallel">
<title>Parallel Operations</title>
<para>The third template parameter of <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound">Triangulation_data_structure_3</ref></computeroutput> is <computeroutput>Concurrency_tag</computeroutput>. It enables the use of a concurrent container (<computeroutput><ref refid="classCGAL_1_1Concurrent__compact__container" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Concurrent_compact_container</ref></computeroutput>) to store vertices and cells. If it is <computeroutput><ref refid="structCGAL_1_1Parallel__tag" kindref="compound" external="/home/cgal-testsuite/cgal_doc_build/CGAL-4.13-I-128/doc/scripts/build_doc/doc_tags/STL_Extension.tag">Parallel_tag</ref></computeroutput>, then <computeroutput>create_vertex</computeroutput>, <computeroutput>create_cell</computeroutput>, <computeroutput>delete_vertex</computeroutput> and <computeroutput>delete_cell</computeroutput> can be called concurrently.</para></sect2>
</sect1>
<sect1 id="index_1TDS3secexamples">
<title>Examples</title>
<sect2 id="index_1TDS_3IncrementalConstruction">
<title>Incremental Construction</title>
<para>The following example shows how to construct a 3D triangulation data structure by inserting vertices.</para><para><linebreak/>
<bold>File</bold> <ref refid="TDS_3_2tds_8cpp-example" kindref="compound">TDS_3/tds.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_data_structure_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound">CGAL::Triangulation_data_structure_3&lt;&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Tds;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Tds::size_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Tds::Cell_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cell_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Tds::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tds<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.number_of_vertices()<sp/>==<sp/>0<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.dimension()<sp/>==<sp/>-2<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Vertex_handle&gt;<sp/>PV(7);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PV[0]<sp/>=<sp/>T.insert_increase_dimension();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.number_of_vertices()<sp/>==<sp/>1<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.dimension()<sp/>==<sp/>-1<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>each<sp/>of<sp/>the<sp/>following<sp/>insertions<sp/>of<sp/>vertices<sp/>increases<sp/>the<sp/>dimension</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=1;<sp/>i&lt;5;<sp/>i++<sp/>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PV[i]<sp/>=<sp/>T.insert_increase_dimension(PV[0]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>T.number_of_vertices()<sp/>==<sp/>(size_type)<sp/>i+1<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>T.dimension()<sp/>==<sp/>i-1<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(<sp/>T.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.number_of_cells()<sp/>==<sp/>5<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>now<sp/>have<sp/>a<sp/>simplex<sp/>in<sp/>dimension<sp/>4</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>cell<sp/>incident<sp/>to<sp/>PV[0]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Cell_handle<sp/>c<sp/>=<sp/>PV[0]-&gt;cell();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ind;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>check<sp/>=<sp/>c-&gt;has_vertex(<sp/>PV[0],<sp/>ind<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>check<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>PV[0]<sp/>is<sp/>the<sp/>vertex<sp/>of<sp/>index<sp/>ind<sp/>in<sp/>c</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>insertion<sp/>of<sp/>a<sp/>new<sp/>vertex<sp/>in<sp/>the<sp/>facet<sp/>opposite<sp/>to<sp/>PV[0]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PV[5]<sp/>=<sp/>T.insert_in_facet(c,<sp/>ind);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.number_of_vertices()<sp/>==<sp/>6<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.dimension()<sp/>==<sp/>3<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>insertion<sp/>of<sp/>a<sp/>new<sp/>vertex<sp/>in<sp/>c</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PV[6]<sp/>=<sp/>T.insert_in_cell(c);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.number_of_vertices()<sp/>==<sp/>7<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.dimension()<sp/>==<sp/>3<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(<sp/>T.is_valid()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>oFileT(</highlight><highlight class="stringliteral">&quot;output_tds&quot;</highlight><highlight class="normal">,std::ios::out);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>writing<sp/>file<sp/>output_tds;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>oFileT<sp/>&lt;&lt;<sp/>T;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="index_1TDS_3CrossLinkingBetweena2Danda3DDataStructures">
<title>Cross-Linking Between a 2D and a 3D Data Structures</title>
<para>This example program illustrates how to setup a 2D and a 3D triangulation data structures whose vertices respectively store vertex handles of the other one.</para><para><linebreak/>
<bold>File</bold> <ref refid="TDS_3_2linking_2d_and_3d_8cpp-example" kindref="compound">TDS_3/linking_2d_and_3d.cpp</ref> <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_data_structure_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_data_structure_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>declare<sp/>the<sp/>2D<sp/>vertex<sp/>base<sp/>type,<sp/>parametrized<sp/>by<sp/>some<sp/>3D<sp/>TDS.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T3,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb<sp/>=<sp/>CGAL::Triangulation_ds_vertex_base_2&lt;&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_vertex_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>declare<sp/>the<sp/>3D<sp/>vertex<sp/>base<sp/>type,<sp/>parametrized<sp/>by<sp/>some<sp/>2D<sp/>TDS.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T2,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb<sp/>=<sp/>CGAL::Triangulation_ds_vertex_base_3&lt;&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_vertex_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Then,<sp/>we<sp/>have<sp/>to<sp/>break<sp/>the<sp/>dependency<sp/>cycle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>we<sp/>need<sp/>to<sp/>refer<sp/>to<sp/>a<sp/>dummy<sp/>3D<sp/>TDS.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__ds__vertex__base__3" kindref="compound">CGAL::Triangulation_ds_vertex_base_3&lt;&gt;::Triangulation_data_structure</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dummy_tds_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>2D<sp/>TDS,<sp/>initially<sp/>plugging<sp/>a<sp/>dummy<sp/>3D<sp/>TDS<sp/>in<sp/>the<sp/>vertex<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>(to<sp/>break<sp/>the<sp/>dependency<sp/>cycle).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Triangulation_data_structure_2&lt;My_vertex_2&lt;Dummy_tds_3&gt;<sp/>&gt;<sp/><sp/>TDS_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>3D<sp/>TDS,<sp/>here<sp/>we<sp/>can<sp/>plug<sp/>the<sp/>2D<sp/>TDS<sp/>directly.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__3" kindref="compound">CGAL::Triangulation_data_structure_3&lt;My_vertex_3&lt;TDS_2&gt;</ref><sp/>&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TDS_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T3,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_vertex_2</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Vb</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Face_handle<sp/><sp/><sp/><sp/>Face_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>TDS2&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Rebind_TDS<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::template<sp/>Rebind_TDS&lt;TDS2&gt;::Other<sp/><sp/>Vb2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>also<sp/>have<sp/>to<sp/>break<sp/>the<sp/>cycle<sp/>here<sp/>by<sp/>hardcoding<sp/>TDS_3<sp/>instead<sp/>of<sp/>T3.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>My_vertex_2&lt;TDS_3,<sp/>Vb2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Other;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_2()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_2(Face_handle<sp/>f)<sp/>:<sp/>Vb(f)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>store<sp/>a<sp/>vertex<sp/>handle<sp/>of<sp/>the<sp/>3D<sp/>TDS.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T3::Vertex_handle<sp/>v3;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T2,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_vertex_3</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Vb</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::Cell_handle<sp/><sp/><sp/><sp/>Cell_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>TDS2&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Rebind_TDS<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vb::template<sp/>Rebind_TDS&lt;TDS2&gt;::Other<sp/><sp/>Vb2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>My_vertex_3&lt;T2,<sp/>Vb2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Other;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_3()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_vertex_3(Cell_handle<sp/>c)<sp/>:<sp/>Vb(c)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>store<sp/>a<sp/>vertex<sp/>handle<sp/>of<sp/>the<sp/>2D<sp/>TDS.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T2::Vertex_handle<sp/>v2;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>TDS_2<sp/>t2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>TDS_3<sp/>t3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>TDS_2::Vertex_handle<sp/>v2<sp/>=<sp/>t2.insert_dim_up();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>TDS_3::Vertex_handle<sp/>v3<sp/>=<sp/>t3.insert_increase_dimension();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v2-&gt;v3<sp/>=<sp/>v3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v3-&gt;v2<sp/>=<sp/>v2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(t2.is_valid());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(t3.is_valid());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="index_1TDS_3Design">
<title>Design and Implementation History</title>
<para>Monique Teillaud introduced the triangulation of the topological sphere <formula id="10">$ S^d$</formula> in <formula id="11">$ \mathbb{R}^{d+1}$</formula> to manage the underlying graph of geometric triangulations and handle degenerate dimensions <ref refid="citelist_1CITEREF_t-tdtc-99" kindref="member">[2]</ref>.</para><para>Sylvain Pion improved the software in several ways, in particular regarding the memory management.</para><para>In 2013, Cl√©ment Jamin added the ability to create/delete vertices and cells in parallel. This feature is used by the parallel triangulation. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
